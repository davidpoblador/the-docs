<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::DOM::Node: Super class of all nodes in xml::dom</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Super class of all nodes in xml::dom">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::DOM::Node (3pm) manual">
  <meta name="twitter:description" content="Super class of all nodes in xml::dom">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-dom-perl-XML::DOM::Node-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::DOM::Node.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::DOM::Node (3pm) manual" />
  <meta property="og:description" content="Super class of all nodes in xml::dom" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-dom-perl-XML::DOM::Node-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::DOM::Node<small> (3pm)</small></h1>
        <p class="lead">Super class of all nodes in xml::dom</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::DOM::Node.3pm.html">
      <span itemprop="name">XML::DOM::Node: Super class of all nodes in xml::dom</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-dom-perl/">
      <span itemprop="name">libxml-dom-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::DOM::Node.3pm.html">
      <span itemprop="name">XML::DOM::Node: Super class of all nodes in xml::dom</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>XML::DOM::Node is the super class of all nodes in an \s-1XML::DOM\s0 document. This means that all nodes that subclass XML::DOM::Node also inherit all the methods that XML::DOM::Node implements.</p><p><strong>&#92;$1</strong></p>
<dl class='dl-vertical'>
  <dt>
    @NodeNames
  </dt>
  <dd>
    <p>The variable @XML::DOM::Node::NodeNames maps the node type constants to strings. It is used by XML::DOM::Node::getNodeTypeName.</p>
  </dd>
  <dt>
    getNodeType
  </dt>
  <dd>
    <p>Return an integer indicating the node type. See \s-1XML::DOM\s0 constants.</p>
  </dd>
  <dt>
    getNodeName
  </dt>
  <dd>
    <p>Return a property or a hardcoded string, depending on the node type. Here are the corresponding functions or values:</p>
<pre>
 Attr                   getName
 AttDef                 getName
 AttlistDecl            getName
 CDATASection           "#cdata-section"
 Comment                "#comment"
 Document               "#document"
 DocumentType           getNodeName
 DocumentFragment       "#document-fragment"
 Element                getTagName
 ElementDecl            getName
 EntityReference        getEntityName
 Entity                 getNotationName
 Notation               getName
 ProcessingInstruction  getTarget
 Text                   "#text"
 XMLDecl                "#xml-declaration"
</pre>
<p><strong>Not In \s-1DOM\s0 Spec</strong>: AttDef, AttlistDecl, ElementDecl and XMLDecl were added for completeness.</p>
  </dd>
  <dt>
    getNodeValue and setNodeValue (value)
  </dt>
  <dd>
    <p>Returns a string or undef, depending on the node type. This method is provided for completeness. In other languages it saves the programmer an upcast. The value is either available thru some other method defined in the subclass, or else undef is returned. Here are the corresponding methods: Attr::getValue, Text::getData, CDATASection::getData, Comment::getData, ProcessingInstruction::getData.</p>
  </dd>
  <dt>
    getParentNode and setParentNode (parentNode)
  </dt>
  <dd>
    <p>The parent of this node. All nodes, except Document, DocumentFragment, and Attr may have a parent. However, if a node has just been created and not yet added to the tree, or if it has been removed from the tree, this is undef.</p>
  </dd>
  <dt>
    getChildNodes
  </dt>
  <dd>
    <p>A NodeList that contains all children of this node. If there are no children, this is a NodeList containing no nodes. The content of the returned NodeList is \*(L"live\*(R" in the sense that, for instance, changes to the children of the node object that it was created from are immediately reflected in the nodes returned by the NodeList accessors; it is not a static snapshot of the content of the node. This is true for every NodeList, including the ones returned by the getElementsByTagName method. \s-1NOTE:\s0 this implementation does not return a \*(L"live\*(R" NodeList for getElementsByTagName. See \s-1CAVEATS\s0. When this method is called in a list context, it returns a regular perl list containing the child nodes. Note that this list is not \*(L"live\*(R". E.g.  @list = $node-&gt;getChildNodes;        # returns a perl list  $nodelist = $node-&gt;getChildNodes;    # returns a NodeList (object reference)  for my $kid ($node-&gt;getChildNodes)   # iterate over the children of $node</p>
  </dd>
  <dt>
    getFirstChild
  </dt>
  <dd>
    <p>The first child of this node. If there is no such node, this returns undef.</p>
  </dd>
  <dt>
    getLastChild
  </dt>
  <dd>
    <p>The last child of this node. If there is no such node, this returns undef.</p>
  </dd>
  <dt>
    getPreviousSibling
  </dt>
  <dd>
    <p>The node immediately preceding this node. If there is no such node, this returns undef.</p>
  </dd>
  <dt>
    getNextSibling
  </dt>
  <dd>
    <p>The node immediately following this node. If there is no such node, this returns undef.</p>
  </dd>
  <dt>
    getAttributes
  </dt>
  <dd>
    <p>A NamedNodeMap containing the attributes (Attr nodes) of this node (if it is an Element) or undef otherwise. Note that adding/removing attributes from the returned object, also adds/removes attributes from the Element node that the NamedNodeMap came from.</p>
  </dd>
  <dt>
    getOwnerDocument
  </dt>
  <dd>
    <p>The Document object associated with this node. This is also the Document object used to create new nodes. When this node is a Document this is undef.</p>
  </dd>
  <dt>
    insertBefore (newChild, refChild)
  </dt>
  <dd>
    <p>Inserts the node newChild before the existing child node refChild. If refChild is undef, insert newChild at the end of the list of children. If newChild is a DocumentFragment object, all of its children are inserted, in the same order, before refChild. If the newChild is already in the tree, it is first removed. Return Value: The node being inserted. DOMExceptions:</p>
<dl class='dl-vertical'>
  <dt>
    * \s-1HIERARCHY_REQUEST_ERR\s0
  </dt>
  <dd>
    <p>Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to insert is one of this node's ancestors.</p>
  </dd>
  <dt>
    * \s-1WRONG_DOCUMENT_ERR\s0
  </dt>
  <dd>
    <p>Raised if newChild was created from a different document than the one that created this node.</p>
  </dd>
  <dt>
    * \s-1NO_MODIFICATION_ALLOWED_ERR\s0
  </dt>
  <dd>
    <p>Raised if this node is readonly.</p>
  </dd>
  <dt>
    * \s-1NOT_FOUND_ERR\s0
  </dt>
  <dd>
    <p>Raised if refChild is not a child of this node.</p>
  </dd>

</dl>

  </dd>
  <dt>
    replaceChild (newChild, oldChild)
  </dt>
  <dd>
    <p>Replaces the child node oldChild with newChild in the list of children, and returns the oldChild node. If the newChild is already in the tree, it is first removed. Return Value: The node replaced. DOMExceptions:</p>
<dl class='dl-vertical'>
  <dt>
    * \s-1HIERARCHY_REQUEST_ERR\s0
  </dt>
  <dd>
    <p>Raised if this node is of a type that does not allow children of the type of the newChild node, or it the node to put in is one of this node's ancestors.</p>
  </dd>
  <dt>
    * \s-1WRONG_DOCUMENT_ERR\s0
  </dt>
  <dd>
    <p>Raised if newChild was created from a different document than the one that created this node.</p>
  </dd>
  <dt>
    * \s-1NO_MODIFICATION_ALLOWED_ERR\s0
  </dt>
  <dd>
    <p>Raised if this node is readonly.</p>
  </dd>
  <dt>
    * \s-1NOT_FOUND_ERR\s0
  </dt>
  <dd>
    <p>Raised if oldChild is not a child of this node.</p>
  </dd>

</dl>

  </dd>
  <dt>
    removeChild (oldChild)
  </dt>
  <dd>
    <p>Removes the child node indicated by oldChild from the list of children, and returns it. Return Value: The node removed. DOMExceptions:</p>
<dl class='dl-vertical'>
  <dt>
    * \s-1NO_MODIFICATION_ALLOWED_ERR\s0
  </dt>
  <dd>
    <p>Raised if this node is readonly.</p>
  </dd>
  <dt>
    * \s-1NOT_FOUND_ERR\s0
  </dt>
  <dd>
    <p>Raised if oldChild is not a child of this node.</p>
  </dd>

</dl>

  </dd>
  <dt>
    appendChild (newChild)
  </dt>
  <dd>
    <p>Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed. If it is a DocumentFragment object, the entire contents of the document fragment are moved into the child list of this node Return Value: The node added. DOMExceptions:</p>
<dl class='dl-vertical'>
  <dt>
    * \s-1HIERARCHY_REQUEST_ERR\s0
  </dt>
  <dd>
    <p>Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to append is one of this node's ancestors.</p>
  </dd>
  <dt>
    * \s-1WRONG_DOCUMENT_ERR\s0
  </dt>
  <dd>
    <p>Raised if newChild was created from a different document than the one that created this node.</p>
  </dd>
  <dt>
    * \s-1NO_MODIFICATION_ALLOWED_ERR\s0
  </dt>
  <dd>
    <p>Raised if this node is readonly.</p>
  </dd>

</dl>

  </dd>
  <dt>
    hasChildNodes
  </dt>
  <dd>
    <p>This is a convenience method to allow easy determination of whether a node has any children. Return Value: 1 if the node has any children, 0 otherwise.</p>
  </dd>
  <dt>
    cloneNode (deep)
  </dt>
  <dd>
    <p>Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes. The duplicate node has no parent (parentNode returns undef.). Cloning an Element copies all attributes and their values, including those generated by the \s-1XML\s0 processor to represent defaulted attributes, but this method does not copy any text it contains unless it is a deep clone, since the text is contained in a child Text node. Cloning any other type of node simply returns a copy of this node. Parameters:  <em>deep</em>   If true, recursively clone the subtree under the specified node. If false, clone only the node itself (and its attributes, if it is an Element). Return Value: The duplicate node.</p>
  </dd>
  <dt>
    normalize
  </dt>
  <dd>
    <p>Puts all Text nodes in the full depth of the sub-tree underneath this Element into a \*(L"normal\*(R" form where only markup (e.g., tags, comments, processing instructions, \s-1CDATA\s0 sections, and entity references) separates Text nodes, i.e., there are no adjacent Text nodes. This can be used to ensure that the \s-1DOM\s0 view of a document is the same as if it were saved and re-loaded, and is useful when operations (such as XPointer lookups) that depend on a particular document tree structure are to be used. <strong>Not In \s-1DOM\s0 Spec</strong>: In the \s-1DOM\s0 Spec this method is defined in the Element and Document class interfaces only, but it doesn't hurt to have it here...</p>
  </dd>
  <dt>
    getElementsByTagName (name [, recurse])
  </dt>
  <dd>
    <p>Returns a NodeList of all descendant elements with a given tag name, in the order in which they would be encountered in a preorder traversal of the Element tree. Parameters:  <em>name</em>  The name of the tag to match on. The special value \*(L"*\*(R" matches all tags.  <em>recurse</em>  Whether it should return only direct child nodes (0) or any descendant that matches the tag name (1). This argument is optional and defaults to 1. It is not part of the \s-1DOM\s0 spec. Return Value: A list of matching Element nodes. \s-1NOTE:\s0 this implementation does not return a \*(L"live\*(R" NodeList for getElementsByTagName. See \s-1CAVEATS\s0. When this method is called in a list context, it returns a regular perl list containing the result nodes. E.g.  @list = $node-&gt;getElementsByTagName("tag");       # returns a perl list  $nodelist = $node-&gt;getElementsByTagName("tag");   # returns a NodeList (object ref.)  for my $elem ($node-&gt;getElementsByTagName("tag")) # iterate over the result nodes</p>
  </dd>
  <dt>
    getNodeTypeName
  </dt>
  <dd>
    <p>Return the string describing the node type. E.g. returns \*(L"\s-1ELEMENT_NODE\s0\*(R" if getNodeType returns \s-1ELEMENT_NODE\s0. It uses @XML::DOM::Node::NodeNames.</p>
  </dd>
  <dt>
    toString
  </dt>
  <dd>
    <p>Returns the entire subtree as a string.</p>
  </dd>
  <dt>
    printToFile (filename)
  </dt>
  <dd>
    <p>Prints the entire subtree to the file with the specified filename. Croaks: if the file could not be opened for writing.</p>
  </dd>
  <dt>
    printToFileHandle (handle)
  </dt>
  <dd>
    <p>Prints the entire subtree to the file handle. E.g. to print to \s-1STDOUT:\s0  $node-&gt;printToFileHandle (&#92;*STDOUT);</p>
  </dd>
  <dt>
    print (obj)
  </dt>
  <dd>
    <p>Prints the entire subtree using the object's print method. E.g to print to a FileHandle object:  $f = new FileHandle ("file.out", "w");  $node-&gt;print ($f);</p>
  </dd>
  <dt>
    getChildIndex (child)
  </dt>
  <dd>
    <p>Returns the index of the child node in the list returned by getChildNodes. Return Value: the index or -1 if the node is not found.</p>
  </dd>
  <dt>
    getChildAtIndex (index)
  </dt>
  <dd>
    <p>Returns the child node at the specifed index or undef.</p>
  </dd>
  <dt>
    addText (text)
  </dt>
  <dd>
    <p>Appends the specified string to the last child if it is a Text node, or else appends a new Text node (with the specified text.) Return Value: the last child if it was a Text node or else the new Text node.</p>
  </dd>
  <dt>
    dispose
  </dt>
  <dd>
    <p>Removes all circular references in this node and its descendants so the objects can be claimed for garbage collection. The objects should not be used afterwards.</p>
  </dd>
  <dt>
    setOwnerDocument (doc)
  </dt>
  <dd>
    <p>Sets the ownerDocument property of this node and all its children (and attributes etc.) to the specified document. This allows the user to cut and paste document subtrees between different XML::DOM::Documents. The node should be removed from the original document first, before calling setOwnerDocument. This method does nothing when called on a Document node.</p>
  </dd>
  <dt>
    isAncestor (parent)
  </dt>
  <dd>
    <p>Returns 1 if parent is an ancestor of this node or if it is this node itself.</p>
  </dd>
  <dt>
    expandEntityRefs (str)
  </dt>
  <dd>
    <p>Expands all the entity references in the string and returns the result. The entity references can be character references (e.g. \*(L"&#123;\*(R" or \*(L"&#x1fc2\*(R"), default entity references (\*(L"&quot;\*(R", \*(L"&gt;\*(R", \*(L"&lt;\*(R", \*(L"&apos;\*(R" and \*(L"&amp;\*(R") or entity references defined in Entity objects as part of the DocumentType of the owning Document. Character references are expanded into \s-1UTF-8\s0. Parameter entity references (e.g. %ent;) are not expanded. E.g.  $node-&gt;to_sax (DocumentHandler =&gt; $my_handler,                 Handler =&gt; $handler2 ); %HANDLERS may contain the following handlers:</p>
<dl class='dl-vertical'>
  <dt>
    * DocumentHandler
  </dt>
  <dd>
    
  </dd>
  <dt>
    * DTDHandler
  </dt>
  <dd>
    
  </dd>
  <dt>
    * EntityResolver
  </dt>
  <dd>
    
  </dd>
  <dt>
    * Handler
  </dt>
  <dd>
    <p>Default handler when one of the above is not specified</p>
  </dd>

</dl>
<p>Each XML::DOM::Node generates the appropriate \s-1SAX\s0 callbacks (for the appropriate \s-1SAX\s0 handler.) Different \s-1SAX\s0 handlers can be plugged in to accomplish different things, e.g. XML::Checker would check the node (currently only Document and Element nodes are supported), XML::Handler::BuildDOM would create a new \s-1DOM\s0 subtree (thereby, in essence, copying the Node) and in the near future, XML::Writer could print the node. All Perl \s-1SAX\s0 related work is still in flux, so this interface may change a little. See PerlSAX for the description of the \s-1SAX\s0 interface.</p>
  </dd>
  <dt>
    check ( [$checker] )
  </dt>
  <dd>
    <p>See descriptions for <em>check()</em> in XML::DOM::Document and XML::DOM::Element. To use the xql method, you must first <em>use</em> \s-1XML::XQL\s0 and \s-1XML::XQL::DOM\s0. This method is basically a shortcut for:  $query = new XML::XQL::Query ( @XQL_OPTIONS );  return $query-&gt;solve ($node); If the first parameter in @XQL_OPTIONS is the \s-1XQL\s0 expression, you can leave off the 'Expr' keyword, so:  $node-&gt;xql ("doc//elem1[@attr]", @other_options); is identical to:  $node-&gt;xql (Expr =&gt; "doc//elem1[@attr]", @other_options); See XML::XQL::Query for other available \s-1XQL_OPTIONS\s0. See \s-1XML::XQL\s0 and XML::XQL::Tutorial for more info.</p>
  </dd>
  <dt>
    isHidden ()
  </dt>
  <dd>
    <p>Whether the node is hidden. See Hidden Nodes for details.</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::DOM::NamedNodeMap.3pm.html"><span aria-hidden="true">&larr;</span> XML::DOM::NamedNodeMap.3pm: A hash table interface for xml::dom</a></li>
   <li class="next"><a href="XML::DOM::NodeList.3pm.html">XML::DOM::NodeList.3pm: A node list as used by xml::dom <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

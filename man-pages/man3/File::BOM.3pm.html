<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>File::BOM: Utilities for handling byte order marks</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Utilities for handling byte order marks">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="File::BOM (3pm) manual">
  <meta name="twitter:description" content="Utilities for handling byte order marks">
  <meta name="twitter:image" content="https://www.carta.tech/images/libfile-bom-perl-File::BOM-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/File::BOM.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="File::BOM (3pm) manual" />
  <meta property="og:description" content="Utilities for handling byte order marks" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libfile-bom-perl-File::BOM-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">File::BOM<small> (3pm)</small></h1>
        <p class="lead">Utilities for handling byte order marks</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/File::BOM.3pm.html">
      <span itemprop="name">File::BOM: Utilities for handling byte order marks</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libfile-bom-perl/">
      <span itemprop="name">libfile-bom-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/File::BOM.3pm.html">
      <span itemprop="name">File::BOM: Utilities for handling byte order marks</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use File::BOM qw( :all )
</pre>
<h3>high-level functions</h3>
<p>    # read a file with encoding from the BOM:     open_bom(FH, $file)     open_bom(FH, $file, &apos;:utf8&apos;) # the same but with a default encoding</p><p>    # get encoding too     $encoding = open_bom(FH, $file, &apos;:utf8&apos;);</p><p>    # open a potentially unseekable file:     ($encoding, $spillage) = open_bom(FH, $file, &apos;:utf8&apos;);</p><p>    # change encoding of an open handle according to BOM     $encoding = defuse(*HANDLE);     ($encoding, $spillage) = defuse(*HANDLE);</p><p>    # Decode a string according to leading BOM:     $unicode = decode_from_bom($string_with_bom);</p><p>    # Decode a string and get the encoding:     ($unicode, $encoding) = decode_from_bom($string_with_bom)</p>
<h3>PerlIO::via interface</h3>
<p>    # Read the Right Thing from a unicode file with BOM:     open(HANDLE, &apos;&lt;:via(File::BOM)&apos;, $filename)</p><p>    # Writing little-endian UTF-16 file with BOM:     open(HANDLE, &apos;&gt;:encoding(UTF-16LE):via(File::BOM)&apos;, $filename)</p>
<h3>lower-level functions</h3>
<p>    # read BOM encoding from a filehandle:     $encoding = get_encoding_from_filehandle(FH)</p><p>    # Get encoding even if FH is unseekable:     ($encoding, $spillage) = get_encoding_from_filehandle(FH);</p><p>    # Get encoding from a known unseekable handle:     ($encdoing, $spillage) = get_encoding_from_stream(FH);</p><p>    # get encoding and BOM length from BOM at start of string:     ($encoding, $offset) = get_encoding_from_bom($string);</p>
<h3>variables</h3>
<p>    # print a BOM for a known encoding     print FH $enc2bom{$encoding};</p><p>    # get an encoding from a known BOM     $enc = $bom2enc{$bom}</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides functions for handling unicode byte order marks, which are to be found at the beginning of some files and streams.</p><p>For details about what a byte order mark is, see &lt;http://www.unicode.org/unicode/faq/utf_bom.html#BOM&gt;</p><p>The intention of File::BOM is for files with BOMs to be readable as seamlessly as possible, regardless of the encoding used. To that end, several different interfaces are available, as shown in the synopsis above.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p>Nothing by default.</p><h3>symbols</h3>
<ul>
<li><p><em>open_bom()</em></p></li><li><p><em>defuse()</em></p></li><li><p><em>decode_from_bom()</em></p></li><li><p><em>get_encoding_from_filehandle()</em></p></li><li><p><em>get_encoding_from_stream()</em></p></li><li><p><em>get_encoding_from_bom()</em></p></li><li><p>%bom2enc</p></li><li><p>%enc2bom</p></li>
</ul>
<h3>tags</h3>
<ul>
<li><p>:all All of the above</p></li><li><p>:subs subroutines only</p></li><li><p>:vars just %bom2enc and %enc2bom</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VARIABLES</h2>
        <div class="sectioncontent">
<p>Maps Byte Order marks to their encodings.</p><p>The keys of this hash are strings which represent the BOMs, the values are their encodings, in a format which is understood by Encode</p><p>The encodings represented in this hash are: \s-1UTF-8\s0, \s-1UTF-16BE\s0, \s-1UTF-16LE\s0, \s-1UTF-32BE\s0 and \s-1UTF-32LE\s0 A reverse-lookup hash for bom2enc, with a few aliases used in Encode, namely utf8, iso-10646-1 and \s-1UCS-2\s0.</p><p>Note that \s-1UTF-16\s0, \s-1UTF-32\s0 and \s-1UCS-4\s0 are not included in this hash. Mainly because Encode::encode automatically puts BOMs on output. See Encode::Unicode</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<h3>open_bom</h3>
<p>    $encoding = open_bom(HANDLE, $filename, $default_mode)</p><p>    ($encoding, $spill) = open_bom(HANDLE, $filename, $default_mode)</p><p>opens \s-1HANDLE\s0 for reading on $filename, setting the mode to the appropriate encoding for the \s-1BOM\s0 stored in the file.</p><p>On failure, a fatal error is raised, see the \s-1DIAGNOSTICS\s0 section for details on how to catch these. This is in order to allow the return value(s) to be used for other purposes.</p><p>If the file doesn't contain a \s-1BOM\s0, $default_mode is used instead. Hence:</p><p>    open_bom(FH, &apos;my_file.txt&apos;, &apos;:utf8&apos;)</p><p>Opens my_file.txt for reading in an appropriate encoding found from the \s-1BOM\s0 in that file, or as a \s-1UTF-8\s0 file if none is found.</p><p>In the absense of a $default_mode argument, the following 2 calls should be equivalent:</p><p>    open_bom(FH, &apos;no_bom.txt&apos;);</p><p>    open(FH, &apos;&lt;&apos;, &apos;no_bom.txt&apos;);</p><p>If an undefined value is passed as the handle, a symbol will be generated for it like <em>open()</em> does:</p><p>    # create filehandle on the fly     $enc = open_bom(my $fh, $filename, &apos;:utf8&apos;);     $line = &lt;$fh&gt;;</p><p>The filehandle will be cued up to read after the \s-1BOM\s0. Unseekable files (e.g. fifos) will cause croaking, unless called in list context to catch spillage from the handle. Any spillage will be automatically decoded from the encoding, if found.</p><p>    e.g.</p><p>    # croak if my_socket is unseekable     open_bom(FH, &apos;my_socket&apos;);</p><p>    # keep spillage if my_socket is unseekable     ($encoding, $spillage) = open_bom(FH, &apos;my_socket&apos;);</p><p>    # discard any spillage from open_bom     ($encoding) = open_bom(FH, &apos;my_socket&apos;);</p>
<h3>defuse</h3>
<p>    $enc = defuse(FH);</p><p>    ($enc, $spill) = defuse(FH);</p><p>\s-1FH\s0 should be a filehandle opened for reading, it will have the relevant encoding layer pushed onto it be binmode if a \s-1BOM\s0 is found. Spillage should be Unicode, not bytes.</p><p>Any uncaptured spillage will be silently lost. If the handle is unseekable, use list context to avoid data loss.</p><p>If no \s-1BOM\s0 is found, the mode will be unaffected.</p>
<h3>decode_from_bom</h3>
<p>    $unicode_string = decode_from_bom($string, $default, $check)</p><p>    ($unicode_string, $encoding) = decode_from_bom($string, $default, $check)</p><p>Reads a \s-1BOM\s0 from the beginning of $string, decodes $string (minus the \s-1BOM\s0) and returns it to you as a perl unicode string.</p><p>if $string doesn't have a \s-1BOM\s0, $default is used instead.</p><p>$check, if supplied, is passed to Encode::decode as the third argument.</p><p>If there's no \s-1BOM\s0 and no default, the original string is returned and encoding is ''.</p><p>See Encode</p>
<h3>get_encoding_from_filehandle</h3>
<p>    $encoding = get_encoding_from_filehandle(HANDLE)</p><p>    ($encoding, $spillage) = get_encoding_from_filehandle(HANDLE)</p><p>Returns the encoding found in the given filehandle.</p><p>The handle should be opened in a non-unicode way (e.g. mode '&lt;:bytes') so that the \s-1BOM\s0 can be read in its natural state.</p><p>After calling, the handle will be set to read at a point after the \s-1BOM\s0 (or at the beginning of the file if no \s-1BOM\s0 was found)</p><p>If called in scalar context, unseekable handles cause a <em>croak()</em>.</p><p>If called in list context, unseekable handles will be read byte-by-byte and any spillage will be returned. See <em>get_encoding_from_stream()</em></p>
<h3>get_encoding_from_stream</h3>
<p>    ($encoding, $spillage) = get_encoding_from_stream(*FH);</p><p>Read a \s-1BOM\s0 from an unrewindable source. This means reading the stream one byte at a time until either a \s-1BOM\s0 is found or every possible \s-1BOM\s0 is ruled out. Any non-BOM bytes read from the handle will be returned in $spillage.</p><p>If a \s-1BOM\s0 is found and the spillage contains a partial character (judging by the expected character width for the encoding) more bytes will be read from the handle to ensure that a complete character is returned.</p><p>Spillage is always in bytes, not characters.</p><p>This function is less efficient than get_encoding_from_filehandle, but should work just as well on a seekable handle as on an unseekable one.</p>
<h3>get_encoding_from_bom</h3>
<p>    ($encoding, $offset) = get_encoding_from_bom($string)</p><p>Returns the encoding and length in bytes of the \s-1BOM\s0 in $string.</p><p>If there is no \s-1BOM\s0, an empty string is returned and $offset is zero.</p><p>To get the data from the string, the following should work:</p><p>    use Encode;</p><p>    my($encoding, $offset) = get_encoding_from_bom($string);</p><p>    if ($encoding) {         $string = decode($encoding, substr($string, $offset))     }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PerlIO::via interface</h2>
        <div class="sectioncontent">
<p>File::BOM can be used as a PerlIO::via interface.</p><p>    open(HANDLE, &apos;&lt;:via(File::BOM)&apos;, &apos;my_file.txt&apos;);</p><p>    open(HANDLE, &apos;&gt;:encoding(UTF-16LE):via(File::BOM)&apos;, &apos;out_file.txt)     print "foo&#92;n"; # BOM is written to file here</p><p>This method is less prone to errors on non-seekable files as spillage is incorporated into an internal buffer, but it doesn't give you any information about the encoding being used, or indeed whether or not a \s-1BOM\s0 was present.</p><p>There are a few known problems with this interface, especially surrounding <em>seek()</em> and <em>tell()</em>, please see the \s-1BUGS\s0 section for more details about this.</p><h3>Reading</h3>
<p>The via(File::BOM) layer must be added before the handle is read from, otherwise any \s-1BOM\s0 will be missed. If there is no \s-1BOM\s0, no decoding will be done.</p><p>Because of a limitation in PerlIO::via, <em>read()</em> always works on bytes, not characters. \s-1BOM\s0 decoding will still be done but output will be bytes of \s-1UTF-8\s0.</p><p>    open(BOM, &apos;&lt;:via(File::BOM)&apos;, $file)     $bytes_read = read(BOM, $buffer, $length);     $unicode = decode(&apos;UTF-8&apos;, $buffer, Encode::FB_QUIET);</p><p>    # Now $unicode is valid unicode and $buffer contains any left-over bytes</p>
<h3>Writing</h3>
<p>Add the via(File::BOM) layer on top of a unicode encoding layer to print a \s-1BOM\s0 at the start of the output file. This needs to be done before any data is written. The \s-1BOM\s0 is written as part of the first print command on the handle, so if you don't print anything to the handle, you won't get a \s-1BOM\s0.</p><p>There is a \*(L"Wide character in print\*(R" warning generated when the via(File::BOM) layer doesn't receive utf8 on writing. This glitch was resolved in perl version 5.8.7, but if your perl version is older than that, you'll need to make sure that the via(File::BOM) layer receives utf8 like this:</p><p>    # This works OK     open(FH, &apos;&gt;:encoding(UTF-16LE):via(File::BOM):utf8&apos;, $filename)</p><p>    # This generates warnings with older perls     open(FH, &apos;&gt;:encoding(UTF-16LE):via(File::BOM)&apos;, $filename)</p>
<h3>Seeking</h3>
<p>Seeking with \s-1SEEK_SET\s0 results in an offset equal to the length of any detected \s-1BOM\s0 being applied to the position parameter. Thus:</p><p>    # Seek to end of BOM (not start of file!)     seek(FILE_BOM_HANDLE, 0, SEEK_SET)</p>
<h3>Telling</h3>
<p>In order to work correctly with <em>seek()</em>, <em>tell()</em> also returns a postion adjusted by the length of the \s-1BOM\s0.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO File::BOM&hellip;</h2>
        <div class="sectioncontent">
<ul>
<li><p>Encode</p></li><li><p>Encode::Unicode</p></li><li><p>&lt;http://www.unicode.org/unicode/faq/utf_bom.html#BOM&gt;</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>The following exceptions are raised via <em>croak()</em></p><ul>
<li><p>Couldn't read '&lt;filename&gt;': $! <em>open_bom()</em> couldn't open the given file for reading</p></li><li><p>Couldn't set binmode of handle opened on '&lt;filename&gt;' to '&lt;mode&gt;': $! <em>open_bom()</em> couldn't set the binmode of the handle</p></li><li><p>No string decode_from_bom called on an undefined value</p></li><li><p>Unseekable handle: $! <em>get_encoding_from_filehandle()</em> or <em>open_bom()</em> called on an unseekable file or handle in scalar context.</p></li><li><p>Couldn't read from handle: $! <em>_get_encoding_seekable()</em> couldn't read the handle. This function is called from <em>get_encoding_from_filehandle()</em>, <em>defuse()</em> and <em>open_bom()</em></p></li><li><p>Couldn't reset read position: $! _get_encoding_seekable couldn't seek to the position after the \s-1BOM\s0.</p></li><li><p>Couldn't read byte: $! get_encoding_from_stream couldn't read from the handle. This function is called from <em>get_encoding_from_filehandle()</em> and <em>open_bom()</em> when the handle or file is unseekable.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Older versions of PerlIO::via have a few problems with writing, see above.</p><p>The current version of PerlIO::via has limitations with regard to seek and tell, currently only line-wise seek and tell are supported by this module. If <em>read()</em> is used to read partial lines, <em>tell()</em> will still give the position of the end of the last line read.</p><p>Under windows, <em>tell()</em> seems to return erroneously when reading files with unix line endings.</p><p>Under windows, warnings may be generated when using the PerlIO::via interface to read \s-1UTF-16LE\s0 and \s-1UTF-32LE\s0 encoded files. This seems to be a bug in the relevant encoding(...) layers.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Matt Lawrence &lt;mattlaw@cpan.org&gt;</p><p>With thanks to Mark Fowler and Steve Purkis for additional tests and advice.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2005 Matt Lawrence, All Rights Reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Fennec::Lite.3pm.html"><span aria-hidden="true">&larr;</span> Fennec::Lite.3pm: Minimalist fennec, the commonly used bits.</a></li>
   <li class="next"><a href="File::BaseDir.3pm.html">File::BaseDir.3pm: Use the freedesktop.org base directory specification <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Aspect::Library::Listenable: Observer pattern with events</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Observer pattern with events">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Aspect::Library::Listenable (3pm) manual">
  <meta name="twitter:description" content="Observer pattern with events">
  <meta name="twitter:image" content="https://www.carta.tech/images/libaspect-perl-Aspect::Library::Listenable-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Aspect::Library::Listenable.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Aspect::Library::Listenable (3pm) manual" />
  <meta property="og:description" content="Observer pattern with events" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libaspect-perl-Aspect::Library::Listenable-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Aspect::Library::Listenable<small> (3pm)</small></h1>
        <p class="lead">Observer pattern with events</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Aspect::Library::Listenable.3pm.html">
      <span itemprop="name">Aspect::Library::Listenable: Observer pattern with events</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libaspect-perl/">
      <span itemprop="name">libaspect-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Aspect::Library::Listenable.3pm.html">
      <span itemprop="name">Aspect::Library::Listenable: Observer pattern with events</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  # The class that we will make listenable
  package Point;

  sub new {
     bless { color =&gt; &apos;blue&apos; }, shift;
  }

  sub erase {
      print &apos;erased!&apos;;
  }

  sub get_color {
      $_[0]-&gt;{color};
  }

  sub set_color {
      $_[0]-&gt;{color} = $_[1];
  }

  package main;

  use Aspect;
  use Aspect::Library::Listenable;

  # Setup the simplest listenable relationship: a signal

  # Define the aspect for the listenable relationship
  aspect Listenable =&gt; ( Erase =&gt; call &apos;Point::erase&apos; );

  # Now add a listener
  my $erase_listener = sub { print shift-&gt;as_string };
  add_listener $point, Erase =&gt; $erase_listener;

  my $point = Point-&gt;new;
  $point-&gt;erase;
  # prints: "erased! name:Erase, source:Point"

  remove_listener $point, Erase =&gt; $erase_listener;
  $point-&gt;erase;
  # prints: "erased!"

  # A more complex relationship: listeners get old and new color values
  # and will only be notified if these values are not equal
  aspect Listenable =&gt;
     (Color =&gt; call &apos;Point::set_color&apos;, color =&gt; &apos;get_color&apos;);

  add_listener $point, Color =&gt;
     my $color_listener = sub { print shift-&gt;as_string };

  $point-&gt;set_color(&apos;red&apos;);
  # prints: "name:Color, source:Point, color:red, old_color:blue, params:red"

  $point-&gt;set_color(&apos;red&apos;); # does not print anything, color unchanged

  remove_listener $point, Color =&gt; $color_listener;

  # listeners can be callback, as above, or they can be objects

  package ColorListener;
  sub new { bless {}, shift }
  sub handle_event_Color { print "new color: ". shift-&gt;color };
  package main;

  add_listener $point, Color =&gt; my $object_listener = ColorListener-&gt;new;
  $point-&gt;set_color(&apos;green&apos;);
  # prints: "new color: green"
  remove_listener $point, Color =&gt; $object_listener;


  # listeners can also be specific methods on objects

  package EraseListener;
  sub new { bless {}, shift }
  sub my_erase_handler { print &apos;heard an erase event!&apos; }
  package main;

  add_listener $point, Color =&gt;
     [my_erase_handler =&gt; my $method_listener = EraseListener-&gt;new]
  $point-&gt;erase;
  # prints: "heard an erase event!"
  remove_listener $point, Color =&gt; $method_listener;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A reusable aspect for implementing the Listenable design pattern. It lets you to define listenables and the events they fire. Then you can add/remove listeners to these listenables. When specific methods of the listenable are called, registered listeners will be notified.</p><p>Some examples of use are:</p><ul>
<li><p>A timer that allows registration of listeners. They will receive events when the timer fires.</p></li><li><p>In an \s-1MVC\s0 application, as a mechanism for registering views as listeners of models. Then when models change, views receive events, which they handle by updating the display. Several views can be set as listeners for any event of any model.</p></li>
</ul><p>The Listenable pattern is a variation of the basic Observer pattern:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Listeners can be attached to specific events fired by a listenable. Listenables can fire several types of events. In the basic Observer pattern, observers are attached to entire observables.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Listeners receive an event as their only parameter. From this event, they can get its name, source, old/new states of the listenable, and any parameters that were sent to the listenable method that fired the event.</p>
  </dd>

</dl>
<p>Because it is implemented using aspects, there is no change required to the listenable or listener classes. For example, you are not required to fire events after performing interesting state changes in the listenable. The aspect will do this for you.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USING</h2>
        <div class="sectioncontent">
<p>Creating listenable relationships between objects is done in two steps. First you must define the relationship between the <em>classes</em>, then you can instantiate the defined relationship between <em>instances</em> of these classes.</p><h3>\s-1DEFINING\s0</h3>
<p>Defining the relationships between classes is done once per program run. This is similar to how methods and classes are defined only once.</p><p>Each listenable relationship between classes is defined by one aspect, answering 3 questions:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>What is the name of the event being fired?</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>What methods on what listenable objects cause events to be fired?</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>What data will be present in the event object, so that listeners can gather information about the change to the listenable that caused the event to fire? This is optional. The event could carry no data at all, except its name and source.</p>
  </dd>

</dl>
<p>You create a listenable aspect so:</p><p>  aspect Listenable =&gt; (EVENT_NAME =&gt; POINTCUT, EVENT_DATA)</p><p>The \*(C`EVENT_DATA\*(C' part is optional. The three parameters are your answers to the questions above:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1EVENT_NAME\s0
  </dt>
  <dd>
    <p>The string event name. A listenable can participate in several listenable aspects, each with a different event name. Another way to describe it, is that a listenable can fire several types of events.</p>
  </dd>
  <dt>
    \s-1POINTCUT\s0
  </dt>
  <dd>
    <p>A pointcut object (Aspect::Pointcut) that selects \*(L"hot\*(R" methods. After these methods are run, an event will be fired.</p>
  </dd>
  <dt>
    \s-1EVENT_DATA\s0
  </dt>
  <dd>
    <p>Optional hash of keys and values you want to add to the event before it is fired. They key is the string name of the property that will be given to the event, and the value is a string name of a method, on the listenable, that will be called to get the property value. The getter method on the listenable must exist for this to work. If you set \*(C`EVENT_DATA\*(C', then change checking will be performed before firing. The event will only be fired, if the event data has changed. If there is no \*(C`EVENT_DATA\*(C', the event will always be fired. The \*(C`EVENT_DATA\*(C' feature is useful for providing listeners with more information about the event. Example: when listening to a selection widget, it may by used for informing listeners of the item selected.</p>
  </dd>

</dl>
<p>Here is an example of transforming a selector widget, so that it will fire an event, right after it has received a click from the user. Listeners can get the selected index from the event they receive:</p><p>  aspect Listenable =&gt; (      ItemSelected   =&gt; call &apos;SelectorWidget::click&apos;,      selected_index =&gt; &apos;selected_index&apos;,   );</p><p>This assumes that there exists a method \*(C`SelectorWidget::selected_index\*(C', that will return the currently selected item, and a method \*(C`click\*(C', called whenever the user clicks the widget. The event will only be fired if the \*(C`selected_index\*(C' has changed.</p><p>Because the aspect should be created only <em>Once</em> during a program run, for each listenable relationship type, there are several options for choosing the place to actually create it:</p><ul>
<li><p>In the listenable, outside any methods or in some static initializer</p></li><li><p>In the top level program unit</p></li><li><p>In a Facade over some framework</p></li><li><p>In a new class you create, which must be used by the code adding/removing listeners</p></li>
</ul><p>Now all that is needed is some way to add and remove listener objects, from a specific listenable, so that the event will actually be handled by someone, and not just fired into the void.</p>
<h3>\s-1ADDING\s0 \s-1AND\s0 \s-1REMOVING\s0 \s-1LISTENERS\s0</h3>
<p>The simplest listener is a \*(C`CODE\*(C' ref. It can added and removed so:</p><p>  use Aspect::Library::Listenable;   my $code = sub { print "event!" }   add_listener $point, Color =&gt; $code;    # add   $point-&gt;set_color(&apos;red&apos;);               # $code will be run   remove_listener $point, Color =&gt; $code; # remove   $point-&gt;set_color(&apos;yellow&apos;);            # event will not fire</p><p>The event object is the only parameter received by the callback.</p><p>The other two types of listeners are <em>object</em>, and <em>method</em>:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Object - the method \*(C`handle_event_EVENT_NAME\*(C' will be called.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Array ref with two elements- scalar method name and listener object.</p>
  </dd>

</dl>
<p>When the listener is an object , the method name to be called is computed from the event name by adding \*(C`handle_event_\*(C' in front of the event name. For example: a car object will call the method \*(C`handle_event_FrontLeftDoorOpened\*(C' on its listeners that are objects.</p><p>When the listener is an array ref (method listener), the method name (1st element) is called on the object (2nd element). When removing this type of listener, you do not remove the array ref but the listener object, i.e. exactly like you remove an object listener.</p><p>For method listeners, you can also change the parameter list of the method. Usually, the event is the only parameter to the listener method. By changing the parameter list, you can turn any existing method into a listener method, without changing it.</p><p>You change the parameter list, by providing a list of event properties, whose values will become the new parameter list. Here is how to make a \*(C`Family::set_father_name\*(C' run each time \*(C`Person::set_name\*(C' is called on the father object:</p><p>  aspect Listenable =&gt; (      NameChange =&gt; call &apos;Person::set_name&apos;,      name =&gt; &apos;name&apos;,   );</p><p>  $father = Person-&gt;new;   $family = Family-&gt;new;</p><p>  add_listener $father, NameChange =&gt;      [set_father_name =&gt; $family, [qw(name)]];</p><p>  $father-&gt;set_name(&apos;dan&apos;); # $family-&gt;set_father_name(&apos;dan&apos;) will be called</p>
<h3>\s-1HANDLING\s0 \s-1EVENTS\s0</h3>
<p>Listener code is called with one parameter: the event. Its class is \*(C`Aspect::Listenable::Event\*(C'. All events have at least these properties: The name of the event as defined in the aspect. The listenable object. The event was fired because a method was called. In this property you will find an array ref of the parameters sent to that method.</p><p>Besides these properties, you can also access any properties that were defined to be in the event state, when the listenable aspect was created. For each such property, there is another, with \*(C`old_\*(C' prefixed, which holds the value of the property on the listenable, <em>before</em> the event was fired.</p><p>You access properties on the event using getters. To get the new color of a point after a \*(C`Color\*(C' event:</p><p>  sub handle_event_Color {      my $event = shift;      print $event-&gt;color;   }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<ul>
<li><p>Only works with hash based objects. May use \*(C`Scalar-Footnote\*(C' in the future to get around this, or try to keep listeners in the aspect, not the listenable.</p></li><li><p>Supports removing listeners, but not aspects. Aspects will be removed and event will stop firing, but listeners will not be cleaned up from listenables. Setup your aspect only once per relationship type, and call \*(C`aspect Listenable...\*(C' in a void context.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Aspect::Library::Listenable&hellip;</h2>
        <div class="sectioncontent">
<p>\*(C`Class::Listener\*(C', \*(C`Class::Observable\*(C'. Both are object-oriented solutions to the same problem. Both force you to change the listenable class, by adding the code to fire events inside your \*(L"hot\*(R" methods.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Adam Kennedy &lt;adamk@cpan.org&gt;</p><p>Marcel Gru\*:nauer &lt;marcel@cpan.org&gt;</p><p>Ran Eilam &lt;eilara@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2001 by Marcel Gru\*:nauer</p><p>Some parts copyright 2009 - 2013 Adam Kennedy.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Aspect::Library::Breakpoint.3pm.html"><span aria-hidden="true">&larr;</span> Aspect::Library::Breakpoint.3pm: A breakpoint aspect</a></li>
   <li class="next"><a href="Aspect::Library::Singleton.3pm.html">Aspect::Library::Singleton.3pm: A singleton aspect <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::EasyOBJ: Easy xml object navigation</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Easy xml object navigation">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::EasyOBJ (3pm) manual">
  <meta name="twitter:description" content="Easy xml object navigation">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-easyobj-perl-XML::EasyOBJ-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::EasyOBJ.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::EasyOBJ (3pm) manual" />
  <meta property="og:description" content="Easy xml object navigation" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-easyobj-perl-XML::EasyOBJ-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::EasyOBJ<small> (3pm)</small></h1>
        <p class="lead">Easy xml object navigation</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::EasyOBJ.3pm.html">
      <span itemprop="name">XML::EasyOBJ: Easy xml object navigation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-easyobj-perl/">
      <span itemprop="name">libxml-easyobj-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::EasyOBJ.3pm.html">
      <span itemprop="name">XML::EasyOBJ: Easy xml object navigation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>Version 1.12</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 # open exisiting file
 my $doc = new XML::EasyOBJ(&apos;my_xml_document.xml&apos;);
 my $doc = new XML::EasyOBJ(-type =&gt; &apos;file&apos;, -param =&gt; &apos;my_xml_document.xml&apos;);

 # create object from XML string
 my $doc = new XML::EasyOBJ(-type =&gt; &apos;string&apos;, -param =&gt; $xml_source);

 # create new file
 my $doc = new XML::EasyOBJ(-type =&gt; &apos;new&apos;, -param =&gt; &apos;root_tag&apos;);

 # read from document
 my $text = $doc-&gt;some_element($index)-&gt;getString;
 my $attr = $doc-&gt;some_element($index)-&gt;getAttr(&apos;foo&apos;);
 my $element = $doc-&gt;some_element($index);
 my @elements = $doc-&gt;some_element;

 # first "some_element" element
 my $elements = $doc-&gt;some_element;
 # list of "some_element" elements
 my @elements = $doc-&gt;some_element;

 # write to document
 $doc-&gt;an_element-&gt;setString(&apos;some string&apos;)
 $doc-&gt;an_element-&gt;addString(&apos;some string&apos;)
 $doc-&gt;an_element-&gt;setAttr(&apos;attrname&apos;, &apos;val&apos;)
 $doc-&gt;an_element-&gt;setAttr(&apos;attr1&apos; =&gt; &apos;val&apos;, &apos;attr2&apos; =&gt; &apos;val2&apos;)

 # access elements with non-name chars and the underlying DOM
 my $element = $doc-&gt;getElement(&apos;foo-bar&apos;)-&gt;getElement(&apos;bar-none&apos;);
 my $dom = $doc-&gt;foobar-&gt;getDomObj;

 # get elements without specifying the element name
 my @elements = $doc-&gt;getElement();
 my $sixth_element = $doc-&gt;getElement(&apos;&apos;, 5);

 # remove elements/attrs
 $doc-&gt;remElement(&apos;tagname&apos;, $index);
 $doc-&gt;tag_name-&gt;remAttr($attr);

 # remap builtin methods
 $doc-&gt;remapMethod(&apos;getString&apos;, &apos;s&apos;);
 my $text = $doc-&gt;some_element-&gt;s;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>I wrote XML::EasyOBJ a couple of years ago because it seemed to me that the \s-1DOM\s0 wasn't very \*(L"perlish\*(R" and the \s-1DOM\s0 is difficult for us mere mortals that don't use it on a regular basis.  As I only need to process \s-1XML\s0 on an occasionally I wanted an easy way to do what I needed to do without having to refer back to \s-1DOM\s0 documentation each time.</p><p>A quick fact list about XML::EasyOBJ:</p><p> * Runs on top of XML::DOM  * Allows access to the DOM as needed  * Simple routines to reading and writing elements/attributes</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REQUIREMENTS</h2>
        <div class="sectioncontent">
<p>XML::EasyOBJ uses \s-1XML::DOM\s0.  \s-1XML::DOM\s0 is available from \s-1CPAN\s0 (www.cpan.org).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>Below is a description of the methods avialable.</p><h3>new</h3>
<p>You can create a new object from an \s-1XML\s0 file, a string of \s-1XML\s0, or a new document.  The constructor takes a set of key value pairs as follows:</p>
<dl class='dl-vertical'>
  <dt>
    -type
  </dt>
  <dd>
    <p>The type is either \*(L"file\*(R", \*(L"string\*(R" or \*(L"new\*(R".  \*(L"file\*(R" will create the object from a file source, \*(L"string\*(R" will create the object from a string of \s-1XML\s0 code, and \*(L"new\*(R" will create a new document object.</p>
  </dd>
  <dt>
    -param
  </dt>
  <dd>
    <p>This value depends on the -type that is passed to the constructor. If the -type is \*(L"file\*(R" this will be the filename to open and parse. If -type is \*(L"string\*(R", this is a string of \s-1XML\s0 code.  If -type is \*(L"new\*(R", this is the name of the root element. Creating an object from an \s-1XML\s0 file:  my $doc = new XML::EasyOBJ(-type =&gt; &apos;file&apos;, -param =&gt; &apos;my_xml_document.xml&apos;); Creating an object from a string containing the \s-1XML\s0 source:  my $doc = new XML::EasyOBJ(-type =&gt; &apos;string&apos;, -param =&gt; $xml_source); Creating a new \s-1XML\s0 document by passing the root tag name:  my $doc = new XML::EasyOBJ(-type =&gt; &apos;new&apos;, -param =&gt; &apos;root_tag&apos;);</p>
  </dd>
  <dt>
    -expref
  </dt>
  <dd>
    <p>Passing a value of 1 will force the expansion of references when grabbing string data from the \s-1XML\s0 file.  The default value is 0, not to expand references.</p>
  </dd>

</dl>
<p>Obtionally you may also pass the filename to open as the first argument instead of passing the -type and -param parameters. This is backwards compatable with early version of XML::EasyOBJ which did not handle -type and -param parameters.</p><p> my $doc = new XML::EasyOBJ(&apos;my_xml_document.xml&apos;);</p>
<h3>makeNewNode( \s-1NEW_TAG\s0 )</h3>
<p>Append a new element node to the current node. Takes the tag name as the parameter and returns the created node as a convienence.</p><p> my $p_element = $doc-&gt;body-&gt;makeNewNode(&apos;p&apos;);</p>
<h3>remapMethod( \s-1CUR_METHOD\s0, \s-1NEW_METHOD\s0 )</h3>
<p>Allows you to change the name of any of the object methods. You might want to do this for convienience or to avoid a naming collision with an element in the document.</p><p>Two parameters need to be passed; the current name of the method and the new name. Returns 1 on a successful mapping and undef on failure. A failure can result if you don't pass two parameters if if the \*(L"copy from\*(R" method name does not exist.</p><p> $doc-&gt;remapMethod(&apos;getString&apos;, &apos;s&apos;);  $doc-&gt;s();</p><p>After remapping you must use the new name if you with to remap the method again.  You can call the remapMethod method from any place in the \s-1XML\s0 tree and it will always change the method globally.</p><p>In the following example $val1 and $val2 are equal:</p><p> $doc-&gt;some_element-&gt;another_element-&gt;(&apos;getString&apos;, &apos;s&apos;);  my $val1 = $doc-&gt;s();  $doc-&gt;remapMethod(&apos;s&apos;, &apos;getString&apos;);  my $val2 = $doc-&gt;getString();</p>
<h3>getString( )</h3>
<p>Recursively extracts text from the current node and all children element nodes. Returns the extracted text as a single scalar value. Expands entities based on if the -expref flag was supplied during object creation.</p>
<h3>extractText( )</h3>
<p>Same as <em>getString()</em> but does not check the -expref flag.  Included for compatability with inital version of interface.</p>
<h3>setString( \s-1STRING\s0 )</h3>
<p>Sets the text value of the specified element. This is done by first removing all text node children of the current element and then appending the supplied text as a new child element.</p><p>Take this \s-1XML\s0 fragment and code for example:</p><p>&lt;p&gt;This elment has &lt;b&gt;text&lt;/b&gt; and &lt;i&gt;child&lt;/i&gt; elements&lt;/p&gt;</p><p> $doc-&gt;p-&gt;setString(&apos;This is the new text&apos;);</p><p>This will change the fragment to this:</p><p>&lt;p&gt;&lt;b&gt;text&lt;/b&gt;&lt;i&gt;child&lt;/i&gt;This is the new text&lt;/p&gt;</p><p>Because the &lt;b&gt; and &lt;i&gt; tags are not text nodes they are left unchanged, and the new text is added at the end of the specified element.</p><p>If you need more specific control on the change you should either use the <em>getDomObj()</em> method and use the \s-1DOM\s0 methods directly or remove all of the child nodes and rebuild the &lt;p&gt; element from scratch.  Also see the <em>addString()</em> method.</p>
<h3>addString( \s-1STRING\s0 )</h3>
<p>Adds to the the text value of the specified element. This is done by appending the supplied text as a new child element.</p><p>Take this \s-1XML\s0 fragment and code for example:</p><p>&lt;p&gt;This elment has &lt;b&gt;text&lt;/b&gt;&lt;/p&gt;</p><p> $doc-&gt;p-&gt;addString(&apos; and elements&apos;);</p><p>This will change the fragment to this:</p><p>&lt;p&gt;This elment has &lt;b&gt;text&lt;/b&gt; and elements&lt;/p&gt;</p>
<h3>getAttr( \s-1ATTR_NAME\s0 )</h3>
<p>Returns the value of the named attribute.</p><p> my $val = $doc-&gt;body-&gt;img-&gt;getAttr(&apos;src&apos;);</p>
<h3>getTagName( )</h3>
<p>Returns the tag name of the specified element. This method is useful when you are enumerating child elements and do not know their element names.</p><p> foreach my $element ( $doc-&gt;getElement() ) {     print $element-&gt;getTagName();  }</p>
<h3>setAttr( \s-1ATTR_NAME\s0, \s-1ATTR_VALUE\s0, [\s-1ATTR_NAME\s0, \s-1ATTR_VALUE\s0]... )</h3>
<p>For each name/value pair passed the attribute name and value will be set for the specified element.</p>
<h3>remAttr( \s-1ATTR_NAME\s0 )</h3>
<p>Removes the specified attribute from the current element.</p>
<h3>remElement( \s-1TAG_NAME\s0, \s-1INDEX\s0 )</h3>
<p>Removes a child element of the current element. The name of the child element and the index must be supplied.  An index of 0 will remove the first occurance of the named element, 1 the second, 2 the third, etc.</p>
<h3>getElement( \s-1TAG_NAME\s0, \s-1INDEX\s0 )</h3>
<p>Returns the node from the tag name and index. If no index is given the first child with that name is returned. Use this method when you have element names that include characters that are not legal as a perl method name.  For example:</p><p> &lt;foo&gt; &lt;!-- root element --&gt;   &lt;bar&gt;    &lt;foo-bar&gt;test&lt;/foo-bar&gt;   &lt;/bar&gt;  &lt;/foo&gt;</p><p> # "foo-bar" is not a legal method name  print $doc-&gt;bar-&gt;getElement(&apos;foo-bar&apos;)-&gt;getString();</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">getDomObj( )</h2>
        <div class="sectioncontent">
<p>Returns the \s-1DOM\s0 object associated with the current node. This is useful when you need fine access via the \s-1DOM\s0 to perform a specific function.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BEGINNER QUICK START GUIDE</h2>
        <div class="sectioncontent">
<h3>Introduction</h3>
<p>You too can write \s-1XML\s0 applications, just as long as you understand the basics of \s-1XML\s0 (elements and attributes). You can learn to write your first program that can read data from an \s-1XML\s0 file in a mere 10 minutes.</p>
<h3>Assumptions</h3>
<p>It is assumed that you are familiar with the structure of the document that you are reading.  Next, you must know the basics of perl lists, loops, and how to call a function.  You must also have an \s-1XML\s0 document to read.</p><p>Simple eh?</p>
<h3>Loading the \s-1XML\s0 document</h3>
<p> use XML::EasyOBJ;  my $doc = new XML::EasyOBJ(&apos;my_xml_document.xml&apos;) || die "Can&apos;t make object";</p><p>Replace the string \*(L"my_xml_document.xml\*(R" with the name of your \s-1XML\s0 document. If the document is in another directory you will need to specify the path to it as well.</p><p>The variable $doc is an object, and represents our root \s-1XML\s0 element in the document.</p>
<h3>Reading text with getString</h3>
<p>Each element becomes an object. So lets assume that the \s-1XML\s0 page looks like this:</p><p> &lt;table&gt;   &lt;record&gt;    &lt;rec2 foo="bar"&gt;     &lt;field1&gt;field1a&lt;/field1&gt;     &lt;field2&gt;field2b&lt;/field2&gt;     &lt;field3&gt;field3c&lt;/field3&gt;    &lt;/rec2&gt;    &lt;rec2 foo="baz"&gt;     &lt;field1&gt;field1d&lt;/field1&gt;     &lt;field2&gt;field2e&lt;/field2&gt;     &lt;field3&gt;field3f&lt;/field3&gt;    &lt;/rec2&gt;   &lt;/record&gt;  &lt;/table&gt;</p><p>As mentioned in he last step, the $doc object is the root element of the \s-1XML\s0 page. In this case the root element is the \*(L"table\*(R" element.</p><p>To read the text of any field is as easy as navigating the \s-1XML\s0 elements. For example, lets say that we want to retrieve the text \*(L"field2e\*(R". This text is in the \*(L"field2\*(R" element of the \s-1SECOND\s0 \*(L"rec2\*(R" element, which is in the \s-1FIRST\s0 \*(L"record\*(R" element.</p><p>So the code to print that value it looks like this:</p><p> print $doc-&gt;<strong>record</strong>(0)-&gt;<strong>rec2</strong>(1)-&gt;field2-&gt;getString;</p><p>The \*(L"getString\*(R" method returns the text within an element.</p><p>We can also break it down like this:</p><p> # grab the FIRST "record" element (index starts at 0)  my $record = $doc-&gt;<strong>record</strong>(0);</p><p> # grab the SECOND "rec2" element within $record  my $rec2 = $record-&gt;<strong>rec2</strong>(1);</p><p> # grab the "field2" element from $rec2  # NOTE: If you don&apos;t specify an index, the first item  #       is returned and in this case there is only 1.  my $field2 = $rec2-&gt;field2;</p><p> # print the text  print $field2-&gt;getString;</p>
<h3>Reading \s-1XML\s0 attributes with getAttr</h3>
<p>Looking at the example in the previous step, can you guess what this code will print?</p><p> print $doc-&gt;<strong>record</strong>(0)-&gt;<strong>rec2</strong>(0)-&gt;getAttr(&apos;foo&apos;);  print $doc-&gt;<strong>record</strong>(0)-&gt;<strong>rec2</strong>(1)-&gt;getAttr(&apos;foo&apos;);</p><p>If you couldn't guess, they will print out the value of the \*(L"foo\*(R" attribute of the first and second rec2 elements.</p>
<h3>Looping through elements</h3>
<p>Lets take our example in the previous step where we printed the attribute values and rewrite it to use a loop. This will allow it to print all of the \*(L"foo\*(R" attributes no matter how many \*(L"rec2\*(R" elements we have.</p><p> foreach my $rec2 ( $doc-&gt;<strong>record</strong>(0)-&gt;rec2 ) {    print $rec2-&gt;getAttr(&apos;foo&apos;);  }</p><p>When we call $doc-&gt;<em>record</em>\|(0)-&gt;rec2 this way (i.e. in list context), the module will return a list of \*(L"rec2\*(R" elements.</p>
<h3>That's it!</h3>
<p>You are now an \s-1XML\s0 programmer! *start rejoicing now*</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROGRAMMING NOTES</h2>
        <div class="sectioncontent">
<p>When creating a new instance of XML::EasyOBJ it will return an object reference on success, or undef on failure. Besides that, \s-1ALL\s0 methods will always return a value. This means that if you specify an element that does not exist, it will still return an object reference (and create that element automagically). This is just another way to lower the bar, and make this module easier to use.</p><p>You will run into problems if you have \s-1XML\s0 tags which are named after perl's special subroutine names (i.e. \*(L"\s-1DESTROY\s0\*(R", \*(L"\s-1AUTOLOAD\s0\*(R"), or if they are named after subroutines used in the module ( \*(L"getString\*(R", \*(L"getAttr\*(R", etc ). You can get around this by using the <em>getElement()</em> method of using the <em>remapMethod()</em> method which can be used on every object method (except \s-1AUTOLOAD\s0 and \s-1DESTROY\s0).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR/COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2000-2002 Robert Hanson &lt;rhanson@blast.net&gt;</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::EasyOBJ&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1XML::DOM\s0</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::ESISParser.3pm.html"><span aria-hidden="true">&larr;</span> XML::ESISParser.3pm: Perl sax parser using nsgmls</a></li>
   <li class="next"><a href="XML::Feed.3pm.html">XML::Feed.3pm: Syndication feed parser and auto-discovery <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

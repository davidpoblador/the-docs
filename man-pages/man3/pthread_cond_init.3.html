<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pthread_cond_init: Operations on conditions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Operations on conditions">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pthread_cond_init<small> (3)</small></h1>
        <p class="lead">Operations on conditions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pthread_cond_init.3.html">
      <span itemprop="name">pthread_cond_init: Operations on conditions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/glibc/">
      <span itemprop="name">glibc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pthread_cond_init.3.html">
      <span itemprop="name">pthread_cond_init: Operations on conditions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<p><strong>#include &lt;pthread.h&gt;</strong></p>
<p class='spacer'>

<p><strong>pthread_cond_t </strong><em>cond</em><strong> = PTHREAD_COND_INITIALIZER;</strong></p>
<p class='spacer'>

<p><strong>int pthread_cond_init(pthread_cond_t *</strong><em>cond</em><strong>, pthread_condattr_t *</strong><em>cond_attr</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_cond_signal(pthread_cond_t *</strong><em>cond</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_cond_broadcast(pthread_cond_t *</strong><em>cond</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_cond_wait(pthread_cond_t *</strong><em>cond</em><strong>, pthread_mutex_t *</strong><em>mutex</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_cond_timedwait(pthread_cond_t *</strong><em>cond</em><strong>, pthread_mutex_t *</strong><em>mutex</em><strong>, const struct timespec *</strong><em>abstime</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_cond_destroy(pthread_cond_t *</strong><em>cond</em><strong>);</strong></p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p>A condition (short for ``condition variable'') is a synchronization device that allows threads to suspend execution and relinquish the processors until some predicate on shared data is satisfied. The basic operations on conditions are: signal the condition (when the predicate becomes true), and wait for the condition, suspending the thread execution until another thread signals the condition.</p>
<p class='spacer'>

<p>A condition variable must always be associated with a mutex, to avoid the race condition where a thread prepares to wait on a condition variable and another thread signals the condition just before the first thread actually waits on it.</p>
<p class='spacer'>

<p><strong>pthread_cond_init</strong> initializes the condition variable <em>cond</em>, using the condition attributes specified in <em>cond_attr</em>, or default attributes if <em>cond_attr</em> is <strong>NULL</strong>. The LinuxThreads implementation supports no attributes for conditions, hence the <em>cond_attr</em> parameter is actually ignored.</p>
<p class='spacer'>

<p>Variables of type <strong>pthread_cond_t</strong> can also be initialized statically, using the constant <strong>PTHREAD_COND_INITIALIZER</strong>.</p>
<p class='spacer'>

<p><strong>pthread_cond_signal</strong> restarts one of the threads that are waiting on the condition variable <em>cond</em>. If no threads are waiting on <em>cond</em>, nothing happens. If several threads are waiting on <em>cond</em>, exactly one is restarted, but it is not specified which.</p>
<p class='spacer'>

<p><strong>pthread_cond_broadcast</strong> restarts all the threads that are waiting on the condition variable <em>cond</em>. Nothing happens if no threads are waiting on <em>cond</em>.</p>
<p class='spacer'>

<p><strong>pthread_cond_wait</strong> atomically unlocks the <em>mutex</em> (as per <strong>pthread_unlock_mutex</strong>) and waits for the condition variable <em>cond</em> to be signaled. The thread execution is suspended and does not consume any CPU time until the condition variable is signaled. The <em>mutex</em> must be locked by the calling thread on entrance to <strong>pthread_cond_wait</strong>. Before returning to the calling thread, <strong>pthread_cond_wait</strong> re-acquires <em>mutex</em> (as per <strong>pthread_lock_mutex</strong>).</p>
<p class='spacer'>

<p>Unlocking the mutex and suspending on the condition variable is done atomically. Thus, if all threads always acquire the mutex before signaling the condition, this guarantees that the condition cannot be signaled (and thus ignored) between the time a thread locks the mutex and the time it waits on the condition variable.</p>
<p class='spacer'>

<p><strong>pthread_cond_timedwait</strong> atomically unlocks <em>mutex</em> and waits on <em>cond</em>, as <strong>pthread_cond_wait</strong> does, but it also bounds the duration of the wait. If <em>cond</em> has not been signaled within the amount of time specified by <em>abstime</em>, the mutex <em>mutex</em> is re-acquired and <strong>pthread_cond_timedwait</strong> returns the error <strong>ETIMEDOUT</strong>. The <em>abstime</em> parameter specifies an absolute time, with the same origin as <a href="../man2/time.2.html"><strong>time</strong>(2)</a> and <a href="../man2/gettimeofday.2.html"><strong>gettimeofday</strong>(2)</a>: an <em>abstime</em> of 0 corresponds to 00:00:00 GMT, January 1, 1970.</p>
<p class='spacer'>

<p><strong>pthread_cond_destroy</strong> destroys a condition variable, freeing the resources it might hold. No threads must be waiting on the condition variable on entrance to <strong>pthread_cond_destroy</strong>. In the LinuxThreads implementation, no resources are associated with condition variables, thus <strong>pthread_cond_destroy</strong> actually does nothing except checking that the condition has no waiting threads.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CANCELLATION</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p><strong>pthread_cond_wait</strong> and <strong>pthread_cond_timedwait</strong> are cancellation points. If a thread is cancelled while suspended in one of these functions, the thread immediately resumes execution, then locks again the <em>mutex</em> argument to <strong>pthread_cond_wait</strong> and <strong>pthread_cond_timedwait</strong>, and finally executes the cancellation. Consequently, cleanup handlers are assured that <em>mutex</em> is locked when they are called.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ASYNC-SIGNAL SAFETY</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p>The condition functions are not async-signal safe, and should not be called from a signal handler. In particular, calling <strong>pthread_cond_signal</strong> or <strong>pthread_cond_broadcast</strong> from a signal handler may deadlock the calling thread.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p>All condition variable functions return 0 on success and a non-zero error code on error.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p><strong>pthread_cond_init</strong>, <strong>pthread_cond_signal</strong>, <strong>pthread_cond_broadcast</strong>, and <strong>pthread_cond_wait</strong> never return an error code.</p>
<p class='spacer'>

    <p>The <strong>pthread_cond_timedwait</strong> function returns the following error codes on error:</p>
    <dl class='dl-vertical'>
      <dt><strong>ETIMEDOUT</strong></dt>
      <dd>
    <p>the condition variable was not signaled until the timeout specified by <em>abstime</em></p>
<p class='spacer'>

      </dd>
      <dt><strong>EINTR</strong></dt>
      <dd>
    <p><strong>pthread_cond_timedwait</strong> was interrupted by a signal</p>
      </dd>
    </dl>
<p class='spacer'>

    <p>The <strong>pthread_cond_destroy</strong> function returns the following error code on error:</p>
    <dl class='dl-vertical'>
      <dt><strong>EBUSY</strong></dt>
      <dd>
    <p>some threads are currently waiting on <em>cond</em>.</p>
      </dd>
    </dl>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">

<p>Xavier Leroy &lt;Xavier.Leroy@inria.fr&gt;</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p>Consider two shared variables <em>x</em> and <em>y</em>, protected by the mutex <em>mut</em>, and a condition variable <em>cond</em> that is to be signaled whenever <em>x</em> becomes greater than <em>y</em>.</p>
<p class='spacer'>

<pre>
int x,y;
pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
</pre>

<p class='spacer'>

<p>Waiting until <em>x</em> is greater than <em>y</em> is performed as follows:</p>
<p class='spacer'>

<pre>
pthread_mutex_lock(&mut);
while (x &lt;= y) {
        pthread_cond_wait(&cond, &mut);
}
/* operate on x and y */
pthread_mutex_unlock(&mut);
</pre>

<p class='spacer'>

<p>Modifications on <em>x</em> and <em>y</em> that may cause <em>x</em> to become greater than <em>y</em> should signal the condition if needed:</p>
<p class='spacer'>

<pre>
pthread_mutex_lock(&mut);
/* modify x and y */
if (x &gt; y) pthread_cond_broadcast(&cond);
pthread_mutex_unlock(&mut);
</pre>

<p class='spacer'>

<p>If it can be proved that at most one waiting thread needs to be waken up (for instance, if there are only two threads communicating through <em>x</em> and <em>y</em>), <strong>pthread_cond_signal</strong> can be used as a slightly more efficient alternative to <strong>pthread_cond_broadcast</strong>. In doubt, use <strong>pthread_cond_broadcast</strong>.</p>
<p class='spacer'>

<p>To wait for <em>x</em> to becomes greater than <em>y</em> with a timeout of 5 seconds, do:</p>
<p class='spacer'>

<pre>
struct timeval now;
struct timespec timeout;
int retcode;

pthread_mutex_lock(&mut);
gettimeofday(&now);
timeout.tv_sec = now.tv_sec + 5;
timeout.tv_nsec = now.tv_usec * 1000;
retcode = 0;
while (x &lt;= y && retcode != ETIMEDOUT) {
        retcode = pthread_cond_timedwait(&cond, &mut, &timeout);
}
if (retcode == ETIMEDOUT) {
        /* timeout occurred */
} else {
        /* operate on x and y */
}
pthread_mutex_unlock(&mut);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pthread_cond_init&hellip;</h2>
        <div class="sectioncontent">

<p><a href="../man3/pthread_condattr_init.3.html"><strong>pthread_condattr_init</strong>(3)</a>, <a href="../man3/pthread_mutex_lock.3.html"><strong>pthread_mutex_lock</strong>(3)</a>, <a href="../man3/pthread_mutex_unlock.3.html"><strong>pthread_mutex_unlock</strong>(3)</a>, <a href="../man2/gettimeofday.2.html"><strong>gettimeofday</strong>(2)</a>, <a href="../man2/nanosleep.2.html"><strong>nanosleep</strong>(2)</a>.</p>
<p class='spacer'>

        </div>
      </section>

<nav>
  <ul class="pager">
   <li class="previous"><a href="pthread_cond_destroy.3.html"><span aria-hidden="true">&larr;</span> pthread_cond_destroy.3: Operations on conditions</a></li>
   <li class="next"><a href="pthread_cond_signal.3.html">pthread_cond_signal.3: Operations on conditions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoVRMLLOD: The sovrmllod class is used to represent various levels of detail based on distance.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sovrmllod class is used to represent various levels of detail based on distance.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoVRMLLOD (3) manual">
  <meta name="twitter:description" content="The sovrmllod class is used to represent various levels of detail based on distance.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoVRMLLOD-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoVRMLLOD.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoVRMLLOD (3) manual" />
  <meta property="og:description" content="The sovrmllod class is used to represent various levels of detail based on distance.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoVRMLLOD-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoVRMLLOD<small> (3)</small></h1>
        <p class="lead">The sovrmllod class is used to represent various levels of detail based on distance.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoVRMLLOD.3.html">
      <span itemprop="name">SoVRMLLOD: The sovrmllod class is used to represent various levels of detail based on distance.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoVRMLLOD.3.html">
      <span itemprop="name">SoVRMLLOD: The sovrmllod class is used to represent various levels of detail based on distance.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/VRMLnodes/SoVRMLLOD.h&gt;</p><p>Inherits <strong>SoGroup</strong>.</p><h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> <strong>SoVRMLLOD</strong> (void)</p><p><strong>SoVRMLLOD</strong> (int levels)</p><p>virtual SbBool <strong>affectsState</strong> (void) const </p><p>void <strong>addLevel</strong> (<strong>SoNode</strong> *<strong>level</strong>)</p><p>void <strong>insertLevel</strong> (<strong>SoNode</strong> *<strong>level</strong>, int idx)</p><p><strong>SoNode</strong> * <strong>getLevel</strong> (int idx) const </p><p>int <strong>findLevel</strong> (const <strong>SoNode</strong> *<strong>level</strong>) const </p><p>int <strong>getNumLevels</strong> (void) const </p><p>void <strong>removeLevel</strong> (int idx)</p><p>void <strong>removeLevel</strong> (<strong>SoNode</strong> *<strong>level</strong>)</p><p>void <strong>removeAllLevels</strong> (void)</p><p>void <strong>replaceLevel</strong> (int idx, <strong>SoNode</strong> *<strong>level</strong>)</p><p>void <strong>replaceLevel</strong> (<strong>SoNode</strong> *old, <strong>SoNode</strong> *<strong>level</strong>)</p><p>virtual void <strong>doAction</strong> (<strong>SoAction</strong> *action)</p><p>virtual void <strong>callback</strong> (<strong>SoCallbackAction</strong> *action)</p><p>virtual void <strong>GLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>rayPick</strong> (<strong>SoRayPickAction</strong> *action)</p><p>virtual void <strong>getBoundingBox</strong> (<strong>SoGetBoundingBoxAction</strong> *action)</p><p>virtual void <strong>search</strong> (<strong>SoSearchAction</strong> *action)</p><p>virtual void <strong>write</strong> (<strong>SoWriteAction</strong> *action)</p><p>virtual void <strong>getPrimitiveCount</strong> (<strong>SoGetPrimitiveCountAction</strong> *action)</p><p>virtual void <strong>audioRender</strong> (<strong>SoAudioRenderAction</strong> *action)</p><p>virtual void <strong>GLRenderBelowPath</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>GLRenderInPath</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>GLRenderOffPath</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>void <strong>addChild</strong> (<strong>SoNode</strong> *child)</p><p>void <strong>insertChild</strong> (<strong>SoNode</strong> *child, int idx)</p><p><strong>SoNode</strong> * <strong>getChild</strong> (int idx) const </p><p>int <strong>findChild</strong> (const <strong>SoNode</strong> *child) const </p><p>int <strong>getNumChildren</strong> (void) const </p><p>void <strong>removeChild</strong> (int idx)</p><p>void <strong>removeChild</strong> (<strong>SoNode</strong> *child)</p><p>void <strong>removeAllChildren</strong> (void)</p><p>void <strong>replaceChild</strong> (int idx, <strong>SoNode</strong> *child)</p><p>void <strong>replaceChild</strong> (<strong>SoNode</strong> *old, <strong>SoNode</strong> *child)</p><p>virtual <strong>SoChildList</strong> * <strong>getChildren</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p>
<h3>Public Attributes</h3>
<p><strong>SoMFFloat</strong> <strong>range</strong></p><p><strong>SoSFVec3f</strong> <strong>center</strong></p><p><strong>SoMFNode</strong> <strong>level</strong></p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual <strong>~SoVRMLLOD</strong> ()</p><p>virtual void <strong>notify</strong> (<strong>SoNotList</strong> *list)</p><p>virtual SbBool <strong>readInstance</strong> (<strong>SoInput</strong> *in, unsigned short flags)</p><p>virtual void <strong>copyContents</strong> (const <strong>SoFieldContainer</strong> *from, SbBool copyConn)</p><p>virtual int <strong>whichToTraverse</strong> (<strong>SoAction</strong> *action)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoVRMLLOD</strong> class is used to represent various levels of detail based on distance.</p><p><strong>The detailed class documentation is taken verbatim from the VRML97 standard (ISO/IEC 14772-1:1997). It is copyright The Web3D Consortium, and is used by permission of the Consortium:</strong></p>
<pre>
LOD {
  exposedField MFNode  level    []
  field        SFVec3f center   0 0 0    # (-,)
  field        MFFloat range    []       # (0,)
}

</pre>
<p>The LOD node specifies various levels of detail or complexity for a given object, and provides hints allowing browsers to automatically choose the appropriate version of the object based on the distance from the user. The level field contains a list of nodes that represent the same object or objects at varying levels of detail, ordered from highest level of detail to the lowest level of detail. The range field specifies the ideal distances at which to switch between the levels. Subclause 4.6.5, Grouping and children nodes (http://www.web3d.org/x3d/specifications/vrml/ISO-IEC-14772-VRML97/part1/concepts.html#4.6.5), contains details on the types of nodes that are legal values for level.</p><p>The center field is a translation offset in the local coordinate system that specifies the centre of the LOD node for distance calculations.</p><p>The number of nodes in the level field shall exceed the number of values in the range field by one (i.e., N+1 level values for N range values). The range field contains monotonic increasing values that shall be greater than zero. In order to calculate which level to display, first the distance is calculated from the viewer's location, transformed into the local coordinate system of the LOD node (including any scaling transformations), to the center point of the LOD node. Then, the LOD node evaluates the step function L(d) to choose a level for a given value of d (where d is the distance from the viewer position to the centre of the LOD node). Let n ranges, R0, R1, R2, ..., Rn-1, partition the domain (0, +infinity) into n+1 subintervals given by (0, R0), [R0, R1)... , [Rn-1, +infinity). Also, let n levels L0, L1, L2, ..., Ln-1 be the values of the step function function L(d). The level node, L(d), for a given distance d is defined as follows:</p>
<pre>
  L(d) = L0,   if d &lt; R0,
       = Li+1, if Ri &lt;= d &lt; Ri+1, for -1 &lt; i &lt; n-1,
       = Ln-1, if d &gt;= Rn-1.
</pre>
<p>Specifying too few levels will result in the last level being used repeatedly for the lowest levels of detail. If more levels than ranges are specified, the extra levels are ignored. An empty range field is an exception to this rule. This case is a hint to the browser that it may choose a level automatically to maintain a constant display rate. Each value in the range field shall be greater than the previous value.</p><p>LOD nodes are evaluated top-down in the scene graph. Only the descendants of the currently selected level are rendered. All nodes under an LOD node continue to receive and send events regardless of which LOD node's level is active. For example, if an active TimeSensor node is contained within an inactive level of an LOD node, the TimeSensor node sends events regardless of the LOD node's state.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoVRMLLOD::SoVRMLLOD (void)</h3>
<p>Constructor.</p>
<h3>SoVRMLLOD::SoVRMLLOD (intlevels)</h3>
<p>Constructor. <em>levels</em> is the expected number of levels.</p>
<h3>SoVRMLLOD::~SoVRMLLOD ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoVRMLLOD::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>const \fBSoFieldData\fP * SoVRMLLOD::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>SbBool SoVRMLLOD::affectsState (void) const\fC [virtual]\fP</h3>
<p>Returns TRUE if the node could have any effect on the state during traversal.</p><p>If it returns FALSE, no data in the traversal-state will change from the pre-traversal state to the post-traversal state. The <strong>SoSeparator</strong> node will for instance return FALSE<strong>, as it pushes and pops the state before and after traversal of its children. All </strong><strong>SoShape</strong><strong> nodes will also return FALSE</strong><strong>, as just pushing out geometry data to the rendering engine won't affect the actual rendering state.</strong></p><p>The default method returns TRUE, on a 'better safe than sorry' philosophy.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoVRMLLOD::addLevel (\fBSoNode\fP *levelptr)</h3>
<p>Adds a new level.</p>
<h3>void SoVRMLLOD::insertLevel (\fBSoNode\fP *levelptr, intidx)</h3>
<p>Inserts a new level.</p>
<h3>\fBSoNode\fP * SoVRMLLOD::getLevel (intidx) const</h3>
<p>Returns a level.</p>
<h3>int SoVRMLLOD::findLevel (const \fBSoNode\fP *node) const</h3>
<p>Find <em>node</em>, and return the level index or -1 if not found.</p>
<h3>int SoVRMLLOD::getNumLevels (void) const</h3>
<p>Return the number of levels.</p>
<h3>void SoVRMLLOD::removeLevel (intidx)</h3>
<p>Removes the level at index <em>idx</em>.</p>
<h3>void SoVRMLLOD::removeLevel (\fBSoNode\fP *levelptr)</h3>
<p>Find <em>level</em>, and remove it if found.</p>
<h3>void SoVRMLLOD::removeAllLevels (void)</h3>
<p>Remove all levels.</p>
<h3>void SoVRMLLOD::replaceLevel (intidx, \fBSoNode\fP *node)</h3>
<p>Replace the level at <em>idx</em> with <em>node</em>.</p>
<h3>void SoVRMLLOD::replaceLevel (\fBSoNode\fP *oldnode, \fBSoNode\fP *newnode)</h3>
<p>Find <em>oldnode</em>, and replace it with <em>newnode</em>.</p>
<h3>void SoVRMLLOD::doAction (\fBSoAction\fP *action)\fC [virtual]\fP</h3>
<p>This function performs the typical operation of a node for any action.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::callback (\fBSoCallbackAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoCallbackAction</strong>.</p><p>Simply updates the state according to how the node behaves for the render action, so the application programmer can use the <strong>SoCallbackAction</strong> for extracting information about the scene graph.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::GLRender (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGLRenderAction</strong>.</p><p>This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::rayPick (\fBSoRayPickAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoRayPickAction</strong>.</p><p>Checks the ray specification of the <em>action</em> and tests for intersection with the data of the node.</p><p>Nodes influencing relevant state variables for how picking is done also overrides this method.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoVRMLLOD::getBoundingBox (\fBSoGetBoundingBoxAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetBoundingBoxAction</strong>.</p><p>Calculates bounding box and center coordinates for node and modifies the values of the <em>action</em> to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node.</p><p>Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::search (\fBSoSearchAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoSearchAction</strong>.</p><p>Compares the search criteria from the <em>action</em> to see if this node is a match. Searching is done by matching up <em>all</em> criteria set up in the <strong>SoSearchAction</strong> -- if <em>any</em> of the requested criteria is a miss, the search is not deemed successful for the node.</p><p><strong>See also:</strong></p><p><strong>SoSearchAction</strong></p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::write (\fBSoWriteAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoWriteAction</strong>.</p><p>Writes out a node object, and any connected nodes, engines etc, if necessary.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetPrimitiveCountAction</strong>.</p><p>Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the <em>action</em>.</p><p>Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::audioRender (\fBSoAudioRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoAudioRenderAction</strong>.</p><p>Does common processing for <strong>SoAudioRenderAction</strong> <em>action</em> instances.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::GLRenderBelowPath (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Implements the SoAction::BELOW_PATH traversal method for the rendering action.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoVRMLLOD::GLRenderInPath (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Implements the SoAction::IN_PATH traversal method for the rendering action.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoVRMLLOD::GLRenderOffPath (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Implements the SoAction::OFF_PATH traversal method for the rendering action.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoVRMLLOD::addChild (\fBSoNode\fP *node)\fC [virtual]\fP</h3>
<p>Append a child <em>node</em> to the list of children nodes this group node is managing.</p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::insertChild (\fBSoNode\fP *child, intnewchildindex)\fC [virtual]\fP</h3>
<p>Insert a <em>child</em> node at position <em>newchildindex</em>.</p><p><em>newchildindex</em> must be &lt;= this-&gt;<strong>getNumChildren()</strong></p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>\fBSoNode\fP * SoVRMLLOD::getChild (intindex) const\fC [virtual]\fP</h3>
<p>Returns pointer to child node at <em>index</em>.</p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>int SoVRMLLOD::findChild (const \fBSoNode\fP *node) const\fC [virtual]\fP</h3>
<p>Returns index in our list of children for child <em>node</em>, or -1 if <em>node</em> is not a child of this group node.</p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>int SoVRMLLOD::getNumChildren (void) const\fC [virtual]\fP</h3>
<p>Returns number of child nodes managed by this group.</p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::removeChild (intchildindex)\fC [virtual]\fP</h3>
<p>Remove node at <em>childindex</em> in our list of children.</p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::removeChild (\fBSoNode\fP *child)\fC [virtual]\fP</h3>
<p>Remove <em>child</em> from the set of children managed by this group node. Will decrease the reference count of <em>child</em> by 1.</p><p>This is a convenience method. It will simply call <strong>findChild()</strong> with <em>child</em> as argument, and then call <strong>removeChild(int)</strong> if the child is found.</p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::removeAllChildren (void)\fC [virtual]\fP</h3>
<p>Do not manage the children anymore. Will dereference all children by 1 as they are removed.</p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::replaceChild (intindex, \fBSoNode\fP *newchild)\fC [virtual]\fP</h3>
<p>Replace child at <em>index</em> with <em>newChild</em>.</p><p>Dereferences the child previously at <em>index</em>, and increases the reference count of <em>newChild</em> by 1.</p><p><em>index</em> must be &lt; this-&gt;<strong>getNumChildren()</strong></p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::replaceChild (\fBSoNode\fP *oldchild, \fBSoNode\fP *newchild)\fC [virtual]\fP</h3>
<p>Replace <em>oldchild</em> with <em>newchild</em>.</p><p>Dereferences <em>oldchild</em> by 1, and increases the reference count of <em>newchild</em> by 1.</p><p>This is a convenience method. It will simply call <strong>findChild()</strong> with <em>oldchild</em> as argument, and call <strong>replaceChild(int, SoNode*)</strong> if the child is found.</p><p>Please note that this method is not virtual in the original SGI Inventor API.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>\fBSoChildList\fP * SoVRMLLOD::getChildren (void) const\fC [virtual]\fP</h3>
<p>Returns list of children.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::notify (\fBSoNotList\fP *l)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Notifies all auditors for this instance when changes are made.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>SbBool SoVRMLLOD::readInstance (\fBSoInput\fP *in, unsigned shortflags)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method is mainly intended for internal use during file import operations.</p><p>It reads a definition of an instance from the input stream <em>in</em>. The input stream state points to the start of a serialized / persistant representation of an instance of this class type.</p><p>TRUE or FALSE is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not. The import process should be robust and handle corrupted input streams by returning FALSE.</p><p><em>flags</em> is used internally during binary import when reading user extension nodes, group nodes or engines.</p><p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>void SoVRMLLOD::copyContents (const \fBSoFieldContainer\fP *from, SbBoolcopyconnections)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Makes a deep copy of all data of <em>from</em> into this instance, <em>except</em> external scenegraph references if <em>copyconnections</em> is FALSE<em>.</em></p><p>This is the method that should be overridden by extension node / engine / dragger / whatever subclasses which needs to account for internal data that are not handled automatically.</p><p>For copying nodes from application code, you should not invoke this function directly, but rather call the <strong>SoNode::copy()</strong> function:</p>
<pre>
SoNode * mynewnode = templatenode-&gt;copy();
</pre>
<p>The same also goes for engines.</p><p>Make sure that when you override the <strong>copyContents()</strong> method in your extension class that you also make it call upwards to it's parent superclass in the inheritance hierarchy, as <strong>copyContents()</strong> in for instance <strong>SoNode</strong> and <strong>SoFieldContainer</strong> does important work. It should go something like this:</p>
<pre>
void
MyCoinExtensionNode::copyContents(const SoFieldContainer * from,
                                  SbBool copyconnections)
{
  // let parent superclasses do their thing (copy fields, copy
  // instance name, etc etc)
  SoNode::copyContents(from, copyconnections);

  // [..then copy internal data..]
}
</pre>
<p>Reimplemented from <strong>SoGroup</strong>.</p>
<h3>int SoVRMLLOD::whichToTraverse (\fBSoAction\fP *action)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns the child to traverse based on distance to current viewpoint.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoMFFloat\fP SoVRMLLOD::range</h3>
<p>The range for each level.</p>
<h3>\fBSoSFVec3f\fP SoVRMLLOD::center</h3>
<p>The center used when calculating distance.</p>
<h3>\fBSoMFNode\fP SoVRMLLOD::level</h3>
<p>The different levels.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoVRMLInterpolator.3.html"><span aria-hidden="true">&larr;</span> SoVRMLInterpolator.3: The sovrmlinterpolator class is an internal abstract class.</a></li>
   <li class="next"><a href="SoVRMLLight.3.html">SoVRMLLight.3: The sovrmllight class is a superclass for vrml light nodes. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Statistics::Basic: A collection of very basic statistics modules</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A collection of very basic statistics modules">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Statistics::Basic (3pm) manual">
  <meta name="twitter:description" content="A collection of very basic statistics modules">
  <meta name="twitter:image" content="https://www.carta.tech/images/libstatistics-basic-perl-Statistics::Basic-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Statistics::Basic.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Statistics::Basic (3pm) manual" />
  <meta property="og:description" content="A collection of very basic statistics modules" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libstatistics-basic-perl-Statistics::Basic-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Statistics::Basic<small> (3pm)</small></h1>
        <p class="lead">A collection of very basic statistics modules</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Statistics::Basic.3pm.html">
      <span itemprop="name">Statistics::Basic: A collection of very basic statistics modules</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libstatistics-basic-perl/">
      <span itemprop="name">libstatistics-basic-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Statistics::Basic.3pm.html">
      <span itemprop="name">Statistics::Basic: A collection of very basic statistics modules</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use Statistics::Basic qw(:all);
</pre>
<p>These actually return objects, not numbers.  The objects will interpolate as nicely formated numbers (using Number::Format).  Or the actual number will be returned when the object is used as a number.</p><p>    my $median = median( 1,2,3 );     my $mean   = mean(  [1,2,3]); # array refs are ok too</p><p>    my $variance = variance( 1,2,3 );     my $stddev   = stddev(   1,2,3 );</p><p>Although passing unblessed numbers and array refs to these functions works, it's sometimes better to pass vector objects so the objects can reuse calculated values.</p><p>    my $v1       = $mean-&gt;query_vector;     my $variance = variance( $v1 );     my $stddev   = stddev(   $v1 );</p><p>Here, the mean used by the variance and the variance used by the standard deviation will not need to be recalculated.  Now consider these two calculations.</p><p>    my $covariance  = covariance(  [1 .. 3], [1 .. 3] );     my $correlation = correlation( [1 .. 3], [1 .. 3] );</p><p>The covariance above would need to be recalculated by the correlation when these functions are called this way.  But, if we instead built vectors first, that wouldn't happen:</p><p>    # $v1 is defined above     my $v2  = vector(1,2,3);     my $cov = covariance(  $v1, $v2 );     my $cor = correlation( $v1, $v2 );</p><p>Now $cor can reuse the variance calculated in $cov.</p><p>All of the functions above return objects that interpolate or evaluate as a single string or as a number.  Statistics::Basic::LeastSquareFit and Statistics::Basic::Mode are different:</p><p>    my $unimodal   = mode(1,2,3,3);     my $multimodal = mode(1,2,3);</p><p>    print "The modes are: $unimodal and $multimodal.&#92;n";     print "The first is multimodal... " if $unimodal-&gt;is_multimodal;     print "The second is multimodal.&#92;n" if $multimodal-&gt;is_multimodal;</p><p>In the first case, $unimodal will interpolate as a string <strong>and</strong> function correctly as a number.  However, in the second case, trying to use $multimodal as a number will \*(C`croak\*(C' an error \*(-- it still interpolates fine though.</p><p>    my $lsf = leastsquarefit($v1, $v2);</p><p>This $lsf will interpolate fine, showing \*(C`LSF( alpha: $alpha, beta: $beta )\*(C', but it will \*(C`croak\*(C' if you try to use the object as a number.</p><p>    my $v3             = $multimodal-&gt;query;     my ($alpha, $beta) = $lsf-&gt;query;     my $average        = $mean-&gt;query;</p><p>All of the objects allow you to explicitly query, if you're not in the mood to use overload.</p><p>    my @answers = (         $mode-&gt;query,         $median-&gt;query,         $stddev-&gt;query,     );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SHORTCUTS</h2>
        <div class="sectioncontent">
<p>The following shortcut functions can be used in place of calling the module's \*(C`new()\*(C' method directly.</p><p>They all take either array refs <strong>or</strong> lists as arguments, with the exception of the shortcuts that need two vectors to process (e.g. Statistics::Basic::Correlation).</p>
<dl class='dl-vertical'>
  <dt>
    <strong></strong><strong>vector()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::Vector object. Arguments to \*(C`vector()\*(C' can be any of: an array ref, a list of numbers, or a blessed vector object.  If passed a blessed vector object, vector will just return the vector passed in.</p>
  </dd>
  <dt>
    <strong></strong><strong>mean()</strong><strong></strong> <strong></strong><strong>average()</strong><strong></strong> <strong></strong><strong>avg()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::Mean object. You can choose to call \*(C`mean()\*(C' as \*(C`average()\*(C' or \*(C`avg()\*(C'.  Arguments can be any of: an array ref, a list of numbers, or a blessed vector object.</p>
  </dd>
  <dt>
    <strong></strong><strong>median()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::Median object. Arguments can be any of: an array ref, a list of numbers, or a blessed vector object.</p>
  </dd>
  <dt>
    <strong></strong><strong>mode()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::Mode object. Arguments can be any of: an array ref, a list of numbers, or a blessed vector object.</p>
  </dd>
  <dt>
    <strong></strong><strong>variance()</strong><strong></strong> <strong></strong><strong>var()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::Variance object. You can choose to call \*(C`variance()\*(C' as \*(C`var()\*(C'.  Arguments can be any of: an array ref, a list of numbers, or a blessed vector object.  If you will also be calculating the mean of the same list of numbers it's recommended to do this:     my $vec  = vector(1,2,3);     my $mean = mean($vec);     my $var  = variance($vec); This would also work:     my $mean = mean(1,2,3);     my $var  = variance($mean-&gt;query_vector); This will calculate the same mean twice:     my $mean = mean(1,2,3);     my $var  = variance(1,2,3); If you really only need the variance, ignore the above and this is fine:     my $variance = variance(1,2,3,4,5);</p>
  </dd>
  <dt>
    <strong></strong><strong>stddev()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::StdDev object. Arguments can be any of: an array ref, a list of numbers, or a blessed vector object.  Pass a vector object to \*(C`stddev()\*(C' to avoid recalculating the variance and mean if applicable (see \*(C`variance()\*(C').</p>
  </dd>
  <dt>
    <strong></strong><strong>covariance()</strong><strong></strong> <strong></strong><strong>cov()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::Covariance object. Arguments to \*(C`covariance()\*(C' or \*(C`cov()\*(C' must be array ref or vector objects. There must be precisely two arguments (or none, setting the vectors to two empty ones), and they must be the same length.</p>
  </dd>
  <dt>
    <strong></strong><strong>correlation()</strong><strong></strong> <strong></strong><strong>cor()</strong><strong></strong> <strong></strong><strong>corr()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::Correlation object. Arguments to \*(C`correlation()\*(C' or \*(C`cor()\*(C'/\*(C`corr()\*(C' must be array ref or vector objects.  There must be precisely two arguments (or none, setting the vectors to two empty ones), and they must be the same length.</p>
  </dd>
  <dt>
    <strong></strong><strong>leastsquarefit()</strong><strong></strong> <strong>\s-1</strong><strong>LSF\s0()</strong><strong></strong> <strong></strong><strong>lsf()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::LeastSquareFit object. Arguments to \*(C`leastsquarefit()\*(C' or \*(C`lsf()\*(C'/\*(C`LSF()\*(C' must be array ref or vector objects.  There must be precisely two arguments (or none, setting the vectors to two empty ones), and they must be the same length.</p>
  </dd>
  <dt>
    <strong></strong><strong>computed()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a Statistics::Basic::ComputedVector object. Argument must be a blessed vector object.  See the section on \*(L"\s-1COMPUTED\s0 \s-1VECTORS\s0\*(R" for more information on this.</p>
  </dd>
  <dt>
    <strong></strong><strong>handle_missing_values()</strong><strong></strong> <strong></strong><strong>handle_missing()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns two Statistics::Basic::ComputedVector objects. Arguments to this function should be two vector arguments.  See the section on \*(L"\s-1MISSING\s0 \s-1VALUES\s0\*(R" for further information on this function.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMPUTED VECTORS</h2>
        <div class="sectioncontent">
<p>Sometimes it will be handy to have a vector computed from another (or at least that updates based on the first).  Consider the case of outliers:</p><p>    my @a = ( (1,2,3) x 7, 15 );     my @b = ( (1,2,3) x 7 );</p><p>    my $v1 = vector(@a);     my $v2 = vector(@b);     my $v3 = computed($v1);        $v3-&gt;set_filter(sub {            my $m = mean($v1);            my $s = stddev($v1);</p><p>           grep { abs($_-$m) &lt;= $s } @_;        });</p><p>This filter sets $v3 to always be equal to $v1 such that all the elements that differ from the mean by more than a standard deviation are removed.  As such, "$v2" eq "$v3" since 15 is clearly an outlier by inspection.</p><p>    print "$v1&#92;n";     print "$v3&#92;n";</p><p>... prints:</p><p>    [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 15]     [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MISSING VALUES</h2>
        <div class="sectioncontent">
<p>Something I get asked about quite a lot is, \*(L"can S::B handle missing values?\*(R" The answer used to be, "that really depends on your data set, use grep," but I recently decided (5/29/09) that it was time to just go ahead and add this feature.</p><p>Strictly speaking, the feature was already there.  You simply need to add a couple filters to your data.  See \*(C`t/75_filtered_missings.t\*(C' for the test example.</p><p>This is what people usually mean when they ask if S::B can \*(L"handle\*(R" missing data:</p><p>    my $v1 = vector(1,2,3,undef,4);     my $v2 = vector(1,2,3,4, undef);     my $v3 = computed($v1);     my $v4 = computed($v2);</p><p>    $v3-&gt;set_filter(sub {         my @v = $v2-&gt;query;         map {$_[$_]} grep { defined $v[$_] and defined $_[$_] } 0 .. $#_;     });</p><p>    $v4-&gt;set_filter(sub {         my @v = $v1-&gt;query;         map {$_[$_]} grep { defined $v[$_] and defined $_[$_] } 0 .. $#_;     });</p><p>    print "$v1 $v2&#92;n"; # prints: [1, 2, 3, _, 4] [1, 2, 3, 4, _]     print "$v3 $v4&#92;n"; # prints: [1, 2, 3] [1, 2, 3]</p><p>But I've made it even simpler.  Since this is such a common request, I have provided a helper function to build the filters automatically:</p><p>    my $v1 = vector(1,2,3,undef,4);     my $v2 = vector(1,2,3,4, undef);</p><p>    my ($f1, $f2) = handle_missing_values($v1, $v2);</p><p>    print "$f1 $f2&#92;n"; # prints: [1, 2, 3] [1, 2, 3]</p><p>Note that in practice, you would still manipulate (insert, and shift) $v1 and $v2, <em>not</em> the computed vectors.  But for correlations and the like, you would use $f1 and $f2.</p><p>    $v1-&gt;<strong>insert</strong>(5);     $v2-&gt;<strong>insert</strong>(6);</p><p>    my $correlation = correlation($f1, $f2);</p><p>You can still insert on $f1 and $f2, but it updates the input vector rather than the computed one (which is just a filter handler).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REUSE DETAILS</h2>
        <div class="sectioncontent">
<p>Most of the objects have a variety of query functions that allow you to extract the objects used within.  Although, the objects are smart enough to prevent needless duplication.  That is, the following would test would pass:</p><p>    use Statistics::Basic qw(:all);</p><p>    my $v1 = vector(1,2,3,4,5);     my $v2 = vector($v1);     my $sd = stddev( $v1 );     my $v3 = $sd-&gt;query_vector;     my $m1 = mean( $v1 );     my $m2 = $sd-&gt;query_mean;     my $m3 = Statistics::Basic::Mean-&gt;new( $v1 );     my $v4 = $m3-&gt;query_vector;</p><p>    use Scalar::Util qw(refaddr);     use Test; plan tests =&gt; 5;</p><p>    ok( refaddr($v1), refaddr($v2) );     ok( refaddr($v2), refaddr($v3) );     ok( refaddr($m1), refaddr($m2) );     ok( refaddr($m2), refaddr($m3) );     ok( refaddr($v3), refaddr($v4) );</p><p>    # this is t/54_* in the distribution</p><p>Also, note that the mean is only calculated once even though we've calculated a variance and a standard deviation above.</p><p>Suppose you'd like a copy of the Statistics::Basic::Variance object that the Statistics::Basic::StdDev object is using.  All of the objects within should be accessible with query functions as follows.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUERY FUNCTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong></strong><strong>query()</strong><strong></strong>
  </dt>
  <dd>
    <p>This method exists in all of the objects.  Statistics::Basic::LeastSquareFit is the only one that returns two values (alpha and beta) as a list. Statistics::Basic::Vector returns either the list of elements in the vector, or reference to that array (depending on the context).  All of the other \*(C`query()\*(C' methods return a single number, the number the module purports to calculate.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_mean()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the Statistics::Basic::Mean object used by Statistics::Basic::Variance and Statistics::Basic::StdDev.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_mean1()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the first Statistics::Basic::Mean object used by Statistics::Basic::Covariance, Statistics::Basic::Correlation and Statistics::Basic::LeastSquareFit.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_mean2()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the second Statistics::Basic::Mean object used by Statistics::Basic::Covariance, and Statistics::Basic::Correlation.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_covariance()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the Statistics::Basic::Covariance object used by Statistics::Basic::Correlation and Statistics::Basic::LeastSquareFit.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_variance()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the Statistics::Basic::Variance object used by Statistics::Basic::StdDev.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_variance1()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the first Statistics::Basic::Variance object used by Statistics::Basic::LeastSquareFit.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_vector()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the Statistics::Basic::Vector object used by any of the single vector modules.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_vector1()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the first Statistics::Basic::Vector object used by any of the two vector modules.</p>
  </dd>
  <dt>
    <strong></strong><strong>query_vector2()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the second Statistics::Basic::Vector object used by any of the two vector modules.</p>
  </dd>
  <dt>
    <strong></strong><strong>is_multimodal()</strong><strong></strong>
  </dt>
  <dd>
    <p>Statistics::Basic::Mode objects sometimes return Statistics::Basic::Vector objects instead of numbers.  When \*(C`is_multimodal()\*(C' is true, the mode is a vector, not a scalar.</p>
  </dd>
  <dt>
    <strong></strong><strong>y_given_x()</strong><strong></strong>
  </dt>
  <dd>
    <p>Statistics::Basic::LeastSquareFit is meant for finding a line of best fit. This function can be used to find the \*(C`y\*(C' for a given \*(C`x\*(C' based on the calculated $beta (slope) and $alpha (y-offset).</p>
  </dd>
  <dt>
    <strong></strong><strong>x_given_y()</strong><strong></strong>
  </dt>
  <dd>
    <p>Statistics::Basic::LeastSquareFit is meant for finding a line of best fit. This function can be used to find the \*(C`x\*(C' for a given \*(C`y\*(C' based on the calculated $beta (slope) and $alpha (y-offset). This function can produce divide-by-zero errors since it must divide by the slope to find the \*(C`x\*(C' value.  (The slope should rarely be zero though, that's a vertical line and would represent very odd data points.)</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSERT and SET FUNCTIONS</h2>
        <div class="sectioncontent">
<p>These objects are all intended to be useful while processing long columns of data, like data you'd find in a database.</p>
<dl class='dl-vertical'>
  <dt>
    <strong></strong><strong>insert()</strong><strong></strong>
  </dt>
  <dd>
    <p>Vectors try to stay the same size when they accept new elements, \s-1FIFO\s0 style.     my $v1 = vector(1,2,3); # a 3 touple        $v1-&gt;<strong>insert</strong>(4); # still a 3 touple</p><p>    print "$v1&#92;n"; # prints: [2, 3, 4]</p><p>    $v1-&gt;<strong>insert</strong>(7); # still a 3 touple     print "$v1&#92;n"; # prints: [3, 4, 7] All of the other Statistics::Basic modules have this function too.  The modules that track two vectors will need two arguments to insert though.     my $mean = mean([1,2,3]);        $mean-&gt;<strong>insert</strong>(4);</p><p>    print "mean: $mean&#92;n"; # prints 3 ... (2+3+4)/3</p><p>    my $correlation = correlation($mean-&gt;query_vector,         $mean-&gt;query_vector-&gt;copy);</p><p>    print "correlation: $correlation&#92;n"; # 1</p><p>    $correlation-&gt;insert(3,4);     print "correlation: $correlation&#92;n"; # 0.5 Also, note that the underlying vectors keep track of recalculating automatically.     my $v = vector(1,2,3);     my $m = mean($v);     my $s = stddev($v); The mean has not been calculated yet.     print "$s; $m&#92;n"; # 0.82; 2 The mean has been calculated once (even though the Statistics::Basic::StdDev uses it).     $v-&gt;<strong>insert</strong>(4); print "$s; $m&#92;n"; 0.82; 3     $m-&gt;<strong>insert</strong>(5); print "$s; $m&#92;n"; 0.82; 4     $s-&gt;<strong>insert</strong>(6); print "$s; $m&#92;n"; 0.82; 5 The mean has been calculated thrice more and only thrice more.</p>
  </dd>
  <dt>
    <strong></strong><strong>append()</strong><strong></strong> <strong></strong><strong>ginsert()</strong><strong></strong>
  </dt>
  <dd>
    <p>You can grow the vectors instead of sliding them (\s-1FIFO\s0). For this, use \*(C`append()\*(C' (or \*(C`ginsert()\*(C', same thing).     my $v = vector(1,2,3);     my $m = mean($v);     my $s = stddev($v);</p><p>    $v-&gt;<strong>append</strong>(4); print "$s; $m&#92;n"; 1.12; 2.5     $m-&gt;<strong>append</strong>(5); print "$s; $m&#92;n"; 1.41; 3     $s-&gt;<strong>append</strong>(6); print "$s; $m&#92;n"; 1.71; 1.71</p><p>    print "$v&#92;n"; # [1, 2, 3, 4, 5, 6]     print "$s&#92;n"; # 1.71 Of course, with a correlation, or a covariance, it'd look more like this:     my $c = correlation([1,2,3], [3,4,5]);        $c-&gt;append(7,7);</p><p>    print "c=$c&#92;n"; # c=0.98</p>
  </dd>
  <dt>
    <strong></strong><strong>set_vector()</strong><strong></strong>
  </dt>
  <dd>
    <p>This allows you to set the vector to a known state.  It takes either array ref or vector objects.     my $v1 = vector(1,2,3);     my $v2 = $v1-&gt;copy;        $v2-&gt;set_vector([4,5,6]);</p><p>    my $m = mean();</p><p>    $m-&gt;set_vector([1,2,3]);     $m-&gt;set_vector($v2);</p><p>    my $c = correlation();</p><p>    $c-&gt;set_vector($v1,$v2);     $c-&gt;set_vector([1,2,3], [4,5,6]);</p>
  </dd>
  <dt>
    <strong></strong><strong>set_size()</strong><strong></strong>
  </dt>
  <dd>
    <p>This sets the size of the vector.  When the vector is made bigger, the vector is filled to the new length with leading zeros (i.e., they are the first to be kicked out after new \*(C`insert()\*(C's.     my $v = vector(1,2,3);        $v-&gt;<strong>set_size</strong>(7);</p><p>    print "$v&#92;n"; # [0, 0, 0, 0, 1, 2, 3]</p><p>    my $m = mean();        $m-&gt;<strong>set_size</strong>(7);</p><p>    print "", $m-&gt;query_vector, "&#92;n";      # [0, 0, 0, 0, 0, 0, 0]</p><p>    my $c = correlation([3],[3]);        $c-&gt;<strong>set_size</strong>(7);</p><p>    print "", $c-&gt;query_vector1, "&#92;n";     print "", $c-&gt;query_vector2, "&#92;n";      # [0, 0, 0, 0, 0, 0, 3]      # [0, 0, 0, 0, 0, 0, 3]</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>Each of the following options can be specified on package import like this.</p><p>    use Statistics::Basic qw(unbias=0); # start with unbias disabled     use Statistics::Basic qw(unbias=1); # start with unbias enabled</p><p>When specified on import, each option has certain defaults.</p><p>    use Statistics::Basic qw(unbias); # start with unbias enabled     use Statistics::Basic qw(nofill); # start with nofill enabled     use Statistics::Basic qw(toler);  # start with toler disabled     use Statistics::Basic qw(ipres);  # start with ipres=2</p><p>Additionally, with the exception of \*(L"ignore_env\*(R", they can all be accessed via package variables of the same name in all upper case.  Example:</p><p>    # code code code</p><p>    $Statistics::Basic::UNBIAS = 0; # turn UNBIAS off</p><p>    # code code code</p><p>    $Statistics::Basic::UNBIAS = 1; # turn it back on</p><p>    # code code code</p><p>    {         local $Statistics::Basic::DEBUG_STATS_B = 1; # debug, this block only     }</p><p>Special caveat: \*(L"toler\*(R" can in fact be changed via the package var (e.g., \*(C`$Statistics::Basic::TOLER=0.0001\*(C').  But, for speed reasons, it must be defined before any other packages are imported or it will not actually do anything when changed.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>unbias</strong>
  </dt>
  <dd>
    <p>This module uses the <strong>sum(X - mean(X))/N</strong> definition of variance. If you wish to use the <em>unbiased</em>, <strong>sum(X-mean(X)/(N-1)</strong> definition, then set the $Statistics::Basic::UNBIAS true (possibly with \*(C`use Statistics::Basic qw(unbias)\*(C'). This can be changed at any time with the package variable or at compile time. This feature was requested by \*(C`Robert McGehee &lt;xxxxxxxx@wso.williams.edu&gt;\*(C'. [\s-1NOTE\s0 2008-11-06: http://cpanratings.perl.org/dist/Statistics-Basic &lt;http://cpanratings.perl.org/dist/Statistics-Basic&gt;, this can also be called "<strong>population (n)</strong>\*(L" vs \*(R"<strong>sample (n-1)</strong>" and is indeed fully addressed right here!]</p>
  </dd>
  <dt>
    <strong>ipres</strong>
  </dt>
  <dd>
    <p>\*(C`ipres\*(C' defaults to 2.  It is passed to Number::Format as the second argument to <em>format_number()</em> during string interpolation (see: overload).</p>
  </dd>
  <dt>
    <strong>toler</strong>
  </dt>
  <dd>
    <p>When set, $Statistics::Basic::TOLER (which is not enabled by default), instructs the stats objects to test true when <em>within</em> some tolerable range, pretty much like this:     sub is_equal {         return abs($_[0]-$_[1])&lt;$Statistics::Basic::TOLER             if defined($Statistics::Basic::TOLER)</p><p>        return $_[0] == $_[1]     } For performance reasons, this must be defined before the import of any other Statistics::Basic modules or the modules will fail to overload the \*(C`==\*(C' operator. $Statistics::Basic::TOLER totally disabled:     use Statistics::Basic qw(:all toler); $Statistics::Basic::TOLER disabled, but changeable:     use Statistics::Basic qw(:all toler=0);</p><p>    $Statistics::Basic::TOLER = 0.000_001; You can <em>change</em> the tolerance at runtime, but it must be set (or unset) at compile time before the packages load.</p>
  </dd>
  <dt>
    <strong>nofill</strong>
  </dt>
  <dd>
    <p>Normally when you set the size of a vector it automatically fills with zeros on the first-out side of the vector.  You can disable the autofilling with this option.  It can be changed at any time.</p>
  </dd>
  <dt>
    <strong>debug</strong>
  </dt>
  <dd>
    <p>Enable debugging with \*(C`use Statistics::Basic qw(debug)\*(C' or disable a specific level (including 0 to disable) with \*(C`use Statistics::Basic qw(debug=2)\*(C'. This is also accessible at runtime using $Statistics::Basic::DEBUG_STATS_B and can be switched on and off at any time.</p>
  </dd>
  <dt>
    <strong>ignore_env</strong>
  </dt>
  <dd>
    <p>Normally the defaults for these options can be changed in the environment of the program.  Example:     UNBIAS=1 perl ./myprog.pl This does the same thing as \*(C`$Statistics::Basic::UNBIAS=1\*(C' or \*(C`use Statistics::Basic qw(unbias)\*(C' unless you disable the %ENV checking with this option.     use Statistics::Basic qw(ignore_env);</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT VARIABLES</h2>
        <div class="sectioncontent">
<p>You can change the defaults (assuming ignore_env is not used) from your bash prompt.  Example:</p><p>    DEBUG_STATS_B=1 perl ./myprog.pl Sets the default value of \*(L"debug\*(R". Sets the default value of \*(L"unbias\*(R". Sets the default value of \*(L"nofill\*(R". Sets the default value of \*(L"ipres\*(R". Sets the default value of \*(L"toler\*(R".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERLOADS</h2>
        <div class="sectioncontent">
<p>All of the objects are true in numeric context.  All of the objects print useful strings when evaluated as a string.  Most of the objects evaluate usefully as numbers, although Statistics::Basic::Vector objects, Statistics::Basic::ComputedVector objects, and Statistics::Basic::LeastSquareFit objects do not \*(-- they instead raise an error.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author's note on Statistics::Descriptive</h2>
        <div class="sectioncontent">
<p>I've been asked a couple times now why I don't link to Statistics::Descriptive in my see also section.  As a rule, I only link to packages there that I think are related or that I actually used in the package construction.  I've never personally used Descriptive, but it surely seems to do quite a lot more.  In a sense, this package really doesn't do statistics, not like a scientist would think about it anyway.  So I always figured people could find their own way to Descriptive anyway.</p><p>The one thing this package does do, that I don't think Descriptive does (correct me if I'm wrong) is time difference computations.  If there are say, 200 things in the mean object, then after inserting (using this package) there'll still be 200 things, allowing the computation of a moving average, moving stddev, moving correlation, etc.  You might argue that this is rarely needed, but it is really the only time I need to compute these things.</p><p>  while( $data = $fetch_sth-&gt;fetchrow_arrayref ) {       $mean-&gt;insert($data);       $moving_avg_sth-&gt;execute(0 + $mean);   }</p><p>Since I opened the topic I'd also like to mention that I find this package easier to use.  That is a matter of taste and since I wrote this, you might say I'm a little biased.  Your mileage may vary.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Paul Miller \*(C`&lt;jettero@cpan.org&gt;\*(C'</p><p>I am using this software in my own projects...  If you find bugs, please please please let me know. :) Actually, let me know if you find it handy at all.  Half the fun of releasing this stuff is knowing that people use it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2012 Paul Miller \*(-- Licensed under the \s-1LGPL\s0 version 2.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Statistics::Basic&hellip;</h2>
        <div class="sectioncontent">
<p><em>perl</em>\|(1), Number::Format, overload, Statistics::Basic::Vector, Statistics::Basic::ComputedVector, Statistics::Basic::_OneVectorBase, Statistics::Basic::Mean, Statistics::Basic::Median, Statistics::Basic::Mode, Statistics::Basic::Variance, Statistics::Basic::StdDev, Statistics::Basic::_TwoVectorBase, Statistics::Basic::Correlation, Statistics::Basic::Covariance, Statistics::Basic::LeastSquareFit</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Stat::lsMode.3pm.html"><span aria-hidden="true">&larr;</span> Stat::lsMode.3pm: Format file modes like the \*(c`ls -l\*(c' command does</a></li>
   <li class="next"><a href="Statistics::Basic::ComputedVector.3pm.html">Statistics::Basic::ComputedVector.3pm: A class for computing filtered vectors <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

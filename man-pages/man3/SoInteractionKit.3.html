<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoInteractionKit: The sointeractionkit class is a base class for draggers.  this nodekit class makes it possible to set surrogate paths for parts. instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction. all picks on this path will be handled by the dragger.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sointeractionkit class is a base class for draggers.  this nodekit class makes it possible to set surrogate paths for parts. instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction. all picks on this path will be handled by the dragger.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoInteractionKit (3) manual">
  <meta name="twitter:description" content="The sointeractionkit class is a base class for draggers.  this nodekit class makes it possible to set surrogate paths for parts. instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction. all picks on this path will be handled by the dragger.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoInteractionKit-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoInteractionKit.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoInteractionKit (3) manual" />
  <meta property="og:description" content="The sointeractionkit class is a base class for draggers.  this nodekit class makes it possible to set surrogate paths for parts. instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction. all picks on this path will be handled by the dragger." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoInteractionKit-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoInteractionKit<small> (3)</small></h1>
        <p class="lead">The sointeractionkit class is a base class for draggers.  this nodekit class makes it possible to set surrogate paths for parts. instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction. all picks on this path will be handled by the dragger.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoInteractionKit.3.html">
      <span itemprop="name">SoInteractionKit: The sointeractionkit class is a base class for draggers.  this nodekit class makes it possible to set surrogate paths for parts. instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction. all picks on this path will be handled by the dragger.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoInteractionKit.3.html">
      <span itemprop="name">SoInteractionKit: The sointeractionkit class is a base class for draggers.  this nodekit class makes it possible to set surrogate paths for parts. instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction. all picks on this path will be handled by the dragger.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/nodekits/SoInteractionKit.h&gt;</p><p>Inherits <strong>SoBaseKit</strong>.</p><p>Inherited by <strong>SoDragger</strong>.</p><h3>Public Types</h3>
<p>enum <strong>CacheEnabled</strong> { <strong>OFF</strong>, <strong>ON</strong>, <strong>AUTO</strong> }</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> virtual const <strong>SoNodekitCatalog</strong> * <strong>getNodekitCatalog</strong> (void) const </p><p><strong>SoInteractionKit</strong> (void)</p><p>virtual SbBool <strong>setPartAsPath</strong> (const <strong>SbName</strong> &partname, <strong>SoPath</strong> *path)</p><p>virtual SbBool <strong>setPartAsDefault</strong> (const <strong>SbName</strong> &partname, <strong>SoNode</strong> *node, SbBool onlyifdefault=TRUE)</p><p>virtual SbBool <strong>setPartAsDefault</strong> (const <strong>SbName</strong> &partname, const <strong>SbName</strong> &nodename, SbBool onlyifdefault=TRUE)</p><p>SbBool <strong>isPathSurrogateInMySubgraph</strong> (const <strong>SoPath</strong> *path, <strong>SoPath</strong> *&pathToOwner, <strong>SbName</strong> &surrogatename, <strong>SoPath</strong> *&surrogatepath, SbBool fillargs=TRUE)</p><p>SbBool <strong>isPathSurrogateInMySubgraph</strong> (const <strong>SoPath</strong> *path)</p><p>virtual SbBool <strong>setPart</strong> (const <strong>SbName</strong> &partname, <strong>SoNode</strong> *from)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static const <strong>SoNodekitCatalog</strong> * <strong>getClassNodekitCatalog</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p><p>static void <strong>setSwitchValue</strong> (<strong>SoNode</strong> *node, const int newVal)</p>
<h3>Public Attributes</h3>
<p><strong>SoSFEnum</strong> <strong>renderCaching</strong></p><p><strong>SoSFEnum</strong> <strong>boundingBoxCaching</strong></p><p><strong>SoSFEnum</strong> <strong>renderCulling</strong></p><p><strong>SoSFEnum</strong> <strong>pickCulling</strong></p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual <strong>~SoInteractionKit</strong> ()</p><p>virtual void <strong>copyContents</strong> (const <strong>SoFieldContainer</strong> *fromFC, SbBool copyConnections)</p><p>virtual SbBool <strong>setPart</strong> (const int partNum, <strong>SoNode</strong> *node)</p><p>virtual SbBool <strong>readInstance</strong> (<strong>SoInput</strong> *in, unsigned short flags)</p><p>virtual SbBool <strong>setAnyPartAsDefault</strong> (const <strong>SbName</strong> &partname, <strong>SoNode</strong> *node, SbBool anypart=TRUE, SbBool onlyifdefault=TRUE)</p><p>virtual SbBool <strong>setAnyPartAsDefault</strong> (const <strong>SbName</strong> &partname, const <strong>SbName</strong> &nodename, SbBool anypart=TRUE, SbBool onlyifdefault=TRUE)</p><p>SbBool <strong>setAnySurrogatePath</strong> (const <strong>SbName</strong> &name, <strong>SoPath</strong> *path, SbBool leafcheck=FALSE, SbBool publiccheck=FALSE)</p><p>virtual SbBool <strong>setUpConnections</strong> (SbBool onoff, SbBool doitalways=FALSE)</p><p>virtual void <strong>setDefaultOnNonWritingFields</strong> ()</p><p>void <strong>connectSeparatorFields</strong> (<strong>SoSeparator</strong> *dest, SbBool onOff)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p><p>static const <strong>SoNodekitCatalog</strong> ** <strong>getClassNodekitCatalogPtr</strong> (void)</p><p>static void <strong>readDefaultParts</strong> (const char *fileName, const char defaultBuffer[], int defBufSize)</p><p>static void <strong>fieldSensorCB</strong> (void *, <strong>SoSensor</strong> *)</p>
<h3>Protected Attributes</h3>
<p><strong>SoSFNode</strong> <strong>geomSeparator</strong></p><p><strong>SoSFNode</strong> <strong>topSeparator</strong></p><p><strong>SoFieldSensor</strong> * <strong>fieldSensor</strong></p><p><strong>SoSeparator</strong> * <strong>oldTopSep</strong></p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoInteractionKit</strong> class is a base class for draggers.</p><p>This nodekit class makes it possible to set surrogate paths for parts. Instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction. All picks on this path will be handled by the dragger.</p><p>The <strong>SoInteractionKit</strong> is primarily an internal class used as a superclass for the dragger classes, and it is unlikely that it should be of interest to application programmers, unless you have very special needs in your application.</p><p>Node kit structure (new entries versus parent class marked with arrow prefix):</p>
<pre>
CLASS SoInteractionKit
--&gt;"this"
      "callbackList"
--&gt;   "topSeparator"
--&gt;      "geomSeparator"
</pre>
<p>(See <strong>SoBaseKit::printDiagram()</strong> for information about the output formatting.)</p><p>Detailed information on catalog parts:</p>
<pre>
CLASS SoInteractionKit
PVT   "this",  SoInteractionKit  ---
      "callbackList",  SoNodeKitListPart [ SoCallback, SoEventCallback ]
PVT   "topSeparator",  SoSeparator  ---
PVT   "geomSeparator",  SoSeparator  ---
</pre>
<p>(See <strong>SoBaseKit::printTable()</strong> for information about the output formatting.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoInteractionKit::CacheEnabled\fP</h3>
<p>Enumeration of valid values for the cache control fields <strong>SoInteractionKit::renderCaching</strong>, <strong>SoInteractionKit::boundingBoxCaching</strong>, <strong>SoInteractionKit::renderCulling</strong> and <strong>SoInteractionKit::pickCulling</strong>.</p><p>The same values with the same semantics are present in this enum as for <strong>SoSeparator::CacheEnabled</strong>, so see that documentation.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoInteractionKit::SoInteractionKit (void)</h3>
<p>Constructor.</p>
<h3>SoInteractionKit::~SoInteractionKit ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoInteractionKit::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoDragger</strong>, <strong>SoTrackballDragger</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTransformerDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTranslate1Dragger</strong>, <strong>SoTranslate2Dragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScaleUniformDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoPointLightDragger</strong>, and <strong>SoTabBoxDragger</strong>.</p>
<h3>const \fBSoFieldData\fP * SoInteractionKit::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoDragger</strong>, <strong>SoTrackballDragger</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTransformerDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTranslate1Dragger</strong>, <strong>SoTranslate2Dragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScaleUniformDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoPointLightDragger</strong>, and <strong>SoTabBoxDragger</strong>.</p>
<h3>const \fBSoNodekitCatalog\fP * SoInteractionKit::getNodekitCatalog (void) const\fC [virtual]\fP</h3>
<p>Returns the nodekit catalog which defines the layout of this class' kit.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoDragger</strong>, <strong>SoTrackballDragger</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTransformerDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTranslate1Dragger</strong>, <strong>SoTranslate2Dragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScaleUniformDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoPointLightDragger</strong>, and <strong>SoTabBoxDragger</strong>.</p>
<h3>SbBool SoInteractionKit::setPartAsPath (const \fBSbName\fP &partname, \fBSoPath\fP *path)\fC [virtual]\fP</h3>
<p>Sets a part in the kit as a surrogate path. The <em>partname</em> part is set to NULL<em>, and the surrogate path is remembered. Following picks on the surrogate path will be regarded as a pick on </em><em>partname</em><em>.</em></p>
<h3>SbBool SoInteractionKit::setPartAsDefault (const \fBSbName\fP &partname, \fBSoNode\fP *node, SbBoolonlyifdefault = \fCTRUE\fP)\fC [virtual]\fP</h3>
<p>Sets the value of <em>partname</em> to <em>node</em>, and sets the part's field to default (i.e. node will not be written on scene graph export).</p><p>If <em>onlyifdefault</em> is TRUE<em>, </em><em>partname</em><em> is only set if it is already in the default state.</em></p><p>The reason for this method is to make it possible for dragger subclasses to avoid having their default parts written out on export.</p>
<h3>SbBool SoInteractionKit::setPartAsDefault (const \fBSbName\fP &partname, const \fBSbName\fP &nodename, SbBoolonlyifdefault = \fCTRUE\fP)\fC [virtual]\fP</h3>
<p>Find node in the global dictionary, and set as default.</p><p><strong>See also:</strong></p><p><strong>setPartAsDefault()</strong></p>
<h3>SbBool SoInteractionKit::isPathSurrogateInMySubgraph (const \fBSoPath\fP *path, \fBSoPath\fP *&pathToOwner, \fBSbName\fP &surrogatename, \fBSoPath\fP *&surrogatepath, SbBoolfillargs = \fCTRUE\fP)</h3>
<p>Checks if <em>path</em> is contained within any of the surrogate paths in any interaction kits from this node down. Returns information about the owner and the surrogate path if found, and <em>fillargs</em> is <em>TRUE</em>. The returned path (<em>pathToOwner</em>) is not ref'ed, It's the callers responsibility to ref and unref this path.</p>
<h3>SbBool SoInteractionKit::isPathSurrogateInMySubgraph (const \fBSoPath\fP *path)</h3>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<h3>void SoInteractionKit::setSwitchValue (\fBSoNode\fP *node, const intnewVal)\fC [static]\fP</h3>
<p>Convenience method that sets the switch value for a switch node. Checks if node != 0, and only sets the switch value if value has changed.</p>
<h3>SbBool SoInteractionKit::setPart (const \fBSbName\fP &partname, \fBSoNode\fP *from)\fC [virtual]\fP</h3>
<p>Sets the catalog part given by <em>partname</em> to the <em>from</em> node pointer.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>void SoInteractionKit::copyContents (const \fBSoFieldContainer\fP *from, SbBoolcopyconnections)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Makes a deep copy of all data of <em>from</em> into this instance, <em>except</em> external scenegraph references if <em>copyconnections</em> is FALSE<em>.</em></p><p>This is the method that should be overridden by extension node / engine / dragger / whatever subclasses which needs to account for internal data that are not handled automatically.</p><p>For copying nodes from application code, you should not invoke this function directly, but rather call the <strong>SoNode::copy()</strong> function:</p>
<pre>
SoNode * mynewnode = templatenode-&gt;copy();
</pre>
<p>The same also goes for engines.</p><p>Make sure that when you override the <strong>copyContents()</strong> method in your extension class that you also make it call upwards to it's parent superclass in the inheritance hierarchy, as <strong>copyContents()</strong> in for instance <strong>SoNode</strong> and <strong>SoFieldContainer</strong> does important work. It should go something like this:</p>
<pre>
void
MyCoinExtensionNode::copyContents(const SoFieldContainer * from,
                                  SbBool copyconnections)
{
  // let parent superclasses do their thing (copy fields, copy
  // instance name, etc etc)
  SoNode::copyContents(from, copyconnections);

  // [..then copy internal data..]
}
</pre>
<p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoRotateSphericalDragger</strong>, and <strong>SoRotateCylindricalDragger</strong>.</p>
<h3>SbBool SoInteractionKit::setPart (const intpartnum, \fBSoNode\fP *node)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Sets parts, updates nodekit scene graph, and makes sure graph is valid with respect to right siblings and parent. This method is virtual to enable subclasses to detect when a part changes value.</p><p>This method is not part of the original SGI Open Inventor API, but is an extension specific to Coin.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>SbBool SoInteractionKit::readInstance (\fBSoInput\fP *in, unsigned shortflags)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method is mainly intended for internal use during file import operations.</p><p>It reads a definition of an instance from the input stream <em>in</em>. The input stream state points to the start of a serialized / persistant representation of an instance of this class type.</p><p>TRUE or FALSE is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not. The import process should be robust and handle corrupted input streams by returning FALSE.</p><p><em>flags</em> is used internally during binary import when reading user extension nodes, group nodes or engines.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>void SoInteractionKit::readDefaultParts (const char *fileName, const chardefaultBuffer[], intdefBufSize)\fC [static]\fP, \fC [protected]\fP</h3>
<p>Reads default parts for a dragger.</p><p>This method is called from dragger constructors to set up a dragger's nodekit catalog of interaction and feedback geometry.</p><p><em>fileName</em> is the user-changeable resource file in the Inventor file format, while <em>defaultBuffer</em> and <em>defBufSize</em> can point to the statically compiled default parts.</p><p>The environment variable SO_DRAGGER_DIR must be set to a valid directory prefix for <em>fileName</em>, or no resource file will be loaded (and <em>defaultBuffer</em> will be used instead).</p><p>If both a <em>fileName</em> and a <em>defaultBuffer</em> is provided, the file will be attempted found and loaded first, if that fails, the geometry will be attempted read from the buffer.</p>
<h3>SbBool SoInteractionKit::setAnyPartAsDefault (const \fBSbName\fP &partname, const \fBSbName\fP &nodename, SbBoolanypart = \fCTRUE\fP, SbBoolonlyifdefault = \fCTRUE\fP)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Protected version of <strong>setPartAsDefault()</strong>, to make it possible to set non-leaf and private parts (if anypart is TRUE<strong>).</strong></p><p><strong>See also:</strong></p><p><strong>setPartAsDefault()</strong></p>
<h3>SbBool SoInteractionKit::setAnySurrogatePath (const \fBSbName\fP &partname, \fBSoPath\fP *path, SbBoolleafcheck = \fCFALSE\fP, SbBoolpubliccheck = \fCFALSE\fP)\fC [protected]\fP</h3>
<p>Protected version of <strong>setPartAsPath()</strong>, to make it possible to set non-leaf and private parts.</p><p>('The nice thing about C++ is that only your friends can handle your private parts.')</p><p><strong>See also:</strong></p><p><strong>setPartAsPath()</strong></p>
<h3>SbBool SoInteractionKit::setUpConnections (SbBoolonoff, SbBooldoitalways = \fCFALSE\fP)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Sets up all internal connections for instances of this class.</p><p>(This method will usually not be of interest to the application programmer, unless you want to extend the library with new custom nodekits or dragger classes. If so, see the <strong>SoBaseKit</strong> class documentation.)</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoTransformerDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoTrackballDragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTabBoxDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTranslate2Dragger</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoTranslate1Dragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScaleUniformDragger</strong>, and <strong>SoPointLightDragger</strong>.</p>
<h3>void SoInteractionKit::setDefaultOnNonWritingFields (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>(Be aware that this method is unlikely to be of interest to the application programmer who does not want to extend the library with new custom nodekits or draggers. If you indeed <em>are</em> writing extensions, see the information in the <strong>SoBaseKit</strong> class documentation.)</p><p>This is a virtual method, and the code in it should call <strong>SoField::setDefault()</strong> with argument TRUE<strong> on part fields that should not be written upon scenegraph export operations.</strong></p><p>This is typically done when:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>field value is NULL and part is NULL by default</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    2.
  </dt>
  <dd>
    <p>it is a leaf <strong>SoGroup</strong> or <strong>SoSeparator</strong> node with no children</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    3.
  </dt>
  <dd>
    <p>it is a leaf listpart with no children and an <strong>SoGroup</strong> or <strong>SoSeparator</strong> container</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    4.
  </dt>
  <dd>
    <p>it is a non-leaf part and it's of <strong>SoGroup</strong> type and all fields are at their default values</p>
  </dd>

</dl>
<p>Subclasses should usually override this to do additional settings for new member fields. From the subclass, do remember to call 'upwards' to your superclass' <strong>setDefaultOnNonWritingFields()</strong> method.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoTransformerDragger</strong>, <strong>SoDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoTrackballDragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTabBoxDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, and <strong>SoPointLightDragger</strong>.</p>
<h3>void SoInteractionKit::fieldSensorCB (void *d, \fBSoSensor\fP *s)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoInteractionKit::connectSeparatorFields (\fBSoSeparator\fP *dest, SbBoolonOff)\fC [protected]\fP</h3>
<p>Obsoleted in Coin.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoSFEnum\fP SoInteractionKit::renderCaching</h3>
<p>Controls the value of the <strong>SoSeparator::renderCaching</strong> field in the <strong>SoInteractionKit</strong> catalog's topSeparator instance.</p><p>See documentation of <strong>SoSeparator::renderCaching</strong>.</p>
<h3>\fBSoSFEnum\fP SoInteractionKit::boundingBoxCaching</h3>
<p>Controls the value of the <strong>SoSeparator::boundingBoxCaching</strong> field in the <strong>SoInteractionKit</strong> catalog's topSeparator instance.</p><p>See documentation of <strong>SoSeparator::boundingBoxCaching</strong>.</p>
<h3>\fBSoSFEnum\fP SoInteractionKit::renderCulling</h3>
<p>Controls the value of the <strong>SoSeparator::renderCulling</strong> field in the <strong>SoInteractionKit</strong> catalog's topSeparator instance.</p><p>See documentation of <strong>SoSeparator::renderCulling</strong>.</p>
<h3>\fBSoSFEnum\fP SoInteractionKit::pickCulling</h3>
<p>Controls the value of the <strong>SoSeparator::pickCulling</strong> field in the <strong>SoInteractionKit</strong> catalog's topSeparator instance.</p><p>See documentation of <strong>SoSeparator::pickCulling</strong>.</p>
<h3>\fBSoFieldSensor\fP * SoInteractionKit::fieldSensor\fC [protected]\fP</h3>
<p>Obsoleted in Coin.</p>
<h3>\fBSoFieldSensor\fP * SoInteractionKit::oldTopSep\fC [protected]\fP</h3>
<p>Obsoleted in Coin.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoInteraction.3.html"><span aria-hidden="true">&larr;</span> SoInteraction.3: The sointeraction class takes care of initalizing internal classes.  sointeraction is present for the sole purpose of providing an interface to the initialization methods of the classes in coin which are somehow related to user interaction, like the draggers and manipulators.</a></li>
   <li class="next"><a href="SoInterpolate.3.html">SoInterpolate.3: The sointerpolate class is the base class for all interpolator engines.  interpolators are used to linearly interpolate between two values. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

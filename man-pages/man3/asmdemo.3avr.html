<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>asmdemo: For time- or space-critical applications, it can often be desirable to combine c code (for easy maintenance) and assembly code (for maximal speed or minimal code size) together. this demo provides an example of how to do that.  the objective of the demo is to decode radio-controlled model pwm signals, and control an output pwm based on the current input signal's value. the incoming pwm pulses follow a standard encoding scheme where a pulse width of 920 microseconds denotes one end of the scale (represented as 0 % pulse width on output), and 2120 microseconds mark the other end (100 % output pwm). normally, multiple channels would be encoded that way in subsequent pulses, followed by a larger gap, so the entire frame will repeat each 14 through 20 ms, but this is ignored for the purpose of the demo, so only a single input pwm channel is assumed.  the basic challenge is to use the cheapest controller available for the task, an attiny13 that has only a single timer channel. as this timer channel is required to run the outgoing pwm signal generation, the incoming pwm decoding had to be adjusted to the constraints set by the outgoing pwm.  as pwm generation toggles the counting direction of timer 0 between up and down after each 256 timer cycles, the current time cannot be deduced by reading tcnt0 only, but the current counting direction of the timer needs to be considered as well. this requires servicing interrupts whenever the timer hits top (255) and bottom (0) to learn about each change of the counting direction. for pwm generation, it is usually desired to run it at the highest possible speed so filtering the pwm frequency from the modulated output signal is made easy. thus, the pwm timer runs at full cpu speed. this causes the overflow and compare match interrupts to be triggered each 256 cpu clocks, so they must run with the minimal number of processor cycles possible in order to not impose a too high cpu load by these interrupt service routines. this is the main reason to implement the entire interrupt handling in fine-tuned assembly code rather than in c.  in order to verify parts of the algorithm, and the underlying hardware, the demo has been set up in a way so the pin-compatible but more expensive attiny45 (or its siblings attiny25 and attiny85) could be used as well. in that case, no separate assembly code is required, as two timer channels are avaible.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="For time- or space-critical applications, it can often be desirable to combine c code (for easy maintenance) and assembly code (for maximal speed or minimal code size) together. this demo provides an example of how to do that.  the objective of the demo is to decode radio-controlled model pwm signals, and control an output pwm based on the current input signal's value. the incoming pwm pulses follow a standard encoding scheme where a pulse width of 920 microseconds denotes one end of the scale (represented as 0 % pulse width on output), and 2120 microseconds mark the other end (100 % output pwm). normally, multiple channels would be encoded that way in subsequent pulses, followed by a larger gap, so the entire frame will repeat each 14 through 20 ms, but this is ignored for the purpose of the demo, so only a single input pwm channel is assumed.  the basic challenge is to use the cheapest controller available for the task, an attiny13 that has only a single timer channel. as this timer channel is required to run the outgoing pwm signal generation, the incoming pwm decoding had to be adjusted to the constraints set by the outgoing pwm.  as pwm generation toggles the counting direction of timer 0 between up and down after each 256 timer cycles, the current time cannot be deduced by reading tcnt0 only, but the current counting direction of the timer needs to be considered as well. this requires servicing interrupts whenever the timer hits top (255) and bottom (0) to learn about each change of the counting direction. for pwm generation, it is usually desired to run it at the highest possible speed so filtering the pwm frequency from the modulated output signal is made easy. thus, the pwm timer runs at full cpu speed. this causes the overflow and compare match interrupts to be triggered each 256 cpu clocks, so they must run with the minimal number of processor cycles possible in order to not impose a too high cpu load by these interrupt service routines. this is the main reason to implement the entire interrupt handling in fine-tuned assembly code rather than in c.  in order to verify parts of the algorithm, and the underlying hardware, the demo has been set up in a way so the pin-compatible but more expensive attiny45 (or its siblings attiny25 and attiny85) could be used as well. in that case, no separate assembly code is required, as two timer channels are avaible.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="asmdemo (3avr) manual">
  <meta name="twitter:description" content="For time- or space-critical applications, it can often be desirable to combine c code (for easy maintenance) and assembly code (for maximal speed or minimal code size) together. this demo provides an example of how to do that.  the objective of the demo is to decode radio-controlled model pwm signals, and control an output pwm based on the current input signal's value. the incoming pwm pulses follow a standard encoding scheme where a pulse width of 920 microseconds denotes one end of the scale (represented as 0 % pulse width on output), and 2120 microseconds mark the other end (100 % output pwm). normally, multiple channels would be encoded that way in subsequent pulses, followed by a larger gap, so the entire frame will repeat each 14 through 20 ms, but this is ignored for the purpose of the demo, so only a single input pwm channel is assumed.  the basic challenge is to use the cheapest controller available for the task, an attiny13 that has only a single timer channel. as this timer channel is required to run the outgoing pwm signal generation, the incoming pwm decoding had to be adjusted to the constraints set by the outgoing pwm.  as pwm generation toggles the counting direction of timer 0 between up and down after each 256 timer cycles, the current time cannot be deduced by reading tcnt0 only, but the current counting direction of the timer needs to be considered as well. this requires servicing interrupts whenever the timer hits top (255) and bottom (0) to learn about each change of the counting direction. for pwm generation, it is usually desired to run it at the highest possible speed so filtering the pwm frequency from the modulated output signal is made easy. thus, the pwm timer runs at full cpu speed. this causes the overflow and compare match interrupts to be triggered each 256 cpu clocks, so they must run with the minimal number of processor cycles possible in order to not impose a too high cpu load by these interrupt service routines. this is the main reason to implement the entire interrupt handling in fine-tuned assembly code rather than in c.  in order to verify parts of the algorithm, and the underlying hardware, the demo has been set up in a way so the pin-compatible but more expensive attiny45 (or its siblings attiny25 and attiny85) could be used as well. in that case, no separate assembly code is required, as two timer channels are avaible.">
  <meta name="twitter:image" content="https://www.carta.tech/images/avr-libc-asmdemo-3avr.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3avr/asmdemo.3avr.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="asmdemo (3avr) manual" />
  <meta property="og:description" content="For time- or space-critical applications, it can often be desirable to combine c code (for easy maintenance) and assembly code (for maximal speed or minimal code size) together. this demo provides an example of how to do that.  the objective of the demo is to decode radio-controlled model pwm signals, and control an output pwm based on the current input signal's value. the incoming pwm pulses follow a standard encoding scheme where a pulse width of 920 microseconds denotes one end of the scale (represented as 0 % pulse width on output), and 2120 microseconds mark the other end (100 % output pwm). normally, multiple channels would be encoded that way in subsequent pulses, followed by a larger gap, so the entire frame will repeat each 14 through 20 ms, but this is ignored for the purpose of the demo, so only a single input pwm channel is assumed.  the basic challenge is to use the cheapest controller available for the task, an attiny13 that has only a single timer channel. as this timer channel is required to run the outgoing pwm signal generation, the incoming pwm decoding had to be adjusted to the constraints set by the outgoing pwm.  as pwm generation toggles the counting direction of timer 0 between up and down after each 256 timer cycles, the current time cannot be deduced by reading tcnt0 only, but the current counting direction of the timer needs to be considered as well. this requires servicing interrupts whenever the timer hits top (255) and bottom (0) to learn about each change of the counting direction. for pwm generation, it is usually desired to run it at the highest possible speed so filtering the pwm frequency from the modulated output signal is made easy. thus, the pwm timer runs at full cpu speed. this causes the overflow and compare match interrupts to be triggered each 256 cpu clocks, so they must run with the minimal number of processor cycles possible in order to not impose a too high cpu load by these interrupt service routines. this is the main reason to implement the entire interrupt handling in fine-tuned assembly code rather than in c.  in order to verify parts of the algorithm, and the underlying hardware, the demo has been set up in a way so the pin-compatible but more expensive attiny45 (or its siblings attiny25 and attiny85) could be used as well. in that case, no separate assembly code is required, as two timer channels are avaible." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/avr-libc-asmdemo-3avr.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">asmdemo<small> (3avr)</small></h1>
        <p class="lead">For time- or space-critical applications, it can often be desirable to combine c code (for easy maintenance) and assembly code (for maximal speed or minimal code size) together. this demo provides an example of how to do that.  the objective of the demo is to decode radio-controlled model pwm signals, and control an output pwm based on the current input signal's value. the incoming pwm pulses follow a standard encoding scheme where a pulse width of 920 microseconds denotes one end of the scale (represented as 0 % pulse width on output), and 2120 microseconds mark the other end (100 % output pwm). normally, multiple channels would be encoded that way in subsequent pulses, followed by a larger gap, so the entire frame will repeat each 14 through 20 ms, but this is ignored for the purpose of the demo, so only a single input pwm channel is assumed.  the basic challenge is to use the cheapest controller available for the task, an attiny13 that has only a single timer channel. as this timer channel is required to run the outgoing pwm signal generation, the incoming pwm decoding had to be adjusted to the constraints set by the outgoing pwm.  as pwm generation toggles the counting direction of timer 0 between up and down after each 256 timer cycles, the current time cannot be deduced by reading tcnt0 only, but the current counting direction of the timer needs to be considered as well. this requires servicing interrupts whenever the timer hits top (255) and bottom (0) to learn about each change of the counting direction. for pwm generation, it is usually desired to run it at the highest possible speed so filtering the pwm frequency from the modulated output signal is made easy. thus, the pwm timer runs at full cpu speed. this causes the overflow and compare match interrupts to be triggered each 256 cpu clocks, so they must run with the minimal number of processor cycles possible in order to not impose a too high cpu load by these interrupt service routines. this is the main reason to implement the entire interrupt handling in fine-tuned assembly code rather than in c.  in order to verify parts of the algorithm, and the underlying hardware, the demo has been set up in a way so the pin-compatible but more expensive attiny45 (or its siblings attiny25 and attiny85) could be used as well. in that case, no separate assembly code is required, as two timer channels are avaible.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/asmdemo.3avr.html">
      <span itemprop="name">asmdemo: For time- or space-critical applications, it can often be desirable to combine c code (for easy maintenance) and assembly code (for maximal speed or minimal code size) together. this demo provides an example of how to do that.  the objective of the demo is to decode radio-controlled model pwm signals, and control an output pwm based on the current input signal's value. the incoming pwm pulses follow a standard encoding scheme where a pulse width of 920 microseconds denotes one end of the scale (represented as 0 % pulse width on output), and 2120 microseconds mark the other end (100 % output pwm). normally, multiple channels would be encoded that way in subsequent pulses, followed by a larger gap, so the entire frame will repeat each 14 through 20 ms, but this is ignored for the purpose of the demo, so only a single input pwm channel is assumed.  the basic challenge is to use the cheapest controller available for the task, an attiny13 that has only a single timer channel. as this timer channel is required to run the outgoing pwm signal generation, the incoming pwm decoding had to be adjusted to the constraints set by the outgoing pwm.  as pwm generation toggles the counting direction of timer 0 between up and down after each 256 timer cycles, the current time cannot be deduced by reading tcnt0 only, but the current counting direction of the timer needs to be considered as well. this requires servicing interrupts whenever the timer hits top (255) and bottom (0) to learn about each change of the counting direction. for pwm generation, it is usually desired to run it at the highest possible speed so filtering the pwm frequency from the modulated output signal is made easy. thus, the pwm timer runs at full cpu speed. this causes the overflow and compare match interrupts to be triggered each 256 cpu clocks, so they must run with the minimal number of processor cycles possible in order to not impose a too high cpu load by these interrupt service routines. this is the main reason to implement the entire interrupt handling in fine-tuned assembly code rather than in c.  in order to verify parts of the algorithm, and the underlying hardware, the demo has been set up in a way so the pin-compatible but more expensive attiny45 (or its siblings attiny25 and attiny85) could be used as well. in that case, no separate assembly code is required, as two timer channels are avaible.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/avr-libc/">
      <span itemprop="name">avr-libc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/asmdemo.3avr.html">
      <span itemprop="name">asmdemo: For time- or space-critical applications, it can often be desirable to combine c code (for easy maintenance) and assembly code (for maximal speed or minimal code size) together. this demo provides an example of how to do that.  the objective of the demo is to decode radio-controlled model pwm signals, and control an output pwm based on the current input signal's value. the incoming pwm pulses follow a standard encoding scheme where a pulse width of 920 microseconds denotes one end of the scale (represented as 0 % pulse width on output), and 2120 microseconds mark the other end (100 % output pwm). normally, multiple channels would be encoded that way in subsequent pulses, followed by a larger gap, so the entire frame will repeat each 14 through 20 ms, but this is ignored for the purpose of the demo, so only a single input pwm channel is assumed.  the basic challenge is to use the cheapest controller available for the task, an attiny13 that has only a single timer channel. as this timer channel is required to run the outgoing pwm signal generation, the incoming pwm decoding had to be adjusted to the constraints set by the outgoing pwm.  as pwm generation toggles the counting direction of timer 0 between up and down after each 256 timer cycles, the current time cannot be deduced by reading tcnt0 only, but the current counting direction of the timer needs to be considered as well. this requires servicing interrupts whenever the timer hits top (255) and bottom (0) to learn about each change of the counting direction. for pwm generation, it is usually desired to run it at the highest possible speed so filtering the pwm frequency from the modulated output signal is made easy. thus, the pwm timer runs at full cpu speed. this causes the overflow and compare match interrupts to be triggered each 256 cpu clocks, so they must run with the minimal number of processor cycles possible in order to not impose a too high cpu load by these interrupt service routines. this is the main reason to implement the entire interrupt handling in fine-tuned assembly code rather than in c.  in order to verify parts of the algorithm, and the underlying hardware, the demo has been set up in a way so the pin-compatible but more expensive attiny45 (or its siblings attiny25 and attiny85) could be used as well. in that case, no separate assembly code is required, as two timer channels are avaible.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Hardware setup</h2>
        <div class="sectioncontent">
<p>The incoming PWM pulse train is fed into PB4. It will generate a pin change interrupt there on eache edge of the incoming signal.</p><p>The outgoing PWM is generated through OC0B of timer channel 0 (PB1). For demonstration purposes, a LED should be connected to that pin (like, one of the LEDs of an STK500).</p><p>The controllers run on their internal calibrated RC oscillators, 1.2 MHz on the ATtiny13, and 1.0 MHz on the ATtiny45.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">A code walkthrough</h2>
        <div class="sectioncontent">
<h3>asmdemo.c</h3>
<p>After the usual include files, two variables are defined. The first one, pwm_incoming is used to communicate the most recent pulse width detected by the incoming PWM decoder up to the main loop.</p><p>The second variable actually only constitutes of a single bit, intbits.pwm_received. This bit will be set whenever the incoming PWM decoder has updated pwm_incoming.</p><p>Both variables are marked <em>volatile</em> to ensure their readers will always pick up an updated value, as both variables will be set by interrupt service routines.</p><p>The function ioinit() initializes the microcontroller peripheral devices. In particular, it starts timer 0 to generate the outgoing PWM signal on OC0B. Setting OCR0A to 255 (which is the <em>TOP</em> value of timer 0) is used to generate a timer 0 overflow A interrupt on the ATtiny13. This interrupt is used to inform the incoming PWM decoder that the counting direction of channel 0 is just changing from up to down. Likewise, an overflow interrupt will be generated whenever the countdown reached <em>BOTTOM</em> (value 0), where the counter will again alter its counting direction to upwards. This information is needed in order to know whether the current counter value of TCNT0<em> is to be evaluated from bottom or top.</em></p><p>Further, ioinit() activates the pin-change interrupt PCINT0 on any edge of PB4. Finally, PB1 (OC0B) will be activated as an output pin, and global interrupts are being enabled.</p><p>In the ATtiny45 setup, the C code contains an ISR for PCINT0. At each pin-change interrupt, it will first be analyzed whether the interrupt was caused by a rising or a falling edge. In case of the rising edge, timer 1 will be started with a prescaler of 16 after clearing the current timer value. Then, at the falling edge, the current timer value will be recorded (and timer 1 stopped), the pin-change interrupt will be suspended, and the upper layer will be notified that the incoming PWM measurement data is available.</p><p>Function main() first initializes the hardware by calling ioinit(), and then waits until some incoming PWM value is available. If it is, the output PWM will be adjusted by computing the relative value of the incoming PWM. Finally, the pin-change interrupt is re-enabled, and the CPU is put to sleep.</p>
<h3>project.h</h3>
<p>In order for the interrupt service routines to be as fast as possible, some of the CPU registers are set aside completely for use by these routines, so the compiler would not use them for C code. This is arranged for in <strong>project.h</strong><strong>.</strong></p><p>The file is divided into one section that will be used by the assembly source code, and another one to be used by C code. The assembly part is distinguished by the preprocessing macro <strong>ASSEMBLER</strong><strong> (which will be automatically set by the compiler front-end when preprocessing an assembly-language file), and it contains just macros that give symbolic names to a number of CPU registers. The preprocessor will then replace the symbolic names by their right-hand side definitions before calling the assembler.</strong></p><p>In C code, the compiler needs to see variable declarations for these objects. This is done by using declarations that bind a variable permanently to a CPU register (see <strong>How to permanently bind a variable to a register?</strong>). Even in case the C code never has a need to access these variables, declaring the register binding that way causes the compiler to not use these registers in C code at all.</p><p>The flags variable needs to be in the range of r16 through r31 as it is the target of a <em>load immediate</em> (or SER<em>) instruction that is not applicable to the entire register file.</em></p>
<h3>isrs.S</h3>
<p>This file is a preprocessed assembly source file. The C preprocessor will be run by the compiler front-end first, resolving all #include, #define etc. directives. The resulting program text will then be passed on to the assembler.</p><p>As the C preprocessor strips all C-style comments, preprocessed assembly source files can have both, C-style (/* ... */, // ...) as well as assembly-style (; ...) comments.</p><p>At the top, the IO register definition file <strong>avr/io.h</strong><strong> and the project declaration file </strong><strong>project.h</strong><strong></strong><strong> are included. The remainder of the file is conditionally assembled only if the target MCU type is an ATtiny13, so it will be completely ignored for the ATtiny45 option.</strong></p><p>Next are the two interrupt service routines for timer 0 compare A match (timer 0 hits <em>TOP</em>, as OCR0A is set to 255) and timer 0 overflow (timer 0 hits <em>BOTTOM</em>). As discussed above, these are kept as short as possible. They only save SREG<em> (as the flags will be modified by the INC</em> instruction), increment the counter_hi<em> variable which forms the high part of the current time counter (the low part is formed by querying TCNT0</em> directly), and clear or set the variable flags<em>, respectively, in order to note the current counting direction. The RETI</em> instruction terminates these interrupt service routines. Total cycle count is 8 CPU cycles, so together with the 4 CPU cycles needed for interrupt setup, and the 2 cycles for the RJMP from the interrupt vector to the handler, these routines will require 14 out of each 256 CPU cycles, or about 5 % of the overall CPU time.</p><p>The pin-change interrupt PCINT0 will be handled in the final part of this file. The basic algorithm is to quickly evaluate the current system time by fetching the current timer value of TCNT0, and combining it with the overflow part in counter_hi. If the counter is currently counting down rather than up, the value fetched from TCNT0 must be negated. Finally, if this pin-change interrupt was triggered by a rising edge, the time computed will be recorded as the start time only. Then, at the falling edge, this start time will be subracted from the current time to compute the actual pulse width seen (left in pwm_incoming), and the upper layers are informed of the new value by setting bit 0 in the intbits flags. At the same time, this pin-change interrupt will be disabled so no new measurement can be performed until the upper layer had a chance to process the current value.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">The source code</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for avr-libc from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="asinf.3avr.html"><span aria-hidden="true">&larr;</span> asinf.3avr: Math.h: mathematics -</a></li>
   <li class="next"><a href="assembler.3avr.html">assembler.3avr: Avr-libc and assembler programs <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

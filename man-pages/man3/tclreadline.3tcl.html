<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>tclreadline: Gnu readline for the tcl scripting language</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Gnu readline for the tcl scripting language">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="tclreadline (3tcl) manual">
  <meta name="twitter:description" content="Gnu readline for the tcl scripting language">
  <meta name="twitter:image" content="https://www.carta.tech/images/tcl-tclreadline-tclreadline-3tcl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3tcl/tclreadline.3tcl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="tclreadline (3tcl) manual" />
  <meta property="og:description" content="Gnu readline for the tcl scripting language" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/tcl-tclreadline-tclreadline-3tcl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">tclreadline<small> (3tcl)</small></h1>
        <p class="lead">Gnu readline for the tcl scripting language</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tcl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tcl/tclreadline.3tcl.html">
      <span itemprop="name">tclreadline: Gnu readline for the tcl scripting language</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/tcl-tclreadline/">
      <span itemprop="name">tcl-tclreadline</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tcl/tclreadline.3tcl.html">
      <span itemprop="name">tclreadline: Gnu readline for the tcl scripting language</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>::tclreadline::readline</strong> <em>command</em> [<em>options</em>]</p>
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>tclreadline</strong> package makes the gnu readline available to the scripting language tcl. The primary purpose of the package is to facilitate the interactive script development by the means of word and file name completion as well as history expansion (well known from shells like bash).</p><p>Additionally tclreadline can also be used for tcl scripts which want to use a shell like input interface. In this case the <strong>::tclreadline::readline read</strong> command has to be called explicitly.</p><p>The advantage of <strong>tclreadline</strong> is that it uses the callback handler mechanism of the gnu readline while it processes tcl events. This way X events from a wish gui will processed as well as events from the tclreadline line interface.</p><p><strong>tclreadline</strong> is basically a shared library and a few tcl scripts which are accessed with the tcl package require command. Therefore <strong>tclreadline</strong> should work with all common extensions like <strong>blt, itcl, itk, tix ...</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMANDS</h2>
        <div class="sectioncontent">
<p>If you want to use <strong>tclreadline</strong> as a line interface for developing tcl scripts, you probably don't have to read this section. In this case the only thing you should do is to modify your .tclshrc according to the section <strong>FILES</strong>.</p><p>For the functionality of the GNU readline you should refer to the readline's documentation.</p><p>The following list will give all commands, which are currently implemented in the shared lib (e.g. libtclreadline2.1.0.so). Additional commands were introduced in a startup script <strong>tclreadlineSetup.tcl</strong>, which lives in the tclreadline installation directory. (typically something like /usr/local/lib/tclreadline ..) These commands are primarily for internal use and not documented here.</p><p>Note that all commands reside in the namespace <strong>::tclreadline::</strong>.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>::tclreadline::readline add</strong> <em>string</em></p>
  </dt>
  <dd>
    <p>adds a string to the completer. If the string contains white spaces, each of the words will be completed consecutively when hitting &lt;Tab&gt;. Example:</p>
<pre>
    ::tclreadline::readline add "button pathName ?options?"
</pre>
<p>typing but&lt;Tab&gt; will complete to button. Hitting &lt;Tab&gt; again will complete to "button pathName".  ...</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline complete</strong> <em>string</em></p>
  </dt>
  <dd>
    <p>returns 1 if <em>string</em> is a complete tcl command and 0 otherwise.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline customcompleter</strong> [<em>string</em>]</p>
  </dt>
  <dd>
    <p>Register the proc <em>string</em> as custom completer. This proc is called with exactly four arguments each time completion takes place: the word to complete ("text"), the "start" and "end" positions of this word in the line entered so far, and this line ("line"). The custom completion script should return an array of strings which is a list of completions for "text".  If there are no completions, it should return an empty string "".  The first entry in the returned list is the substitution for "text". The remaining entries are the possible completions. If the custom completion script returns an empty string and builtin completion is enabled (see <strong>tclreadline::readline builtincompleter</strong>), the builtin completer is called. <strong>tclreadline::readline customcompleter</strong> simply returns the current custom completer if called w/o <em>string</em>. To turn of custom completion, call <strong>tclreadline::readline customcompleter</strong> with an empty <em>string</em>.</p><p>Example: <strong>% puts $b&lt;TAB&gt;</strong> will call the custom completer with the four arguments <em>"$b"</em>, <em>"5"</em>, <em>"8"</em> and <em>"puts $b"</em>. The custom completer could return a string like "$bl $black $blue", which will complete "$b" to "$bl" (the longest match) and offer a list of two further matches "$black" and "$blue".</p><p>For further reference, see the proc tclreadline::ScriptCompleter in the file tclreadlineSetup.tcl.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline builtincompleter</strong> [<em>bool</em>]</p>
  </dt>
  <dd>
    <p>enable or disable the builtin completer. If the builtin completer is enabled, it will be invoked either if there is no custom completer, or the custom completer returned an empty  string. The builtin completer is on by default. <strong>tclreadline::readline builtincompleter</strong> returns the current custom completer (also, if called w/o the <em>bool</em> argument).</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline eofchar</strong> [<em>script</em>]</p>
  </dt>
  <dd>
    <p>set a script which will be called, if readline returns the eof character (this is typically the case if CTRL-D is entered at the very beginning of the line). The default for this script is "puts {}; exit". Setting this to an empty value disables any action on eof. <strong>tclreadline::readline eof</strong> returns the current eof script.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline initialize</strong> <em>historyfile</em></p>
  </dt>
  <dd>
    <p>initialize the tclreadline interface and read the history from the <em>historyfile</em>. On success an empty string is returned. This command has to be called before any other tclreadline commands.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline read</strong> <em>prompt</em></p>
  </dt>
  <dd>
    <p>prints the <em>prompt</em> to stdout and enters the tclreadline event loop. Both readline and X events are processed. Returns the (eventually history-expanded) input string. <strong>tclreadline::readline read</strong> rises an error, if an error occurs while evaluating a script completer.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline write</strong> <em>historyfile</em></p>
  </dt>
  <dd>
    <p>writes the history to the <em>historyfile</em>. This command is called automatically from the internal routine ::tclreadline::Exit. If the variable <strong>tclreadline::historyLength</strong> is non-negative, the historyfile will be truncated to hold only this number lines.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline reset-terminal</strong> [<em>terminalName</em>]</p>
  </dt>
  <dd>
    <p>w/o argument: reset the state of the terminal to what it was before tclreadline was used. With argument: reinitialize readline's idea of the terminal settings using terminalName as the terminal type. The form w/o argument might not work if tclreadline was compiled with an older version of libreadline.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline bell</strong></p>
  </dt>
  <dd>
    <p>Ring the terminal bell, obeying the setting of bell-style -- audible or visible.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::text</strong></p>
  </dt>
  <dd>
    <p>Return the current input.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::readline update</strong></p>
  </dt>
  <dd>
    <p>Redraw the current input line.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::Print</strong> [<em>yes / no</em>]</p>
  </dt>
  <dd>
    <p>turns on or off the default behavior of tclsh to print the result of every command. This is turned on by default, so it will just behave as the tclsh w/o tclreadline. Turning off might be useful, when reading binary data for example. If <strong>::tclreadline::Print</strong> is called w/o arguments, it returns the current setting.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::Loop</strong> [<em>historyfile</em>]</p>
  </dt>
  <dd>
    <p>enter the tclreadline main loop. This command is typically called from the startup resource file (something .tclshrc, depending on the interpreter you use, see the file `sample.tclshrc'). The main loop sets up some completion characteristics as variable -- try something like "puts $b&lt;TAB&gt;" -- and command completion -- try "puts [in&lt;TAB&gt;". If the optional argument <em>historyfile</em> is given, this file will be used for reading and writing the command history instead of the default <strong>.tclsh-history</strong>. <strong>::tclreadline::Loop</strong> will normally not return. If you want to write your own main loop and/or own custom completers, it is probably a good idea to start with tclreadline::Loop (see the file tclreadlineSetup.tcl).</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::prompt1</strong></p>
  </dt>
  <dd>
    <p>a proc which is called by ::tclreadline::Loop and returns a string which will be displayed as the primary prompt. This prompt will be something like "[info nameofexecutable] &#92;[[pwd]&#92;]" possibly fancy colored. The default proc is defined on entering the ::tclreadline::Loop, if it is not already defined. So: If you define your own proc ::tclreadline::prompt1 before entering ::tclreadline::Loop, this proc is called each time the prompt is to be displayed. Example:</p>
<pre>
    package require tclreadline
    namespace eval tclreadline {
        proc prompt1 {} {
            return "[clock format [clock seconds]]&gt; "
        }
    }
    ::tclreadline::Loop
</pre>
<p>Note that non-printable control characters as color control characters must be enclosed in literal ctrl-a / ctrl-b to tell readline the length of the printable prompt. See for example the variable `prompt_string' in the file tclreadlineSetup.tcl in your tclreadline installation directory.</p>
  </dd>
  <dt>
    <p><strong>::tclreadline::prompt2</strong></p>
  </dt>
  <dd>
    <p>a proc which is called by ::tclreadline::Loop and returns a string which will be displayed as the secondary prompt when interactively prompting  for  continuation  of  an incomplete command.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VARIABLES</h2>
        <div class="sectioncontent">
<p><em>tclreadline</em> defines the following variables in the namespace <em>::tclreadline</em>: (for backwards compatibility the global variables tclreadline_version,  tclreadline_patchLevel and tclreadline_library are still present).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>tclreadline::version</strong> (read-only)</p>
  </dt>
  <dd>
    <p>holds the version string "2.1.0".</p>
  </dd>
  <dt>
    <p><strong>tclreadline::patchLevel</strong> (read-only)</p>
  </dt>
  <dd>
    <p>holds the patch level string "2.1.0".</p>
  </dd>
  <dt>
    <p><strong>tclreadline::library</strong> (read-only)</p>
  </dt>
  <dd>
    <p>holds the library directory string.</p>
  </dd>
  <dt>
    <p><strong>tclreadline::license</strong> (read-only)</p>
  </dt>
  <dd>
    <p>holds a BSD license statement.</p>
  </dd>
  <dt>
    <p><strong>tclreadline::historyLength</strong></p>
  </dt>
  <dd>
    <p>Number of lines, which will be written to the historyfile. This number is -1 by default, which means that the historyfile will not be truncated.  See also <strong>tclreadline::write</strong>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>the <strong>.tclshrc</strong> file in the HOME directory, which is read on tclsh startup. Alternatively, the name of this initialization file might be <strong>.wishrc</strong> ... depending on what interpreter you use. These files should typically contain something like</p>
<pre>
    if {$tcl_interactive} {
        package require tclreadline
        ::tclreadline::Loop
    }
</pre>
<p>which will enter the tclreadline main loop.</p><p>the <strong>.tclsh-history</strong> file in the HOME directory. On startup commands will be read from this file. On exit, the readline history is written to this file. Note that if you abort tclsh with &lt;cntrl-c&gt; no history is written. For the future it is planned to set up a signal handler, which will write the history on &lt;ctrl-c&gt; before exiting.</p><p>the <strong>.inputrc</strong> file in the users HOME directory. This file is used normally for all programs which use the gnu readline (e.g.  bash). The `global' readline settings there will be valid also for <strong>tclreadline</strong>. Additionally the .inputrc might hold conditional settings for the implementation name <strong>tclreadline</strong>. Example of some lines in your .inputrc:</p>
<pre>
    $if tclreadline
    "&#92;C-xp": "puts $env(PATH)"
    $endif
</pre>
<p>For further documentation please refer to the gnu readline documentation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>citing the readline manual:  It's too big and too slow.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO tclreadline&hellip;</h2>
        <div class="sectioncontent">
<p>The official <strong>tclreadline</strong> web site at:</p><p>http://www.zellner.org/tclreadline/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Johannes Zellner, &lt;johannes@zellner.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTRIBUTIONS, SUGGESTIONS AND PATCHES</h2>
        <div class="sectioncontent">
<p>Magnus Eriksson &lt;magnus.eriksson@netinsight.se&gt;, Les Johnson &lt;les@infolabs.com&gt;, Harald Kirsch &lt;kir@iitb.fhg.de&gt;, Christian Krone &lt;krischan@sql.de&gt;, Larry W. Virden &lt;lvirden@cas.org&gt;, David Engel &lt;dlengel@home.com&gt; &lt;david@debian.org&gt;, Matthew Clarke &lt;Matthew_Clarke@mindlink.bc.ca&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBIAN PACKAGE</h2>
        <div class="sectioncontent">
<p>David Engel &lt;dlengel@home.com&gt;, &lt;david@debian.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISCLAIMER</h2>
        <div class="sectioncontent">
<p><strong>tclreadline</strong> comes with a BSD type license. The read-only variable tclreadline::license holds the complete license statement.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="tcldot.3tcl.html"><span aria-hidden="true">&larr;</span> tcldot.3tcl: Graph manipulation in tcl</a></li>
   <li class="next"><a href="tkhtml.3tcl.html">tkhtml.3tcl: Widget to render html documents. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

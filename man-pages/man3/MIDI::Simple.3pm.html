<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MIDI::Simple: Procedural/oop interface for midi composition</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Procedural/oop interface for midi composition">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="MIDI::Simple (3pm) manual">
  <meta name="twitter:description" content="Procedural/oop interface for midi composition">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmidi-perl-MIDI::Simple-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/MIDI::Simple.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="MIDI::Simple (3pm) manual" />
  <meta property="og:description" content="Procedural/oop interface for midi composition" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmidi-perl-MIDI::Simple-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">MIDI::Simple<small> (3pm)</small></h1>
        <p class="lead">Procedural/oop interface for midi composition</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/MIDI::Simple.3pm.html">
      <span itemprop="name">MIDI::Simple: Procedural/oop interface for midi composition</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmidi-perl/">
      <span itemprop="name">libmidi-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/MIDI::Simple.3pm.html">
      <span itemprop="name">MIDI::Simple: Procedural/oop interface for midi composition</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use MIDI::Simple;
 new_score;
 text_event 'http://www.ely.anglican.org/parishes/camgsm/chimes.html';
 text_event 'Lord through this hour/ be Thou our guide';
 text_event 'so, by Thy power/ no foot shall slide';
 set_tempo 500000;  # 1 qn =&gt; .5 seconds (500,000 microseconds)
 patch_change 1, 8;  # Patch 8 = Celesta
</pre>
<p> noop c1, f, o2;  # Setup  # Now play  n qn, Cs2;   n F;   n Ds;  n hn, Gs_d1;  n qn, Cs;    n Ds;  n F;   n hn, Cs;  n qn, F;     n Cs;  n Ds;  n hn, Gs_d1;  n qn, Gs_d1; n Ds;  n F;   n hn, Cs;</p><p> write_score 'westmister_chimes.mid';</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTE ON VERSION CHANGES</h2>
        <div class="sectioncontent">
<p>I consider this module a late-stage beta.  Let me know if you run into any problems, and feel free to suggest features.</p><p>This module is somewhat incompatible with the MIDI::Simple versions before .700.</p><p>I think I've settled on (i.e., basically frozen) the basic interface for this module, and will now hopefully only add functionality.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module sits on top of all the \s-1MIDI\s0 modules \*(-- notably MIDI::Score (so you should skim MIDI::Score) \*(-- and is meant to serve as a basic interface to them, for composition.  By composition, I mean composing anew; you can use this module to add to or modify existing \s-1MIDI\s0 files, but that functionality is to be considered expermental.</p><p>This module provides two related but distinct bits of functionality: 1) a mini-language (implemented as procedures that can double as methods) for composing by adding notes to a score structure; and 2) simple functions for reading and writing scores, specifically the scores you make with the composition language.</p><p>The fact that this module's interface is both procedural and object-oriented makes it a definite two-headed beast.  The parts of the guts of the source code are not for the faint of heart.</p><p><strong>&#92;$1</strong></p><p>A MIDI::Simple object is a data structure with the following attributes:</p>
<dl class='dl-vertical'>
  <dt>
    Score
  </dt>
  <dd>
    <p>This is a list of all the notes (each a listref) that constitute this one-track musical piece.  Scores are explained in MIDI::Score. You probably don't need to access the Score attribute directly, but be aware that this is where all the notes you make with \*(C`n\*(C' events go.</p>
  </dd>
  <dt>
    Time
  </dt>
  <dd>
    <p>This is a non-negative integer expressing the start-time, in ticks from the start-time of the \s-1MIDI\s0 piece, that the next note pushed to the Score will have.</p>
  </dd>
  <dt>
    Channel
  </dt>
  <dd>
    <p>This is a number in the range [0-15] that specifies the current default channel for note events.</p>
  </dd>
  <dt>
    Duration
  </dt>
  <dd>
    <p>This is a non-negative (presumably nonzero) number expressing, in ticks, the current default length of note events, or rests.</p>
  </dd>
  <dt>
    Octave
  </dt>
  <dd>
    <p>This is a number in the range [0-10], expressing what the current default octave number is.  This is used for figuring out exactly what note-pitch is meant by a relative note-pitch specification like \*(L"A\*(R".</p>
  </dd>
  <dt>
    Notes
  </dt>
  <dd>
    <p>This is a list (presumably non-empty) of note-pitch specifications, <em>as note numbers</em> in the range [0-127].</p>
  </dd>
  <dt>
    Volume
  </dt>
  <dd>
    <p>This is an integer in the range [0-127] expressing the current default volume for note events.</p>
  </dd>
  <dt>
    Tempo
  </dt>
  <dd>
    <p>This is an integer expressing the number of ticks a quarter note occupies.  It's currently 96, and you shouldn't alter it unless you <em>really</em> know what you're doing.  If you want to control the tempo of a piece, use the \*(C`set_tempo\*(C' routine, instead.</p>
  </dd>
  <dt>
    Cookies
  </dt>
  <dd>
    <p>This is a hash that can be used by user-defined object-methods for storing whatever they want.</p>
  </dd>

</dl>
<p>Each package that you call the procedure \*(C`new_score\*(C' from, has a default MIDI::Simple object associated with it, and all the above attributes are accessible as:</p><p>  @Score $Time $Channel $Duration $Octave   @Notes $Volume $Tempo %Cookies</p><p>(Although I doubt you'll use these from any package other than \*(L"main\*(R".)  If you don't know what a package is, don't worry about it. Just consider these attributes synonymous with the above-listed variables.  Just start your programs with</p><p>  use MIDI::Simple;   new_score;</p><p>and you'll be fine. MIDI::Simple provides some pure functions (i.e., things that take input, and give a return value, and that's all they do), but what you're mostly interested in its routines.  By \*(L"routine\*(R" I mean a subroutine that you call, whether as a procedure or as a method, and that affects data structures other than the return value.</p><p>Here I'm using \*(L"procedure\*(R" to mean a routine you call like this:</p><p>  name(parameters...);   # or, just maybe:   name;</p><p>(In technical terms, I mean a non-method subroutine that can have side effects, and which may not even provide a useful return value.)  And I'm using \*(L"method\*(R" to mean a routine you call like this:</p><p>  $object-&gt;name(parameters);</p><p>So bear these terms in mind when you see routines below that act like one, or the other, or both. These are the most important routines: As a procedure, this initializes the package's default object (Score, etc.).  As a method, this is a constructor, returning a new MIDI::Simple object.  Neither form takes any parameters. This uses the parameters given (and/or the state variables like Volume, Channel, Notes, etc) to add a new note to the Score \*(-- or several notes to the Score, if Notes has more than one element in it \*(-- or no notes at all, if Notes is empty list. Then it moves Time ahead as appropriate.  See the section \*(L"Parameters For n/r/noop\*(R", below. This is exactly like \*(C`n\*(C', except it never pushes anything to Score, but moves ahead Time.  (In other words, there is no such thing as a rest-event; it's just a item during which there are no note-events playing.) This is exactly like \*(C`n\*(C' and \*(C`r\*(C', except it never alters Score, <em>and</em> never changes Time.  It is meant to be used for setting the other state variables, i.e.: Channel, Duration, Octave, Volume, Notes. A parameter in an \*(C`n\*(C', \*(C`r\*(C', or \*(C`noop\*(C' call is meant to change an attribute (\s-1AKA\s0 state variable), namely Channel, Duration, Octave, Volume, or Notes.</p><p>Here are the kinds of parameters you can use in calls to n/r/noop:</p><p>* A numeric <strong>volume</strong> parameter.  This has the form \*(L"V\*(R" followed by a positive integer in the range 0 (completely inaudible?) to 127 (\s-1AS\s0 \s-1LOUD\s0 \s-1AS\s0 \s-1POSSIBLE\s0).  Example: \*(L"V90\*(R" sets Volume to 90.</p><p>* An alphanumeric <strong>volume</strong> parameter.  This is a key from the hash %MIDI::Simple::Volume.  Current legal values are \*(L"ppp\*(R", \*(L"pp\*(R", \*(L"p\*(R", \*(L"mp\*(R", \*(L"mezzo\*(R" (or \*(L"m\*(R"), \*(L"mf\*(R", \*(L"f\*(R", \*(L"ff\*(R", and \*(L"fff\*(R".  Example: \*(L"ff\*(R" sets Volume to 112.  (Note that \*(L"m\*(R" isn't a good bareword, so use \*(L"mezzo\*(R" instead, or just always remember to use quotes around \*(L"m\*(R".)</p><p>* A numeric <strong>channel</strong> parameter.  This has the form \*(L"c\*(R" followed by a positive integer 0 to 15.  Example: \*(L"c2\*(R", to set Channel to 2.</p><p>* A numeric <strong>duration</strong> parameter.  This has the form \*(L"d\*(R" followed by a positive (presumably nonzero) integer.  Example: \*(L"d48\*(R", to set Duration to 48.</p><p>* An alphabetic (or in theory, possibly alphanumeric) <strong>duration</strong> parameter.  This is a key from the hash %MIDI::Simple::Length. Current legal values start with \*(L"wn\*(R", \*(L"hn\*(R", \*(L"qn\*(R", \*(L"en\*(R", \*(L"sn\*(R" for whole, half, quarter, eighth, or sixteenth notes.  Add \*(L"d\*(R" to the beginning of any of these to get \*(L"dotted...\*(R" (e.g., \*(L"dqn\*(R" for a dotted quarter note).  Add \*(L"dd\*(R" to the beginning of any of that first list to get \*(L"double-dotted...\*(R"  (e.g., \*(L"ddqn\*(R" for a double-dotted quarter note).  Add \*(L"t\*(R" to the beginning of any of that first list to get \*(L"triplet...\*(R"  (e.g., \*(L"tsn\*(R" for a triplet sixteenth note \*(-- i.e. a note such that 3 of them add up to something as long as one eighth note). You may add to the contents of %MIDI::Simple::Length to support whatever abbreviations you want, as long as the parser can't mistake them for any other kind of n/r/noop parameter.</p><p>* A numeric, absolute <strong>octave</strong> specification.  This has the form: an \*(L"o\*(R" (lowercase oh), and then an integer in the range 0 to 10, representing an octave 0 to 10.  The Octave attribute is used only in resolving relative note specifications, as explained further below in this section.  (All absolute note specifications also set Octave to whatever octave they occur in.)</p><p>* A numeric, relative <strong>octave</strong> specification.  This has the form: \*(L"o_d\*(R" (\*(L"d\*(R" for down) or \*(L"o_u\*(R" (\*(L"u\*(R" for down), and then an integer. This increments, or decrements, Octave.  E.g., if Octave is 6, \*(L"o_d2\*(R" will decrement Octave by 2, making it 4.  If this moves Octave below 0, it is forced to 0.  Or if it moves Octave above 10, it is forced to 10.  (For more information, see the section \*(L"Invalid or Out-of-Range Parameters to n/r/noop\*(R", below.)</p><p>* A numeric, absolute <strong>note</strong> specification.  This has the form: an optional \*(L"n\*(R", and then an integer in the range 0 to 127, representing a note ranging from C0 to G10.  The source to \s-1MIDI\s0 has a useful reference table showing the meanings of given note numbers.  Examples: \*(L"n60\*(R", or \*(L"60\*(R", which each add a 60 to the list Notes.</p><p>Since this is a kind of absolute note specification, it sets Octave to whatever octave the given numeric note occurs in.  E.g., \*(L"n60\*(R" is \*(L"C5\*(R", and therefore sets Octave to 5.</p><p>The setting of the Notes list is a bit special, compared to how setting the other attributes works.  If there are any note specifications in a given parameter list for n, r, or noop, then all those specifications together are assigned to Notes.</p><p>If there are no note specifications in the parameter list for n, r, or noop, then Notes isn't changed.  (But see the destription of \*(L"rest\*(R", at the end of this section.)</p><p>So this:</p><p>  n mf, n40, n47, n50;</p><p>sets Volume to 80, and Notes to (40, 47, 50).  And it sets Octave, first to 3 (since n40 is in octave 3), then to 3 again (since n47 = B3), and then finally to 4 (since n50 = D4).</p><p>Note that this is the same as:</p><p>  n n40, n47, n50, mf;</p><p>The relative orders of parameters is <strong>usually</strong> irrelevant; but see the section \*(L"Order of Parameters in a Call to n/r/noop\*(R", below.</p><p>* An alphanumeric, absolute <strong>note</strong> specification.</p><p>These have the form: a string denoting a note within the octave (as determined by %MIDI::Simple::Note \*(-- see below, in the description of alphanumeric, relative note specifications), and then a number denoting the octave number (in the range 0-10).  Examples: \*(L"C3\*(R", \*(L"As4\*(R" or \*(L"Asharp4\*(R", \*(L"Bf9\*(R" or \*(L"Bflat9\*(R".</p><p>Since this is a kind of absolute note specification, it sets Octave to whatever octave the given numeric note occurs in.  E.g., \*(L"C3\*(R" sets Octave to 3, \*(L"As4\*(R" sets Octave to 4, and \*(L"Bflat9\*(R" sets Octave to 9.</p><p>This:</p><p>  n E3, B3, D4, mf;</p><p>does the same as this example of ours from before:</p><p>  n n40, n47, n50, mf;</p><p>* An alphanumeric, relative <strong>note</strong> specification.</p><p>These have the form: a string denoting a note within the octave (as determined by %MIDI::Simple::Note), and then an optional parameter \*(L"_u[number]\*(R" meaning \*(L"so many octaves up from the current octave\*(R" or \*(L"_d[parameter]\*(R" meaning \*(L"so many octaves down from the current octave\*(R".</p><p>Examples: \*(L"C\*(R", \*(L"As\*(R" or \*(L"Asharp\*(R", \*(L"Bflat\*(R" or \*(L"Bf\*(R", \*(L"C_d3\*(R", \*(L"As_d1\*(R" or \*(L"Asharp_d1\*(R", \*(L"Bflat_u3\*(R" or \*(L"Bf_u3\*(R".</p><p>In resolving what actual notes these kinds of specifications denote, the current value of Octave is used.</p><p>What's a legal for the first bit (before any optional octave up/down specification) comes from the keys to the hash %MIDI::Simple::Note. The current acceptable values are:</p><p> C                                 (maps to the value 0)  Cs or Df or Csharp or Dflat       (maps to the value 1)  D                                 (maps to the value 2)  Ds or Ef or Dsharp or Eflat       (maps to the value 3)  E                                 (maps to the value 4)  F                                 (maps to the value 5)  Fs or Gf or Fsharp or Gflat       (maps to the value 6)  G                                 (maps to the value 7)  Gs or Af or Gsharp or Aflat       (maps to the value 8)  A                                 (maps to the value 9)  As or Bf or Asharp or Bflat       (maps to the value 10)  B                                 (maps to the value 11)</p><p>(Note that these are based on the English names for these notes.  If you prefer to add values to accomodate other strings denoting notes in the octave, you may do so by adding to the hash %MIDI::Simple::Note like so:</p><p>  use MIDI::Simple;   %MIDI::Simple::Note =     (%MIDI::Simple::Note,  # keep all the old values      'H' =&gt; 10,      'Do' =&gt; 0,      # ...etc...     );</p><p>But the values you add must not contain any characters outside the range [A-Za-z&#92;x80-&#92;xFF]; and your new values must not look like anything that could be any other kind of specification.  E.g., don't add \*(L"mf\*(R" or \*(L"o3\*(R" to %MIDI::Simple::Note.)</p><p>Consider that these bits of code all do the same thing:</p><p>  n E3, B3, D4, mf;       # way 1</p><p>  n E3, B,  D_u1, mf;     # way 2</p><p>  n o3, E, B,  D_u1, mf;  # way 3</p><p>  noop o3, mf;            # way 4   n     E, B,  D_u1;</p><p>or even</p><p>  n o3, E, B, o4, D, mf;       # way 5!</p><p>  n o6, E_d3, B_d3, D_d2, mf;  # way 6!</p><p>If a \*(L"_d[number]\*(R" would refer to a note in an octave below 0, it is forced into octave 0.  If a \*(L"_u[number]\*(R" would refer to a note in an octave above 10, it is forced into octave 10.  E.g., if Octave is 8, \*(L"G_u4\*(R" would resolve to the same as \*(L"G10\*(R" (not \*(L"G12\*(R" \*(-- as that's out of range); if Octave is 2, \*(L"G_d4\*(R" would resolve to the same as \*(L"G0\*(R". (For more information, see the section \*(L"Invalid or Out-of-Range Parameters to n/r/noop\*(R", below.)</p><p>* The string "\*(C`rest\*(C'" acts as a sort of note specification \*(-- it sets Notes to empty-list.  That way you can make a call to \*(C`n\*(C' actually make a rest:</p><p>  n qn, G;    # makes a G quarter-note   n hn, rest; # half-rest -- alters Notes, making it ()   n C,G;      # half-note chord: simultaneous C and G   r;          # half-rest -- DOESN'T alter Notes.   n qn;       # quarter-note chord: simultaneous C and G   n rest;     # quarter-rest   n;          # another quarter-rest</p><p>(If you can follow the above code, then you understand.)</p><p>A "\*(C`rest\*(C'\*(L" that occurs in a parameter list with other note specs (e.g., \*(R"n qn, A, rest, G") has <strong>no effect</strong>, so don't do that. The order of parameters in calls to n/r/noop is not important except insofar as the parameters change the Octave parameter, which may change how some relative note specifications are resolved.  For example:</p><p>  noop o4, mf;   n G, B, A3, C;</p><p>is the same as \*(L"n mf, G4, B4, A3, C3\*(R".  But just move that \*(L"C\*(R" to the start of the list:</p><p>  noop o4, mf;   n C, G, B, A3;</p><p>and you something different, equivalent to \*(L"n mf, C4, G4, B4, A3\*(R".</p><p>But note that you can put the \*(L"mf\*(R" anywhere without changing anything.</p><p>But <strong>stylistically</strong>, I strongly advise putting note parameters at the <strong>end</strong> of the parameter list:</p><p>  n mf, c10, C, B;  # 1. good   n C, B, mf, c10;  # 2. bad   n C, mf, c10, B;  # 3. so bad!</p><p>3 is particularly bad because an uninformed/inattentive reader may get the impression that the C may be at a different volume and on a different channel than the B.</p><p>(Incidentally, \*(L"n C5,G5\*(R" and \*(L"n G5,C5\*(R" are the same for most purposes, since the C and the G are played at the same time, and with the same parameters (channel and volume); but actually they differ in which note gets put in the Score first, and therefore which gets encoded first in the \s-1MIDI\s0 file \*(-- but this makes no difference at all, unless you're manipulating the note-items in Score or the \s-1MIDI\s0 events in a track.) If a parameter in a call to n/r/noop is uninterpretable, Perl dies with an error message to that effect.</p><p>If a parameter in a call to n/r/noop has an out-of-range value (like \*(L"o12\*(R" or \*(L"c19\*(R"), Perl dies with an error message to that effect.</p><p>As somewhat of a merciful exception to this rule, if a parameter in a call to n/r/noop is a relative specification (whether like \*(L"o_d3\*(R" or \*(L"o_u3\*(R", or like \*(L"G_d3\*(R" or \*(L"G_u3\*(R") which happens to resolve to an out-of-range value (like \*(L"G_d3\*(R" given an Octave value of 2), then Perl will <strong>not</strong> die, but instead will silently try to bring that note back into range, by forcing it up to octave 0 (if it would have been lower), or down into 9 or 10 (if it would have been an octave higher than 10, or a note higher than G10), as appropriate.</p><p>(This becomes strange in that, given an Octave of 8, \*(L"G_u4\*(R" is forced down to G10, but \*(L"A_u4\*(R" is forced down to an A9.  But that boundary has to pop up someplace \*(-- it's just unfortunate that it's in the middle of octave 10.) The object attributes discussed above are readable and writeable with object methods.  For each attribute there is a read/write method, and a read-only method that returns a reference to the attribute's value:</p><p>  Attribute ||  R/W-Method ||   RO-R-Method   ----------++-------------++--------------------------------------   Score     ||  Score      ||   Score_r      (returns a listref)   Notes     ||  Notes      ||   Notes_r      (returns a listref)   Time      ||  Time       ||   Time_r       (returns a scalar ref)   Duration  ||  Duration   ||   Duration_r   (returns a scalar ref)   Channel   ||  Channel    ||   Channel_r    (returns a scalar ref)   Octave    ||  Octave     ||   Octave_r     (returns a scalar ref)   Volume    ||  Volume     ||   Volume_r     (returns a scalar ref)   Tempo     ||  Tempo      ||   Tempo_r      (returns a scalar ref)   Cookies   ||  Cookies    ||   Cookies_r    (returns a hashref)</p><p>To read any of the above via a R/W-method, call with no parameters, e.g.:</p><p>  $notes = $obj-&gt;Notes;  # same as $obj-&gt;Notes()</p><p>The above is the read-attribute (\*(L"get\*(R") form.</p><p>To set the value, call with parameters:</p><p>  $obj-&gt;Notes(13,17,22);</p><p>The above is the write-attribute (\*(L"put\*(R") form.  Incidentally, when used in write-attribute form, the return value is the same as the parameters, except for Score or Cookies.  (In those two cases, I've suppressed it for efficiency's sake.)</p><p>Alternately (and much more efficiently), you can use the read-only reference methods to read or alter the above values;</p><p>  $notes_r = $obj-&gt;Notes_r;   # to read:   @old_notes = @$notes_r;   # to write:   @$notes_r = (13,17,22);</p><p>And this is the only way to set Cookies, Notes, or Score to a (), like so:</p><p>  $notes_r = $obj-&gt;Notes_r;   @$notes_r = ();</p><p>Since this:</p><p>  $obj-&gt;Notes;</p><p>is just the read-format call, remember?</p><p>Like all methods in this class, all the above-named attribute methods double as procedures that act on the default object \*(-- in other words, you can say:</p><p>  Volume 10;              # same as:  $Volume = 10;   @score_copy = Score;    # same as:  @score_copy = @Score   Score @new_score;       # same as:  @Score = @new_score;   $score_ref = Score_r;   # same as:  $score_ref = &#92;@Score   Volume(Volume + 10)     # same as:  $Volume += 10</p><p>But, stylistically, I suggest not using these procedures \*(-- just directly access the variables instead. These routines, below, add a \s-1MIDI\s0 event to the Score, with a start-time of Time.  Example:</p><p>  text_event "And now the bongos!";  # procedure use</p><p>  $obj-&gt;text_event "And now the bongos!";  # method use</p><p>These are named after the \s-1MIDI\s0 events they add to the score, so see MIDI::Event for an explanation of what the data types (like \*(L"velocity\*(R" or \*(L"pitch_wheel\*(R") mean.  I've reordered this list so that what I guess are the most important ones are toward the top:</p>
<dl class='dl-vertical'>
  <dt>
    patch_change <em>channel</em>, <em>patch</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    key_after_touch <em>channel</em>, <em>note</em>, <em>velocity</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    channel_after_touch <em>channel</em>, <em>velocity</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    control_change <em>channel</em>, <em>controller(0-127)</em>, <em>value(0-127)</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    pitch_wheel_change <em>channel</em>, <em>pitch_wheel</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    set_tempo <em>tempo</em>;  (See the section on tempo, below.)
  </dt>
  <dd>
    
  </dd>
  <dt>
    smpte_offset <em>hr</em>, <em>mn</em>, <em>se</em>, <em>fr</em>, <em>ff</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    time_signature <em>nn</em>, <em>dd</em>, <em>cc</em>, <em>bb</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    key_signature <em>sf</em>, <em>mi</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    text_event <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    copyright_text_event <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    track_name <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    instrument_name <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    lyric <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    set_sequence_number <em>sequence</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    marker <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    cue_point <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    sequencer_specific <em>raw</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    sysex_f0 <em>raw</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    sysex_f7 <em>raw</em>;
  </dt>
  <dd>
    
  </dd>

</dl>
<p>And here's the ones I'll be surprised if anyone ever uses:</p>
<dl class='dl-vertical'>
  <dt>
    text_event_08 <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    text_event_09 <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    text_event_0a <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    text_event_0b <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    text_event_0c <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    text_event_0d <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    text_event_0e <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    text_event_0f <em>text</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    raw_meta_event <em>command</em>(0-255), <em>raw</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    song_position <em>starttime</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    song_select <em>song_number</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    tune_request <em>starttime</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    raw_data <em>raw</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    end_track <em>starttime</em>;
  </dt>
  <dd>
    
  </dd>
  <dt>
    note <em>duration</em>, <em>channel</em>, <em>note</em>, <em>velocity</em>;
  </dt>
  <dd>
    <p>The chart above shows that tempo is set with a method/procedure that takes the form set_tempo(<em>tempo</em>), and MIDI::Event says that <em>tempo</em> is \*(L"microseconds, a value 0 to 16,777,215 (0x00FFFFFF)\*(R". But at the same time, you see that there's an attribute of the MIDI::Simple object called \*(L"Tempo\*(R", which I've warned you to leave at the default value of 96.  So you may wonder what the deal is.</p>
  </dd>

</dl>
<p>The \*(L"Tempo\*(R" attribute (\s-1AKA\s0 \*(L"Divisions\*(R") is an integer that specifies the number of \*(L"ticks\*(R" per \s-1MIDI\s0 quarter note.  Ticks is just the notional timing unit all \s-1MIDI\s0 events are expressed in terms of. Calling it \*(L"Tempo\*(R" is misleading, really; what you want to change to make your music go faster or slower isn't that parameter, but instead the mapping of ticks to actual time \*(-- and that is what \*(C`set_tempo\*(C' does.  Its one parameter is the number of microseconds each quarter note should get.</p><p>Suppose you wanted a tempo of 120 quarter notes per minute.  In terms of microseconds per quarter note:</p><p>  set_tempo 500_000; # you can use _ like a thousands-separator comma</p><p>In other words, this says to make each quarter note take up 500,000 microseconds, namely .5 seconds.  And there's 120 of those half-seconds to the minute; so, 120 quarter notes to the minute.</p><p>If you see a \*(L"[quarter note symbol] = 160\*(R" in a piece of sheet music, and you want to figure out what number you need for the \*(C`set_tempo\*(C', do:</p><p>  60_000_000 / 160  ... and you get:  375_000</p><p>Therefore, you should call:</p><p>  set_tempo 375_000;</p><p>So in other words, this general formula:</p><p>  set_tempo int(60_000_000 / $quarter_notes_per_minute);</p><p>should do you fine.</p><p>As to the Tempo/Duration parameter, leave it alone and just assume that 96 ticks-per-quarter-note is a universal constant, and you'll be happy.</p><p>(You may wonder: Why 96?  As far as I've worked out, all purmutations of the normal note lengths (whole, half, quarter, eighth, sixteenth, and even thirty-second notes) and tripletting, dotting, or double-dotting, times 96, all produce integers.  For example, if a quarter note is 96 ticks, then a double-dotted thirty-second note is 21 ticks (i.e., 1.75 * 1/8 * 96).  But that'd be a messy 10.5 if there were only 48 ticks to a quarter note.  Now, if you wanted a quintuplet anywhere, you'd be out of luck, since 96 isn't a factor of five.  It's actually 3 * (2 ** 5), i.e., three times two to the fifth.  If you really need quintuplets, then you have my very special permission to mess with the Tempo attribute \*(-- I suggest multiples of 96, e.g., 5 * 96.)</p><p>(You may also have read in MIDI::Filespec that \*(C`time_signature\*(C' allows you to define an arbitrary mapping of your concept of quarter note, to \s-1MIDI\s0's concept of quarter note.  For your sanity and mine, leave them the same, at a 1:1 mapping \*(-- i.e., with an '8' for \*(C`time_signature\*(C''s last parameter, for \*(L"eight notated 32nd-notes per \s-1MIDI\s0 quarter note\*(R".  And this is relevant only if you're calling \*(C`time_signature\*(C' anyway, which is not necessarily a given.)</p>
<dl class='dl-vertical'>
  <dt>
    $opus = write_score <em>filespec</em>
  </dt>
  <dd>
    <p>Writes the score to the filespec (e.g, \*(L"../../samples/funk2.midi\*(R", or a variable containing that value), with the score's Ticks as its tick parameters (\s-1AKA\s0 \*(L"divisions\*(R").  Among other things, this function calls the function \*(C`make_opus\*(C', below, and if you capture the output of write_score, you'll get the opus created, if you want it for anything. (Also: you can also use a filehandle-reference instead of the filespec: \*(C`write_score *STDOUT{IO}\*(C'.)</p>
  </dd>
  <dt>
    read_score <em>filespec</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    $obj = MIDI::Simple-&gt;read_score('foo.mid'))
  </dt>
  <dd>
    <p>In the first case (a procedure call), does \*(C`new_score\*(C' to erase and initialize the object attributes (Score, Octave, etc), then reads from the file named.  The file named has to be a \s-1MIDI\s0 file with exactly one eventful track, or Perl dies.  And in the second case, \*(C`read_score\*(C' acts as a constructor method, returning a new object read from the file. Score, Ticks, and Time are all affected: Score is the event form of all the \s-1MIDI\s0 events in the \s-1MIDI\s0 file. (Note: <em>Seriously</em> deformed \s-1MIDI\s0 files may confuse the routine that turns \s-1MIDI\s0 events into a Score.) Ticks is set from the ticks setting (\s-1AKA\s0 \*(L"divisions\*(R") of the file. Time is set to the end time of the latest event in the file. (Also: you can also use a filehandle-reference instead of the filespec: \*(C`read_score *STDIN{IO}\*(C'.) If ever you have to make a Score out of a single track from a <em>multitrack</em> file, read the file into an $opus, and then consider something like:         new_score;         $opus = MIDI::Opus-&gt;new({ 'from_file' =&gt; "foo2.mid" });         $track = ($opus-&gt;tracks)[2]; # get the third track         ($score_r, $end_time) =           MIDI::Score::events_r_to_score_r($track-&gt;events_r);         $Ticks = $opus-&gt;ticks;         @Score =  @$score_r;         $Time = $end_time;</p>
  </dd>
  <dt>
    synch( \s-1LIST\s0 of coderefs )
  </dt>
  <dd>
    
  </dd>
  <dt>
    $obj-&gt;synch( \s-1LIST\s0 of coderefs )
  </dt>
  <dd>
    <p>\s-1LIST\s0 is a list of coderefs (whether as a series of anonymous subs, or as a list of items like \*(C`(&#92;&foo, &#92;&bar, &#92;&baz)\*(C', or a mixture of both) that \*(C`synch\*(C' calls in order to add to the given object \*(-- which in the first form is the package's default object, and which in the second case is $obj.  What \*(C`synch\*(C' does is: * remember the initial value of Time, before calling any of the routines; * for each routine given, reset Time to what it was initially, call the routine, and then note what the value of Time is, after each call; * then, after having called all of the routines, set Time to whatever was the greatest (equals latest) value of Time that resulted from any of the calls to the routines. The coderefs are all called with one argument in @_ \*(-- the object they are supposed to affect.  All these routines should/must therefore use method calls instead of procedure calls.  Here's an example usage of synch:         my $measure = 0;         my @phrases =(           [ Cs, F,  Ds, Gs_d1 ], [Cs,    Ds, F, Cs],           [ F,  Cs, Ds, Gs_d1 ], [Gs_d1, Ds, F, Cs]         );         for(1 .. 20) { synch(&#92;&count, &#92;&lalala); }         sub count {           my $it = $_[0];           $it-&gt;r(wn); # whole rest           # not just "r(wn)" -- we want a method, not a procedure!           ++$measure;         }         sub lalala {           my $it = $_[0];           $it-&gt;noop(c1,mf,o3,qn); # setup           my $phrase_number = ($measure + -1) % 4;           my @phrase = @{$phrases[$phrase_number]};           foreach my $note (@phrase) { $it-&gt;n($note); }         } Makes an opus (a MIDI::Opus object) out of Score, setting the opus's tick parameter (\s-1AKA\s0 \*(L"divisions\*(R") to $ticks.  The opus is, incidentally, format 0, with one track. Dumps Score's contents, via \*(C`print\*(C' (so you can \*(C`select()\*(C' an output handle for it).  Currently this is in this somewhat uninspiring format:   ['note', 0, 96, 1, 25, 96],   ['note', 96, 96, 1, 29, 96], as it is (currently) just a call to &MIDI::Score::dump_score; but in the future I may (should?) make it output in \*(C`n\*(C'/\*(C`r\*(C' notation.  In the meantime I assume you'll use this, if at all, only for debugging purposes. These are subroutines that aren't methods and don't affect anything (i.e., don't have \*(L"side effects\*(R") \*(-- they just take input and/or give output.</p>
  </dd>
  <dt>
    interval \s-1LISTREF\s0, \s-1LIST\s0
  </dt>
  <dd>
    <p>This takes a reference to a list of integers, and a list of note-pitch specifications (whether relative or absolute), and returns a list consisting of the given note specifications transposed by that many half-steps.  E.g.,   @majors = interval [0,4,7], C, Bflat3; which returns the list \*(C`(C,E,G,Bf3,D4,F4)\*(C'. Items in \s-1LIST\s0 which aren't note specifications are passed thru unaltered.</p>
  </dd>
  <dt>
    note_map { \s-1BLOCK\s0 } \s-1LIST\s0
  </dt>
  <dd>
    <p>This is pretty much based on (or at least inspired by) the normal Perl \*(C`map\*(C' function, altho the syntax is a bit more restrictive (i.e., \*(C`map\*(C' can take the form \*(C`map {BLOCK} LIST\*(C' or \*(C`map(EXPR,LIST)\*(C' \*(-- the latter won't work with \*(C`note_map\*(C'). \*(C`note_map {BLOCK} (LIST)\*(C' evaluates the \s-1BLOCK\s0 for each element of \s-1LIST\s0 (locally setting $_ to each element's note-number value) and returns the list value composed of the results of each such evaluation.  Evaluates \s-1BLOCK\s0 in a list context, so each element of \s-1LIST\s0 may produce zero, one, or more elements in the returned value. Moreover, besides setting $_, \*(C`note_map\*(C' feeds \s-1BLOCK\s0 (which it sees as an anonymous subroutine) three parameters, which \s-1BLOCK\s0 can access in @_ :   $_[0]  :  Same as $_.  I.e., The current note-specification,             as a note number.             This is the result of having fed the original note spec             (which you can see in $_[2]) to is_note_spec.   $_[1]  :  The absoluteness flag for this note, from the             above-mentioned call to is_note_spec.             0 = it was relative (like 'C')             1 = it was absolute (whether as 'C4' or 'n41' or '41')   $_[2] : the actual note specification from LIST, if you want             to access it for any reason. Incidentally, any items in \s-1LIST\s0 that aren't a note specification are passed thru unchanged \*(-- \s-1BLOCK\s0 isn't called on it. So, in other words, what \*(C`note_map\*(C' does, for each item in \s-1LIST\s0, is: * It calls \*(C`is_note_spec\*(C' on it to test whether it's a note specification at all.  If it isn't, just passes it thru.  If it is, then \*(C`note_map\*(C' stores the note number and the absoluteness flag that \*(C`is_note_spec\*(C' returned, and... * It calls \s-1BLOCK\s0, providing the note number in $_ and $_[0], the absoluteness flag in $_[1], and the original note specification in $_[2].  Stores the return value of calling \s-1BLOCK\s0 (in a list context of course) \*(-- this should be a list of note numbers. * For each element of the return value (which is actually free to be an empty list), converts it from a note number to whatever <strong>kind</strong> of specification the original note value was.  So, for each element, if the original was relative, \*(C`note_map\*(C' interprets the return value as a relative note number, and calls \*(C`number_to_relative\*(C' on it; if it was absolute, \*(C`note_map\*(C' will try to restore it to the correspondingly formatted absolute specification type. An example is, I hope, helpful: This:         note_map { $_ - 3, $_ + 2 }  qw(Cs3 n42 50 Bf) returns this:         ('Bf2', 'Ef3', 'n39', 'n44', '47', '52', 'G', 'C_u1') Or, to line things up:           Cs3       n42       50      Bf            |         |        |       |         /-----&#92;   /-----&#92;   /---&#92;   /----&#92;         Bf2 Ef3   n39 n44   47 52   G C_u1 Now, of course, this is the same as what this:         interval [-3, 2], qw(Cs3 n42 50 Bf) returns.  This is fitting, as \*(C`interval\*(C', internally, is basically a simplified version of \*(C`note_map\*(C'.  But \*(C`interval\*(C' only lets you do unconditional transposition, whereas \*(C`note_map\*(C' lets you do anything at all.  For example:        @note_specs = note_map { $funky_lookup_table{$_} }                               C, Gf; or        @note_specs = note_map { $_ + int(<strong>rand</strong>(2)) }                               @stuff; \*(C`note_map\*(C', like \*(C`map\*(C', can seem confusing to beginning programmers (and many intermediate ones, too), but it is quite powerful.</p>
  </dd>
  <dt>
    number_to_absolute \s-1NUMBER\s0
  </dt>
  <dd>
    <p>This returns the absolute note specification (in the form \*(L"C5\*(R") that the \s-1MIDI\s0 note number in \s-1NUMBER\s0 represents. This is like looking up the note number in %MIDI::number2note \*(-- not exactly the same, but effectively the same.  See the source for more details.</p>
  </dd>
  <dt>
    the function number_to_relative \s-1NUMBER\s0
  </dt>
  <dd>
    <p>This returns the relative note specification that \s-1NUMBER\s0 represents. The idea of a numerical representation for \*(C`relative\*(C' note specifications was necessitated by \*(C`interval\*(C' and \*(C`note_map\*(C' \*(-- since without this, you couldn't meaningfully say, for example, interval [0,2] 'F'.  This should illustrate the concept:           number_to_relative(-10)   =&gt;   "D_d1"           number_to_relative( -3)   =&gt;   "A_d1"           number_to_relative(  0)   =&gt;   "C"           number_to_relative(  5)   =&gt;   "F"           number_to_relative( 10)   =&gt;   "Bf"           number_to_relative( 19)   =&gt;   "G_u1"           number_to_relative( 40)   =&gt;   "E_u3"</p>
  </dd>
  <dt>
    is_note_spec \s-1STRING\s0
  </dt>
  <dd>
    <p>If \s-1STRING\s0 is a note specification, \*(C`is_note_spec(STRING)\*(C' returns a list of two elements: first, a flag of whether the note specification is absolute (flag value 1) or relative (flag value 0); and second, a note number corresponding to that note specification.  If \s-1STRING\s0 is not a note specification, \*(C`is_note_spec(STRING)\*(C' returns an empty list (which in a boolean context is \s-1FALSE\s0). Implementationally, \*(C`is_note_spec\*(C' just uses \*(C`is_absolute_note_spec\*(C' and \*(C`is_relative_note_spec\*(C'. Example usage:         @note_details = is_note_spec($thing);         if(@note_details) {           ($absoluteness_flag, $note_num) = @note_details;           ...stuff...         } else {           push @other_stuff, $thing;  # or whatever         }</p>
  </dd>
  <dt>
    is_relative_note_spec \s-1STRING\s0
  </dt>
  <dd>
    <p>If \s-1STRING\s0 is an relative note specification, returns the note number for that specification as a one-element list (which in a boolean context is \s-1TRUE\s0).  Returns empty-list (which in a boolean context is \s-1FALSE\s0) if \s-1STRING\s0 is \s-1NOT\s0 a relative note specification. To just get the boolean value:       print "Snorf!&#92;n" unless is_relative_note_spec($note); But to actually get the note value:       ($note_number) = is_relative_note_spec($note); Or consider this:       @is_rel = is_relative_note_spec($note);       if(@is_rel) {         $note_number = $is_rel[0];       } else {         print "Snorf!&#92;n";       } (Author's note, two years later: all this business of returning lists of various sizes, with this and other functions in here, is basically a workaround for the fact that there's not really any such thing as a boolean context in Perl \*(-- at least, not as far as user-defined functions can see.  I now think I should have done this with just returning a single scalar value: a number (which could be 0!) if the input is a number, and undef/emptylist (\*(C`return;\*(C') if not \*(-- then, the user could test:       # Hypothetical --       # This fuction doesn't actually work this way:       if(defined(my $note_val = is_relative_note_spec($string))) {          ...do things with $note_val...       } else {          print "Hey, that's no note!&#92;n";       } However, I don't anticipate users actually using these messy functions often at all \*(-- I basically wrote these for internal use by MIDI::Simple, then I documented them on the off chance they <em>might</em> be of use to anyone else.)</p>
  </dd>
  <dt>
    is_absolute_note_spec \s-1STRING\s0
  </dt>
  <dd>
    <p>Just like \*(C`is_relative_note_spec\*(C', but for absolute note specifications instead of relative ones. Presumably the second syntax is useless \*(-- it just returns $obj.  But the first syntax returns the current package's default object. Suppose you write a routine, \*(C`funkify\*(C', that does something-or-other to a given MIDI::Simple object.  You could write it so that acts on the current package's default object, which is fine \*(-- but, among other things, that means you can't call \*(C`funkify\*(C' from a sub you have \*(C`synch\*(C' call, since such routines should/must use only method calls. So let's say that, instead, you write \*(C`funkify\*(C' so that the first argument to it is the object to act on.  If the MIDI::Simple object you want it to act on is it $sonata, you just say   funkify($sonata) However, if you want it to act on the current package's default MIDI::Simple object, what to say?  Simply,   $package_opus = Self;   funkify($package_opus);</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 1998-2002 Sean M. Burke. All rights reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sean M. Burke \*(C`sburke@cpan.org\*(C'</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="MIDI::Score.3pm.html"><span aria-hidden="true">&larr;</span> MIDI::Score.3pm: Midi scores</a></li>
   <li class="next"><a href="MIDI::Track.3pm.html">MIDI::Track.3pm: Functions and methods for midi tracks <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

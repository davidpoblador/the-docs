<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>application: Generic otp application functions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Generic otp application functions">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="application (3erl) manual">
  <meta name="twitter:description" content="Generic otp application functions">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-application-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/application.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="application (3erl) manual" />
  <meta property="og:description" content="Generic otp application functions" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-application-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">application<small> (3erl)</small></h1>
        <p class="lead">Generic otp application functions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/application.3erl.html">
      <span itemprop="name">application: Generic otp application functions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/application.3erl.html">
      <span itemprop="name">application: Generic otp application functions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>In OTP, <em>application</em> denotes a component implementing some specific functionality, that can be started and stopped as a unit, and which can be re-used in other systems as well. This module interfaces the <em>application controller</em>, a process started at every Erlang runtime system, and contains functions for controlling applications (for example starting and stopping applications), and functions to access information about applications (for example configuration parameters).</p><p>An application is defined by an <em>application specification</em>. The specification is normally located in an <em>application resource file</em> called <em>Application.app</em>, where <em>Application</em> is the name of the application. Refer to <a href="../man5/app.5.html"><strong>app</strong>(5)</a></strong> for more information about the application specification.</p><p>This module can also be viewed as a behaviour for an application implemented according to the OTP design principles as a supervision tree. The definition of how to start and stop the tree should be located in an <em>application callback module</em> exporting a pre-defined set of functions.</p><p>Refer to <strong>OTP Design Principles</strong> for more information about applications and behaviours.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>start_type()</strong> = normal

             | {takeover, Node :: node()}

             | {failover, Node :: node()}

</pre>

<pre>
<strong>restart_type()</strong> = permanent | transient | temporary

</pre>

<pre>
<strong></strong>
<strong>tuple_of(T)</strong>

</pre>
<p>A tuple where the elements are of type <em>T</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
get_all_env() -&gt; Env

</pre>

<pre>
<strong></strong>
get_all_env(Application) -&gt; Env

</pre>
<p>Types:</p><p>Application = atom()</p><p>Env = [{Par :: atom(), Val :: term()}]</p><p>Returns the configuration parameters and their values for <em>Application</em>. If the argument is omitted, it defaults to the application of the calling process.</p><p>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns <em>[]</em>.</p>
<pre>
<strong></strong>
get_all_key() -&gt; [] | {ok, Keys}

</pre>

<pre>
<strong></strong>
get_all_key(Application) -&gt; undefined | Keys

</pre>
<p>Types:</p><p>Application = atom()</p><p>Keys = {ok, [{Key :: atom(), Val :: term()}, ...]}</p><p>Returns the application specification keys and their values for <em>Application</em>. If the argument is omitted, it defaults to the application of the calling process.</p><p>If the specified application is not loaded, the function returns <em>undefined</em>. If the process executing the call does not belong to any application, the function returns <em>[]</em>.</p>
<pre>
<strong></strong>
get_application() -&gt; undefined | {ok, Application}

</pre>

<pre>
<strong></strong>
get_application(PidOrModule) -&gt; undefined | {ok, Application}

</pre>
<p>Types:</p><p>PidOrModule = (Pid :: pid()) | (Module :: module())</p><p>Application = atom()</p><p>Returns the name of the application to which the process <em>Pid</em> or the module <em>Module</em> belongs. Providing no argument is the same as calling <em>get_application(self())</em>.</p><p>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns <em>undefined</em>.</p>
<pre>
<strong></strong>
get_env(Par) -&gt; undefined | {ok, Val}

</pre>

<pre>
<strong></strong>
get_env(Application, Par) -&gt; undefined | {ok, Val}

</pre>
<p>Types:</p><p>Application = Par = atom()</p><p>Val = term()</p><p>Returns the value of the configuration parameter <em>Par</em> for <em>Application</em>. If the application argument is omitted, it defaults to the application of the calling process.</p><p>If the specified application is not loaded, or the configuration parameter does not exist, or if the process executing the call does not belong to any application, the function returns <em>undefined</em>.</p>
<pre>
<strong></strong>
get_env(Application, Par, Def) -&gt; Val

</pre>
<p>Types:</p><p>Application = Par = atom()</p><p>Def = Val = term()</p><p>Works like <strong>get_env/2</strong> but returns <em>Def</em> value when configuration parameter <em>Par</em> does not exist.</p>
<pre>
<strong></strong>
get_key(Key) -&gt; undefined | {ok, Val}

</pre>

<pre>
<strong></strong>
get_key(Application, Key) -&gt; undefined | {ok, Val}

</pre>
<p>Types:</p><p>Application = Key = atom()</p><p>Val = term()</p><p>Returns the value of the application specification key <em>Key</em> for <em>Application</em>. If the application argument is omitted, it defaults to the application of the calling process.</p><p>If the specified application is not loaded, or the specification key does not exist, or if the process executing the call does not belong to any application, the function returns <em>undefined</em>.</p>
<pre>
<strong></strong>
load(AppDescr) -&gt; ok | {error, Reason}

</pre>

<pre>
<strong></strong>
load(AppDescr, Distributed) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>AppDescr = Application | (AppSpec :: <strong>application_spec()</strong>)</p><p>Application = atom()</p><p>Distributed = {Application, Nodes}</p>
<pre>
            | {Application, Time, Nodes}
</pre>

<pre>
            | default
</pre>
<p>Nodes = [node() | <strong>tuple_of</strong>(node())]</p><p>Time = integer() &gt;= 1</p><p>Reason = term()</p>
<pre>
<strong>application_spec()</strong> =

    {application,

     Application :: atom(),

     AppSpecKeys :: [<strong>application_opt()</strong>]}
</pre>

<pre>
<strong>application_opt()</strong> = {description, Description :: string()}

                  | {vsn, Vsn :: string()}

                  | {id, Id :: string()}

                  | {modules, [Module :: module()]}

                  | {registered, Names :: [Name :: atom()]}

                  | {applications, [Application :: atom()]}

                  | {included_applications,

                     [Application :: atom()]}

                  | {env, [{Par :: atom(), Val :: term()}]}

                  | {start_phases,

                     [{Phase :: atom(), PhaseArgs :: term()}] |

                     undefined}

                  | {maxT, MaxT :: timeout()}

                  | {maxP, MaxP :: integer() &gt;= 1 | infinity}

                  | {mod,

                     Start ::

                         {Module :: module(),

                          StartArgs :: term()}}
</pre>
<p>Loads the application specification for an application into the application controller. It will also load the application specifications for any included applications. Note that the function does not load the actual Erlang object code.</p><p>The application can be given by its name <em>Application</em>. In this case the application controller will search the code path for the application resource file <em>Application.app</em> and load the specification it contains.</p><p>The application specification can also be given directly as a tuple <em>AppSpec</em>. This tuple should have the format and contents as described in <a href="../man5/app.5.html"><strong>app</strong>(5)</a></em>.</p><p>If <em>Distributed == {Application,[Time,]Nodes}</em>, the application will be distributed. The argument overrides the value for the application in the Kernel configuration parameter <em>distributed</em>. <em>Application</em> must be the name of the application (same as in the first argument). If a node crashes and <em>Time</em> has been specified, then the application controller will wait for <em>Time</em> milliseconds before attempting to restart the application on another node. If <em>Time</em> is not specified, it will default to 0 and the application will be restarted immediately.</p><p><em>Nodes</em> is a list of node names where the application may run, in priority from left to right. Node names can be grouped using tuples to indicate that they have the same priority. Example:</p>
<pre>
Nodes = [cp1@cave, {cp2@cave, cp3@cave}]
</pre>
<p>This means that the application should preferably be started at <em>cp1@cave</em>. If <em>cp1@cave</em> is down, the application should be started at either <em>cp2@cave</em> or <em>cp3@cave</em>.</p><p>If <em>Distributed == default</em>, the value for the application in the Kernel configuration parameter <em>distributed</em> will be used.</p>
<pre>
<strong></strong>
loaded_applications() -&gt; [{Application, Description, Vsn}]

</pre>
<p>Types:</p><p>Application = atom()</p><p>Description = Vsn = string()</p><p>Returns a list with information about the applications which have been loaded using <em>load/1,2</em>, also included applications. <em>Application</em> is the application name. <em>Description</em> and <em>Vsn</em> are the values of its <em>description</em> and <em>vsn</em> application specification keys, respectively.</p>
<pre>
<strong></strong>
permit(Application, Permission) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Application = atom()</p><p>Permission = boolean()</p><p>Reason = term()</p><p>Changes the permission for <em>Application</em> to run at the current node. The application must have been loaded using <em>load/1,2</em> for the function to have effect.</p><p>If the permission of a loaded, but not started, application is set to <em>false</em>, <em>start</em> will return <em>ok</em> but the application will not be started until the permission is set to <em>true</em>.</p><p>If the permission of a running application is set to <em>false</em>, the application will be stopped. If the permission later is set to <em>true</em>, it will be restarted.</p><p>If the application is distributed, setting the permission to <em>false</em> means that the application will be started at, or moved to, another node according to how its distribution is configured (see <em>load/2</em> above).</p><p>The function does not return until the application is started, stopped or successfully moved to another node. However, in some cases where permission is set to <em>true</em> the function may return <em>ok</em> even though the application itself has not started. This is true when an application cannot start because it has dependencies to other applications which have not yet been started. When they have been started, <em>Application</em> will be started as well.</p><p>By default, all applications are loaded with permission <em>true</em> on all nodes. The permission is configurable by using the Kernel configuration parameter <em>permissions</em>.</p>
<pre>
<strong></strong>
set_env(Application, Par, Val) -&gt; ok

</pre>

<pre>
<strong></strong>
set_env(Application, Par, Val, Opts) -&gt; ok

</pre>
<p>Types:</p><p>Application = Par = atom()</p><p>Val = term()</p><p>Opts = [{timeout, timeout()} | {persistent, boolean()}]</p><p>Sets the value of the configuration parameter <em>Par</em> for <em>Application</em>.</p><p><em>set_env/4</em> uses the standard <em>gen_server</em> timeout value (5000 ms). The <em>timeout</em> option can be provided if another timeout value is useful, for example, in situations where the application controller is heavily loaded.</p><p>If <em>set_env/4</em> is called before the application is loaded, the application environment values specified in the <em>Application.app</em> file will override the ones previously set. This is also true for application reloads.</p><p>The <em>persistent</em> option can be set to <em>true</em> when there is a need to guarantee parameters set with <em>set_env/4</em> will not be overridden by the ones defined in the application resource file on load. This means persistent values will stick after the application is loaded and also on application reload.</p><p><strong></strong> Warning:</p><p>Use this function only if you know what you are doing, that is, on your own applications. It is very application and configuration parameter dependent when and how often the value is read by the application, and careless use of this function may put the application in a weird, inconsistent, and malfunctioning state.</p>
<pre>
<strong></strong>
ensure_started(Application) -&gt; ok | {error, Reason}

</pre>

<pre>
<strong></strong>
ensure_started(Application, Type) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Application = atom()</p><p>Type = <strong>restart_type()</strong></p><p>Reason = term()</p><p>Equivalent to <strong></strong><em>application:start/1,2</em> except it returns <em>ok</em> for already started applications.</p>
<pre>
<strong></strong>
ensure_all_started(Application) -&gt; {ok, Started} | {error, Reason}

</pre>

<pre>
<strong></strong>
ensure_all_started(Application, Type) -&gt;
<strong></strong>
                      {ok, Started} | {error, Reason}

</pre>
<p>Types:</p><p>Application = atom()</p><p>Type = <strong>restart_type()</strong></p><p>Started = [atom()]</p><p>Reason = term()</p><p>Equivalent to calling <strong></strong><em>application:start/1,2</em> repeatedly on all dependencies that have not yet been started for an application. The function returns <em>{ok, AppNames}</em> for a successful start or for an already started application (which are however omitted from the <em>AppNames</em> list), and reports <em>{error, {AppName,Reason}}</em> for errors, where <em>Reason</em> is any possible reason returned by <strong></strong><em>application:start/1,2</em> when starting a specific dependency. In case of an error, the applications that were started by the function are stopped to bring the set of running applications back to its initial state.</p>
<pre>
<strong></strong>
start(Application) -&gt; ok | {error, Reason}

</pre>

<pre>
<strong></strong>
start(Application, Type) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Application = atom()</p><p>Type = <strong>restart_type()</strong></p><p>Reason = term()</p><p>Starts <em>Application</em>. If it is not loaded, the application controller will first load it using <em>load/1</em>. It will make sure any included applications are loaded, but will not start them. That is assumed to be taken care of in the code for <em>Application</em>.</p><p>The application controller checks the value of the application specification key <em>applications</em>, to ensure that all applications that should be started before this application are running. If not, <em>{error,{not_started,App}}</em> is returned, where <em>App</em> is the name of the missing application.</p><p>The application controller then creates an <em>application master</em> for the application. The application master is the group leader of all the processes in the application. The application master starts the application by calling the application callback function <em>Module:start/2</em> as defined by the application specification key <em>mod</em>.</p><p>The <em>Type</em> argument specifies the type of the application. If omitted, it defaults to <em>temporary</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If a transient application terminates with <em>Reason == normal</em>, this is reported but no other applications are terminated. If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If a temporary application terminates, this is reported but no other applications are terminated.</p>
  </dd>

</dl>
<p>Note that it is always possible to stop an application explicitly by calling <em>stop/1</em>. Regardless of the type of the application, no other applications will be affected.</p><p>Note also that the transient type is of little practical use, since when a supervision tree terminates, the reason is set to <em>shutdown</em>, not <em>normal</em>.</p>
<pre>
<strong></strong>
start_type() -&gt; StartType | undefined | local

</pre>
<p>Types:</p><p>StartType = <strong>start_type()</strong></p><p>This function is intended to be called by a process belonging to an application, when the application is being started, to determine the start type which is either <em>StartType</em> or <em>local</em>.</p><p>See <strong></strong><em>Module:start/2</em> for a description of <em>StartType</em>.</p><p><em>local</em> is returned if only parts of the application is being restarted (by a supervisor), or if the function is called outside a startup.</p><p>If the process executing the call does not belong to any application, the function returns <em>undefined</em>.</p>
<pre>
<strong></strong>
stop(Application) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Application = atom()</p><p>Reason = term()</p><p>Stops <em>Application</em>. The application master calls <em>Module:prep_stop/1</em>, if such a function is defined, and then tells the top supervisor of the application to shutdown (see <em>supervisor(3erl)</em>). This means that the entire supervision tree, including included applications, is terminated in reversed start order. After the shutdown, the application master calls <em>Module:stop/1</em>. <em>Module</em> is the callback module as defined by the application specification key <em>mod</em>.</p><p>Last, the application master itself terminates. Note that all processes with the application master as group leader, i.e. processes spawned from a process belonging to the application, thus are terminated as well.</p><p>When stopped, the application is still loaded.</p><p>In order to stop a distributed application, <em>stop/1</em> has to be called on all nodes where it can execute (that is, on all nodes where it has been started). The call to <em>stop/1</em> on the node where the application currently executes will stop its execution. The application will not be moved between nodes due to <em>stop/1</em> being called on the node where the application currently executes before <em>stop/1</em> is called on the other nodes.</p>
<pre>
<strong></strong>
takeover(Application, Type) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Application = atom()</p><p>Type = <strong>restart_type()</strong></p><p>Reason = term()</p><p>Performs a takeover of the distributed application <em>Application</em>, which executes at another node <em>Node</em>. At the current node, the application is restarted by calling <em>Module:start({takeover,Node},StartArgs)</em>. <em>Module</em> and <em>StartArgs</em> are retrieved from the loaded application specification. The application at the other node is not stopped until the startup is completed, i.e. when <em>Module:start/2</em> and any calls to <em>Module:start_phase/3</em> have returned.</p><p>Thus two instances of the application will run simultaneously during the takeover, which makes it possible to transfer data from the old to the new instance. If this is not acceptable behavior, parts of the old instance may be shut down when the new instance is started. Note that the application may not be stopped entirely however, at least the top supervisor must remain alive.</p><p>See <em>start/1,2</em> for a description of <em>Type</em>.</p>
<pre>
<strong></strong>
unload(Application) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Application = atom()</p><p>Reason = term()</p><p>Unloads the application specification for <em>Application</em> from the application controller. It will also unload the application specifications for any included applications. Note that the function does not purge the actual Erlang object code.</p>
<pre>
<strong></strong>
unset_env(Application, Par) -&gt; ok

</pre>

<pre>
<strong></strong>
unset_env(Application, Par, Opts) -&gt; ok

</pre>
<p>Types:</p><p>Application = Par = atom()</p><p>Opts = [{timeout, timeout()} | {persistent, boolean()}]</p><p>Removes the configuration parameter <em>Par</em> and its value for <em>Application</em>.</p><p><em>unset_env/2</em> uses the standard <em>gen_server</em> timeout value (5000 ms). The <em>timeout</em> option can be provided if another timeout value is useful, for example, in situations where the application controller is heavily loaded.</p><p><em>unset_env/3</em> also allows the persistent option to be passed (see <em>set_env/4</em> above).</p><p><strong></strong> Warning:</p><p>Use this function only if you know what you are doing, that is, on your own applications. It is very application and configuration parameter dependent when and how often the value is read by the application, and careless use of this function may put the application in a weird, inconsistent, and malfunctioning state.</p>
<pre>
<strong></strong>
which_applications() -&gt; [{Application, Description, Vsn}]

</pre>

<pre>
<strong></strong>
which_applications(Timeout) -&gt; [{Application, Description, Vsn}]

</pre>
<p>Types:</p><p>Timeout = timeout()</p><p>Application = atom()</p><p>Description = Vsn = string()</p><p>Returns a list with information about the applications which are currently running. <em>Application</em> is the application name. <em>Description</em> and <em>Vsn</em> are the values of its <em>description</em> and <em>vsn</em> application specification keys, respectively.</p><p><em>which_applications/0</em> uses the standard <em>gen_server</em> timeout value (5000 ms). A <em>Timeout</em> argument can be provided if another timeout value is useful, for example, in situations where the application controller is heavily loaded.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACK MODULE</h2>
        <div class="sectioncontent">
<p>The following functions should be exported from an <em>application</em> callback module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> Module:start(StartType, StartArgs) -&gt; {ok, Pid} | {ok, Pid, State} | {error, Reason}</p><p>Types:</p><p>StartType = <strong>start_type()</strong></p><p>StartArgs = term()</p><p>Pid = pid()</p><p>State = term()</p><p>This function is called whenever an application is started using <em>application:start/1,2</em>, and should start the processes of the application. If the application is structured according to the OTP design principles as a supervision tree, this means starting the top supervisor of the tree.</p><p><em>StartType</em> defines the type of start:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>normal</em> if it's a normal startup.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>normal</em> also if the application is distributed and started at the current node due to a failover from another node, and the application specification key <em>start_phases == undefined</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{takeover,Node}</em> if the application is distributed and started at the current node due to a takeover from <em>Node</em>, either because <em>application:takeover/2</em> has been called or because the current node has higher priority than <em>Node</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{failover,Node}</em> if the application is distributed and started at the current node due to a failover from <em>Node</em>, and the application specification key <em>start_phases /= undefined</em>.</p>
  </dd>

</dl>
<p><em>StartArgs</em> is the <em>StartArgs</em> argument defined by the application specification key <em>mod</em>.</p><p>The function should return <em>{ok,Pid}</em> or <em>{ok,Pid,State}</em> where <em>Pid</em> is the pid of the top supervisor and <em>State</em> is any term. If omitted, <em>State</em> defaults to <em>[]</em>. If later the application is stopped, <em>State</em> is passed to <em>Module:prep_stop/1</em>.</p><p><strong></strong> Module:start_phase(Phase, StartType, PhaseArgs) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Phase = atom()</p><p>StartType = <strong>start_type()</strong></p><p>PhaseArgs = term()</p><p>Pid = pid()</p><p>State = state()</p><p>This function is used to start an application with included applications, when there is a need for synchronization between processes in the different applications during startup.</p><p>The start phases is defined by the application specification key <em>start_phases == [{Phase,PhaseArgs}]</em>. For included applications, the set of phases must be a subset of the set of phases defined for the including application.</p><p>The function is called for each start phase (as defined for the primary application) for the primary application and all included applications, for which the start phase is defined.</p><p>See <em>Module:start/2</em> for a description of <em>StartType</em>.</p><p><strong></strong> Module:prep_stop(State) -&gt; NewState</p><p>Types:</p><p>State = NewState = term()</p><p>This function is called when an application is about to be stopped, before shutting down the processes of the application.</p><p><em>State</em> is the state returned from <em>Module:start/2</em>, or <em>[]</em> if no state was returned. <em>NewState</em> is any term and will be passed to <em>Module:stop/1</em>.</p><p>The function is optional. If it is not defined, the processes will be terminated and then <em>Module:stop(State)</em> is called.</p><p><strong></strong> Module:stop(State)</p><p>Types:</p><p>State = term()</p><p>This function is called whenever an application has stopped. It is intended to be the opposite of <em>Module:start/2</em> and should do any necessary cleaning up. The return value is ignored.</p><p><em>State</em> is the return value of <em>Module:prep_stop/1</em>, if such a function exists. Otherwise <em>State</em> is taken from the return value of <em>Module:start/2</em>.</p><p><strong></strong> Module:config_change(Changed, New, Removed) -&gt; ok</p><p>Types:</p><p>Changed = [{Par,Val}]</p><p>New = [{Par,Val}]</p><p>Removed = [Par]</p><p> Par = atom()</p><p> Val = term()</p><p>This function is called by an application after a code replacement, if there are any changes to the configuration parameters.</p><p><em>Changed</em> is a list of parameter-value tuples with all configuration parameters with changed values, <em>New</em> is a list of parameter-value tuples with all configuration parameters that have been added, and <em>Removed</em> is a list of all parameters that have been removed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO application&hellip;</h2>
        <div class="sectioncontent">
<p><strong>OTP Design Principles</strong>, <a href="../man7/kernel.7.html"><strong>kernel</strong>(7)</a></strong>, <a href="../man5/app.5.html"><strong>app</strong>(5)</a></strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="any.3erl.html"><span aria-hidden="true">&larr;</span> any.3erl: The corba any type</a></li>
   <li class="next"><a href="array.3erl.html">array.3erl: Functional, extendible arrays. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

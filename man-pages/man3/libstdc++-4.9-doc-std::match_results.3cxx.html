<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>std::match_results: Std::match_results _bi_iter, _alloc  -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Std::match_results _bi_iter, _alloc  -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="std::match_results (3cxx) manual">
  <meta name="twitter:description" content="Std::match_results _bi_iter, _alloc  -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libstdc++-4.9-doc-std::match_results-3cxx.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3cxx/libstdc++-4.9-doc-std::match_results.3cxx.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="std::match_results (3cxx) manual" />
  <meta property="og:description" content="Std::match_results _bi_iter, _alloc  -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libstdc++-4.9-doc-std::match_results-3cxx.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">std::match_results<small> (3cxx)</small></h1>
        <p class="lead">Std::match_results _bi_iter, _alloc  -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::match_results.3cxx.html">
      <span itemprop="name">std::match_results: Std::match_results _bi_iter, _alloc  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libstdc++-4.9-doc/">
      <span itemprop="name">libstdc++-4.9-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::match_results.3cxx.html">
      <span itemprop="name">std::match_results: Std::match_results _bi_iter, _alloc  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Inherits <strong>std::vector&lt; sub_match&lt; _Bi_iter &gt;, _Alloc &gt;</strong>.</p><h3>Public Member Functions</h3>
<p>bool <strong>ready</strong> () const </p>
<h3>Private Types</h3>
<p>typedef</p><p>_Alloc_traits::const_pointer <strong>const_pointer</strong>"</p><p>typedef <strong>std::reverse_iterator</strong></p><p>&lt; const_iterator &gt; <strong>const_reverse_iterator</strong>"</p><p>typedef _Base::pointer <strong>pointer</strong></p><p>typedef <strong>std::reverse_iterator</strong></p><p>&lt; iterator &gt; <strong>reverse_iterator</strong>"</p>
<h3>Private Member Functions</h3>
<p>pointer <strong>_M_allocate</strong> (size_t __n)</p><p>pointer <strong>_M_allocate_and_copy</strong> (size_type __n, _ForwardIterator __first, _ForwardIterator __last)</p><p>void <strong>_M_assign_aux</strong> (_InputIterator __first, _InputIterator __last, <strong>std::input_iterator_tag</strong>)</p><p>void <strong>_M_assign_aux</strong> (_ForwardIterator __first, _ForwardIterator __last, <strong>std::forward_iterator_tag</strong>)</p><p>void <strong>_M_assign_dispatch</strong> (_Integer __n, _Integer __val, __true_type)</p><p>void <strong>_M_assign_dispatch</strong> (_InputIterator __first, _InputIterator __last, __false_type)</p><p>size_type <strong>_M_check_len</strong> (size_type __n, const char *__s) const</p><p>void <strong>_M_deallocate</strong> (pointer __p, size_t __n)</p><p>void <strong>_M_default_append</strong> (size_type __n)</p><p>void <strong>_M_default_initialize</strong> (size_type __n)</p><p>void <strong>_M_emplace_back_aux</strong> (_Args &&...__args)</p><p>iterator <strong>_M_erase</strong> (iterator __position)</p><p>iterator <strong>_M_erase</strong> (iterator __first, iterator __last)</p><p>void <strong>_M_erase_at_end</strong> (pointer __pos) noexcept</p><p>void <strong>_M_fill_assign</strong> (size_type __n, const <strong>value_type</strong> &__val)</p><p>void <strong>_M_fill_initialize</strong> (size_type __n, const <strong>value_type</strong> &__value)</p><p>void <strong>_M_fill_insert</strong> (iterator __pos, size_type __n, const <strong>value_type</strong> &__x)</p><p>_Tp_alloc_type & <strong>_M_get_Tp_allocator</strong> () noexcept</p><p>const _Tp_alloc_type & <strong>_M_get_Tp_allocator</strong> () const noexcept</p><p>void <strong>_M_initialize_dispatch</strong> (_Integer __n, _Integer __value, __true_type)</p><p>void <strong>_M_initialize_dispatch</strong> (_InputIterator __first, _InputIterator __last, __false_type)</p><p>void <strong>_M_insert_aux</strong> (iterator __position, _Args &&...__args)</p><p>void <strong>_M_insert_dispatch</strong> (iterator __pos, _Integer __n, _Integer __val, __true_type)</p><p>void <strong>_M_insert_dispatch</strong> (iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)</p><p>void <strong>_M_range_check</strong> (size_type __n) const</p><p>void <strong>_M_range_initialize</strong> (_InputIterator __first, _InputIterator __last, <strong>std::input_iterator_tag</strong>)</p><p>void <strong>_M_range_initialize</strong> (_ForwardIterator __first, _ForwardIterator __last, <strong>std::forward_iterator_tag</strong>)</p><p>void <strong>_M_range_insert</strong> (iterator __pos, _InputIterator __first, _InputIterator __last, <strong>std::input_iterator_tag</strong>)</p><p>void <strong>_M_range_insert</strong> (iterator __pos, _ForwardIterator __first, _ForwardIterator __last, <strong>std::forward_iterator_tag</strong>)</p><p>bool <strong>_M_shrink_to_fit</strong> ()</p><p>void <strong>assign</strong> (size_type __n, const <strong>value_type</strong> &__val)</p><p>void <strong>assign</strong> (_InputIterator __first, _InputIterator __last)</p><p>void <strong>assign</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l)</p><p><strong>reference</strong> <strong>at</strong> (size_type __n)</p><p><strong>const_reference</strong> <strong>at</strong> (size_type __n) const</p><p><strong>reference</strong> <strong>back</strong> () noexcept</p><p><strong>const_reference</strong> <strong>back</strong> () const noexcept</p><p>iterator <strong>begin</strong> () noexcept</p><p>size_type <strong>capacity</strong> () const noexcept</p><p>void <strong>clear</strong> () noexcept</p><p><strong>const_reverse_iterator</strong> <strong>crbegin</strong> () const noexcept</p><p><strong>const_reverse_iterator</strong> <strong>crend</strong> () const noexcept</p><p><strong>sub_match</strong>&lt; _Bi_iter &gt; * <strong>data</strong> () noexcept</p><p>const <strong>sub_match</strong>&lt; _Bi_iter &gt; * <strong>data</strong> () const noexcept</p><p>iterator <strong>emplace</strong> (const_iterator __position, _Args &&...__args)</p><p>void <strong>emplace_back</strong> (_Args &&...__args)</p><p>iterator <strong>end</strong> () noexcept</p><p>iterator <strong>erase</strong> (const_iterator __position)</p><p>iterator <strong>erase</strong> (const_iterator __first, const_iterator __last)</p><p><strong>reference</strong> <strong>front</strong> () noexcept</p><p><strong>const_reference</strong> <strong>front</strong> () const noexcept</p><p>iterator <strong>insert</strong> (const_iterator __position, const <strong>value_type</strong> &__x)</p><p>iterator <strong>insert</strong> (const_iterator __position, <strong>value_type</strong> &&__x)</p><p>iterator <strong>insert</strong> (const_iterator __position, initializer_list&lt; <strong>value_type</strong> &gt; __l)</p><p>iterator <strong>insert</strong> (const_iterator __position, size_type __n, const <strong>value_type</strong> &__x)</p><p>iterator <strong>insert</strong> (const_iterator __position, _InputIterator __first, _InputIterator __last)</p><p><strong>reference</strong> <strong>operator[]</strong> (size_type __n) noexcept</p><p><strong>const_reference</strong> <strong>operator[]</strong> (size_type __n) const noexcept</p><p>void <strong>pop_back</strong> () noexcept</p><p>void <strong>push_back</strong> (const <strong>value_type</strong> &__x)</p><p>void <strong>push_back</strong> (<strong>value_type</strong> &&__x)</p><p><strong>reverse_iterator</strong> <strong>rbegin</strong> () noexcept</p><p><strong>const_reverse_iterator</strong> <strong>rbegin</strong> () const noexcept</p><p><strong>reverse_iterator</strong> <strong>rend</strong> () noexcept</p><p><strong>const_reverse_iterator</strong> <strong>rend</strong> () const noexcept</p><p>void <strong>reserve</strong> (size_type __n)</p><p>void <strong>resize</strong> (size_type __new_size)</p><p>void <strong>resize</strong> (size_type __new_size, const <strong>value_type</strong> &__x)</p><p>void <strong>shrink_to_fit</strong> ()</p><p>void <strong>swap</strong> (<strong>vector</strong> &__x) noexcept(_Alloc_traits::_S_nothrow_swap())</p>
<h3>Private Attributes</h3>
<p>_Vector_impl <strong>_M_impl</strong></p>
<h3>Friends</h3>
<p>template&lt;typename _Bp , typename _Ap , typename _Cp , typename _Rp , __detail::_RegexExecutorPolicy , bool &gt; bool <strong>__detail::__regex_algo_impl</strong> (_Bp, _Bp, <strong>match_results</strong>&lt; _Bp, _Ap &gt; &, const <strong>basic_regex</strong>&lt; _Cp, _Rp &gt; &, <strong>regex_constants::match_flag_type</strong>)</p><p>template&lt;typename , typename , typename , bool &gt; class <strong>__detail::_Executor</strong></p><p>template&lt;typename , typename , typename &gt; class <strong>regex_iterator</strong></p>
<h3>10.? Public Types</h3>
<p>typedef <strong>sub_match</strong>&lt; _Bi_iter &gt; <strong>value_type</strong></p><p>typedef const <strong>value_type</strong> & <strong>const_reference</strong></p><p>typedef <strong>const_reference</strong> <strong>reference</strong></p><p>typedef _Base_type::const_iterator <strong>const_iterator</strong></p><p>typedef const_iterator <strong>iterator</strong></p><p>typedef</p><p>__iter_traits::difference_type <strong>difference_type</strong>"</p><p>typedef <strong>allocator_traits</strong></p><p>&lt; _Alloc &gt;::size_type <strong>size_type</strong>"</p><p>typedef _Alloc <strong>allocator_type</strong></p><p>typedef __iter_traits::value_type <strong>char_type</strong></p><p>typedef <strong>std::basic_string</strong></p><p>&lt; char_type &gt; <strong>string_type</strong>"</p>
<h3>28.10.1 Construction, Copying, and Destruction</h3>
<p><strong>match_results</strong> (const _Alloc &__a=_Alloc())</p><p><strong>match_results</strong> (const <strong>match_results</strong> &__rhs)=default</p><p><strong>match_results</strong> (<strong>match_results</strong> &&__rhs) noexcept=default</p><p><strong>match_results</strong> & <strong>operator=</strong> (const <strong>match_results</strong> &__rhs)=default</p><p><strong>match_results</strong> & <strong>operator=</strong> (<strong>match_results</strong> &&__rhs)=default</p><p><strong>~match_results</strong> ()</p>
<h3>28.10.2 Size</h3>
<p>size_type <strong>size</strong> () const </p><p>size_type <strong>max_size</strong> () const </p><p>bool <strong>empty</strong> () const </p>
<h3>10.3 Element Access</h3>
<p>difference_type <strong>length</strong> (size_type __sub=0) const </p><p>difference_type <strong>position</strong> (size_type __sub=0) const </p><p><strong>string_type</strong> <strong>str</strong> (size_type __sub=0) const </p><p><strong>const_reference</strong> <strong>operator[]</strong> (size_type __sub) const </p><p><strong>const_reference</strong> <strong>prefix</strong> () const </p><p><strong>const_reference</strong> <strong>suffix</strong> () const </p><p>const_iterator <strong>begin</strong> () const </p><p>const_iterator <strong>cbegin</strong> () const </p><p>const_iterator <strong>end</strong> () const </p><p>const_iterator <strong>cend</strong> () const </p>
<h3>10.4 Formatting</h3>
<p>These functions perform formatted substitution of the matched character sequences into their target. The format specifiers and escape sequences accepted by these functions are determined by their flags parameter as documented above. template&lt;typename _Out_iter &gt; _Out_iter <strong>format</strong> (_Out_iter __out, const char_type *__fmt_first, const char_type *__fmt_last, <strong>match_flag_type</strong> __flags=<strong>regex_constants::format_default</strong>) const </p><p>template&lt;typename _Out_iter , typename _St , typename _Sa &gt; _Out_iter <strong>format</strong> (_Out_iter __out, const <strong>basic_string</strong>&lt; char_type, _St, _Sa &gt; &__fmt, <strong>match_flag_type</strong> __flags=<strong>regex_constants::format_default</strong>) const </p><p>template&lt;typename _St , typename _Sa &gt; <strong>basic_string</strong>&lt; char_type, _St, _Sa &gt; <strong>format</strong> (const <strong>basic_string</strong>&lt; char_type, _St, _Sa &gt; &__fmt, <strong>match_flag_type</strong> __flags=<strong>regex_constants::format_default</strong>) const </p><p><strong>string_type</strong> <strong>format</strong> (const char_type *__fmt, <strong>match_flag_type</strong> __flags=<strong>regex_constants::format_default</strong>) const </p>
<h3>10.5 Allocator</h3>
<p>allocator_type <strong>get_allocator</strong> () const </p>
<h3>10.6 Swap</h3>
<p>void <strong>swap</strong> (<strong>match_results</strong> &__that)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;class std::match_results&lt; _Bi_iter, _Alloc &gt;</h3>
<p>The results of a match or search operation.</p><p>A collection of character sequences representing the result of a regular expression match. Storage for the collection is allocated and freed as necessary by the member functions of class template match_results.</p><p>This class satisfies the Sequence requirements, with the exception that only the operations defined for a const-qualified Sequence are supported.</p><p>The sub_match object stored at index 0 represents sub-expression 0, i.e. the whole match. In this case the sub_match member matched is always true. The sub_match object stored at index n denotes what matched the marked sub-expression n within the matched expression. If the sub-expression n participated in a regular expression match then the sub_match member matched evaluates to true, and members first and second denote the range of characters [first, second) which formed that match. Otherwise matched is false, and members first and second point to the end of the sequence that was searched.</p><p>Definition at line 38 of file regex.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::\fBmatch_results\fP (const _Alloc &__a = \fC_Alloc()\fP)\fC [inline]\fP, \fC [explicit]\fP</h3>
<p>Constructs a default match_results container.</p><p><strong>Postcondition:</strong></p><p>size() returns 0 and str() returns an empty string.</p><p>Definition at line 1570 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::\fBmatch_results\fP (const \fBmatch_results\fP&lt; _Bi_iter, _Alloc &gt; &__rhs)\fC [default]\fP</h3>
<p>Copy constructs a match_results.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::\fBmatch_results\fP (\fBmatch_results\fP&lt; _Bi_iter, _Alloc &gt; &&__rhs)\fC [default]\fP, \fC [noexcept]\fP</h3>
<p>Move constructs a match_results.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::~\fBmatch_results\fP ()\fC [inline]\fP</h3>
<p>Destroys a match_results object.</p><p>Definition at line 1599 of file regex.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; const_iterator \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::begin () const\fC [inline]\fP</h3>
<p>Gets an iterator to the start of the sub_match collection.</p><p>Definition at line 1756 of file regex.h.</p><p>Referenced by std::match_results&lt; _Bi_iter &gt;::cbegin().</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; const_iterator \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::cbegin () const\fC [inline]\fP</h3>
<p>Gets an iterator to the start of the sub_match collection.</p><p>Definition at line 1763 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; const_iterator \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::cend () const\fC [inline]\fP</h3>
<p>Gets an iterator to one-past-the-end of the collection.</p><p>Definition at line 1777 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; bool \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::empty () const\fC [inline]\fP</h3>
<p>Indicates if the match_results contains no results.</p><p><strong>Return values:</strong></p><p><em>true</em> The match_results object is empty.</p><p><em>false</em> The match_results object is not empty.</p><p>Definition at line 1643 of file regex.h.</p><p>Referenced by std::match_results&lt; _Bi_iter &gt;::prefix(), and std::match_results&lt; _Bi_iter &gt;::suffix().</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; const_iterator \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::end () const\fC [inline]\fP</h3>
<p>Gets an iterator to one-past-the-end of the collection.</p><p>Definition at line 1770 of file regex.h.</p><p>Referenced by std::match_results&lt; _Bi_iter &gt;::cend().</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; template&lt;typename _Out_iter &gt; _Out_iter \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::format (_Out_iter__out, const char_type *__fmt_first, const char_type *__fmt_last, \fBmatch_flag_type\fP__flags = \fC\fBregex_constants::format_default\fP\fP) const</h3>
<p><strong>Precondition:</strong></p><p>ready() == true</p><p>Referenced by std::match_results&lt; _Bi_iter &gt;::format().</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; template&lt;typename _Out_iter , typename _St , typename _Sa &gt; _Out_iter \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::format (_Out_iter__out, const \fBbasic_string\fP&lt; char_type, _St, _Sa &gt; &__fmt, \fBmatch_flag_type\fP__flags = \fC\fBregex_constants::format_default\fP\fP) const\fC [inline]\fP</h3>
<p><strong>Precondition:</strong></p><p>ready() == true</p><p>Definition at line 1806 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; template&lt;typename _St , typename _Sa &gt; \fBbasic_string\fP&lt;char_type, _St, _Sa&gt; \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::format (const \fBbasic_string\fP&lt; char_type, _St, _Sa &gt; &__fmt, \fBmatch_flag_type\fP__flags = \fC\fBregex_constants::format_default\fP\fP) const\fC [inline]\fP</h3>
<p><strong>Precondition:</strong></p><p>ready() == true</p><p>Definition at line 1818 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBstring_type\fP \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::format (const char_type *__fmt, \fBmatch_flag_type\fP__flags = \fC\fBregex_constants::format_default\fP\fP) const\fC [inline]\fP</h3>
<p><strong>Precondition:</strong></p><p>ready() == true</p><p>Definition at line 1830 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; allocator_type \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::get_allocator () const\fC [inline]\fP</h3>
<p>Gets a copy of the allocator.</p><p>Definition at line 1852 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; difference_type \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::length (size_type__sub = \fC0\fP) const\fC [inline]\fP</h3>
<p>Gets the length of the indicated submatch.</p><p><strong>Parameters:</strong></p><p><em>__sub</em> indicates the submatch.</p><p><strong>Precondition:</strong></p><p>ready() == true</p><p>This function returns the length of the indicated submatch, or the length of the entire match if __sub is zero (the default).</p><p>Definition at line 1662 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; size_type \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::max_size () const\fC [inline]\fP</h3>
<p>Gets the number of matches and submatches. The number of matches for a given regular expression will be either 0 if there was no match or mark_count() + 1 if a match was successful. Some matches may be empty.</p><p><strong>Returns:</strong></p><p>the number of matches found.</p><p>Definition at line 1634 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBmatch_results\fP& \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::operator= (const \fBmatch_results\fP&lt; _Bi_iter, _Alloc &gt; &__rhs)\fC [default]\fP</h3>
<p>Assigns rhs to *this.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBmatch_results\fP& \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::operator= (\fBmatch_results\fP&lt; _Bi_iter, _Alloc &gt; &&__rhs)\fC [default]\fP</h3>
<p>Move-assigns rhs to *this.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBconst_reference\fP \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::operator[] (size_type__sub) const\fC [inline]\fP</h3>
<p>Gets a sub_match reference for the match or submatch.</p><p><strong>Parameters:</strong></p><p><em>__sub</em> indicates the submatch.</p><p><strong>Precondition:</strong></p><p>ready() == true</p><p>This function gets a reference to the indicated submatch, or the entire match if __sub is zero.</p><p>If __sub &gt;= size() then this function returns a sub_match with a special value indicating no submatch.</p><p>Definition at line 1710 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; difference_type \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::position (size_type__sub = \fC0\fP) const\fC [inline]\fP</h3>
<p>Gets the offset of the beginning of the indicated submatch.</p><p><strong>Parameters:</strong></p><p><em>__sub</em> indicates the submatch.</p><p><strong>Precondition:</strong></p><p>ready() == true</p><p>This function returns the offset from the beginning of the target sequence to the beginning of the submatch, unless the value of __sub is zero (the default), in which case this function returns the offset from the beginning of the target sequence to the beginning of the match.</p><p>Returns -1 if __sub is out of range.</p><p>Definition at line 1679 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBconst_reference\fP \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::prefix () const\fC [inline]\fP</h3>
<p>Gets a sub_match representing the match prefix.</p><p><strong>Precondition:</strong></p><p>ready() == true</p><p>This function gets a reference to a sub_match object representing the part of the target range between the start of the target range and the start of the match.</p><p>Definition at line 1727 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; bool \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::ready () const\fC [inline]\fP</h3>
<p>Indicates if the match_results is ready.</p><p><strong>Return values:</strong></p><p><em>true</em> The object has a fully-established result state.</p><p><em>false</em> The object is not ready.</p><p>Definition at line 1610 of file regex.h.</p><p>Referenced by std::match_results&lt; _Bi_iter &gt;::operator[](), std::match_results&lt; _Bi_iter &gt;::prefix(), and std::match_results&lt; _Bi_iter &gt;::suffix().</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; size_type \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::size () const\fC [inline]\fP</h3>
<p>Gets the number of matches and submatches. The number of matches for a given regular expression will be either 0 if there was no match or mark_count() + 1 if a match was successful. Some matches may be empty.</p><p><strong>Returns:</strong></p><p>the number of matches found.</p><p>Definition at line 1627 of file regex.h.</p><p>Referenced by std::match_results&lt; _Bi_iter &gt;::empty(), std::match_results&lt; _Bi_iter &gt;::operator[](), and std::match_results&lt; _Bi_iter &gt;::position().</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBstring_type\fP \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::str (size_type__sub = \fC0\fP) const\fC [inline]\fP</h3>
<p>Gets the match or submatch converted to a string type.</p><p><strong>Parameters:</strong></p><p><em>__sub</em> indicates the submatch.</p><p><strong>Precondition:</strong></p><p>ready() == true</p><p>This function gets the submatch (or match, if __sub is zero) extracted from the target range and converted to the associated string type.</p><p>Definition at line 1695 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; \fBconst_reference\fP \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::suffix () const\fC [inline]\fP</h3>
<p>Gets a sub_match representing the match suffix.</p><p><strong>Precondition:</strong></p><p>ready() == true</p><p>This function gets a reference to a sub_match object representing the part of the target range between the end of the match and the end of the target range.</p><p>Definition at line 1744 of file regex.h.</p>
<h3>template&lt;typename _Bi_iter, typename _Alloc = allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; void \fBstd::match_results\fP&lt; _Bi_iter, _Alloc &gt;::swap (\fBmatch_results\fP&lt; _Bi_iter, _Alloc &gt; &__that)\fC [inline]\fP</h3>
<p>Swaps the contents of two match_results.</p><p>Definition at line 1866 of file regex.h.</p><p>Referenced by std::match_results&lt; _Bi_iter &gt;::swap().</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for libstdc++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libstdc++-4.8-doc-std::match_results.3cxx.html"><span aria-hidden="true">&larr;</span> std::match_results.3cxx: Std::match_results _bi_iter, _alloc  -</a></li>
   <li class="next"><a href="libstdc++-4.8-doc-std::mem_fun1_ref_t.3cxx.html">std::mem_fun1_ref_t.3cxx: Std::mem_fun1_ref_t _ret, _tp, _arg  - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

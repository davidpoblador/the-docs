<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>popt: Parse command line options</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parse command line options">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="popt (3) manual">
  <meta name="twitter:description" content="Parse command line options">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpopt-dev-popt-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/popt.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="popt (3) manual" />
  <meta property="og:description" content="Parse command line options" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpopt-dev-popt-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">popt<small> (3)</small></h1>
        <p class="lead">Parse command line options</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/popt.3.html">
      <span itemprop="name">popt: Parse command line options</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpopt-dev/">
      <span itemprop="name">libpopt-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/popt.3.html">
      <span itemprop="name">popt: Parse command line options</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<strong>#include &lt;popt.h&gt;</strong>

<strong>poptContext poptGetContext(const char * </strong><em>name</em><strong>, int </strong><em>argc</em><strong>,</strong>
<strong>                           const char ** </strong><em>argv</em><strong>,</strong>
<strong>                           const struct poptOption * </strong><em>options</em><strong>,</strong>
<strong>                           int </strong><em>flags</em><strong>);</strong>

<strong>void poptFreeContext(poptContext </strong><em>con</em><strong>);</strong>

<strong>void poptResetContext(poptContext </strong><em>con</em><strong>);</strong>

<strong>int poptGetNextOpt(poptContext </strong><em>con</em><strong>);</strong>

<strong>const char * poptGetOptArg(poptContext </strong><em>con</em><strong>);</strong>

<strong>const char * poptGetArg(poptContext </strong><em>con</em><strong>);</strong>

<strong>const char * poptPeekArg(poptContext </strong><em>con</em><strong>);</strong>

<strong>const char ** poptGetArgs(poptContext </strong><em>con</em><strong>);</strong>

<strong>const char *const poptStrerror(const int </strong><em>error</em><strong>);</strong>

<strong>const char * poptBadOption(poptContext </strong><em>con</em><strong>, int </strong><em>flags</em><strong>);</strong>

<strong>int poptReadDefaultConfig(poptContext </strong><em>con</em><strong>, int </strong><em>flags</em><strong>);</strong>

<strong>int poptReadConfigFile(poptContext </strong><em>con</em><strong>, char * </strong><em>fn</em><strong>);</strong>

<strong>int poptAddAlias(poptContext </strong><em>con</em><strong>, struct poptAlias </strong><em>alias</em><strong>,</strong>
<strong>                 int </strong><em>flags</em><strong>);</strong>

<strong>int poptParseArgvString(char * </strong><em>s</em><strong>, int *  </strong><em>argcPtr</em><strong>,</strong>
<strong>                        const char *** </strong><em>argvPtr</em><strong>);</strong>

<strong>int poptDupArgv(int </strong><em>argc</em><strong>, const char ** </strong><em>argv</em><strong>, int * </strong><em>argcPtr</em><strong>,</strong>
<strong>                        const char *** </strong><em>argvPtr</em><strong>);</strong>

<strong>int poptStuffArgs(poptContext </strong><em>con</em><strong>, const char ** </strong><em>argv</em><strong>);</strong>

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The popt library exists essentially for parsing command-line options. It is found superior in many ways when compared to parsing the argv array by hand or using the getopt functions <strong>getopt()</strong> and <strong>getopt_long()</strong> [see <a href="../man3/getopt.3.html"><strong>getopt</strong>(3)</a>]. Some specific advantages of popt are: it does not utilize global variables, thus enabling multiple passes in parsing <em>argv</em> ; it can parse an arbitrary array of <em>argv</em>-style elements,  allowing parsing of command-line-strings from any source; it provides a standard method of option aliasing (to be discussed at length below.); it can exec external option filters; and, finally, it can automatically generate help and usage messages for the application.</p><p>Like <strong>getopt_long()</strong>, the popt library supports short and long style options.  Recall that a <strong>short option</strong> consists of a - character followed by a single alphanumeric character. A <strong>long option</strong>, common in GNU utilities, consists of two - characters followed by a string made up of letters, numbers and hyphens.  Long options are optionally allowed to begin with a single -, primarily to allow command-line compatibility between popt applications and X toolkit applications. Either type of option may be followed by an argument.  A space separates a short option from its arguments; either a space or an = separates a long option from an argument.</p><p>The popt library is highly portable and should work on any POSIX platform.  The latest version is distributed with rpm and is always available from: ftp://ftp.rpm.org/pub/rpm/dist.</p><p>It may be redistributed under the X consortium license, see the file COPYING in the popt source distribution for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BASIC POPT USAGE</h2>
        <div class="sectioncontent">
<h3>1. THE OPTION TABLE</h3>
<p>Applications provide popt with information on their command-line options by means of an "option table," i.e., an array of <strong>struct poptOption</strong> structures:</p><p>#include &lt;popt.h&gt;</p>
<pre>
struct poptOption {
    const char * longName; /* may be NULL */
    char shortName;        /* may be '&#92;0' */
    int argInfo;
    void * arg;            /* depends on argInfo */
    int val;               /* 0 means don't return, just update flag */
    char * descrip;        /* description for autohelp -- may be NULL */
    char * argDescrip;     /* argument description for autohelp */
};
</pre>
<p>Each member of the table defines a single option that may be passed to the program.  Long and short options are considered a single option that may occur in two different forms.  The first two members, <em>longName</em> and <em>shortName</em>, define the names of the option; the first is a long name, while the latter is a single character.</p><p>The <em>argInfo</em> member tells popt what type of argument is expected after the option.  If no argument is expected, <strong>POPT_ARG_NONE</strong> should be used. The rest of the valid values are shown in the following table:</p><table class="table table-striped">
<tr>
<th>Value</th>
<th>Description</th>
<th>arg Type</th></tr>

<tr>
<td>POPT_ARG_NONE</td>
<td>No argument expected</td>
<td>int</td></tr>

<tr>
<td>POPT_ARG_STRING</td>
<td>No type checking to be performed</td>
<td>char *</td></tr>

<tr>
<td>POPT_ARG_ARGV</td>
<td>No type checking to be performed</td>
<td>char **</td></tr>

<tr>
<td>POPT_ARG_SHORT</td>
<td>An short argument is expected</td>
<td>short</td></tr>

<tr>
<td>POPT_ARG_INT</td>
<td>An integer argument is expected</td>
<td>int</td></tr>

<tr>
<td>POPT_ARG_LONG</td>
<td>A long integer is expected</td>
<td>long</td></tr>

<tr>
<td>POPT_ARG_LONGLONG</td>
<td>A long long integer is expected</td>
<td>long long</td></tr>

<tr>
<td>POPT_ARG_VAL</td>
<td>Integer value taken from val</td>
<td>int</td></tr>

<tr>
<td>POPT_ARG_FLOAT</td>
<td>An float argument is expected</td>
<td>float</td></tr>

<tr>
<td>POPT_ARG_DOUBLE</td>
<td>A double argument is expected</td>
<td>double</td></tr>
</table><p>For numeric values, if the <em>argInfo</em> value is bitwise or'd with one of <strong>POPT_ARGFLAG_OR</strong>, <strong>POPT_ARGFLAG_AND</strong>, or <strong>POPT_ARGFLAG_XOR</strong>, the value is saved by performing an OR, AND, or XOR. If the <em>argInfo</em> value is bitwise or'd with <strong>POPT_ARGFLAG_NOT</strong>, the value will be negated before saving. For the common operations of setting and/or clearing bits, <strong>POPT_BIT_SET</strong> and <strong>POPT_BIT_CLR</strong> have the appropriate flags set to perform bit operations.</p><p>If the <em>argInfo</em> value is bitwise or'd with <strong>POPT_ARGFLAG_ONEDASH</strong>, the long argument may be given with a single - instead of two. For example, if <strong>--longopt</strong> is an option with <strong>POPT_ARGFLAG_ONEDASH</strong>, is specified, <strong>-longopt</strong> is accepted as well.</p><p>The next element, <em>arg</em>, allows popt to automatically update  program variables when the option is used. If <em>arg</em> is  <strong>NULL</strong>, it is ignored and popt takes no special action.  Otherwise it should point to a variable of the type indicated in the right-most column of the table above. A <strong>POPT_ARG_ARGV</strong> arg will (re-)allocate an array of char * string pointers, append the string argument, and add a <strong>NULL</strong> sentinel at the end of the array as needed. The target char ** address of a <strong>POPT_ARG_ARGV</strong> arg should be initialized to <strong>NULL</strong>.</p><p>If the option takes no argument (<em>argInfo</em> is  <strong>POPT_ARG_NONE</strong>), the variable pointed to by  <em>arg</em> is set to 1 when the option is used.  (Incidentally, it  will perhaps not escape the attention of hunt-and-peck typists that the value of <strong>POPT_ARG_NONE</strong> is 0.)  If the option does take  an argument, the variable that <em>arg</em> points to is updated to reflect the value of the argument. Any string is acceptable for <strong>POPT_ARG_STRING</strong> and <strong>POPT_ARG_ARGV</strong> arguments, but  <strong>POPT_ARG_INT</strong>, <strong>POPT_ARG_SHORT</strong>, <strong>POPT_ARG_LONG</strong>, <strong>POPT_ARG_LONGLONG</strong>, <strong>POPT_ARG_FLOAT</strong>, and  <strong>POPT_ARG_DOUBLE</strong> are converted to the appropriate type, and an  error returned if the conversion fails.</p><p><strong>POPT_ARG_VAL</strong> causes <em>arg</em> to be set to the (integer) value of <em>val</em> when the argument is found.  This is most often useful for mutually-exclusive arguments in cases where it is not an error for multiple arguments to occur and where you want the last argument specified to win; for example, "rm -i -f".  <strong>POPT_ARG_VAL</strong> causes the parsing function not to return a value, since the value of <em>val</em> has already been used.</p><p>If the <em>argInfo</em> value is bitwise or'd with <strong>POPT_ARGFLAG_OPTIONAL</strong>, the argument to the long option may be omitted. If the long option is used without an argument, a default value of zero or NULL will be saved (if the arg pointer is present), otherwise behavior will be identical to a long option with argument.</p><p>The next option, <em>val</em>, is the value popt's parsing function should return when the option is encountered.  If it is 0, the parsing function does not return a value, instead parsing the next command-line argument.</p><p>The last two options, <em>descrip</em> and <em>argDescrip</em> are only required if automatic help messages are desired (automatic usage messages can be generated without them). <em>descrip</em> is a text description of the argument and <em>argdescrip</em> is a short summary of the type of arguments the option expects, or NULL if the option doesn't require any arguments.</p><p>If popt should automatically provide <strong>--usage</strong> and <strong>--help</strong> (<strong>-?</strong>) options, one line in the table should be the macro <strong>POPT_AUTOHELP</strong>. This macro includes another option table (via <strong>POPT_ARG_INCLUDE_TABLE</strong> ; see below) in the main one which provides the table entries for these arguments. When <strong>--usage</strong> or <strong>--help</strong> are passed to programs which use popt's automatic help, popt displays the appropriate message on stderr as soon as it finds the option, and exits the program with a return code of 0. If you want to use popt's automatic help generation in a different way, you need to explicitly add the option entries to your programs option table instead of using <strong>POPT_AUTOHELP</strong>.</p><p>If the <em>argInfo</em> value is bitwise or'd with <strong>POPT_ARGFLAG_DOC_HIDDEN</strong>, the argument will not be shown in help output.</p><p>If the <em>argInfo</em> value is bitwise or'd with <strong>POPT_ARGFLAG_SHOW_DEFAULT</strong>, the initial value of the arg will be shown in help output.</p><p>The final structure in the table should have all the pointer values set to <strong>NULL</strong> and all the arithmetic values set to 0, marking the  end of the table. The macro <strong>POPT_TABLEEND</strong> is provided to do that.</p><p>There are two types of option table entries which do not specify command line options. When either of these types of entries are used, the <em>longName</em> element must be <strong>NULL</strong> and the <strong>shortName</strong> element must be <strong>'&#92;0'</strong>.</p><p>The first of these special entry types allows the application to nest another option table in the current one; such nesting may extend quite deeply (the actual depth is limited by the program's stack). Including other option tables allows a library to provide a standard set of command-line options to every program which uses it (this is often done in graphical programming toolkits, for example). To do this, set the <em>argInfo</em> field to <strong>POPT_ARG_INCLUDE_TABLE</strong> and the arg field to point to the table which is being included. If automatic help generation is being used, the <em>descrip</em> field should contain a overall description of the option table being included.</p><p>The other special option table entry type tells popt to call a function (a callback) when any option in that table is found. This is especially useful when included option tables are being used, as the program which provides the top-level option table doesn't need to be aware of the other options which are provided by the included table. When a callback is set for a table, the parsing function never returns information on an option in the table. Instead, options information must be retained via the callback or by having popt set a variable through the option's <em>arg</em> field. Option callbacks should match the following prototype:</p>
<pre>
<strong>void poptCallbackType(poptContext con,</strong>
<strong>                      const struct poptOption * opt,</strong>
<strong>                      const char * arg, void * data);</strong>
</pre>
<p>The first parameter is the context which is being parsed (see the next section for information on contexts), <em>opt</em> points to the option which triggered this callback, and <em>arg</em> is the option's argument. If the option does not take an argument, <em>arg</em> is <strong>NULL</strong>.  The final parameter, <em>data</em> is taken from the <em>descrip</em> field of the option table entry which defined the callback. As <em>descrip</em> is a pointer, this allows callback functions to be passed an arbitrary set of data (though a typecast will have to be used).</p><p>The option table entry which defines a callback has an <em>argInfo</em> of <strong>POPT_ARG_CALLBACK</strong>, an <em>arg</em> which points to the callback function, and a <em>descrip</em> field which specifies an arbitrary pointer to be passed to the callback.</p>
<h3>2. CREATING A CONTEXT</h3>
<p>popt can interleave the parsing of multiple command-line sets. It allows this by keeping all the state information for a particular set of command-line arguments in a <strong>poptContext</strong> data structure, an opaque type that should not be  modified outside the popt library.</p><p>New popt contexts are created by <strong>poptGetContext()</strong>:</p>
<pre>
<strong>poptContext poptGetContext(const char * </strong><em>name</em><strong>, int </strong><em>argc</em><strong>,</strong>
<strong>                           const char ** </strong><em>argv</em><strong>,</strong>
<strong>                           const struct poptOption * </strong><em>options</em><strong>,</strong>
<strong>                           int </strong><em>flags</em><strong>);</strong>
</pre>
<p>The first parameter, <em>name</em>, is used only for alias handling (discussed later). It  should be the name of the application whose options are being parsed, or should be <strong>NULL</strong> if no option aliasing is desired. The next  two arguments specify the command-line arguments to parse. These are generally passed to <strong>poptGetContext()</strong> exactly as they were  passed to the program's <strong>main()</strong> function. The  <em>options</em> parameter points to the table of command-line options,  which was described in the previous section. The final parameter, <em>flags</em>, can take one of three values:</p><table class="table table-striped">
<tr>
<th>Value</th>
<th>Description</th></tr>

<tr>
<td>POPT_CONTEXT_NO_EXEC</td>
<td>Ignore exec expansions</td></tr>

<tr>
<td>POPT_CONTEXT_KEEP_FIRST</td>
<td>Do not ignore argv[0]</td></tr>

<tr>
<td>POPT_CONTEXT_POSIXMEHARDER</td>
<td>Options cannot follow arguments</td></tr>
</table><p>A <strong>poptContext</strong> keeps track of which options have already been  parsed and which remain, among other things. If a program wishes to restart option processing of a set of arguments, it can reset the <strong>poptContext</strong> by passing the context as the sole argument to  <strong>poptResetContext()</strong>.</p><p>When argument processing is complete, the process should free the <strong>poptContext</strong> as it contains dynamically allocated components. The  <strong>poptFreeContext()</strong> function takes a  <strong>poptContext</strong> as its sole argument and frees the resources the  context is using.</p><p>Here are the prototypes of both <strong>poptResetContext()</strong> and  <strong>poptFreeContext()</strong>:</p>
<pre>
<strong>#include &lt;popt.h&gt;</strong>
<strong>void poptFreeContext(poptContext </strong><em>con</em><strong>);</strong>
<strong>void poptResetContext(poptContext </strong><em>con</em><strong>);</strong>
</pre>

<h3>3. PARSING THE COMMAND LINE</h3>
<p>After an application has created a <strong>poptContext</strong>, it may begin  parsing arguments. <strong>poptGetNextOpt()</strong> performs the actual  argument parsing.</p>
<pre>
<strong>#include &lt;popt.h&gt;</strong>
<strong>int poptGetNextOpt(poptContext </strong><em>con</em><strong>);</strong>
</pre>
<p>Taking the context as its sole argument, this function parses the next command-line argument found. After finding the next argument in the option table, the function fills in the object pointed to by the option table entry's <em>arg</em> pointer if it is not <strong>NULL</strong>. If the val entry for the option is  non-0, the function then returns that value. Otherwise, <strong>poptGetNextOpt()</strong> continues on to the next argument.</p><p><strong>poptGetNextOpt()</strong> returns -1 when the final argument has been  parsed, and other negative values when errors occur. This makes it a good idea to keep the <em>val</em> elements in the options table greater than 0.</p><p>If all of the command-line options are handled through <em>arg</em> pointers, command-line parsing is reduced to the following line of code:</p>
<pre>
rc = poptGetNextOpt(poptcon);
</pre>
<p>Many applications require more complex command-line parsing than this, however, and use the following structure:</p>
<pre>
while ((rc = poptGetNextOpt(poptcon)) &gt; 0) {
     switch (rc) {
          /* specific arguments are handled here */
     }
}
</pre>
<p>When returned options are handled, the application needs to know the value of any arguments that were specified after the option. There are two ways to discover them. One is to ask popt to fill in a variable with the value of the option through the option table's <em>arg</em> elements. The  other is to use <strong>poptGetOptArg()</strong>:</p>
<pre>
<strong>#include &lt;popt.h&gt;</strong>
<strong>char * poptGetOptArg(poptContext </strong><em>con</em><strong>);</strong>
</pre>
<p>This function returns the argument given for the final option returned by <strong>poptGetNextOpt()</strong>, or it returns <strong>NULL</strong> if no argument was specified. The calling function is responsible for deallocating this string.</p>
<h3>4. LEFTOVER ARGUMENTS</h3>
<p>Many applications take an arbitrary number of command-line arguments, such as a list of file names. When popt encounters an argument that does not begin with a -, it assumes it is such an argument and adds it to a list of leftover arguments. Three functions allow applications to access such arguments:</p>
<pre>
<strong>const char * poptGetArg(poptContext </strong><em>con</em><strong>);</strong>
</pre>
<p>This function returns the next leftover argument and marks it as processed.</p>
<pre>
<strong>const char * poptPeekArg(poptContext </strong><em>con</em><strong>);</strong>
</pre>
<p>The next leftover argument is returned but not marked as processed. This allows an application to look ahead into the argument list, without modifying the list.</p>
<pre>
<strong>const char ** poptGetArgs(poptContext </strong><em>con</em><strong>);</strong>
</pre>
<p>All the leftover arguments are returned in a manner identical to <em>argv</em>.  The final element in the returned array points to  <strong>NULL</strong>, indicating the end of the arguments.</p>
<h3>5. AUTOMATIC HELP MESSAGES</h3>
<p>The <strong>popt</strong> library can automatically generate help messages which describe the options a program accepts. There are two types of help messages which can be generated. Usage messages are a short messages which lists valid options, but does not describe them. Help messages describe each option on one (or more) lines, resulting in a longer, but more useful, message. Whenever automatic help messages are used, the <strong>descrip</strong> and <strong>argDescrip</strong> fields <strong>struct poptOption</strong> members should be filled in for each option.</p><p>The <strong>POPT_AUTOHELP</strong> macro makes it easy to add <strong>--usage</strong> and <strong>--help</strong> messages to your program, and is described in part 1 of this man page. If more control is needed over your help messages, the following two functions are available:</p>
<pre>
<strong>#include &lt;popt.h&gt;</strong>
<strong>void poptPrintHelp(poptContext </strong><em>con</em><strong>, FILE * </strong><em>f</em><strong>, int </strong><em>flags</em><strong>);</strong>
<strong>void poptPrintUsage(poptContext </strong><em>con</em><strong>, FILE * </strong><em>f</em><strong>, int </strong><em>flags</em><strong>);</strong>
</pre>
<p><strong>poptPrintHelp()</strong> displays the standard help message to the stdio file descriptor f, while <strong>poptPrintUsage()</strong> displays the shorter usage message. Both functions currently ignore the <strong>flags</strong> argument; it is there to allow future changes.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERROR HANDLING</h2>
        <div class="sectioncontent">
<p>All of the popt functions that can return errors return integers. When an error occurs, a negative error code is returned. The following table summarizes the error codes that occur:</p>
<pre>
<strong>     Error                      Description</strong>
<strong>POPT_ERROR_NOARG       </strong>Argument missing for an option.
<strong>POPT_ERROR_BADOPT      </strong>Option's argument couldn't be parsed.
<strong>POPT_ERROR_OPTSTOODEEP </strong>Option aliasing nested too deeply.
<strong>POPT_ERROR_BADQUOTE    </strong>Quotations do not match.
<strong>POPT_ERROR_BADNUMBER   </strong>Option couldn't be converted to number.
<strong>POPT_ERROR_OVERFLOW    </strong>A given number was too big or small.
</pre>
<p>Here is a more detailed discussion of each error:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>POPT_ERROR_NOARG</strong></p>
  </dt>
  <dd>
    <p>An option that requires an argument was specified on the command line, but no argument was given. This can be returned only by <strong>poptGetNextOpt()</strong>.</p>
  </dd>
  <dt>
    <p><strong>POPT_ERROR_BADOPT</strong></p>
  </dt>
  <dd>
    <p>An option was specified in <em>argv</em> but is not in the option table. This error can be returned only from <strong>poptGetNextOpt()</strong>.</p>
  </dd>
  <dt>
    <p><strong>POPT_ERROR_OPTSTOODEEP</strong></p>
  </dt>
  <dd>
    <p>A set of option aliases is nested too deeply. Currently, popt follows options only 10 levels to prevent infinite recursion. Only <strong>poptGetNextOpt()</strong> can return this error.</p>
  </dd>
  <dt>
    <p><strong>POPT_ERROR_BADQUOTE</strong></p>
  </dt>
  <dd>
    <p>A parsed string has a quotation mismatch (such as a single quotation mark). <strong>poptParseArgvString()</strong>, <strong>poptReadConfigFile()</strong>, or  <strong>poptReadDefaultConfig()</strong> can return this error.</p>
  </dd>
  <dt>
    <p><strong>POPT_ERROR_BADNUMBER</strong></p>
  </dt>
  <dd>
    <p>A conversion from a string to a number (int or long) failed due to the string containing nonnumeric characters. This occurs when <strong>poptGetNextOpt()</strong> is processing an argument of type  <strong>POPT_ARG_INT</strong>, <strong>POPT_ARG_SHORT</strong>, <strong>POPT_ARG_LONG</strong>, <strong>POPT_ARG_LONGLONG</strong>,  POPT_ARG_FLOAT<strong>, or </strong>POPT_ARG_DOUBLE<strong>.</strong></p>
  </dd>
  <dt>
    <p><strong>POPT_ERROR_OVERFLOW</strong></p>
  </dt>
  <dd>
    <p>A string-to-number conversion failed because the number was too large or too small. Like <strong>POPT_ERROR_BADNUMBER</strong>, this error can occur only when <strong>poptGetNextOpt()</strong> is processing an  argument of type <strong>POPT_ARG_INT</strong>, <strong>POPT_ARG_SHORT</strong>, <strong>POPT_ARG_LONG</strong>, <strong>POPT_ARG_LONGLONG</strong>,  POPT_ARG_FLOAT<strong>, or </strong>POPT_ARG_DOUBLE<strong>.</strong></p>
  </dd>
  <dt>
    <p><strong>POPT_ERROR_ERRNO</strong></p>
  </dt>
  <dd>
    <p>A system call returned with an error, and <em>errno</em> still contains the error from the system call. Both <strong>poptReadConfigFile()</strong> and <strong>poptReadDefaultConfig()</strong> can  return this error.</p>
  </dd>

</dl>
<p>Two functions are available to make it easy for applications to provide good error messages.</p>
<pre>
<strong>const char *const poptStrerror(const int </strong><em>error</em><strong>);</strong>
</pre>
<p>This function takes a popt error code and returns a string describing the error, just as with the standard <strong>strerror()</strong> function.</p>
<pre>
<strong>const char * poptBadOption(poptContext </strong><em>con</em><strong>, int </strong><em>flags</em><strong>);</strong>
</pre>
<p>If an error occurred during <strong>poptGetNextOpt()</strong>, this function  returns the option that caused the error. If the <em>flags</em> argument is set to <strong>POPT_BADOPTION_NOALIAS</strong>, the outermost option is  returned. Otherwise, <em>flags</em> should be 0, and the option that is  returned may have been specified through an alias.</p><p>These two functions make popt error handling trivial for most applications. When an error is detected from most of the functions, an error message is printed along with the error string from <strong>poptStrerror()</strong>. When an error occurs during argument parsing,  code similar to the following displays a useful error message:</p>
<pre>
fprintf(stderr, "%s: %s&#92;n",
        poptBadOption(optCon, POPT_BADOPTION_NOALIAS),
        poptStrerror(rc));
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTION ALIASING</h2>
        <div class="sectioncontent">
<p>One of the primary benefits of using popt over <strong>getopt()</strong> is the  ability to use option aliasing. This lets the user specify options that popt expands into other options when they are specified. If the standard grep program made use of popt, users could add a <strong>--text</strong> option  that expanded to <strong>-i -n -E -2</strong> to let them more easily find  information in text files.</p><h3>1. SPECIFYING ALIASES</h3>
<p>Aliases are normally specified in two places: <em>/etc/popt</em> and the <strong>.popt</strong> file in the user's home directory (found through  the <strong>HOME</strong> environment variable). Both files have the same format,  an arbitrary number of lines formatted like this:</p><p><em>appname</em><strong> alias </strong><em>newoption</em><strong></strong><em> expansion</em></p><p>The <em>appname</em> is the name of the application, which must be the  same as the <em>name</em> parameter passed to  <strong>poptGetContext()</strong>. This allows each file to specify aliases for  multiple programs. The <strong>alias</strong> keyword specifies that an alias is  being defined; currently popt configuration files support only aliases, but other abilities may be added in the future. The next option is the option that should be aliased, and it may be either a short or a long option. The rest of the line specifies the expansion for the alias. It is parsed similarly to a shell command, which allows &#92;, ", and ' to be used for quoting. If a backslash is the final character on a line, the next line in the file is assumed to be a logical continuation of the line containing the backslash, just as in shell.</p><p>The following entry would add a <strong>--text</strong> option to the grep command,  as suggested at the beginning of this section.</p><p><strong>grep alias --text -i -n -E -2</strong></p>
<h3>2. ENABLING ALIASES</h3>
<p>An application must enable alias expansion for a <strong>poptContext</strong> before calling <strong>poptGetNextArg()</strong> for the first time. There are  three functions that define aliases for a context:</p>
<pre>
<strong>int poptReadDefaultConfig(poptContext </strong><em>con</em><strong>, int </strong><em>flags</em><strong>);</strong>
</pre>
<p>This function reads aliases from <em>/etc/popt</em> and the  <strong>.popt</strong> file in the user's home directory. Currently,  <em>flags</em> should be  <strong>NULL</strong>, as it is provided only for future expansion.</p>
<pre>
<strong>int poptReadConfigFile(poptContext </strong><em>con</em><strong>, char * </strong><em>fn</em><strong>);</strong>
</pre>
<p>The file specified by <em>fn</em> is opened and parsed as a popt  configuration file. This allows programs to use program-specific configuration files.</p>
<pre>
<strong>int poptAddAlias(poptContext </strong><em>con</em><strong>, struct poptAlias </strong><em>alias</em><strong>,</strong>
<strong>                 int </strong><em>flags</em><strong>);</strong>
</pre>
<p>Occasionally, processes want to specify aliases without having to read them from a configuration file. This function adds a new alias to a context. The <em>flags</em> argument should be 0, as it is  currently reserved for future expansion. The new alias is specified as a <strong>struct poptAlias</strong>, which is defined as:</p>
<pre>
struct poptAlias {
     const char * longName; /* may be NULL */
     char shortName; /* may be '&#92;0' */
     int argc;
     const char ** argv; /* must be free()able */
};
</pre>
<p>The first two elements, <em>longName</em> and <em>shortName</em>, specify  the option that is aliased. The final two, <em>argc</em> and <em>argv</em>, define the expansion to use when the aliases option is encountered.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARSING ARGUMENT STRINGS</h2>
        <div class="sectioncontent">
<p>Although popt is usually used for parsing arguments already divided into an <em>argv</em>-style array, some programs need to parse strings that  are formatted identically to command lines. To facilitate this, popt provides a function that parses a string into an array of strings, using rules similar to normal shell parsing.</p>
<pre>
<strong>#include &lt;popt.h&gt;</strong>
<strong>int poptParseArgvString(char * </strong><em>s</em><strong>, int * </strong><em>argcPtr</em><strong>,</strong>
<strong>                        char *** </strong><em>argvPtr</em><strong>);</strong>
<strong>int poptDupArgv(int </strong><em>argc</em><strong>, const char ** </strong><em>argv</em><strong>, int * </strong><em>argcPtr</em><strong>,</strong>
<strong>                        const char *** </strong><em>argvPtr</em><strong>);</strong>
</pre>
<p>The string s is parsed into an <em>argv</em>-style array. The integer  pointed to by the <em>argcPtr</em> parameter contains the number of elements  parsed, and the final <em>argvPtr</em> parameter contains the address of the newly created array. The routine <strong>poptDupArgv()</strong> can be used to make a copy of an existing  argument array.</p><p>The <em>argvPtr</em> created by <strong>poptParseArgvString()</strong> or <strong>poptDupArgv()</strong> is suitable to pass directly  to <strong>poptGetContext()</strong>. Both routines return a single dynamically allocated contiguous block of storage and should be <strong>free()</strong>ed when the application is finished with the storage.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HANDLING EXTRA ARGUMENTS</h2>
        <div class="sectioncontent">
<p>Some applications implement the equivalent of option aliasing but need to do so through special logic. The <strong>poptStuffArgs()</strong> function  allows an application to insert new arguments into the current <strong>poptContext</strong>.</p>
<pre>
<strong>#include &lt;popt.h&gt;</strong>
<strong>int poptStuffArgs(poptContext </strong><em>con</em><strong>, const char ** </strong><em>argv</em><strong>);</strong>
</pre>
<p>The passed <em>argv</em> must have a <strong>NULL</strong> pointer as its final element. When  <strong>poptGetNextOpt()</strong> is next called, the  "stuffed" arguments are the first to be parsed. popt returns to the normal arguments once all the stuffed arguments have been exhausted.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>The following example is a simplified version of the program "robin" which appears in Chapter 15 of the text cited below.  Robin has been stripped of everything but its argument-parsing logic, slightly reworked, and renamed "parse." It may prove useful in illustrating at least some of the features of the extremely rich popt library.</p>
<pre>
#include &lt;popt.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void usage(poptContext optCon, int exitcode, char *error, char *addl) {
    poptPrintUsage(optCon, stderr, 0);
    if (error) fprintf(stderr, "%s: %s&#92;n", error, addl);
    exit(exitcode);
}

int main(int argc, char *argv[]) {
   int     c;            /* used for argument parsing */
   int     i = 0;        /* used for tracking options */
   int     speed = 0;    /* used in argument parsing to set speed */
   int     raw = 0;      /* raw mode? */
   int     j;
   char    buf[BUFSIZ+1];
   const char *portname;
   poptContext optCon;   /* context for parsing command-line options */

   struct poptOption optionsTable[] = {
      { "bps", 'b', POPT_ARG_INT, &speed, 0,
	"signaling rate in bits-per-second", "BPS" },
      { "crnl", 'c', 0, 0, 'c',
	"expand cr characters to cr/lf sequences", NULL },
      { "hwflow", 'h', 0, 0, 'h',
	"use hardware (RTS/CTS) flow control", NULL },
      { "noflow", 'n', 0, 0, 'n',
	"use no flow control", NULL },
      { "raw", 'r', 0, &raw, 0,
	"don't perform any character conversions", NULL },
      { "swflow", 's', 0, 0, 's',
	"use software (XON/XOF) flow control", NULL } ,
      POPT_AUTOHELP
      { NULL, 0, 0, NULL, 0 }
    };

   optCon = poptGetContext(NULL, argc, argv, optionsTable, 0);
   poptSetOtherOptionHelp(optCon, "[OPTIONS]* &lt;port&gt;");

   if (argc &lt; 2) {
	poptPrintUsage(optCon, stderr, 0);
	<strong>exit</strong>(1);
   }

   /* Now do options processing, get portname */
   while ((c = poptGetNextOpt(optCon)) &gt;= 0) {
      switch (c) {
       case 'c':
          buf[i++] = 'c';
          break;
       case 'h':
          buf[i++] = 'h';
          break;
       case 's':
          buf[i++] = 's';
          break;
       case 'n':
          buf[i++] = 'n';
          break;
      }
   }
   portname = poptGetArg(optCon);
   if((portname == NULL) || !(poptPeekArg(optCon) == NULL))
      usage(optCon, 1, "Specify a single port", ".e.g., /dev/cua0");

   if (c &lt; -1) {
      /* an error occurred during option processing */
      fprintf(stderr, "%s: %s&#92;n",
              poptBadOption(optCon, POPT_BADOPTION_NOALIAS),
              poptStrerror(c));
      return 1;
   }

   /* Print out options, portname chosen */
   printf("Options  chosen: ");
   for(j = 0; j &lt; i ; j++)
      printf("-%c ", buf[j]);
   if(raw) printf("-r ");
   if(speed) printf("-b %d ", speed);
   printf("&#92;nPortname chosen: %s&#92;n", portname);

   poptFreeContext(optCon);
   <strong>exit</strong>(0);
}
</pre>
<p>RPM, a popular Linux package management program, makes heavy use of popt's features. Many of its command-line arguments are implemented through popt aliases, which makes RPM an excellent example of how to take advantage of the popt library. For more information on RPM, see http://www.rpm.org. The popt source code distribution includes test program(s) which use all of the features of the popt libraries in various ways. If a feature isn't working for you, the popt test code is the first place to look.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>None presently known.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Erik W. Troan &lt;ewt@redhat.com&gt;</p><p>This man page is derived in part from <em>Linux Application Development</em> by Michael K. Johnson and Erik W. Troan, Copyright (c) 1998 by Addison Wesley Longman, Inc., and included in the popt documentation with the permission of the Publisher and the appreciation of the Authors.</p><p>Thanks to Robert Lynch for his extensive work on this man page.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO popt&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/getopt.3.html"><strong>getopt</strong>(3)</a></p><p><em>Linux Application Development</em>, by Michael K. Johnson and  Erik W. Troan (Addison-Wesley, 1998; ISBN 0-201-30821-5), Chapter 24.</p><p><strong>popt.ps</strong> is a Postscript version of the above cited book  chapter. It can be found in the source archive for popt available at: ftp://ftp.rpm.org/pub/rpm.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="popen.3.html"><span aria-hidden="true">&larr;</span> popen.3: Pipe stream to or from a process</a></li>
   <li class="next"><a href="popupDialog.3.html">popupDialog.3: Cdk utility functions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

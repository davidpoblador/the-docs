<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>GD::SVG: Seamlessly enable svg output from scripts written using gd</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Seamlessly enable svg output from scripts written using gd">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="GD::SVG (3pm) manual">
  <meta name="twitter:description" content="Seamlessly enable svg output from scripts written using gd">
  <meta name="twitter:image" content="https://www.carta.tech/images/libgd-svg-perl-GD::SVG-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/GD::SVG.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="GD::SVG (3pm) manual" />
  <meta property="og:description" content="Seamlessly enable svg output from scripts written using gd" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libgd-svg-perl-GD::SVG-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">GD::SVG<small> (3pm)</small></h1>
        <p class="lead">Seamlessly enable svg output from scripts written using gd</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/GD::SVG.3pm.html">
      <span itemprop="name">GD::SVG: Seamlessly enable svg output from scripts written using gd</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libgd-svg-perl/">
      <span itemprop="name">libgd-svg-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/GD::SVG.3pm.html">
      <span itemprop="name">GD::SVG: Seamlessly enable svg output from scripts written using gd</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    # use GD;
    use GD::SVG;

    # my $img = GD::Image-&gt;new();
    my $img = GD::SVG::Image-&gt;new();

    # $img-&gt;png();
    $img-&gt;svg();
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>\s-1GD::SVG\s0 painlessly enables scripts that utilize \s-1GD\s0 to export scalable vector graphics (\s-1SVG\s0). It accomplishes this task by wrapping \s-1SVG\s0.pm with GD-styled method calls. To enable this functionality, one need only change the \*(L"use \s-1GD\s0\*(R" call to \*(L"use \s-1GD::SVG\s0\*(R" (and initial \*(L"new\*(R" method calls).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p>\s-1GD::SVG\s0 exports the same methods as \s-1GD\s0 itself, overriding those methods.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>In order to generate \s-1SVG\s0 output from your script using \s-1GD::SVG\s0, you will need to first</p><p>  # use GD;   use GD::SVG;</p><p>After that, each call to the package classes that \s-1GD\s0 implements should be changed to \s-1GD::SVG\s0. Thus:</p><p>  GD::Image    becomes  GD::SVG::Image   GD::Font     becomes  GD::SVG::Font</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DYNAMICALLY SELECTING SVG OUTPUT</h2>
        <div class="sectioncontent">
<p>If you would like your script to be able to dynamically select either \s-1PNG\s0 or \s-1JPEG\s0 output (via \s-1GD\s0) or \s-1SVG\s0 output (via \s-1GD::SVG\s0), you should place your \*(L"use\*(R" statement within an eval. In the example below, each of the available classes is created at the top of the script for convenience, as well as the image output type.</p><p>  my $package = shift;   eval "use $package";   my $image_pkg = $package . &apos;::Image&apos;;   my $font_pkg  = $package . &apos;::Font&apos;;</p><p>  # Creating new images thus becomes   my $image   = $image_pkg-&gt;new($width,$height);</p><p>  # Establish the image output type   my $image_type;   if ($package = &apos;GD::SVG&apos;) {     $image_type = &apos;svg&apos;;   } else {     $image_type = &apos;png&apos;;   }</p><p>Finally, you should change all GD::Image and GD::Font references to $image_pkg-&gt; and $font_pkg-&gt;, respectively.</p><p>  GD::Image-&gt;new()   becomes   $image_pkg-&gt;new()   GD::Font-&gt;Large()  becomes   $font_pkg-&gt;Large()</p><p>The GD::Polygon and GD::Polyline classes work with \s-1GD::SVG\s0 without modification.</p><p>If you make heavy use of \s-1GD\s0's exported methods, it may also be necessary to add () to the endo of method names to avoide bareword compilation errors. That's the price you pay for using exported functions!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPORTANT NOTES</h2>
        <div class="sectioncontent">
<p>\s-1GD::SVG\s0 does not directly generate \s-1SVG\s0, but instead relies upon \s-1SVG\s0.pm. It is not intended to supplant \s-1SVG\s0.pm.  Furthermore, since \s-1GD::SVG\s0 is, in essence an \s-1API\s0 to an \s-1API\s0, it may not be suitable for applications where speed is of the essence. In these cases, \s-1GD::SVG\s0 may provide a short-term solution while scripts are re-written to enable more direct output of \s-1SVG\s0.</p><p>Many of the \s-1GD::SVG\s0 methods accept additional parameters (which are in turn reflected in the \s-1SVG\s0.pm \s-1API\s0) that are not supported in \s-1GD\s0.  Look through the remainder of this document for options on specific In addition, several functions have yet to be mapped to \s-1SVG\s0.pm calls. Please see the section below regarding regarding \s-1GD\s0 functions that are missing or altered in \s-1GD::SVG\s0.</p><p>A similar module (\s-1SVG::GD\s0) implements a similar wrapper around \s-1GD\s0. Please see the section at the bottom of this document that compares \s-1GD::SVG\s0 to \s-1SVG::GD\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PREREQUISITES</h2>
        <div class="sectioncontent">
<p>\s-1GD::SVG\s0 requires the Ronan Oger's \s-1SVG\s0.pm module, Lincoln Stein's \s-1GD\s0.pm module, libgd and its dependencies.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GENERAL DIFFICULTIES IN TRANSLATING GD TO SVG</h2>
        <div class="sectioncontent">
<p>These are the primary weaknesses of \s-1GD::SVG\s0.</p>
<dl class='dl-vertical'>
  <dt>
    \s-1SVG\s0 requires unique identifiers for each element
  </dt>
  <dd>
    <p>Each element in an \s-1SVG\s0 image requires a unique identifier. In general, \s-1GD::SVG\s0 handles this by automatically generating unique random numbers.  In addition to the typical parameters for \s-1GD\s0 methods, \s-1GD::SVG\s0 methods allow a user to pass an optional id parameter for naming the object.</p>
  </dd>
  <dt>
    Direct calls to the \s-1GD\s0 package will fail
  </dt>
  <dd>
    <p>You must change direct calls to the classes that \s-1GD\s0 invokes:</p>
<pre>
    GD::Image-&gt;<em>new()</em> should be changed to GD::SVG::Image-&gt;<em>new()</em>
</pre>
<p>See the documentation above for how to dynamically switch between packages.</p>
  </dd>
  <dt>
    raster <em>fill()</em> and <em>fillToBorder()</em> not supported
  </dt>
  <dd>
    <p>As \s-1SVG\s0 documents are not inherently aware of their canvas, the flood fill methods are not currently supported.</p>
  </dd>
  <dt>
    <em>getPixel()</em> not supported.
  </dt>
  <dd>
    <p>Although <em>setPixel()</em> works as expected, its counterpart <em>getPixel()</em> is not supported. I plan to support this method in a future release.</p>
  </dd>
  <dt>
    No support for generation of images from filehandles or raw data
  </dt>
  <dd>
    <p>\s-1GD::SVG\s0 works only with scripts that generate images directly in the code using the \s-1GD-\s0&gt;new(height,width) approach. <em>newFrom()</em> methods are not currently supported.</p>
  </dd>
  <dt>
    Tiled fills are not supported
  </dt>
  <dd>
    <p>Any functions passed gdTiled objects will die.</p>
  </dd>
  <dt>
    Styled and Brushed lines only partially implemented
  </dt>
  <dd>
    <p>Calls to the gdStyled and gdBrushed functions via a rather humorous kludge (and simplification). Depending on the complexity of the brush, they may behave from slightly differently to radically differently from their behavior under \s-1GD\s0. You have been warned. See the documentation sections for the methods that set these options (<em>setStyle()</em>, <em>setBrush()</em>, and <em>setTransparent()</em>).</p>
  </dd>

</dl>
<p>See below for a full list of methods that have not yet been implemented.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WHEN THINGS GO WRONG</h2>
        <div class="sectioncontent">
<p>\s-1GD\s0 is a complicated module.  Translating \s-1GD\s0 methods into those required to draw in \s-1SVG\s0 are not always direct. You may or may not get the output you expect. In general, some tweaking of image parameters (like text height and width) may be necessary.</p><p>If your script doesn't work as expected, first check the list of methods that \s-1GD::SVG\s0 provides.  Due to differences in the nature of \s-1SVG\s0 images, not all \s-1GD\s0 methods have been implemented in \s-1GD::SVG\s0.</p><p>If your image doesn't look as expected, try tweaking specific aspects of image generation.  In particular, check for instances where you calculate dimensions of items on the fly like font-&gt;height. In \s-1SVG\s0, the values of fonts are defined explicitly.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GD FUNCTIONS MISSING FROM GD::SVG</h2>
        <div class="sectioncontent">
<p>The following \s-1GD\s0 functions have not yet been incorporated into \s-1GD::SVG\s0. If you attempt to use one of these functions (and you have enabled debug warnings via the <em>new()</em> method), \s-1GD::SVG\s0 will print a warning to \s-1STDERR\s0.</p><p>  Creating image objects:     GD::Image-&gt;newPalette([$width,$height])     GD::Image-&gt;newTrueColor([$width,$height])     GD::Image-&gt;newFromPng($file, [$truecolor])     GD::Image-&gt;newFromPngData($data, [$truecolor])     GD::Image-&gt;newFromJpeg($file, [$truecolor])     GD::Image-&gt;newFromJpegData($data, [$truecolor])     GD::Image-&gt;newFromXbm($file)     GD::Image-&gt;newFromWMP($file)     GD::Image-&gt;newFromGd($file)     GD::Image-&gt;newFromGdData($data)     GD::Image-&gt;newFromGd2($file)     GD::Image-&gt;newFromGd2Data($data)     GD::Image-&gt;newFromGd2Part($file,srcX,srcY,width,height)     GD::Image-&gt;newFromXpm($filename)</p><p>  Image methods:     $gddata   = $image-&gt;gd     $gd2data  = $image-&gt;gd2     $wbmpdata = $image-&gt;wbmp([$foreground])</p><p>  Color control methods:     $image-&gt;colorAllocateAlpha()     $image-&gt;colorClosest()     $image-&gt;colorClosestHWB()     $image-&gt;getPixel()     $image-&gt;transparent()</p><p>  Special Colors:     $image-&gt;setBrush() (semi-supported, with kludge)     $image-&gt;setStyle() (semi-supported, with kludge)     gdTiled     $image-&gt;setAntialiased()     gdAntiAliased()     $image-&gt;setAntiAliasedDontBlend()</p><p>  Drawing methods:     $image-&gt;dashedLine()     $image-&gt;fill()     $image-&gt;fillToBorder()</p><p>  Image copying methods     None of the image copying methods are yet supported</p><p>  Image transformation methods     None of the image transformation methods are yet supported</p><p>  Character and string drawing methods      $image-&gt;stringUp()  - incompletely supported - broken      $image-&gt;charUp()      $image-&gt;stringFT()</p><p>  Alpha Channels     $image-&gt;alphaBlending()     $image-&gt;saveAlpha()</p><p>  Miscellaneous image methods     $image-&gt;isTrueColor()     $image-&gt;compare($image2)     $image-&gt;clip()     $image-&gt;boundsSafe()</p><p>  GD::Polyline     Supported without modifications</p><p>  Font methods:     $font-&gt;nchars()     $font-&gt;offset()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GROUPING FUNCTIONS GD::SVG</h2>
        <div class="sectioncontent">
<p>\s-1GD::SVG\s0 supports three additional methods that provides the ability to recursively group objects: These methods start and end a group in a procedural manner. Once a group is started, all further drawing will be appended to the group until <em>endGroup()</em> is invoked. You may optionally pass a string \s-1ID\s0 and an \s-1SVG\s0 styles hash to startGroup. This method returns a GD::Group object, which has all the behaviors of a \s-1GD::SVG\s0 object except that it draws within the current group. You can invoke this object's drawing methods to draw into a group. The group is closed once the object goes out of scope. While the object is open, invoking drawing methods on the parent \s-1GD::SVG\s0 object will also draw into the group until it goes out of scope. Here is an example of using grouping in the procedural way:  use GD::SVG;  my $img   = GD::SVG::Image-&gt;new(500,500);  my $white = $img-&gt;colorAllocate(255,255,255);  my $black = $img-&gt;colorAllocate(0,0,0);  my $blue  = $img-&gt;colorAllocate(0,0,255);  my $red   = $img-&gt;colorAllocate(255,0,0);</p><p> $img-&gt;startGroup(&apos;circle in square&apos;);  $img-&gt;rectangle(100,100,400,400,$blue);</p><p> $img-&gt;startGroup(&apos;circle and boundary&apos;);  $img-&gt;filledEllipse(250,250,200,200,$red);  $img-&gt;ellipse(250,250,200,200,$black);</p><p> $img-&gt;endGroup;  $img-&gt;endGroup;</p><p> print $img-&gt;svg; Here is an example of using grouping with the GD::Group object:   ...</p><p> my $g1 = $img-&gt;newGroup(&apos;circle in square&apos;);  $g1-&gt;rectangle(100,100,400,400,$blue);</p><p> my $g2 = $g1-&gt;startGroup(&apos;circle and boundary&apos;);  $g2-&gt;filledEllipse(250,250,200,200,$red);  $g2-&gt;ellipse(250,250,200,200,$black);</p><p> print $img-&gt;svg; Finally, here is a fully worked example of using the GD::Simple module to make the syntax cleaner:  #!/usr/bin/perl</p><p> use strict;  use GD::Simple;</p><p> GD::Simple-&gt;class(&apos;GD::SVG&apos;);</p><p> my $img = GD::Simple-&gt;new(500,500);  $img-&gt;bgcolor(&apos;white&apos;);  $img-&gt;fgcolor(&apos;blue&apos;);</p><p> my $g1 = $img-&gt;newGroup(&apos;circle in square&apos;);  $g1-&gt;rectangle(100,100,400,400);  $g1-&gt;moveTo(250,250);</p><p> my $g2 = $g1-&gt;newGroup(&apos;circle and boundary&apos;);  $g2-&gt;fgcolor(&apos;black&apos;);  $g2-&gt;bgcolor(&apos;red&apos;);  $g2-&gt;ellipse(200,200);</p><p> print $img-&gt;svg;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GD VERSUS GD::SVG METHODS</h2>
        <div class="sectioncontent">
<p>All \s-1GD::SVG\s0 methods mimic the naming and interface of \s-1GD\s0 methods.  As such, maintenance of \s-1GD::SVG\s0 follows the development of both \s-1GD\s0 and \s-1SVG\s0. Much of the original \s-1GD\s0 documentation is replicated here for ease of use. Subtle differences in the implementation of these methods between \s-1GD\s0 and \s-1GD::SVG\s0 are discussed below. In particular, the return value for some \s-1GD::SVG\s0 methods differs from its \s-1GD\s0 counterpart.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT CONSTRUCTORS: CREATING IMAGES</h2>
        <div class="sectioncontent">
<p>\s-1GD::SVG\s0 currently only supports the creation of image objects via its new constructor.  This is in contrast to \s-1GD\s0 proper which supports the creation of images from previous images, filehandles, filenames, and data. Create a blank \s-1GD::SVG\s0 image object of the specified dimensions in pixels. In turn, this method will create a new \s-1SVG\s0 object and store it internally. You can turn on debugging with the \s-1GD::SVG\s0 specific $debug parameter.  This should be boolean true and will cause non-implemented methods to print a warning on their status to \s-1STDERR\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GD::SVG::Image METHODS</h2>
        <div class="sectioncontent">
<p>Once a GD::Image object is created, you can draw with it, copy it, and merge two images.  When you are finished manipulating the object, you can convert it into a standard image file format to output or save to a file.</p><h3>Image Data Output Methods</h3>
<p>\s-1GD::SVG\s0 implements a single output method, <em>svg()</em>! This returns the image in \s-1SVG\s0 format. You may then print it, pipe it to an image viewer, or write it to a file handle. For example,   $svg_data = $image-&gt;svg();   open (DISPLAY,"| display -") || die;   binmode DISPLAY;   print DISPLAY $svg_data;   close DISPLAY; if you'd like to return an inline version of the image (instead of a full document version complete with the \s-1DTD\s0), pass the <em>svg()</em> method the 'inline' flag:   $svg_data = $image-&gt;svg(-inline=&gt;&apos;true&apos;); Calling the other standard \s-1GD\s0 image output methods (eg jpeg,gd,gd2,png) on a GD::SVG::Image object will cause your script to exit with a warning.</p>
<h3>Color Control</h3>
<p>These methods allow you to control and manipulate the color table of a \s-1GD::SVG\s0 image. In contrast to \s-1GD\s0 which uses color indices, \s-1GD::SVG\s0 passes stringified \s-1RGB\s0 triplets as colors. \s-1GD::SVG\s0, however, maintains an internal hash structure of colors and colored indices in order to map \s-1GD\s0 functions that manipulate the color table. This typically requires behind-the-scenes translation of these stringified \s-1RGB\s0 triplets into a color index. Unlike \s-1GD\s0, colors need not be allocated in advance in \s-1SVG\s0.  Unlike \s-1GD\s0 which returns a color index, colorAllocate returns a formatted string compatible with \s-1SVG\s0. Simultaneously, it creates and stores internally a \s-1GD\s0 compatible color index for use with \s-1GD\s0's color manipulation methods.   returns: "rgb(RED,GREEN,BLUE)" \s-1NOT\s0 \s-1IMPLEMENTED\s0 Provided with a color index, remove it from the color table. This returns the index of the color closest in the color table to the red green and blue components specified. This method is inherited directly from \s-1GD\s0.   Example: $apricot = $myImage-&gt;colorClosest(255,200,180); \s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1NOT\s0 \s-1IMPLEMENTED\s0 Retrieve the color index of an rgb triplet (or -1 if it has yet to be allocated). \s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1NOT\s0 \s-1IMPLEMENTED\s0 Retrieve the total number of colors indexed in the image. \s-1NOT\s0 \s-1IMPLEMENTED\s0 Provided with a color index, return the \s-1RGB\s0 triplet.  In \s-1GD::SVG\s0, color indexes are replaced with actual \s-1RGB\s0 triplets in the form \*(L"rgb($r,$g,$b)\*(R". Control the transparency of individual colors. \s-1NOT\s0 \s-1IMPLEMENTED\s0</p>
<h3>Special Colors</h3>
<p>\s-1GD\s0 implements a number of special colors that can be used to achieve special effects.  They are constants defined in the \s-1GD::\s0 namespace, but automatically exported into your namespace when the \s-1GD\s0 module is loaded. \s-1GD::SVG\s0 offers limited support for these methods.</p>
<dl class='dl-vertical'>
  <dt>
    gdBrushed
  </dt>
  <dd>
    <p>In \s-1GD\s0, one can draw lines and shapes using a brush pattern.  Brushes are just images that you can create and manipulate in the usual way. When you draw with them, their contents are used for the color and shape of the lines. To make a brushed line, you must create or load the brush first, then assign it to the image using <em>setBrush()</em>.  You can then draw in that with that brush using the gdBrushed special color.  It's often useful to set the background of the brush to transparent so that the non-colored parts don't overwrite other parts of your image.   # Via GD, this is how one would set a Brush   $diagonal_brush = new GD::Image(5,5);   $white = $diagonal_brush-&gt;colorAllocate(255,255,255);   $black = $diagonal_brush-&gt;colorAllocate(0,0,0);   $diagonal_brush-&gt;transparent($white);   $diagonal_brush-&gt;line(0,4,4,0,$black); # NE diagonal \s-1GD::SVG\s0 offers limited support for setBrush (and the corresponding gdBrushed methods) - currently only in the shapes of squares. Internally, \s-1GD::SVG\s0 extracts the longest dimension of the image using the <em>getBounds()</em> method. Next, it extracts the second color set, assuming that to be the foreground color. It then re-calls the original drawing method with these new values in place of the gdBrushed. See the private _distill_gdSpecial method for the internal details of this operation. Lines drawn with <em>line()</em>, <em>rectangle()</em>, <em>arc()</em>, and so forth are 1 pixel thick by default.  Call <em>setThickness()</em> to change the line drawing width. <em>setStyle()</em> and <em>gdStyled()</em> are partially supported in \s-1GD::SVG\s0. \s-1GD::SVG\s0 determines the alternating pattern of dashes, treating the first unique color encountered in the array as on, the second as off and so on. The first color in the array is then used to draw the actual line.</p>
  </dd>
  <dt>
    gdTiled
  </dt>
  <dd>
    <p>\s-1NOT\s0 \s-1IMPLEMENTED\s0</p>
  </dd>
  <dt>
    <em>gdStyled()</em>
  </dt>
  <dd>
    <p>The \s-1GD\s0 special color gdStyled is partially implemented in \s-1GD::SVG\s0. Only the first color will be used to generate the dashed pattern specified in <em>setStyle()</em>. See <em>setStyle()</em> for additional information. \s-1NOT\s0 \s-1IMPLEMENTED\s0</p>
  </dd>
  <dt>
    gdAntiAliased
  </dt>
  <dd>
    <p>\s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1NOT\s0 \s-1IMPLEMENTED\s0</p>
  </dd>

</dl>

<h3>Drawing Commands</h3>
<p>Set the corresponding pixel to the given color.  \s-1GD::SVG\s0 implements this by drawing a single dot in the specified color at that position. Draw a line between the two coordinate points with the specified color.  Passing an optional id will set the id of that \s-1SVG\s0 element. \s-1GD::SVG\s0 also supports drawing with the special brushes - gdStyled and gdBrushed - although these special styles are difficult to replicate precisley in \s-1GD::SVG\s0. \s-1NOT\s0 \s-1IMPLEMENTED\s0 This draws a rectangle with the specified color.  (x1,y1) and (x2,y2) are the upper left and lower right corners respectively.  You may also draw with the special colors gdBrushed and gdStyled. filledRectangle is a \s-1GD\s0 specific method with no direct equivalent in \s-1SVG\s0.  \s-1GD::SVG\s0 translates this method into an \s-1SVG\s0 appropriate method by passing the filled color parameter as a named 'filled' parameter to \s-1SVG\s0. Drawing with the special colors is also permitted. See the documentation for the <em>line()</em> method for additional details.    GD call:      $img-&gt;filledRectangle($x1,$y1,$x2,$y2,$color);</p><p>   SVG call:      $img-&gt;rectangle(x=&gt; $x1,y=&gt; $y1,                      width  =&gt; $x2-$x1,                      height =&gt; $y2-$y1,                      fill   =&gt; $color This draws a polygon with the specified color.  The polygon must be created first (see \*(L"Polygons\*(R" below).  The polygon must have at least three vertices.  If the last vertex doesn't close the polygon, the method will close it for you.  Both real color indexes and the special colors gdBrushed, gdStyled and gdStyledBrushed can be specified. See the documentation for the <em>line()</em> method for additional details.   $poly = new GD::Polygon;   $poly-&gt;addPt(50,0);   $poly-&gt;addPt(99,99);   $poly-&gt;addPt(0,99);   $image-&gt;polygon($poly,$blue); This draws a polygon filled with the specified color.  Drawing with the special colors is also permitted. See the documentation for the <em>line()</em> method for additional details.   # make a polygon   $poly = new GD::Polygon;   $poly-&gt;addPt(50,0);   $poly-&gt;addPt(99,99);   $poly-&gt;addPt(0,99);</p><p>  # draw the polygon, filling it with a color   $image-&gt;filledPolygon($poly,$peachpuff); This draws a polygon filled with the specified color.  Drawing with the special colors is also permitted. See the documentation for the <em>line()</em> method for additional details.   # make a polygon   $poly = new GD::Polygon;   $poly-&gt;addPt(50,0);   $poly-&gt;addPt(99,99);   $poly-&gt;addPt(0,99);</p><p>  # draw the polygon, filling it with a color   $image-&gt;filledPolygon($poly,$peachpuff);   $image-&gt;polyline($polyline,$black) This draws a polyline with the specified color. Both real color indexes and the special colors gdBrushed, gdStyled and gdStyledBrushed can be specified. Neither the <em>polyline()</em> method or the <em>polygon()</em> method are very picky: you can call either method with either a GD::Polygon or a GD::Polyline.  The <em>method</em> determines if the shape is \*(L"closed\*(R" or \*(L"open\*(R" as drawn, <em>not</em> the object type.         $image-&gt;polydraw($poly,$black) This method draws the polything as expected (polygons are closed, polylines are open) by simply checking the object type and calling either $image-&gt;<em>polygon()</em> or $image-&gt;<em>polyline()</em>. These <em>methods()</em> draw ellipses. ($cx,$cy) is the center of the arc, and ($width,$height) specify the ellipse width and height, respectively. <em>filledEllipse()</em> is like <em>ellipse()</em> except that the former produces filled versions of the ellipse. Drawing with the special colors is also permitted. See the documentation for the <em>line()</em> method for additional details. This draws arcs and ellipses.  (cx,cy) are the center of the arc, and (width,height) specify the width and height, respectively.  The portion of the ellipse covered by the arc are controlled by start and end, both of which are given in degrees from 0 to 360.  Zero is at the top of the ellipse, and angles increase clockwise.  To specify a complete ellipse, use 0 and 360 as the starting and ending angles.  To draw a circle, use the same value for width and height. Internally, <em>arc()</em> calls the <em>ellipse()</em> method of \s-1SVG\s0.pm. Drawing with the special colors is also permitted. See the documentation for the <em>line()</em> method for additional details. Currently, true arcs are \s-1NOT\s0 supported, only those where the start and end equal 0 and 360 respectively resulting in a closed arc. This method is like <em>arc()</em> except that it colors in the pie wedge with the selected color.  $arc_style is optional.  If present it is a bitwise \s-1OR\s0 of the following constants: gdArc           connect start & end points of arc with a rounded edge gdChord         connect start & end points of arc with a straight line gdPie           synonym for gdChord gdNoFill        outline the arc or chord gdEdged         connect beginning and ending of the arc to the center gdArc and gdChord are mutally exclusive.  gdChord just connects the starting and ending angles with a straight line, while gdArc pro- duces a rounded edge. gdPie is a synonym for gdArc. gdNoFill indi- cates that the arc or chord should be outlined, not filled.  gdEdged, used together with gdNoFill, indicates that the beginning and ending angles should be connected to the center; this is a good way to outline (rather than fill) a \*(L"pie slice.\*(R" Using these special styles, you can easily draw bordered ellipses and circles. # Create the filled shape: $image-&gt;filledArc($x,$y,$width,$height,0,360,$fill); # Now border it. $image-&gt;filledArc($x,$y,$width,$height,0,360,$color,gdNoFill); \s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1NOT\s0 \s-1IMPLEMENTED\s0</p>
<h3>Image Copying Methods</h3>
<p>The basic <em>copy()</em> command is implemented in \s-1GD::SVG\s0. You can copy one \s-1GD::SVG\s0 into another \s-1GD::SVG\s0, or copy a GD::Image or GD::Simple object into a \s-1GD::SVG\s0, thereby embedding a pixmap image into the \s-1SVG\s0 image.</p><p>All other image copying methods are unsupported, and if your script calls one of the following methods, your script will die remorsefully with a warning.  With sufficient demand, I might try to implement some of these methods.  For now, I think that they are beyond the intent of \s-1GD::SVG\s0.</p><p>  $image-&gt;clone()   $image-&gt;copyMerge()   $image-&gt;copyMergeGray()   $image-&gt;copyResized()   $image-&gt;copyResampled()   $image-&gt;trueColorToPalette()</p>
<h3>Image Transfomation Commands</h3>
<p>None of the image transformation commands are implemented in \s-1GD::SVG\s0. If your script calls one of the following methods, your script will die remorsefully with a warning.  With sufficient demand, I might try to implement some of these methods.  For now, I think that they are beyond the intent of \s-1GD::SVG\s0.</p><p>  $image = $sourceImage-&gt;copyRotate90()   $image = $sourceImage-&gt;copyRotate180()   $image = $sourceImage-&gt;copyRotate270()   $image = $sourceImage-&gt;copyFlipHorizontal()   $image = $sourceImage-&gt;copyFlipVertical()   $image = $sourceImage-&gt;copyTranspose()   $image = $sourceImage-&gt;copyReverseTranspose()   $image-&gt;rotate180()   $image-&gt;flipHorizontal()   $image-&gt;flipVertical()</p>
<h3>Character And String Drawing</h3>
<p>\s-1GD\s0 allows you to draw characters and strings, either in normal horizon- tal orientation or rotated 90 degrees.  In \s-1GD\s0, these routines use a GD::Font object.  Internally, \s-1GD::SVG\s0 mimics the behavior of \s-1GD\s0 with respect to fonts in a very similar manner, using instead a GD::SVG::Font object described in more detail below.</p><p>\s-1GD\s0's font handling abilities are not as flexible as \s-1SVG\s0 and it does not allow the dynamic creation of fonts, instead exporting five available fonts as global variables: gdGiantFont, gdLargeFont, gdMediumBoldFont, gdSmallFont and gdTinyFont. \s-1GD::SVG\s0 also exports these same global variables but establishes them in a different manner using constant variables to establish the font family, font height and width of these global fonts.  These values were chosen to match as closely as possible \s-1GD\s0's output.  If unsatisfactory, adjust the constants at the top of this file.  In all subroutines below, \s-1GD::SVG\s0 passes a generic GD::SVG::Font object in place of the exported font variables. This method draws a string starting at position (x,y) in the speci- fied font and color.  Your choices of fonts are gdSmallFont, gdMediumBoldFont, gdTinyFont, gdLargeFont and gdGiantFont.   $myImage-&gt;string(gdSmallFont,2,10,"Peachy Keen",$peach); Same as the previous example, except that it draws the text rotated counter-clockwise 90 degrees. These methods draw single characters at position (x,y) in the spec- ified font and color.  They're carry-overs from the C interface, where there is a distinction between characters and strings.  Perl is insensible to such subtle distinctions. Neither is \s-1SVG\s0, which simply calls the <em>string()</em> method internally. In \s-1GD\s0, these methods use TrueType to draw a scaled, antialiased strings using the TrueType font of your choice. \s-1GD::SVG\s0 can handle this directly generating by calling the <em>string()</em> method internally.   The arguments are as follows:</p><p>  fgcolor    Color index to draw the string in   fontname   An absolute path to the TrueType (.ttf) font file   ptsize     The desired point size (may be fractional)   angle      The rotation angle, in radians   x,y        X and Y coordinates to start drawing the string   string     The string itself \s-1GD::SVG\s0 attempts to extract the name of the font from the pathname supplied in the fontname argument. If it fails, Helvetica will be used instead. If successful, the method returns an eight-element list giving the boundaries of the rendered string:   @bounds[0,1]  Lower left corner (x,y)   @bounds[2,3]  Lower right corner (x,y)   @bounds[4,5]  Upper right corner (x,y)   @bounds[6,7]  Upper left corner (x,y) This from the \s-1GD\s0 documentation (not yet implemented in \s-1GD::SVG\s0): An optional 8th argument allows you to pass a hashref of options to <em>stringFT()</em>.  Two hashkeys are recognized: linespacing, if present, controls the spacing between lines of text.  charmap, if present, sets the character map to use. The value of linespacing is supposed to be a multiple of the char- acter height, so setting linespacing to 2.0 will result in double- spaced lines of text.  However the current version of libgd (2.0.12) does not do this.  Instead the linespacing seems to be double what is provided in this argument.  So use a spacing of 0.5 to get separation of exactly one line of text.  In practice, a spacing of 0.6 seems to give nice results.  Another thing to watch out for is that successive lines of text should be separated by the \*(L"&#92;r&#92;n\*(R" characters, not just \*(L"&#92;n\*(R". The value of charmap is one of \*(L"Unicode\*(R", \*(L"Shift_JIS\*(R" and \*(L"Big5\*(R".  The interaction between Perl, Unicode and libgd is not clear to me, and you should experiment a bit if you want to use this feature.   $gd-&gt;stringFT($black,&apos;/dosc/windows/Fonts/pala.ttf&apos;,40,0,20,90,                 "hi there&#92;r&#92;nbye now",                 {linespacing=&gt;0.6,                  charmap  =&gt; &apos;Unicode&apos;,                }); For backward compatibility with older versions of the FreeType library, the alias <em>stringTTF()</em> is also recognized.  Also be aware that relative font paths are not recognized due to problems in the libgd library. Call <em>useFontConfig()</em> with a value of 1 in order to enable support for fontconfig font patterns (see stringFT).  Regardless of the value of $flag, this method will return a true value if the fontconfig library is present, or false otherwise. \s-1NOT\s0 \s-1IMPLEMENTED\s0</p>
<h3>Alpha Channels</h3>
<p>\s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1NOT\s0 \s-1IMPLEMENTED\s0</p>
<h3>Miscellaneous Image Methods</h3>
<p>\s-1NOT\s0 \s-1IMPLEMENTED\s0 <em>getBounds()</em> returns the height and width of the image. \s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1NOT\s0 \s-1IMPLEMENTED\s0 \s-1NOT\s0 \s-1IMPLEMENTED\s0</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GD::SVG::Polygon METHODS</h2>
        <div class="sectioncontent">
<p>\s-1SVG\s0 is much more adept at creating polygons than \s-1GD\s0. That said, \s-1GD\s0 does provide some rudimentary support for polygons but must be created as seperate objects point by point. Create an empty polygon with no vertices.   $poly = new GD::SVG::Polygon; Add point (x,y) to the polygon.   $poly-&gt;addPt(0,0);   $poly-&gt;addPt(0,50);   $poly-&gt;addPt(25,25); Retrieve the point at the specified vertex.   ($x,$y) = $poly-&gt;<strong>getPt</strong>(2); Change the value of an already existing vertex.  It is an error to set a vertex that isn't already defined.   $poly-&gt;setPt(2,100,100); Delete the specified vertex, returning its value.   ($x,$y) = $poly-&gt;<strong>deletePt</strong>(1); Draw from current vertex to a new vertex, using relative (dx,dy) coordinates.  If this is the first point, act like <em>addPt()</em>.   $poly-&gt;addPt(0,0);   $poly-&gt;toPt(0,50);   $poly-&gt;toPt(25,-25); \s-1NOT\s0 \s-1IMPLEMENTED\s0 Return the number of vertices in the polygon. Return a list of all the verticies in the polygon object.  Each mem- ber of the list is a reference to an (x,y) array.   @vertices = $poly-&gt;vertices;   foreach $v (@vertices)       print join(",",@$v),"&#92;n";   } Return the smallest rectangle that completely encloses the polygon. The return value is an array containing the (left,top,right,bottom) of the rectangle.   ($left,$top,$right,$bottom) = $poly-&gt;bounds; Offset all the vertices of the polygon by the specified horizontal (dh) and vertical (dy) amounts.  Positive numbers move the polygon down and to the right. Returns the number of vertices affected.   $poly-&gt;offset(10,30); Map the polygon from a source rectangle to an equivalent position in a destination rectangle, moving it and resizing it as necessary.  See polys.pl for an example of how this works.  Both the source and destination rectangles are given in (left,top,right,bottom) coordi- nates.  For convenience, you can use the polygon's own bounding box as the source rectangle.   # Make the polygon really tall   $poly-&gt;map($poly-&gt;bounds,0,0,50,200); \s-1NOT\s0 \s-1IMPLEMENTED\s0 Scale each vertex of the polygon by the X and Y factors indicated by sx and sy.  For example scale(2,2) will make the polygon twice as large.  For best results, move the center of the polygon to position (0,0) before you scale, then move it back to its previous position. \s-1NOT\s0 \s-1IMPLEMENTED\s0 Run each vertex of the polygon through a transformation matrix, where sx and sy are the X and Y scaling factors, rx and ry are the X and Y rotation factors, and tx and ty are X and Y offsets.  See the Adobe PostScript Reference, page 154 for a full explanation, or experiment. \s-1NOT\s0 \s-1IMPLEMENTED\s0</p><h3>GD::Polyline</h3>
<p>Please see GD::Polyline for information on creating open polygons and splines.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GD::SVG::Font METHODS</h2>
        <div class="sectioncontent">
<p>\s-1NOTE:\s0 The object-oriented implementation to font utilites is not yet supported.</p><p>The libgd library (used by the Perl \s-1GD\s0 library) has built-in support for about half a dozen fonts, which were converted from public-domain X Windows fonts.  For more fonts, compile libgd with TrueType support and use the <em>stringFT()</em> call.</p><p>\s-1GD::SVG\s0 replicates the internal fonts of \s-1GD\s0 by hardcoding fonts which resemble the design and point size of the original.  Each of these fonts is available both as an imported global (e.g. gdSmallFont) and as a package method (e.g. GD::Font-&gt;Small).</p>
<dl class='dl-vertical'>
  <dt>
    gdTinyFont
  </dt>
  <dd>
    
  </dd>
  <dt>
    GD::Font-&gt;Tiny
  </dt>
  <dd>
    <p>This is a tiny, almost unreadable font, 5x8 pixels wide.</p>
  </dd>
  <dt>
    gdSmallFont
  </dt>
  <dd>
    
  </dd>
  <dt>
    GD::Font-&gt;Small
  </dt>
  <dd>
    <p>This is the basic small font, \*(L"borrowed\*(R" from a well known public domain 6x12 font.</p>
  </dd>
  <dt>
    gdMediumBoldFont
  </dt>
  <dd>
    
  </dd>
  <dt>
    GD::Font-&gt;MediumBold
  </dt>
  <dd>
    <p>This is a bold font intermediate in size between the small and large fonts, borrowed from a public domain 7x13 font;</p>
  </dd>
  <dt>
    gdLargeFont
  </dt>
  <dd>
    
  </dd>
  <dt>
    GD::Font-&gt;Large
  </dt>
  <dd>
    <p>This is the basic large font, \*(L"borrowed\*(R" from a well known public domain 8x16 font.</p>
  </dd>
  <dt>
    gdGiantFont
  </dt>
  <dd>
    
  </dd>
  <dt>
    GD::Font-&gt;Giant
  </dt>
  <dd>
    <p>This is a 9x15 bold font converted by Jan Pazdziora from a sans serif X11 font. This returns the number of characters in the font.   print "The large font contains ",gdLargeFont-&gt;nchars," characters&#92;n"; \s-1NOT\s0 \s-1IMPLEMENTED\s0 This returns the \s-1ASCII\s0 value of the first character in the font These return the width and height of the font.   ($w,$h) = (gdLargeFont-&gt;width,gdLargeFont-&gt;height);</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REAL WORLD EXAMPLES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    BioPerl
  </dt>
  <dd>
    <p>The Bio::Graphics package of the BioPerl project makes use of \s-1GD::SVG\s0 to export \s-1SVG\s0 graphics.   http://www.bioperl.org/</p>
  </dd>
  <dt>
    Generic Genome Browser
  </dt>
  <dd>
    <p>The Generic Genome Browser (GBrowse) utilizes Bio::Graphics and enables \s-1SVG\s0 dumping of genomics views. You can see a real-world example of \s-1SVG\s0 output from GBrowse at WormBase:   http://www.wormbase.org/cgi-bin/gbrowse/ Further information about the Generic Genome Browser is available at the Generic Model Organism Project home page:   http://www.gmod.org/</p>
  </dd>
  <dt>
    toddot
  </dt>
  <dd>
    <p>I've also prepared a number of comparative images at my website (shameless plug, hehe):   http://www.toddot.net/projects/GD-SVG/</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNAL METHODS</h2>
        <div class="sectioncontent">
<p>The following internal methods are private and documented only for those wishing to extend the \s-1GD::SVG\s0 interface.</p>
<dl class='dl-vertical'>
  <dt>
    <em>_distill_gdSpecial()</em>
  </dt>
  <dd>
    <p>When a drawing method is passed a stylized brush via gdBrushed, the internal <em>_distill_gdSpecial()</em> method attempts to make sense of this by setting line thickness and foreground color. Since stylized brushes are GD::SVG::Image objects, it does this by fetching the width of the image using the getBounds method. This width is then used to setThickness.  The last color set by colorAllocate is then used for the foreground color. In setting line thickness, \s-1GD::SVG\s0 temporarily overrides any previously set line thickness.  In \s-1GD\s0, setThickness is persistent through uses of stylized brushes. To accomodate this behavior, <em>_distill_gdSpecial()</em> temporarily stores the previous line_thickness in the $self-&gt;{previous_line_thickness} flag.</p>
  </dd>
  <dt>
    <em>_reset()</em>
  </dt>
  <dd>
    <p>The <em>_reset()</em> method is used to restore persistent drawing settings between uses of stylized brushes. Currently, this involves   - restoring line thickness</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPORTANT NOTE! GD::SVG / SVG::GD</h2>
        <div class="sectioncontent">
<p>A second module (\s-1SVG::GD\s0), written by Ronan Oger also provides similar functionality as this module. Ronan and I are concurrently developing these modules with an eye towards integrating them in the future. In principle, the primary difference is that \s-1GD::SVG\s0 aims to generate \s-1SVG\s0 and \s-1SVG\s0 only.  That is, it:</p><p>  1. Does not store an internal representation of the GD image</p><p>  2. Does not enable JPG, PNG, OR SVG output from a single pass      through data</p><p>  3. Only occasioanally uses inherited methods from GD</p><p>Instead \s-1GD::SVG\s0 depends on the user to choose which output format they would like in advance, \*(L"use\*(R"ing the appropriate module for that output. As described at the start of this document, module selection between \s-1GD\s0 and \s-1GD::SVG\s0 can be made dynamically using eval statements and variables for the differnet classes that \s-1GD\s0 and \s-1GD::SVG\s0 create.</p><p>There is a second reason for not maintaining a double representation of the data in \s-1GD\s0 and \s-1SVG\s0 format: \s-1SVG\s0 documents can quickly become very large, especially with large datasets. In cases where scripts are primarily generating png images in a server environment and would only occasionally need to export \s-1SVG\s0, gernerating an \s-1SVG\s0 image in parallel would result in an unacceptable performance hit.</p><p>Thus \s-1GD::SVG\s0 aims to be a plugin for existing configurations that depend on \s-1GD\s0 but would like to take advantage of \s-1SVG\s0 output.</p><p>\s-1SVG::GD\s0, on the other hand, aims to tie in the raster-editing ability of \s-1GD\s0 with the power of \s-1SVG\s0 output. In part, it aims to do this by inheriting many methods from \s-1GD\s0 directly and bringing them into the functional space of \s-1GD\s0.  This makes \s-1SVG::GD\s0 easier to set up initially (simply by adding the \*(L"use \s-1SVG::GD\s0\*(R" below the \*(L"use \s-1GD\s0\*(R" statement of your script. \s-1GD::SVG\s0 sacrfices this initial ease-of-setup for more targeted applications.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>Lincoln Stein, my postdoctoral mentor, author of \s-1GD\s0.pm, and all around Perl stud. Ronan Oger, author of \s-1SVG\s0.pm conceptualized and implemented another wrapper around \s-1GD\s0 at about the exact same time as this module. He also provided helpful discussions on implementing \s-1GD\s0 functions into \s-1SVG\s0.  Oliver Drechsel and Marc Lohse provided patches to actually make the stringUP method functional.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Todd Harris, PhD &lt;harris@cshl.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright @ 2003-2005 Todd Harris and the Cold Spring Harbor Laboratory</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO GD::SVG&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1GD\s0, \s-1SVG\s0, SVG::Manual, \s-1SVG::DOM\s0</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="GD::Barcode::UPCE.3pm.html"><span aria-hidden="true">&larr;</span> GD::Barcode::UPCE.3pm: Create upc-e barcode image with gd</a></li>
   <li class="next"><a href="Games::Go::Dg2ASCII.3pm.html">Games::Go::Dg2ASCII.3pm: Perl extension to convert games::go::diagrams to ascii diagrams <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

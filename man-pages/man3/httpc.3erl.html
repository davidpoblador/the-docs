<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>httpc: An http/1.1 client</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="An http/1.1 client">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="httpc (3erl) manual">
  <meta name="twitter:description" content="An http/1.1 client">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-httpc-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/httpc.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="httpc (3erl) manual" />
  <meta property="og:description" content="An http/1.1 client" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-httpc-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">httpc<small> (3erl)</small></h1>
        <p class="lead">An http/1.1 client</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/httpc.3erl.html">
      <span itemprop="name">httpc: An http/1.1 client</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/httpc.3erl.html">
      <span itemprop="name">httpc: An http/1.1 client</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides the API to a HTTP/1.1 compatible client according to RFC 2616, caching is currently not supported.</p><p><strong></strong> Note:</p><p>When starting the Inets application a manager process for the default profile will be started. The functions in this API that do not explicitly use a profile will access the default profile. A profile keeps track of proxy options, cookies and other options that can be applied to more than one request.</p><p>If the scheme https is used the ssl application needs to be started. When https links needs to go through a proxy the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS, however "TLS upgrade" according to RFC 2817 is not supported.</p><p>Also note that pipelining will only be used if the pipeline timeout is set, otherwise persistent connections without pipelining will be used e.i. the client always waits for the previous response before sending the next request.</p><p>There are some usage examples in the <strong>Inets User's Guide.</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMON DATA TYPES </h2>
        <div class="sectioncontent">
<p>Type definitions that are used more than once in this module:</p>
<pre>
boolean()    = true | false
string()     = list of ASCII characters
request_id() = ref()
profile()    = atom()
path()       = string() representing a file path or directory path
ip_address() = See inet(3erl)
socket_opt() = See the Options used by gen_tcp(3erl) and
               ssl(3erl) connect(s)

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HTTP DATA TYPES </h2>
        <div class="sectioncontent">
<p>Type definitions that are related to HTTP:</p><p>For more information about HTTP see rfc 2616</p>
<pre>
method()         = head | get | put | post | trace | options | delete
request()        = {url(), headers()} |
                   {url(), headers(), content_type(), body()}
url()            = string() - Syntax according to the URI definition in rfc 2396, ex: "http://www.erlang.org"
status_line()    = {http_version(), status_code(), reason_phrase()}
http_version()   = string() ex: "HTTP/1.1"
status_code()    = integer()
reason_phrase()  = string()
content_type()   = string()
headers()        = [header()]
header()         = {field(), value()}
field()          = string()
value()          = string()
body()           = string() |
                   binary() |
                   {fun(accumulator()) -&gt; body_processing_result(),
                    accumulator()} |
                   {chunkify,
                    fun(accumulator()) -&gt; body_processing_result(),
                    accumulator()}
body_processing_result() = eof | {ok, iolist(), accumulator()}
accumulator()    = term()
filename()       = string()

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SSL DATA TYPES </h2>
        <div class="sectioncontent">
<p>See <strong>ssl(3erl)</strong> for information about ssl options (<em>ssloptions()</em>).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HTTP CLIENT SERVICE START/STOP </h2>
        <div class="sectioncontent">
<p>A HTTP client can be configured to start when starting the inets application or started dynamically in runtime by calling the inets application API <em>inets:start(httpc, ServiceConfig)</em>, or <em>inets:start(httpc, ServiceConfig, How)</em> see <strong>inets(3erl)</strong>. Below follows a description of the available configuration options.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{profile, profile()}: Name of the profile, see common data types below, this option is mandatory.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{data_dir, path()}: Directory where the profile may save persistent data, if omitted all cookies will be treated as session cookies.</p>
  </dd>

</dl>
<p>The client can be stopped using <em>inets:stop(httpc, Pid)</em> or <em>inets:stop(httpc, Profile)</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> request(Url) -&gt;</p><p><strong></strong> request(Url, Profile) -&gt; {ok, Result} | {error, Reason}</p><p>Types:</p><p>Url = url()</p><p>Result = {status_line(), headers(), Body} | {status_code(), Body} | request_id()</p><p>Body = string() | binary()</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>Reason = term()</p><p>Equivalent to <em>httpc:request(get, {Url, []}, [], [])</em>.</p><p><strong></strong> request(Method, Request, HTTPOptions, Options) -&gt;</p><p><strong></strong> request(Method, Request, HTTPOptions, Options, Profile) -&gt; {ok, Result} | {ok, saved_to_file} | {error, Reason}</p><p>Types:</p><p>Method = method()</p><p>Request = request()</p><p>HTTPOptions = http_options()</p><p>http_options() = [http_option()]</p><p>http_option() = {timeout, timeout()} | {connect_timeout, timeout()} | {ssl, ssloptions()} | {essl, ssloptions()} | {autoredirect, boolean()} | {proxy_auth, {userstring(), passwordstring()}} | {version, http_version()} | {relaxed, boolean()} | {url_encode, boolean()}</p><p>timeout() = integer() &gt;= 0 | infinity</p><p>Options = options()</p><p>options() = [option()]</p><p>option() = {sync, boolean()} | {stream, stream_to()} | {body_format, body_format()} | {full_result, boolean()} | {headers_as_is, boolean() | {socket_opts, socket_opts()} | {receiver, receiver()}, {ipv6_host_with_brackets, boolean()}}</p><p>stream_to() = none | self | {self, once} | filename()</p><p>socket_opts() = [socket_opt()]</p><p>receiver() = pid() | function()/1 | {Module, Function, Args}</p><p>Module = atom()</p><p>Function = atom()</p><p>Args = list()</p><p>body_format() = string | binary</p><p>Result = {status_line(), headers(), Body} | {status_code(), Body} | request_id()</p><p>Body = string() | binary()</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>Reason = {connect_failed, term()} | {send_failed, term()} | term()</p><p>Sends a HTTP-request. The function can be both synchronous and asynchronous. In the later case the function will return <em>{ok, RequestId}</em> and later on the information will be delivered to the <em>receiver</em> depending on that value.</p><p>Http option (<em>http_option()</em>) details:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>timeout</em>: Timeout time for the request.</p><p>The clock starts ticking as soon as the request has been sent.</p><p>Time is in milliseconds.</p><p>Defaults to <em>infinity</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>connect_timeout</em>: Connection timeout time, used during the initial request, when the client is <em>connecting</em> to the server.</p><p>Time is in milliseconds.</p><p>Defaults to the value of the <em>timeout</em> option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ssl</em>: This is the default ssl config option, currently defaults to <em>essl</em>, see below.</p><p>Defaults to <em>[]</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>essl</em>: If using the Erlang based implementation of SSL, these SSL-specific options are used.</p><p>Defaults to <em>[]</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>autoredirect</em>: Should the client automatically retrieve the information from the new URI and return that as the result instead of a 30X-result code.</p><p>Note that for some 30X-result codes automatic redirect is not allowed. In these cases the 30X-result will always be returned.</p><p>Defaults to <em>true</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>proxy_auth</em>: A proxy-authorization header using the provided user name and password will be added to the request.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>version</em>: Can be used to make the client act as an <em>HTTP/1.0</em> or <em>HTTP/0.9</em> client. By default this is an <em>HTTP/1.1</em> client. When using <em>HTTP/1.0</em> persistent connections will not be used.</p><p>Defaults to the string <em>"HTTP/1.1"</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>relaxed</em>: If set to <em>true</em> workarounds for known server deviations from the HTTP-standard are enabled.</p><p>Defaults to <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>url_encode</em>: Will apply Percent-encoding, also known as URL encoding on the URL.</p><p>Defaults to <em>false</em>.</p>
  </dd>

</dl>
<p>Option (<em>option()</em>) details:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>sync</em>: Shall the request be synchronous or asynchronous.</p><p>Defaults to <em>true</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>stream</em>: Streams the body of a 200 or 206 response to the calling process or to a file. When streaming to the calling process using the option <em>self</em> the following stream messages will be sent to that process: <em>{http, {RequestId, stream_start, Headers}}, {http, {RequestId, stream, BinBodyPart}}, {http, {RequestId, stream_end, Headers}}</em>. When streaming to to the calling processes using the option <em>{self, once}</em> the first message will have an additional element e.i. <em>{http, {RequestId, stream_start, Headers, Pid}}</em>, this is the process id that should be used as an argument to <em>http:stream_next/1</em> to trigger the next message to be sent to the calling process.</p><p>Note that it is possible that chunked encoding will add headers so that there are more headers in the <em>stream_end</em> message than in the <em>stream_start</em>. When streaming to a file and the request is asynchronous the message <em>{http, {RequestId, saved_to_file}}</em> will be sent.</p><p>Defaults to <em>none</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>body_format</em>: Defines if the body shall be delivered as a string or as a binary. This option is only valid for the synchronous request.</p><p>Defaults to <em>string</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>full_result</em>: Should a "full result" be returned to the caller (that is, the body, the headers and the entire status-line) or not (the body and the status code).</p><p>Defaults to <em>true</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>headers_as_is</em>: Shall the headers provided by the user be made lower case or be regarded as case sensitive.</p><p>Note that the http standard requires them to be case insenstive. This feature should only be used if there is no other way to communicate with the server or for testing purpose. Also note that when this option is used no headers will be automatically added, all necessary headers have to be provided by the user.</p><p>Defaults to <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>socket_opts</em>: Socket options to be used for this and subsequent request(s).</p><p>Overrides any value set by the <strong>set_options</strong> function.</p><p>Note that the validity of the options are <em>not</em> checked in any way.</p><p>Note that this may change the socket behaviour (see <strong>inet:setopts/2</strong>) for an already existing one, and therefore an already connected request handler.</p><p>By default the socket options set by the <strong>set_options/1,2</strong> function are used when establishing a connection.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>receiver</em>: Defines how the client will deliver the result of an asynchroneous request (<em>sync</em> has the value <em>false</em>).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>pid()</em>: Message(s) will be sent to this process in the format:</p>
  </dd>

</dl>

<pre>
{http, ReplyInfo}

</pre>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>function/1</em>: Information will be delivered to the receiver via calls to the provided fun:</p>
  </dd>

</dl>

<pre>
Receiver(ReplyInfo)

</pre>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{Module, Function, Args}</em>: Information will be delivered to the receiver via calls to the callback function:</p>
  </dd>

</dl>

<pre>
apply(Module, Function, [ReplyInfo | Args])

</pre>
<p>In all of the above cases, <em>ReplyInfo</em> has the following structure:</p>
  </dd>

</dl>

<pre>
{RequestId, saved_to_file}
{RequestId, {error, Reason}}
{RequestId, Result}
{RequestId, stream_start, Headers}
{RequestId, stream_start, Headers, HandlerPid}
{RequestId, stream,       BinBodyPart}
{RequestId, stream_end,   Headers}

</pre>
<p>Defaults to the <em>pid()</em> of the process calling the request function (<em>self()</em>).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ipv6_host_with_brackets</em>: When parsing the Host-Port part of an URI with a IPv6 address with brackets, shall we retain those brackets (<em>true</em>) or strip them (<em>false</em>).</p><p>Defaults to <em>false</em>.</p>
  </dd>

</dl>
<p><strong></strong> cancel_request(RequestId) -&gt;</p><p><strong></strong> cancel_request(RequestId, Profile) -&gt; ok</p><p>Types:</p><p>RequestId = request_id() - A unique identifier as returned by request/4</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>Cancels an asynchronous HTTP-request. Note this does not guarantee that the request response will not be delivered, as it is asynchronous the the request may already have been completed when the cancellation arrives.</p><p><strong></strong> set_options(Options) -&gt;</p><p><strong></strong> set_options(Options, Profile) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Options = [Option]</p><p>Option = {proxy, {Proxy, NoProxy}} | {https_proxy, {Proxy, NoProxy}} | {max_sessions, MaxSessions} | {max_keep_alive_length, MaxKeepAlive} | {keep_alive_timeout, KeepAliveTimeout} | {max_pipeline_length, MaxPipeline} | {pipeline_timeout, PipelineTimeout} | {cookies, CookieMode} | {ipfamily, IpFamily} | {ip, IpAddress} | {port, Port} | {socket_opts, socket_opts()} | {verbose, VerboseMode}</p><p>Proxy = {Hostname, Port}</p><p>Hostname = string()</p><p>ex: "localhost" or "foo.bar.se"</p><p>Port = integer()</p><p>ex: 8080</p><p>NoProxy = [NoProxyDesc]</p><p>NoProxyDesc = DomainDesc | HostName | IPDesc</p><p>DomainDesc = "*.Domain"</p><p>ex: "*.ericsson.se"</p><p>IpDesc = string()</p><p>ex: "134.138" or "[FEDC:BA98" (all IP-addresses starting with 134.138 or FEDC:BA98), "66.35.250.150" or "[2010:836B:4179::836B:4179]" (a complete IP-address).</p><p>proxy defaults to {undefined, []} e.i. no proxy is configured and https_proxy defaults to the value of proxy.</p><p>MaxSessions = integer()</p><p>Default is <em>2</em>. Maximum number of persistent connections to a host.</p><p>MaxKeepAlive = integer()</p><p>Default is <em>5</em>. Maximum number of outstanding requests on the same connection to a host.</p><p>KeepAliveTimeout = integer()</p><p>Default is <em>120000</em> (= 2 min). If a persistent connection is idle longer than the <em>keep_alive_timeout</em> in milliseconds, the client will close the connection. The server may also have such a time out but you should not count on it!</p><p>MaxPipeline = integer()</p><p>Default is <em>2</em>. Maximum number of outstanding requests on a pipelined connection to a host.</p><p>PipelineTimeout = integer()</p><p>Default is <em>0</em>, which will result in pipelining not being used. If a persistent connection is idle longer than the <em>pipeline_timeout</em> in milliseconds, the client will close the connection.</p><p>CookieMode = enabled | disabled | verify</p><p>Default is <em>disabled</em>. If Cookies are enabled all valid cookies will automatically be saved in the client manager's cookie database. If the option <em>verify</em> is used the function <em>store_cookies/2</em> has to be called for the cookies to be saved.</p><p>IpFamily = inet | inet6 | inet6fb4</p><p>By default <em>inet</em>. When it is set to <em>inet6fb4</em> you can use both ipv4 and ipv6. It first tries <em>inet6</em> and if that does not works falls back to <em>inet</em>. The option is here to provide a workaround for buggy ipv6 stacks to ensure that ipv4 will always work.</p><p>IpAddress = ip_address()</p><p>If the host has several network interfaces, this option specifies which one to use. See <strong>gen_tcp:connect/3,4</strong> for more info.</p><p>Port = integer()</p><p>Specify which local port number to use. See <strong>gen_tcp:connect/3,4</strong> for more info.</p><p>socket_opts() = [socket_opt()]</p><p>The options are appended to the socket options used by the client.</p><p>These are the default values when a new request handler is started (for the initial connect). They are passed directly to the underlying transport (gen_tcp or ssl) <em>without</em> verification!</p><p>VerboseMode = false | verbose | debug | trace</p><p>Default is <em>false</em>. This option is used to switch on (or off) different levels of erlang trace on the client. It is a debug feature.</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>Sets options to be used for subsequent requests.</p><p><strong></strong> Note:</p><p>If possible the client will keep its connections alive and use persistent connections with or without pipeline depending on configuration and current circumstances. The HTTP/1.1 specification does not provide a guideline for how many requests would be ideal to be sent on a persistent connection, this very much depends on the application. Note that a very long queue of requests may cause a user perceived delay as earlier requests may take a long time to complete. The HTTP/1.1 specification does suggest a limit of 2 persistent connections per server, which is the default value of the <em>max_sessions</em> option.</p><p><strong></strong> get_options(OptionItems) -&gt; {ok, Values} | {error, Reason}</p><p><strong></strong> get_options(OptionItems, Profile) -&gt; {ok, Values} | {error, Reason}</p><p>Types:</p><p>OptionItems = all | [option_item()]</p><p>option_item() = proxy | https_proxy max_sessions | keep_alive_timeout | max_keep_alive_length | pipeline_timeout | max_pipeline_length | cookies | ipfamily | ip | port | socket_opts | verbose</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>Values = [{option_item(), term()}]</p><p>Reason = term()</p><p>Retrieves the options currently used by the client.</p><p><strong></strong> stream_next(Pid) -&gt; ok</p><p>Types:</p><p>Pid = pid() - as received in the stream_start message</p><p>Triggers the next message to be streamed, e.i. same behavior as active once for sockets.</p><p><strong></strong> store_cookies(SetCookieHeaders, Url) -&gt;</p><p><strong></strong> store_cookies(SetCookieHeaders, Url, Profile) -&gt; ok | {error, Reason}</p><p>Types:</p><p>SetCookieHeaders = headers() - where field = "set-cookie"</p><p>Url = url()</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>Saves the cookies defined in SetCookieHeaders in the client profile's cookie database. You need to call this function if you have set the option <em>cookies</em> to <em>verify</em>. If no profile is specified the default profile will be used.</p><p><strong></strong> cookie_header(Url) -&gt;</p><p><strong></strong> cookie_header(Url, Profile | Opts) -&gt; header() | {error, Reason}</p><p><strong></strong> cookie_header(Url, Opts, Profile) -&gt; header() | {error, Reason}</p><p>Types:</p><p>Url = url()</p><p>Opts = [cookie_header_opt()]</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>cookie_header_opt() = {ipv6_host_with_brackets, boolean()}</p><p>Returns the cookie header that would be sent when making a request to <em>Url</em> using the profile <em>Profile</em>. If no profile is specified the default profile will be used.</p><p>The option <em>ipv6_host_with_bracket</em> deals with how to parse IPv6 addresses. See the <em>Options</em> argument of the <strong>request/4,5</strong> for more info.</p><p><strong></strong> reset_cookies() -&gt; void()</p><p><strong></strong> reset_cookies(Profile) -&gt; void()</p><p>Types:</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>Resets (clears) the cookie database for the specified <em>Profile</em>. If no profile is specified the default profile will be used.</p><p><strong></strong> which_cookies() -&gt; cookies()</p><p><strong></strong> which_cookies(Profile) -&gt; cookies()</p><p>Types:</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>cookies() = [cookie_stores()]</p><p>cookie_stores() = {cookies, cookies()} | {session_cookies, cookies()}</p><p>cookies() = [cookie()]</p><p>cookie() = term()</p><p>This function produces a list of the entire cookie database. It is intended for debugging/testing purposes. If no profile is specified the default profile will be used.</p><p><strong></strong> which_sessions() -&gt; session_info()</p><p><strong></strong> which_sessions(Profile) -&gt; session_info()</p><p>Types:</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>session_info() = {GoodSessions, BadSessions, NonSessions}</p><p>GoodSessions = session()</p><p>BadSessions = tuple()</p><p>NonSessions = term()</p><p>This function produces a slightly processed dump of the session database. It is intended for debugging. If no profile is specified the default profile will be used.</p><p><strong></strong> info() -&gt; list()</p><p><strong></strong> info(Profile) -&gt; list()</p><p>Types:</p><p>Profile = profile() | pid() (when started <em>stand_alone</em>)</p><p>This function produces a list of miscelleneous info. It is intended for debugging. If no profile is specified the default profile will be used.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO httpc&hellip;</h2>
        <div class="sectioncontent">
<p>RFC 2616, <strong>inets(3erl)</strong>, <strong>gen_tcp(3erl)</strong>, <strong>ssl(3erl)</strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="http_uri.3erl.html"><span aria-hidden="true">&larr;</span> http_uri.3erl: Uri utility module</a></li>
   <li class="next"><a href="httpd.3erl.html">httpd.3erl: An implementation of an http <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XDGA: Client library for the xfree86-dga extension.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Client library for the xfree86-dga extension.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XDGA (3) manual">
  <meta name="twitter:description" content="Client library for the xfree86-dga extension.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxxf86dga-dev-XDGA-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/XDGA.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XDGA (3) manual" />
  <meta property="og:description" content="Client library for the xfree86-dga extension." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxxf86dga-dev-XDGA-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XDGA<small> (3)</small></h1>
        <p class="lead">Client library for the xfree86-dga extension.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/XDGA.3.html">
      <span itemprop="name">XDGA: Client library for the xfree86-dga extension.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxxf86dga-dev/">
      <span itemprop="name">libxxf86dga-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/XDGA.3.html">
      <span itemprop="name">XDGA: Client library for the xfree86-dga extension.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;X11/extensions/xf86dga.h&gt;</strong> Bool <strong>XDGAQueryExtension</strong>(</p><p>Display *<em>dpy</em>,</p><p>int *<em>eventBase</em>,</p><p>int *<em>errorBase</em>) Bool <strong>XDGAQueryVersion</strong>(</p><p>Display *<em>dpy</em>,</p><p>int *<em>majorVersion</em>,</p><p>int *<em>minorVersion</em>) XDGAMode *<strong>XDGAQueryModes</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>int *<em>num</em>) XDGADevice *<strong>XDGASetMode</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>int <em>mode</em>) Bool <strong>XDGAOpenFramebuffer</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>) void <strong>XDGACloseFramebuffer</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>) void <strong>XDGASetViewport</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>int <em>x</em>,</p><p>int <em>y</em>,</p><p>int <em>flags</em>) void <strong>XDGAInstallColormap</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>Colormap <em>cmap</em>) Colormap <strong>XDGACreateColormap</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>XDGADevice *<em>device</em>,</p><p>int <em>alloc</em>) void <strong>XDGASelectInput</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>long <em>event_mask</em>) void <strong>XDGAFillRectangle</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>int <em>x</em>,</p><p>int <em>y</em>,</p><p>unsigned int <em>width</em>,</p><p>unsigned int <em>height</em>,</p><p>unsigned long <em>color</em>) void <strong>XDGACopyArea</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>int <em>srcx</em>,</p><p>int <em>srcy</em>,</p><p>unsigned int <em>width</em>,</p><p>unsigned int <em>height</em>,</p><p>int <em>dstx</em>,</p><p>int <em>dsty</em>) void <strong>XDGACopyTransparentArea</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>int <em>srcx</em>,</p><p>int <em>srcy</em>,</p><p>unsigned int <em>width</em>,</p><p>unsigned int <em>height</em>,</p><p>int <em>dstx</em>,</p><p>int <em>dsty</em>,</p><p>unsigned long <em>key</em>) int <strong>XDGAGetViewportStatus</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>) void <strong>XDGASync</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>) Bool <strong>XDGASetClientVersion</strong>(</p><p>Display *<em>dpy</em>) void <strong>XDGAChangePixmapMode</strong>(</p><p>Display *<em>dpy</em>,</p><p>int <em>screen</em>,</p><p>int *<em>x</em>,</p><p>int *<em>y</em>,</p><p>int <em>mode</em>) void <strong>XDGAKeyEventToXKeyEvent</strong>(</p><p>XDGAKeyEvent *<em>dk</em>,</p><p>XKeyEvent *<em>xk</em>)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>XFree86-DGA</strong> extension is an X server extension for allowing client programs direct access to the video frame buffer.  This is a brief description of the programming interface for version 2.0 of the <strong>XFree86-DGA</strong> extension.</p><p><strong>XFree86-DGA</strong> is not intended as a direct rendering API, but rather, as a mechanism to "get the X Server out of the way" so that some other direct rendering API can have full access to the hardware.  With this in mind, DGA does provide clients some direct access to the hardware without requiring a separate rendering API, but this access is limited to direct linear framebuffer access.</p><p>Most of the reasons for the <strong>XFree86-DGA</strong> extension's existence are now better served in other ways.  Further development of this extension is not expected, and it may be deprecated in a future release.  The features that continue to be useful will either be provided through other existing mechanisms, or through an extension that address those needs more specifically.</p><p><strong>XFree86-DGA</strong> is initialized by passing a number corresponding to a valid <em>XDGAMode</em> to <strong>XDGASetMode</strong>(). Clients can get a list of valid modes from <strong>XDGAQueryModes</strong>(). Each <em>XDGAMode</em> corresponds to a different framebuffer layout.</p><p><strong>XDGAQueryModes</strong>() returns a pointer to an array of <em>XDGAMode</em>s which are valid for the given screen. <em>num</em> is the number of elements in the array.  The returned array can be freed with <strong>XFree</strong>(3).  The <em>XDGAMode</em> structure is as follows:</p>
<pre>
typedef struct {
   int num;
   char *name;
   float verticalRefresh;
   int flags;
   int imageWidth;
   int imageHeight;
   int pixmapWidth;
   int pixmapHeight;
   int bytesPerScanline;
   int byteOrder;
   int depth;
   int bitsPerPixel;
   unsigned long redMask;
   unsigned long greenMask;
   unsigned long blueMask;
   short visualClass;
   int viewportWidth;
   int viewportHeight;
   int xViewportStep;
   int yViewportStep;
   int maxViewportX;
   int maxViewportY;
   int viewportFlags;
   int reserved1;
   int reserved2;

} XDGAMode;
</pre>

<dl class='dl-vertical'>
  <dt>
    <p><em>num</em></p>
  </dt>
  <dd>
    <p>A unique identifying number (<em>num</em> &gt; 0) for the mode.  This is the number referenced when initializing the mode.</p>
  </dd>
  <dt>
    <p><em>name</em></p>
  </dt>
  <dd>
    <p>The name of the corresponding modeline as given in the xorg.conf file.</p>
  </dd>
  <dt>
    <p><em>verticalRefresh</em></p>
  </dt>
  <dd>
    <p>The vertical refresh rate for the modeline (in Hz).</p>
  </dd>
  <dt>
    <p><em>flags</em></p>
  </dt>
  <dd>
    <p>Any of the following may be OR'd together:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>XDGAConcurrentAccess</strong></p>
  </dt>
  <dd>
    <p>Indicates that concurrent client/server access to the framebuffer is possible.  If this flag is not set it is very important to call <strong>XDGASync</strong>() before directly accessing the framebuffer if a call to <strong>XDGAFillRectangle</strong>(), <strong>XDGACopyArea</strong>() or <strong>XDGACopyTransparentArea</strong>() or any Xlib rendering function has been made prior to such accesses.</p>
  </dd>
  <dt>
    <p><strong>XDGASolidFillRect</strong></p>
  </dt>
  <dd>
    <p>Indicates that <strong>XDGAFillRectangle</strong>() is supported.</p>
  </dd>
  <dt>
    <p><strong>XDGABlitRect</strong></p>
  </dt>
  <dd>
    <p>Indicates that <strong>XDGACopyArea</strong>() is supported.</p>
  </dd>
  <dt>
    <p><strong>XDGABlitTransRect</strong></p>
  </dt>
  <dd>
    <p>Indicates that <strong>XDGACopyTransparentArea</strong>() is supported.</p>
  </dd>
  <dt>
    <p><strong>XDGAPixmap</strong></p>
  </dt>
  <dd>
    <p>Indicates that a Pixmap will be returned when the mode is initialized. This means that rendering with Xlib is possible for this mode.</p>
  </dd>
  <dt>
    <p><strong>XDGAInterlaced</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>XDGADoublescan</strong></p>
  </dt>
  <dd>
    <p>Indicates that the mode is an interlaced or doublescan mode.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><em>imageWidth</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>imageHeight</em></p>
  </dt>
  <dd>
    <p>The width and height of the framebuffer area accessible by the client. This rectangle is always justified to the upper left-hand corner.</p>
  </dd>
  <dt>
    <p><em>pixmapWidth</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>pixmapHeight</em></p>
  </dt>
  <dd>
    <p>The width and height of the framebuffer area accessible by Xlib.  This rectangle is always justified to the upper left-hand corner.  These fields are only valid if the <strong>XDGAPixmap</strong> flag is set in the <em>flags</em> field.</p>
  </dd>
  <dt>
    <p><em>bytesPerScanline</em></p>
  </dt>
  <dd>
    <p>The pitch of the framebuffer in bytes.</p>
  </dd>
  <dt>
    <p><em>byteOrder</em></p>
  </dt>
  <dd>
    <p><strong>MSBFirst</strong> or <strong>LSBFirst</strong>.</p>
  </dd>
  <dt>
    <p><em>depth</em></p>
  </dt>
  <dd>
    <p>The number of bits in each pixel which contain usable data.</p>
  </dd>
  <dt>
    <p><em>bitsPerPixel</em></p>
  </dt>
  <dd>
    <p>The number of bits taken up by each pixel.</p>
  </dd>
  <dt>
    <p><em>redMask</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>greenMask</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>blueMask</em></p>
  </dt>
  <dd>
    <p>The RGB masks.  These do not apply to color-indexed modes.</p>
  </dd>
  <dt>
    <p><em>visualClass</em></p>
  </dt>
  <dd>
    <p><strong>TrueColor</strong>, <strong>PseudoColor</strong>, <strong>DirectColor</strong>, etc.</p>
  </dd>
  <dt>
    <p><em>viewportWidth</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>viewportHeight</em></p>
  </dt>
  <dd>
    <p>The dimensions of the portion of the framebuffer which will be displayed on the screen.</p>
  </dd>
  <dt>
    <p><em>xViewportStep</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>yViewportStep</em></p>
  </dt>
  <dd>
    <p>The granularity of the x,y viewport positioning possible with the <strong>XDGASetViewport</strong>() function.</p>
  </dd>
  <dt>
    <p><em>maxViewportX</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>maxViewportY</em></p>
  </dt>
  <dd>
    <p>The maximum x and y positions possible with the <strong>XDGASetViewport</strong>() function.</p>
  </dd>
  <dt>
    <p><em>viewportFlags</em></p>
  </dt>
  <dd>
    <p>Any of the following may be OR'd together</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>XDGAFlipRetrace</strong></p>
  </dt>
  <dd>
    <p>Indicates that the hardware can switch viewports during the vertical retrace.</p>
  </dd>
  <dt>
    <p><strong>XDGAFlipImmediate</strong></p>
  </dt>
  <dd>
    <p>Indicates that the hardware can switch viewports immediately without waiting for the vertical retrace.</p>
  </dd>

</dl>

  </dd>

</dl>
<p><strong>XDGASetMode</strong>() initialises the <em>XDGAMode</em> corresponding to <em>num</em>. To exit DGA mode and return to normal server operation, call <strong>XDGASetMode</strong>() with <em>num</em> set to zero. <strong>XDGASetMode</strong>() returns a pointer to an <em>XDGADevice</em> if successful.  The XDGADevice can be freed with <strong>XFree</strong>(3).  The <em>XDGADevice</em> structure is as follows:</p>
<pre>
typedef struct {
   XDGAMode mode;
   unsigned char *data;
   Pixmap pixmap;

} XDGADevice;
</pre>

<dl class='dl-vertical'>
  <dt>
    <p><em>mode</em></p>
  </dt>
  <dd>
    <p>The <em>XDGAMode</em> structure, identical to the information returned by <strong>XDGAQueryModes</strong>().</p>
  </dd>
  <dt>
    <p><em>data</em></p>
  </dt>
  <dd>
    <p>If direct framebuffer access is desired and possible, this field will contain a pointer to the mapped framebuffer memory.  Generally, this field will be zero unless a call to <strong>XDGAOpenFramebuffer</strong>() is made prior to initialization of the mode.</p>
  </dd>
  <dt>
    <p><em>pixmap</em></p>
  </dt>
  <dd>
    <p>If the mode supports Xlib rendering as indicated by <strong>XDGAPixmap</strong> in the <em>flags</em> field, this will contain a Pixmap handle suitable for passing as the drawable argument to Xlib functions.  This field will be zero if Xlib rendering is not supported.</p>
  </dd>

</dl>
<p><strong>XDGAQueryExtension</strong>() checks for the presence of the extension and returns the event and error bases.</p><p><strong>XDGAQueryVersion</strong>() returns the <strong>XFree86-DGA</strong> major and minor version numbers.</p><p><strong>XDGAOpenFramebuffer</strong>() maps the framebuffer memory.  The client needs sufficient privileges to be able to do this. <strong>XDGAOpenFramebuffer</strong>() should be called prior to initializing a DGA mode if direct framebuffer access is desired for that mode. <strong>XDGAOpenFramebuffer</strong>() does not need to be called if direct framebuffer access is not required. If the framebuffer is opened,</p><p><strong>XDGACloseFramebuffer</strong>() should be called prior to client exit to unmap the memory.</p><p><strong>XDGAChangePixmapMode</strong>() can be used to change between two pixmap sizes in cases where a Pixmap is available for Xlib rendering.  The following values for the <em>mode</em> parameter are available:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>XDGAPixmapModeLarge</strong></p>
  </dt>
  <dd>
    <p>The pixmap size is defined by the <em>pixmapWidth</em> and <em>pixmapHeight</em> fields in the <em>XDGAMode</em> structure.  The <em>x</em> and <em>y</em> values are ignored in this case.</p>
  </dd>
  <dt>
    <p><strong>XDGAPixmapModeSmall</strong></p>
  </dt>
  <dd>
    <p>The pixmap size is defined by the <em>viewportWidth</em> and <em>viewportHeight</em> fields in the <em>XDGAMode</em> structure.  In this mode, the <em>x</em> and <em>y</em> values specify where in the framebuffer this pixmap rectangle is located. It may be placed anywhere within the Xlib renderable region described by the <em>pixmapWidth</em> and <em>pixmapHeight</em> fields in the <em>XDGAMode</em>. The <em>x</em> and <em>y</em> values returned are the resultant location of the pixmap and may be different from the requested x,y location due to platform specific alignment constraints.  All Xlib rendering is clipped to this pixmap rectangle.</p>
  </dd>

</dl>
<p><strong>XDGASetViewport</strong>() sets the upper left-hand corner of the rectangle of framebuffer that is to be displayed on the screen.  Not all locations may be supported by the hardware and requested locations will be adjusted according to the <em>xViewportStep</em> and <em>yViewportStep</em> fields in the <em>XDGAMode</em>.</p><p><em>flags</em> can be <strong>XDGAFlipRetrace</strong> or <strong>XDGAFlipImmediate</strong> to adjust the viewport location at the next vertical retrace or immediately.  Values other than the supported values advertised in the mode's <em>viewportFlags</em> field will result in hardware-specific default behavior. <strong>XDGAFlipImmediate</strong> will block until the flip is completed. <strong>XDGAFlipRetrace</strong> will generally NOT block so it is necessary to monitor the viewport status with <strong>XDGAGetViewportStatus</strong>(). <strong>XDGAFlipImmediate</strong> requests during pending <strong>XDGAFlipRetrace</strong> requests will be ignored.</p><p><strong>XDGAGetViewportStatus</strong>() keeps track of the <strong>XDGASetViewport</strong>() requests still pending.  The return value of the function will have consecutive bits set (LSB justified), each bit representing a pending viewport change.  For example:</p>
<pre>
     while(XDGAGetViewportStatus(dpy, screen));
</pre>
<p>waits for all pending viewport changes to finish.</p>
<pre>
     while(0x2 & XDGAGetViewportStatus(dpy, screen));
</pre>
<p>waits until all but the last viewport changes have completed.</p><p><strong>XDGACreateColormap</strong>() is similar to the Xlib function <strong>XCreateColormap</strong>(3) except that it takes an <em>XDGADevice</em> as an argument instead of a Window and Visual.  Though <strong>XCreateColormap</strong>(3) may create usable colormaps in some cases, <strong>XDGACreateColormap</strong>() is the preferred method for creating colormaps in DGA since there may not be an advertised visual compatible with the DGA device.</p><p><strong>XDGAInstallColormap</strong>() must be used to install colormaps in DGA mode.  <strong>XInstallColormap</strong>(3) will not work.</p><p><strong>XDGASelectInput</strong>() enables DGA's own event mechanism.  This function is similar to <strong>XSelectInput</strong>(3), and all Xlib Key, Button and Motion masks are supported. The following DGA events are defined:</p>
<pre>
typedef struct {
   int type;             /\(** ButtonPress or ButtonRelease + the DGA event base*/
   unsigned long serial; /\(** # or last request processed by the server */
   Display *display;     /\(** Display the event was read from */
   int screen;           /\(** The screen number the event came from */
   Time time;            /\(** milliseconds */
   unsigned int state;   /\(** key or button mask */
   unsigned int button;  /\(** detail */

} XDGAButtonEvent;
</pre>

<pre>
typedef struct {
   int type;             /\(** KeyPress or KeyRelease + the DGA event base*/
   unsigned long serial; /\(** # or last request processed by the server */
   Display *display;     /\(** Display the event was read from */
   int screen;           /\(** The screen number the event came from */
   Time time;            /\(** milliseconds */
   unsigned int state;   /\(** key or button mask */
   unsigned int keycode; /\(** detail */

} XDGAKeyEvent;
</pre>

<pre>
typedef struct {
   int type;             /\(** MotionNotify + the DGA event base*/
   unsigned long serial; /\(** # or last request processed by the server */
   Display *display;     /\(** Display the event was read from */
   int screen;           /\(** The screen number the event came from */
   Time time;            /\(** milliseconds */
   unsigned int state;   /\(** key or button mask */
   int dx;               /\(** relative pointer motion */
   int dy;               /\(** relative pointer motion */

} XDGAMotionEvent;
</pre>
<p><strong>XDGAKeyEventToXKeyEvent</strong>() is a helper function to translate <em>XDGAKeyEvent</em>s into <em>XKeyEvent</em>s suitable for use with <strong>XLookupKeysym</strong>(3).</p><p><strong>XDGAFillRectangle</strong>(), <strong>XDGACopyArea</strong>(), and <strong>XDGACopyTransparentArea</strong>() are included with some reservation since DGA is not intended as a rendering API.  These are merely convenience routines and are optionally supported.  The associated flags will be set in the <em>XDGAMode</em>'s <em>flags</em> field if these functions are supported.  These functions will be no-ops otherwise. they do not provide direct access to the hardware, but are simply context-less operations performed by the server.</p><p><strong>XDGASync</strong>() blocks until all server rendering to the framebuffer completes.  If Xlib or the 3 rendering functions above are used, <strong>XDGASync</strong>() must be called before the client directly accesses the framebuffer as the server rendering is asynchronous with the client and may have not completed.  This is especially important if the <strong>XDGAConcurrentAccess</strong> flag is not set in the <em>XDGAMode</em>'s <em>flags</em> field since concurrent access by the server and client may result in a system lockup.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XDGA&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/Xorg.1.html"><strong>Xorg</strong>(1)</a>, <a href="../man5/xorg.conf.5.html"><strong>xorg.conf</strong>(5)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p><strong>XFree86-DGA</strong> version 2 was written by Mark Vojkovich.  Version 1 was written by Jon Tombs, Harm Hanemaayer, Mark Vojkovich.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XCompositeVersion.3.html"><span aria-hidden="true">&larr;</span> XCompositeVersion.3: X composite extension library</a></li>
   <li class="next"><a href="XDeleteDeviceProperty.3.html">XDeleteDeviceProperty.3: Get, change or delete a devices property. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ifp.h: Ifp.h -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Ifp.h -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ifp.h (3) manual">
  <meta name="twitter:description" content="Ifp.h -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libifp-dev-ifp.h-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/ifp.h.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ifp.h (3) manual" />
  <meta property="og:description" content="Ifp.h -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libifp-dev-ifp.h-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ifp.h<small> (3)</small></h1>
        <p class="lead">Ifp.h -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ifp.h.3.html">
      <span itemprop="name">ifp.h: Ifp.h -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libifp-dev/">
      <span itemprop="name">libifp-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ifp.h.3.html">
      <span itemprop="name">ifp.h: Ifp.h -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>An interface for iRiver's flash-based portable music players.</p><p><strong>Author:</strong></p><p>Copyright (C) Geoff Oakham, 2004; &lt;oakhamg@users.sourceforge.net&gt;</p><p>Calling Conventions (unless otherwise stated):</p><ul>
<li><p>integer return value 0 indicates success, error otherwise</p></li><li><p>argument 'dev' is a device handle</p></li><li><p>argument 'f' is the full path to a remote file or directory. (eg. '&#92;foo&#92;bar.mp3')</p></li><li><p>argument 'b' is a buffer for returning data</p></li><li><p>remote pathnames use '&#92;' instead of '/' for separating directories (eg '&#92;classical&#92;mozart&#92;magicflute.ogg')</p></li><li><p>functions that return numerical values (eg. <strong>ifp_freespace</strong>) return negative values on error</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<h3>Setup and initialization</h3>
<p>int <strong>ifp_init</strong> (struct <strong>ifp_device</strong> *dev, void *dev_handle)</p><p><em>Initializes device. </em> int <strong>ifp_finalize</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Releases device. Releases any resources aquired by </em><strong>ifp_init</strong><em>. Basically, when </em><strong>ifp_init</strong><em> returns 0 (success), </em><strong>ifp_finalize</strong><em> must be called after you're finished with dev. </em><strong></strong> void * <strong>ifp_find_device</strong> (void)</p><p><em>Scans the system and returns the first compatible iFP device. </em> int <strong>ifp_release_device</strong> (void *)</p><p><em>Releases device handle allocated by </em><strong>ifp_find_device</strong><em>. </em><strong></strong> int <strong>ifp_selftest</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Tests communications with the device. </em> int <strong>ifp_format</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Reformats the device's storage media. </em> int <strong>ifp_update_firmware</strong> (struct <strong>ifp_device</strong> *dev, const char *localfile, <strong>ifp_progress</strong> fn, void *context)</p><p><em>Upgrades the firmware. </em></p>
<h3>Device status</h3>
<p>int <strong>ifp_device_info</strong> (struct <strong>ifp_device</strong> *dev, char *b, int n)</p><p><em>Creates a human readable status string. </em> int <strong>ifp_battery</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Reports the battery's status on the scale from 0 to 4. </em> int <strong>ifp_capacity</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Reports the device's capacity in bytes. </em> int <strong>ifp_freespace</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Reports the device's available free space in bytes. </em> int <strong>ifp_model</strong> (struct <strong>ifp_device</strong> *dev, char *b, int n)</p><p><em>Reads in the device's model number into 's'. </em> int <strong>ifp_delta</strong> (struct <strong>ifp_device</strong> *dev, int *values)</p><p><em>(experimental) retrieves a mystery value. </em> int <strong>ifp_firmware_version</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Reads the device's firmware version. The firmware version is returned in raw BCD. For human consumption, I suggest:. </em> const char * <strong>ifp_error_message</strong> (int n)</p><p><em>Return an English string describing an error number. </em></p>
<h3>Metadata</h3>
<p>int <strong>ifp_rename</strong> (struct <strong>ifp_device</strong> *dev, const char *old_path, const char *new_path)</p><p><em>Renames a file or directory. </em> int <strong>ifp_delete</strong> (struct <strong>ifp_device</strong> *dev, const char *f)</p><p><em>Delete the file f. </em> int <strong>ifp_mkdir</strong> (struct <strong>ifp_device</strong> *dev, const char *f)</p><p><em>Creates a new directory, f. </em> int <strong>ifp_rmdir</strong> (struct <strong>ifp_device</strong> *dev, const char *f)</p><p><em>Deletes the directory f. </em> int <strong>ifp_list_dirs</strong> (struct <strong>ifp_device</strong> *dev, const char *dirname, int(*callbk)(void *, int, const char *, int), void *context)</p><p><em>Reads directory contents. </em> int <strong>ifp_treewalk_open</strong> (struct <strong>ifp_device</strong> *dev, const char *directory, void **handle)</p><p><em>Recursively walk a remote directory. (Interface similar to 'fts.h'.). </em> int <strong>ifp_treewalk_close</strong> (void *tws_p)</p><p><em>Releases the resources used in a treewalk. </em> <strong>ifp_treewalk_entry</strong> * <strong>ifp_treewalk_next</strong> (void *tws_p)</p><p><em>Returns the next file or directory in a treewalk. </em></p>
<h3>Reading files</h3>
<p>int <strong>ifp_read_open</strong> (struct <strong>ifp_device</strong> *dev, const char *f)</p><p><em>Opens the file f for reading. </em> int <strong>ifp_read_close</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Closes a file open for reading. </em> int <strong>ifp_read_seek</strong> (struct <strong>ifp_device</strong> *dev, int abs_position)</p><p><em>Fast-forward within the current file. </em> int <strong>ifp_read_data</strong> (struct <strong>ifp_device</strong> *dev, void *b, int bytes)</p><p><em>Reads from an open file. Reads the next 'bytes' of data into 'buff'. </em> int <strong>ifp_read_eof</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Check if we've reached the end of the file. (EOF). </em> int <strong>ifp_read_size</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Returns the size of the current file in bytes. </em></p>
<h3>Creating files</h3>
<p>int <strong>ifp_write_open</strong> (struct <strong>ifp_device</strong> *dev, const char *f, int fsize)</p><p><em>Opens the file f for writing. </em> int <strong>ifp_write_close</strong> (struct <strong>ifp_device</strong> *dev)</p><p><em>Closes a file open for writing. </em> int <strong>ifp_write_data</strong> (struct <strong>ifp_device</strong> *dev, void *b, int bytes)</p><p><em>Writes 'bytes' of data from buff to the file. </em></p>
<h3>Bulk file transfers (userland only)</h3>
<p>int <strong>ifp_read_file_progress</strong> (struct <strong>ifp_device</strong> *dev, FILE *dst, const char *f, int(*progress)(void *, int), void *context)</p><p><em>Downloads a file; includes a hook for a progress metre. </em> int <strong>ifp_write_file_progress</strong> (struct <strong>ifp_device</strong> *dev, FILE *src, int filesize, const char *f, int(*progress)(void *, int), void *context)</p><p><em>Uploads a file; includes a hook for a progress metre. Creates a new file 'f' on the device and populates it with data from 'src'. Filesize is the number of bytes to be uploaded from 'src'. </em> static int <strong>ifp_read_file</strong> (struct <strong>ifp_device</strong> *dev, FILE *dst, const char *f)</p><p><em>Reads the file 'f' into dst. </em> static int <strong>ifp_write_file</strong> (struct <strong>ifp_device</strong> *dev, FILE *src, int filesize, const char *f)</p><p><em>Creates a new file 'f' from src. </em> int <strong>ifp_download_file</strong> (struct <strong>ifp_device</strong> *dev, const char *remotefile, const char *localfile, <strong>ifp_progress</strong> fn, void *fn_context)</p><p><em>Downloads 'remotefile' and saves it directly on the filesystem as 'localfile'. </em> int <strong>ifp_upload_file</strong> (struct <strong>ifp_device</strong> *dev, const char *localfile, const char *remotefile, <strong>ifp_progress</strong> fn, void *fn_context)</p><p><em>Uploads 'localfile' from the filesystem onto the device as 'remotefile'. </em> int <strong>ifp_delete_dir_recursive</strong> (struct <strong>ifp_device</strong> *dev, const char *f)</p><p><em>Deletes the directory 'f', its files and subdirectories. (Think of 'rm -Rf'.). </em> int <strong>ifp_download_dir</strong> (struct <strong>ifp_device</strong> *dev, const char *remotedir, const char *localdir, <strong>ifp_progress</strong> fn, void *fn_context)</p><p><em>Downloads the contents of 'remotedir' (including all subdirectories) and saves it as 'localdir'. </em> int <strong>ifp_upload_dir</strong> (struct <strong>ifp_device</strong> *dev, const char *localdir, const char *remotedir, <strong>ifp_progress</strong> fn, void *fn_context)</p><p><em>Uploads the contents of 'localdir' (including all subdirectories) to the device as 'remotedir'. </em></p>
<h3>Boolean tests</h3>
<p>int <strong>ifp_is_file</strong> (struct <strong>ifp_device</strong> *dev, const char *f)</p><p><em>Tests if f is a file. </em> int <strong>ifp_is_dir</strong> (struct <strong>ifp_device</strong> *dev, const char *f)</p><p><em>Tests if f is a directory. </em> int <strong>ifp_exists</strong> (struct <strong>ifp_device</strong> *dev, const char *f)</p><p><em>Tests for the existance of f. </em></p>
<h3>FM Tuner preset station manipulation</h3>
<p>int <strong>ifp_get_tuner_presets</strong> (struct <strong>ifp_device</strong> *dev, void *data, int n)</p><p><em>Retrieves the tuner preset file into 'data'. </em> int <strong>ifp_set_tuner_presets</strong> (struct <strong>ifp_device</strong> *dev, void *data, int n)</p><p><em>Stores the tuner preset file 'data' on the device. </em> int <strong>ifp_get_station</strong> (int n, void *b, char *callsign, int *freq)</p><p><em>Reads station #n from the binary datablock into more useful forms. </em> int <strong>ifp_set_station</strong> (int n, void *data, const char *callsign, int freq)</p><p><em>Sets station #n to 'freq' and 'callsign'. </em></p>
<h3>Defines</h3>
<p>#define <strong>IFP_1XX</strong>   0x1001</p><p>#define <strong>IFP_3XX</strong>   0x1003</p><p>#define <strong>IFP_5XX</strong>   0x1005</p><p>#define <strong>IFP_7XX</strong>   0x1007</p><p>#define <strong>IFP_8XX</strong>   0x1008</p><p>#define <strong>IFP_9XX</strong>   0x1008</p><p>#define <strong>IFP_N10</strong>   0x1011</p><p>#define <strong>IFP_FILE</strong>   1</p><p>#define <strong>IFP_DIR</strong>   2</p><p>#define <strong>IFP_ERR_DEV_FUBAR</strong>   8</p><p>#define <strong>IFP_ERR_BAD_FREQUENCY</strong>   9</p><p>#define <strong>IFP_ERR_BAD_FILENAME</strong>   10</p><p>#define <strong>IFP_ERR_USER_CANCEL</strong>   11</p><p>#define <strong>IFP_TUNER_PRESET_DATA</strong>   240</p><p>#define <strong>IFP_FREQ_MIN</strong>   8750</p><p>#define <strong>IFP_FREQ_MAX</strong>   10800</p><p>#define <strong>IFP_PRESET_TOTAL</strong>   20</p><p>#define <strong>IFP_TUNER_LABEL</strong>   6</p>
<h3>Typedefs</h3>
<p>typedef int(* <strong>ifp_progress</strong> )(void *, struct <strong>ifp_transfer_status</strong> *)</p><p><em>Callback for implementing a progress metre. </em></p>
<h3>Enumerations</h3>
<p>enum { <strong>IFP_WALK_FILE</strong> =  IFP_FILE, <strong>IFP_WALK_DIR_PRE</strong> =  IFP_DIR, <strong>IFP_WALK_DIR_POST</strong>, <strong>IFP_WALK_NONE</strong> }</p><p><em>File types for treewalking. </em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Define Documentation</h2>
        <div class="sectioncontent">
<h3>#define IFP_1XX   0x1001</h3>
<p>Model number for iFP-100 series</p>
<h3>#define IFP_3XX   0x1003</h3>
<p>Model number for iFP-300 series</p>
<h3>#define IFP_5XX   0x1005</h3>
<p>Model number for iFP-500 series</p>
<h3>#define IFP_7XX   0x1007</h3>
<p>Model number for iFP-700 series</p>
<h3>#define IFP_8XX   0x1008</h3>
<p>Model number for iFP-800 series</p>
<h3>#define IFP_9XX   0x1008</h3>
<p>Model number for iFP-900 series</p>
<h3>#define IFP_N10   0x1011</h3>
<p>Model number for N10</p>
<h3>#define IFP_FILE   1</h3>
<p>File 'type'.</p>
<h3>#define IFP_DIR   2</h3>
<p>Dir 'type'.</p>
<h3>#define IFP_ERR_DEV_FUBAR   8</h3>
<p>device not responding; try jiggling handle</p>
<h3>#define IFP_ERR_BAD_FREQUENCY   9</h3>
<p>tuner frequency out of range</p>
<h3>#define IFP_ERR_BAD_FILENAME   10</h3>
<p>filename is invalid. Likely causes are unsupported characters, or a filename that's too long (more than ::IFP_MAXFILENAMELEN chars).</p><p>note: linux's fatfs returns EINVAL instead. Should we switch?</p>
<h3>#define IFP_ERR_USER_CANCEL   11</h3>
<p>A user callback requested the transfer be cancelled.</p>
<h3>#define IFP_TUNER_PRESET_DATA   240</h3>
<p>Tuner preset buffer size.</p>
<h3>#define IFP_FREQ_MIN   8750</h3>
<p>lowist valid frequency (87.5kHz)</p>
<h3>#define IFP_FREQ_MAX   10800</h3>
<p>highist valid frequency (108.0kHz)</p>
<h3>#define IFP_PRESET_TOTAL   20</h3>
<p>number of preset stations.</p>
<h3>#define IFP_TUNER_LABEL   6</h3>
<p>max size of label string.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>typedef int(* \fBifp_progress\fP)(void *, struct \fBifp_transfer_status\fP *)</h3>
<p>Callback for implementing a progress metre.</p><p>If provided, this function is typically called several times during a file transfer to give GUI applications a chance provide user feedback.</p><p>This function should return 0 for 'success' or 1 to request the transfer be cancelled when possible. (The request might be ignored.) Other values are considered 'error values'.</p><p>The first parameter is whatever if you passed to the main function as 'context'. You may use this for anything you like or leave it NULL.</p><p>The second parameter is a pointer to information about the transfer in progress. The only value guaranteed to be valid for _all_ transfers is file_bytes. Which values *are* valid should be obvious from context. To be on the safe side, please guard against NULL pointers and divide-by -zero errors. (The structure itself won't be NULL. I promise.)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Enumeration Type Documentation</h2>
        <div class="sectioncontent">
<h3>anonymous enum</h3>
<p>File types for treewalking.</p><p><strong>Enumeration values: </strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>IFP_WALK_FILE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>file</p>
  </dd>
  <dt>
    <p><strong></strong><em>IFP_WALK_DIR_PRE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>directory, before visiting its children</p>
  </dd>
  <dt>
    <p><strong></strong><em>IFP_WALK_DIR_POST </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>directory, after visiting its children</p>
  </dd>
  <dt>
    <p><strong></strong><em>IFP_WALK_NONE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>none of the above</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Function Documentation</h2>
        <div class="sectioncontent">
<h3>int ifp_init (struct \fBifp_device\fP * dev, void * device_handle)</h3>
<p>Initializes device.</p><p>Initialzies and tests the device for use with device_handle. (<strong>ifp_finalize</strong> should be called when you're finished with 'dev'.)</p><p><strong>Parameters:</strong></p><p><em>dev</em> Unitialized memory ready for use as an <strong>ifp_device</strong>.</p><p><em>device_handle</em> The iFP USB hardware device handle.</p><p><strong>Returns:</strong></p><p><strong>IFP_ERR_DEV_FUBAR</strong> if the self-test failed. (Ask the user to jiggle the handle.)</p><p>0 on success.</p><p><strong>Examples: </strong> <strong>simple.c</strong>.</p>
<h3>void* ifp_find_device (void)</h3>
<p>Scans the system and returns the first compatible iFP device.</p><p>If no device is found, NULL is returned. The handle must be released with <strong>ifp_release_device</strong>.</p><p><strong>Examples: </strong> <strong>simple.c</strong>.</p>
<h3>int ifp_selftest (struct \fBifp_device\fP * dev)</h3>
<p>Tests communications with the device.</p><p>This is done automatically on startup by <strong>ifp_init</strong>, so normal shouldn't need to call this.. unless they really want to.</p>
<h3>int ifp_format (struct \fBifp_device\fP * dev)</h3>
<p>Reformats the device's storage media.</p><p>(Deletes all your stuff.) Returns 0 on success, 1 on error. This function hasn't been tested--please report if you've successfully used it.</p>
<h3>int ifp_update_firmware (struct \fBifp_device\fP * dev, const char * localfile, \fBifp_progress\fP fn, void * fn_context)</h3>
<p>Upgrades the firmware.</p><p>This is much like a file upload, except: the filename on the local disk must be in the format 'IFP-?XXT.HEX', 'IFP-1XXTC.HEX' or 'N10.HEX'. The progress meter only tracks the firmware upload. The flash-upgrading itself and reboot take extra time we can't predict.</p><p>Immediately after calling ifp_update_firmware, the caller should release 'dev', and wait a healthy ammount of time (10 or more seconds) before trying to reconnect. During this time, you'll see the message 'upgrading firmware please don't touch' on the device, after which the device will shutdown: user will likely have to turn it back on themselves.</p><p>I welcome suggestions and/or code on how to help monitor the device status during a firmware upgrade.</p>
<h3>int ifp_device_info (struct \fBifp_device\fP * dev, char * s, int n)</h3>
<p>Creates a human readable status string.</p><p>Creates a human readable status string similar to 'model IFP-007T, firmware 1.14, battery =[####], delta 1.8.4.42'.</p><p><strong>Examples: </strong> <strong>simple.c</strong>.</p>
<h3>int ifp_battery (struct \fBifp_device\fP * dev)</h3>
<p>Reports the battery's status on the scale from 0 to 4.</p><p>Typical values are 4, 0 and occasionally 2.</p>
<h3>int ifp_model (struct \fBifp_device\fP * dev, char * s, int size)</h3>
<p>Reads in the device's model number into 's'.</p><p>('size' is the size of the buffer s points to.) Typical results look like 'IFP-590T'.</p>
<h3>int ifp_delta (struct \fBifp_device\fP * dev, int * values)</h3>
<p>(experimental) retrieves a mystery value.</p><p>I've coined this mystery value 'Delta' until a better name is chosen.</p><p><strong>Parameters:</strong></p><p><em>values</em> an empty int[4] for the output values.</p><p>Integers returned in 'values' are my interpretation of the data. The actual raw data has been varried widely:</p>
<pre>
 0108 0312 ffff ffff
 0108 0415 ffff ffff
 0108 0616 ffff ffff
 0108 0417 0000 0000
 0108 0418 ffff ffff
</pre>
<p>Two devices returned 4 bytes instead of 8.</p>
<h3>int ifp_firmware_version (struct \fBifp_device\fP * dev)</h3>
<p>Reads the device's firmware version. The firmware version is returned in raw BCD. For human consumption, I suggest:.</p>
<pre>
      sprintf(s, '%x.%02x', r/0x0100, r%0x100)
</pre>

<h3>const char* ifp_error_message (int n)</h3>
<p>Return an English string describing an error number.</p><p>(Available only in userland.)</p>
<h3>int ifp_rename (struct \fBifp_device\fP * dev, const char * old_path, const char * new_path)</h3>
<p>Renames a file or directory.</p><p>Renames or moves the object 'old_path' to 'new_path'.</p><p><strong>Parameters:</strong></p><p><em>old_path</em> an existing file or directory.</p><p><em>new_path</em> an available path for a new file or directory. (Ie, the path's parent directory exists and the path isn't in use by another object in that directory.)</p><p>Returns 0 on success and -ENOENT, -EEXIST, -EACCES, IFP_ERR_BAD_FILENAME on failure, as appropriate.</p>
<h3>int ifp_delete (struct \fBifp_device\fP * dev, const char * f)</h3>
<p>Delete the file f.</p><p>Returns -ENOENT if f doesn't exist.</p>
<h3>int ifp_mkdir (struct \fBifp_device\fP * dev, const char * f)</h3>
<p>Creates a new directory, f.</p><p>Returns -ENOENT if f's parent doesn't exist, -EEXISTS the dirname 'f' is allready in use, and IFP_ERR_BAD_FILENAME if 'f' contains unsupported characters.</p>
<h3>int ifp_rmdir (struct \fBifp_device\fP * dev, const char * d)</h3>
<p>Deletes the directory f.</p><p>Returns 0 on success or: -ENOENT -ENOTEMPTY -EACCES</p>
<h3>int ifp_list_dirs (struct \fBifp_device\fP * dev, const char * filename, int(*)(void *, int, const char *, int) callbk, void * context)</h3>
<p>Reads directory contents.</p><p>Passes the contents of 'dirname' to a callback function, one entry at a time. The parameters given to the callback function are:</p><ul>
<li><p>void * context is the same context passed to list_dirs</p></li><li><p>int type is either <strong>IFP_FILE</strong> or <strong>IFP_DIR</strong></p></li><li><p>char * name is the entry name without a full path. (Ie, no '&#92;' chars)</p></li><li><p>int filesize is the number of bytes in a file (undefied for directories)</p></li>
</ul><p>The callback can return '0' on success, '1' to 'break' (leave early without error) or &lt;0 on error.</p><p>Returns 0 on success or -ENOENT if the directory doesn't exist.</p><p><strong>Examples: </strong> <strong>simple.c</strong>.</p>
<h3>struct int ifp_treewalk_open (struct \fBifp_device\fP * dev, const char * directory, void ** handle)</h3>
<p>Recursively walk a remote directory. (Interface similar to 'fts.h'.).</p><p>Start a treewalk for the 'directory' on the device. The handle for this session is placed at *handle; this handle is freed by calling <strong>ifp_treewalk_close</strong>.</p><p> 'dev' won't be left in a 'special state' after calling treewalk-family functions. Likewise, please don't leave dev in a 'special state' before calling <strong>ifp_treewalk_open</strong> or <strong>ifp_treewalk_next</strong>.</p><p>Returns -ENOENT if the directory doesn't exist.</p>
<h3>int ifp_treewalk_close (void * tws_p)</h3>
<p>Releases the resources used in a treewalk.</p><p>Must be called after each successful call of <strong>ifp_treewalk_open</strong>.</p>
<h3>struct \fBifp_treewalk_entry\fP* ifp_treewalk_next (void * tws_p)</h3>
<p>Returns the next file or directory in a treewalk.</p><p>The structure returned is valid until the next <strong>ifp_treewalk_next</strong> or <strong>ifp_treewalk_close</strong> function call. See <strong>ifp_treewalk_entry</strong> for details about the fields.</p><p>Likewise, please don't leave 'dev' in a 'special state' before calling <strong>ifp_treewalk_next</strong>.</p><p>NULL is returned after the last entry.</p>
<h3>int ifp_read_open (struct \fBifp_device\fP * dev, const char * f)</h3>
<p>Opens the file f for reading.</p><p>Returns -ENOENT if 'f' doesn't exist and -EACCES if 'f' is read-protected by the device.</p>
<h3>int ifp_read_seek (struct \fBifp_device\fP * dev, int bytes)</h3>
<p>Fast-forward within the current file.</p><p>In the current open file, skip forward to 'bytes' (ignoring the data). Caution: the implementation isn't particularily fast, and can only seek forward. Avoid it if you can.</p>
<h3>int ifp_read_data (struct \fBifp_device\fP * dev, void * buff, int bytes)</h3>
<p>Reads from an open file. Reads the next 'bytes' of data into 'buff'.</p><p><strong>Returns:</strong></p><p>the number of bytes read, or &lt;0 on error.</p>
<h3>int ifp_write_open (struct \fBifp_device\fP * dev, const char * f, int filesize)</h3>
<p>Opens the file f for writing.</p><p>Creates and opens a new file of 'filesize' bytes with the name 'f'. Returns -EEXIST if the name 'f' isn't available. (Ie, if there allready exists a file or directory with the same name.) Returns -ENOENT, -ENOSPC, or IFP_ERR_BAD_FILENAME</p>
<h3>int ifp_write_data (struct \fBifp_device\fP * dev, void * buff, int bytes)</h3>
<p>Writes 'bytes' of data from buff to the file.</p><p>Returns 0 on success. (Does not return the number of bytes written--it's all or nothing.)</p>
<h3>int ifp_read_file_progress (struct \fBifp_device\fP * dev, FILE * dst, const char * f, int(*)(void *, int) fn, void * fn_context)</h3>
<p>Downloads a file; includes a hook for a progress metre.</p><p>Reads the file 'f' from the device and saves it in 'dst'.</p><p><strong>Parameters:</strong></p><p><em>f</em> name of the remote file we're downloading</p><p><em>dst</em> where the data will be saved</p><p><em>progress</em> Optional. If given, this function will be called occationally so an application can update a progress metre. (For example.)</p><p><em>context</em> Context for the progress metre. (Safe to leave NULL.)</p><p>(Available only in userland.)</p><p>Returns -ENOENT if 'f' doesn't exist; -EACCES if 'f' is read-protected by the device; -ENOSPC; and <strong>IFP_ERR_USER_CANCEL</strong> if the callback requested the transfer cancelled.</p><p>(Available only in userland.)</p>
<h3>int ifp_write_file_progress (struct \fBifp_device\fP * dev, FILE * src, int filesize, const char * f, int(*)(void *, int) fn, void * fn_context)</h3>
<p>Uploads a file; includes a hook for a progress metre. Creates a new file 'f' on the device and populates it with data from 'src'. Filesize is the number of bytes to be uploaded from 'src'.</p><p>(Note: it appears the device might not need to know the number of bytes in a file ahead time. The current implementation doesn't support this, but if you don't have access to the filesize ahead of time, you might be able to hack libifp to let you do it anyways.)</p><p><strong>Parameters:</strong></p><p><em>src</em> data to be uploaded</p><p><em>filesize</em> number of bytes to copy from src</p><p><em>f</em> name of the file to be created</p><p><em>progress</em> Optional. If given, this function will be called occationally so an application can update its progress metre.</p><p><em>context</em> Context for the progress metre. (Safe to leave NULL.)</p><p>Returns -EEXIST, -ENOENT, -ENOSPC, <strong>IFP_ERR_BAD_FILENAME</strong>, <strong>IFP_ERR_USER_CANCEL</strong></p><p>(Available only in userland.)</p>
<h3>struct int ifp_download_file (struct \fBifp_device\fP * dev, const char * remotefile, const char * localfile, \fBifp_progress\fP fn, void * fn_context)</h3>
<p>Downloads 'remotefile' and saves it directly on the filesystem as 'localfile'.</p><p>The progress callback function 'fn' and its context pointer are optional. See <strong>ifp_progress</strong> and <strong>ifp_transfer_status</strong> for more information.</p><p>Returns -ENOENT, -EACCES, -ENOSPC and <strong>IFP_ERR_USER_CANCEL</strong> (Available only in userland.)</p><p>Note: There is currently a 'EPIPE' bug in the wild that is relatively rare but causes file corruption during download. ifp_download_file and ifp_download_dir detect and recover from it automatically, but you might see the progress numbers 'jump backwards' occasionally.</p>
<h3>int ifp_upload_file (struct \fBifp_device\fP * dev, const char * localfile, const char * remotefile, \fBifp_progress\fP fn, void * fn_context)</h3>
<p>Uploads 'localfile' from the filesystem onto the device as 'remotefile'.</p><p>The progress callback function 'fn' and its context pointer are optional. See <strong>ifp_progress</strong> and <strong>ifp_transfer_status</strong> for more information.</p><p>Returns -EEXIST, -ENOENT, -ENOSPC, <strong>IFP_ERR_BAD_FILENAME</strong>, <strong>IFP_ERR_USER_CANCEL</strong> (Available only in userland.)</p>
<h3>int ifp_delete_dir_recursive (struct \fBifp_device\fP * dev, const char * f)</h3>
<p>Deletes the directory 'f', its files and subdirectories. (Think of 'rm -Rf'.).</p><p>Will return -ENOENT if 'f' doesn't exist or isn't a directory.</p><p>(Available only in userland, at this time.)</p>
<h3>int ifp_download_dir (struct \fBifp_device\fP * dev, const char * remotedir, const char * localdir, \fBifp_progress\fP fn, void * fn_context)</h3>
<p>Downloads the contents of 'remotedir' (including all subdirectories) and saves it as 'localdir'.</p><p>Note that 'localdir' must not allready exist. Example: suppose localdir was '/tmp/tunes/tame' and remotedir was '&#92;classical&#92;junk'. The directory '/tmp/tunes/tame' will be created and the file '&#92;classical&#92;junk&#92;buz&#92;fud.ogg' will be copied as '/tmp/tunes/tame/buz/fud.ogg'</p><p>The progress callback function 'fn' and its context pointer are optional. See <strong>ifp_progress</strong> and <strong>ifp_transfer_status</strong> for more information.</p><p>Returns -ENOENT, -EACCES, -ENOSPC <strong>IFP_ERR_USER_CANCEL</strong></p><p>(Available only in userland.)</p><p>Note: There is currently a 'EPIPE' bug in the wild that is relatively rare but causes file corruption during download. ifp_download_file and ifp_download_dir detect and recover from it automatically, but you might see the progress numbers 'jump backwards' occasionally.</p>
<h3>int ifp_upload_dir (struct \fBifp_device\fP * dev, const char * localdir, const char * remotedir, \fBifp_progress\fP fn, void * fn_context)</h3>
<p>Uploads the contents of 'localdir' (including all subdirectories) to the device as 'remotedir'.</p><p>Note that 'remotedir' must not exist on the remote device. Example: suppose localdir was '/tmp/tunes/tame' and remotedir was '&#92;classical&#92;junk'. The directory '&#92;classical&#92;junk' will be created and the file '/tmp/tunes/tame/buz/fud.ogg' will be copied as '&#92;classical&#92;junk&#92;buz&#92;fud.ogg'.</p><p>The progress callback function 'fn' and its context pointer are optional. See <strong>ifp_progress</strong> and <strong>ifp_transfer_status</strong> for more information.</p><p>Returns -EEXIST, -ENOENT, -ENOSPC, <strong>IFP_ERR_BAD_FILENAME</strong>, or <strong>IFP_ERR_USER_CANCEL</strong>. FIXME: handle invalid filenames from local filesystem with more grace</p><p>(Available only in userland.)</p>
<h3>int ifp_is_file (struct \fBifp_device\fP * dev, const char * f)</h3>
<p>Tests if f is a file.</p><p>Returns 1 if it is, and 0 if it doesn't exist or isn't a file.</p>
<h3>int ifp_is_dir (struct \fBifp_device\fP * dev, const char * f)</h3>
<p>Tests if f is a directory.</p><p>Returns 1 if it is, and 0 if it doesn't exist or isn't a dir.</p>
<h3>int ifp_exists (struct \fBifp_device\fP * dev, const char * f)</h3>
<p>Tests for the existance of f.</p><p><strong>Returns:</strong></p><p><strong>IFP_FILE</strong> if f is a file</p><p><strong>IFP_DIR</strong> if f is a directory</p><p>0 if f doesn't exist</p><p>&lt;0 error.</p>
<h3>int ifp_get_tuner_presets (struct \fBifp_device\fP * dev, void * data, int n)</h3>
<p>Retrieves the tuner preset file into 'data'.</p><p> 'data' is a buffer of 'n' bytes.. n must be at least <strong>IFP_TUNER_PRESET_DATA</strong> bytes.</p>
<h3>int ifp_set_tuner_presets (struct \fBifp_device\fP * dev, void * data, int n)</h3>
<p>Stores the tuner preset file 'data' on the device.</p><p> 'data' is tuner preset file to be stored.. it is extactly <strong>IFP_TUNER_PRESET_DATA</strong> bytes. 'n' must be exactly <strong>IFP_TUNER_PRESET_DATA</strong></p>
<h3>int ifp_get_station (int n, void * b, char * callsign, int * freq)</h3>
<p>Reads station #n from the binary datablock into more useful forms.</p><p>b is the block of data loaded using <strong>ifp_get_tuner_presets</strong>, n is a number between 0 and <strong>IFP_PRESET_TOTAL</strong>-1, callsign is a pointer to a buffer of at least <strong>IFP_TUNER_LABEL</strong>+1 bytes, freq is a pointer to an integer, where the station's frequency will be saved. The frequency units are 10*kHz (0.01MHz) and should range from <strong>IFP_FREQ_MIN</strong> to <strong>IFP_FREQ_MAX</strong>.</p><p>Apon successful return, 'callsign' will be loaded the station's label as a zero-terminated string, and 'freq' will be the station's frequency in units of 10*kHz (0.01MHz).</p>
<h3>int ifp_set_station (int n, void * b, const char * callsign, int freq)</h3>
<p>Sets station #n to 'freq' and 'callsign'.</p><p>b is the block of data loaded using <strong>ifp_get_tuner_presets</strong>, n is a number between 0 and <strong>IFP_PRESET_TOTAL</strong>-1, callsign is a zero-terminated string (but only the first 6 characters will be used), freq is the FM frequency in units of Hz*10^4 (or 0.01 MHz); freq should range from <strong>IFP_FREQ_MIN</strong> to <strong>IFP_FREQ_MAX</strong>.</p><p>eg: //sets station #4 to 94.9MHz and labeled 'bbc1' i = <strong>ifp_set_station</strong>(3, p, 'bbc1', 9490);</p><p>Notes: -<strong>ifp_set_tuner_presets</strong> must be called before any changes to take affect.</p><p>-Although this interface suggests frequency accuracy of 0.01MHz is possible, I've found some players only support increments 0.05MHz. Setting a frequency to a more accurate value is *not* an error: the hardware will silently truncate to a nearby acceptable value.</p><p>-User interfaces can provide feedback to the user of the above 'effect' by saving and reloading the preset data after every change. Any trunction by the hardware will be immediately obvious.</p><p>Returns <strong>IFP_ERR_BAD_FREQUENCY</strong> if the frequency is out of range.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for libifp from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="if_nametoindex.3.html"><span aria-hidden="true">&larr;</span> if_nametoindex.3: Mappings between network interface names and indexes</a></li>
   <li class="next"><a href="ilaclc.3.html">ilaclc.3: Ilaclc.f - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ct_telnet: Common test specific layer on top of telnet client ct_telnet_client.erl</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Common test specific layer on top of telnet client ct_telnet_client.erl">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ct_telnet (3erl) manual">
  <meta name="twitter:description" content="Common test specific layer on top of telnet client ct_telnet_client.erl">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-ct_telnet-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/ct_telnet.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ct_telnet (3erl) manual" />
  <meta property="og:description" content="Common test specific layer on top of telnet client ct_telnet_client.erl" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-ct_telnet-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ct_telnet<small> (3erl)</small></h1>
        <p class="lead">Common test specific layer on top of telnet client ct_telnet_client.erl</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ct_telnet.3erl.html">
      <span itemprop="name">ct_telnet: Common test specific layer on top of telnet client ct_telnet_client.erl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ct_telnet.3erl.html">
      <span itemprop="name">ct_telnet: Common test specific layer on top of telnet client ct_telnet_client.erl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Common Test specific layer on top of telnet client <em>ct_telnet_client.erl</em></p><p>Use this module to set up telnet connections, send commands and perform string matching on the result. See the <em>unix_telnet</em> manual page for information about how to use <em>ct_telnet</em>, and configure connections, specifically for unix hosts.</p><p>The following default values are defined in <em>ct_telnet</em>:</p>
<pre>
  Connection timeout = 10 sec (time to wait for connection)
  Command timeout = 10 sec (time to wait for a command to return)
  Max no of reconnection attempts = 3
  Reconnection interval = 5 sek (time to wait in between reconnection attempts)
  Keep alive = true (will send NOP to the server every 10 sec if connection is idle)
</pre>
<p>These parameters can be altered by the user with the following configuration term:</p>
<pre>
  {telnet_settings, [{connect_timeout,Millisec},
                     {command_timeout,Millisec},
                     {reconnection_attempts,N},
                     {reconnection_interval,Millisec},
                     {keep_alive,Bool}]}.
</pre>
<p><em>Millisec = integer(), N = integer()</em></p><p>Enter the <em>telnet_settings</em> term in a configuration file included in the test and ct_telnet will retrieve the information automatically. Note that <em>keep_alive</em> may be specified per connection if required. See <em>unix_telnet</em> for details.</p><p><em></em><strong>Logging</strong></p><p>The default logging behaviour of <em>ct_telnet</em> is to print information to the test case HTML log about performed operations and commands and their corresponding results. What won't be printed to the HTML log are text strings sent from the telnet server that are not explicitly received by means of a <em>ct_telnet</em> function such as <em>expect/3</em>. <em>ct_telnet</em> may however be configured to use a special purpose event handler, implemented in <em>ct_conn_log_h</em>, for logging <em>all</em> telnet traffic. To use this handler, you need to install a Common Test hook named <em>cth_conn_log</em>. Example (using the test suite info function):</p>
<pre>
  suite() -&gt;
      [{ct_hooks, [{cth_conn_log, [{conn_mod(),hook_options()}]}]}].
</pre>
<p><em>conn_mod()</em> is the name of the common_test module implementing the connection protocol, i.e. <em>ct_telnet</em>.</p><p>The <em>cth_conn_log</em> hook performs unformatted logging of telnet data to a separate text file. All telnet communication is captured and printed, including arbitrary data sent from the server. The link to this text file can be found on the top of the test case HTML log.</p><p>By default, data for all telnet connections is logged in one common file (named <em>default</em>), which might get messy e.g. if multiple telnet sessions are running in parallel. It is therefore possible to create a separate log file for each connection. To configure this, use the hook option <em>hosts</em> and list the names of the servers/connections that will be used in the suite. Note that the connections must be named for this to work (see the <em>open</em> function below).</p><p>The hook option named <em>log_type</em> may be used to change the <em>cth_conn_log</em> behaviour. The default value of this option is <em>raw</em>, which results in the behaviour described above. If the value is set to <em>html</em>, all telnet communication is printed to the test case HTML log instead.</p><p>All <em>cth_conn_log</em> hook options described above can also be specified in a configuration file with the configuration variable <em>ct_conn_log</em>. Example:</p>
<pre>
  {ct_conn_log, [{ct_telnet,[{log_type,raw},
                             {hosts,[key_or_name()]}]}]}
</pre>
<p><em>Note</em> that hook options specified in a configuration file will overwrite any hardcoded hook options in the test suite!</p><p><em></em><strong>Logging example</strong></p><p>The following <em>ct_hooks</em> statement will cause printing of telnet traffic to separate logs for the connections named <em>server1</em> and <em>server2</em>. Traffic for any other connections will be logged in the default telnet log.</p>
<pre>
  suite() -&gt;
      [{ct_hooks,
        [{cth_conn_log, [{ct_telnet,[{hosts,[server1,server2]}]}]}]}].
</pre>
<p>As previously explained, the above specification could also be provided by means of an entry like this in a configuration file:</p>
<pre>
  {ct_conn_log, [{ct_telnet,[{hosts,[server1,server2]}]}]}.
</pre>
<p>in which case the <em>ct_hooks</em> statement in the test suite may simply look like this:</p>
<pre>
  suite() -&gt;
      [{ct_hooks, [{cth_conn_log, []}]}].
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>connection() = handle() | {target_name() (see module ct), connection_type()} | target_name() (see module ct)</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>connection_type() = telnet | ts1 | ts2</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>handle() = handle() (see module ct_gen_conn)</em>:</p><p>Handle for a specific telnet connection.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>prompt_regexp() = string()</em>:</p><p>A regular expression which matches all possible prompts for a specific type of target. The regexp must not have any groups i.e. when matching, re:run/3 shall return a list with one single element.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> close(Connection) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Connection = connection() (see module ct_telnet)</p><p>Reason = term()</p><p>Close the telnet connection and stop the process managing it.</p><p>A connection may be associated with a target name and/or a handle. If <em>Connection</em> has no associated target name, it may only be closed with the handle value (see the <em>open/4</em> function).</p><p><strong></strong> cmd(Connection, Cmd) -&gt; {ok, Data} | {error, Reason}</p><p>Equivalent to <strong>cmd(Connection, Cmd, DefaultTimeout)</strong>.</p><p><strong></strong> cmd(Connection, Cmd, Timeout) -&gt; {ok, Data} | {error, Reason}</p><p>Types:</p><p>Connection = connection() (see module ct_telnet)</p><p>Cmd = string()</p><p>Timeout = integer()</p><p>Data = [string()]</p><p>Reason = term()</p><p>Send a command via telnet and wait for prompt.</p><p><strong></strong> cmdf(Connection, CmdFormat, Args) -&gt; {ok, Data} | {error, Reason}</p><p>Equivalent to <strong>cmdf(Connection, CmdFormat, Args, DefaultTimeout)</strong>.</p><p><strong></strong> cmdf(Connection, CmdFormat, Args, Timeout) -&gt; {ok, Data} | {error, Reason}</p><p>Types:</p><p>Connection = connection() (see module ct_telnet)</p><p>CmdFormat = string()</p><p>Args = list()</p><p>Timeout = integer()</p><p>Data = [string()]</p><p>Reason = term()</p><p>Send a telnet command and wait for prompt (uses a format string and list of arguments to build the command).</p><p><strong></strong> expect(Connection, Patterns) -&gt; term()</p><p>Equivalent to <strong>expect(Connections, Patterns, [])</strong>.</p><p><strong></strong> expect(Connection, Patterns, Opts) -&gt; {ok, Match} | {ok, MatchList, HaltReason} | {error, Reason}</p><p>Types:</p><p>Connection = connection() (see module ct_telnet)</p><p>Patterns = Pattern | [Pattern]</p><p>Pattern = string() | {Tag, string()} | prompt | {prompt, Prompt}</p><p>Prompt = string()</p><p>Tag = term()</p><p>Opts = [Opt]</p><p>Opt = {idle_timeout, IdleTimeout} | {total_timeout, TotalTimeout} | repeat | {repeat, N} | sequence | {halt, HaltPatterns} | ignore_prompt | no_prompt_check</p><p>IdleTimeout = infinity | integer()</p><p>TotalTimeout = infinity | integer()</p><p>N = integer()</p><p>HaltPatterns = Patterns</p><p>MatchList = [Match]</p><p>Match = RxMatch | {Tag, RxMatch} | {prompt, Prompt}</p><p>RxMatch = [string()]</p><p>HaltReason = done | Match</p><p>Reason = timeout | {prompt, Prompt}</p><p>Get data from telnet and wait for the expected pattern.</p><p><em>Pattern</em> can be a POSIX regular expression. If more than one pattern is given, the function returns when the first match is found.</p><p><em>RxMatch</em> is a list of matched strings. It looks like this: <em>[FullMatch, SubMatch1, SubMatch2, ...]</em> where <em>FullMatch</em> is the string matched by the whole regular expression and <em>SubMatchN</em> is the string that matched subexpression no <em>N</em>. Subexpressions are denoted with '(' ')' in the regular expression</p><p>If a <em>Tag</em> is given, the returned <em>Match</em> will also include the matched <em>Tag</em>. Else, only <em>RxMatch</em> is returned.</p><p>The <em>idle_timeout</em> option indicates that the function shall return if the telnet client is idle (i.e. if no data is received) for more than <em>IdleTimeout</em> milliseconds. Default timeout is 10 seconds.</p><p>The <em>total_timeout</em> option sets a time limit for the complete expect operation. After <em>TotalTimeout</em> milliseconds, <em>{error,timeout}</em> is returned. The default value is <em>infinity</em> (i.e. no time limit).</p><p>The function will always return when a prompt is found, unless any of the <em>ignore_prompt</em> or <em>no_prompt_check</em> options are used, in which case it will return when a match is found or after a timeout.</p><p>If the <em>ignore_prompt</em> option is used, <em>ct_telnet</em> will ignore any prompt found. This option is useful if data sent by the server could include a pattern that would match the prompt regexp (as returned by <em>TargedMod:get_prompt_regexp/0</em>), but which should not cause the function to return.</p><p>If the <em>no_prompt_check</em> option is used, <em>ct_telnet</em> will not search for a prompt at all. This is useful if, for instance, the <em>Pattern</em> itself matches the prompt.</p><p>The <em>repeat</em> option indicates that the pattern(s) shall be matched multiple times. If <em>N</em> is given, the pattern(s) will be matched <em>N</em> times, and the function will return with <em>HaltReason = done</em>.</p><p>The <em>sequence</em> option indicates that all patterns shall be matched in a sequence. A match will not be concluded untill all patterns are matched.</p><p>Both <em>repeat</em> and <em>sequence</em> can be interrupted by one or more <em>HaltPatterns</em>. When <em>sequence</em> or <em>repeat</em> is used, there will always be a <em>MatchList</em> returned, i.e. a list of <em>Match</em> instead of only one <em>Match</em>. There will also be a <em>HaltReason</em> returned.</p><p><em>Examples:</em></p><p><em>expect(Connection,[{abc,"ABC"},{xyz,"XYZ"}],</em> <em>[sequence,{halt,[{nnn,"NNN"}]}]).</em></p><p>will try to match "ABC" first and then "XYZ", but if "NNN" appears the function will return <em>{error,{nnn,["NNN"]}}</em>. If both "ABC" and "XYZ" are matched, the function will return <em>{ok,[AbcMatch,XyzMatch]}</em>.</p><p><em>expect(Connection,[{abc,"ABC"},{xyz,"XYZ"}],</em> <em>[{repeat,2},{halt,[{nnn,"NNN"}]}]).</em></p><p>will try to match "ABC" or "XYZ" twice. If "NNN" appears the function will return with <em>HaltReason = {nnn,["NNN"]}</em>.</p><p>The <em>repeat</em> and <em>sequence</em> options can be combined in order to match a sequence multiple times.</p><p><strong></strong> format_data(How, X2) -&gt; term()</p><p><strong></strong> get_data(Connection) -&gt; {ok, Data} | {error, Reason}</p><p>Types:</p><p>Connection = connection() (see module ct_telnet)</p><p>Data = [string()]</p><p>Reason = term()</p><p>Get all data which has been received by the telnet client since last command was sent.</p><p><strong></strong> open(Name) -&gt; {ok, Handle} | {error, Reason}</p><p>Equivalent to <strong>open(Name, telnet)</strong>.</p><p><strong></strong> open(Name, ConnType) -&gt; {ok, Handle} | {error, Reason}</p><p>Types:</p><p>Name = target_name()</p><p>ConnType = connection_type() (see module ct_telnet)</p><p>Handle = handle() (see module ct_telnet)</p><p>Reason = term()</p><p>Open a telnet connection to the specified target host.</p><p><strong></strong> open(KeyOrName, ConnType, TargetMod) -&gt; {ok, Handle} | {error, Reason}</p><p>Equivalent to <strong>open(KeyOrName, ConnType, TargetMod, [])</strong>.</p><p><strong></strong> open(KeyOrName, ConnType, TargetMod, Extra) -&gt; {ok, Handle} | {error, Reason}</p><p>Types:</p><p>KeyOrName = Key | Name</p><p>Key = atom()</p><p>Name = target_name() (see module ct)</p><p>ConnType = connection_type()</p><p>TargetMod = atom()</p><p>Extra = term()</p><p>Handle = handle()</p><p>Reason = term()</p><p>Open a telnet connection to the specified target host.</p><p>The target data must exist in a configuration file. The connection may be associated with either <em>Name</em> and/or the returned <em>Handle</em>. To allocate a name for the target, use <em>ct:require/2</em> in a test case, or use a <em>require</em> statement in the suite info function (<em>suite/0</em>), or in a test case info function. If you want the connection to be associated with <em>Handle</em> only (in case you need to open multiple connections to a host for example), simply use <em>Key</em>, the configuration variable name, to specify the target. Note that a connection that has no associated target name can only be closed with the handle value.</p><p><em>TargetMod</em> is a module which exports the functions <em>connect(Ip,Port,KeepAlive,Extra)</em> and <em>get_prompt_regexp()</em> for the given <em>TargetType</em> (e.g. <em>unix_telnet</em>).</p><p><em>See also:</em> <strong>ct:require/2</strong>.</p><p><strong></strong> send(Connection, Cmd) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Connection = connection() (see module ct_telnet)</p><p>Cmd = string()</p><p>Reason = term()</p><p>Send a telnet command and return immediately.</p><p>The resulting output from the command can be read with <em>get_data/1</em> or <em>expect/2/3</em>.</p><p><strong></strong> sendf(Connection, CmdFormat, Args) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Connection = connection() (see module ct_telnet)</p><p>CmdFormat = string()</p><p>Args = list()</p><p>Reason = term()</p><p>Send a telnet command and return immediately (uses a format string and a list of arguments to build the command).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO ct_telnet&hellip;</h2>
        <div class="sectioncontent">
<p><strong>unix_telnet</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p><em></em> &lt;&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ct_ssh.3erl.html"><span aria-hidden="true">&larr;</span> ct_ssh.3erl: Ssh/sftp client module.</a></li>
   <li class="next"><a href="dbg.3erl.html">dbg.3erl: The text based trace facility <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DBIx::DBStag: </title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="DBIx::DBStag (3pm) manual">
  <meta name="twitter:description" content="">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdbix-dbstag-perl-DBIx::DBStag-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/DBIx::DBStag.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="DBIx::DBStag (3pm) manual" />
  <meta property="og:description" content="" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdbix-dbstag-perl-DBIx::DBStag-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">DBIx::DBStag<small> (3pm)</small></h1>
        <p class="lead"></p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::DBStag.3pm.html">
      <span itemprop="name">DBIx::DBStag: </span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdbix-dbstag-perl/">
      <span itemprop="name">libdbix-dbstag-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::DBStag.3pm.html">
      <span itemprop="name">DBIx::DBStag: </span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>  use DBIx::DBStag;   my $dbh = DBIx::DBStag-&gt;connect("dbi:Pg:dbname=moviedb");   my $sql = q[               SELECT                studio.*,                movie.*,                star.*               FROM                studio NATURAL JOIN                movie NATURAL JOIN                movie_to_star NATURAL JOIN                star               WHERE                movie.genre = &apos;sci-fi&apos; AND star.lastname = &apos;Fisher&apos;               USE NESTING                (set(studio(movie(star))))              ];   my $dataset = $dbh-&gt;selectall_stag($sql);   my @studios = $dataset-&gt;get_studio;</p><p>  # returns nested data that looks like this -   #   # (studio   #  (name "20th C Fox")   #  (movie   #   (name "star wars") (genre "sci-fi")   #   (star   #    (firstname "Carrie")(lastname "Fisher")))))</p><p>  # iterate through result tree -   foreach my $studio (@studios) {         printf "STUDIO: %s&#92;n", $studio-&gt;get_name;         my @movies = $studio-&gt;get_movie;</p><p>        foreach my $movie (@movies) {             printf "  MOVIE: %s (genre:%s)&#92;n",               $movie-&gt;get_name, $movie-&gt;get_genre;             my @stars = $movie-&gt;get_star;</p><p>            foreach my $star (@stars) {                 printf "    STARRING: %s:%s&#92;n",                   $star-&gt;get_firstname, $star-&gt;get_lastname;             }         }   }</p><p>  # manipulate data then store it back in the database   my @allstars = $dataset-&gt;get("movie/studio/star");   $_-&gt;set_fullname($_-&gt;get_firstname.&apos; &apos;.$_-&gt;get_lastname)     foreach(@allstars);</p><p>  $dbh-&gt;storenode($dataset);   exit 0;</p><p>Or from the command line:</p><p>  unix&gt; selectall_xml.pl -d &apos;dbi:Pg:dbname=moviebase&apos;     &#92;        &apos;SELECT * FROM studio NATURAL JOIN movie NATURAL   &#92;           JOIN movie_to_star NATURAL JOIN star            &#92;           USE NESTING (set(studio(movie(star))))&apos;</p><p>Or using a predefined template:</p><p>  unix&gt; selectall_xml.pl -d moviebase /mdb-movie genre=sci-fi</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is for mapping between relational databases and Stag objects (Structured Tags - see Data::Stag). Stag objects can also be represented as \s-1XML\s0. The module has two main uses:</p>
<dl class='dl-vertical'>
  <dt>
    Querying
  </dt>
  <dd>
    <p>This module can take the results of any \s-1SQL\s0 query and decompose the flattened results into a tree data structure which reflects the foreign keys in the underlying relational schema. It does this by looking at the \s-1SQL\s0 query and introspecting the database schema, rather than requiring metadata or an object model. In this respect, the module works just like a regular \s-1DBI\s0 handle, with a few extra methods. Queries can also make use of predefined <strong>templates</strong></p>
  </dd>
  <dt>
    Storing Data
  </dt>
  <dd>
    <p>DBStag objects can store any tree-like datastructure (such as \s-1XML\s0 documents) into a database using normalized schema that reflects the structure of the tree being stored. This is done using little or no metadata. \s-1XML\s0 can also be imported, and a relational schema automatically generated.</p>
  </dd>

</dl>
<p>For a tutorial on using DBStag to build and query relational databases from \s-1XML\s0 sources, please see DBIx::DBStag::Cookbook</p><h3>\s-1HOW\s0 \s-1QUERY\s0 \s-1RESULTS\s0 \s-1ARE\s0 \s-1TURNED\s0 \s-1INTO\s0 \s-1STAG/XML\s0</h3>
<p>This is a general overview of the rules for turning \s-1SQL\s0 query results into a tree like data structure. You don't need to understand all these rules to be able to use this module - you can experiment by using the <strong>selectall_xml.pl</strong> script which comes with this distribution.</p><p><em>Mapping Relations</em></p><p>Relations (i.e. tables and views) are elements (nodes) in the tree. The elements have the same name as the relation in the database.</p><p>These nodes are always non-terminal (ie they always have child nodes)</p><p><em>Mapping Columns</em></p><p>Table and view columns of a relation are sub-elements of the table or view to which they belong. These elements will be <strong>data elements</strong> (i.e. terminal nodes). Only the columns selected in the \s-1SQL\s0 query will be present.</p><p>For example, the following query</p><p>  SELECT name, job FROM person;</p><p>will return a data structure that looks like this:</p><p>  (set    (person     (name "fred")     (job "forklift driver"))    (person     (name "joe")     (job "steamroller mechanic")))</p><p>The data is shown as a lisp-style S-Expression - it can also be expressed as \s-1XML\s0, or manipulated as an object within perl.</p><p><em>Handling table aliases</em></p><p>If an \s-1ALIAS\s0 is used in the \s-1FROM\s0 part of the \s-1SQL\s0 query, the relation element will be nested inside an element with the same name as the alias. For instance, the query</p><p>  SELECT name FROM person AS author WHERE job = &apos;author&apos;;</p><p>Will return a data structure like this:</p><p>  (set    (author     (person      (name "Philip K Dick"))))</p><p>The underlying assumption is that aliasing is used for a purpose in the original query; for instance, to determine the context of the relation where it may be ambiguous.</p><p>  SELECT *   FROM person AS employee            INNER JOIN        person AS boss ON (employee.boss_id = boss.person_id)</p><p>Will generate a nested result structure similar to this -</p><p>  (set    (employee     (person      (person_id "...")      (name "...")      (salary  "...")      (boss       (person        (person_id "...")        (name "...")        (salary  "..."))))))</p><p>If we neglected the alias, we would have 'person' directly nested under 'person', and the meaning would not be obvious. Note how the contents of the \s-1SQL\s0 query dynamically modifies the schema/structure of the result tree.</p><p><em>\s-1NOTE\s0 \s-1ON\s0 \s-1SQL\s0 \s-1SYNTAX\s0</em></p><p>Right now, DBStag is fussy about how you specify aliases; you must use <strong>\s-1AS\s0</strong> - you must say</p><p>  SELECT name FROM person AS author;</p><p>instead of</p><p>  SELECT name FROM person author;</p><p><em>Nesting of relations</em></p><p>The main utility of querying using this module is in retrieving the nested relation elements from the flattened query results. Given a query over relations A, B, C, D,... there are a number of possible tree structures. Not all of the tree structures are meaningful or useful.</p><p>Usually it will make no sense to nest A under B if there is no foreign key relationship linking either A to B, or B to A. This is not always the case - it may be desirable to nest A under B if there is an intermediate linking table that is required at the relational level but not required in the tree structure.</p><p>DBStag will guess a structure/schema based on the ordering of the relations in your \s-1FROM\s0 clause. However, this guess can be over-ridden at either the \s-1SQL\s0 level (using DBStag specific \s-1SQL\s0 extensions) or at the \s-1API\s0 level.</p><p>The default algorithm is to nest each relation element under the relation element preceding it in the \s-1FROM\s0 clause; for instance:</p><p>  SELECT * FROM a NATURAL JOIN b NATURAL JOIN c</p><p>If there are appropriately named foreign keys, the following data will be returned (assuming one column 'x_foo' in each of a, b and c)</p><p>  (set    (a     (a_foo "...")     (b      (b_foo "...")      (c       (c_foo "...")))))</p><p>where 'x_foo' is a column in relation 'x'</p><p>This is not always desirable. If both b and c have foreign keys into table a, DBStag will not detect this - you have to guide it. There are two ways of doing this - you can guide by bracketing your \s-1FROM\s0 clause like this:</p><p>  SELECT * FROM (a NATURAL JOIN b) NATURAL JOIN c</p><p>This will generate</p><p>  (set    (a     (a_foo "...")     (b      (b_foo "..."))     (c      (c_foo "..."))))</p><p>Now b and c are siblings in the tree. The algorithm is similar to before: nest each relation element under the relation element preceding it; or, if the preceding item in the \s-1FROM\s0 clause is a bracketed structure, nest it under the first relational element in the bracketed structure.</p><p>(Note that in MySQL you may not place brackets in the \s-1FROM\s0 clause in this way)</p><p>Another way to achieve the same thing is to specify the desired tree structure using a DBStag specific \s-1SQL\s0 extension. The DBStag specific component is removed from the \s-1SQL\s0 before being presented to the \s-1DBMS\s0. The extension is the <strong>\s-1USE\s0 \s-1NESTING\s0</strong> clause, which should come at the end of the \s-1SQL\s0 query (and is subsequently removed before processing by the \s-1DBMS\s0).</p><p>  SELECT *   FROM a NATURAL JOIN b NATURAL JOIN c   USE NESTING (set (a (b)(c)));</p><p>This will generate the same tree as above (i.e. 'b' and 'c' are siblings). Notice how the nesting in the clause is the same as the nesting in the resulting tree structure.</p><p>Note that 'set' is not a table in the underlying relational schema - the result data tree requires a named top level node to group all the 'a' relations under. You can call this top level element whatever you like.</p><p>If you are using the DBStag \s-1API\s0 directly, you can pass in the nesting structure as an argument to the select call; for instance:</p><p>  my $xmlstr =     $dbh-&gt;selectall_xml(-sql=&gt;q[SELECT *                                 FROM a NATURAL JOIN b                                      NATURAL JOIN c],                         -nesting=&gt;&apos;(set (a (b)(c)))&apos;);</p><p>or the equivalent -</p><p>  my $xmlstr =     $dbh-&gt;selectall_xml(q[SELECT *                           FROM a NATURAL JOIN b                                NATURAL JOIN c],                         &apos;(set (a (b)(c)))&apos;);</p><p>If you like, you can also use \s-1XML\s0 here (only at the \s-1API\s0 level, not at the \s-1SQL\s0 level) -</p><p>  my $seq =     $dbh-&gt;selectall_xml(-sql=&gt;q[SELECT *                                 FROM a NATURAL JOIN b                                      NATURAL JOIN c],                         -nesting=&gt;q[                                     &lt;set&gt;                                       &lt;a&gt;                                         &lt;b&gt;&lt;/b&gt;                                         &lt;c&gt;&lt;/c&gt;                                       &lt;/a&gt;                                     &lt;/set&gt;                                    ]);</p><p>As you can see, this is a little more verbose than the S-Expression</p><p>Most command line scripts that use this module should allow pass-through via the '-nesting' switch.</p><p><em>Aliasing of functions and expressions</em></p><p>If you alias a function or an expression, DBStag needs to know where to put the resulting column; the column must be aliased.</p><p>This is inferred from the first named column in the function or expression; for example, the \s-1SQL\s0 below uses the minus function:</p><p>  SELECT blah.*, foo.*, foo.x-foo.y AS z</p><p>The <strong>z</strong> element will be nested under the <strong>foo</strong> element</p><p>You can force different nesting using a <strong>double underscore</strong>:</p><p>  SELECT blah.*, foo.*, foo.x - foo.y AS blah_\|_z</p><p>This will nest the <strong>z</strong> element under the <strong>blah</strong> element</p><p>If you would like to override this behaviour and use the alias as the element name, pass in the -aliaspolicy=&gt;'a' arg to the \s-1API\s0 call. If you wish to use the table names without nesting, use -aliaspolicy=&gt;'t'.</p>
<h3>Conformance to DTD/XML-Schema</h3>
<p>DBStag returns Data::Stag structures that are equivalent to a simplified subset of \s-1XML\s0 (and also a simplified subset of lisp S-Expressions).</p><p>These structures are examples of <strong>semi-structured data</strong> - a good reference is this book -</p><p>  Data on the Web: From Relations to Semistructured Data and XML   Serge Abiteboul, Dan Suciu, Peter Buneman   Morgan Kaufmann; 1st edition (January 2000)</p><p>The schema for the resulting Stag structures can be seen to conform to a schema that is dynamically determined at query-time from the underlying relational schema and from the specification of the query itself.</p><p>If you need to generate a \s-1DTD\s0 you can ause the <strong>stag-autoschema.pl</strong> script, which is part of the Data::Stag distribution</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUERY METHODS</h2>
        <div class="sectioncontent">
<p>The following methods are for using the DBStag \s-1API\s0 to query a database</p><h3>connect</h3>
<p>  Usage   - $dbh = DBIx::DBStag-&gt;connect($DSN);   Returns - L&lt;DBIx::DBStag&gt;   Args    - see the connect() method in L&lt;DBI&gt;</p><p>This will be the first method you call to initiate a DBStag object</p><p>The \s-1DSN\s0 may be a standard \s-1DBI\s0 \s-1DSN\s0, or it can be a DBStag alias</p>
<h3>selectall_stag</h3>
<p> Usage   - $stag = $dbh-&gt;selectall_stag($sql);            $stag = $dbh-&gt;selectall_stag($sql, $nesting_clause);            $stag = $dbh-&gt;selectall_stag(-template=&gt;$template,                                         -bind=&gt;{%variable_bindinfs});  Returns - L&lt;Data::Stag&gt;  Args    - sql string,            [nesting string],            [bind hashref],            [template DBIx::DBStag::SQLTemplate]</p><p>Executes a query and returns a Data::Stag structure</p><p>An optional nesting expression can be passed in to control how the relation is decomposed into a tree. The nesting expression can be \s-1XML\s0 or an S-Expression; see above for details</p>
<h3>selectall_xml</h3>
<p> Usage   - $xml = $dbh-&gt;selectall_xml($sql);  Returns - string  Args    - See selectall_stag()</p><p>As <em>selectall_stag()</em>, but the results are transformed into an \s-1XML\s0 string</p>
<h3>selectall_sxpr</h3>
<p> Usage   - $sxpr = $dbh-&gt;selectall_sxpr($sql);  Returns - string  Args    - See selectall_stag()</p><p>As <em>selectall_stag()</em>, but the results are transformed into an S-Expression string; see Data::Stag for more details.</p>
<h3>selectall_sax</h3>
<p> Usage   - $dbh-&gt;selectall_sax(-sql=&gt;$sql, -handler=&gt;$sax_handler);  Returns - string  Args    - sql string, [nesting string], handler SAX</p><p>As <em>selectall_stag()</em>, but the results are transformed into \s-1SAX\s0 events</p><p>[currently this is just a wrapper to selectall_xml but a genuine event generation model will later be used]</p>
<h3>selectall_rows</h3>
<p> Usage   - $tbl = $dbh-&gt;selectall_rows($sql);  Returns - arrayref of arrayref  Args    - See selectall_stag()</p><p>As <em>selectall_stag()</em>, but the results of the \s-1SQL\s0 query are left undecomposed and unnested. The resulting structure is just a flat table; the first row is the column headings. This is similar to \s-1DBI-\s0&gt;<em>selectall_arrayref()</em>. The main reason to use this over the direct \s-1DBI\s0 method is to take advantage of other stag functionality, such as templates</p>
<h3>prepare_stag \s-1PRIVATE\s0 \s-1METHOD\s0</h3>
<p> Usage   - $prepare_h = $dbh-&gt;prepare_stag(-template=&gt;$template);  Returns - hashref (see below)  Args    - See selectall_stag()</p><p>Returns a hashref</p><p>      {        sth=&gt;$sth,        exec_args=&gt;&#92;@exec_args,        cols=&gt;&#92;@cols,        col_aliases_ordered=&gt;&#92;@col_aliases_ordered,        alias=&gt;$aliasstruct,        nesting=&gt;$nesting       };</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STORAGE METHODS</h2>
        <div class="sectioncontent">
<p>The following methods are for using the DBStag \s-1API\s0 to store nested data in a database</p><h3>storenode</h3>
<p>  Usage   - $dbh-&gt;storenode($stag);   Returns -   Args    - L&lt;Data::Stag&gt;</p><p>\s-1SEE\s0 \s-1ALSO:\s0 The <strong>stag-storenode.pl</strong> script</p><p>Recursively stores a stag tree structure in the database.</p><p>The database schema is introspected for most of the mapping data, but you can supply your own (see later)</p><p>The Stag tree/XML must be a direct mapping of the relational schema. Column and table names must correspond to element names. Elements may be nested. Different styles of XML-Relational mapping may be used: XORT-style and the more compact Stag-style</p><p><em>XORT-style mapping</em></p><p>With a XORT-style mapping, elements corresponding to tables can be nested under elements corresponding to foreign keys.</p><p>For example, if the relational schema has a foreign key from table <strong>person</strong> to table <strong>address</strong>, the following \s-1XML\s0 is permissable:</p><p>  &lt;person&gt;     &lt;name&gt;..&lt;/name&gt;     &lt;address_id&gt;       &lt;address&gt;       &lt;/address&gt;     &lt;/address_id&gt;   &lt;/person&gt;</p><p>The <strong>address</strong> node will be stored in the database and collapsed to whatever the value of the primary key is.</p><p><em>Stag-style mapping</em></p><p>Stag-style is more compact, but sometimes relies on the presence of a <strong>dbstag_metadata</strong> element to specify how foreign keys are mapped</p><p><em>Operations</em></p><p>Operations are specified as attributes inside elements, specifying whether the nod should be inserted, updated, looked up or stored/forced. Operations are optional (default is force/store).</p><p>  &lt;person op="insert"&gt;    &lt;name&gt;fred&lt;/name&gt;    &lt;address_id op="lookup"&gt;     &lt;streetaddr&gt;..&lt;/&gt;     &lt;city&gt;..&lt;/&gt;    &lt;/address_id&gt;   &lt;/person&gt;</p><p>The above will always insert into the person table (which may be quite dangerous; if an entry with the same unique constraint exists, an error will be thrown). Assuming (streetaddr,city) is a unique constraint for the address table, this will lookup the specified address (and not modify the table) and use the returned pk value for the <strong>person.address_id</strong> foreign key</p><p>The operations are:</p>
<dl class='dl-vertical'>
  <dt>
    force (default)
  </dt>
  <dd>
    <p>looks up (by unique constraints) first; if exists, will do an update. if does not exist, will do an insert</p>
  </dd>
  <dt>
    insert
  </dt>
  <dd>
    <p>insert only. \s-1DBMS\s0 will throw error if row with same \s-1UC\s0 exists</p>
  </dd>
  <dt>
    update
  </dt>
  <dd>
    <p>update only. \s-1DBMS\s0 will throw error if a row the with the specified \s-1UC\s0 cannot be found</p>
  </dd>
  <dt>
    lookup
  </dt>
  <dd>
    <p>finds the pk value using one of the unique constraints present in the \s-1XML\s0 node</p>
  </dd>
  <dt>
    delete \s-1NOT\s0 \s-1IMPLEMENTED\s0
  </dt>
  <dd>
    <p>deletes row that has matching \s-1UC\s0</p>
  </dd>

</dl>
<p>Operations can be used in either \s-1XORT\s0 or Stag mode</p><p><em>Macros</em></p><p>Macros can be used with either \s-1XORT\s0 or Stag style mappings. Macros allow you to refer to the same node later on in the \s-1XML\s0</p><p>  &lt;person op="lookup" id="joe"&gt;     &lt;name&gt;joe&lt;/name&gt;   &lt;/person&gt;   &lt;person op="lookup" id="fred"&gt;     &lt;name&gt;fred&lt;/name&gt;   &lt;/person&gt;   ...   &lt;person_relationship&gt;     &lt;type&gt;friend&lt;/type&gt;     &lt;person1_id&gt;joe&lt;/person1_id&gt;     &lt;person2_id&gt;fred&lt;/person2_id&gt;   &lt;/person_relationship&gt;</p><p>Assuming <strong>name</strong> is a unique constraint for <strong>person</strong>, and person_relationship has two foreign keys named person1_id and person2_id linking to the person table, DBStag will first lookup the two person rows by name (throwing an error if not present) and use the returned pk values to populate the person_relationship table</p><p><em>How it works</em></p><p>Before a node is stored, certain subnodes will be pre-stored; these are subnodes for which there is a foreign key mapping \s-1FROM\s0 the parent node \s-1TO\s0 the child node. This pre-storage is recursive.</p><p>After these nodes are stored, the current node is either INSERTed or UPDATEd. The database is introspected for \s-1UNIQUE\s0 constraints; these are used as keys. If there exists a row in the database with matching key, then the node is UPDATEd; otherwise it is INSERTed.</p><p>(primary keys from pre-stored nodes become foreign key values in the existing node)</p><p>Subsequently, all subnodes that were not pre-stored are now post-stored.  The primary key for the existing node will become foreign keys for the post-stored subnodes.</p>
<h3>force_safe_node_names</h3>
<p>  Usage   - $dbh-&gt;<strong>force_safe_node_names</strong>(1);   Returns - bool   Args    - bool [optional]</p><p>If this is set, then before storage, all node names are made <strong>DB-safe</strong>; they are lowercased, and the following transform is applied:</p><p>  tr/a-z0-9_//cd;</p>
<h3>mapping</h3>
<p>  Usage   - $dbh-&gt;mapping(["alias/table.col=fktable.fkcol"]);   Returns -   Args    - array</p><p>Creates a stag-relational mapping (for storing data only)</p><p>Occasionally not enough information can be obtained from db introspection; you can provide extra mapping data this way.</p><p>Occasionally you stag objects/data/XML will contain aliases that do not correspond to actual \s-1SQL\s0 relations; the aliases are intermediate nodes that provide information on which foreign key column to use</p><p>For example, with data like this:</p><p>  (person    (name "...")    (favourite_film     (film (....))    (least_favourite_film     (film (....)))))</p><p>There may only be two \s-1SQL\s0 tables: person and film; person would have two foreign key columns into film. The mapping may look like this</p><p>  ["favourite_film/person.favourite_film_id=film.film_id",    "least_favourite_film/person.least_favourite_film_id=film.film_id"]</p><p>The mapping can also be supplied in the xml that is loaded; any node named \*(L"dbstag_metadata\*(R" will not be loaded; it is used to supply the mapping. For example:</p><p>  &lt;personset&gt;     &lt;dbstag_mapping&gt;       &lt;map&gt;favourite_film/person.favourite_film_id=film.film_id&lt;/map&gt;       &lt;map&gt;least_favourite_film/person.least_favourite_film_id=film.film_id&lt;/map&gt;     &lt;/dbstag_mapping&gt;     &lt;person&gt;...</p>
<h3>mapconf</h3>
<p>  Usage   - $dbh-&gt;mapconf("mydb-stagmap.stm");   Returns -   Args    - filename</p><p>sets the conf file containing the stag-relational mappings</p><p>This is not of any use for a XORT-style mapping, where foreign key columns are explicitly stated</p><p>See <em>mapping()</em> above</p><p>The file contains line like:</p><p>  favourite_film/person.favourite_film_id=film.film_id   least_favourite_film/person.least_favourite_film_id=film.film_id</p>
<h3>noupdate_h</h3>
<p>  Usage   - $dbh-&gt;noupdate_h({person=&gt;1})   Returns -   Args    - hashref</p><p>Keys of hash are names of nodes that do not get updated - if a unique key is queried for and does not exist, the node will be inserted and subnodes will be stored; if the unique key does exist in the db, then this will not be updated; subnodes will not be stored</p>
<h3>trust_primary_key_values</h3>
<p>  Usage   - $dbh-&gt;<strong>trust_primary_key_values</strong>(1)   Returns - bool   Args    - bool (optional)</p><p>The default behaviour of the <em>storenode()</em> method is to remap all <strong>surrogate</strong> \s-1PRIMARY\s0 \s-1KEY\s0 values it comes across.</p><p>A surrogate primary key is typically a primary key of type \s-1SERIAL\s0 (or \s-1AUTO_INCREMENT\s0) in MySQL. They are identifiers assigned automatically be the database with no semantics.</p><p>It may be desirable to store the same data in two different databases. We would generally not expect the surrogate IDs to match between databases, even if the rest of the data does.</p><p>(If you do not use surrogate primary key columns in your load xml, then you can ignore this accessor)</p><p>You should \s-1NOT\s0 use this method in conjunction with Macros</p><p>If you use primary key columns in your \s-1XML\s0, and the primary keys are not surrogate, then youshould set this.  If this accessor is set to non-zero (true) then the primary key values in the \s-1XML\s0 will be used.</p><p>If your db has surrogate/auto-increment/serial PKs, and you wish to use these \s-1PK\s0 columns in your \s-1XML\s0, yet you want to make \s-1XML\s0 that can be exported from one db and imported into another, then the default behaviour will be fine.</p><p>For example, if we extract a 'person' from a db with surrogate \s-1PK\s0 <strong>id</strong> and unique key <strong>ssno</strong>, we may get this:</p><p>  &lt;person&gt;     &lt;id&gt;23&lt;/id&gt;     &lt;name&gt;fred&lt;/name&gt;     &lt;ssno&gt;1234-567&lt;/ssno&gt;   &lt;/person&gt;</p><p>If we then import this into an entirely fresh db, with no rows in table <strong>person</strong>, then the default behaviour of <em>storenode()</em> will create a row like this:</p><p>  &lt;person&gt;     &lt;id&gt;1&lt;/id&gt;     &lt;name&gt;fred&lt;/name&gt;     &lt;ssno&gt;1234-567&lt;/ssno&gt;   &lt;/person&gt;</p><p>The \s-1PK\s0 val 23 has been mapped to 1 (all foreign keys that point to person.id=23 will now point to person.id=1)</p><p>If we were to first call $sdbh-&gt;<em>trust_primary_key_values</em>\|(1), then person.id would remain to be 23. This would only be appropriate behaviour if we were storing back into the same db we retrieved from.</p>
<h3>tracenode</h3>
<p>  Usage   - $dbh-&gt;tracenode(&apos;person/name&apos;)</p><p>Traces on \s-1STDERR\s0 inserts/updates on a particular element type (table), displaying the sub-element (column value).</p>
<h3>is_caching_on \fB\s-1ADVANCED\s0 \s-1OPTION\s0\fP</h3>
<p>  Usage   - $dbh-&gt;is_caching_on(&apos;person&apos;, 1)   Returns - number   Args    - number                    0: off (default)                    1: memory-caching ON                    2: memory-caching OFF, bulkload ON                    3: memory-caching ON, bulkload ON</p><p>IN-MEMORY \s-1CACHING\s0</p><p>By default no in-memory caching is used. If this is set to 1, then an in-memory cache is used for any particular element. No cache management is used, so you should be sure not to cache elements that will cause memory overloads.</p><p>Setting this will not affect the final result, it is purely an efficiency measure for use with <em>storenode()</em>.</p><p>The cache is indexed by all unique keys for that particular element/table, wherever those unique keys are set</p><p>\s-1BULKLOAD\s0</p><p>If bulkload is used without memory-caching (set to 2), then only INSERTs will be performed for this element. Note that this could potentially cause a unique key violation, if the same element is present twice</p><p>If bulkload is used with memory-caching (set to 3) then only INSERTs will be performed; the unique serial/autoincrement identifiers for those inserts will be cached and used. This means you can have the same element twice. However, the load must take place in one session, otherwise the contents of memory will be lost</p>
<h3>clear_cache</h3>
<p>  Usage   - $dbh-&gt;clear_cache;   Returns -   Args    - none</p><p>Clears the in-memory cache</p><p>Caches are not automatically managed - the \s-1API\s0 user is responsible for making suring the cache does not get too big</p>
<h3>cache_summary</h3>
<p>  Usage   - print $dbh-&gt;cache_summary-&gt;xml   Returns -  L&lt;Data::Stag&gt;   Args    -</p><p>Gives a summary of the size of the in-memory cache by keys. This can be used for automatic cache management:</p><p>  $person_cache = $dbh-&gt;cache_summary-&gt;get_person;   my @index_nodes = $person_cache-&gt;tnodes;   foreach (@index_nodes) {     if ($_-&gt;data &gt; MAX_PERSON_CACHE_SIZE) {       $dbh-&gt;clear_cache;     }   }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SQL TEMPLATES</h2>
        <div class="sectioncontent">
<p>DBStag comes with its own \s-1SQL\s0 templating system. This allows you to reuse the same canned \s-1SQL\s0 or similar \s-1SQL\s0 qeuries in different contexts. See DBIx::DBStag::SQLTemplate</p><h3>find_template</h3>
<p>  Usage   - $template = $dbh-&gt;find_template("my-template-name");   Returns - L&lt;DBIx::DBStag::SQLTemplate&gt;   Args    - str</p><p>Returns an object representing a canned paramterized \s-1SQL\s0 query. See DBIx::DBStag::SQLTemplate for documentation on templates</p>
<h3>list_templates</h3>
<p>  Usage   - $templates = $dbh-&gt;list_templates();   Returns - Arrayref of L&lt;DBIx::DBStag::SQLTemplate&gt;   Args    -</p><p>Returns a list of \s-1ALL\s0 defined templates - See DBIx::DBStag::SQLTemplate</p>
<h3>find_templates_by_schema</h3>
<p>  Usage   - $templates = $dbh-&gt;find_templates_by_schema($schema_name);   Returns - Arrayref of L&lt;DBIx::DBStag::SQLTemplate&gt;   Args    - str</p><p>Returns a list of templates for a particular schema - See DBIx::DBStag::SQLTemplate</p>
<h3>find_templates_by_dbname</h3>
<p>  Usage   - $templates = $dbh-&gt;find_templates_by_dbname("mydb");   Returns - Arrayref of L&lt;DBIx::DBStag::SQLTemplate&gt;   Args    - db name</p><p>Returns a list of templates for a particular db</p><p>Requires resources to be set up (see below)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESOURCES</h2>
        <div class="sectioncontent">
<p>Generally when connecting to a database, it is necessary to specify a \s-1DBI\s0 style \s-1DSN\s0 locator. DBStag also allows you specify a <strong>resource</strong> list file which maps logical names to full locators</p><p>The following methods allows you to use a resource list</p><h3>resources_list</h3>
<p>  Usage   - $rlist = $dbh-&gt;resources_list   Returns - arrayref to a hashref   Args    - none</p><p>Returns a list of resources; each resource is a hash</p><p>  {name=&gt;"mydbname",    type=&gt;"rdb",    schema=&gt;"myschema",   }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SETTING UP RESOURCES</h2>
        <div class="sectioncontent">
<p>The above methods rely on you having a file describing all the relational dbs available to you, and setting the env var \s-1DBSTAG_DBIMAP_FILE\s0 set (this is a <strong>:</strong> separated list of paths).</p><p><strong>This is alpha code - not fully documented, \s-1API\s0 may change</strong></p><p>Currently a resources file is a whitespace delimited text file - XML/Sxpr/IText definitions may be available later</p><p>Here is an example of a resources file:</p><p>  # LOCAL   mytestdb         rdb        Pg:mytestdb                      schema=test</p><p>  # SYSTEM   worldfactbook    rdb      Pg:worldfactbook@db1.mycompany.com  schema=wfb   employees        rdb      Pg:employees@db2.mycompany.com      schema=employees</p><p>The first column is the <strong>nickname</strong> or <strong>logical name</strong> of the resource/db. This nickname can be used instead of the full \s-1DBI\s0 locator path (eg you can just use <strong>employees</strong> instead of <strong>dbi:Pg:dbname=employees;host=db2.mycompany.com</strong></p><p>The second column is the resource type - rdb is for relational database. You can use the same file to track other system datasources available to you, but DBStag is only interested in relational dbs.</p><p>The 3rd column is a way of locating the resource - driver:name@host</p><p>The 4th column is a <strong>;</strong> separated list of <strong>tag</strong>=<strong>value</strong> pairs; the most important tag is the <strong>schema</strong> tag. Multiple dbs may share the same schema, and hence share \s-1SQL\s0 Templates</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMAND LINE SCRIPTS</h2>
        <div class="sectioncontent">
<p>DBStag is usable without writing any perl, you can use command line scripts and files that utilise tree structures (\s-1XML\s0, S-Expressions)</p>
<dl class='dl-vertical'>
  <dt>
    selectall_xml.pl
  </dt>
  <dd>
    <p> selectall_xml.pl -d &lt;DSN&gt; [-n &lt;nestexpr&gt;] &lt;SQL&gt; Queries database and writes decomposed relation as \s-1XML\s0 Can also be used with templates:  selectall_xml.pl -d &lt;DSN&gt; /&lt;templatename&gt; &lt;var1&gt; &lt;var2&gt; ... &lt;varN&gt;</p>
  </dd>
  <dt>
    selectall_html.pl
  </dt>
  <dd>
    <p> selectall_html.pl -d &lt;DSN&gt; [-n &lt;nestexpr&gt;] &lt;SQL&gt; Queries database and writes decomposed relation as \s-1HTML\s0 with nested tables indicating the nested structures.</p>
  </dd>
  <dt>
    stag-storenode.pl
  </dt>
  <dd>
    <p> stag-storenode.pl -d &lt;DSN&gt; &lt;file&gt; Stores data from a file (Supported formats: \s-1XML\s0, Sxpr, IText - see Data::Stag) in a normalized database. Gets it right most of the time. \s-1TODO\s0 - metadata help</p>
  </dd>
  <dt>
    stag-autoddl.pl
  </dt>
  <dd>
    <p> stag-autoddl.pl [-l &lt;linktable&gt;]* &lt;file&gt; Takes data from a file (Supported formats: \s-1XML\s0, Sxpr, IText - see Data::Stag) and generates a relational schema in the form of \s-1SQL\s0 \s-1CREATE\s0 \s-1TABLE\s0 statements.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT VARIABLES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    \s-1DBSTAG_TRACE\s0
  </dt>
  <dd>
    <p>setting this environment will cause all \s-1SQL\s0 statements to be printed on \s-1STDERR\s0, as well as a full trace of how nodes are stored</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>The \s-1SQL\s0 parsing can be quite particular - sometimes the \s-1SQL\s0 can be parsed by the \s-1DBMS\s0 but not by DBStag. The error messages are not always helpful.</p><p>There are probably a few cases the \s-1SQL\s0 \s-1SELECT\s0 parsing grammar cannot deal with.</p><p>If you want to select from views, you need to hack DBIx::DBSchema (as of v0.21)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>Use SQL::Translator to make \s-1SQL\s0 \s-1DDL\s0 generation less Pg-specific; also for deducing foreign keys (right now foreign keys are guessed by the name of the column, eg table_id)</p><p>Can we cache the grammar so that startup is not so slow?</p><p>Improve algorithm so that events are fired rather than building up entire structure in-memory</p><p>Tie in all \s-1DBI\s0 attributes accessible by hash, i.e.: $dbh-&gt;{...}</p><p>Error handling</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WEBSITE</h2>
        <div class="sectioncontent">
<p>&lt;http://stag.sourceforge.net&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Chris Mungall &lt;<em>cjm \s-1AT\s0 fruitfly \s-1DOT\s0 org</em>&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2004 Chris Mungall</p><p>This module is free software. You may distribute this module under the same terms as perl itself</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="DBIx::ContextualFetch.3pm.html"><span aria-hidden="true">&larr;</span> DBIx::ContextualFetch.3pm: Add contextual fetches to dbi</a></li>
   <li class="next"><a href="DBIx::DBStag::Constraint.3pm.html">DBIx::DBStag::Constraint.3pm: Recursive structure for representing query constraints <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

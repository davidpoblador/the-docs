<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SQL::Parser: </title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SQL::Parser (3pm) manual">
  <meta name="twitter:description" content="">
  <meta name="twitter:image" content="https://www.carta.tech/images/libsql-statement-perl-SQL::Parser-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/SQL::Parser.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SQL::Parser (3pm) manual" />
  <meta property="og:description" content="" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libsql-statement-perl-SQL::Parser-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SQL::Parser<small> (3pm)</small></h1>
        <p class="lead"></p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/SQL::Parser.3pm.html">
      <span itemprop="name">SQL::Parser: </span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libsql-statement-perl/">
      <span itemprop="name">libsql-statement-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/SQL::Parser.3pm.html">
      <span itemprop="name">SQL::Parser: </span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p> use SQL::Parser;                                     # CREATE A PARSER OBJECT  my $parser = SQL::Parser-&gt;new();</p><p> $parser-&gt;feature( $class, $name, $value );           # SET OR FIND STATUS OF  my $has_feature = $parser-&gt;feature( $class, $name ); # A PARSER FEATURE</p><p> $parser-&gt;dialect( $dialect_name );                   # SET OR FIND STATUS OF  my $current_dialect = $parser-&gt;dialect;              # A PARSER DIALECT</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>SQL::Parser is part of the SQL::Statement distribution and, most interaction with the parser should be done through SQL::Statement. The methods shown above create and modify a parser object.  To use the parser object to parse \s-1SQL\s0 and to examine the resulting structure, you should use SQL::Statement.</p><p><strong>Important Note</strong>: Previously SQL::Parser had its own hash-based interface for parsing, but that is now deprecated and will eventually be phased out in favor of the object-oriented parsing interface of SQL::Statement.  If you are unable to transition some features to the new interface or have concerns about the phase out, please contact me. See \*(L"The Parse Structure\*(R" for details of the now-deprecated hash method if you still need them.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>\fInew()\fP</h3>
<p>Create a new parser object</p><p> use SQL::Parser;  my $parser = SQL::Parser-&gt;new();</p><p>The <em>new()</em> method creates a SQL::Parser object which can then be used to parse and validate the syntax of \s-1SQL\s0 strings. It takes two optional parameters - 1) the name of the \s-1SQL\s0 dialect that will define the syntax rules for the parser and 2) a reference to a hash which can contain additional attributes of the parser.  If no dialect is specified, 'AnyData' is the default.</p><p> use SQL::Parser;  my $parser = SQL::Parser-&gt;new( $dialect_name, &#92;%attrs );</p><p>The dialect_name parameter is a string containing any valid dialect such as '\s-1ANSI\s0', 'AnyData', or '\s-1CSV\s0'.  See the section on the <em>dialect()</em> method below for details.</p><p>The \*(C`attrs\*(C' parameter is a reference to a hash that can contain error settings for the PrintError and RaiseError attributes.</p><p>An example:</p><p>  use SQL::Parser;   my $parser = SQL::Parser-&gt;new(&apos;AnyData&apos;, {RaiseError=&gt;1} );</p><p>  This creates a new parser that uses the grammar rules   contained in the .../SQL/Dialects/AnyData.pm file and which   sets the RaiseError attribute to true.</p>
<h3>\fIdialect()\fP</h3>
<p> $parser-&gt;dialect( $dialect_name );     # load a dialect configuration file  my $dialect = $parser-&gt;dialect;        # get the name of the current dialect</p><p> For example:</p><p>   $parser-&gt;dialect(&apos;AnyData&apos;);  # loads the AnyData config file    print $parser-&gt;dialect;       # prints &apos;AnyData&apos;</p><p>The $dialect_name parameter may be the name of any dialect configuration file on your system.  Use the $parser-&gt;list('dialects') method to see a list of available dialects.  At a minimum it will include \*(L"\s-1ANSI\s0\*(R", \*(L"\s-1CSV\s0\*(R", and \*(L"AnyData\*(R".  For backwards compatibility 'Ansi' is accepted as a synonym for '\s-1ANSI\s0', otherwise the names are case sensitive.</p><p>Loading a new dialect configuration file erases all current parser features and resets them to those defined in the configuration file.</p>
<h3>\fIfeature()\fP</h3>
<p>Features define the rules to be used by a specific parser instance.  They are divided into the following classes:</p><p>    * valid_commands     * valid_options     * valid_comparison_operators     * valid_data_types     * reserved_words</p><p>Within each class a feature name is either enabled or disabled. For example, under \*(L"valid_data_types\*(R" the name \*(L"\s-1BLOB\s0\*(R" may be either disabled or enabled.  If it is not enabled (either by being specifically disabled, or simply by not being specified at all) then any \s-1SQL\s0 string using \*(L"\s-1BLOB\s0\*(R" as a data type will throw a syntax error \*(L"Invalid data type: '\s-1BLOB\s0'\*(R".</p><p>The <em>feature()</em> method allows you to enable, disable, or check the status of any feature.</p><p> $parser-&gt;feature( $class, $name, 1 );             # enable a feature</p><p> $parser-&gt;feature( $class, $name, 0 );             # disable a feature</p><p> my $feature = $parser-&gt;feature( $class, $name );  # return status of a feature</p><p> For example:</p><p> $parser-&gt;feature(&apos;reserved_words&apos;,&apos;FOO&apos;,1);       # make &apos;FOO&apos; a reserved word</p><p> $parser-&gt;feature(&apos;valid_data_types&apos;,&apos;BLOB&apos;,0);    # disallow &apos;BLOB&apos; as a                                                    # data type</p><p>                                                   # determine if the LIKE                                                    # operator is supported  my $LIKE = $parser-&gt;feature(&apos;valid_operators&apos;,&apos;LIKE&apos;);</p><p>See the section below on \*(L"Backwards Compatibility\*(R" for use of the <em>feature()</em> method with SQL::Statement 0.1x style parameters.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Supported SQL syntax</h2>
        <div class="sectioncontent">
<p>The SQL::Statement distribution can be used to either just parse \s-1SQL\s0 statements or to execute them against actual data.  A broader set of syntax is supported in the parser than in the executor.  For example the parser allows you to specify column constraints like \s-1PRIMARY\s0 \s-1KEY\s0. Currently, these are ignored by the execution engine.  Likewise syntax such as \s-1RESTRICT\s0 and \s-1CASCADE\s0 on \s-1DROP\s0 statements or \s-1LOCAL\s0 \s-1GLOBAL\s0 \s-1TEMPORARY\s0 tables in \s-1CREATE\s0 are supported by the parser but ignored by the executor.</p><p>To see the list of Supported \s-1SQL\s0 syntax formerly kept in this pod, see SQL::Statement.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Subclassing SQL::Parser</h2>
        <div class="sectioncontent">
<p>In the event you need to either extend or modify SQL::Parser's default behavior, the following methods may be overridden: Processes the \s-1BETWEEN\s0...AND... predicates; default converts to 2 range predicates. Process the \s-1IN\s0 (...list...) predicates; default converts to a series of \s-1OR\s0'd '=' predicate, or \s-1AND\s0'd '&lt;&gt;' predicates for \s-1NOT\s0 \s-1IN\s0. Abstract method; default simply returns the original string. Called after <em>repl_btwn()</em> and <em>repl_in()</em>, but before any further predicate processing is applied. Possible uses include converting other predicate syntax not recognized by SQL::Parser into user-defined functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">The parse structure</h2>
        <div class="sectioncontent">
<p>This section outlines the <strong>now-deprecated</strong> hash interface to the parsed structure.  It is included <strong>for backwards compatibility only</strong>. You should use the SQL::Statement object interface to the structure instead.  See SQL::Statement.</p><p><strong>Parse Structures</strong></p><p>Here are some further examples of the data structures returned by the <em>structure()</em> method after a call to <em>parse()</em>.  Only specific details are shown for each \s-1SQL\s0 instance, not the entire structure.</p><p><strong></strong><strong>parse()</strong><strong></strong></p><p>Once a SQL::Parser object has been created with the <em>new()</em> method, the <em>parse()</em> method can be used to parse any number of \s-1SQL\s0 strings.  It takes a single required parameter \*(-- a string containing a \s-1SQL\s0 command.  The \s-1SQL\s0 string may optionally be terminated by a semicolon.  The <em>parse()</em> method returns a true value if the parse is successful and a false value if the parse finds \s-1SQL\s0 syntax errors.</p><p>Examples:</p><p>  1) my $success = $parser-&gt;parse(&apos;SELECT * FROM foo&apos;);</p><p>  2) my $sql = &apos;SELECT * FROM foo&apos;;      my $success = $parser-&gt;parse( $sql );</p><p>  3) my $success = $parser-&gt;parse(qq!          SELECT id,phrase            FROM foo           WHERE id &lt; 7             AND phrase &lt;&gt; &apos;bar&apos;        ORDER BY phrase;    !);</p><p>  4) my $success = $parser-&gt;parse(&apos;SELECT * FRoOM foo &apos;);</p><p>In examples #1,#2, and #3, the value of $success will be true because the strings passed to the <em>parse()</em> method are valid \s-1SQL\s0 strings.</p><p>In example #4, however, the value of $success will be false because the string contains a \s-1SQL\s0 syntax error ('FRoOM' instead of '\s-1FROM\s0').</p><p>In addition to checking the return value of <em>parse()</em> with a variable like $success, you may use the PrintError and RaiseError attributes as you would in a \s-1DBI\s0 script:</p><p> * If PrintError is true, then SQL syntax errors will be sent as    warnings to STDERR (i.e. to the screen or to a file if STDERR    has been redirected).  This is set to true by default which    means that unless you specifically turn it off, all errors    will be reported.</p><p> * If RaiseError is true, then SQL syntax errors will cause the    script to die, (i.e. the script will terminate unless wrapped    in an eval).  This is set to false by default which means    that unless you specifically turn it on, scripts will    continue to operate even if there are SQL syntax errors.</p><p>Basically, you should leave PrintError on or else you will not be warned when an error occurs.  If you are simply validating a series of strings, you will want to leave RaiseError off so that the script can check all strings regardless of whether some of them contain \s-1SQL\s0 errors.  However, if you are going to try to execute the \s-1SQL\s0 or need to depend that it is correct, you should set RaiseError on so that the program will only continue to operate if all \s-1SQL\s0 strings use correct syntax.</p><p>\s-1IMPORTANT\s0 \s-1NOTE\s0 #1: The <em>parse()</em> method only checks syntax, it does \s-1NOT\s0 verify if the objects listed actually exist.  For example, given the string \*(L"\s-1SELECT\s0 model \s-1FROM\s0 cars\*(R", the <em>parse()</em> method will report that the string contains valid \s-1SQL\s0 but that will not tell you whether there actually is a table called \*(L"cars\*(R" or whether that table contains a column called 'model'. Those kinds of verifications are performed by the SQL::Statement module, not by SQL::Parser by itself.</p><p>\s-1IMPORTANT\s0 \s-1NOTE\s0 #2: The <em>parse()</em> method uses rules as defined by the selected dialect configuration file and the <em>feature()</em> method.  This means that a statement that is valid in one dialect may not be valid in another.  For example the '\s-1CSV\s0' and 'AnyData' dialects define '\s-1BLOB\s0' as a valid data type but the '\s-1ANSI\s0' dialect does not.  Therefore the statement '\s-1CREATE\s0 \s-1TABLE\s0 foo (picture \s-1BLOB\s0)' would be valid in the first two dialects but would produce a syntax error in the '\s-1ANSI\s0' dialect.</p><p><strong></strong><strong>structure()</strong><strong></strong></p><p>After a SQL::Parser object has been created and the <em>parse()</em> method used to parse a \s-1SQL\s0 string, the <em>structure()</em> method returns the data structure of that string.  This data structure may be passed on to other modules (e.g. SQL::Statement) or it may be printed out using, for example, the Data::Dumper module.</p><p>The data structure contains all of the information in the \s-1SQL\s0 string as parsed into its various components.  To take a simple example:</p><p> $parser-&gt;parse(&apos;SELECT make,model FROM cars&apos;);  use Data::Dumper;  print Dumper $parser-&gt;structure;</p><p>Would produce:</p><p> $VAR1 = {           &apos;column_defs&apos; =&gt; [                               { &apos;type&apos;  =&gt; &apos;column&apos;,                                 &apos;value&apos; =&gt; &apos;make&apos;, },                               { &apos;type&apos;  =&gt; &apos;column&apos;,                                 &apos;value&apos; =&gt; &apos;model&apos;, },                             ],           &apos;command&apos; =&gt; &apos;SELECT&apos;,           &apos;table_names&apos; =&gt; [                              &apos;cars&apos;                            ]         };</p><p> &apos;SELECT make,model, FROM cars&apos;</p><p>      command =&gt; &apos;SELECT&apos;,       table_names =&gt; [ &apos;cars&apos; ],       column_names =&gt; [ &apos;make&apos;, &apos;model&apos; ],</p><p> &apos;CREATE TABLE cars ( id INTEGER, model VARCHAR(40) )&apos;</p><p>      column_defs =&gt; {           id    =&gt; { data_type =&gt; INTEGER     },           model =&gt; { data_type =&gt; VARCHAR(40) },       },</p><p> &apos;SELECT DISTINCT make FROM cars&apos;</p><p>      set_quantifier =&gt; &apos;DISTINCT&apos;,</p><p> &apos;SELECT MAX (model) FROM cars&apos;</p><p>    set_function   =&gt; {         name =&gt; &apos;MAX&apos;,         arg  =&gt; &apos;models&apos;,     },</p><p> &apos;SELECT * FROM cars LIMIT 5,10&apos;</p><p>    limit_clause =&gt; {         offset =&gt; 5,         limit  =&gt; 10,     },</p><p> &apos;SELECT * FROM vars ORDER BY make, model DESC&apos;</p><p>    sort_spec_list =&gt; [         { make  =&gt; &apos;ASC&apos;  },         { model =&gt; &apos;DESC&apos; },     ],</p><p> "INSERT INTO cars VALUES ( 7, &apos;Chevy&apos;, &apos;Impala&apos; )"</p><p>    values =&gt; [ 7, &apos;Chevy&apos;, &apos;Impala&apos; ],</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>You can find documentation for this module with the perldoc command.</p><p>    perldoc SQL::Parser     perldoc SQL::Statement</p><p>You can also look for information at:</p><ul>
<li><p>\s-1RT:\s0 \s-1CPAN\s0's request tracker http://rt.cpan.org/NoAuth/Bugs.html?Dist=SQL-Statement &lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=SQL-Statement&gt;</p></li><li><p>AnnoCPAN: Annotated \s-1CPAN\s0 documentation http://annocpan.org/dist/SQL-Statement &lt;http://annocpan.org/dist/SQL-Statement&gt;</p></li><li><p>\s-1CPAN\s0 Ratings http://cpanratings.perl.org/s/SQL-Statement &lt;http://cpanratings.perl.org/s/SQL-Statement&gt;</p></li><li><p>Search \s-1CPAN\s0 http://search.cpan.org/dist/SQL-Statement/ &lt;http://search.cpan.org/dist/SQL-Statement/&gt;</p></li>
</ul><h3>Where can I go for help?</h3>
<p>For questions about installation or usage, please ask on the dbi-users@perl.org mailing list or post a question on PerlMonks (&lt;http://www.perlmonks.org/&gt;, where Jeff is known as jZed). Jens does not visit PerlMonks on a regular basis.</p><p>If you have a bug report, a patch or a suggestion, please open a new report ticket at \s-1CPAN\s0 (but please check previous reports first in case your issue has already been addressed). You can mail any of the module maintainers, but you are more assured of an answer by posting to the dbi-users list or reporting the issue in \s-1RT\s0.</p><p>Report tickets should contain a detailed description of the bug or enhancement request and at least an easily verifiable way of reproducing the issue or fix. Patches are always welcome, too.</p>
<h3>Where can I go for help with a concrete version?</h3>
<p>Bugs and feature requests are accepted against the latest version only. To get patches for earlier versions, you need to get an agreement with a developer of your choice - who may or not report the the issue and a suggested fix upstream (depends on the license you have chosen).</p>
<h3>Business support and maintenance</h3>
<p>For business support you can contact Jens via his \s-1CPAN\s0 email address rehsackATcpan.org. Please keep in mind that business support is neither available for free nor are you eligible to receive any support based on the license distributed with this package.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR & COPYRIGHT</h2>
        <div class="sectioncontent">
<p> This module is</p><p> copyright (c) 2001,2005 by Jeff Zucker and  copyright (c) 2008,2010 by Jens Rehsack.</p><p> All rights reserved.</p><p>The module may be freely distributed under the same terms as Perl itself using either the \*(L"\s-1GPL\s0 License\*(R" or the \*(L"Artistic License\*(R" as specified in the Perl \s-1README\s0 file.</p><p>Jeff can be reached at: jzuckerATcpan.org Jens can be reached at: rehsackATcpan.org or via dbi-devATperl.org</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SQL::Eval.3pm.html"><span aria-hidden="true">&larr;</span> SQL::Eval.3pm: Base for deriving evaluation objects for sql::statement</a></li>
   <li class="next"><a href="SQL::ReservedWords.3pm.html">SQL::ReservedWords.3pm: Reserved sql words by ansi/iso <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

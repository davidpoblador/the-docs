<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tangram::Relational::Mappings: Mapping inheritance</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Mapping inheritance">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Tangram::Relational::Mappings (3pm) manual">
  <meta name="twitter:description" content="Mapping inheritance">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtangram-perl-Tangram::Relational::Mappings-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Tangram::Relational::Mappings.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Tangram::Relational::Mappings (3pm) manual" />
  <meta property="og:description" content="Mapping inheritance" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtangram-perl-Tangram::Relational::Mappings-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Tangram::Relational::Mappings<small> (3pm)</small></h1>
        <p class="lead">Mapping inheritance</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Tangram::Relational::Mappings.3pm.html">
      <span itemprop="name">Tangram::Relational::Mappings: Mapping inheritance</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtangram-perl/">
      <span itemprop="name">libtangram-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Tangram::Relational::Mappings.3pm.html">
      <span itemprop="name">Tangram::Relational::Mappings: Mapping inheritance</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>There are many ways of representing inheritance relationships in a relational database. This document describes three popular ways and how Tangram supports them.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STRATEGIES FOR MAPPING INHERITANCE</h2>
        <div class="sectioncontent">
<p>Inheritance is a concept that has no equivalent in the relational world. However, it is possible to implement it by using strict disciplines and a combination of relational features like tables and foreign keys.</p><p>One of the paramount issues about mapping inheritance is how well the mapping supports polymorphism.  Any Object-Oriented persistence facility that deserves its name needs to allow the retrieval of all the Fruits, and return a heterogeneous collection of Apples, Oranges and Bananas.  Also, it must perform this operation in an efficient manner.  In particular, polymorphic retrieval should not cost one \s-1SELECT\s0 per retrieved object.</p><p>A secondary - yet important - issue is how well the mapping plays by the rules of orthogonal orthodoxy.</p><p>Another issue we'll examine is how well the mapping supports 'complex' queries, that is, queries that involve several objects.</p><p>Three strategies are in common use, that go by the name Vertical, Horizontal and Filtered mapping.  They all have advantages and disadvantages.</p><p>The following sections describe the three strategies in details. They make use of a simple object model to illustrate the mappings.</p>
<pre>
                          +---------------------+
                          |        Person       |
                          |      {abstract}     |
     +---------&lt;------- 1 +---------------------+
     |                    | name: string        |
     |                    +---------------------+
     |                               |
     |                               ^
     |                               |
     |            +------------------+---------------------+
     |            |                                        |
     |   +---------------+                        +-----------------+
     V   | NaturalPerson |                        |    LegalPerson  |
     |   +---------------+                        +-----------------+
     |   |  age: integer |                        | form: string    |
     |   +---------------+                        +-----------------+
     |
     |
     |
     |                    +---------------------+
     +--------&gt;-------- * |        Vehicle      |
                          |       {abstract}    |
                          +---------------------+
                          | make: string        |
                          +---------------------+
                                     |
                                     ^
                                     |
                  +------------------+-------------------+
                  |                                      |
         +---------------+                      +-----------------+
         |      Car      |                      |      Plane      |
         +---------------+                      +-----------------+
         | plate: string |                      | ident: string   |
         +---------------+                      +-----------------+
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Horizontal Mapping</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">description</h2>
        <div class="sectioncontent">
<p>Each <em>concrete</em> class is mapped onto a single table. Each row in the table describes the persistent state of one object.</p><p>The attributes are mapped onto columns, usually one column per attribute but not necessarily. For example, collections may be stored elsewhere (for example on a link table) and thus require no column on the class' table.</p><p>In effect, the database looks like this:</p><p>         +---------------+          | NaturalPerson |          +------+--------+-------+------+          |  id  |  name          | age  |          ================================          |  17  | Bill Gates     |  46  |          +------+----------------+------+          |  23  | Georges Bush   |  50  |          +------+----------------+------+</p><p>         +-------------+          | LegalPerson |          +------+------+---------+------+          |  id  |  name          | form |          ================================          |  36  |  Microsoft     |  Inc |          +------+----------------+------+</p><p>         +------+          | Car  |          +------+-------+----------------+--------+          |  id  | owner |  make          | plate  |          ==========================================          |  12  |  17   | Saab           | BILL-1 |          +------+-------+----------------+--------+          |  50  |  36   | Miata          | MS-001 |          +------+-------+----------------+--------+          |  51  |  36   | Miata          | MS-002 |          +------+-------+----------------+--------+</p><p>         +-------+          | Plane |          +------++-----+----------------+--------+          |  id  | owner|  make          | ident  |          =========================================          |  29  |  23  |  Boeing        | AF-001 |          +------+------+----------------+--------+</p><h3>advantages</h3>
<p>Polymorphic retrieval costs one \s-1SELECT\s0 per concrete conforming class; retrieving all the Persons costs two SELECTs. These SELECTs, however, don't use joins - an expensive operation. In our example, retrieving all the Persons requires the following two SELECTs:</p><p>   SELECT id, name, age FROM NaturalPerson    SELECT id, name, form FROM LegalPerson</p>
<h3>disadvantages</h3>
<p>This mapping is reasonable with regard to relational orthodoxy, but not perfect: the 'name' column is present on two different tables, with the same semantic.</p><p>The biggest drawback, however, happens when you try to perfrom complex queries.  Suppose oyu want to retrieve all the Persons (Natural- or Legal-) that own a Vehicle of make 'Saab' (be it a Car or a Plane). Sticking with equijoins, the cost of the operation is four SELECTs:</p><p>   SELECT NaturalPerson.id, NaturalPerson.name, NaturalPerson.age       FROM NaturalPerson, Car       WHERE Car.owner = NaturalPerson.id</p><p>   SELECT NaturalPerson.id, NaturalPerson.name, NaturalPerson.age       FROM NaturalPerson, Plane       WHERE Plane.owner = NaturalPerson.id</p><p>   SELECT LegalPerson.id, LegalPerson.name, LegalPerson.form       FROM LegalPerson, Car       WHERE Car.owner = LegalPerson.id</p><p>   SELECT LegalPerson.id, LegalPerson.name, LegalPerson.form       FROM LegalPerson, Plane       WHERE Plane.owner = LegalPerson.id</p><p>When the depth of the hierarchies increase, the combinatory explosion makes complex queries prohibitive.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Vertical Mapping</h2>
        <div class="sectioncontent">
<h3>description</h3>
<p>Each class has its corresponding table, which contains only the class' direct fields. In other words, the table doesn't store the inherited fields. Both concrete and abstract classes get a table. The state of an object is thus scattered over several tables.</p><p>For example:</p><p>         +--------+          | Person |          +------+-+------+-------+          |  id  |  name          |          =========================          |  17  | Bill Gates     |          +------+----------------+          |  23  | Georges Bush   |          +------+----------------+          |  36  | Microsoft      |          +------+----------------+</p><p>         +---------------+     +-------------+          | NaturalPerson |     | LegalPerson |          +------+--------+     +-------+-----++          |  id  | age    |     |  id   | form |          =================     ================          |  17  |  46    |     |  36   |  Inc |          +------+--------+     +-------+------+          |  23  |  50    |          +------+--------+</p><p>         +---------+          | Vehicle |          +------+--+----+----------------+          |  id  | owner |  make          |          =================================          |  12  | 17    | Saab           |          +------+-------+----------------+          |  29  | 23    | AF-001         |          +------+-------+----------------+          |  50  | 36    | Miata          |          +------+-------+----------------+          |  51  | 36    | Miata          |          +------+-------+----------------+</p><p>         +------+              +-------+          | Car  |              | Plane |          +------++--------+    +-------+--------+          |  id   | plate  |    |  id   | ident  |          ==================    ==================          |  12   | BILL-1 |    |  29   | AF-001 |          +-------+--------+    +-------+--------+          |  50   | MS-001 |          +-------+--------+          |  51   | MS-002 |          +-------+--------+</p><p>Polymorphic retrieval is achieved by issuing one \s-1SELECT\s0 per concrete conforming class; retrieving In our example, retrieving all the Persons requires the following two SELECTs:</p><p>   SELECT Person.id, Person.name, NaturalPerson.age       FROM Person, NaturalPerson       WHERE Person.id = NaturalPerson.id</p><p>   SELECT Person.id, Person.name, LegalPerson.form       FROM Person, LegalPerson       WHERE Person.id = LegalPerson.id</p><p>This mapping sometimes needs an extra column that carries a type identifier. In our example, we take the very resonable assumption that Person is an abstract class. Had we decided to allow 'pure' Persons, we would have been faced with the following problem: the Person table would contain rows that describe pure Persons, but also rows that describe the Person part of Natural- and LegalPersons. We would need to filter those incomplete objects out when retrieving the pure Persons. Thus the Person table would look like this:</p><p>         +--------+          | Person |          +-----+--+---+----------------+          | id  | type |  name          |          ===============================          | 13  | 1    | Pure Person    |          +-----+------+----------------+          | 17  | 2    | Bill Gates     |          +-----+------+----------------+          | 23  | 2    | Georges Bush   |          +-----+------+----------------+          | 36  | 3    | Microsoft      |          +-----+------+----------------+</p><p>In this case, we need an extra \s-1SELECT\s0 for retrieving pure Persons:</p><p>   SELECT Person.id, Person.name       FROM Person       WHERE Person.type IN (1)</p>
<h3>advantages</h3>
<p>From the relational point of view, this mapping is excellent: the resulting database is in third normal form.</p><p>This mapping also supports complex queries very well. Take the Saab owners example again: we don't need to involve the Car nor Plane tables in the query. As a result, two SELECTs suffice:</p><p>   SELECT Person.id, Person.name, NaturalPerson.age       FROM Person, NaturalPerson, Vehicle       WHERE Person.id = NaturalPerson.id AND Vehicle.owner = Person.id</p><p>   SELECT Person.id, Person.name, LegalPerson.form       FROM Person, LegalPerson, Vehicle       WHERE Person.id = LegalPerson.id AND Vehicle.owner = Person.id</p>
<h3>disadvantages</h3>
<p>The mapping potentially has the highest performance cost: it requires multiple SELECTs like the horizontal mapping, but in addition, these SELECTs use joins.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Filtered Mapping</h2>
        <div class="sectioncontent">
<h3>description</h3>
<p>Entire hierarchies are mapped onto a single table. Two rows may describe objects of different types, maybe completely unrelated. The set of columns is the uperset of all the columns needed by all the attributes of any of the classes involved in the mapping.</p><p>A special 'type' column contains an value that uniquely identifies the concrete class of the object described by the row.</p><p>All the columns related to attributes that don't occur in all the classes must be declared as \s-1NULLABLE\s0. Indeed, the table may contain mostly \s-1NULL\s0 values.</p><p>In our example, the database may look either like this:</p><p>         +---------+          | Persons |          +-----+---+--+----------------+------+------+          | id  | type |  name          | age  | form |          =============================================          | 17  |  1   | Bill Gates     |  46  | NULL |          +-----+------+----------------+------+------+          | 23  |  1   | Georges Bush   |  50  | NULL |          +-----+------+----------------+------+------+          | 36  |  2   | Microsoft      | NULL |  Inc |          +-----+------+----------------+------+------+</p><p>         +---------+          | Persons |          +-----+---+--+----------------+------+------+          | id  | type |  name          | age  | form |          =============================================          | 17  |  1   | Bill Gates     |  46  | NULL |          +-----+------+----------------+------+------+          | 23  |  1   | Georges Bush   |  50  | NULL |          +-----+------+----------------+------+------+          | 36  |  2   | Microsoft      | NULL |  Inc |          +-----+------+----------------+------+------+          | 36  |  2   | Microsoft      | NULL |  Inc |          +-----+------+----------------+------+------+</p><p>         +----------+          | Vehicles |          +-----+----+-+-------+----------------+--------+--------+          | id  | type | owner |  make          | plate  | ident  |          =========================================================          | 12  |  3   |  17   | Saab           | BILL-1 | NULL   |          +-----+------+-------+----------------+--------+--------+          | 29  |  4   |  23   | Boeing         | NULL   | AF-001 |          +-----+------+-------+----------------+--------+--------+          | 50  |  3   |  36   | Miata          | MS-001 | NULL   |          +-----+------+-------+----------------+--------+--------+          | 51  |  3   |  36   | Miata          | MS-002 | NULL   |          +-----+------+-------+----------------+--------+--------+</p><p>Retrieving all the Persons requires only one \s-1SELECT:\s0</p><p>   SELECT id, name, age, form FROM Persons</p><p>When retrieving NaturalPersons we must take care to filter out the rows that belog to LegalPersons:</p><p>   SELECT id, name, age FROM Persons WHERE type = 1</p><p>We may even decide to place unrelated hierarchies on the same table:</p><p>   +---------+    | Objects |    +-----+---+--+---------------+------+------+--------+--------+--------+    | id  | type |  name         | age  | form | make   | plate  | ident  |    =======================================================================    | 17  |  1   | Bill Gates    |  46  | NULL | NULL   | NULL   | NULL   |    +-----+------+---------------+------+------+--------+--------+--------+    | 23  |  1   | Georges Bush  |  50  | NULL | NULL   | NULL   | NULL   |    +-----+------+---------------+------+------+--------+--------+--------+    | 36  |  2   | Microsoft     | NULL | Inc  | NULL   | NULL   | NULL   |    +-----+------+---------------+------+------+--------+--------+--------+    | 12  |  3   | NULL          | NULL | NULL | Saab   | BILL-1 | NULL   |    +-----+------+---------------+------+------+--------+--------+--------+    | 29  |  4   | NULL          | NULL | NULL | Boeing | NULL   | AF-001 |    +-----+------+---------------+------+------+--------+--------+--------+    | 50  |  3   | NULL          | NULL | NULL | Miata  | MS-001 | NULL   |    +-----+------+---------------+------+------+--------+--------+--------+    | 51  |  3   | NULL          | NULL | NULL | Miata  | MS-002 | NULL   |    +-----+------+---------------+------+------+--------+--------+--------+</p>
<h3>advantages</h3>
<p>Polymorphic retrieval costs exactly one \s-1SELECT\s0, regardless of the number of conforming types. Thus this mapping potentially is the most efficient.</p>
<h3>disadvantages</h3>
<p>This mapping is very questionable according to relational orthodoxy. Even if one decides to forgo these rules, using such a mapping takes away many of the interesting features offered by modern \s-1RDBM\s0 systems. Because nearly all the columns must allow \s-1NULL\s0 values, we cannot take advantage of features like referential integrity constraints, domain constraints, indexes, etc.</p><p>Also, as the table becomes cluttered with \s-1NULL\s0 values, the relative number of significant columns in any given row tends towards zero: we may end up retrieving rows consisting of a little information swimming in a sea of NULLs.</p><p>In effect, this mapping may end up hindering performance instead of improving it in presence of deep hierarchies with many attributes.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAPPINGS SUPPORTED BY TANGRAM</h2>
        <div class="sectioncontent">
<p>Tangram supports both vertical mapping and filtered mapping, and any hybrid of the two.</p><p>The 'table' attribute in the class description in the Schema can be used to put the state of several classes on the same table. The table name defaults to the class name, resulting in a vertical mapping.</p><p>For example, the following schema:</p><p>   Tangram::Relational-&gt;schema( {         classes =&gt;           [ Person =&gt;             {              table =&gt; &apos;Persons&apos;,              fields =&gt; { string =&gt; [ qw( name ) ] }             },</p><p>            NaturalPerson =&gt;             {              table =&gt; &apos;Persons&apos;,              fields =&gt; { int =&gt; [ qw( age ) ] }             },</p><p>            LegalPerson =&gt;             {              table =&gt; &apos;Persons&apos;,              fields =&gt; { string =&gt; [ qw( form ) ] }             }           ] } );</p><p>...specifies a pure filtered mapping for the Person hierarchy:</p><p>   CREATE TABLE Persons    (      id INTEGER NOT NULL,      PRIMARY KEY( id ),      type INTEGER NOT NULL,      form VARCHAR(255) NULL,      age INT NULL,      name VARCHAR(255) NULL    );</p><p>The following schema:</p><p>   Tangram::Relational-&gt;schema( {         classes =&gt;           [ Person =&gt;             {              table =&gt; &apos;Person&apos;,              fields =&gt; { string =&gt; [ qw( name ) ] }             },</p><p>            NaturalPerson =&gt;             {              table =&gt; &apos;NaturalPerson&apos;,              fields =&gt; { int =&gt; [ qw( age ) ] }             },</p><p>            LegalPerson =&gt;             {              table =&gt; &apos;Person&apos;,              fields =&gt; { string =&gt; [ qw( form ) ] }             }           ] } );</p><p>...gives NaturalPerson its own table, but LegalPerson shares the Person table:</p><p>   CREATE TABLE Person    (      id INTEGER NOT NULL,      PRIMARY KEY( id ),      type INTEGER NOT NULL,      form VARCHAR(255) NULL,      name VARCHAR(255) NULL    );</p><p>   CREATE TABLE NaturalPerson    (      id INTEGER NOT NULL,      PRIMARY KEY( id ),      type INTEGER NOT NULL,      age INT NULL    );</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Tangram::Relational.3pm.html"><span aria-hidden="true">&larr;</span> Tangram::Relational.3pm: Orthogonal object persistence in relational databases</a></li>
   <li class="next"><a href="Tangram::Remote.3pm.html">Tangram::Remote.3pm: Represent persistent objects in client space <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

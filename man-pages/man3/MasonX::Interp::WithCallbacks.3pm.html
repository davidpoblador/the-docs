<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MasonX::Interp::WithCallbacks: Mason callback support via params::callbackrequest.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Mason callback support via params::callbackrequest.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="MasonX::Interp::WithCallbacks (3pm) manual">
  <meta name="twitter:description" content="Mason callback support via params::callbackrequest.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmasonx-interp-withcallbacks-perl-MasonX::Interp::WithCallbacks-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/MasonX::Interp::WithCallbacks.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="MasonX::Interp::WithCallbacks (3pm) manual" />
  <meta property="og:description" content="Mason callback support via params::callbackrequest." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmasonx-interp-withcallbacks-perl-MasonX::Interp::WithCallbacks-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">MasonX::Interp::WithCallbacks<small> (3pm)</small></h1>
        <p class="lead">Mason callback support via params::callbackrequest.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/MasonX::Interp::WithCallbacks.3pm.html">
      <span itemprop="name">MasonX::Interp::WithCallbacks: Mason callback support via params::callbackrequest.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmasonx-interp-withcallbacks-perl/">
      <span itemprop="name">libmasonx-interp-withcallbacks-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/MasonX::Interp::WithCallbacks.3pm.html">
      <span itemprop="name">MasonX::Interp::WithCallbacks: Mason callback support via params::callbackrequest.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>In your Mason component:</p>
<pre>
  % if (exists $ARGS{answer}) {
  &lt;p&gt;&lt;b&gt;Answer: &lt;% $ARGS{answer} %&gt;&lt;/b&gt;&lt;/p&gt;
  % } else {
  &lt;form&gt;
    &lt;p&gt;Enter an epoch time: &lt;input type="text" name="epoch_time" /&gt;&lt;br /&gt;
      &lt;input type="submit" name="myCallbacker|calc_time_cb" value="Calculate" /&gt;
    &lt;/p&gt;
  &lt;/form&gt;
  % }
</pre>
<p>In <em>handler.pl</em>:</p><p>  use strict;   use MasonX::Interp::WithCallbacks;</p><p>  sub calc_time {       my $cb = shift;       my $params = $cb-&gt;params;       my $val = $cb-&gt;value;       $params-&gt;{answer} = localtime($val || time);   }</p><p>  my $ah = HTML::Mason::ApacheHandler-&gt;new     ( interp_class =&gt; &apos;MasonX::Interp::WithCallbacks&apos;,       callbacks =&gt; [ { cb_key  =&gt; &apos;calc_time&apos;,                        pkg_key =&gt; &apos;myCallbacker&apos;,                        cb      =&gt; &#92;&calc_time } ]     );</p><p>  sub handler {       my $r = shift;       $ah-&gt;handle_request($r);   }</p><p>Or, in a subclass of Params::Callback:</p><p>  package MyApp::CallbackHandler;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;myCallbacker&apos; );</p><p>  sub calc_time : Callback {       my $self = shift;       my $params = $self-&gt;params;       my $val = $cb-&gt;value;       $params-&gt;{answer} = localtime($val || time);   }</p><p>And then, in <em>handler.pl</em>:</p><p>  # Load order is important here!   use MyApp::CallbackHandler;   use MasonX::Interp::WithCallbacks;</p><p>  my $ah = HTML::Mason::ApacheHandler-&gt;new     ( interp_class =&gt; &apos;MasonX::Interp::WithCallbacks&apos;,       cb_classes =&gt; [qw(myCallbacker)] );</p><p>  sub handler {       my $r = shift;       $ah-&gt;handle_request($r);   }</p><p>Or, just use MasonX::Interp::WithCallbacks directly:</p><p>  use MyApp::CallbackHandler;   use MasonX::Interp::WithCallbacks;   my $interp = MasonX::Interp::WithCallbacks-&gt;new     ( cb_classes =&gt; [qw(myCallbacker)] );   $interp-&gt;exec($comp, %args);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>MasonX::Interp::WithCallbacks subclasses HTML::Mason::Interp in order to provide a Mason callback system built on Params::CallbackRequest. Callbacks may be either code references provided to the \*(C`new()\*(C' constructor, or methods defined in subclasses of Params::Callback. Callbacks are triggered either for every request or by specially named keys in the Mason request arguments, and all callbacks are executed at the beginning of a request, just before Mason creates and executes the request component stack.</p><p>This module brings support for a sort of plugin architecture based on Params::CallbackRequest to Mason. Mason then executes code before executing any components. This approach allows you to carry out logical processing of data submitted from a form, to affect the contents of the Mason request arguments (and thus the %ARGS hash in components), and even to redirect or abort the request before Mason handles it.</p><p>Much of the documentation here is based on that in Params::CallbackRequest, although it prefers using \s-1HTML\s0 form fields for its examples rather than Perl hashes. But see the Params::CallbackRequest documentation for the latest on its interface.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">JUSTIFICATION</h2>
        <div class="sectioncontent">
<p>Why would you want to do this? Well, there are a number of reasons. Some I can think of offhand include:</p>
<dl class='dl-vertical'>
  <dt>
    Stricter separation of logic from presentation
  </dt>
  <dd>
    <p>Most application logic handled in Mason components takes place in \*(C`&lt;%init&gt;\*(C' blocks, often in the same component as presentation logic. By moving the application logic into Perl modules and then directing Mason to execute that code as callbacks, you obviously benefit from a cleaner separation of application logic and presentation.</p>
  </dd>
  <dt>
    Widgitization
  </dt>
  <dd>
    <p>Thanks to their ability to preprocess arguments, callbacks enable developers to develop easier-to-use, more dynamic widgets that can then be used in any and all Mason component, or even with other templating systems. For example, a widget that puts many related fields into a form (such as a date selection widget) can have its fields preprocessed by a callback (for example, to properly combine the fields into a unified date field) before the Mason component that responds to the form submission gets the data. See Params::Callback for an example solution for this very problem.</p>
  </dd>
  <dt>
    Shared Memory
  </dt>
  <dd>
    <p>Callbacks are just Perl subroutines in modules, and are therefore loaded at server startup time in a mod_perl environment. Thus the memory they consume is all in the Apache parent process, and shared by the child processes. For code that executes frequently, this can be much less resource-intensive than code in Mason components, since components are loaded separately in each Apache child process (unless they're preloaded via the \*(C`preloads\*(C' parameter to the HTML::Mason::Interp constructor).</p>
  </dd>
  <dt>
    Performance
  </dt>
  <dd>
    <p>Since they're executed before Mason creates a component stack and executes the components, callbacks have the opportunity to short-circuit the Mason processing by doing something else. A good example is redirection. Often the application logic in callbacks does its thing and then redirects the user to a different page. Executing the redirection in a callback eliminates a lot of extraneous processing that would otherwise be executed before the redirection, creating a snappier response for the user.</p>
  </dd>
  <dt>
    Testing
  </dt>
  <dd>
    <p>Mason components are not easy to test via a testing framework such as Test::Harness. Subroutines in modules, on the other hand, are fully testable. This means that you can write tests in your application test suite to test your callback subroutines.</p>
  </dd>

</dl>
<p>And if those aren't enough reasons, then just consider this: Callbacks are just <em>way cool.</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>MasonX::Interp::WithCallbacks uses Params::CallbackRequest for its callback architecture, and therefore supports its two different types of callbacks: those triggered by a specially named key in the Mason request arguments hash, and those executed for every request.</p><h3>Argument-Triggered Callbacks</h3>
<p>Argument-triggered callbacks are triggered by specially named request argument keys. These keys are constructed as follows: The package name followed by a pipe character (\*(L"|\*(R"), the callback key with the string \*(L"_cb\*(R" appended to it, and finally an optional priority number at the end. For example, if you specified a callback with the callback key \*(L"save\*(R" and the package key \*(L"world\*(R", a callback field might be added to an \s-1HTML\s0 form like this:</p><p>  &lt;input type="button" value="Save World" name="world|save_cb" /&gt;</p><p>This field, when submitted to the Mason server, would trigger the callback associated with the \*(L"save\*(R" callback key in the \*(L"world\*(R" package. If such a callback hasn't been configured, then Params::CallbackRequest will throw a Params::CallbackReuest::Exception::InvalidKey exception. Here's how to configure a functional callback when constructing your MasonX::Interp::WithCallbacks object so that that doesn't happen:</p><p>  my $interp = MasonX::Interp::WithCallbacks-&gt;new     ( callbacks =&gt; [ { pkg_key =&gt; &apos;world&apos;,                        cb_key  =&gt; &apos;save&apos;,                        cb      =&gt; &#92;&My::World::save } ] );</p><p>With this configuration, the request argument created by the above \s-1HTML\s0 form field will trigger the execution of the &My::World::save subroutine.</p><p><em>Functional Callback Subroutines</em></p><p>Functional callbacks use a code reference for argument-triggered callbacks, and Params::CallbackRequest executes them with a single argument, a Params::Callback object. Thus, a callback subroutine will generally look something like this:</p><p>  sub foo {       my $cb = shift;       # Do stuff.   }</p><p>The Params::Callback object provides accessors to data relevant to the callback, including the callback key, the package key, and the request arguments (or parameters). It also includes \*(C`redirect()\*(C' and \*(C`abort()\*(C' methods. See the Params::Callback documentation for all the goodies.</p><p>Note that all callbacks are executed in a \*(C`eval {}\*(C' block, so if any of your callback subroutines \*(C`die\*(C', Params::CallbackRequest will throw an Params::CallbackRequest::Exception::Execution exception If you don't like this, use the \*(C`cb_exception_handler\*(C' parameter to \*(C`new()\*(C' to install your own exception handler.</p><p><em>Object-Oriented Callback Methods</em></p><p>Object-oriented callback methods are defined in subclasses of Params::Callback. Unlike functional callbacks, they are not called with a Params::Callback object, but with an instance of the callback subclass. These classes inherit all the goodies provided by Params::Callback, so you can essentially use their instances exactly as you would use the Params::Callback object in functional callback subroutines. But because they're subclasses, you can add your own methods and attributes. See Params::Callback for all the gory details on subclassing, along with a few examples. Generally, callback methods will look like this:</p><p>  sub foo : Callback {       my $self = shift;       # Do stuff.   }</p><p>As with functional callback subroutines, method callbacks are executed in a \*(C`eval {}\*(C' block. Again, see the \*(C`cb_exception_handler\*(C' parameter to install your own exception handler.</p><p><strong>Note:</strong> It's important that you \*(C`use\*(C' any and all MasonX::Callback subclasses <em>before</em> you \*(C`use MasonX::Interp::WithCallbacks\*(C' or \*(C`use Params::CallbackRequest\*(C'. This is to get around an issue with identifying the names of the callback methods in mod_perl. Read the comments in the MasonX::Callback source code if you're interested in learning more.</p><p><em>The Package Key</em></p><p>The use of the package key is a convenience so that a system with many functional callbacks can use callbacks with the same keys but in different packages. The idea is that the package key will uniquely identify the module in which each callback subroutine is found, but it doesn't necessarily have to be so. Use the package key any way you wish, or not at all:</p><p>  my $interp = MasonX::Interp::WithCallbacks-&gt;new     ( callbacks =&gt; [ { cb_key  =&gt; &apos;save&apos;,                        cb      =&gt; &#92;&My::World::save } ] );</p><p>But note that if you don't use the package key at all, you'll still need to provide one in the parameters to be submitted to \*(C`exec()\*(C' By default, that key is \*(L"\s-1DEFAULT\s0\*(R". Such a callback field in an \s-1HTML\s0 form would then look like this:</p><p>  &lt;input type="button" value="Save World" name="DEFAULT|save_cb" /&gt;</p><p>If you don't like the \*(L"\s-1DEFAULT\s0\*(R" package name, you can set an alternative default using the \*(C`default_pkg_name\*(C' parameter to \*(C`new()\*(C':</p><p>  my $interp = MasonX::Interp::WithCallbacks-&gt;new     ( callbacks        =&gt; [ { cb_key  =&gt; &apos;save&apos;,                               cb      =&gt; &#92;&My::World::save } ],       default_pkg_name =&gt; &apos;MyPkg&apos; );</p><p>Then, of course, any callbacks without a specified package key of their own will then use the custom default:</p><p>  &lt;input type="button" value="Save World" name="MyPkg|save_cb" /&gt;</p><p><em>The Class Key</em></p><p>The class key is essentially a synonym for the package key, but applies more directly to object-oriented callbacks. The difference is mainly that it corresponds to an actual class, and that all Params::Callback subclasses are <em>required</em> to have a class key; it's not optional as it is with functional callbacks. The class key may be declared in your Params::Callback subclass like so:</p><p>  package MyApp::CallbackHandler;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;MyCBHandler&apos; );</p><p>The class key can also be declared by implementing a \*(C`CLASS_KEY()\*(C' method, like so:</p><p>  package MyApp::CallbackHandler;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass;   use constant CLASS_KEY =&gt; &apos;MyCBHandler&apos;;</p><p>If no class key is explicitly defined, Params::Callback will use the subclass name, instead. In any event, the \*(C`register_callback()\*(C' method <strong>must</strong> be called to register the subclass with Params::Callback. See the Params::Callback documentation for complete details.</p><p><em>Priority</em></p><p>Sometimes one callback is more important than another. For example, you might rely on the execution of one callback to set up variables needed by another. Since you can't rely on the order in which callbacks are executed (the Mason request arguments are stored in a hash, and the processing of a hash is, of course, unordered), you need a method of ensuring that the setup callback executes first.</p><p>In such a case, you can set a higher priority level for the setup callback than for callbacks that depend on it. For functional callbacks, you can do it like this:</p><p>  my $interp = MasonX::Interp::WithCallbacks-&gt;new     ( callbacks        =&gt; [ { cb_key   =&gt; &apos;setup&apos;,                               priority =&gt; 3,                               cb       =&gt; &#92;&setup },                             { cb_key   =&gt; &apos;save&apos;,                               cb       =&gt; &#92;&save }                           ] );</p><p>For object-oriented callbacks, you can define the priority right in the callback method declaration:</p><p>  sub setup : Callback( priority =&gt; 3 ) {       my $self = shift;       # ...   }</p><p>  sub save : Callback {       my $self = shift;       # ...   }</p><p>In these examples, the \*(L"setup\*(R" callback has been configured with a priority level of \*(L"3\*(R". This ensures that it will always execute before the \*(L"save\*(R" callback, which has the default priority of \*(L"5\*(R". This is true regardless of the order of the fields in the corresponding HTML::Form:</p><p>  &lt;input type="button" value="Save World" name="DEFAULT|save_cb" /&gt;   &lt;input type="hidden" name="DEFAULT|setup_cb" value="1" /&gt;</p><p>Despite the fact that the \*(L"setup\*(R" callback field appears after the \*(L"save\*(R" field (and will generally be submitted by the browser in that order), the \*(L"setup\*(R" callback will always execute first because of its higher priority.</p><p>Although the \*(L"save\*(R" callback got the default priority of \*(L"5\*(R", this too can be customized to a different priority level via the \*(C`default_priority\*(C' parameter to \*(C`new()\*(C' for functional callbacks and the \*(C`default_priority\*(C' to the class declaration for object-oriented callbacks For example, this functional callback configuration:</p><p>  my $interp = MasonX::Interp::WithCallbacks-&gt;new     ( callbacks        =&gt; [ { cb_key   =&gt; &apos;setup&apos;,                               priority =&gt; 3,                               cb       =&gt; &#92;&setup },                             { cb_key   =&gt; &apos;save&apos;,                               cb       =&gt; &#92;&save }                           ],       default_priority =&gt; 2 );</p><p>And this Params::Callback subclass declaration:</p><p>  package MyApp::CallbackHandler;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;MyCBHandler&apos;,                                   default_priority =&gt; 2 );</p><p>Will cause the \*(L"save\*(R" callback to always execute before the \*(L"setup\*(R" callback, since its priority level will default to \*(L"2\*(R".</p><p>In addition, the priority level can be overridden via the form submission field itself by appending a priority level to the end of the callback field name. Hence, this example:</p><p>  &lt;input type="button" value="Save World" name="DEFAULT|save_cb2" /&gt;   &lt;input type="hidden" name="DEFAULT|setup_cb" value="1" /&gt;</p><p>Causes the \*(L"save\*(R" callback to execute before the \*(L"setup\*(R" callback by overriding the \*(L"save\*(R" callback's priority to level \*(L"2\*(R". Of course, any other form field that triggers the \*(L"save\*(R" callback without a priority override will still execute \*(L"save\*(R" at its configured level.</p>
<h3>Request Callbacks</h3>
<p>Request callbacks come in two separate flavors: those that execute before the argument-triggered callbacks, and those that execute after the argument-triggered callbacks. All of them execute before the Mason component stack executes. Functional request callbacks may be specified via the \*(C`pre_callbacks\*(C' and \*(C`post_callbacks\*(C' parameters to \*(C`new()\*(C', respectively:</p><p>  my $interp = MasonX::Interp::WithCallbacks-&gt;new     ( pre_callbacks  =&gt; [ &#92;&translate, &#92;&foobarate ],       post_callbacks =&gt; [ &#92;&escape, &#92;&negate ] );</p><p>Object-oriented request callbacks may be declared via the \*(C`PreCallback\*(C' and \*(C`PostCallback\*(C' method attributes, like so:</p><p>  sub translate : PreCallback { ... }   sub foobarate : PreCallback { ... }   sub escape : PostCallback { ... }   sub negate : PostCallback { ... }</p><p>In these examples, the \*(C`translate()\*(C' and \*(C`foobarate()\*(C' subroutines or methods will execute (in that order) before any argument-triggered callbacks are executed (none will be in these examples, since none are specified).</p><p>Conversely, the \*(C`escape()\*(C' and \*(C`negate()\*(C' subroutines or methods will be executed (in that order) after all argument-triggered callbacks have been executed. And regardless of what argument-triggered callbacks may be triggered, the request callbacks will always be executed for <em>every</em> request.</p><p>Although they may be used for different purposes, the \*(C`pre_callbacks\*(C' and \*(C`post_callbacks\*(C' functional callback code references expect the same argument as argument-triggered functional callbacks: a Params::Callback object:</p><p>  sub foo {       my $cb = shift;       # Do your business here.   }</p><p>Similarly, object-oriented request callback methods will be passed an object of the class defined in the class key portion of the callback trigger \*(-- either an object of the class in which the callback is defined, or an object of a subclass:</p><p>  sub foo : PostCallback {       my $self = shift;       # ...   }</p><p>Of course, the attributes of the Params::Callback or subclass object will be different than in argument-triggered callbacks. For example, the \*(C`priority\*(C', \*(C`pkg_key\*(C', and \*(C`cb_key\*(C' attributes will naturally be undefined. It will, however, be the same instance of the object passed to all other functional callbacks \*(-- or to all other class callbacks with the same class key \*(-- in a single request.</p><p>Like the argument-triggered callbacks, request callbacks are executed in a \*(C`eval {}\*(C' block, so if any of them \*(C`die\*(C's, an Params::CallbackRequest::Exception::Execution exception will be thrown. Use the \*(C`cb_exception_handler\*(C' parameter to \*(C`new()\*(C' if you don't like this.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<p>In addition to those offered by the HTML::Mason::Interp base class, this module supports a number of its own parameters to the \*(C`new()\*(C' constructor based on those required by Params::CallbackRequest. Each also has a corresponding <em>httpd.conf</em> variable as well, so, if you really want to, you can use MasonX::Interp::WithCallbacks right in your <em>httpd.conf</em> file:</p><p>  PerlModule MasonX::Interp::WithCallbacks   PerlSetVar MasonInterpClass MasonX::Interp::WithCallbacks   SetHandler perl-script   PerlHandler HTML::Mason::ApacheHandler</p><p>The parameters to \*(C`new()\*(C' and their corresponding <em>httpd.conf</em> variables are as follows: Argument-triggered functional callbacks are configured via the \*(C`callbacks\*(C' parameter. This parameter is an array reference of hash references, and each hash reference specifies a single callback. The supported keys in the callback specification hashes are:</p><p>Required. A string that, when found in a properly-formatted Mason request argument key, will trigger the execution of the callback. Required. A reference to the Perl subroutine that will be executed when the \*(C`cb_key\*(C' has been found in a Mason request argument key. Each code reference should expect a single argument: a Params::Callback object. The same instance of a Params::Callback object will be used for all functional callbacks in a single request. Optional. A key to uniquely identify the package in which the callback subroutine is found. This parameter is useful in systems with many callbacks, where developers may wish to use the same \*(C`cb_key\*(C' for different subroutines in different packages. The default package key may be set via the \*(C`default_pkg_key\*(C' parameter. Optional. Indicates the level of priority of a callback. Some callbacks are more important than others, and should be executed before the others. Params::CallbackRequest supports priority levels ranging from \*(L"0\*(R" (highest priority) to \*(L"9\*(R" (lowest priority). The default priority for functional callbacks may be set via the \*(C`default_priority\*(C' parameter.</p><p>The &lt;callbacks&gt; parameter can also be specified via the <em>httpd.conf</em> configuration variable \*(C`MasonCallbacks\*(C'. Use \*(C`PerlSetVar\*(C' to specify several callbacks; each one should be an \*(C`eval\*(C'able string that converts into a hash reference as specified here. For example, to specify two callbacks, use this syntax:   PerlAddVar MasonCallbacks "{ cb_key  =&gt; &apos;foo&apos;, cb =&gt; sub { ... }"   PerlAddVar MasonCallbacks "{ cb_key  =&gt; &apos;bar&apos;, cb =&gt; sub { ... }" Note that the \*(C`eval\*(C'able string must be entirely on its own line in the <em>httpd.conf</em> file.</p><p>This parameter accepts an array reference of code references that should be executed for <em>every</em> request <em>before</em> any other callbacks. They will be executed in the order in which they're listed in the array reference. Each code reference should expect a single Params::Callback argument. The same instance of a Params::Callback object will be used for all functional callbacks in a single request. Use pre-argument-triggered request callbacks when you want to do something with the arguments submitted for every request, such as convert character sets. The &lt;pre_callbacks&gt; parameter can also be specified via the <em>httpd.conf</em> configuration variable \*(C`MasonPreCallbacks\*(C'. Use multiple \*(C`PerlAddVar\*(C' to add multiple pre-request callbacks; each one should be an \*(C`eval\*(C'able string that converts into a code reference:   PerlAddVar MasonPreCallbacks "sub { ... }"   PerlAddVar MasonPreCallbacks "sub { ... }" This parameter accepts an array reference of code references that should be executed for <em>every</em> request <em>after</em> all other callbacks have been called. They will be executed in the order in which they're listed in the array reference. Each code reference should expect a single Params::Callback argument. The same instance of a Params::Callback object will be used for all functional callbacks in a single request. Use post-argument-triggered request callbacks when you want to do something with the arguments submitted for every request, such as HTML-escape their values. The &lt;post_callbacks&gt; parameter can also be specified via the <em>httpd.conf</em> configuration variable \*(C`MasonPostCallbacks\*(C'. Use multiple \*(C`PerlAddVar\*(C' to add multiple post-request callbacks; each one should be an \*(C`eval\*(C'able string that converts into a code reference:   PerlAddVar MasonPostCallbacks "sub { ... }"   PerlAddVar MasonPostCallbacks "sub { ... }" An array reference listing the class keys of all of the Params::Callback subclasses containing callback methods that you want included in your MasonX::Interp::WithCallbacks object. Alternatively, the \*(C`cb_classes\*(C' parameter may simply be the word \*(L"\s-1ALL\s0\*(R", in which case <em>all</em> Params::Callback subclasses will have their callback methods registered with your MasonX::Interp::WithCallbacks object. See the Params::Callback documentation for details on creating callback classes and methods. <strong>Note:</strong> Be sure to \*(C`use MasonX::Interp::WithCallbacks\*(C' or \*(C`use Params::CallbackRequest\*(C' <em>only</em> after you've \*(C`use\*(C'd all of the Params::Callback subclasses you need or else you won't be able to use their callback methods. The &lt;cb_classes&gt; parameter can also be specified via the <em>httpd.conf</em> configuration variable \*(C`MasonCbClasses\*(C'. Use multiple \*(C`PerlAddVar\*(C' to add multiple callback class keys. But, again, be sure to load MasonX::Interp::WithCallbacks or Params::CallbackRequest <em>only</em> after you've loaded all of your MasonX::Callback handler subclasses:   PerlModule My::CBClass   PerlModule Your::CBClass   PerlSetVar MasonCbClasses myCBClass   PerlAddVar MasonCbClasses yourCBClass   # Load MasonX::Interp::WithCallbacks last!   PerlModule MasonX::Interp::WithCallbacks The priority level at which functional callbacks will be executed. Does not apply to object-oriented callbacks. This value will be used in each hash reference passed via the \*(C`callbacks\*(C' parameter to \*(C`new()\*(C' that lacks a \*(C`priority\*(C' key. You may specify a default priority level within the range of \*(L"0\*(R" (highest priority) to \*(L"9\*(R" (lowest priority). If not specified, it defaults to \*(L"5\*(R". Use the \*(C`MasonDefaultPriority\*(C' variable to set the the \*(C`default_priority\*(C' parameter in your <em>httpd.conf</em> file:   PerlSetVar MasonDefaultPriority 3 The default package key for functional callbacks. Does not apply to object-oriented callbacks. This value that will be used in each hash reference passed via the \*(C`callbacks\*(C' parameter to \*(C`new()\*(C' that lacks a \*(C`pkg_key\*(C' key. It can be any string that evaluates to a true value, and defaults to \*(L"\s-1DEFAULT\s0\*(R" if not specified. Use the \*(C`MasonDefaultPkgKey\*(C' variable to set the the \*(C`default_pkg_key\*(C' parameter in your <em>httpd.conf</em> file:   PerlSetVar MasonDefaultPkgKey CBFoo By default, Params::CallbackRequest will execute all request callbacks. However, in many situations it may be desirable to skip any callbacks that have no value for the callback field. One can do this by simply checking \*(C`$cb-&gt;value\*(C' in the callback, but if you need to disable the execution of all callbacks, pass the \*(C`ignore_nulls\*(C' parameter with a true value. It is set to a false value by default. Use the \*(C`MasonIgnoreNulls\*(C' variable to set the the \*(C`ignore_nulls\*(C' parameter in your <em>httpd.conf</em> file:   PerlSetVar MasonIgnoreNulls 1 When Params::CallbackRequest encounters an exception during the execution of callbacks, it normally calls \*(C`Params::CallbackRequest::Exceptions::rethrow_exception\*(C' to handle the exception. But if you throw your own exceptions in your callbacks, and want to handle them differently (say, to handle them and then let the request continue), pass the \*(C`cb_exception_handler\*(C' parameter a code reference to do what you need. Use the \*(C`MasonCbExceptionHandler\*(C' variable to set the \*(C`cb_exception_handler\*(C' parameter in your <em>httpd.conf</em> file:   MasonCbExceptionHandler "sub {...}" <strong>Note:</strong> This is the only parameter that differs in name from the same parameter to \*(C`Params::CallbackRequest-&gt;new\*(C'. This is so that it can be easily distinguished from the possible addition of a \*(C`exception_handler\*(C' parameter to a future version of Mason.</p><h3>Accessor Methods</h3>
<p>All of the above parameters to \*(C`new()\*(C' are passed to the Params::CallbackRequest constructor and deleted from the MasonX::Interp::WithCallbacks object. MasonX::Interp::WithCallbacks then contains a Params::CallbackRequest object that it uses to handle the execution of all callbacks for each request.</p><p><em>cb_request</em></p><p>  my $interp = MasonX::Interp::WithCallbacks-&gt;new;   my $cb_request = $interp-&gt;cb_request;</p><p>Returns the Params::CallbackRequest object in use during the execution of \*(C`make_request()\*(C'.</p><p><em>comp_path</em></p><p>  my $comp_path = $interp-&gt;comp_path;   $interp-&gt;comp_path($comp_path);</p><p>Returns the component path resolved by Mason during the execution of \*(C`handle_request()\*(C'. The cool thing is that it can be changed during the execution of callback methods:</p><p>  sub change_path :Callback {       my $cb = shift;       my $interp = $cb-&gt;requester;       $inpter-&gt;comp_path($some_other_path);   }</p><p>In this example, we have overridden the component path determined by the Mason resolver in favor of an alternate component, which will be executed, instead.</p>
<h3>Requester</h3>
<p>The MasonX::Interp::WithCallbacks object is available in all callback methods via the \*(C`requester()\*(C' accessor:</p><p>  sub access_interp :Callback {       my $cb = shift;       my $interp = $cb-&gt;requester;       # ...   }</p>
<h3>Notes</h3>
<p>  $interp-&gt;cb_request-&gt;notes($key =&gt; $value);   my $note = $interp-&gt;cb_request-&gt;notes($key);   my $notes = $interp-&gt;cb_request-&gt;notes;</p><p>The Params::CallbackRequest notes interface remains available via the \*(C`notes()\*(C' method of both Params::CallbackRequest and Params::Callback. Notes stored via this interface will be copied to the HTML::Mason::Request \*(C`notes()\*(C' interface before the execution of the request, <em>and</em> continue to be available for the lifetime of the Mason request via \*(C`$interp-&gt;cb_request-&gt;notes\*(C'. Notes will be cleared out at the end of the request, just as with \*(C`$r-&gt;pnotes\*(C'.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>This module is stored in an open GitHub repository &lt;http://github.com/theory/masonx-interp-withcallbacks/&gt;. Feel free to fork and contribute!</p><p>Please file bug reports via GitHub Issues &lt;http://github.com/theory/masonx-interp-withcallbacks/issues/&gt; or by sending mail to bug-MasonX-Interp-WithCallbacks.cpan.org &lt;mailto:bug-MasonX-Interp-WithCallbacks.cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO MasonX::Interp::WithCallbacks&hellip;</h2>
        <div class="sectioncontent">
<p>Params::CallbackRequest handles the processing of the Mason request arguments and the execution of callbacks. See its documentation for the most up-to-date documentation of the underlying callback architecture.</p><p>Params::Callback objects get passed as the sole argument to all functional callbacks, and offer access to data relevant to the callback. Params::Callback also defines the object-oriented callback interface, making its documentation a must-read for anyone who wishes to create callback classes and methods.</p><p>This module works with HTML::Mason by subclassing HTML::Mason::Interp. Inspired by the implementation of callbacks in Bricolage (&lt;http://bricolage.cc/&gt;), it is however a completely new code base with a rather different approach.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David E. Wheeler &lt;david@justatheory.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright 2003-2011 by David E. Wheeler. Some Rights Reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Mason::Plugin::RouterSimple.3pm.html"><span aria-hidden="true">&larr;</span> Mason::Plugin::RouterSimple.3pm: Specify routes for page components</a></li>
   <li class="next"><a href="MasonX::ProcessDir.3pm.html">MasonX::ProcessDir.3pm: Process a directory of mason 2 templates <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

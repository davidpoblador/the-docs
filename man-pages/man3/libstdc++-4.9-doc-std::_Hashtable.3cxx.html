<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>std::_Hashtable: Std::_hashtable _key, _value, _alloc, _extractkey, _equal, _h1, _h2, _hash, _rehashpolicy, _traits  -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Std::_hashtable _key, _value, _alloc, _extractkey, _equal, _h1, _h2, _hash, _rehashpolicy, _traits  -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="std::_Hashtable (3cxx) manual">
  <meta name="twitter:description" content="Std::_hashtable _key, _value, _alloc, _extractkey, _equal, _h1, _h2, _hash, _rehashpolicy, _traits  -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libstdc++-4.9-doc-std::_Hashtable-3cxx.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3cxx/libstdc++-4.9-doc-std::_Hashtable.3cxx.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="std::_Hashtable (3cxx) manual" />
  <meta property="og:description" content="Std::_hashtable _key, _value, _alloc, _extractkey, _equal, _h1, _h2, _hash, _rehashpolicy, _traits  -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libstdc++-4.9-doc-std::_Hashtable-3cxx.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">std::_Hashtable<small> (3cxx)</small></h1>
        <p class="lead">Std::_hashtable _key, _value, _alloc, _extractkey, _equal, _h1, _h2, _hash, _rehashpolicy, _traits  -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::_Hashtable.3cxx.html">
      <span itemprop="name">std::_Hashtable: Std::_hashtable _key, _value, _alloc, _extractkey, _equal, _h1, _h2, _hash, _rehashpolicy, _traits  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libstdc++-4.9-doc/">
      <span itemprop="name">libstdc++-4.9-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::_Hashtable.3cxx.html">
      <span itemprop="name">std::_Hashtable: Std::_hashtable _key, _value, _alloc, _extractkey, _equal, _h1, _h2, _hash, _rehashpolicy, _traits  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Inherits <strong>std::__detail::_Hashtable_base&lt; _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits &gt;</strong>, <strong>std::__detail::_Map_base&lt; _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits &gt;</strong>, <strong>std::__detail::_Insert&lt; _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits &gt;</strong>, <strong>std::__detail::_Rehash_base&lt; _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits &gt;</strong>, <strong>std::__detail::_Equality&lt; _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits &gt;</strong>, and <strong>std::__detail::_Hashtable_alloc&lt; __alloctr_rebind&lt; _Alloc, __detail::_Hash_node&lt; _Value, _Traits::__hash_cached::value &gt; &gt;::__type &gt;</strong>.</p><h3>Public Types</h3>
<p>typedef _Alloc <strong>allocator_type</strong></p><p>using <strong>const_iterator</strong> = <strong>__detail::_Node_const_iterator</strong>&lt; value_type, __constant_iterators::value, __hash_cached::value &gt;</p><p>using <strong>const_local_iterator</strong> = <strong>__detail::_Local_const_iterator</strong>&lt; key_type, value_type, _ExtractKey, _H1, _H2, _Hash, __constant_iterators::value, __hash_cached::value &gt;</p><p>typedef</p><p>__value_alloc_traits::const_pointer <strong>const_pointer</strong>"</p><p>typedef const value_type & <strong>const_reference</strong></p><p>typedef std::ptrdiff_t <strong>difference_type</strong></p><p>using <strong>iterator</strong> = <strong>__detail::_Node_iterator</strong>&lt; value_type, __constant_iterators::value, __hash_cached::value &gt;</p><p>typedef _Equal <strong>key_equal</strong></p><p>typedef _Key <strong>key_type</strong></p><p>using <strong>local_iterator</strong> = <strong>__detail::_Local_iterator</strong>&lt; key_type, value_type, _ExtractKey, _H1, _H2, _Hash, __constant_iterators::value, __hash_cached::value &gt;</p><p>typedef</p><p>__value_alloc_traits::pointer <strong>pointer</strong>"</p><p>typedef value_type & <strong>reference</strong></p><p>typedef std::size_t <strong>size_type</strong></p><p>typedef _Value <strong>value_type</strong></p>
<h3>Protected Member Functions</h3>
<p>const _Equal & <strong>_M_eq</strong> () const </p><p>_Equal & <strong>_M_eq</strong> ()</p><p>bool <strong>_M_equals</strong> (const _Key &__k, __hash_code __c, <strong>__node_type</strong> *__n) const </p><p>void <strong>_M_swap</strong> (_Hashtable_base &__x)</p>
<h3>Private Types</h3>
<p>using <strong>__bucket_alloc_traits</strong> = <strong>std::allocator_traits</strong>&lt; __bucket_alloc_type &gt;</p><p>using <strong>__bucket_alloc_type</strong> = typename __alloctr_rebind&lt; __node_alloc_type, __bucket_type &gt;::__type</p><p>using <strong>__value_alloc_type</strong> = typename __alloctr_rebind&lt; __node_alloc_type, __value_type &gt;::__type</p><p>using <strong>__value_type</strong> = typename __node_type::value_type</p>
<h3>Private Member Functions</h3>
<p>__bucket_type * <strong>_M_allocate_buckets</strong> (std::size_t __n)</p><p><strong>__node_type</strong> * <strong>_M_allocate_node</strong> (_Args &&...__args)</p><p>void <strong>_M_deallocate_buckets</strong> (__bucket_type *, std::size_t __n)</p><p>void <strong>_M_deallocate_node</strong> (<strong>__node_type</strong> *__n)</p><p>void <strong>_M_deallocate_nodes</strong> (<strong>__node_type</strong> *__n)</p><p>__node_alloc_type & <strong>_M_node_allocator</strong> ()</p><p>const __node_alloc_type & <strong>_M_node_allocator</strong> () const</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<h3>template&lt;typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits&gt;singleton std::_Hashtable&lt; _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits &gt;</h3>
<p>Primary class template _Hashtable.</p><p><strong>Template Parameters:</strong></p><p><em>_Value</em> CopyConstructible type.</p><p><em>_Key</em> CopyConstructible type.</p><p><em>_Alloc</em> An allocator type ([lib.allocator.requirements]) whose _Alloc::value_type is _Value. As a conforming extension, we allow for _Alloc::value_type != _Value.</p><p><em>_ExtractKey</em> Function object that takes an object of type _Value and returns a value of type _Key.</p><p><em>_Equal</em> Function object that takes two objects of type k and returns a bool-like value that is true if the two objects are considered equal.</p><p><em>_H1</em> The hash function. A unary function object with argument type _Key and result type size_t. Return values should be distributed over the entire range [0, numeric_limits&lt;size_t&gt;:max()].</p><p><em>_H2</em> The range-hashing function (in the terminology of Tavori and Dreizin). A binary function object whose argument types and result type are all size_t. Given arguments r and N, the return value is in the range [0, N).</p><p><em>_Hash</em> The ranged hash function (Tavori and Dreizin). A binary function whose argument types are _Key and size_t and whose result type is size_t. Given arguments k and N, the return value is in the range [0, N). Default: hash(k, N) = h2(h1(k), N). If _Hash is anything other than the default, _H1 and _H2 are ignored.</p><p><em>_RehashPolicy</em> Policy class with three members, all of which govern the bucket count. _M_next_bkt(n) returns a bucket count no smaller than n. _M_bkt_for_elements(n) returns a bucket count appropriate for an element count of n. _M_need_rehash(n_bkt, n_elt, n_ins) determines whether, if the current bucket count is n_bkt and the current element count is n_elt, we need to increase the bucket count. If so, returns make_pair(true, n), where n is the new bucket count. If not, returns make_pair(false, &lt;anything&gt;)</p><p><em>_Traits</em> Compile-time class with three boolean std::integral_constant members: __cache_hash_code, __constant_iterators, __unique_keys.</p><p>Each _Hashtable data structure has:</p><ul>
<li><p>_Bucket[] _M_buckets</p></li><li><p>_Hash_node_base _M_before_begin</p></li><li><p>size_type _M_bucket_count</p></li><li><p>size_type _M_element_count</p></li>
</ul><p>with _Bucket being _Hash_node* and _Hash_node containing:</p><ul>
<li><p>_Hash_node* _M_next</p></li><li><p>Tp _M_value</p></li><li><p>size_t _M_hash_code if cache_hash_code is true</p></li>
</ul><p>In terms of Standard containers the hashtable is like the aggregation of:</p><ul>
<li><p>std::forward_list&lt;_Node&gt; containing the elements</p></li><li><p>std::vector&lt;std::forward_list&lt;_Node&gt;::iterator&gt; representing the buckets</p></li>
</ul><p>The non-empty buckets contain the node before the first node in the bucket. This design makes it possible to implement something like a std::forward_list::insert_after on container insertion and std::forward_list::erase_after on container erase calls. _M_before_begin is equivalent to std::forward_list::before_begin. Empty buckets contain nullptr. Note that one of the non-empty buckets contains &_M_before_begin which is not a dereferenceable node so the node pointer in a bucket shall never be dereferenced, only its next node can be.</p><p>Walking through a bucket's nodes requires a check on the hash code to see if each node is still in the bucket. Such a design assumes a quite efficient hash functor and is one of the reasons it is highly advisable to set __cache_hash_code to true.</p><p>The container iterators are simply built from nodes. This way incrementing the iterator is perfectly efficient independent of how many empty buckets there are in the container.</p><p>On insert we compute the element's hash code and use it to find the bucket index. If the element must be inserted in an empty bucket we add it at the beginning of the singly linked list and make the bucket point to _M_before_begin. The bucket that used to point to _M_before_begin, if any, is updated to point to its new before begin node.</p><p>On erase, the simple iterator design requires using the hash functor to get the index of the bucket to update. For this reason, when __cache_hash_code is set to false the hash functor must not throw and this is enforced by a static assertion.</p><p>Functionality is implemented by decomposition into base classes, where the derived _Hashtable class is used in _Map_base, _Insert, _Rehash_base, and _Equality base classes to access the 'this' pointer. _Hashtable_base is used in the base classes as a non-recursive, fully-completed-type so that detailed nested type information, such as iterator type and node type, can be used. This is similar to the 'Curiously Recurring Template Pattern' (CRTP) technique, but uses a reconstructed, not explicitly passed, template pattern.</p><p>Base class templates are:</p><ul>
<li><p>__detail::_Hashtable_base</p></li><li><p>__detail::_Map_base</p></li><li><p>__detail::_Insert</p></li><li><p>__detail::_Rehash_base</p></li><li><p>__detail::_Equality</p></li>
</ul><p>Definition at line 170 of file bits/hashtable.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for libstdc++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libstdc++-4.8-doc-std::_Hashtable.3cxx.html"><span aria-hidden="true">&larr;</span> std::_Hashtable.3cxx: Std::_hashtable _key, _value, _alloc, _extractkey, _equal, _h1, _h2, _hash, _rehashpolicy, _traits  -</a></li>
   <li class="next"><a href="libstdc++-4.8-doc-std::_List_base.3cxx.html">std::_List_base.3cxx: Std::_list_base _tp, _alloc  - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

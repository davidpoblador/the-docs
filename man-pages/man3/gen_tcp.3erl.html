<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gen_tcp: Interface to tcp/ip sockets</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Interface to tcp/ip sockets">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gen_tcp (3erl) manual">
  <meta name="twitter:description" content="Interface to tcp/ip sockets">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-gen_tcp-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/gen_tcp.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gen_tcp (3erl) manual" />
  <meta property="og:description" content="Interface to tcp/ip sockets" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-gen_tcp-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gen_tcp<small> (3erl)</small></h1>
        <p class="lead">Interface to tcp/ip sockets</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gen_tcp.3erl.html">
      <span itemprop="name">gen_tcp: Interface to tcp/ip sockets</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gen_tcp.3erl.html">
      <span itemprop="name">gen_tcp: Interface to tcp/ip sockets</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <em>gen_tcp</em> module provides functions for communicating with sockets using the TCP/IP protocol.</p><p>The following code fragment provides a simple example of a client connecting to a server at port 5678, transferring a binary and closing the connection:</p>
<pre>
client() -&gt;
    SomeHostInNet = "localhost", % to make it runnable on one machine
    {ok, Sock} = gen_tcp:connect(SomeHostInNet, 5678,
                                 [binary, {packet, 0}]),
    ok = gen_tcp:send(Sock, "Some Data"),
    ok = gen_tcp:close(Sock).
</pre>
<p>At the other end a server is listening on port 5678, accepts the connection and receives the binary:</p>
<pre>
server() -&gt;
    {ok, LSock} = gen_tcp:listen(5678, [binary, {packet, 0},
                                        {active, false}]),
    {ok, Sock} = gen_tcp:accept(LSock),
    {ok, Bin} = do_recv(Sock, []),
    ok = gen_tcp:close(Sock),
    Bin.

do_recv(Sock, Bs) -&gt;
    case gen_tcp:recv(Sock, 0) of
        {ok, B} -&gt;
            do_recv(Sock, [Bs, B]);
        {error, closed} -&gt;
            {ok, list_to_binary(Bs)}
    end.
</pre>
<p>For more examples, see the <strong>examples</strong> section.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>option()</strong> = {active, true | false | once | -32768..32767}

         | {buffer, integer() &gt;= 0}

         | {delay_send, boolean()}

         | {deliver, port | term}

         | {dontroute, boolean()}

         | {exit_on_close, boolean()}

         | {header, integer() &gt;= 0}

         | {high_msgq_watermark, integer() &gt;= 1}

         | {high_watermark, integer() &gt;= 0}

         | {keepalive, boolean()}

         | {linger, {boolean(), integer() &gt;= 0}}

         | {low_msgq_watermark, integer() &gt;= 1}

         | {low_watermark, integer() &gt;= 0}

         | {mode, list | binary}

         | list

         | binary

         | {nodelay, boolean()}

         | {packet,

            0 |

            1 |

            2 |

            4 |

            raw |

            sunrm |

            asn1 |

            cdr |

            fcgi |

            line |

            tpkt |

            http |

            httph |

            http_bin |

            httph_bin}

         | {packet_size, integer() &gt;= 0}

         | {priority, integer() &gt;= 0}

         | {raw,

            Protocol :: integer() &gt;= 0,

            OptionNum :: integer() &gt;= 0,

            ValueBin :: binary()}

         | {recbuf, integer() &gt;= 0}

         | {reuseaddr, boolean()}

         | {send_timeout, integer() &gt;= 0 | infinity}

         | {send_timeout_close, boolean()}

         | {sndbuf, integer() &gt;= 0}

         | {tos, integer() &gt;= 0}

         | {ipv6_v6only, boolean()}

</pre>

<pre>
<strong>option_name()</strong> = active

              | buffer

              | delay_send

              | deliver

              | dontroute

              | exit_on_close

              | header

              | high_msgq_watermark

              | high_watermark

              | keepalive

              | linger

              | low_msgq_watermark

              | low_watermark

              | mode

              | nodelay

              | packet

              | packet_size

              | priority

              | {raw,

                 Protocol :: integer() &gt;= 0,

                 OptionNum :: integer() &gt;= 0,

                 ValueSpec :: (ValueSize :: integer() &gt;= 0)

                            | (ValueBin :: binary())}

              | recbuf

              | reuseaddr

              | send_timeout

              | send_timeout_close

              | sndbuf

              | tos

              | ipv6_v6only

</pre>

<pre>
<strong>connect_option()</strong> = {ip, <strong>inet:ip_address()</strong>}

                 | {fd, Fd :: integer() &gt;= 0}

                 | {ifaddr, <strong>inet:ip_address()</strong>}

                 | <strong>inet:address_family()</strong>

                 | {port, <strong>inet:port_number()</strong>}

                 | {tcp_module, module()}

                 | <strong>option()</strong>

</pre>

<pre>
<strong>listen_option()</strong> = {ip, <strong>inet:ip_address()</strong>}

                | {fd, Fd :: integer() &gt;= 0}

                | {ifaddr, <strong>inet:ip_address()</strong>}

                | <strong>inet:address_family()</strong>

                | {port, <strong>inet:port_number()</strong>}

                | {backlog, B :: integer() &gt;= 0}

                | {tcp_module, module()}

                | <strong>option()</strong>

</pre>

<pre>
<strong></strong>
<strong>socket()</strong>

</pre>
<p>As returned by accept/1,2 and connect/3,4.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
connect(Address, Port, Options) -&gt; {ok, Socket} | {error, Reason}

</pre>

<pre>
<strong></strong>
connect(Address, Port, Options, Timeout) -&gt;
<strong></strong>
           {ok, Socket} | {error, Reason}

</pre>
<p>Types:</p><p>Address = <strong>inet:ip_address()</strong> | <strong>inet:hostname()</strong></p><p>Port = <strong>inet:port_number()</strong></p><p>Options = [<strong>connect_option()</strong>]</p><p>Timeout = timeout()</p><p>Socket = <strong>socket()</strong></p><p>Reason = <strong>inet:posix()</strong></p><p>Connects to a server on TCP port <em>Port</em> on the host with IP address <em>Address</em>. The <em>Address</em> argument can be either a hostname, or an IP address.</p><p>The available options are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{ip, ip_address()}</em>: If the host has several network interfaces, this option specifies which one to use.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{ifaddr, ip_address()}</em>: Same as <em>{ip, ip_address()}</em>. If the host has several network interfaces, this option specifies which one to use.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{fd, integer() &gt;= 0}</em>: If a socket has somehow been connected without using <em>gen_tcp</em>, use this option to pass the file descriptor for it. If <em>{ip, ip_address()}</em> and/or <em>{port, port_number()}</em> is combined with this option the fd will be bound to the given interface and port before connecting. If these options are not given it is assumed that the fd is already bound appropriately.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>inet</em>: Set up the socket for IPv4.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>inet6</em>: Set up the socket for IPv6.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{port, Port}</em>: Specify which local port number to use.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{tcp_module, module()}</em>: Override which callback module is used. Defaults to <em>inet_tcp</em> for IPv4 and <em>inet6_tcp</em> for IPv6.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>Opt</em>: See <strong>inet:setopts/2</strong>.</p>
  </dd>

</dl>
<p>Packets can be sent to the returned socket <em>Socket</em> using <em>send/2</em>. Packets sent from the peer are delivered as messages:</p>
<pre>
{tcp, Socket, Data}
</pre>
<p>If the socket is in <em>{active, N}</em> mode (see <strong> inet:setopts/2</strong> for details) and its message counter drops to 0, the following message is delivered to indicate that the socket has transitioned to passive (<em>{active, false}</em>) mode:</p>
<pre>
{tcp_passive, Socket}
</pre>
<p>If the socket is closed, the following message is delivered:</p>
<pre>
{tcp_closed, Socket}
</pre>
<p>If an error occurs on the socket, the following message is delivered:</p>
<pre>
{tcp_error, Socket, Reason}
</pre>
<p>unless <em>{active, false}</em> is specified in the option list for the socket, in which case packets are retrieved by calling <em>recv/2</em>.</p><p>The optional <em>Timeout</em> parameter specifies a timeout in milliseconds. The default value is <em>infinity</em>.</p><p><strong></strong> Note:</p><p>The default values for options given to <em>connect</em> can be affected by the Kernel configuration parameter <em>inet_default_connect_options</em>. See <strong>inet(3erl)</strong> for details.</p>
<pre>
<strong></strong>
listen(Port, Options) -&gt; {ok, ListenSocket} | {error, Reason}

</pre>
<p>Types:</p><p>Port = <strong>inet:port_number()</strong></p><p>Options = [<strong>listen_option()</strong>]</p><p>ListenSocket = <strong>socket()</strong></p><p>Reason = system_limit | <strong>inet:posix()</strong></p><p>Sets up a socket to listen on the port <em>Port</em> on the local host.</p><p>If <em>Port == 0</em>, the underlying OS assigns an available port number, use <em>inet:port/1</em> to retrieve it.</p><p>The available options are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>list</em>: Received <em>Packet</em> is delivered as a list.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>binary</em>: Received <em>Packet</em> is delivered as a binary.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{backlog, B}</em>: <em>B</em> is an integer &gt;= 0. The backlog value defaults to 5. The backlog value defines the maximum length that the queue of pending connections may grow to.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{ip, ip_address()}</em>: If the host has several network interfaces, this option specifies which one to listen on.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{port, Port}</em>: Specify which local port number to use.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{fd, Fd}</em>: If a socket has somehow been connected without using <em>gen_tcp</em>, use this option to pass the file descriptor for it.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{ifaddr, ip_address()}</em>: Same as <em>{ip, ip_address()}</em>. If the host has several network interfaces, this option specifies which one to use.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>inet6</em>: Set up the socket for IPv6.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>inet</em>: Set up the socket for IPv4.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{tcp_module, module()}</em>: Override which callback module is used. Defaults to <em>inet_tcp</em> for IPv4 and <em>inet6_tcp</em> for IPv6.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>Opt</em>: See <strong>inet:setopts/2</strong>.</p>
  </dd>

</dl>
<p>The returned socket <em>ListenSocket</em> can only be used in calls to <em>accept/1,2</em>.</p><p><strong></strong> Note:</p><p>The default values for options given to <em>listen</em> can be affected by the Kernel configuration parameter <em>inet_default_listen_options</em>. See <strong>inet(3erl)</strong> for details.</p>
<pre>
<strong></strong>
accept(ListenSocket) -&gt; {ok, Socket} | {error, Reason}

</pre>

<pre>
<strong></strong>
accept(ListenSocket, Timeout) -&gt; {ok, Socket} | {error, Reason}

</pre>
<p>Types:</p><p>ListenSocket = <strong>socket()</strong></p><p>Returned by <em>listen/2</em>.</p><p>Timeout = timeout()</p><p>Socket = <strong>socket()</strong></p><p>Reason = closed | timeout | system_limit | <strong>inet:posix()</strong></p><p>Accepts an incoming connection request on a listen socket. <em>Socket</em> must be a socket returned from <em>listen/2</em>. <em>Timeout</em> specifies a timeout value in ms, defaults to <em>infinity</em>.</p><p>Returns <em>{ok, Socket}</em> if a connection is established, or <em>{error, closed}</em> if <em>ListenSocket</em> is closed, or <em>{error, timeout}</em> if no connection is established within the specified time, or <em>{error, system_limit}</em> if all available ports in the Erlang emulator are in use. May also return a POSIX error value if something else goes wrong, see inet(3erl) for possible error values.</p><p>Packets can be sent to the returned socket <em>Socket</em> using <em>send/2</em>. Packets sent from the peer are delivered as messages:</p>
<pre>
{tcp, Socket, Data}
</pre>
<p>unless <em>{active, false}</em> was specified in the option list for the listen socket, in which case packets are retrieved by calling <em>recv/2</em>.</p><p><strong></strong> Note:</p><p>It is worth noting that the <em>accept</em> call does <em>not</em> have to be issued from the socket owner process. Using version 5.5.3 and higher of the emulator, multiple simultaneous accept calls can be issued from different processes, which allows for a pool of acceptor processes handling incoming connections.</p>
<pre>
<strong></strong>
send(Socket, Packet) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>socket()</strong></p><p>Packet = iodata()</p><p>Reason = closed | <strong>inet:posix()</strong></p><p>Sends a packet on a socket.</p><p>There is no <em>send</em> call with timeout option, you use the <em>send_timeout</em> socket option if timeouts are desired. See the <strong>examples</strong> section.</p>
<pre>
<strong></strong>
recv(Socket, Length) -&gt; {ok, Packet} | {error, Reason}

</pre>

<pre>
<strong></strong>
recv(Socket, Length, Timeout) -&gt; {ok, Packet} | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>socket()</strong></p><p>Length = integer() &gt;= 0</p><p>Timeout = timeout()</p><p>Packet = string() | binary() | HttpPacket</p><p>Reason = closed | <strong>inet:posix()</strong></p><p>HttpPacket = term()</p><p>See the description of <em>HttpPacket</em> in <strong> erlang:decode_packet/3</strong>.</p><p>This function receives a packet from a socket in passive mode. A closed socket is indicated by a return value <em>{error, closed}</em>.</p><p>The <em>Length</em> argument is only meaningful when the socket is in <em>raw</em> mode and denotes the number of bytes to read. If <em>Length</em> = 0, all available bytes are returned. If <em>Length</em> &gt; 0, exactly <em>Length</em> bytes are returned, or an error; possibly discarding less than <em>Length</em> bytes of data when the socket gets closed from the other side.</p><p>The optional <em>Timeout</em> parameter specifies a timeout in milliseconds. The default value is <em>infinity</em>.</p>
<pre>
<strong></strong>
controlling_process(Socket, Pid) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>socket()</strong></p><p>Pid = pid()</p><p>Reason = closed | not_owner | <strong>inet:posix()</strong></p><p>Assigns a new controlling process <em>Pid</em> to <em>Socket</em>. The controlling process is the process which receives messages from the socket. If called by any other process than the current controlling process, <em>{error, not_owner}</em> is returned.</p>
<pre>
<strong></strong>
close(Socket) -&gt; ok

</pre>
<p>Types:</p><p>Socket = <strong>socket()</strong></p><p>Closes a TCP socket.</p>
<pre>
<strong></strong>
shutdown(Socket, How) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>socket()</strong></p><p>How = read | write | read_write</p><p>Reason = <strong>inet:posix()</strong></p><p>Immediately close a socket in one or two directions.</p><p><em>How == write</em> means closing the socket for writing, reading from it is still possible.</p><p>To be able to handle that the peer has done a shutdown on the write side, the <em>{exit_on_close, false}</em> option is useful.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>The following example illustrates usage of the {active,once} option and multiple accepts by implementing a server as a number of worker processes doing accept on one single listen socket. The start/2 function takes the number of worker processes as well as a port number to listen for incoming connections on. If <em>LPort</em> is specified as <em>0</em>, an ephemeral portnumber is used, why the start function returns the actual portnumber allocated:</p>
<pre>
start(Num,LPort) -&gt;
    case gen_tcp:listen(LPort,[{active, false},{packet,2}]) of
        {ok, ListenSock} -&gt;
            start_servers(Num,ListenSock),
            {ok, Port} = inet:port(ListenSock),
            Port;
        {error,Reason} -&gt;
            {error,Reason}
    end.

start_servers(0,_) -&gt;
    ok;
start_servers(Num,LS) -&gt;
    spawn(?MODULE,server,[LS]),
    start_servers(Num-1,LS).

server(LS) -&gt;
    case gen_tcp:accept(LS) of
        {ok,S} -&gt;
            loop(S),
            server(LS);
        Other -&gt;
            io:format("accept returned ~w - goodbye!~n",[Other]),
            ok
    end.

loop(S) -&gt;
    inet:setopts(S,[{active,once}]),
    receive
        {tcp,S,Data} -&gt;
            Answer = process(Data), % Not implemented in this example
            gen_tcp:send(S,Answer),
            loop(S);
        {tcp_closed,S} -&gt;
            io:format("Socket ~w closed [~w]~n",[S,self()]),
            ok
    end.
</pre>
<p>A simple client could look like this:</p>
<pre>
client(PortNo,Message) -&gt;
    {ok,Sock} = gen_tcp:connect("localhost",PortNo,[{active,false},
                                                    {packet,2}]),
    gen_tcp:send(Sock,Message),
    A = gen_tcp:recv(Sock,0),
    gen_tcp:close(Sock),
    A.
</pre>
<p>The fact that the <em>send</em> call does not accept a timeout option, is because timeouts on send is handled through the socket option <em>send_timeout</em>. The behavior of a send operation with no receiver is in a very high degree defined by the underlying TCP stack, as well as the network infrastructure. If one wants to write code that handles a hanging receiver that might eventually cause the sender to hang on a <em>send</em> call, one writes code like the following.</p><p>Consider a process that receives data from a client process that is to be forwarded to a server on the network. The process has connected to the server via TCP/IP and does not get any acknowledge for each message it sends, but has to rely on the send timeout option to detect that the other end is unresponsive. We could use the <em>send_timeout</em> option when connecting:</p>
<pre>
    ...
    {ok,Sock} = gen_tcp:connect(HostAddress, Port,
                                [{active,false},
                                 {send_timeout, 5000},
                                 {packet,2}]),
                    loop(Sock), % See below
    ...
</pre>
<p>In the loop where requests are handled, we can now detect send timeouts:</p>
<pre>
loop(Sock) -&gt;
    receive
        {Client, send_data, Binary} -&gt;
            case gen_tcp:send(Sock,[Binary]) of
                {error, timeout} -&gt;
                    io:format("Send timeout, closing!~n",
                              []),
                    handle_send_timeout(), % Not implemented here
                    Client ! {self(),{error_sending, timeout}},
                    %% Usually, it's a good idea to give up in case of a
                    %% send timeout, as you never know how much actually
                    %% reached the server, maybe only a packet header?!
                    gen_tcp:close(Sock);
                {error, OtherSendError} -&gt;
                    io:format("Some other error on socket (~p), closing",
                              [OtherSendError]),
                    Client ! {self(),{error_sending, OtherSendError}},
                    gen_tcp:close(Sock);
                ok -&gt;
                    Client ! {self(), data_sent},
                    loop(Sock)
            end
    end.
</pre>
<p>Usually it would suffice to detect timeouts on receive, as most protocols include some sort of acknowledgment from the server, but if the protocol is strictly one way, the <em>send_timeout</em> option comes in handy!</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gen_server.3erl.html"><span aria-hidden="true">&larr;</span> gen_server.3erl: Generic server behaviour</a></li>
   <li class="next"><a href="gen_udp.3erl.html">gen_udp.3erl: Interface to udp sockets <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

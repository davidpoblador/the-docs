<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Data::Float: Details of the floating point data type</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Details of the floating point data type">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Data::Float (3pm) manual">
  <meta name="twitter:description" content="Details of the floating point data type">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdata-float-perl-Data::Float-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Data::Float.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Data::Float (3pm) manual" />
  <meta property="og:description" content="Details of the floating point data type" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdata-float-perl-Data::Float-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Data::Float<small> (3pm)</small></h1>
        <p class="lead">Details of the floating point data type</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::Float.3pm.html">
      <span itemprop="name">Data::Float: Details of the floating point data type</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdata-float-perl/">
      <span itemprop="name">libdata-float-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::Float.3pm.html">
      <span itemprop="name">Data::Float: Details of the floating point data type</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        use Data::Float qw(have_signed_zero);

        if(have_signed_zero) { ...

        # and many other constants; see text

        use Data::Float qw(
                float_class float_is_normal float_is_subnormal
                float_is_nzfinite float_is_zero float_is_finite
                float_is_infinite float_is_nan
        );

        $class = float_class($value);

        if(float_is_normal($value)) { ...
        if(float_is_subnormal($value)) { ...
        if(float_is_nzfinite($value)) { ...
        if(float_is_zero($value)) { ...
        if(float_is_finite($value)) { ...
        if(float_is_infinite($value)) { ...
        if(float_is_nan($value)) { ...

        use Data::Float qw(float_sign signbit float_parts);

        $sign = float_sign($value);
        $sign_bit = signbit($value);
        ($sign, $exponent, $significand) = float_parts($value);

        use Data::Float qw(float_hex hex_float);

        print float_hex($value);
        $value = hex_float($string);

        use Data::Float qw(float_id_cmp totalorder);

        @sorted_floats = sort { float_id_cmp($a, $b) } @floats;
        if(totalorder($a, $b)) { ...

        use Data::Float qw(
                pow2 mult_pow2 copysign
                nextup nextdown nextafter
        );

        $x = pow2($exp);
        $x = mult_pow2($value, $exp);
        $x = copysign($magnitude, $sign_from);
        $x = nextup($x);
        $x = nextdown($x);
        $x = nextafter($x, $direction);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is about the native floating point numerical data type. A floating point number is one of the types of datum that can appear in the numeric part of a Perl scalar.  This module supplies constants describing the native floating point type, classification functions, and functions to manipulate floating point values at a low level.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FLOATING POINT</h2>
        <div class="sectioncontent">
<h3>Classification</h3>
<p>Floating point values are divided into five subtypes:</p>
<dl class='dl-vertical'>
  <dt>
    normalised
  </dt>
  <dd>
    <p>The value is made up of a sign bit (making the value positive or negative), a significand, and exponent.  The significand is a number in the range [1, 2), expressed as a binary fraction of a certain fixed length.  (Significands requiring a longer binary fraction, or lacking a terminating binary representation, cannot be obtained.)  The exponent is an integer in a certain fixed range.  The magnitude of the value represented is the product of the significand and two to the power of the exponent.</p>
  </dd>
  <dt>
    subnormal
  </dt>
  <dd>
    <p>The value is made up of a sign bit, significand, and exponent, as for normalised values.  However, the exponent is fixed at the minimum possible for a normalised value, and the significand is in the range (0, 1).  The length of the significand is the same as for normalised values.  This is essentially a fixed-point format, used to provide gradual underflow.  Not all floating point formats support this subtype. Where it is not supported, underflow is sudden, and the difference between two minimum-exponent normalised values cannot be exactly represented.</p>
  </dd>
  <dt>
    zero
  </dt>
  <dd>
    <p>Depending on the floating point type, there may be either one or two zero values: zeroes may carry a sign bit.  Where zeroes are signed, it is primarily in order to indicate the direction from which a value underflowed (was rounded) to zero.  Positive and negative zero compare as numerically equal, and they give identical results in most arithmetic operations.  They are on opposite sides of some branch cuts in complex arithmetic.</p>
  </dd>
  <dt>
    infinite
  </dt>
  <dd>
    <p>Some floating point formats include special infinite values.  These are generated by overflow, and by some arithmetic cases that mathematically generate infinities.  There are two infinite values: positive infinity and negative infinity. Perl does not always generate infinite values when normal floating point behaviour calls for it.  For example, the division \*(C`1.0/0.0\*(C' causes an exception rather than returning an infinity.</p>
  </dd>
  <dt>
    not-a-number (NaN)
  </dt>
  <dd>
    <p>This type of value exists in some floating point formats to indicate error conditions.  Mathematically undefined operations may generate NaNs, and NaNs propagate through all arithmetic operations.  A NaN has the distinctive property of comparing numerically unequal to all floating point values, including itself. Perl does not always generate NaNs when normal floating point behaviour calls for it.  For example, the division \*(C`0.0/0.0\*(C' causes an exception rather than returning a NaN. Perl has only (at most) one NaN value, even if the underlying system supports different NaNs.  (\s-1IEEE\s0 754 arithmetic has NaNs which carry a quiet/signal bit, a sign bit (yes, a sign on a not-number), and many bits of implementation-defined data.)</p>
  </dd>

</dl>

<h3>Mixing floating point and integer values</h3>
<p>Perl does not draw a strong type distinction between native integer (see Data::Integer) and native floating point values.  Both types of value can be stored in the numeric part of a plain (string) scalar. No distinction is made between the integer representation and the floating point representation where they encode identical values.  Thus, for floating point arithmetic, native integer values that can be represented exactly in floating point may be freely used as floating point values.</p><p>Native integer arithmetic has exactly one zero value, which has no sign. If the floating point type does not have signed zeroes then the floating point and integer zeroes are exactly equivalent.  If the floating point type does have signed zeroes then the integer zero can still be used in floating point arithmetic, and it behaves as an unsigned floating point zero.  On such systems there are therefore three types of zero available. There is a bug in Perl which sometimes causes floating point zeroes to change into integer zeroes; see \*(L"\s-1BUGS\s0\*(R" for details.</p><p>Where a native integer value is used that is too large to exactly represent in floating point, it will be rounded as necessary to a floating point value.  This rounding will occur whenever an operation has to be performed in floating point because the result could not be exactly represented as an integer.  This may be confusing to functions that expect a floating point argument.</p><p>Similarly, some operations on floating point numbers will actually be performed in integer arithmetic, and may result in values that cannot be exactly represented in floating point.  This happens whenever the arguments have integer values that fit into the native integer type and the mathematical result can be exactly represented as a native integer. This may be confusing in cases where floating point semantics are expected.</p><p>See <em>perlnumber</em>\|(1) for discussion of Perl's numeric semantics.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTANTS</h2>
        <div class="sectioncontent">
<h3>Features</h3>

<dl class='dl-vertical'>
  <dt>
    have_signed_zero
  </dt>
  <dd>
    <p>Truth value indicating whether floating point zeroes carry a sign.  If yes, then there are two floating point zero values: +0.0 and -0.0.  (Perl scalars can nevertheless also hold an integer zero, which is unsigned.) If no, then there is only one zero value, which is unsigned.</p>
  </dd>
  <dt>
    have_subnormal
  </dt>
  <dd>
    <p>Truth value indicating whether there are subnormal floating point values.</p>
  </dd>
  <dt>
    have_infinite
  </dt>
  <dd>
    <p>Truth value indicating whether there are infinite floating point values.</p>
  </dd>
  <dt>
    have_nan
  </dt>
  <dd>
    <p>Truth value indicating whether there are NaN floating point values. It is difficult to reliably generate a NaN in Perl, so in some unlikely circumstances it is possible that there might be NaNs that this module failed to detect.  In that case this constant would be false but a NaN might still turn up somewhere.  What this constant reliably indicates is the availability of the \*(C`nan\*(C' constant below.</p>
  </dd>

</dl>

<h3>Extrema</h3>

<dl class='dl-vertical'>
  <dt>
    significand_bits
  </dt>
  <dd>
    <p>The number of fractional bits in the significand of finite floating point values.  The significand also has an implicit integer bit, not counted in this constant; the integer bit is always 1 for normalised values and always 0 for subnormal values.</p>
  </dd>
  <dt>
    significand_step
  </dt>
  <dd>
    <p>The difference between adjacent representable values in the range [1, 2] (where the exponent is zero).  This is equal to 2^-significand_bits.</p>
  </dd>
  <dt>
    max_finite_exp
  </dt>
  <dd>
    <p>The maximum exponent permitted for finite floating point values.</p>
  </dd>
  <dt>
    max_finite_pow2
  </dt>
  <dd>
    <p>The maximum representable power of two.  This is 2^max_finite_exp.</p>
  </dd>
  <dt>
    max_finite
  </dt>
  <dd>
    <p>The maximum representable finite value.  This is 2^(max_finite_exp+1) - 2^(max_finite_exp-significand_bits).</p>
  </dd>
  <dt>
    max_number
  </dt>
  <dd>
    <p>The maximum representable number.  This is positive infinity if there are infinite values, or max_finite if there are not.</p>
  </dd>
  <dt>
    max_integer
  </dt>
  <dd>
    <p>The maximum integral value for which all integers from zero to that value inclusive are representable.  Equivalently: the minimum positive integral value N for which the value N+1 is not representable.  This is 2^(significand_bits+1).  The name is somewhat misleading.</p>
  </dd>
  <dt>
    min_normal_exp
  </dt>
  <dd>
    <p>The minimum exponent permitted for normalised floating point values.</p>
  </dd>
  <dt>
    min_normal
  </dt>
  <dd>
    <p>The minimum positive value representable as a normalised floating point value.  This is 2^min_normal_exp.</p>
  </dd>
  <dt>
    min_finite_exp
  </dt>
  <dd>
    <p>The base two logarithm of the minimum representable positive finite value. If there are subnormals then this is min_normal_exp - significand_bits. If there are no subnormals then this is min_normal_exp.</p>
  </dd>
  <dt>
    min_finite
  </dt>
  <dd>
    <p>The minimum representable positive finite value.  This is 2^min_finite_exp.</p>
  </dd>

</dl>

<h3>Special Values</h3>

<dl class='dl-vertical'>
  <dt>
    pos_zero
  </dt>
  <dd>
    <p>The positive zero value.  (Exists only if zeroes are signed, as indicated by the \*(C`have_signed_zero\*(C' constant.) If Perl is at risk of transforming floating point zeroes into integer zeroes (see \*(L"\s-1BUGS\s0\*(R"), then this is actually a non-constant function that always returns a fresh floating point zero.  Thus the return value is always a true floating point zero, regardless of what happened to zeroes previously returned.</p>
  </dd>
  <dt>
    neg_zero
  </dt>
  <dd>
    <p>The negative zero value.  (Exists only if zeroes are signed, as indicated by the \*(C`have_signed_zero\*(C' constant.) If Perl is at risk of transforming floating point zeroes into integer zeroes (see \*(L"\s-1BUGS\s0\*(R"), then this is actually a non-constant function that always returns a fresh floating point zero.  Thus the return value is always a true floating point zero, regardless of what happened to zeroes previously returned.</p>
  </dd>
  <dt>
    pos_infinity
  </dt>
  <dd>
    <p>The positive infinite value.  (Exists only if there are infinite values, as indicated by the \*(C`have_infinite\*(C' constant.)</p>
  </dd>
  <dt>
    neg_infinity
  </dt>
  <dd>
    <p>The negative infinite value.  (Exists only if there are infinite values, as indicated by the \*(C`have_infinite\*(C' constant.)</p>
  </dd>
  <dt>
    nan
  </dt>
  <dd>
    <p>Not-a-number.  (Exists only if NaN values were detected, as indicated by the \*(C`have_nan\*(C' constant.)</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>Each \*(L"float_\*(R" function takes a floating point argument to operate on.  The argument must be a native floating point value, or a native integer with a value that can be represented in floating point.  Giving a non-numeric argument will cause mayhem.  See \*(L"is_number\*(R" in Params::Classify for a way to check for numericness.  Only the numeric value of the scalar is used; the string value is completely ignored, so dualvars are not a problem.</p><h3>Classification</h3>
<p>Each \*(L"float_is_\*(R" function returns a simple truth value result.</p>
<dl class='dl-vertical'>
  <dt>
    float_class(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Determines which of the five classes described above \s-1VALUE\s0 falls into. Returns \*(L"\s-1NORMAL\s0\*(R", \*(L"\s-1SUBNORMAL\s0\*(R", \*(L"\s-1ZERO\s0\*(R", \*(L"\s-1INFINITE\s0\*(R", or \*(L"\s-1NAN\s0\*(R" accordingly.</p>
  </dd>
  <dt>
    float_is_normal(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Returns true iff \s-1VALUE\s0 is a normalised floating point value.</p>
  </dd>
  <dt>
    float_is_subnormal(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Returns true iff \s-1VALUE\s0 is a subnormal floating point value.</p>
  </dd>
  <dt>
    float_is_nzfinite(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Returns true iff \s-1VALUE\s0 is a non-zero finite value (either normal or subnormal; not zero, infinite, or NaN).</p>
  </dd>
  <dt>
    float_is_zero(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Returns true iff \s-1VALUE\s0 is a zero.  If zeroes are signed then the sign is irrelevant.</p>
  </dd>
  <dt>
    float_is_finite(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Returns true iff \s-1VALUE\s0 is a finite value (either normal, subnormal, or zero; not infinite or NaN).</p>
  </dd>
  <dt>
    float_is_infinite(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Returns true iff \s-1VALUE\s0 is an infinity (either positive infinity or negative infinity).</p>
  </dd>
  <dt>
    float_is_nan(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Returns true iff \s-1VALUE\s0 is a NaN.</p>
  </dd>

</dl>

<h3>Examination</h3>

<dl class='dl-vertical'>
  <dt>
    float_sign(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Returns "<strong>+</strong>\*(L" or \*(R"<strong>-</strong>\*(L" to indicate the sign of \s-1VALUE\s0.  An unsigned zero returns the sign \*(R"<strong>+</strong>".  \*(C`die\*(C's if \s-1VALUE\s0 is a NaN.</p>
  </dd>
  <dt>
    signbit(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>\s-1VALUE\s0 must be a floating point value.  Returns the sign bit of \s-1VALUE:\s0 0 if \s-1VALUE\s0 is positive or a positive or unsigned zero, or 1 if \s-1VALUE\s0 is negative or a negative zero.  Returns an unpredictable value if \s-1VALUE\s0 is a NaN. This is an \s-1IEEE\s0 754 standard function.  According to the standard NaNs have a well-behaved sign bit, but Perl can't see that bit.</p>
  </dd>
  <dt>
    float_parts(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>Divides up a non-zero finite floating point value into sign, exponent, and significand, returning these as a three-element list in that order. The significand is returned as a floating point value, in the range [1, 2) for normalised values, and in the range (0, 1) for subnormals. \*(C`die\*(C's if \s-1VALUE\s0 is not finite and non-zero.</p>
  </dd>

</dl>

<h3>String conversion</h3>

<dl class='dl-vertical'>
  <dt>
    float_hex(VALUE[, \s-1OPTIONS\s0])
  </dt>
  <dd>
    <p>Encodes the exact value of \s-1VALUE\s0 as a hexadecimal fraction, returning the fraction as a string.  Specifically, for finite values the output is of the form "<em>s</em><strong>0x</strong><em>m</em><strong>.</strong><em>mmmmm</em><strong>p</strong><em>eee</em>\*(L", where \*(R"<em>s</em>\*(L" is the sign, \*(R"<em>m</em><strong>.</strong><em>mmmm</em>\*(L" is the significand in hexadecimal, and \*(R"<em>eee</em>" is the exponent in decimal with a sign. The details of the output format are very configurable.  If \s-1OPTIONS\s0 is supplied, it must be a reference to a hash, in which these keys may be present:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>exp_digits</strong>
  </dt>
  <dd>
    <p>The number of digits of exponent to show, unless this is modified by <strong>exp_digits_range_mod</strong> or more are required to show the exponent exactly. (The exponent is always shown in full.)  Default 0, so the minimum possible number of digits is used.</p>
  </dd>
  <dt>
    <strong>exp_digits_range_mod</strong>
  </dt>
  <dd>
    <p>Modifies the number of exponent digits to show, based on the number of digits required to show the full range of exponents for normalised and subnormal values.  If "<strong>\s-1IGNORE\s0</strong>\*(L" then nothing is done.  If \*(R"<strong>\s-1ATLEAST\s0</strong>\*(L" then at least this many digits are shown.  Default \*(R"<strong>\s-1IGNORE\s0</strong>".</p>
  </dd>
  <dt>
    <strong>exp_neg_sign</strong>
  </dt>
  <dd>
    <p>The string that is prepended to a negative exponent.  Default "<strong>-</strong>".</p>
  </dd>
  <dt>
    <strong>exp_pos_sign</strong>
  </dt>
  <dd>
    <p>The string that is prepended to a non-negative exponent.  Default "<strong>+</strong>". Make it the empty string to suppress the positive sign.</p>
  </dd>
  <dt>
    <strong>frac_digits</strong>
  </dt>
  <dd>
    <p>The number of fractional digits to show, unless this is modified by <strong>frac_digits_bits_mod</strong> or <strong>frac_digits_value_mod</strong>.  Default 0, but by default this gets modified.</p>
  </dd>
  <dt>
    <strong>frac_digits_bits_mod</strong>
  </dt>
  <dd>
    <p>Modifies the number of fractional digits to show, based on the length of the significand.  There is a certain number of digits that is the minimum required to explicitly state every bit that is stored, and the number of digits to show might get set to that number depending on this option. If "<strong>\s-1IGNORE\s0</strong>\*(L" then nothing is done.  If \*(R"<strong>\s-1ATLEAST\s0</strong>\*(L" then at least this many digits are shown.  If \*(R"<strong>\s-1ATMOST\s0</strong>\*(L" then at most this many digits are shown.  If \*(R"<strong>\s-1EXACTLY\s0</strong>\*(L" then exactly this many digits are shown. Default \*(R"<strong>\s-1ATLEAST\s0</strong>".</p>
  </dd>
  <dt>
    <strong>frac_digits_value_mod</strong>
  </dt>
  <dd>
    <p>Modifies the number of fractional digits to show, based on the number of digits required to show the actual value exactly.  Works the same way as <strong>frac_digits_bits_mod</strong>.  Default "<strong>\s-1ATLEAST\s0</strong>".</p>
  </dd>
  <dt>
    <strong>hex_prefix_string</strong>
  </dt>
  <dd>
    <p>The string that is prefixed to hexadecimal digits.  Default "<strong>0x</strong>". Make it the empty string to suppress the prefix.</p>
  </dd>
  <dt>
    <strong>infinite_string</strong>
  </dt>
  <dd>
    <p>The string that is returned for an infinite magnitude.  Default "<strong>inf</strong>".</p>
  </dd>
  <dt>
    <strong>nan_string</strong>
  </dt>
  <dd>
    <p>The string that is returned for a NaN value.  Default "<strong>nan</strong>".</p>
  </dd>
  <dt>
    <strong>neg_sign</strong>
  </dt>
  <dd>
    <p>The string that is prepended to a negative value (including negative zero).  Default "<strong>-</strong>".</p>
  </dd>
  <dt>
    <strong>pos_sign</strong>
  </dt>
  <dd>
    <p>The string that is prepended to a positive value (including positive or unsigned zero).  Default "<strong>+</strong>".  Make it the empty string to suppress the positive sign.</p>
  </dd>
  <dt>
    <strong>subnormal_strategy</strong>
  </dt>
  <dd>
    <p>The manner in which subnormal values are displayed.  If "<strong>\s-1SUBNORMAL\s0</strong>\*(L", they are shown with the minimum exponent for normalised values and a significand in the range (0, 1).  This matches how they are stored internally.  If \*(R"<strong>\s-1NORMAL\s0</strong>\*(L", they are shown with a significand in the range [1, 2) and a lower exponent, as if they were normalised.  This gives a consistent appearance for magnitudes regardless of normalisation. Default \*(R"<strong>\s-1SUBNORMAL\s0</strong>".</p>
  </dd>
  <dt>
    <strong>zero_strategy</strong>
  </dt>
  <dd>
    <p>The manner in which zero values are displayed.  If "<strong>STRING=</strong><em>str</em>", the string <em>str</em> is used, preceded by a sign.  If "<strong>\s-1SUBNORMAL\s0</strong>\*(L", it is shown with significand zero and the minimum normalised exponent. If \*(R"<strong>EXPONENT=</strong><em>exp</em>", it is shown with significand zero and exponent <em>exp</em>.  Default "<strong>STRING=0.0</strong>".  An unsigned zero is treated as having a positive sign.</p>
  </dd>

</dl>

  </dd>
  <dt>
    hex_float(\s-1STRING\s0)
  </dt>
  <dd>
    <p>Generates and returns a floating point value from a string encoding it in hexadecimal.  The standard input form is "[<em>s</em>][<strong>0x</strong>]<em>m</em>[<strong>.</strong><em>mmmmm</em>][<strong>p</strong><em>eee</em>]\*(L", where \*(R"<em>s</em>\*(L" is the sign, \*(R"<em>m</em>[<strong>.</strong><em>mmmm</em>]\*(L" is a (fractional) hexadecimal number, and \*(R"<em>eee</em>" an optionally-signed exponent in decimal.  If present, the exponent identifies a power of two (not sixteen) by which the given fraction will be multiplied. If the value given in the string cannot be exactly represented in the floating point type because it has too many fraction bits, the nearest representable value is returned, with ties broken in favour of the value with a zero low-order bit.  If the value given is too large to exactly represent then an infinity is returned, or the largest finite value if there are no infinities. Additional input formats are accepted for special values. "[<em>s</em>]<strong>inf</strong>[<strong>inity</strong>]" returns an infinity, or \*(C`die\*(C's if there are no infinities.  "[<em>s</em>][<strong>s</strong>]<strong>nan</strong>" returns a NaN, or \*(C`die\*(C's if there are no NaNs available. All input formats are understood case insensitively.  The function correctly interprets all possible outputs from \*(C`float_hex\*(C' with default settings.</p>
  </dd>

</dl>

<h3>Comparison</h3>

<dl class='dl-vertical'>
  <dt>
    float_id_cmp(A, B)
  </dt>
  <dd>
    <p>This is a comparison function supplying a total ordering of floating point values.  A and B must both be floating point values.  Returns -1, 0, or +1, indicating whether A is to be sorted before, the same as, or after B. The ordering is of the identities of floating point values, not their numerical values.  If zeroes are signed, then the two types are considered to be distinct.  NaNs compare equal to each other, but different from all numeric values.  The exact ordering provided is mostly numerical order: NaNs come first, followed by negative infinity, then negative finite values, then negative zero, then positive (or unsigned) zero, then positive finite values, then positive infinity. In addition to sorting, this function can be useful to check for a zero of a particular sign.</p>
  </dd>
  <dt>
    totalorder(A, B)
  </dt>
  <dd>
    <p>This is a comparison function supplying a total ordering of floating point values.  A and B must both be floating point values.  Returns a truth value indicating whether A is to be sorted before-or-the-same-as B.  That is, it is a &lt;= predicate on the total ordering.  The ordering is the same as that provided by \*(C`float_id_cmp\*(C': NaNs come first, followed by negative infinity, then negative finite values, then negative zero, then positive (or unsigned) zero, then positive finite values, then positive infinity. This is an \s-1IEEE\s0 754r standard function.  According to the standard it is meant to distinguish different kinds of NaNs, based on their sign bit, quietness, and payload, but this function (like the rest of Perl) perceives only one NaN.</p>
  </dd>

</dl>

<h3>Manipulation</h3>

<dl class='dl-vertical'>
  <dt>
    pow2(\s-1EXP\s0)
  </dt>
  <dd>
    <p>\s-1EXP\s0 must be an integer.  Returns the value two the the power \s-1EXP\s0. \*(C`die\*(C's if that value cannot be represented exactly as a floating point value.  The return value may be either normalised or subnormal.</p>
  </dd>
  <dt>
    mult_pow2(\s-1VALUE\s0, \s-1EXP\s0)
  </dt>
  <dd>
    <p>\s-1EXP\s0 must be an integer, and \s-1VALUE\s0 a floating point value.  Multiplies \s-1VALUE\s0 by two to the power \s-1EXP\s0.  This gives exact results, except in cases of underflow and overflow.  The range of \s-1EXP\s0 is not constrained. All normal floating point multiplication behaviour applies.</p>
  </dd>
  <dt>
    copysign(\s-1VALUE\s0, \s-1SIGN_FROM\s0)
  </dt>
  <dd>
    <p>\s-1VALUE\s0 and \s-1SIGN_FROM\s0 must both be floating point values.  Returns a floating point value with the magnitude of \s-1VALUE\s0 and the sign of \s-1SIGN_FROM\s0.  If \s-1SIGN_FROM\s0 is an unsigned zero then it is treated as positive.  If \s-1VALUE\s0 is an unsigned zero then it is returned unchanged. If \s-1VALUE\s0 is a NaN then it is returned unchanged.  If \s-1SIGN_FROM\s0 is a NaN then the sign copied to \s-1VALUE\s0 is unpredictable. This is an \s-1IEEE\s0 754 standard function.  According to the standard NaNs have a well-behaved sign bit, which can be read and modified by this function, but Perl only perceives one NaN and can't see its sign bit, so behaviour on NaNs is not standard-conforming.</p>
  </dd>
  <dt>
    nextup(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>\s-1VALUE\s0 must be a floating point value.  Returns the next representable floating point value adjacent to \s-1VALUE\s0 with a numerical value that is strictly greater than \s-1VALUE\s0, or returns \s-1VALUE\s0 unchanged if there is no such value.  Infinite values are regarded as being adjacent to the largest representable finite values.  Zero counts as one value, even if it is signed, and it is adjacent to the smallest representable positive and negative finite values.  If a zero is returned, because \s-1VALUE\s0 is the smallest representable negative value, and zeroes are signed, it is a negative zero that is returned.  Returns NaN if \s-1VALUE\s0 is a NaN. This is an \s-1IEEE\s0 754r standard function.</p>
  </dd>
  <dt>
    nextdown(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>\s-1VALUE\s0 must be a floating point value.  Returns the next representable floating point value adjacent to \s-1VALUE\s0 with a numerical value that is strictly less than \s-1VALUE\s0, or returns \s-1VALUE\s0 unchanged if there is no such value.  Infinite values are regarded as being adjacent to the largest representable finite values.  Zero counts as one value, even if it is signed, and it is adjacent to the smallest representable positive and negative finite values.  If a zero is returned, because \s-1VALUE\s0 is the smallest representable positive value, and zeroes are signed, it is a positive zero that is returned.  Returns NaN if \s-1VALUE\s0 is a NaN. This is an \s-1IEEE\s0 754r standard function.</p>
  </dd>
  <dt>
    nextafter(\s-1VALUE\s0, \s-1DIRECTION\s0)
  </dt>
  <dd>
    <p>\s-1VALUE\s0 and \s-1DIRECTION\s0 must both be floating point values.  Returns the next representable floating point value adjacent to \s-1VALUE\s0 in the direction of \s-1DIRECTION\s0, or returns \s-1DIRECTION\s0 if it is numerically equal to \s-1VALUE\s0.  Infinite values are regarded as being adjacent to the largest representable finite values.  Zero counts as one value, even if it is signed, and it is adjacent to the positive and negative smallest representable finite values.  If a zero is returned and zeroes are signed then it has the same sign as \s-1VALUE\s0.  Returns NaN if either argument is a NaN. This is an \s-1IEEE\s0 754 standard function.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>As of Perl 5.8.7 floating point zeroes will be partially transformed into integer zeroes if used in almost any arithmetic, including numerical comparisons.  Such a transformed zero appears as a floating point zero (with its original sign) for some purposes, but behaves as an integer zero for other purposes.  Where this happens to a positive zero the result is indistinguishable from a true integer zero.  Where it happens to a negative zero the result is a fourth type of zero, the existence of which is a bug in Perl.  This fourth type of zero will give confusing results, and in particular will elicit inconsistent behaviour from the functions in this module.</p><p>Because of this transforming behaviour, it is best to avoid relying on the sign of zeroes.  If you require signed-zero semantics then take special care to maintain signedness.  Avoid using a zero directly in arithmetic and handle it as a special case.  Any flavour of zero can be accurately copied from one scalar to another without affecting the original.  The functions in this module all avoid modifying their arguments, and where they are meant to return signed zeroes they always return a pristine one.</p><p>As of Perl 5.8.7 stringification of a floating point zero does not preserve its signedness.  The number-to-string-to-number round trip turns a positive floating point zero into an integer zero, but accurately maintains negative and integer zeroes.  If a negative zero gets partially transformed into an integer zero, as described above, the stringification that it gets is based on its state at the first occasion on which the scalar was stringified.</p><p>NaN handling is generally not well defined in Perl.  Arithmetic with a mathematically undefined result may either \*(C`die\*(C' or generate a NaN. Avoid relying on any particular behaviour for such operations, even if your hardware's behaviour is known.</p><p>As of Perl 5.8.7 the <strong>%</strong> operator truncates its arguments to integers, if the divisor is within the range of the native integer type.  It therefore operates correctly on non-integer values only when the divisor is very large.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Data::Float&hellip;</h2>
        <div class="sectioncontent">
<p>Data::Integer, Scalar::Number, <em>perlnumber</em>\|(1)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2006, 2007, 2008, 2010, 2012 Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Data::Faker::StreetAddress.3pm.html"><span aria-hidden="true">&larr;</span> Data::Faker::StreetAddress.3pm: Data::faker plugin</a></li>
   <li class="next"><a href="Data::Flow.3pm.html">Data::Flow.3pm: Perl extension for simple-minded recipe-controlled build of data. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

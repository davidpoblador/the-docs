<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tangram::Tour: Guided tour</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Guided tour">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Tangram::Tour (3pm) manual">
  <meta name="twitter:description" content="Guided tour">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtangram-perl-Tangram::Tour-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Tangram::Tour.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Tangram::Tour (3pm) manual" />
  <meta property="og:description" content="Guided tour" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtangram-perl-Tangram::Tour-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Tangram::Tour<small> (3pm)</small></h1>
        <p class="lead">Guided tour</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Tangram::Tour.3pm.html">
      <span itemprop="name">Tangram::Tour: Guided tour</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtangram-perl/">
      <span itemprop="name">libtangram-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Tangram::Tour.3pm.html">
      <span itemprop="name">Tangram::Tour: Guided tour</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>In this tour, we add persistence to a simple Person design.</p><p>A Person is either a NaturalPerson or a LegalPerson. Persons (in general) have a collection of addresses.</p><p>An address consists in a type (a string) and a city (also a string).</p><p>NaturalPerson - a subclass of Person - represents persons of flesh and blood. NaturalPersons have a name and a firstName (both strings) and an age (an integer). NaturalPersons sometimes have a partner (another NaturalPerson) and even children (a collection of NaturalPersons).</p><p>LegalPerson - another subclass of Person - represents companies and other entities that the law regards as 'persons'. A LegalPerson has a name (a string) and a manager (a NaturalPerson).</p><p>All this is expressed in the following \s-1UML\s0 diagram:</p>
<pre>
                       +---------------------+        +--------------+
                       |       Person        |        |    Address   |
                       |     { abstract }    |1&lt;&gt;--&gt;-*|--------------|
                       |---------------------|        | kind: string |
                       +---------------------+        | city: string |
                                   |                  +--------------+
                                   |
                    +--------------A--------------+
                    |                             |
          +-------------------+           +---------------+
      +--*|   NaturalPerson   |           |  LegalPerson  |
      |   |-------------------|manager    |---------------|
      V   | firstName: string |1---&lt;-----1| name: string  |
      |   | name: string      |           +---------------+
      +--*| age: integer      |
 children +-------------------+
                1       1
                |    partner
                |       |
                +---&gt;---+
</pre>
<p><strong>Note that Tangram does </strong><strong>not</strong><strong> create the corresponding Perl</strong> packages!. That's up to the user. However, to facilitate experimentation, Tangram comes with a module that implements the necessary classes. For more information see Tangram::Springfield.</p><p>Before we can actually store objects we must complete two steps:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Create a Schema</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Create a database</p>
  </dd>

</dl>
<h3>Creating a Schema</h3>
<p>A Schema object contains information about the persistent aspects of a system of classes.</p><p>It also gives a degree of control over the way Tangram performs the object-relational mapping, but in this tour we will use all the defaults.</p><p>Here is the Schema for Springfield:</p><p>   $schema = Tangram::Relational-&gt;schema( {</p><p>      classes =&gt; [</p><p>       Person =&gt; {           abstract =&gt; 1,</p><p>          fields =&gt; {               iarray =&gt; {                  addresses =&gt; { class =&gt; &apos;Address&apos;, aggreg =&gt; 1 } }           }        },</p><p>      Address =&gt; {          fields =&gt; {             string =&gt; [ qw( kind city ) ],          },       },</p><p>      NaturalPerson =&gt; {</p><p>         bases =&gt; [ qw( Person ) ],</p><p>         fields =&gt; {             string   =&gt; [ qw( firstName name ) ],             int      =&gt; [ qw( age ) ],             ref      =&gt; [ qw( partner ) ],             array    =&gt; { children =&gt; &apos;NaturalPerson&apos; },          }       },</p><p>      LegalPerson =&gt; {          bases =&gt; [ qw( Person ) ],</p><p>         fields =&gt; {             string   =&gt; [ qw( name ) ],             ref      =&gt; [ qw( manager ) ],             }          },    ] } );</p><p>The Schema lists all the classes that need persistence, along with their attributes and the inheritance relationships.  We must provide type information for the attributes, because \s-1SQL\s0 is more typed than Perl.  We also tell Tangram that \*(C`Person\*(C' is an abstract class, so it wastes no time attempting to retrieve objects of that exact class.</p><p>Note that Tangram cannot deduce this information by itself. While Perl makes it possible to extract the list of all the classes in an application, in general not all classes will need to persist. A class may have both persistent and non-persistent bases.  As for attributes, Perl's most typical representation for objects - a hash - even allows two objects of the same class to have a different set of attributes.</p><p>For more information on creating Schemas, see Tangram::Relational and  Tangram::Schema.</p>
<h3>Setting up a database</h3>
<p>Now we create a database. The simplest way is to create an empty database and let Tangram initialize it:</p>
<pre>
    use Tangram;
</pre>
<p>    $dbh = DBI-&gt;connect(         @cp );</p><p>    Tangram::Relational-&gt;deploy($schema, $dbh );</p><p>    $dbh-&gt;disconnect();</p><p>Tangram::Relational is the vanilla object-relational backend. It assumes that the database understands standard \s-1SQL\s0, and that both the database and the related \s-1DBI\s0 driver fully implements the \s-1DBI\s0 specification.</p><p>Tangram also comes with vendor-specific backends for Mysql and Sybase. When a vendor-specific backend exists, it should be used in place of the vanilla backend.</p><p>For more information, see Tangram::Relational, Tangram::Sybase and Tangram::mysql.</p>
<h3>Connecting to a database</h3>
<p>We are now ready to store objects. First we connect to the database, using the class method Tangram::Relational::connect (or Tangram::mysql::connect for Mysql).</p><p>The first argument of <em>connect()</em> the schema object; the others are passed directly to DBI::connect. The method returns a Tangram::Storage object that will be used to communicate with the database.</p><p>For example:</p><p>    $storage = Tangram::Relational-&gt;connect( $schema,         @cp );</p><p>connects to a database named Springfield via the vanilla Relational backend, using a specific account and password.</p><p>For more information on connecting to databases, see  Tangram::Relational and Tangram::Storage.</p>
<h3>Inserting objects</h3>
<p>Now we can populate the database:</p><p>   $storage-&gt;insert( NaturalPerson-&gt;new(       firstName =&gt; &apos;Montgomery&apos;, name =&gt; &apos;Burns&apos; ) );</p><p>This inserts a single NaturalPerson object into the database. We can insert several objects in one call:</p><p>   $storage-&gt;insert(       NaturalPerson-&gt;new( firstName =&gt; &apos;Patty&apos;, name =&gt; &apos;Bouvier&apos; ),       NaturalPerson-&gt;new( firstName =&gt; &apos;Selma&apos;, name =&gt; &apos;Bouvier&apos; ) );</p><p>Sometimes Tangram saves objects implicitly:</p><p>    @kids = (         NaturalPerson-&gt;new( firstName =&gt; &apos;Bart&apos;, name =&gt; &apos;Simpson&apos; ),         NaturalPerson-&gt;new( firstName =&gt; &apos;Lisa&apos;, name =&gt; &apos;Simpson&apos; ) );</p><p>    $marge = NaturalPerson-&gt;new(         firstName =&gt; &apos;Marge&apos;, name =&gt; &apos;Simpson&apos;,         addresses =&gt; [             Address-&gt;new(                 kind =&gt; &apos;residence&apos;, city =&gt; &apos;Springfield&apos; ) ],         children =&gt; [ @kids ] );</p><p>    $homer = NaturalPerson-&gt;new( firstName =&gt; &apos;Homer&apos;, name =&gt; &apos;Simpson&apos;,         addresses =&gt; [             Address-&gt;new(                 kind =&gt; &apos;residence&apos;, city =&gt; &apos;Springfield&apos; ),             Address-&gt;new(                 kind =&gt; &apos;work&apos;, city =&gt; &apos;Springfield&apos; ) ],         children =&gt; [ @kids ] );</p><p>    $homer-&gt;{partner} = $marge;     $marge-&gt;{partner} = $homer;</p><p>    $homer_id = $storage-&gt;insert( $homer );</p><p>In the process of saving Homer, Tangram detects that it contains references to objects that are not persistent yet (Marge, the addresses and the kids), and inserts them automatically. Note that Tangram can handle cycles: Homer and Marge refer to each other.</p><p><em>insert()</em> returns an object id, or a list of object ids, that uniquely identify the object(s) that have been inserted.</p><p>For more information on inserting objects, see Tangram::Storage.</p>
<h3>Updating objects</h3>
<p>Updating works pretty much the same as inserting:</p><p>    my $maggie = NaturalPerson-&gt;new(       firstName =&gt; &apos;Maggie&apos;, name =&gt; &apos;Simpson&apos; );</p><p>    push @{ $homer-&gt;{children} }, $maggie;     push @{ $marge-&gt;{children} }, $maggie;</p><p>    $storage-&gt;update( $homer, $marge );</p><p>Here again Tangram detects that Maggie is not already persistent in $storage and automatically inserts it. Note that we need to update Marge explicitly because she was already persistent.</p><p>For more information on updating objects, see Tangram::Storage.</p>
<h3>Memory management</h3>
<p>...is still up to you. Tangram won't break in-memory cycles, it's a persistence tool, not a memory management tool. Let's make sure we don't leak objects:</p><p>   $homer-&gt;{partner} = undef; # do this before $homer goes out of scope</p><p>Also, when we're finished with a storage, we can explicitly disconnect it:</p><p>   $storage-&gt;disconnect();</p><p>Whether it's important or not to disconnect the Storage depends on what version of Perl you use. If it's prior to 5.6, you <em>must</em> disconnect the storage explicitly (or at least call <em>unload()</em>) otherwise the Storage will prevent the objects it controls from being reclaimed by Perl. For more information see see Tangram::Storage.</p>
<h3>Finding objects</h3>
<p>After reconnecting to Springfield, we now want to retrieve some objects. But how do we find them? Basically there are three options</p><ul>
<li><p>We know their IDs.</p></li><li><p>We obtain them from another object.</p></li><li><p>We use a query.</p></li>
</ul>
<h3>Loading by \s-1ID\s0</h3>
<p>When an object is inserted, Tangram assigns an identifier to it. IDs are numbers that uniquely identify objects in the database. \*(C`insert\*(C' returns the \s-1ID\s0(s) of the object(s) it was passed:</p><p>    $storage = Tangram::Relational-&gt;connect( $schema,         @cp );</p><p>    $ned_id = $storage-&gt;insert( NaturalPerson-&gt;new(         firstNname =&gt; &apos;Ned&apos;, name =&gt; &apos;Flanders&apos; ) );</p><p>    @sisters_id = $storage-&gt;insert(         NaturalPerson-&gt;new( firstName =&gt; &apos;Patty&apos;, name =&gt; &apos;Bouvier&apos; ),         NaturalPerson-&gt;new( firstName =&gt; &apos;Selma&apos;, name =&gt; &apos;Bouvier&apos; ) );</p><p>This enables us to retrieve the objects:</p><p>    $ned = $storage-&gt;load( $ned_id );     @sisters = $storage-&gt;load( @sisters_id );</p><p>For more information on loading objects by id, see Tangram::Storage.</p>
<h3>Obtaining objects from other objects</h3>
<p>Once Homer has been restored to his previous state, including his relations with his family. Thus we can say:</p><p>    $storage = Tangram::Relational-&gt;connect( $schema,         @cp );</p><p>    $homer = $storage-&gt;load( $homer_id ); # load by id</p><p>    $marge = $homer-&gt;{partner};     @kids = @{ $homer-&gt;{children} };</p><p>Actually, when Tangram loads an object that contains references to other persistent objects, it doesn't retrieve the referenced objects immediately. Marge is retrieved only when Homer's 'partner' field is accessed.  This mechanism is almost totally transparent, we'd have to use \*(C`tied\*(C' to observe a non-present collection or reference.</p><p>For more information on relationships, see Tangram::Schema, Tangram::Type::Ref::FromMany, Tangram::Type::Array::FromMany, Tangram::Type::Array::FromOne, Tangram::Type::Set::FromMany and Tangram::Type::Set::FromOne.</p>
<h3>select</h3>
<p>To retrieve all the objects of a given class, we use \*(C`select\*(C':</p><p>    $storage = Tangram::Relational-&gt;connect( $schema,         @cp );</p><p>    my @people = $storage-&gt;select( &apos;NaturalPerson&apos; );</p><p>Tangram supports polymorphic retrieval. Let's first insert a LegalPerson:</p><p>    $storage-&gt;insert( LegalPerson-&gt;new(         name =&gt; &apos;Springfield Nuclear Power Plant&apos;, manager =&gt; $burns ) );</p><p>Now we can retrieve all the Persons - Natural or Legal - by making a single call to <em>select()</em>, passing it the base class name:</p><p>    my @all = $storage-&gt;select( &apos;Person&apos; );</p><p>For more information on <em>select()</em>, see Tangram::Storage.</p>
<h3>Filtering</h3>
<p>Usually we won't want to load <em>all</em> the NaturalPersons, only those objects that satisfy some condition. Say, for example, that we want to load only the NaturalPersons whose name field is 'Simpson'. Here's how this can be done:</p><p>    my $person = $storage-&gt;remote( &apos;NaturalPerson&apos; );     my @simpsons = $storage-&gt;select( $person, $person-&gt;{name} eq &apos;Simpson&apos; );</p><p>This will bring in memory only the Simpsons; Burns or the Bouvier sisters won't turn up.  The filtering happens on the database server side, not in Perl space. Internally, Tangram translates the \*(C`$person-\*(C'{name} eq 'Simpson'&gt; clause into a piece of \s-1SQL\s0 code that is passed down to the database.</p><p>The above example only begins to scratch the surface of Tangram's filtering capabilities. The following examples are all legal and working code:</p><p>    # find all the persons *not* named Simpson</p><p>    my $person = $storage-&gt;remote( &apos;NaturalPerson&apos; );     my @others = $storage-&gt;select( $person, $person-&gt;{name} ne &apos;Simpson&apos; );</p><p>    # same thing in a different way</p><p>    my $person = $storage-&gt;remote( &apos;NaturalPerson&apos; );     my @others = $storage-&gt;select( $person, !($person-&gt;{name} eq &apos;Simpson&apos;) );</p><p>    # find all the persons who are older than me</p><p>    my $person = $storage-&gt;remote( &apos;NaturalPerson&apos; );     my @elders = $storage-&gt;select( $person, $person-&gt;{age} &gt; 35 );</p><p>    # find all the Simpsons older than me</p><p>    my $person = $storage-&gt;remote( &apos;NaturalPerson&apos; );     my @simpsons = $storage-&gt;select( $person,         $person-&gt;{name} eq &apos;Simpson&apos; & $person-&gt;{age} &gt; 35 );</p><p>    # find Homer&apos;s wife - note that select *must* be called in list context</p><p>    my ($person1, $person2) = $storage-&gt;remote(         qw( NaturalPerson NaturalPerson ));</p><p>    my ($marge) = $storage-&gt;select( $person1,         $person1-&gt;{partner} == $person2         & $person2-&gt;{firstName} eq &apos;Homer&apos; & $person2-&gt;{name} eq &apos;Simpson&apos; );</p><p>    # find Homer&apos;s wife - this time Homer is already in memory</p><p>    my $homer = $storage-&gt;load( $homer_id );     my $person = $storage-&gt;remote( &apos;NaturalPerson&apos; );</p><p>    my ($marge) = $storage-&gt;select( $person,         $person-&gt;{partner} == $homer );</p><p>    # find everybody who works in Springfield</p><p>    my $address = $storage-&gt;remote( &apos;Address&apos; );</p><p>    my @population = $storage-&gt;select( $person,         $person-&gt;{addresses}-&gt;includes( $address )         & $address-&gt;{kind} eq &apos;work&apos;         & $address-&gt;{city} eq &apos;Springfield&apos;);</p><p>    # find the parents of Bart Simpson</p><p>    my ($person1, $person2) = $storage-&gt;remote(         qw( NaturalPerson NaturalPerson ));</p><p>    my @parents = $storage-&gt;select( $person1,         $person1-&gt;{children}-&gt;includes( $person2 )            & $person2-&gt;{firstName} eq &apos;Bart&apos;            & $person2-&gt;{name} eq &apos;Simpson&apos; );</p><p>    # load Bart     my ($bart) = $storage-&gt;select( $person1, $person1-&gt;{firstName} eq &apos;Bart&apos;);</p><p>    # find the parents of Bart, this time given an object already loaded     my $person = $storage-&gt;remote( &apos;NaturalPerson&apos; );</p><p>    @parents = $storage-&gt;select( $person,         $person-&gt;{children}-&gt;includes( $bart ) );</p><p>Note that Tangram uses a single ampersand (&) or vertical bar (|) to represent logical conjunction or disjunction, not the usual && or ||. This is due to a limitation in Perl's operator overloading mechanism. Make sure you never forget this, because, unfortunately, using && or || in place of & or | is not even a syntax error :(</p><p>Finally, Tangram make it possible to retrieve tuples of related objects:</p><p>    my ($parent, $child) = $storage-&gt;remote(&apos;NaturalPerson&apos;, &apos;NaturalPerson&apos;);</p><p>    @pairs = $storage-&gt;select( [ $parent, $child ],         $parent-&gt;{children}-&gt;includes($child) );</p><p>@pairs contains a list of references to arrays of size two; each array contains a pair of parent and child.</p><p>For more information on filters, see Tangram::Expr and Tangram::Remote.</p>
<h3>Cursors</h3>
<p>Cursors provide a way of retrieving objects one at a time.  This is important is the result set is potentially large.  <em>cursor()</em> takes the same arguments as <em>select()</em> and returns a Cursor objects that can be used to iterate over the result set via methods <em>current()</em> and <em>next()</em>:</p><p>    $storage = Tangram::Relational-&gt;connect( $schema,         @cp );</p><p>    # iterate over all the NaturalPersons in storage</p><p>    my $cursor = $storage-&gt;cursor( &apos;NaturalPerson&apos; );</p><p>    while (my $person = $cursor-&gt;current())     {         # process $person         $cursor-&gt;next();     }</p><p>    $cursor-&gt;close();</p><p>The Cursor will be automatically closed when $cursor is garbage-collected, but Perl doesn't define just when that may happen :( Thus it's a good idea to explicitly close the cursor.</p><p>Each Cursor uses a separate connection to the database. Consequently you can have several cursors open at the same, all with pending results. Of course, mixing reads and writes to the same tables can result in deadlocks.</p><p>For more information on cursors, see Tangram::Storage and Tangram::Cursor.</p>
<h3>Remote objects</h3>
<p>At this point, most people wonder what $person <em>exactly</em> is and how it all works.  This section attempts to give an idea of the mechanisms that are used.</p><p>In Tangram terminology, $person a <em>remote</em> object. Its Perl class is Tangram::Remote, but it's really a placeholder for an object of class \*(C`NaturalPerson\*(C' <em>in the database</em>, much like a table alias in SQL-speak.</p><p>When you request a remote object of a given class, Tangram arranges that the remote object <em>looks like</em> an object of the said class. It <em>seems</em> to have the same fields as a regular object, but don't be misled, it's not the real thing, it's just a way of providing a nice syntax.</p><p>If you dig it, you'll find out that a Remote is just a hash of Tangram::Expr objects.  When you say $homer-&gt;{name}, an Expr is returned, which, most of the time, can be used like any ordinary Perl scalar. However, an Expr represents a value <em>in the database</em>, it's the equivalent of Remote, only for expressions, not for objects.</p><p>Expr objects that represent scalar values (e.g. ints, floats, strings) can be compared between them, or compared with straight Perl scalars. Reference-like Exprs can be compared between themselves and with references</p><p>Expr objects that represent collections have an \*(C`include\*(C' methods that take a persistent object, a Remote object or an \s-1ID\s0.</p><p>The result of comparing Exprs (or calling \*(C`include\*(C') is a Tangram::Expr::Filter that will translate into part of the \s-1SQL\s0 where-clause that will be passed to the \s-1RDBMS\s0.</p><p>For more information on remote objects, see Tangram::Remote.</p>
<h3>Multiple loads</h3>
<p>What happens when we load the same object twice? Consider:</p><p>    my $person = $storage-&gt;remote( &apos;NaturalPerson&apos; );     my @simpsons = $storage-&gt;select( $person, $person-&gt;{name} eq &apos;Simpson&apos; );</p><p>    my @people = $storage-&gt;select( &apos;NaturalPerson&apos; );</p><p>Obviously Homer Simpson will be retrieved by both selects. Are there two Homers in memory now? Fortunately not. There is only one copy of Homer in memory. When Tangram load an object, it checks whether an object with the same \s-1ID\s0 is alredy present. If yes, it keeps the old copy, which is desirable, since we may have changed it already.</p><p>Incidentally, this explains why a Storage will hold objects in memory - until disconnected (again, this will change when Perl supports weak references).</p>
<h3>Transactions</h3>
<p>Tangram wraps database transactions in a object-oriented interface:</p><p>    $storage-&gt;tx_start();     $homer-&gt;{partner} = $marge;     $marge-&gt;{partner} = $homer;     $storage-&gt;update( $homer, $marge );     $storage-&gt;tx_commit();</p><p>Both Marge and Homer will be updated, or none will. <em>tx_rollback()</em> drops the changes.</p><p>Tangram does not emulate transactions for databases that do not support them (like earlier versions of mySql).</p><p>Unlike \s-1DBI\s0, Tangram allows the nested transactions:</p><p>    $storage-&gt;tx_start();</p><p>    {         $storage-&gt;tx_start();         $patty-&gt;{partner} = $selma;         $selma-&gt;{partner} = $patty;         $storage-&gt;tx_commit();     }</p><p>    $homer-&gt;{partner} = $marge;     $marge-&gt;{partner} = $homer;     $storage-&gt;update( $homer, $marge );</p><p>    $storage-&gt;tx_commit();</p><p>Tangram uses a single database transaction, but commits it only when the <em>tx_commit()</em>s exactly balance the <em>tx_start()</em>s. Thanks to this feature any piece of code can open all the transactions it needs and still cooperate smoothly with the rest of the application.  If a \s-1DBI\s0 transaction is already active, it will be reused; otherwise a new one will be started.</p><p>Tangram offer a more robust alternative to the start/commit code sandwich.  <em>tx_do()</em> calls \s-1CODEREF\s0 in a transaction. If the \s-1CODEREF\s0 dies, the transaction is rolled back; otherwise it's committed.  The first example can be rewritten:</p><p>    $storage-&gt;tx_do( sub {         $homer-&gt;{partner} = $marge;         $marge-&gt;{partner} = $homer;         $storage-&gt;update( $homer, $marge };         } );</p><p>For more information on transactions, see Tangram::Storage.</p>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Tangram::Sucks.3pm.html"><span aria-hidden="true">&larr;</span> Tangram::Sucks.3pm: What there is to be improved in tangram</a></li>
   <li class="next"><a href="Tangram::Type.3pm.html">Tangram::Type.3pm: Mapping individual fields <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Authen::Passphrase: Hashed passwords/passphrases as objects</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Hashed passwords/passphrases as objects">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Authen::Passphrase (3pm) manual">
  <meta name="twitter:description" content="Hashed passwords/passphrases as objects">
  <meta name="twitter:image" content="https://www.carta.tech/images/libauthen-passphrase-perl-Authen::Passphrase-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Authen::Passphrase.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Authen::Passphrase (3pm) manual" />
  <meta property="og:description" content="Hashed passwords/passphrases as objects" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libauthen-passphrase-perl-Authen::Passphrase-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Authen::Passphrase<small> (3pm)</small></h1>
        <p class="lead">Hashed passwords/passphrases as objects</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Authen::Passphrase.3pm.html">
      <span itemprop="name">Authen::Passphrase: Hashed passwords/passphrases as objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libauthen-passphrase-perl/">
      <span itemprop="name">libauthen-passphrase-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Authen::Passphrase.3pm.html">
      <span itemprop="name">Authen::Passphrase: Hashed passwords/passphrases as objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        use Authen::Passphrase;

        $ppr = Authen::Passphrase-&gt;from_crypt($passwd);
        $ppr = Authen::Passphrase-&gt;from_rfc2307($userPassword);

        if($ppr-&gt;match($passphrase)) { ...

        $passphrase = $ppr-&gt;passphrase;

        $crypt = $ppr-&gt;as_crypt;
        $userPassword = $ppr-&gt;as_rfc2307;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is the base class for a system of objects that encapsulate passphrases.  An object of this type is a passphrase recogniser: its job is to recognise whether an offered passphrase is the right one. For security, such passphrase recognisers usually do not themselves know the passphrase they are looking for; they can merely recognise it when they see it.  There are many schemes in use to achieve this effect, and the intent of this class is to provide a consistent interface to them all, hiding the details.</p><p>The \s-1CPAN\s0 package Authen-Passphrase contains implementations of several specific passphrase schemes in addition to the base class.  See the specific classes for notes on the security properties of each scheme. In new systems, if there is a choice of which passphrase algorithm to use, it is recommended to use Authen::Passphrase::SaltedDigest or Authen::Passphrase::BlowfishCrypt.  Most other schemes are too weak for new applications, and should be used only for backward compatibility.</p><h3>Side-channel cryptanalysis</h3>
<p>Both the Authen-Passphrase framework and most of the underlying cryptographic algorithm implementations are vulnerable to side-channel cryptanalytic attacks.  However, the impact of this is quite limited.</p><p>Unlike the case of symmetric encryption, where a side-channel attack can extract the plaintext directly, the cryptographic operations involved in passphrase recognition don't directly process the correct passphrase. A sophisticated side-channel attack, applied when offering incorrect passphrases for checking, could potentially extract salt (from the operation of the hashing algorithm) and the target hash value (from the comparison of hash values).  This would enable a cryptanalytic or brute-force attack on the passphrase recogniser to be performed offline. This is not a disaster; the very intent of storing only a hash of the correct passphrase is that leakage of these stored values doesn't compromise the passphrase.</p><p>In a typical usage scenario for this framework, the side-channel attacks that can be mounted are very restricted.  If authenticating network users, typically an attacker has no access at all to power consumption, electromagnetic emanation, and other such side channels.  The only side channel that is readily available is timing, and the precision of timing measurements is significantly blunted by the normal processes of network communication.  For example, it would not normally be feasible to mount a timing attack against hash value comparison (to see how far through the values the first mismatch was).</p><p>Perl as a whole has not been built as a platform for side-channel-resistant cryptography, so hardening Authen-Passphrase and its underlying algorithms is not feasible.  In any serious use of Perl for cryptography, including for authentication using Authen-Passphrase, an analysis should be made of the exposure to side-channel attacks, and if necessary efforts made to further blunt the timing channel.</p><p>One timing attack that is very obviously feasible over the network is to determine which of several passphrase hashing algorithms is being used. This can potentially distinguish between classes of user accounts, or distinguish between existing and non-existing user accounts when an attacker is guessing usernames.  To obscure this information requires an extreme restriction of the timing channel, most likely by explicitly pausing to standardise the amount of time spent on authentication. This defence also rules out essentially all other timing attacks.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PASSPHRASE ENCODINGS</h2>
        <div class="sectioncontent">
<p>Because hashed passphrases frequently need to be stored, various encodings of them have been devised.  This class has constructors and methods to support these.</p><h3>crypt encoding</h3>
<p>The Unix <em>crypt()</em> function, which performs passphrase hashing, returns hashes in a textual format intended to be stored in a text file. In particular, such hashes are stored in /etc/passwd (and now /etc/shadow) to control access to Unix user accounts.  The same textual format has been adopted and extended by other passphrase-handling software such as password crackers.</p><p>For historical reasons, there are several different syntaxes used in this format.  The original DES-based password scheme represents its hashes simply as a string of thirteen base 64 digits.  An extended variant of this scheme uses nineteen base 64 digits, preceded by an "<strong>_</strong>\*(L" marker. A more general syntax was developed later, which starts the string with \*(R"<strong>$</strong>\*(L", an alphanumeric scheme identifier, and another \*(R"<strong>$</strong>".</p><p>In addition to actual passphrase hashes, the crypt format can also represent a couple of special cases.  The empty string indicates that there is no access control; it is possible to login without giving a passphrase.  Finally, any string that is not a possible output of <em>crypt()</em> may be used to prevent login completely; "<strong>*</strong>" is the usual choice, but other strings are used too.</p><p>crypt strings are intended to be used in text files that use colon and newline characters as delimiters.  This module treats the crypt string syntax as being limited to \s-1ASCII\s0 graphic characters excluding colon.</p>
<h3>\s-1RFC\s0 2307 encoding</h3>
<p>\s-1RFC\s0 2307 describes an encoding system for passphrase hashes, to be used in the "<strong>userPassword</strong>\*(L" attribute in \s-1LDAP\s0 databases.  It encodes hashes as \s-1ASCII\s0 text, and supports several passphrase schemes in an extensible way by starting the encoding with an alphanumeric scheme identifier enclosed in braces.  There are several standard scheme identifiers. The \*(R"<strong>{\s-1CRYPT\s0}</strong>" scheme allows the use of any crypt encoding.</p><p>This module treats the \s-1RFC\s0 2307 string syntax as being limited to \s-1ASCII\s0 graphic characters.</p><p>The \s-1RFC\s0 2307 encoding is a good one, and is recommended for storage and exchange of passphrase hashes.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTORS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Authen::Passphrase-&gt;from_crypt(\s-1PASSWD\s0)
  </dt>
  <dd>
    <p>Returns a passphrase recogniser object matching the supplied crypt encoding.  This constructor may only be called on the base class, not any subclass. The specific passphrase recogniser class is loaded at runtime, so successfully loading \*(C`Authen::Passphrase\*(C' does not guarantee that it will be possible to use a specific type of passphrase recogniser. If necessary, check separately for presence and loadability of the recogniser class. Known scheme identifiers:</p><p>A baroque passphrase scheme based on \s-1MD5\s0, designed by Poul-Henning Kamp and originally implemented in FreeBSD.  See Authen::Passphrase::MD5Crypt. Two versions of a passphrase scheme based on Blowfish, designed by Niels Provos and David Mazieres for OpenBSD.  See Authen::Passphrase::BlowfishCrypt. The NT-Hash scheme, which stores the \s-1MD4\s0 hash of the passphrase expressed in Unicode.  See Authen::Passphrase::NTHash. Invision Power Board 2.x salted \s-1MD5\s0 Kerberos \s-1AFS\s0 \s-1DES\s0 Half of the Microsoft \s-1LAN\s0 Manager hash scheme.  The two halves of a \s-1LAN\s0 Manager hash can be separated and manipulated independently; this represents such an isolated half.  See Authen::Passphrase::LANManagerHalf. The NT-Hash scheme, which stores the \s-1MD4\s0 hash of the passphrase expressed in Unicode.  See Authen::Passphrase::NTHash. The <strong></strong><strong>$3</strong><strong>$</strong> identifier refers to the same hash algorithm, but has a slightly different textual format (an extra "<strong>$</strong>"). Portable \s-1PHP\s0 password hash (phpass), based on \s-1MD5\s0.  See Authen::Passphrase::PHPass. Three variants of the Purdy polynomial system used in \s-1VMS\s0. See Authen::Passphrase::VMSPurdy. Kerberos v4 \s-1TGT\s0 A variant of the <strong></strong><strong>$1</strong><strong>$</strong> scheme, used by Apache. Kerberos v5 \s-1TGT\s0</p><p>The historical formats supported are: ("<em>b</em>" represents a base 64 digit.)  The original DES-based Unix password hash scheme.  See Authen::Passphrase::DESCrypt. ("<em>b</em>" represents a base 64 digit.)  Extended DES-based passphrase hash scheme from BSDi.  See Authen::Passphrase::DESCrypt. Accept any passphrase.  See Authen::Passphrase::AcceptAll. To handle historical practice, anything non-empty but shorter than 13 characters and not starting with "<strong>$</strong>" is treated as deliberately rejecting all passphrases.  (See Authen::Passphrase::RejectAll.) Anything 13 characters or longer, or starting with "<strong>$</strong>", that is not recognised as a hash is treated as an error.</p><p>There are also two different passphrase schemes that use a crypt string consisting of 24 base 64 digits.  One is named \*(L"bigcrypt\*(R" and appears in HP-UX, Digital Unix, and \s-1OSF/1\s0 (see Authen::Passphrase::BigCrypt). The other is named \*(L"crypt16\*(R" and appears in Ultrix and Tru64 (see Authen::Passphrase::Crypt16).  These schemes conflict.  Neither of them is accepted as a crypt string by this constructor; such strings are regarded as invalid encodings.</p>
  </dd>
  <dt>
    Authen::Passphrase-&gt;from_rfc2307(\s-1USERPASSWORD\s0)
  </dt>
  <dd>
    <p>Returns a passphrase recogniser object matching the supplied \s-1RFC\s0 2307 encoding.  This constructor may only be called on the base class, not any subclass. The specific passphrase recogniser class is loaded at runtime.  See the note about this for the \*(L"from_crypt\*(R" constructor above. Known scheme identifiers:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>{\s-1CLEARTEXT\s0}</strong>
  </dt>
  <dd>
    <p>Passphrase stored in cleartext.  See Authen::Passphrase::Clear.</p>
  </dd>
  <dt>
    <strong>{\s-1CRYPT\s0}</strong>
  </dt>
  <dd>
    <p>The scheme identifier is followed by a crypt string.</p>
  </dd>
  <dt>
    <strong>{\s-1CRYPT16\s0}</strong>
  </dt>
  <dd>
    <p>Used ambiguously by Exim, to refer to either crypt16 (see Authen::Passphrase::Crypt16) or bigcrypt (see Authen::Passphrase::BigCrypt) depending on compilation options. This is a bug, resulting from a confusion between the two algorithms. This module does not support any meaning for this scheme identifier.</p>
  </dd>
  <dt>
    <strong>{K5KEY}</strong>
  </dt>
  <dd>
    <p>Not a real passphrase scheme, but a placeholder to indicate that a Kerberos key stored separately should be checked against.  No data follows the scheme identifier.</p>
  </dd>
  <dt>
    <strong>{\s-1KERBEROS\s0}</strong>
  </dt>
  <dd>
    <p>Not a real passphrase scheme, but a placeholder to indicate that Kerberos should be invoked to check against a user's passphrase. The scheme identifier is followed by the user's username, in the form "<em>name</em><strong>@</strong><em>realm</em>".</p>
  </dd>
  <dt>
    <strong>{\s-1LANM\s0}</strong>
  </dt>
  <dd>
    <p>Synonym for <strong>{\s-1LANMAN\s0}</strong>, used by CommuniGate Pro.</p>
  </dd>
  <dt>
    <strong>{\s-1LANMAN\s0}</strong>
  </dt>
  <dd>
    <p>The Microsoft \s-1LAN\s0 Manager hash scheme.  See Authen::Passphrase::LANManager.</p>
  </dd>
  <dt>
    <strong>{\s-1MD4\s0}</strong>
  </dt>
  <dd>
    <p>The \s-1MD4\s0 digest of the passphrase is stored.  See Authen::Passphrase::SaltedDigest.</p>
  </dd>
  <dt>
    <strong>{\s-1MD5\s0}</strong>
  </dt>
  <dd>
    <p>The \s-1MD5\s0 digest of the passphrase is stored.  See Authen::Passphrase::SaltedDigest.</p>
  </dd>
  <dt>
    <strong>{\s-1MSNT\s0}</strong>
  </dt>
  <dd>
    <p>The NT-Hash scheme, which stores the \s-1MD4\s0 hash of the passphrase expressed in Unicode.  See Authen::Passphrase::NTHash.</p>
  </dd>
  <dt>
    <strong>{\s-1NS-MTA-MD5\s0}</strong>
  </dt>
  <dd>
    <p>An MD5-based scheme used by Netscape Mail Server.  See Authen::Passphrase::NetscapeMail.</p>
  </dd>
  <dt>
    <strong>{\s-1RMD160\s0}</strong>
  </dt>
  <dd>
    <p>The \s-1RIPEMD-160\s0 digest of the passphrase is stored.  See Authen::Passphrase::SaltedDigest.</p>
  </dd>
  <dt>
    <strong>{\s-1SASL\s0}</strong>
  </dt>
  <dd>
    <p>Not a real passphrase scheme, but a placeholder to indicate that \s-1SASL\s0 should be invoked to check against a user's passphrase.  The scheme identifier is followed by the user's username.</p>
  </dd>
  <dt>
    <strong>{\s-1SHA\s0}</strong>
  </dt>
  <dd>
    <p>The \s-1SHA-1\s0 digest of the passphrase is stored.  See Authen::Passphrase::SaltedDigest.</p>
  </dd>
  <dt>
    <strong>{\s-1SMD5\s0}</strong>
  </dt>
  <dd>
    <p>The \s-1MD5\s0 digest of the passphrase plus a salt is stored.  See Authen::Passphrase::SaltedDigest.</p>
  </dd>
  <dt>
    <strong>{\s-1SSHA\s0}</strong>
  </dt>
  <dd>
    <p>The \s-1SHA-1\s0 digest of the passphrase plus a salt is stored. See Authen::Passphrase::SaltedDigest.</p>
  </dd>
  <dt>
    <strong>{\s-1UNIX\s0}</strong>
  </dt>
  <dd>
    <p>Not a real passphrase scheme, but a placeholder to indicate that Unix mechanisms should be used to check against a Unix user's login passphrase. The scheme identifier is followed by the user's username.</p>
  </dd>
  <dt>
    <strong>{\s-1WM-CRY\s0}</strong>
  </dt>
  <dd>
    <p>Synonym for <strong>{\s-1CRYPT\s0}</strong>, used by CommuniGate Pro.</p>
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>Checks whether the supplied passphrase is correct.  Returns a truth value. If a matching passphrase can be easily determined by the passphrase recogniser then this method will return it.  This is only feasible for very weak passphrase schemes.  The method \*(C`die\*(C's if it is infeasible. Encodes the passphrase recogniser in crypt format and returns the encoded result.  \*(C`die\*(C's if the passphrase recogniser cannot be represented in this form. Encodes the passphrase recogniser in \s-1RFC\s0 2307 format and returns the encoded result.  \*(C`die\*(C's if the passphrase recogniser cannot be represented in this form.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING</h2>
        <div class="sectioncontent">
<p>This class is designed to be subclassed, and cannot be instantiated alone. Any subclass must implement the \*(L"match\*(R" method.  That is the minimum required.</p><p>Subclasses should implement the \*(L"as_crypt\*(R" and \*(L"as_rfc2307\*(R" methods and the \*(L"from_crypt\*(R" and \*(L"from_rfc2307\*(R" constructors wherever appropriate, with the following exception.  If a passphrase scheme has a crypt encoding but no native \s-1RFC\s0 2307 encoding, so it can be \s-1RFC\s0 2307 encoded only by using the "<strong>{\s-1CRYPT\s0}</strong>" scheme, then \*(L"as_rfc2307\*(R" and \*(L"from_rfc2307\*(R" should <em>not</em> be implemented by the class.  There is a default implementation of the \*(L"as_rfc2307\*(R" method that uses "<strong>{\s-1CRYPT\s0}</strong>" and \*(L"as_crypt\*(R", and a default implementation of the \*(L"from_rfc2307\*(R" method that recognises "<strong>{\s-1CRYPT\s0}</strong>" and passes the embedded crypt string to the \*(L"from_crypt\*(R" constructor.</p><p>Implementation of the \*(L"passphrase\*(R" method is entirely optional. It should be attempted only for schemes that are so ludicrously weak as to allow passphrases to be cracked reliably in a short time.  Dictionary attacks are not appropriate implementations.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Authen::Passphrase&hellip;</h2>
        <div class="sectioncontent">
<p>MooseX::Types::Authen::Passphrase, <em>crypt</em>\|(3), \s-1RFC\s0 2307</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2006, 2007, 2009, 2010, 2012 Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Authen::OATH.3pm.html"><span aria-hidden="true">&larr;</span> Authen::OATH.3pm: Oath one time passwords</a></li>
   <li class="next"><a href="Authen::Passphrase::AcceptAll.3pm.html">Authen::Passphrase::AcceptAll.3pm: Accept any passphrase <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

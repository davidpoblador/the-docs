<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>del_CplFileConf: Lookup possible completions for a word</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Lookup possible completions for a word">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="del_CplFileConf (3) manual">
  <meta name="twitter:description" content="Lookup possible completions for a word">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtecla-dev-del_CplFileConf-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/del_CplFileConf.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="del_CplFileConf (3) manual" />
  <meta property="og:description" content="Lookup possible completions for a word" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtecla-dev-del_CplFileConf-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">del_CplFileConf<small> (3)</small></h1>
        <p class="lead">Lookup possible completions for a word</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/del_CplFileConf.3.html">
      <span itemprop="name">del_CplFileConf: Lookup possible completions for a word</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtecla-dev/">
      <span itemprop="name">libtecla-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/del_CplFileConf.3.html">
      <span itemprop="name">del_CplFileConf: Lookup possible completions for a word</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;stdio.h&gt;
#include &lt;libtecla.h&gt;

WordCompletion *new_WordCompletion(void);

WordCompletion *del_WordCompletion(WordCompletion *cpl);


#define CPL_MATCH_FN(fn) int (fn)(WordCompletion *cpl, &#92;
                                  void *data, &#92;
                                  const char *line, &#92;
                                  int word_end)
typedef CPL_MATCH_FN(CplMatchFn);

CPL_MATCH_FN(cpl_file_completions);


CplMatches *cpl_complete_word(WordCompletion *cpl,
                              const char *line,
                              int word_end, void *data,
                              CplMatchFn *match_fn);

CplMatches *cpl_recall_matches(WordCompletion *cpl);

int cpl_list_completions(CplMatches *result, FILE *fp,
                         int term_width);

int cpl_add_completion(WordCompletion *cpl,
                       const char *line, int word_start,
                       int word_end, const char *suffix,
                       const char *type_suffix,
                       const char *cont_suffix);

void cpl_record_error(WordCompletion *cpl,
                      const char *errmsg);

const char *cpl_last_error(WordCompletion *cpl);


#define CPL_CHECK_FN(fn) int (fn)(void *data, &#92;
                                  const char *pathname)

typedef CPL_CHECK_FN(CplCheckFn);

CPL_CHECK_FN(cpl_check_exe);

CplFileConf *new_CplFileConf(void);

CplFileConf *del_CplFileConf(CplFileConf *cfc);

void cfc_literal_escapes(CplFileConf *cfc, int literal);

void cfc_file_start(CplFileConf *cfc, int start_index);

void cfc_set_check_fn(CplFileConf *cfc, CplCheckFn *chk_fn,
                      void *chk_data);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>cpl_complete_word()</strong> function is part of the tecla library (see the <a href="../man3/libtecla.3.html"><strong>libtecla</strong>(3)</a> man page). It is usually called behind the scenes by <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a></strong>, but can also be called separately.</p><p>Given an input line containing an incomplete word to be completed, it calls a user-provided callback function (or the provided file-completion callback function) to look up all possible completion suffixes for that word. The callback function is expected to look backward in the line, starting from the specified cursor position, to find the start of the word to be completed, then to look up all possible completions of that word and record them, one at a time by calling <strong>cpl_add_completion()</strong>.</p><p>Descriptions of the functions of this module are as follows:</p>
<pre>
  WordCompletion *new_WordCompletion(void)
</pre>
<p>This function creates the resources used by the <strong>cpl_complete_word()</strong> function. In particular, it maintains the memory that is used to return the results of calling <strong>cpl_complete_word()</strong>.</p>
<pre>
  WordCompletion *del_WordCompletion(WordCompletion *cpl)
</pre>
<p>This function deletes the resources that were returned by a previous call to <strong>new_WordCompletion()</strong>. It always returns <strong>NULL</strong> (ie. a deleted object). It does nothing if the <strong>cpl</strong> argument is <strong>NULL</strong>.</p><p>The callback functions which lookup possible completions should be defined with the following macro (which is defined in libtecla.h).</p>
<pre>
  #define CPL_MATCH_FN(fn) int (fn)(WordCompletion *cpl, &#92;
                                    void *data, &#92;
                                    const char *line, &#92;
                                    int word_end)
</pre>
<p>Functions of this type are called by <strong>cpl_complete_word()</strong>, and all of the arguments of the callback are those that were passed to said function. In particular, the <strong>line</strong> argument contains the input line containing the word to be completed, and <strong>word_end</strong> is the index of the character that follows the last character of the incomplete word within this string. The callback is expected to look backwards from <strong>word_end</strong> for the start of the incomplete word. What constitutes the start of a word clearly depends on the application, so it makes sense for the callback to take on this responsibility. For example, the builtin filename completion function looks backwards until it hits an unescaped space, or the start of the line.  Having found the start of the word, the callback should then lookup all possible completions of this word, and record each completion via separate calls to <strong>cpl_add_completion()</strong>. If the callback needs access to an application-specific symbol table, it can pass it and any other data that it needs, via the <strong>data</strong> argument. This removes any need for globals.</p><p>The callback function should return 0 if no errors occur. On failure it should return 1, and register a terse description of the error by calling <strong>cpl_record_error()</strong>.</p>
<pre>
  void cpl_record_error(WordCompletion *cpl,
                        const char *errmsg);
</pre>
<p>The last error message recorded by calling <strong>cpl_record_error()</strong>, can subsequently be queried by calling <strong>cpl_last_error()</strong>, as described later.</p>
<pre>
  int cpl_add_completion(WordCompletion *cpl,
                         const char *line, int word_start,
                         int word_end, const char *suffix,
                         const char *type_suffix,
                         const char *cont_suffix);
</pre>
<p>The <strong>cpl_add_completion()</strong> function is called zero or more times by the completion callback function to record each possible completion in the specified <strong>WordCompletion</strong> object. These completions are subsequently returned by <strong>cpl_complete_word()</strong>, as described later. The <strong>cpl</strong>, <strong>line</strong>, and <strong>word_end</strong> arguments should be those that were passed to the callback function. The <strong>word_start</strong> argument should be the index within the input line string of the start of the word that is being completed. This should equal <strong>word_end</strong> if a zero-length string is being completed. The <strong>suffix</strong> argument is the string that would have to be appended to the incomplete word to complete it.  If this needs any quoting (eg. the addition of backslashes before special charaters) to be valid within the displayed input line, this should be included. A copy of the suffix string is allocated internally, so there is no need to maintain your copy of the string after <strong>cpl_add_completion()</strong> returns.</p><p>Note that in the array of possible completions which the <strong>cpl_complete_word()</strong> function returns, the suffix recorded by <strong>cpl_add_completion()</strong> is listed along with the concatentation of this suffix with the word that lies between <strong>word_start</strong> and <strong>word_end</strong> in the input line.</p><p>The <strong>type_suffix</strong> argument specifies an optional string to be appended to the completion if it is displayed as part of a list of completions by <strong>cpl_list_completions()</strong>. The intention is that this indicate to the user the type of each completion. For example, the file completion function places a directory separator after completions that are directories, to indicate their nature to the user. Similary, if the completion were a function, you could indicate this to the user by setting <strong>type_suffix</strong> to "()". Note that the <strong>type_suffix</strong> string isn't copied, so if the argument isn't a literal string between speech marks, be sure that the string remains valid for at least as long as the results of <strong>cpl_complete_word()</strong> are needed.</p><p>The <strong>cont_suffix</strong> is a continuation suffix to append to the completed word in the input line if this is the only completion. This is something that isn't part of the completion itself, but that gives the user an indication about how they might continue to extend the token.  For example, the file-completion callback function adds a directory separator if the completed word is a directory. If the completed word were a function name, you could similarly aid the user by arranging for an open parenthesis to be appended.</p>
<pre>
  CplMatches *cpl_complete_word(WordCompletion *cpl,
                                const char *line,
                                int word_end, void *data,
                                CplMatchFn *match_fn);
</pre>
<p>The <strong>cpl_complete_word()</strong> is normally called behind the scenes by <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a></strong>, but can also be called separately if you separately allocate a <strong>WordCompletion</strong> object. It performs word completion, as described at the beginning of this section. Its first argument is a resource object previously returned by <strong>new_WordCompletion()</strong>.  The <strong>line</strong> argument is the input line string, containing the word to be completed. The <strong>word_end</strong> argument contains the index of the character in the input line, that just follows the last character of the word to be completed. When called by <strong>gl_get_line()</strong>, this is the character over which the user pressed <strong>TAB</strong>. The <strong>match_fn</strong><strong> argument is the function</strong> pointer of the callback function which will lookup possible completions of the word, as described above, and the <strong>data</strong> argument provides a way for the application to pass arbitrary data to the callback function.</p><p>If no errors occur, the <strong>cpl_complete_word()</strong> function returns a pointer to a <strong>CplMatches</strong> container, as defined below. This container is allocated as part of the <strong>cpl</strong> object that was passed to <strong>cpl_complete_word()</strong>, and will thus change on each call which uses the same <strong>cpl</strong> argument.</p>
<pre>
  typedef struct {
    char *completion;        /* A matching completion */
                             /*  string */
    char *suffix;            /* The part of the */
                             /*  completion string which */
                             /*  would have to be */
                             /*  appended to complete the */
                             /*  original word. */
    const char *type_suffix; /* A suffix to be added when */
                             /*  listing completions, to */
                             /*  indicate the type of the */
                             /*  completion. */
  } CplMatch;

  typedef struct {
    char *suffix;            /* The common initial part */
                             /*  of all of the completion */
                             /*  suffixes. */
    const char *cont_suffix; /* Optional continuation */
                             /*  string to be appended to */
                             /*  the sole completion when */
                             /*  nmatch==1. */
    CplMatch *matches;       /* The array of possible */
                             /*  completion strings, */
                             /*  sorted into lexical */
                             /*  order. */
    int nmatch;              /* The number of elements in */
                             /*  the above matches[] */
                             /*  array. */
  } CplMatches;
</pre>
<p>If an error occurs during completion, <strong>cpl_complete_word()</strong> returns NULL. A description of the error can be acquired by calling the <strong>cpl_last_error()</strong><strong> function.</strong></p>
<pre>
  const char *cpl_last_error(WordCompletion *cpl);
</pre>
<p>The <strong>cpl_last_error()</strong><strong> function returns a terse description of the</strong> error which occurred on the last call to <strong>cpl_complete_word()</strong> or <strong>cpl_add_completion()</strong>.</p>
<pre>
  CplMatches *cpl_recall_matches(WordCompletion *cpl);
</pre>
<p>As a convenience, the return value of the last call to <strong>cpl_complete_word()</strong> can be recalled at a later time by calling <strong>cpl_recall_matches()</strong>. If <strong>cpl_complete_word()</strong> returned <strong>NULL</strong>, so will <strong>cpl_recall_matches()</strong>.</p>
<pre>
  int cpl_list_completions(CplMatches *result, FILE *fp,
                           int terminal_width);
</pre>
<p>When the <strong>cpl_complete_word()</strong> function returns multiple possible completions, the <strong>cpl_list_completions()</strong> function can be called upon to list them, suitably arranged across the available width of the terminal. It arranges for the displayed columns of completions to all have the same width, set by the longest completion. It also appends the <strong>type_suffix</strong> strings that were recorded with each completion, thus indicating their types to the user.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE BUILT-IN FILENAME-COMPLETION CALLBACK</h2>
        <div class="sectioncontent">
<p>By default the <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a></strong> function, passes the following completion callback function to <strong>cpl_complete_word()</strong>. This function can also be used separately, either by sending it to <strong>cpl_complete_word()</strong>, or by calling it directly from your own completion callback function.</p>
<pre>
  CPL_MATCH_FN(cpl_file_completions);
</pre>
<p>Certain aspects of the behavior of this callback can be changed via its <strong>data</strong> argument. If you are happy with its default behavior you can pass <strong>NULL</strong> in this argument. Otherwise it should be a pointer to a <strong>CplFileConf</strong> object, previously allocated by calling <strong>new_CplFileConf()</strong>.</p>
<pre>
  CplFileConf *new_CplFileConf(void);
</pre>
<p><strong>CplFileConf</strong> objects encapsulate the configuration parameters of <strong>cpl_file_completions()</strong>. These parameters, which start out with default values, can be changed by calling the accessor functions described below.</p><p>By default, the <strong>cpl_file_completions()</strong><strong> callback function</strong> searches backwards for the start of the filename being completed, looking for the first un-escaped space or the start of the input line. If you wish to specify a different location, call <strong>cfc_file_start()</strong> with the index at which the filename starts in the input line. Passing start_index=-1 re-enables the default behavior.</p>
<pre>
  void cfc_file_start(CplFileConf *cfc, int start_index);
</pre>
<p>By default, when <strong>cpl_file_completions()</strong> looks at a filename in the input line, each lone backslash in the input line is interpreted as being a special character which removes any special significance of the character which follows it, such as a space which should be taken as part of the filename rather than delimiting the start of the filename. These backslashes are thus ignored while looking for completions, and subsequently added before spaces, tabs and literal backslashes in the list of completions. To have unescaped backslashes treated as normal characters, call <strong>cfc_literal_escapes()</strong> with a non-zero value in its <strong>literal</strong> argument.</p>
<pre>
  void cfc_literal_escapes(CplFileConf *cfc, int literal);
</pre>
<p>By default, <strong>cpl_file_completions()</strong> reports all files who's names start with the prefix that is being completed. If you only want a selected subset of these files to be reported in the list of completions, you can arrange this by providing a callback function which takes the full pathname of a file, and returns <strong>0</strong> if the file should be ignored, or <strong>1</strong> if the file should be included in the list of completions. To register such a function for use by <strong>cpl_file_completions()</strong>, call <strong>cfc_set_check_fn()</strong>, and pass it a pointer to the function, together with a pointer to any data that you would like passed to this callback whenever it is called. Your callback can make its decisions based on any property of the file, such as the filename itself, whether the file is readable, writable or executable, or even based on what the file contains.</p>
<pre>
  #define CPL_CHECK_FN(fn) int (fn)(void *data, &#92;
                                    const char *pathname)
  typedef CPL_CHECK_FN(CplCheckFn);

  void cfc_set_check_fn(CplFileConf *cfc,
                        CplCheckFn *chk_fn, void *chk_data);
</pre>
<p>The <strong>cpl_check_exe()</strong> function is a provided callback of the above type, for use with <strong>cpl_file_completions()</strong>. It returns non-zero if the filename that it is given represents a normal file that the user has execute permission to. You could use this to have <strong>cpl_file_completions()</strong> only list completions of executable files.</p><p>When you have finished with a <strong>CplFileConf</strong> variable, you can pass it to the <strong>del_CplFileConf()</strong> destructor function to reclaim its memory.</p>
<pre>
  CplFileConf *del_CplFileConf(CplFileConf *cfc);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THREAD SAFETY</h2>
        <div class="sectioncontent">
<p>In multi-threaded programs, you should use the <strong>libtecla_r.a</strong> version of the library. This uses POSIX reentrant functions where available (hence the <strong>_r</strong> suffix), and disables features that rely on non-reentrant system functions. In the case of this module, the only disabled feature is username completion in <strong>~username/</strong> expressions, in <strong>cpl_file_completions()</strong>.</p><p>Using the <strong>libtecla_r.a</strong> version of the library, it is safe to use the facilities of this module in multiple threads, provided that each thread uses a separately allocated <strong>WordCompletion</strong> object. In other words, if two threads want to do word completion, they should each call <strong>new_WordCompletion()</strong> to allocate their own completion objects.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<pre>
libtecla.a    -    The tecla library
libtecla.h    -    The tecla header file.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO del_CplFileConf&hellip;</h2>
        <div class="sectioncontent">

<pre>
<a href="../man3/libtecla.3.html"><strong>libtecla</strong>(3)</a>, <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a>, <a href="../man3/ef_expand_file.3.html"><strong>ef_expand_file</strong>(3)</a>,
<a href="../man3/pca_lookup_file.3.html"><strong>pca_lookup_file</strong>(3)</a>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Martin Shepherd  (mcs@astro.caltech.edu)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="deflateoutputstreambuf.h.3.html"><span aria-hidden="true">&larr;</span> deflateoutputstreambuf.h.3: Header file that defines deflateoutputstreambuf.</a></li>
   <li class="next"><a href="del_ExpandFile.3.html">del_ExpandFile.3: Expand filenames containing ~user/$envvar and wildcard expressions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

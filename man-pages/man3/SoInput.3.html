<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoInput: The soinput class is an abstraction of file import functionality.  this class takes care of most of the chores of doing data import in coin. it puts a layer of abstraction over the read operations to make it transparent for the rest of the coin code whether or not we're reading from a file, from a memory buffer or from stdin.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soinput class is an abstraction of file import functionality.  this class takes care of most of the chores of doing data import in coin. it puts a layer of abstraction over the read operations to make it transparent for the rest of the coin code whether or not we're reading from a file, from a memory buffer or from stdin.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoInput (3) manual">
  <meta name="twitter:description" content="The soinput class is an abstraction of file import functionality.  this class takes care of most of the chores of doing data import in coin. it puts a layer of abstraction over the read operations to make it transparent for the rest of the coin code whether or not we're reading from a file, from a memory buffer or from stdin.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoInput-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoInput.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoInput (3) manual" />
  <meta property="og:description" content="The soinput class is an abstraction of file import functionality.  this class takes care of most of the chores of doing data import in coin. it puts a layer of abstraction over the read operations to make it transparent for the rest of the coin code whether or not we're reading from a file, from a memory buffer or from stdin." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoInput-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoInput<small> (3)</small></h1>
        <p class="lead">The soinput class is an abstraction of file import functionality.  this class takes care of most of the chores of doing data import in coin. it puts a layer of abstraction over the read operations to make it transparent for the rest of the coin code whether or not we're reading from a file, from a memory buffer or from stdin.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoInput.3.html">
      <span itemprop="name">SoInput: The soinput class is an abstraction of file import functionality.  this class takes care of most of the chores of doing data import in coin. it puts a layer of abstraction over the read operations to make it transparent for the rest of the coin code whether or not we're reading from a file, from a memory buffer or from stdin.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoInput.3.html">
      <span itemprop="name">SoInput: The soinput class is an abstraction of file import functionality.  this class takes care of most of the chores of doing data import in coin. it puts a layer of abstraction over the read operations to make it transparent for the rest of the coin code whether or not we're reading from a file, from a memory buffer or from stdin.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SoInput.h&gt;</p><h3>Public Member Functions</h3>
<p><strong>SoInput</strong> (void)</p><p><strong>SoInput</strong> (<strong>SoInput</strong> *dictIn)</p><p><strong>SoProto</strong> * <strong>findProto</strong> (const <strong>SbName</strong> &name)</p><p>void <strong>addProto</strong> (<strong>SoProto</strong> *proto)</p><p>void <strong>pushProto</strong> (<strong>SoProto</strong> *proto)</p><p><strong>SoProto</strong> * <strong>getCurrentProto</strong> (void) const </p><p>void <strong>popProto</strong> (void)</p><p>void <strong>addRoute</strong> (const <strong>SbName</strong> &fromnode, const <strong>SbName</strong> &fromfield, const <strong>SbName</strong> &tonode, const <strong>SbName</strong> &tofield)</p><p>SbBool <strong>checkISReference</strong> (<strong>SoFieldContainer</strong> *container, const <strong>SbName</strong> &fieldname, SbBool &readok)</p><p>virtual <strong>~SoInput</strong> (void)</p><p>virtual void <strong>setFilePointer</strong> (FILE *newFP)</p><p>virtual SbBool <strong>openFile</strong> (const char *fileName, SbBool okIfNotFound=FALSE)</p><p>virtual SbBool <strong>pushFile</strong> (const char *fileName)</p><p>virtual void <strong>closeFile</strong> (void)</p><p>virtual SbBool <strong>isValidFile</strong> (void)</p><p>virtual SbBool <strong>isValidBuffer</strong> (void)</p><p>virtual FILE * <strong>getCurFile</strong> (void) const </p><p>virtual const char * <strong>getCurFileName</strong> (void) const </p><p>virtual void <strong>setBuffer</strong> (const void *bufpointer, size_t bufsize)</p><p>void <strong>setStringArray</strong> (const char *strings[])</p><p>virtual size_t <strong>getNumBytesRead</strong> (void) const </p><p>virtual <strong>SbString</strong> <strong>getHeader</strong> (void)</p><p>virtual float <strong>getIVVersion</strong> (void)</p><p>virtual SbBool <strong>isBinary</strong> (void)</p><p>virtual SbBool <strong>get</strong> (char &c)</p><p>virtual SbBool <strong>getASCIIBuffer</strong> (char &c)</p><p>virtual SbBool <strong>getASCIIFile</strong> (char &c)</p><p>virtual SbBool <strong>readHex</strong> (uint32_t &l)</p><p>virtual SbBool <strong>read</strong> (char &c)</p><p>virtual SbBool <strong>read</strong> (char &c, SbBool skip)</p><p>virtual SbBool <strong>read</strong> (<strong>SbString</strong> &s)</p><p>virtual SbBool <strong>read</strong> (<strong>SbName</strong> &n, SbBool validIdent=FALSE)</p><p>virtual SbBool <strong>read</strong> (int &i)</p><p>virtual SbBool <strong>read</strong> (unsigned int &i)</p><p>virtual SbBool <strong>read</strong> (short &s)</p><p>virtual SbBool <strong>read</strong> (unsigned short &s)</p><p>virtual SbBool <strong>read</strong> (float &f)</p><p>virtual SbBool <strong>read</strong> (double &d)</p><p>virtual SbBool <strong>readByte</strong> (int8_t &b)</p><p>virtual SbBool <strong>readByte</strong> (uint8_t &b)</p><p>virtual SbBool <strong>readBinaryArray</strong> (unsigned char *c, int length)</p><p>virtual SbBool <strong>readBinaryArray</strong> (int32_t *l, int length)</p><p>virtual SbBool <strong>readBinaryArray</strong> (float *f, int length)</p><p>virtual SbBool <strong>readBinaryArray</strong> (double *d, int length)</p><p>virtual SbBool <strong>eof</strong> (void) const </p><p>SbBool <strong>isFileVRML1</strong> (void)</p><p>SbBool <strong>isFileVRML2</strong> (void)</p><p>virtual void <strong>resetFilePointer</strong> (FILE *fptr)</p><p>virtual void <strong>getLocationString</strong> (<strong>SbString</strong> &string) const </p><p>virtual void <strong>putBack</strong> (const char c)</p><p>virtual void <strong>putBack</strong> (const char *str)</p><p>virtual void <strong>addReference</strong> (const <strong>SbName</strong> &name, <strong>SoBase</strong> *base, SbBool addToGlobalDict=TRUE)</p><p>virtual void <strong>removeReference</strong> (const <strong>SbName</strong> &name)</p><p>virtual <strong>SoBase</strong> * <strong>findReference</strong> (const <strong>SbName</strong> &name) const </p>
<h3>Static Public Member Functions</h3>
<p>static void <strong>addDirectoryFirst</strong> (const char *dirName)</p><p>static void <strong>addDirectoryLast</strong> (const char *dirName)</p><p>static void <strong>addEnvDirectoriesFirst</strong> (const char *envVarName, const char *separator=':&#92;t ')</p><p>static void <strong>addEnvDirectoriesLast</strong> (const char *envVarName, const char *separator=':&#92;t ')</p><p>static void <strong>removeDirectory</strong> (const char *dirName)</p><p>static void <strong>clearDirectories</strong> (void)</p><p>static const <strong>SbStringList</strong> & <strong>getDirectories</strong> (void)</p><p>static void <strong>init</strong> (void)</p><p>static <strong>SbString</strong> <strong>getPathname</strong> (const char *const filename)</p><p>static <strong>SbString</strong> <strong>getPathname</strong> (const <strong>SbString</strong> &s)</p><p>static <strong>SbString</strong> <strong>getBasename</strong> (const char *const filename)</p><p>static <strong>SbString</strong> <strong>getBasename</strong> (const <strong>SbString</strong> &s)</p><p>static <strong>SbString</strong> <strong>searchForFile</strong> (const <strong>SbString</strong> &basename, const <strong>SbStringList</strong> &directories, const <strong>SbStringList</strong> &subdirectories)</p>
<h3>Protected Member Functions</h3>
<p>virtual SbBool <strong>popFile</strong> (void)</p><p>void <strong>setIVVersion</strong> (float version)</p><p>FILE * <strong>findFile</strong> (const char *fileName, <strong>SbString</strong> &fullName)</p><p>void <strong>initFile</strong> (FILE *newFP, const char *fileName, <strong>SbString</strong> *fullName, SbBool openedHere, <strong>SbDict</strong> *refDict=NULL)</p><p>SbBool <strong>checkHeader</strong> (SbBool bValidateBufferHeader=FALSE)</p><p>SbBool <strong>fromBuffer</strong> (void) const </p><p>SbBool <strong>skipWhiteSpace</strong> (void)</p><p>size_t <strong>freeBytesInBuf</strong> (void) const </p><p>SbBool <strong>readInteger</strong> (int32_t &l)</p><p>SbBool <strong>readUnsignedInteger</strong> (uint32_t &l)</p><p>SbBool <strong>readReal</strong> (double &d)</p><p>SbBool <strong>readUnsignedIntegerString</strong> (char *str)</p><p>int <strong>readDigits</strong> (char *str)</p><p>int <strong>readHexDigits</strong> (char *str)</p><p>int <strong>readChar</strong> (char *str, char charToRead)</p><p>SbBool <strong>makeRoomInBuf</strong> (size_t nBytes)</p><p>void <strong>convertShort</strong> (char *from, short *s)</p><p>void <strong>convertInt32</strong> (char *from, int32_t *l)</p><p>void <strong>convertFloat</strong> (char *from, float *f)</p><p>void <strong>convertDouble</strong> (char *from, double *d)</p><p>void <strong>convertShortArray</strong> (char *from, short *to, int len)</p><p>void <strong>convertInt32Array</strong> (char *from, int32_t *to, int len)</p><p>void <strong>convertFloatArray</strong> (char *from, float *to, int len)</p><p>void <strong>convertDoubleArray</strong> (char *from, double *to, int len)</p><p>SbBool <strong>isFileURL</strong> (const char *url)</p><p>char * <strong>URLToFile</strong> (char *out_buf, const char *in_buf)</p><p>SbBool <strong>IsURL</strong> (const char *c_strng)</p>
<h3>Static Protected Member Functions</h3>
<p>static void <strong>setDirectories</strong> (<strong>SbStringList</strong> *dirs)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoInput</strong> class is an abstraction of file import functionality.</p><p>This class takes care of most of the chores of doing data import in Coin. It puts a layer of abstraction over the read operations to make it transparent for the rest of the Coin code whether or not we're reading from a file, from a memory buffer or from stdin.</p><p><strong>SoInput</strong> also takes care of checking file validity, aswell as handling information about features in the various file formats which are supported.</p><p>Example usage:</p>
<pre>
int
main(void)
{
  SoDB::init();

  SoInput in;
  if (in.openFile("fab_model.iv")) {
    SoSeparator * root = SoDB::readAll(&in);
    if (root) {
      // Do stuff with the imported scene graph here
      // ...
      return 0;
    }
  }

  return 1;
}

</pre>
<p>Important note: there are several public and protected methods which makes it possible to pass in or get returned FILE* structures in this class. Do <em>not</em> use these methods when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p><p>This class supports one environment variable called COIN_SOINPUT_SEARCH_GLOBAL_DICT. When set to '1', the global dictionary is searched after the current file dictionary when resolving USE keywords. This makes it possible to reference nodes in other files. The reason for introducing this feature is that the <strong>SoFile</strong> node rereads the file whenever the name field changes. The first time the file is read, it's possible to reference nodes in the parent file, using the USE keyword. But, when the file is reread this is no longer possible, since the reading now starts at the <strong>SoFile</strong> node, with an empty dictionary.</p><p><strong>See also:</strong></p><p><strong>SoOutput</strong>, <strong>SoDB</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoInput::SoInput (void)</h3>
<p>Constructor. If no filepointer is set, input will be read from stdin.</p>
<h3>SoInput::SoInput (\fBSoInput\fP *dictIn)</h3>
<p>A constructor which copies the reference mappings from <em>dictIn</em> upon initialization.</p>
<h3>SoInput::~SoInput (void)\fC [virtual]\fP</h3>
<p>Destructor. Runs <strong>SoInput::closeFile()</strong> to close any open files.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoProto\fP * SoInput::findProto (const \fBSbName\fP &name)</h3>
<p>Searches for PROTO named <em>name</em>. This function will only return PROTOs that have been read by the current <strong>SoInput</strong> instance.</p><p><strong>Since:</strong></p><p>Coin 2.3</p>
<h3>void SoInput::addProto (\fBSoProto\fP *proto)</h3>
<p>Adds a Proto which should be active in the current scope.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoInput::pushProto (\fBSoProto\fP *proto)</h3>
<p>Pushed a Proto onto the Proto stack. The Proto stack is used during VRML2 file parsing.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>See also:</strong></p><p><strong>popProto()</strong></p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>\fBSoProto\fP * SoInput::getCurrentProto (void) const</h3>
<p>Returns the Proto at the top of the Proto stack.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>See also:</strong></p><p><strong>pushProto()</strong></p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoInput::popProto (void)</h3>
<p>Pops a Proto off the Proto stack.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>See also:</strong></p><p><strong>pushProto()</strong></p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoInput::addRoute (const \fBSbName\fP &fromnode, const \fBSbName\fP &fromfield, const \fBSbName\fP &tonode, const \fBSbName\fP &tofield)</h3>
<p>Adds a ROUTE from /a fromnode's , to <em>tonode's</em> tofield. This makes it possible to defines ROUTEs in files before the <em>fromnode</em> or <em>tonode</em> is parsed.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>SbBool SoInput::checkISReference (\fBSoFieldContainer\fP *container, const \fBSbName\fP &fieldname, SbBool &readok)</h3>
<p>Checks if the next bytes in <em>in</em> is the IS keyword. Returns TRUE<em> if the IS keyword was found, </em><em>readok</em><em> will be set to FALSE</em><em> if some error occured while searching for the IS keyword.</em></p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoInput::setFilePointer (FILE *newFP)\fC [virtual]\fP</h3>
<p>Uses the given file pointer as the input file. The input stack of files will be emptied first. Closing a file passed in by it's file pointer is the library user's responsibility.</p><p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p><p>Note that it is not allowed to pass a FILE* to a gzip-compressed file under Mac OS X.</p><p><strong>See also:</strong></p><p><strong>openFile()</strong>, <strong>closeFile()</strong></p>
<h3>SbBool SoInput::openFile (const char *fileName, SbBoolokIfNotFound = \fCFALSE\fP)\fC [virtual]\fP</h3>
<p>Open the given file, and make it the only one in the file stack. If <em>okIfNotFound</em> is FALSE<em>, show a warning message if the file could not be opened.</em></p><p>Returns TRUE if file could be opened for reading, FALSE otherwise.</p><p>Note: even if your attempt at opening a file is unsuccessful, the <strong>SoInput</strong> instance will <em>not</em> default to reading from stdin after a call has been made to this method.</p><p><strong>See also:</strong></p><p><strong>setFilePointer()</strong>, <strong>pushFile()</strong>, <strong>closeFile()</strong></p>
<h3>SbBool SoInput::pushFile (const char *filename)\fC [virtual]\fP</h3>
<p>Push a new file on top of the stack. Further read operations will take place with the new file until it reaches end-of-file, upon when the file will be popped of the stack and we'll continue with the next file in the stack.</p><p>Returns TRUE if the file could be opened for reading, FALSE otherwise.</p><p><strong>See also:</strong></p><p><strong>openFile()</strong></p>
<h3>void SoInput::closeFile (void)\fC [virtual]\fP</h3>
<p>Removes all files from the internal stack. Any files opened by <strong>openFile()</strong> or <strong>pushFile()</strong> will also be closed, but not the files coming from <strong>setFilePointer()</strong> -- which are the responsibility of the caller.</p><p>You usually don't need to call this method explicitly, as it will automatically be triggered by the <strong>SoInput</strong> destructor to close any open files when the <strong>SoInput</strong> instance goes out of scope.</p><p><strong>See also:</strong></p><p><strong>setFilePointer()</strong>, <strong>openFile()</strong>, <strong>pushFile()</strong></p>
<h3>SbBool SoInput::isValidFile (void)\fC [virtual]\fP</h3>
<p>Checks to see if the current file is a valid file which can be read by the Coin library.</p><p>When reading files through e.g. <strong>SoDB::readAll()</strong>, this is automatically checked for you, so application code should usually not need to use this method.</p>
<h3>SbBool SoInput::isValidBuffer (void)\fC [virtual]\fP</h3>
<p>Returns TRUE if the current text buffer represents a valid iv-file which can be read by the Coin library.</p><p>When reading files through e.g. <strong>SoDB::readAll()</strong>, this is automatically checked for you, so application code should usually not need to use this method.</p>
<h3>FILE * SoInput::getCurFile (void) const\fC [virtual]\fP</h3>
<p>Returns file pointer of the file on top of the input stack. If the 'file' is actually a memory buffer, returns NULL.</p><p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p><p><strong>See also:</strong></p><p><strong>getCurFileName()</strong></p>
<h3>const char * SoInput::getCurFileName (void) const\fC [virtual]\fP</h3>
<p>Returns the name of the file on top of the input stack. NULL will be returned if the toplevel 'file' is a memory buffer.</p><p><strong>See also:</strong></p><p><strong>getCurFile()</strong></p>
<h3>void SoInput::setBuffer (const void *bufpointer, size_tbufsize)\fC [virtual]\fP</h3>
<p>Sets up the input stream for reading from a memory buffer. Closes all open files in the file stack first.</p><p>In the original SGI Inventor API this method was designed as 'char * bufpointer', Coin followed this until Coin 3, but changed the signature to const from Coin 4.0.</p>
<h3>void SoInput::setStringArray (const char *strings[])</h3>
<p>Sets up the input stream for reading from the strings pointed to by a NULL-terminated array of string pointers. It is intended for reading memory-inlined scene graphs.</p><p>The rationale for this function is that there is a compiler portability problem with compiling large, static string buffers. Some compilers have fixed max-lengths on this feature, just over 1KB, which obviously becomes a problem real fast. This method lets you specify the buffer as an array of smaller string buffers, typically one string for each line in the Inventor file.</p>
<pre>
SoNode *
makeSceneGraph(void) {
  static const char * inlinescenegraph[] = {
    "#Inventor V2.1 ascii\n",
    "\n",
    "Separator {\n",
    "  Cube {\n",
    "  }\n",
    "}\n",
    NULL
  };
  SoInput in;
  if ( !in.setStringArray(inlinescenegraph) ) return NULL;
  return SoDB::readAll(&in);
}
</pre>
<p><strong>See also:</strong></p><p><strong>setBuffer()</strong></p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.1</p>
<h3>size_t SoInput::getNumBytesRead (void) const\fC [virtual]\fP</h3>
<p>Returns number of bytes read so far from the current file or memory buffer. You can only use this method while you're reading the file. When the reading has finished, the current file is popped off the file stack, and a more or less random number is returned. You should use the stat() system call to find the size of a file (or fseek() and ftell()).</p>
<h3>\fBSbString\fP SoInput::getHeader (void)\fC [virtual]\fP</h3>
<p>Returns header of current file.</p>
<h3>float SoInput::getIVVersion (void)\fC [virtual]\fP</h3>
<p>Returns the library version needed to read a file with the given header. If the header of the current file is not valid, this method returns <em>0.0f</em>.</p>
<h3>SbBool SoInput::isBinary (void)\fC [virtual]\fP</h3>
<p>Returns TRUE if the current file is in binary format.</p>
<h3>SbBool SoInput::get (char &c)\fC [virtual]\fP</h3>
<p>Get next character in current stream. Returns FALSE on end of file.</p><p><strong>See also:</strong></p><p><strong>read()</strong></p>
<h3>SbBool SoInput::getASCIIBuffer (char &c)\fC [virtual]\fP</h3>
<p>Returns next character in current stream. Don't use this method -- <strong>SoInput</strong> is supposed to <em>hide</em> whether or not you are reading from file or memory. It is only included for compatibility reasons.</p>
<h3>SbBool SoInput::getASCIIFile (char &c)\fC [virtual]\fP</h3>
<p>Returns next character in current stream. Don't use this method -- <strong>SoInput</strong> is supposed to <em>hide</em> whether or not you are reading from file or memory. It is only included for compatibility reasons.</p>
<h3>SbBool SoInput::readHex (uint32_t &l)\fC [virtual]\fP</h3>
<p>Reads an unsigned integer in hexidecimal format from the current stream. Note that no error checking is done to see if it actually is a hex format value.</p><p>A number in hexadecimal format must have the '0x' prefix.</p><p>Returns FALSE if end of file is encountered.</p>
<h3>SbBool SoInput::read (char &c)\fC [virtual]\fP</h3>
<p>Skips whitespace and reads next character in input stream. Returns FALSE if encountering end of file.</p>
<h3>SbBool SoInput::read (char &c, SbBoolskip)\fC [virtual]\fP</h3>
<p>Reads next character in input stream, returns FALSE if encountering end of file. If <em>skip</em> is TRUE<em>, skips whitespace before reading a character.</em></p>
<h3>SbBool SoInput::read (\fBSbString\fP &s)\fC [virtual]\fP</h3>
<p>Skips whitespace and extracts string. A string can be placed within quotes, in which case we will return all characters between the quotes (including spaces, tabs, newlines, etc). A quote character (i.e. "'') can also be part of the string, but must then be preceded by a&#92;'' character.</p><p>A string not contained in quotes is terminated by the first following whitespace character.</p><p>Returns FALSE upon encountering end of file (EOF) before the string is fully parsed, or any other error. Note: This function does not return FALSE when encountering all EOFs. When multiple files are on the stack and a string is being parsed (the parser has found one or more valid characters) and EOF is encountered, the parsing stops and the read string along with TRUE is returned. The next time the read method is called, the stack is popped and a read string from the next file is returned - not always returning FALSE between the files (though it might on certain circumstances). The solution to this is to test for end of file after each successive read operation.</p>
<h3>SbBool SoInput::read (\fBSbName\fP &n, SbBoolvalidIdent = \fCFALSE\fP)\fC [virtual]\fP</h3>
<p>Read a name from the current stream and place it in <em>n</em>.</p><p>This method should not be used specifically to read all instances of <strong>SbName</strong>. The semantics of the interface is such that it is designed to handle identifier tokens from the Inventor / VRML file formats. I.e. cases where node names, node types and field names are to be read. If your goal is to read the value of a <strong>SbName</strong> field that is not any of the above, and at least when the string might be quoted, then you should most likely use <strong>SoInput::read(SbString &)</strong> instead.</p><p>If <em>validIdent</em> is TRUE<em> the name needs to be a valid identifier (no reserved characters etc), while </em><em>validIdent</em><em> equal to FALSE</em><em> means we'll just read characters for the next word until we hit whitespace or one of the '{'/'}' delimiters.</em></p><p>Returns FALSE on encountering end of file before a full name has been read -- if <em>validIdent</em> is also FALSE<em>. If </em><em>validIdent</em><em> is passed as TRUE</em><em>, the return value will be FALSE</em><em> if no valid name was found, but </em><em>not</em><em> necessarily on end of file.</em></p>
<h3>SbBool SoInput::read (int &i)\fC [virtual]\fP</h3>
<p>Read integer from current file or buffer position and place it in <em>i</em>. Returns FALSE<em> if we hit end of file prematurely.</em></p>
<h3>SbBool SoInput::read (unsigned int &i)\fC [virtual]\fP</h3>
<p>Read unsigned integer from current file or buffer position and place it in <em>i</em>. Returns FALSE<em> if we hit end of file prematurely.</em></p>
<h3>SbBool SoInput::read (short &s)\fC [virtual]\fP</h3>
<p>Read short integer from current file or buffer position and place it in <em>s</em>. Returns FALSE<em> if we hit end of file prematurely.</em></p>
<h3>SbBool SoInput::read (unsigned short &s)\fC [virtual]\fP</h3>
<p>Read unsigned short integer from current file or buffer position and place it in <em>s</em>. Returns FALSE<em> if we hit end of file prematurely.</em></p>
<h3>SbBool SoInput::read (float &f)\fC [virtual]\fP</h3>
<p>Read float value from current file or buffer position and place it in <em>f</em>. Returns FALSE<em> if we hit end of file prematurely.</em></p>
<h3>SbBool SoInput::read (double &d)\fC [virtual]\fP</h3>
<p>Read double value from current file or buffer position and place it in <em>d</em>. Returns FALSE<em> if we hit end of file prematurely.</em></p>
<h3>SbBool SoInput::readByte (int8_t &b)\fC [virtual]\fP</h3>
<p>Read signed byte integer from current file or buffer position and place it in <em>b</em>. Returns FALSE<em> if we hit end of file prematurely.</em></p>
<h3>SbBool SoInput::readByte (uint8_t &b)\fC [virtual]\fP</h3>
<p>Read unsigned byte integer from current file or buffer position and place it in <em>b</em>. Returns FALSE<em> if we hit end of file prematurely.</em></p>
<h3>SbBool SoInput::readBinaryArray (unsigned char *c, intlength)\fC [virtual]\fP</h3>
<p>Reads <em>length</em> characters from the current stream into <em>c</em>. Returns FALSE<em> if end of file is encountered before the given number of bytes could be read.</em></p>
<h3>SbBool SoInput::readBinaryArray (int32_t *l, intlength)\fC [virtual]\fP</h3>
<p>Reads <em>length</em> 32-bit integers from the current stream into <em>l</em>. Returns FALSE<em> if end of file is encountered before the given number of integers could be read.</em></p>
<h3>SbBool SoInput::readBinaryArray (float *f, intlength)\fC [virtual]\fP</h3>
<p>Reads <em>length</em> floats from the current stream into <em>f</em>. Returns FALSE<em> if end of file is encountered before the given number of binary float values could be read.</em></p>
<h3>SbBool SoInput::readBinaryArray (double *d, intlength)\fC [virtual]\fP</h3>
<p>Reads <em>length</em> double floats from the current stream into <em>d</em>. Returns FALSE<em> if end of file is encountered before the given number of binary double float values could be read.</em></p>
<h3>SbBool SoInput::eof (void) const\fC [virtual]\fP</h3>
<p>Returns TRUE if we are at the end of the current stream, otherwise FALSE.</p>
<h3>SbBool SoInput::isFileVRML1 (void)</h3>
<p>Returns TRUE if current file is a VRML V1.0 file.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p>
<h3>SbBool SoInput::isFileVRML2 (void)</h3>
<p>Returns TRUE if current file is a VRML 2 / VRML97 file.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p>
<h3>void SoInput::resetFilePointer (FILE *fptr)\fC [virtual]\fP</h3>
<p>This function has been obsoleted in Coin.</p>
<h3>void SoInput::getLocationString (\fBSbString\fP &str) const\fC [virtual]\fP</h3>
<p>Places the current line number location and file name in a string which is to be used in the output upon read errors.</p>
<h3>void SoInput::putBack (const charc)\fC [virtual]\fP</h3>
<p>Insert character <em>c</em> in stream at the current position.</p>
<h3>void SoInput::putBack (const char *str)\fC [virtual]\fP</h3>
<p>Insert string <em>str</em> in stream at the current position.</p>
<h3>void SoInput::addReference (const \fBSbName\fP &name, \fBSoBase\fP *base, SbBooladdToGlobalDict = \fCTRUE\fP)\fC [virtual]\fP</h3>
<p>Adds a name&lt;-&gt;<strong>SoBase</strong> mapping to our dictionary.</p><p><strong>See also:</strong></p><p><strong>findReference()</strong>, <strong>removeReference()</strong></p>
<h3>void SoInput::removeReference (const \fBSbName\fP &name)\fC [virtual]\fP</h3>
<p>Removes a name&lt;-&gt;<strong>SoBase</strong> mapping from our dictionary.</p><p><strong>See also:</strong></p><p><strong>findReference()</strong>, <strong>addReference()</strong></p>
<h3>\fBSoBase\fP * SoInput::findReference (const \fBSbName\fP &name) const\fC [virtual]\fP</h3>
<p>Finds an <strong>SoBase</strong> derived object which has been mapped to <em>name</em> earlier during the import process.</p><p>The Coin library will by default only search through the previously loaded nodes from the <em>same</em> file. By setting the environment variable COIN_SOINPUT_SEARCH_GLOBAL_DICT<em> to '1', you can force the import process to search for USE-references through </em><em>all</em><em> nodes that has been loaded or otherwise instantiated.</em></p><p><strong>See also:</strong></p><p><strong>addReference()</strong>, <strong>removeReference()</strong></p>
<h3>void SoInput::addDirectoryFirst (const char *dirName)\fC [static]\fP</h3>
<p>Add a directory to the search list. The added directory will be searched before any of the other directories in the list.</p><p><strong>See also:</strong></p><p><strong>addDirectoryLast()</strong>, <strong>addEnvDirectoriesFirst()</strong>, <strong>addEnvDirectoriesLast()</strong></p><p><strong>removeDirectory()</strong>, <strong>clearDirectories()</strong></p>
<h3>void SoInput::addDirectoryLast (const char *dirName)\fC [static]\fP</h3>
<p>Add a directory to the search list. The added directory will be searched after any of the other directories in the list.</p><p><strong>See also:</strong></p><p><strong>addDirectoryFirst()</strong>, <strong>addEnvDirectoriesFirst()</strong>, <strong>addEnvDirectoriesLast()</strong></p><p><strong>removeDirectory()</strong>, <strong>clearDirectories()</strong></p>
<h3>void SoInput::addEnvDirectoriesFirst (const char *envVarName, const char *separator = \fC':&#92;t '\fP)\fC [static]\fP</h3>
<p>Add in front of the list all directories in the environment variable <em>envVarName</em>. The <em>separator</em> string should contain all characters to be interpreted as separators in the environment variable string list. The default separators are ':', tab and space.</p><p><strong>See also:</strong></p><p><strong>addDirectoryFirst()</strong>, <strong>addDirectoryLast()</strong></p><p><strong>addEnvDirectoriesLast()</strong></p><p><strong>removeDirectory()</strong>, <strong>clearDirectories()</strong></p>
<h3>void SoInput::addEnvDirectoriesLast (const char *envVarName, const char *separator = \fC':&#92;t '\fP)\fC [static]\fP</h3>
<p>Add at the end of the list all directories in the environment variable <em>envVarName</em>. The <em>separator</em> string should contain all characters to be interpreted as separators in the environment variable string list. The default separators are ':', tab and space.</p><p><strong>See also:</strong></p><p><strong>addDirectoryFirst()</strong>, <strong>addDirectoryLast()</strong></p><p><strong>addEnvDirectoriesFirst()</strong></p><p><strong>removeDirectory()</strong>, <strong>clearDirectories()</strong></p>
<h3>void SoInput::removeDirectory (const char *dirName)\fC [static]\fP</h3>
<p>Remove the given directory from the directory search list.</p><p>The search list is scanned from last to first for the directory name, so directories can easily be 'stacked' by pushing with <strong>addDirectoryLast()</strong> and then removed with this method.</p><p><strong>See also:</strong></p><p><strong>addDirectoryFirst()</strong>, <strong>addDirectoryLast()</strong></p><p><strong>addEnvDirectoriesFirst()</strong>, <strong>addEnvDirectoriesLast()</strong></p><p><strong>clearDirectories()</strong></p>
<h3>void SoInput::clearDirectories (void)\fC [static]\fP</h3>
<p>Remove all entries from the directory search list.</p><p><strong>See also:</strong></p><p><strong>addDirectoryFirst()</strong>, <strong>addDirectoryLast()</strong></p><p><strong>addEnvDirectoriesFirst()</strong>, <strong>addEnvDirectoriesLast()</strong></p><p><strong>removeDirectory()</strong></p>
<h3>const \fBSbStringList\fP & SoInput::getDirectories (void)\fC [static]\fP</h3>
<p>Returns the list of directories which'll be searched upon loading Coin and VRML format files. Directory searches will be done whenever any external references appears in a file, for instance to texture images.</p>
<h3>void SoInput::init (void)\fC [static]\fP</h3>
<p>Initialize static variables in class. Called from <strong>SoDB::init()</strong>.</p>
<h3>\fBSbString\fP SoInput::getPathname (const char *constfilename)\fC [static]\fP</h3>
<p>Finds and returns the part of the given filename which is the directory path name.</p>
<h3>\fBSbString\fP SoInput::getPathname (const \fBSbString\fP &s)\fC [static]\fP</h3>
<p>Finds and returns the part of the given filename which is the directory path name.</p>
<h3>\fBSbString\fP SoInput::getBasename (const char *constfilename)\fC [static]\fP</h3>
<p>Finds and returns the part of the given filename which is the base name (i.e. the filename without the leading directory path).</p>
<h3>\fBSbString\fP SoInput::getBasename (const \fBSbString\fP &s)\fC [static]\fP</h3>
<p>Finds and returns the part of the given filename which is the base name (i.e. the filename without the leading directory path).</p>
<h3>\fBSbString\fP SoInput::searchForFile (const \fBSbString\fP &basename, const \fBSbStringList\fP &directories, const \fBSbStringList\fP &subdirectories)\fC [static]\fP</h3>
<p>Given a <em>basename</em> for a file and an array of <em>directories</em> to search, returns the full name of the file found.</p><p>In addition to looking at the root of each directory in <em>directories</em>, all <em>subdirectories</em> is also searched for each item in <em>directories</em>.</p><p>If no file matching <em>basename</em> could be found in any of the directories, returns an empty string.</p><p>This method is a Coin extension, not part of the original Inventor API.</p>
<h3>SbBool SoInput::popFile (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Pop the topmost file off the stack. Returns FALSE if there was no files on the stack to pop. A file is only popped when there is more than one file on the stack.</p><p><strong>See also:</strong></p><p><strong>pushFile()</strong>, <strong>openFile()</strong>, <strong>closeFile()</strong></p>
<h3>void SoInput::setIVVersion (floatversion)\fC [protected]\fP</h3>
<p>Changes the file format version number for the stream at the top of the stack.</p>
<h3>FILE * SoInput::findFile (const char *basename, \fBSbString\fP &fullname)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Return the currently active stream.</p><p>Scan through the include directories in order and try to find a file with the given name in any one of them. If file is found, put the full name with complete path from current directory of process into <em>fullname</em>, open the file and return the file pointer.</p><p>If the file could either not be found or not opened for reading, return NULL.</p><p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p>
<h3>void SoInput::initFile (FILE *newFP, const char *fileName, \fBSbString\fP *fullName, SbBoolopenedHere, \fBSbDict\fP *refDict = \fCNULL\fP)\fC [protected]\fP</h3>
<p>This function has been obsoleted in Coin.</p>
<h3>SbBool SoInput::checkHeader (SbBoolbValidateBufferHeader = \fCFALSE\fP)\fC [protected]\fP</h3>
<p>Returns TRUE if the current stream has had it's header parsed. If it hasn't, this method will attempt to read the header and returns TRUE if it could be done.</p><p>If <em>bValidateBufferHeader</em> is TRUE<em>, the returned flag will also be FALSE</em> if the file stream header was not of a supported file format type.</p>
<h3>SbBool SoInput::fromBuffer (void) const\fC [protected]\fP</h3>
<p>Returns TRUE if the current input stream is fetching data from a memory buffer, or FALSE if the input is from a file.</p>
<h3>SbBool SoInput::skipWhiteSpace (void)\fC [protected]\fP</h3>
<p>Move file pointer past whitespace in the current file or buffer. Returns FALSE if end of file is encountered.</p>
<h3>size_t SoInput::freeBytesInBuf (void) const\fC [protected]\fP</h3>
<p>This function has been obsoleted in Coin.</p>
<h3>SbBool SoInput::readInteger (int32_t &l)\fC [protected]\fP</h3>
<p>Reads 32-bit signed integer value from the current stream. Returns FALSE if we hit end of file prematurely.</p>
<h3>SbBool SoInput::readUnsignedInteger (uint32_t &l)\fC [protected]\fP</h3>
<p>Reads 32-bit unsigned integer value from the current stream. Returns FALSE if we hit end of file prematurely.</p>
<h3>SbBool SoInput::readReal (double &d)\fC [protected]\fP</h3>
<p>Reads a double-precision floating point value from the current stream. Returns FALSE if we hit end of file prematurely or if no valid string representing a value could be read.</p>
<h3>SbBool SoInput::readUnsignedIntegerString (char *str)\fC [protected]\fP</h3>
<p>Reads a set of bytes from the stream making up an unsigned integer and puts them at <em>str</em>.</p><p>Returns FALSE if no string representing an unsigned integer could be read.</p>
<h3>int SoInput::readDigits (char *str)\fC [protected]\fP</h3>
<p>Read decimal base digits from the current input stream into <em>str</em> and returns the number of characters read.</p>
<h3>int SoInput::readHexDigits (char *str)\fC [protected]\fP</h3>
<p>Read hexadecimal base digits from the current input stream into <em>str</em> and returns the number of characters read.</p>
<h3>int SoInput::readChar (char *s, charcharToRead)\fC [protected]\fP</h3>
<p>Reads the next character in stream and compares it to <em>charToRead</em>. Returns 1<em> on success, 0</em> on failure. Failure may come from either end of file, or from the next character in the stream being different than <em>charToRead</em>.</p>
<h3>SbBool SoInput::makeRoomInBuf (size_tnBytes)\fC [protected]\fP</h3>
<p>This function has been obsoleted in Coin.</p>
<h3>void SoInput::convertShort (char *from, short *s)\fC [protected]\fP</h3>
<p>Convert the bytes at <em>from</em> (which must be a short integer in network format (i.e. most significant byte first)) to a short integer in native format which is put at the <em>s</em> pointer.</p>
<h3>void SoInput::convertInt32 (char *from, int32_t *l)\fC [protected]\fP</h3>
<p>Convert the bytes at <em>from</em> (which must be a 32-bit integer in network format (i.e. most significant byte first)) to a 32-bit integer in native format which is put at the <em>l</em> pointer.</p>
<h3>void SoInput::convertFloat (char *from, float *f)\fC [protected]\fP</h3>
<p>Convert the bytes at <em>from</em> (which must be a single-precision floating point number in network format) to a single-precision floating point number in native format which is put at the <em>f</em> pointer.</p>
<h3>void SoInput::convertDouble (char *from, double *d)\fC [protected]\fP</h3>
<p>Convert the bytes at <em>from</em> (which must be a double-precision floating point number in network format) to a double-precision floating point number in native format which is put at the <em>d</em> pointer.</p>
<h3>void SoInput::convertShortArray (char *from, short *to, intlen)\fC [protected]\fP</h3>
<p>Convert a block of short numbers in network format to native format.</p><p><strong>See also:</strong></p><p><strong>convertShort()</strong></p>
<h3>void SoInput::convertInt32Array (char *from, int32_t *to, intlen)\fC [protected]\fP</h3>
<p>Convert a block of 32-bit integer numbers in network format to native format.</p><p><strong>See also:</strong></p><p><strong>convertInt32()</strong></p>
<h3>void SoInput::convertFloatArray (char *from, float *to, intlen)\fC [protected]\fP</h3>
<p>Convert a block of single-precision floating point numbers in network format to native format.</p><p><strong>See also:</strong></p><p><strong>convertFloat()</strong></p>
<h3>void SoInput::convertDoubleArray (char *from, double *to, intlen)\fC [protected]\fP</h3>
<p>Convert a block of double-precision floating point numbers in network format to native format.</p><p><strong>See also:</strong></p><p><strong>convertDouble()</strong></p>
<h3>SbBool SoInput::isFileURL (const char *url)\fC [protected]\fP</h3>
<p>This function is part of the TGS Inventor API, but is not implemented in Coin.</p>
<h3>char * SoInput::URLToFile (char *out_buf, const char *in_buf)\fC [protected]\fP</h3>
<p>This function is part of the TGS Inventor API, but is not implemented in Coin.</p>
<h3>SbBool SoInput::IsURL (const char *c_strng)\fC [protected]\fP</h3>
<p>This function is part of the TGS Inventor API, but is not implemented in Coin.</p>
<h3>void SoInput::setDirectories (\fBSbStringList\fP *dirs)\fC [static]\fP, \fC [protected]\fP</h3>
<p>Set up the directory search path directly with the list of directories in <em>dirs</em>. Note that '.' should be part of the directory list if you want to handle files specified by a relative path.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoInfo.3.html"><span aria-hidden="true">&larr;</span> SoInfo.3: The soinfo class is a node for holding text information.  this is simply a placeholder for textual information about a scene. typically used for specifying author and copyright information in inventor format files, but can also be used for other purposes, of course.</a></li>
   <li class="next"><a href="SoInt32Element.3.html">SoInt32Element.3: The soint32element class is the base class for elements that simply store a 32-bit integer.  this is the superclass of elements where the new element data replaces the old data, and where the data the element stores is a simple 32-bit integer value. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Text::RecordParser: Read record-oriented files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Read record-oriented files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Text::RecordParser (3pm) manual">
  <meta name="twitter:description" content="Read record-oriented files">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtext-recordparser-perl-Text::RecordParser-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Text::RecordParser.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Text::RecordParser (3pm) manual" />
  <meta property="og:description" content="Read record-oriented files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtext-recordparser-perl-Text::RecordParser-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Text::RecordParser<small> (3pm)</small></h1>
        <p class="lead">Read record-oriented files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Text::RecordParser.3pm.html">
      <span itemprop="name">Text::RecordParser: Read record-oriented files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtext-recordparser-perl/">
      <span itemprop="name">libtext-recordparser-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Text::RecordParser.3pm.html">
      <span itemprop="name">Text::RecordParser: Read record-oriented files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Text::RecordParser;

  # use default record (&#92;n) and field (,) separators
  my $p = Text::RecordParser-&gt;new( $file );

  # or be explicit
  my $p = Text::RecordParser-&gt;new({
      filename        =&gt; $file,
      field_separator =&gt; "&#92;t",
  });

  $p-&gt;filename(&apos;foo.csv&apos;);

  # Split records on two newlines
  $p-&gt;record_separator("&#92;n&#92;n");

  # Split fields on tabs
  $p-&gt;field_separator("&#92;t");

  # Skip lines beginning with hashes
  $p-&gt;comment( qr/^#/ );

  # Trim whitespace
  $p-&gt;<strong>trim</strong>(1);

  # Use the fields in the first line as column names
  $p-&gt;bind_header;

  # Get a list of the header fields (in order)
  my @columns = $p-&gt;field_list;

  # Extract a particular field from the next row
  my ( $name, $age ) = $p-&gt;extract( qw[name age] );

  # Return all the fields from the next row
  my @fields = $p-&gt;fetchrow_array;

  # Define a field alias
  $p-&gt;set_field_alias( name =&gt; &apos;handle&apos; );

  # Return all the fields from the next row as a hashref
  my $record = $p-&gt;fetchrow_hashref;
  print $record-&gt;{&apos;name&apos;};
  # or
  print $record-&gt;{&apos;handle&apos;};

  # Return the record as an object with fields as accessors
  my $object = $p-&gt;fetchrow_object;
  print $object-&gt;name; # or $object-&gt;handle;

  # Get all data as arrayref of arrayrefs
  my $data = $p-&gt;fetchall_arrayref;

  # Get all data as arrayref of hashrefs
  my $data = $p-&gt;fetchall_arrayref( { Columns =&gt; {} } );

  # Get all data as hashref of hashrefs
  my $data = $p-&gt;fetchall_hashref(&apos;name&apos;);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is for reading record-oriented data in a delimited text file.  The most common example have records separated by newlines and fields separated by commas or tabs, but this module aims to provide a consistent interface for handling sequential records in a file however they may be delimited.  Typically this data lists the fields in the first line of the file, in which case you should call \*(C`bind_header\*(C' to bind the field name (or not, and it will be called implicitly).  If the first line contains data, you can still bind your own field names via \*(C`bind_fields\*(C'.  Either way, you can then use many methods to get at the data as arrays or hashes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>new</h3>
<p>This is the object constructor.  It takes a hash (or hashref) of arguments.  Each argument can also be set through the method of the same name.</p><ul>
<li><p>filename The path to the file being read.  If the filename is passed and the fh is not, then it will open a filehandle on that file and sets \*(C`fh\*(C' accordingly.</p></li><li><p>comment A compiled regular expression identifying comment lines that should be skipped.</p></li><li><p>data The data to read.</p></li><li><p>fh The filehandle of the file to read.</p></li><li><p>field_separator | fs The field separator (default is comma).</p></li><li><p>record_separator | rs The record separator (default is newline).</p></li><li><p>field_filter A callback applied to all the fields as they are read.</p></li><li><p>header_filter A callback applied to the column names.</p></li><li><p>trim Boolean to enable trimming of leading and trailing whitespace from fields (useful if splitting on whitespace only).</p></li>
</ul><p>See methods for each argument name for more information.</p><p>Alternately, if you supply a single argument to \*(C`new\*(C', it will be treated as the \*(C`filename\*(C' argument.</p>
<h3>bind_fields</h3>
<p>  $p-&gt;bind_fields( qw[ name rank serial_number ] );</p><p>Takes an array of field names and memorizes the field positions for later use.  If the input file has no header line but you still wish to retrieve the fields by name (or even if you want to call \*(C`bind_header\*(C' and then give your own field names), simply pass in the an array of field names you wish to use.</p><p>Pass in an empty array reference to unset:</p><p>  $p-&gt;bind_field( [] ); # unsets fields</p>
<h3>bind_header</h3>
<p>  $p-&gt;bind_header;   my $name = $p-&gt;extract(&apos;name&apos;);</p><p>Takes the fields from the next row under the cursor and assigns the field names to the values.  Usually you would call this immediately after opening the file in order to bind the field names in the first row.</p>
<h3>comment</h3>
<p>  $p-&gt;comment( qr/^#/ );  # Perl-style comments   $p-&gt;comment( qr/^--/ ); # SQL-style comments</p><p>Takes a regex to apply to a record to see if it looks like a comment to skip.</p>
<h3>data</h3>
<p>  $p-&gt;data( $string );   $p-&gt;data( &#92;$string );   $p-&gt;data( @lines );   $p-&gt;data( [$line1, $line2, $line3] );   $p-&gt;data( IO::File-&gt;new(&apos;&lt;data&apos;) );</p><p>Allows a scalar, scalar reference, glob, array, or array reference as the thing to read instead of a file handle.</p><p>It's not advised to pass a filehandle to \*(C`data\*(C' as it will read the entire contents of the file rather than one line at a time if you set it via \*(C`fh\*(C'.</p>
<h3>extract</h3>
<p>  my ( $foo, $bar, $baz ) = $p-&gt;extract( qw[ foo bar baz ] );</p><p>Extracts a list of fields out of the last row read.  The field names must correspond to the field names bound either via \*(C`bind_fields\*(C' or \*(C`bind_header\*(C'.</p>
<h3>fetchrow_array</h3>
<p>  my @values = $p-&gt;fetchrow_array;</p><p>Reads a row from the file and returns an array or array reference of the fields.</p>
<h3>fetchrow_hashref</h3>
<p>  my $record = $p-&gt;fetchrow_hashref;   print "Name = ", $record-&gt;{&apos;name&apos;}, "&#92;n";</p><p>Reads a line of the file and returns it as a hash reference.  The keys of the hashref are the field names bound via \*(C`bind_fields\*(C' or \*(C`bind_header\*(C'.  If you do not bind fields prior to calling this method, the \*(C`bind_header\*(C' method will be implicitly called for you.</p>
<h3>fetchrow_object</h3>
<p>  while ( my $object = $p-&gt;fetchrow_object ) {       my $id   = $object-&gt;id;       my $name = $object-&gt;naem; # &lt;-- this will throw a runtime error   }</p><p>This will return the next data record as a Text::RecordParser::Object object that has read-only accessor methods of the field names and any aliases.  This allows you to enforce field names, further helping ensure that your code is reading the input file correctly.  That is, if you are using the \*(L"fetchrow_hashref\*(R" method to read each line, you may misspell the hash key and introduce a bug in your code.  With this method, Perl will throw an error if you attempt to read a field not defined in the file's headers.  Additionally, any defined field aliases will be created as additional accessor methods.</p>
<h3>fetchall_arrayref</h3>
<p>  my $records = $p-&gt;fetchall_arrayref;   for my $record ( @$records ) {       print "Name = ", $record-&gt;[0], "&#92;n";   }</p><p>  my $records = $p-&gt;fetchall_arrayref( { Columns =&gt; {} } );   for my $record ( @$records ) {       print "Name = ", $record-&gt;{&apos;name&apos;}, "&#92;n";   }</p><p>Like \s-1DBI\s0's fetchall_arrayref, returns an arrayref of arrayrefs.  Also accepts optional \*(L"{ Columns =&gt; {} }\*(R" argument to return an arrayref of hashrefs.</p>
<h3>fetchall_hashref</h3>
<p>  my $records = $p-&gt;fetchall_hashref(&apos;id&apos;);   for my $id ( keys %$records ) {       my $record = $records-&gt;{ $id };       print "Name = ", $record-&gt;{&apos;name&apos;}, "&#92;n";   }</p><p>Like \s-1DBI\s0's fetchall_hashref, this returns a hash reference of hash references.  The keys of the top-level hashref are the field values of the field argument you supply.  The field name you supply can be a field created by a \*(C`field_compute\*(C'.</p>
<h3>fh</h3>
<p>  open my $fh, &apos;&lt;&apos;, $file or die $!;   $p-&gt;fh( $fh );</p><p>Gets or sets the filehandle of the file being read.</p>
<h3>field_compute</h3>
<p>A callback applied to the fields identified by position (or field name if \*(C`bind_fields\*(C' or \*(C`bind_header\*(C' was called).</p><p>The callback will be passed two arguments:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>The current field</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>A reference to all the other fields, either as an array or hash reference, depending on the method which you called.</p>
  </dd>

</dl>
<p>If data looks like this:</p><p>  parent    children   Mike      Greg,Peter,Bobby   Carol     Marcia,Jane,Cindy</p><p>You could split the \*(L"children\*(R" field into an array reference with the values like so:</p><p>  $p-&gt;field_compute( &apos;children&apos;, sub { [ split /,/, shift() ] } );</p><p>The field position or name doesn't actually have to exist, which means you could create new, computed fields on-the-fly.  E.g., if you data looks like this:</p><p>    1,3,5     32,4,1     9,5,4</p><p>You could write a field_compute like this:</p><p>    $p-&gt;field_compute( 3,         sub {             my ( $cur, $others ) = @_;             my $sum;             $sum += $_ for @$others;             return $sum;         }     );</p><p>Field \*(L"3\*(R" will be created as the sum of the other fields.  This allows you to further write:</p><p>    my $data = $p-&gt;fetchall_arrayref;     for my $rec ( @$data ) {         print "$rec-&gt;[0] + $rec-&gt;[1] + $rec-&gt;[2] = $rec-&gt;[3]&#92;n";     }</p><p>Prints:</p><p>    1 + 3 + 5 = 9     32 + 4 + 1 = 37     9 + 5 + 4 = 18</p>
<h3>field_filter</h3>
<p>  $p-&gt;field_filter( sub { $_ = shift; uc(lc($_)) } );</p><p>A callback which is applied to each field.  The callback will be passed the current value of the field.  Whatever is passed back will become the new value of the field.  The above example capitalizes field values.  To unset the filter, pass in the empty string.</p>
<h3>field_list</h3>
<p>  $p-&gt;bind_fields( qw[ foo bar baz ] );   my @fields = $p-&gt;field_list;   print join &apos;, &apos;, @fields; # prints "foo, bar, baz"</p><p>Returns the fields bound via \*(C`bind_fields\*(C' (or \*(C`bind_header\*(C').</p>
<h3>field_positions</h3>
<p>  my %positions = $p-&gt;field_positions;</p><p>Returns a hash of the fields and their positions bound via \*(C`bind_fields\*(C' (or \*(C`bind_header\*(C').  Mostly for internal use.</p>
<h3>field_separator</h3>
<p>  $p-&gt;field_separator("&#92;t");     # splits fields on tabs   $p-&gt;field_separator(&apos;::&apos;);     # splits fields on double colons   $p-&gt;field_separator(qr/&#92;s+/);  # splits fields on whitespace   my $sep = $p-&gt;field_separator; # returns the current separator</p><p>Gets and sets the token to use as the field delimiter.  Regular expressions can be specified using qr//.  If not specified, it will take a guess based on the filename extension (\*(L"comma\*(R" for \*(L".txt,\*(R" \*(L".dat,\*(R" or \*(L".csv\*(R"; \*(L"tab\*(R" for \*(L".tab\*(R").  The default is a comma.</p>
<h3>filename</h3>
<p>  $p-&gt;filename(&apos;/path/to/file.dat&apos;);</p><p>Gets or sets the complete path to the file to be read.  If a file is already opened, then the handle on it will be closed and a new one opened on the new file.</p>
<h3>get_field_aliases</h3>
<p>  my @aliases = $p-&gt;get_field_aliases(&apos;name&apos;);</p><p>Allows you to define alternate names for fields, e.g., sometimes your input file calls city \*(L"town\*(R" or \*(L"township,\*(R" sometimes a file uses \*(L"Moniker\*(R" instead of \*(L"name.\*(R"</p>
<h3>header_filter</h3>
<p>  $p-&gt;header_filter( sub { $_ = shift; s/&#92;s+/_/g; lc $_ } );</p><p>A callback applied to column header names.  The callback will be passed the current value of the header.  Whatever is returned will become the new value of the header.  The above example collapses spaces into a single underscore and lowercases the letters.  To unset a filter, pass in the empty string.</p>
<h3>record_separator</h3>
<p>  $p-&gt;record_separator("&#92;n//&#92;n");   $p-&gt;field_separator("&#92;n");</p><p>Gets and sets the token to use as the record separator.  The default is a newline (\*(L"&#92;n\*(R").</p><p>The above example would read a file that looks like this:</p><p>  field1   field2   field3   //   data1   data2   data3   //</p>
<h3>set_field_alias</h3>
<p>  $p-&gt;set_field_alias({       name =&gt; &apos;Moniker,handle&apos;,        # comma-separated string       city =&gt; [ qw( town township ) ], # or anonymous arrayref   });</p><p>Allows you to define alternate names for fields, e.g., sometimes your input file calls city \*(L"town\*(R" or \*(L"township,\*(R" sometimes a file uses \*(L"Moniker\*(R" instead of \*(L"name.\*(R"</p>
<h3>trim</h3>
<p>  my $trim_value = $p-&gt;<strong>trim</strong>(1);</p><p>Provide \*(L"true\*(R" argument to remove leading and trailing whitespace from fields.  Use a \*(L"false\*(R" argument to disable.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Ken Youens-Clark &lt;kclark@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>http://github.com/kyclark/text-recordparser</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREDITS</h2>
        <div class="sectioncontent">
<p>Thanks to the following:</p><ul>
<li><p>Benjamin Tilly For Text::xSV, the inspirado for this module</p></li><li><p>Tim Bunce et al. For \s-1DBI\s0, from which many of the methods were shamelessly stolen</p></li><li><p>Tom Aldcroft For contributing code to make it easy to parse whitespace-delimited data</p></li><li><p>Liya Ren For catching the column-ordering error when parsing with \*(L"no-headers\*(R"</p></li><li><p>Sharon Wei For catching bug in \*(C`extract\*(C' that sets up infinite loops</p></li><li><p>Lars Thegler For bug report on missing \*(L"script_files\*(R" arg in Build.PL</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>None known.  Please use http://rt.cpan.org/ for reporting bugs.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2006-10 Ken Youens-Clark.  All rights reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the terms of the \s-1GNU\s0 General Public License as published by the Free Software Foundation; version 2.</p><p>This program is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0 General Public License for more details.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Text::Patch.3pm.html"><span aria-hidden="true">&larr;</span> Text::Patch.3pm: Patches text with given patch</a></li>
   <li class="next"><a href="Text::RecordParser::Object.3pm.html">Text::RecordParser::Object.3pm: Read delimited text files as objects <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

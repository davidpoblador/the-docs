<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mail::IMAPTalk: Imap client interface with lots of features</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Imap client interface with lots of features">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Mail::IMAPTalk (3pm) manual">
  <meta name="twitter:description" content="Imap client interface with lots of features">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmail-imaptalk-perl-Mail::IMAPTalk-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Mail::IMAPTalk.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Mail::IMAPTalk (3pm) manual" />
  <meta property="og:description" content="Imap client interface with lots of features" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmail-imaptalk-perl-Mail::IMAPTalk-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Mail::IMAPTalk<small> (3pm)</small></h1>
        <p class="lead">Imap client interface with lots of features</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::IMAPTalk.3pm.html">
      <span itemprop="name">Mail::IMAPTalk: Imap client interface with lots of features</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmail-imaptalk-perl/">
      <span itemprop="name">libmail-imaptalk-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::IMAPTalk.3pm.html">
      <span itemprop="name">Mail::IMAPTalk: Imap client interface with lots of features</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Mail::IMAPTalk;

  $IMAP = Mail::IMAPTalk-&gt;new(
      Server   =&gt; $IMAPServer,
      Username =&gt; &apos;foo&apos;,
      Password =&gt; &apos;bar&apos;,
      Uid      =&gt; 1 )
    || die "Failed to connect/login to IMAP server";

  # Append message to folder
  open(my $F, &apos;rfc822msg.txt&apos;);
  $IMAP-&gt;append($FolderName, $F) || dir $@;
  close($F);

  # Select folder and get first unseen message
  $IMAP-&gt;select($FolderName) || die $@;
  $MsgId = $IMAP-&gt;search(&apos;not&apos;, &apos;seen&apos;)-&gt;[0];

  # Get message envelope and print some details
  $MsgEV = $IMAP-&gt;fetch($MsgId, &apos;envelope&apos;)-&gt;{$MsgId}-&gt;{envelope};
  print "From: " . $MsgEv-&gt;{From};
  print "To: " . $MsgEv-&gt;{To};
  print "Subject: " . $MsgEv-&gt;{Subject};

  # Get message body structure
  $MsgBS = $IMAP-&gt;fetch($MsgId, &apos;bodystructure&apos;)-&gt;{$MsgId}-&gt;{bodystructure};

  # Find imap part number of text part of message
  $MsgTxtHash = Mail::IMAPTalk::find_message($MsgBS);
  $MsgPart = $MsgTxtHash-&gt;{text}-&gt;{&apos;IMAP-Partnum&apos;};

  # Retrieve message text body
  $MsgTxt = $IMAP-&gt;fetch($MsgId, "body[$MsgPart]")-&gt;{$MsgId}-&gt;{body};

  $IMAP-&gt;logout();
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module communicates with an \s-1IMAP\s0 server. Each \s-1IMAP\s0 server command is mapped to a method of this object.</p><p>Although other \s-1IMAP\s0 modules exist on \s-1CPAN\s0, this has several advantages over other modules.</p><ul>
<li><p>It parses the more complex \s-1IMAP\s0 structures like envelopes and body structures into nice Perl data structures.</p></li><li><p>It correctly supports atoms, quoted strings and literals at any point. Some parsers in other modules aren't fully \s-1IMAP\s0 compatiable and may break at odd times with certain messages on some servers.</p></li><li><p>It allows large return values (eg. attachments on a message) to be read directly into a file, rather than into memory.</p></li><li><p>It includes some helper functions to find the actual text/plain or text/html part of a message out of a complex \s-1MIME\s0 structure. It also can find a list of attachements, and \s-1CID\s0 links for \s-1HTML\s0 messages with attached images.</p></li><li><p>It supports decoding of \s-1MIME\s0 headers to Perl utf-8 strings automatically, so you don't have to deal with \s-1MIME\s0 encoded headers (enabled optionally).</p></li>
</ul><p>While the \s-1IMAP\s0 protocol does allow for asynchronous running of commands, this module is designed to be used in a synchronous manner. That is, you issue a command by calling a method, and the command will block until the appropriate response is returned. The method will then return the parsed results from the given command.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLASS OVERVIEW</h2>
        <div class="sectioncontent">
<p>The object methods have been broken in several sections.</p><h3>Sections</h3>

<dl class='dl-vertical'>
  <dt>
    \s-1CONSTANTS\s0
  </dt>
  <dd>
    <p>Lists the available constants the class uses.</p>
  </dd>
  <dt>
    \s-1CONSTRUCTOR\s0
  </dt>
  <dd>
    <p>Explains all the options available when constructing a new instance of the \*(C`Mail::IMAPTalk\*(C' class.</p>
  </dd>
  <dt>
    \s-1CONNECTION\s0 \s-1CONTROL\s0 \s-1METHODS\s0
  </dt>
  <dd>
    <p>These are methods which control the overall \s-1IMAP\s0 connection object, such as logging in and logging out, how results are parsed, how folder names and message id's are treated, etc.</p>
  </dd>
  <dt>
    \s-1IMAP\s0 \s-1FOLDER\s0 \s-1COMMAND\s0 \s-1METHODS\s0
  </dt>
  <dd>
    <p>These are methods to inspect, add, delete and rename \s-1IMAP\s0 folders on the server.</p>
  </dd>
  <dt>
    \s-1IMAP\s0 \s-1MESSAGE\s0 \s-1COMMAND\s0 \s-1METHODS\s0
  </dt>
  <dd>
    <p>These are methods to retrieve, delete, move and add messages to/from \s-1IMAP\s0 folders.</p>
  </dd>
  <dt>
    \s-1HELPER\s0 \s-1METHODS\s0
  </dt>
  <dd>
    <p>These are extra methods that users of this class might find useful. They generally do extra parsing on returned structures to provide higher level functionality.</p>
  </dd>
  <dt>
    \s-1INTERNAL\s0 \s-1METHODS\s0
  </dt>
  <dd>
    <p>These are methods used internally by the \*(C`Mail::IMAPTalk\*(C' object to get work done. They may be useful if you need to extend the class yourself. Note that internal methods will always 'die' if they encounter any errors.</p>
  </dd>
  <dt>
    \s-1INTERNAL\s0 \s-1SOCKET\s0 \s-1FUNCTIONS\s0
  </dt>
  <dd>
    <p>These are functions used internally by the \*(C`Mail::IMAPTalk\*(C' object to read/write data to/from the \s-1IMAP\s0 connection socket. The class does its own buffering so if you want to read/write to the \s-1IMAP\s0 socket, you should use these functions.</p>
  </dd>
  <dt>
    \s-1INTERNAL\s0 \s-1PARSING\s0 \s-1FUNCTIONS\s0
  </dt>
  <dd>
    <p>These are functions used to parse the results returned from the \s-1IMAP\s0 server into Perl style data structures.</p>
  </dd>

</dl>

<h3>Method results</h3>
<p>All methods return undef on failure. There are four main modes of failure:</p>
<dl class='dl-vertical'>
  <dt>
    1. An error occurred reading/writing to a socket. Maybe the server closed it, or you're not connected to any server.
  </dt>
  <dd>
    
  </dd>
  <dt>
    2. An error occurred parsing the response of an \s-1IMAP\s0 command. This is usually only a problem if your \s-1IMAP\s0 server returns invalid data.
  </dt>
  <dd>
    
  </dd>
  <dt>
    3. An \s-1IMAP\s0 command didn't return an '\s-1OK\s0' response.
  </dt>
  <dd>
    
  </dd>
  <dt>
    4. The socket read operation timed out waiting for a response from the server.
  </dt>
  <dd>
    
  </dd>

</dl>
<p>In each case, some readable form of error text is placed in $@, or you can call the \*(C`get_last_error()\*(C' method. For commands which return responses (e.g. fetch, getacl, etc), the result is returned. See each command for details of the response result. For commands with no response but which succeed (e.g. setacl, rename, etc) the result 'ok' is generally returned.</p>
<h3>Method parameters</h3>
<p>All methods which send data to the \s-1IMAP\s0 server (e.g. \*(C`fetch()\*(C', \*(C`search()\*(C', etc) have their arguments processed before they are sent. Arguments may be specified in several ways:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>scalar</strong>
  </dt>
  <dd>
    <p>The value is first checked and quoted if required. Values containing [&#92;000&#92;012&#92;015] are turned into literals, values containing [&#92;000-&#92;040&#92;{&#92;} &#92;%&#92;*&#92;\*(L"] are quoted by surrounding with a \*(R"...\*(L" pair (any \*(R" themselves are turned into &#92;"). undef is turned into \s-1NIL\s0</p>
  </dd>
  <dt>
    <strong>file ref</strong>
  </dt>
  <dd>
    <p>The contents of the file is sent as an \s-1IMAP\s0 literal. Note that because IMAPTalk has to know the length of the file being sent, this must be a true file reference that can be seeked and not just some stream. The entire file will be sent regardless of the current seek point.</p>
  </dd>
  <dt>
    <strong>scalar ref</strong>
  </dt>
  <dd>
    <p>The string/data in the referenced item should be sent as is, no quoting will occur, and the data won't be sent as quoted or as a literal regardless of the contents of the string/data.</p>
  </dd>
  <dt>
    <strong>array ref</strong>
  </dt>
  <dd>
    <p>Emits an opening bracket, and then each item in the array separated by a space, and finally a closing bracket. Each item in the array is processed by the same methods, so can be a scalar, file ref, scalar ref, another array ref, etc.</p>
  </dd>
  <dt>
    <strong>hash ref</strong>
  </dt>
  <dd>
    <p>The hash reference should contain only 1 item. The key is a text string which specifies what to do with the value item of the hash.</p><ul>
<li><p>'Literal' The string/data in the value is sent as an \s-1IMAP\s0 literal regardless of the actual data in the string/data.</p></li><li><p>'Quote' The string/data in the value is sent as an \s-1IMAP\s0 quoted string regardless of the actual data in the string/data.</p></li>
</ul><p>Examples:     # Password is automatically quoted to "nasty%*&#92;"passwd"     $IMAP-&gt;login("joe", &apos;nasty%*"passwd&apos;);     # Append $MsgTxt as string     $IMAP-&gt;append("inbox", { Literal =&gt; $MsgTxt })     # Append MSGFILE contents as new message     $IMAP-&gt;append("inbox", &#92;*MSGFILE ])</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTANTS</h2>
        <div class="sectioncontent">
<p>These constants relate to the standard 4 states that an \s-1IMAP\s0 connection can be in. They are passed and returned from the \*(C`state()\*(C' method. See \s-1RFC\s0 3501 for more details about \s-1IMAP\s0 connection states.</p>
<dl class='dl-vertical'>
  <dt>
    <em>Unconnected</em>
  </dt>
  <dd>
    <p>Current not connected to any server.</p>
  </dd>
  <dt>
    <em>Connected</em>
  </dt>
  <dd>
    <p>Connected to a server, but not logged in.</p>
  </dd>
  <dt>
    <em>Authenticated</em>
  </dt>
  <dd>
    <p>Connected and logged into a server, but not current folder.</p>
  </dd>
  <dt>
    <em>Selected</em>
  </dt>
  <dd>
    <p>Connected, logged in and have 'select'ed a current folder.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTOR</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>Mail::IMAPTalk-&gt;new(%Options)</em>
  </dt>
  <dd>
    <p>Creates new Mail::IMAPTalk object. The following options are supported.</p>
  </dd>
  <dt>
    <strong>Connection Options</strong>
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    <strong>Server</strong>
  </dt>
  <dd>
    <p>The hostname or \s-1IP\s0 address to connect to. This must be supplied unless the <strong>Socket</strong> option is supplied.</p>
  </dd>
  <dt>
    <strong>Port</strong>
  </dt>
  <dd>
    <p>The port number on the host to connect to. Defaults to 143 if not supplied.</p>
  </dd>
  <dt>
    <strong>Socket</strong>
  </dt>
  <dd>
    <p>An existing socket to use as the connection to the \s-1IMAP\s0 server. If you supply the <strong>Socket</strong> option, you should not supply a <strong>Server</strong> or <strong>Port</strong> option. This is useful if you want to create an \s-1SSL\s0 socket connection using IO::Socket::SSL and then pass in the connected socket to the <em>new()</em> call. It's also useful in conjunction with the \*(C`release_socket()\*(C' method described below for reusing the same socket beyond the lifetime of the IMAPTalk object. See a description in the section \*(C`release_socket()\*(C' method for more information. You must have write flushing enabled for any socket you pass in here so that commands will actually be sent, and responses received, rather than just waiting and eventually timing out. you can do this using the Perl \*(C`select()\*(C' call and $| ($AUTOFLUSH) variable as shown below.   my $ofh = select($Socket); $| = 1; select ($ofh);</p>
  </dd>
  <dt>
    <strong>UseBlocking</strong>
  </dt>
  <dd>
    <p>For historical reasons, when reading from a socket, the module sets the socket to non-blocking and does a <em>select()</em>. If you're using an \s-1SSL\s0 socket that doesn't work, so you have to set UseBlocking to true to use blocking reads instead.</p>
  </dd>
  <dt>
    <strong>State</strong>
  </dt>
  <dd>
    <p>If you supply a \*(C`Socket\*(C' option, you can specify the \s-1IMAP\s0 state the socket is currently in, namely one of 'Unconnected', 'Connected', 'Authenticated' or 'Selected'. This defaults to 'Connected' if not supplied and the \*(C`Socket\*(C' option is supplied.</p>
  </dd>
  <dt>
    <strong>ExpectGreeting</strong>
  </dt>
  <dd>
    <p>If supplied and true, and a socket is supplied via the \*(C`Socket\*(C' option, checks that a greeting line is supplied by the server and reads the greeting line.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>Login Options</strong>
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    <strong>Username</strong>
  </dt>
  <dd>
    <p>The username to connect to the \s-1IMAP\s0 server as. If not supplied, no login is attempted and the \s-1IMAP\s0 object is left in the <strong>\s-1CONNECTED\s0</strong> state. If supplied, you must also supply the <strong>Password</strong> option and a login is attempted. If the login fails, the connection is closed and <strong>undef</strong> is returned. If you want to do something with a connection even if the login fails, don't pass a <strong>Username</strong> option, but instead use the <strong>login</strong> method described below.</p>
  </dd>
  <dt>
    <strong>Password</strong>
  </dt>
  <dd>
    <p>The password to use to login to the account.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>\s-1IMAP\s0 message/folder options</strong>
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    <strong>Uid</strong>
  </dt>
  <dd>
    <p>Control whether message ids are message uids or not. This is 1 (on) by default because generally that's how most people want to use it. This affects most commands that require/use/return message ids (e.g. <strong>fetch</strong>, <strong>search</strong>, <strong>sort</strong>, etc)</p>
  </dd>
  <dt>
    <strong>RootFolder</strong>
  </dt>
  <dd>
    <p>If supplied, sets the root folder prefix. This is the same as calling \*(C`set_root_folder()\*(C' with the value passed. If no value is supplied, \*(C`set_root_folder()\*(C' is called with no value. See the \*(C`set_root_folder()\*(C' method for more details.</p>
  </dd>
  <dt>
    <strong>Separator</strong>
  </dt>
  <dd>
    <p>If supplied, sets the folder name text string separator character. Passed as the second parameter to the \*(C`set_root_folder()\*(C' method.</p>
  </dd>
  <dt>
    <strong>CaseInsensitive</strong>
  </dt>
  <dd>
    <p>If supplied, passed along with RootFolder to the \*(C`set_root_folder()\*(C' method.</p>
  </dd>
  <dt>
    <strong>AltRootRegexp</strong>
  </dt>
  <dd>
    <p>If supplied, passed along with RootFolder to the \*(C`set_root_folder()\*(C' method.</p>
  </dd>

</dl>
<p>Examples:   $imap = Mail::IMAPTalk-&gt;new(             Server          =&gt; &apos;foo.com&apos;,             Port            =&gt; 143,             Username        =&gt; &apos;joebloggs&apos;,             Password        =&gt; &apos;mypassword&apos;,             Separator       =&gt; &apos;.&apos;,             RootFolder      =&gt; &apos;inbox&apos;,             CaseInsensitive =&gt; 1)           || die "Connection to foo.com failed. Reason: $@";</p><p>  $imap = Mail::IMAPTalk-&gt;new(             Socket =&gt; $SSLSocket,             State  =&gt; Mail::IMAPTalk::Authenticated,             Uid    =&gt; 0)           || die "Could not query on existing socket. Reason: $@";</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONNECTION CONTROL METHODS</h2>
        <div class="sectioncontent">
<p>Attempt to login user specified username and password. Currently there is only plain text password login support. If someone can give me a hand implementing others (like \s-1DIGEST-MD5\s0, \s-1CRAM-MD5\s0, etc) please contact me (see details below).</p>
<dl class='dl-vertical'>
  <dt>
    <em></em><em>logout()</em><em></em>
  </dt>
  <dd>
    <p>Log out of \s-1IMAP\s0 server. This usually closes the servers connection as well. Set/get the current \s-1IMAP\s0 connection state. Returned or passed value should be one of the constants (Unconnected, Connected, Authenticated, Selected). Get/set the \s-1UID\s0 status of all \s-1UID\s0 possible \s-1IMAP\s0 commands. If set to 1, all commands that can take a \s-1UID\s0 are set to '\s-1UID\s0 Mode', where any \s-1ID\s0 sent to IMAPTalk is assumed to be a \s-1UID\s0.</p>
  </dd>
  <dt>
    <em></em><em>capability()</em><em></em>
  </dt>
  <dd>
    <p>This method returns the \s-1IMAP\s0 servers capability command results. The result is a hash reference of (lc(Capability) =&gt; 1) key value pairs. This means you can do things like:   if ($IMAP-&gt;capability()-&gt;{quota}) { ... } to test if the server has the \s-1QUOTA\s0 capability. If you just want a list of capabilities, use the Perl 'keys' function to get a list of keys from the returned hash reference.</p>
  </dd>
  <dt>
    <em></em><em>namespace()</em><em></em>
  </dt>
  <dd>
    <p>Returns the result of the \s-1IMAP\s0 servers namespace command.</p>
  </dd>
  <dt>
    <em></em><em>noop()</em><em></em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'noop' command which does nothing.</p>
  </dd>
  <dt>
    <em>enable($option)</em>
  </dt>
  <dd>
    <p>Enabled the given imap extension</p>
  </dd>
  <dt>
    <em></em><em>is_open()</em><em></em>
  </dt>
  <dd>
    <p>Returns true if the current socket connection is still open (e.g. the socket hasn't been closed this end or the other end due to a timeout). Change the root folder prefix. Some \s-1IMAP\s0 servers require that all user folders/mailboxes live under a root folder prefix (current versions of <strong>cyrus</strong> for example use '\s-1INBOX\s0' for personal folders and 'user' for other users folders). If no value is specified, it sets it to ''. You might want to use the <strong></strong><strong>namespace()</strong><strong></strong> method to find out what roots are available. The $CaseInsensitive argument is a flag that determines whether the root folder should be matched in a case sensitive or insensitive way. See below. Setting this affects all commands that take a folder argument. Basically if the foldername begins with root folder prefix (case sensitive or insensitive based on the second argument), it's left as is, otherwise the root folder prefix and separator char are prefixed to the folder name. The AltRootRegexp is a regexp that if the start of the folder name matches, does not have $RootFolder preprended. You can use this to protect other namespaces in your \s-1IMAP\s0 server. Examples:   # This is what cyrus uses   $IMAP-&gt;set_root_folder(&apos;inbox&apos;, &apos;.&apos;, 1, &apos;user&apos;);</p><p>  # Selects &apos;Inbox&apos; (because &apos;Inbox&apos; eq &apos;inbox&apos; case insensitive)   $IMAP-&gt;select(&apos;Inbox&apos;);   # Selects &apos;inbox.blah&apos;   $IMAP-&gt;select(&apos;blah&apos;);   # Selects &apos;INBOX.fred&apos; (because &apos;INBOX&apos; eq &apos;inbox&apos; case insensitive)   #IMAP-&gt;select(&apos;INBOX.fred&apos;); # Selects &apos;INBOX.fred&apos;   # Selects &apos;user.john&apos; (because &apos;user&apos; is alt root)   #IMAP-&gt;select(&apos;user.john&apos;); # Selects &apos;user.john&apos;</p>
  </dd>
  <dt>
    <em>_set_separator($Separator)</em>
  </dt>
  <dd>
    <p>Checks if the given separator is the same as the one we used before. If not, it calls set_root_folder to recreate the settings with the new Separator. Sets the mode whether to read literals as file handles or scalars. You should pass a filehandle here that any literal will be read into. To turn off literal reads into a file handle, pass a 0. Examples:   # Read rfc822 text of message 3 into file   # (note that the file will have /r/n line terminators)   open(F, "&gt;messagebody.txt");   $IMAP-&gt;literal_handle_control(&#92;*F);   $IMAP-&gt;fetch(3, &apos;rfc822&apos;);   $IMAP-&gt;<strong>literal_handle_control</strong>(0);</p>
  </dd>
  <dt>
    <em>release_socket($Error)</em>
  </dt>
  <dd>
    <p>Release IMAPTalk's ownership of the current socket it's using so it's not disconnected on \s-1DESTROY\s0. This returns the socket, and makes sure that the IMAPTalk object doesn't hold a reference to it any more and the connection state is set to \*(L"Unconnected\*(R". This means you can't call any methods on the IMAPTalk object any more. If the socket is being released due to an error condition on the connection, then $Error is set to true.</p>
  </dd>
  <dt>
    <em></em><em>get_last_error()</em><em></em>
  </dt>
  <dd>
    <p>Returns a text string which describes the last error that occurred.</p>
  </dd>
  <dt>
    <em></em><em>get_last_completion_response()</em><em></em>
  </dt>
  <dd>
    <p>Returns the last completion response to the tagged command. This is either the string \*(L"ok\*(R", \*(L"no\*(R" or \*(L"bad\*(R" (always lower case)</p>
  </dd>
  <dt>
    <em>get_response_code($Response)</em>
  </dt>
  <dd>
    <p>Returns the extra response data generated by a previous call. This is most often used after calling <strong>select</strong> which usually generates some set of the following sub-results.</p><ul>
<li><p><strong>permanentflags</strong> Array reference of flags which are stored permanently.</p></li><li><p><strong>uidvalidity</strong> Whether the current \s-1UID\s0 set is valid. See the \s-1IMAP\s0 \s-1RFC\s0 for more information on this. If this value changes, then all UIDs in the folder have been changed.</p></li><li><p><strong>uidnext</strong> The next \s-1UID\s0 number that will be assigned.</p></li><li><p><strong>exists</strong> Number of messages that exist in the folder.</p></li><li><p><strong>recent</strong> Number of messages that are recent in the folder.</p></li>
</ul><p>Other possible responses are <strong>alert</strong>, <strong>newname</strong>, <strong>parse</strong>, <strong>trycreate</strong>, <strong>appenduid</strong>, etc. The values are stored in a hash keyed on the $Response item. They're kept until either overwritten by a future response, or explicitly cleared via <em>clear_response_code()</em>. Examples:   # Select inbox and get list of permanent flags, uidnext and number   #  of message in the folder   $IMAP-&gt;select(&apos;inbox&apos;);   my $NMessages = $IMAP-&gt;get_response_code(&apos;exists&apos;);   my $PermanentFlags = $IMAP-&gt;get_response_code(&apos;permanentflags&apos;);   my $UidNext = $IMAP-&gt;get_response_code(&apos;uidnext&apos;);</p>
  </dd>
  <dt>
    <em>clear_response_code($Response)</em>
  </dt>
  <dd>
    <p>Clears any response code information. Response code information is not normally cleared between calls. Changes how results of fetch commands are parsed. Available options are:</p>
<dl class='dl-vertical'>
  <dt>
    <em>BodyStructure</em>
  </dt>
  <dd>
    <p>Parse bodystructure into more Perl-friendly structure See the <strong>\s-1FETCH\s0 \s-1RESULTS\s0</strong> section.</p>
  </dd>
  <dt>
    <em>Envelope</em>
  </dt>
  <dd>
    <p>Parse envelopes into more Perl-friendly structure See the <strong>\s-1FETCH\s0 \s-1RESULTS\s0</strong> section.</p>
  </dd>
  <dt>
    <em>Annotation</em>
  </dt>
  <dd>
    <p>Parse annotation (from \s-1RFC\s0 5257) into more Perl-friendly structure See the <strong>\s-1FETCH\s0 \s-1RESULTS\s0</strong> section.</p>
  </dd>
  <dt>
    <em>EnvelopeRaw</em>
  </dt>
  <dd>
    <p>If parsing envelopes, create To/Cc/Bcc and Raw-To/Raw-Cc/Raw-Bcc entries which are array refs of 4 entries each as returned by the \s-1IMAP\s0 server.</p>
  </dd>
  <dt>
    <em>DecodeUTF8</em>
  </dt>
  <dd>
    <p>If parsing envelopes, decode any \s-1MIME\s0 encoded headers into Perl \s-1UTF-8\s0 strings. For this to work, you must have 'used' Mail::IMAPTalk with: use Mail::IMAPTalk qw(:utf8support ...)</p>
  </dd>

</dl>

  </dd>
  <dt>
    <em>set_tracing($Tracer)</em>
  </dt>
  <dd>
    <p>Allows you to trace both \s-1IMAP\s0 input and output sent to the server and returned from the server. This is useful for debugging. Returns the previous value of the tracer and then sets it to the passed value. Possible values for $Tracer are:</p>
<dl class='dl-vertical'>
  <dt>
    <em>0</em>
  </dt>
  <dd>
    <p>Disable all tracing.</p>
  </dd>
  <dt>
    <em>1</em>
  </dt>
  <dd>
    <p>Print to \s-1STDERR\s0.</p>
  </dd>
  <dt>
    <em>Code ref</em>
  </dt>
  <dd>
    <p>Call code ref for each line input and output. Pass line as parameter.</p>
  </dd>
  <dt>
    <em>Glob ref</em>
  </dt>
  <dd>
    <p>Print to glob.</p>
  </dd>
  <dt>
    <em>Scalar ref</em>
  </dt>
  <dd>
    <p>Appends to the referenced scalar.</p>
  </dd>

</dl>
<p>Note: literals are never passed to the tracer.</p>
  </dd>
  <dt>
    <em>set_unicode_folders($Unicode)</em>
  </dt>
  <dd>
    <p>$Unicode should be 1 or 0 Sets whether folder names are expected and returned as perl unicode strings. The default is currently 0, \s-1BUT\s0 \s-1YOU\s0 \s-1SHOULD\s0 \s-1NOT\s0 \s-1ASSUME\s0 \s-1THIS\s0, because it will probably change in the future. If you want to work with perl unicode strings for folder names, you should call</p>
<pre>
  $ImapTalk-&gt;<em>set_unicode_folders</em>\|(1)
</pre>
<p>and IMAPTalk will automatically encode the unicode strings into \s-1IMAP-UTF7\s0 when sending to the \s-1IMAP\s0 server, and will also decode \s-1IMAP-UTF7\s0 back into perl unicode strings when returning results from the \s-1IMAP\s0 server. If you want to work with folder names in \s-1IMAP-UTF7\s0 bytes, then call</p>
<pre>
  $ImapTalk-&gt;<em>set_unicode_folders</em>\|(0)
</pre>
<p>and IMAPTalk will leave folder names as bytes when sending to and returning results from the \s-1IMAP\s0 server.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMAP FOLDER COMMAND METHODS</h2>
        <div class="sectioncontent">
<p><strong>Note:</strong> In all cases where a folder name is used, the folder name is first manipulated according to the current root folder prefix as described in \*(C`set_root_folder()\*(C'. Perform the standard \s-1IMAP\s0 'select' command to select a folder for retrieving/moving/adding messages. If $Opts{ReadOnly} is true, the \s-1IMAP\s0 \s-1EXAMINE\s0 verb is used instead of \s-1SELECT\s0. Mail::IMAPTalk will cache the currently selected folder, and if you issue another -&gt;select(\*(L"\s-1XYZ\s0\*(R") for the folder that is already selected, it will just return immediately. This can confuse code that expects to get side effects of a select call. For that case, call -&gt;<em>unselect()</em> first, then -&gt;<em>select()</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <em></em><em>unselect()</em><em></em>
  </dt>
  <dd>
    <p>Performs the standard \s-1IMAP\s0 unselect command.</p>
  </dd>
  <dt>
    <em>examine($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'examine' command to select a folder in read only mode for retrieving messages. This is the same as \*(C`select($FolderName, 1)\*(C'. See \*(C`select()\*(C' for more details.</p>
  </dd>
  <dt>
    <em>create($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'create' command to create a new folder.</p>
  </dd>
  <dt>
    <em>delete($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'delete' command to delete a folder.</p>
  </dd>
  <dt>
    <em>localdelete($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the \s-1IMAP\s0 'localdelete' command to delete a folder (doesn't delete subfolders even of \s-1INBOX\s0, is always immediate. Perform the standard \s-1IMAP\s0 'rename' command to rename a folder. Perform the standard \s-1IMAP\s0 'list' command to return a list of available folders. Perform the standard \s-1IMAP\s0 'lsub' command to return a list of subscribed folders</p>
  </dd>
  <dt>
    <em>subscribe($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'subscribe' command to subscribe to a folder.</p>
  </dd>
  <dt>
    <em>unsubscribe($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'unsubscribe' command to unsubscribe from a folder.</p>
  </dd>
  <dt>
    <em></em><em>check()</em><em></em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'check' command to checkpoint the current folder. Perform the \s-1IMAP\s0 'setacl' command to set the access control list details of a folder/mailbox. See \s-1RFC\s0 4314 for more details on the \s-1IMAP\s0 \s-1ACL\s0 extension. $User is the user name to set the access rights for. $Rights is either a list of absolute rights to set, or a list prefixed by a - to remove those rights, or a + to add those rights.</p>
<dl class='dl-vertical'>
  <dt>
    l - lookup (mailbox is visible to \s-1LIST/LSUB\s0 commands)
  </dt>
  <dd>
    
  </dd>
  <dt>
    r - read (\s-1SELECT\s0 the mailbox, perform \s-1CHECK\s0, \s-1FETCH\s0, \s-1PARTIAL\s0, \s-1SEARCH\s0, \s-1COPY\s0 from mailbox)
  </dt>
  <dd>
    
  </dd>
  <dt>
    s - keep seen/unseen information across sessions (\s-1STORE\s0 \s-1SEEN\s0 flag)
  </dt>
  <dd>
    
  </dd>
  <dt>
    w - write (\s-1STORE\s0 flags other than \s-1SEEN\s0 and \s-1DELETED\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    i - insert (perform \s-1APPEND\s0, \s-1COPY\s0 into mailbox)
  </dt>
  <dd>
    
  </dd>
  <dt>
    p - post (send mail to submission address for mailbox, not enforced by \s-1IMAP4\s0 itself)
  </dt>
  <dd>
    
  </dd>
  <dt>
    k - create mailboxes (\s-1CREATE\s0 new sub-mailboxes in any implementation-defined hierarchy, parent mailbox for the new mailbox name in \s-1RENAME\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    x - delete mailbox (\s-1DELETE\s0 mailbox, old mailbox name in \s-1RENAME\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    t - delete messages (set or clear &#92;DELETED flag via \s-1STORE\s0, set &#92;DELETED flag during \s-1APPEND/COPY\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    e - perform \s-1EXPUNGE\s0 and expunge as a part of \s-1CLOSE\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    a - administer (perform \s-1SETACL\s0)
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Due to ambiguity in \s-1RFC\s0 2086, some existing \s-1RFC\s0 2086 server implementations use the \*(L"c\*(R" right to control the \s-1DELETE\s0 command. Others chose to use the \*(L"d\*(R" right to control the \s-1DELETE\s0 command. See the 2.1.1. Obsolete Rights in \s-1RFC\s0 4314 for more details.</p>
<dl class='dl-vertical'>
  <dt>
    c - create (\s-1CREATE\s0 new sub-mailboxes in any implementation-defined hierarchy)
  </dt>
  <dd>
    
  </dd>
  <dt>
    d - delete (\s-1STORE\s0 \s-1DELETED\s0 flag, perform \s-1EXPUNGE\s0)
  </dt>
  <dd>
    
  </dd>

</dl>
<p>The standard access control configurations for cyrus are</p><p>Examples:   # Get full access for user &apos;joe&apos; on his own folder   $IMAP-&gt;setacl(&apos;user.joe&apos;, &apos;joe&apos;, &apos;lrswipcda&apos;) || die "IMAP error: $@";   # Remove write, insert, post, create, delete access for user &apos;andrew&apos;   $IMAP-&gt;setacl(&apos;user.joe&apos;, &apos;andrew&apos;, &apos;-wipcd&apos;) || die "IMAP error: $@";   # Add lookup, read, keep unseen information for user &apos;paul&apos;   $IMAP-&gt;setacl(&apos;user.joe&apos;, &apos;paul&apos;, &apos;+lrs&apos;) || die "IMAP error: $@";</p>
  </dd>
  <dt>
    <em>getacl($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the \s-1IMAP\s0 'getacl' command to get the access control list details of a folder/mailbox. See \s-1RFC\s0 4314 for more details on the \s-1IMAP\s0 \s-1ACL\s0 extension. Returns an array of pairs. Each pair is a username followed by the access rights for that user. See <strong>setacl</strong> for more information on access rights. Examples:   my $Rights = $IMAP-&gt;getacl(&apos;user.joe&apos;) || die "IMAP error : $@";   $Rights = [     &apos;joe&apos;, &apos;lrs&apos;,     &apos;andrew&apos;, &apos;lrswipcda&apos;   ];</p><p>  $IMAP-&gt;setacl(&apos;user.joe&apos;, &apos;joe&apos;, &apos;lrswipcda&apos;) || die "IMAP error : $@";   $IMAP-&gt;setacl(&apos;user.joe&apos;, &apos;andrew&apos;, &apos;-wipcd&apos;) || die "IMAP error : $@";   $IMAP-&gt;setacl(&apos;user.joe&apos;, &apos;paul&apos;, &apos;+lrs&apos;) || die "IMAP error : $@";</p><p>  $Rights = $IMAP-&gt;getacl(&apos;user.joe&apos;) || die "IMAP error : $@";   $Rights = [     &apos;joe&apos;, &apos;lrswipcd&apos;,     &apos;andrew&apos;, &apos;lrs&apos;,     &apos;paul&apos;, &apos;lrs&apos;   ]; Perform the \s-1IMAP\s0 'deleteacl' command to delete all access control information for the given user on the given folder. See <strong>setacl</strong> for more information on access rights. Examples:   my $Rights = $IMAP-&gt;getacl(&apos;user.joe&apos;) || die "IMAP error : $@";   $Rights = [     &apos;joe&apos;, &apos;lrswipcd&apos;,     &apos;andrew&apos;, &apos;lrs&apos;,     &apos;paul&apos;, &apos;lrs&apos;   ];</p><p>  # Delete access information for user &apos;andrew&apos;   $IMAP-&gt;deleteacl(&apos;user.joe&apos;, &apos;andrew&apos;) || die "IMAP error : $@";</p><p>  $Rights = $IMAP-&gt;getacl(&apos;user.joe&apos;) || die "IMAP error : $@";   $Rights = [     &apos;joe&apos;, &apos;lrswipcd&apos;,     &apos;paul&apos;, &apos;lrs&apos;   ]; Perform the \s-1IMAP\s0 'setquota' command to set the usage quota details of a folder/mailbox. See \s-1RFC\s0 2087 for details of the \s-1IMAP\s0 quota extension. $QuotaDetails is a bracketed list of limit item/value pairs which represent a particular type of limit and the value to set it to. Current limits are:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1STORAGE\s0 - Sum of messages' \s-1RFC822\s0.SIZE, in units of 1024 octets
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1MESSAGE\s0 - Number of messages
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Examples:   # Set maximum size of folder to 50M and 1000 messages   $IMAP-&gt;setquota(&apos;user.joe&apos;, &apos;(storage 50000)&apos;) || die "IMAP error: $@";   $IMAP-&gt;setquota(&apos;user.john&apos;, &apos;(messages 1000)&apos;) || die "IMAP error: $@";   # Remove quotas   $IMAP-&gt;setquota(&apos;user.joe&apos;, &apos;()&apos;) || die "IMAP error: $@";</p>
  </dd>
  <dt>
    <em>getquota($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'getquota' command to get the quota details of a folder/mailbox. See \s-1RFC\s0 2087 for details of the \s-1IMAP\s0 quota extension. Returns an array reference to quota limit triplets. Each triplet is made of: limit item, current value, maximum value. Note that this only returns the quota for a folder if it actually has had a quota set on it. It's possible that a parent folder might have a quota as well which affects sub-folders. Use the getquotaroot to find out if this is true. Examples:   my $Result = $IMAP-&gt;getquota(&apos;user.joe&apos;) || die "IMAP error: $@";   $Result = [     &apos;STORAGE&apos;, 31, 50000,     &apos;MESSAGE&apos;, 5, 1000   ];</p>
  </dd>
  <dt>
    <em>getquotaroot($FolderName)</em>
  </dt>
  <dd>
    <p>Perform the \s-1IMAP\s0 'getquotaroot' command to get the quota details of a folder/mailbox and possible root quota as well. See \s-1RFC\s0 2087 for details of the \s-1IMAP\s0 quota extension. The result of this command is a little complex. Unfortunately it doesn't map really easily into any structure since there are several different responses. Basically it's a hash reference. The 'quotaroot' item is the response which lists the root quotas that apply to the given folder. The first item is the folder name, and the remaining items are the quota root items. There is then a hash item for each quota root item. It's probably easiest to look at the example below. Examples:   my $Result = $IMAP-&gt;getquotaroot(&apos;user.joe.blah&apos;) || die "IMAP error: $@";   $Result = {     &apos;quotaroot&apos; =&gt; [       &apos;user.joe.blah&apos;, &apos;user.joe&apos;, &apos;&apos;     ],     &apos;user.joe&apos; =&gt; [       &apos;STORAGE&apos;, 31, 50000,       &apos;MESSAGES&apos;, 5, 1000     ],     &apos;&apos; =&gt; [       &apos;MESSAGES&apos;, 3498, 100000     ]   };</p>
  </dd>
  <dt>
    <em>message_count($FolderName)</em>
  </dt>
  <dd>
    <p>Return the number of messages in a folder. See also \*(C`status()\*(C' for getting more information about messages in a folder. Perform the standard \s-1IMAP\s0 'status' command to retrieve status information about a folder/mailbox. The $StatusList is a bracketed list of folder items to obtain the status of. Can contain: messages, recent, uidnext, uidvalidity, unseen. The return value is a hash reference of lc(status-item) =&gt; value. Examples:   my $Res = $IMAP-&gt;status(&apos;inbox&apos;, &apos;(MESSAGES UNSEEN)&apos;);</p><p>  $Res = {     &apos;messages&apos; =&gt; 8,     &apos;unseen&apos; =&gt; 2   }; Performs many \s-1IMAP\s0 'status' commands on a list of folders. Sends all the commands at once and wait for responses. This speeds up latency issues. Returns a hash ref of folder name =&gt; status results. If an error occurs, the annotation result is a scalar ref to the completion response string (eg 'bad', 'no', etc) Perform the \s-1IMAP\s0 'getannotation' command to get the annotation(s) for a mailbox.  See imap-annotatemore extension for details. Examples:   my $Result = $IMAP-&gt;getannotation(&apos;user.joe.blah&apos;, &apos;/*&apos; &apos;*&apos;) || die "IMAP error: $@";   $Result = {     &apos;user.joe.blah&apos; =&gt; {       &apos;/vendor/cmu/cyrus-imapd/size&apos; =&gt; {         &apos;size.shared&apos; =&gt; &apos;5&apos;,         &apos;content-type.shared&apos; =&gt; &apos;text/plain&apos;,         &apos;value.shared&apos; =&gt; &apos;19261&apos;       },       &apos;/vendor/cmu/cyrus-imapd/lastupdate&apos; =&gt; {         &apos;size.shared&apos; =&gt; &apos;26&apos;,         &apos;content-type.shared&apos; =&gt; &apos;text/plain&apos;,         &apos;value.shared&apos; =&gt; &apos;26-Mar-2004 13:31:56 -0800&apos;       },       &apos;/vendor/cmu/cyrus-imapd/partition&apos; =&gt; {         &apos;size.shared&apos; =&gt; &apos;7&apos;,         &apos;content-type.shared&apos; =&gt; &apos;text/plain&apos;,         &apos;value.shared&apos; =&gt; &apos;default&apos;       }     }   }; Perform the \s-1IMAP\s0 'getmetadata' command to get the metadata items for a mailbox.  See \s-1RFC\s0 5464 for details. If $Options is passed, it is a hashref of options to set. If foldername is the empty string, gets server annotations Examples:   my $Result = $IMAP-&gt;getmetadata(&apos;user.joe.blah&apos;, {depth =&gt; &apos;infinity&apos;}, &apos;/shared&apos;) || die "IMAP error: $@";   $Result = {     &apos;user.joe.blah&apos; =&gt; {       &apos;/shared/vendor/cmu/cyrus-imapd/size&apos; =&gt; &apos;19261&apos;,       &apos;/shared/vendor/cmu/cyrus-imapd/lastupdate&apos; =&gt; &apos;26-Mar-2004 13:31:56 -0800&apos;,       &apos;/shared/vendor/cmu/cyrus-imapd/partition&apos; =&gt; &apos;default&apos;,     }   };</p><p>  my $Result = $IMAP-&gt;getmetadata(&apos;&apos;, "/shared/comment");   $Result =&gt; {     &apos;&apos; =&gt; {       &apos;/shared/comment&apos; =&gt; "Shared comment",     }   }; Perform the \s-1IMAP\s0 'setannotation' command to get the annotation(s) for a mailbox.  See imap-annotatemore extension for details. Examples:   my $Result = $IMAP-&gt;setannotation(&apos;user.joe.blah&apos;, &apos;/comment&apos;, [ &apos;value.priv&apos; &apos;A comment&apos; ])     || die "IMAP error: $@"; Perform the \s-1IMAP\s0 'setmetadata' command.  See \s-1RFC\s0 5464 for details. Examples:   my $Result = $IMAP-&gt;setmetadata(&apos;user.joe.blah&apos;, &apos;/comment&apos;, &apos;A comment&apos;)     || die "IMAP error: $@"; Performs many \s-1IMAP\s0 'getannotation' commands on a list of folders. Sends all the commands at once and wait for responses. This speeds up latency issues. Returns a hash ref of folder name =&gt; annotation results. If an error occurs, the annotation result is a scalar ref to the completion response string (eg 'bad', 'no', etc)</p>
  </dd>
  <dt>
    <em></em><em>close()</em><em></em>
  </dt>
  <dd>
    <p>Perform the standard \s-1IMAP\s0 'close' command to expunge deleted messages from the current folder and return to the Authenticated state. Perform an \s-1IMAP\s0 idle call. Call given callback for each \s-1IDLE\s0 event received. If the callback returns 0, the idle continues. If the callback returns 1, the idle is finished and this call returns. If no timeout is passed, will continue to idle until the callback returns 1 or the server disconnects. If a timeout is passed (including a 0 timeout), the call will return if no events are received within the given time. It will return the result of the \s-1DONE\s0 command, and set $Self-&gt;get_response_code('timeout') to true. If the server closes the connection with a \*(L"bye\*(R" response, it will return undef and $@ =~ /bye/ will be true with the remainder of the bye line following.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMAP MESSAGE COMMAND METHODS</h2>
        <div class="sectioncontent">
<p>Perform the standard \s-1IMAP\s0 'fetch' command to retrieve the specified message items from the specified message IDs. The first parameter can be an optional hash reference that overrides particular parse mode parameters just for this fetch. See \*(C`parse_mode\*(C' for possible keys. $MessageIds can be one of two forms:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>A text string with a comma separated list of message \s-1ID\s0's or message ranges separated by colons. A '*' represents the highest message number. Examples:</p><ul>
<li><p>'1' - first message</p></li><li><p>'1,2,5'</p></li><li><p>'1:*' - all messages</p></li><li><p>'1,3:*' - all but message 2</p></li>
</ul><p>Note that , separated lists and : separated ranges can be mixed, but to make sure a certain hack works, if a '*' is used, it must be the last character in the string.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>An array reference with a list of message \s-1ID\s0's or ranges. The array contents are \*(C`join(&apos;,&apos;, ...)\*(C'ed together.</p>
  </dd>

</dl>
<p>Note: If the \*(C`uid()\*(C' state has been set to true, then all message \s-1ID\s0's must be message UIDs. $MessageItems can be one of, or a bracketed list of:</p><ul>
<li><p>uid</p></li><li><p>flags</p></li><li><p>internaldate</p></li><li><p>envelope</p></li><li><p>bodystructure</p></li><li><p>body</p></li><li><p>body[section]&lt;partial&gt;</p></li><li><p>body.peek[section]&lt;partial&gt;</p></li><li><p>rfc822</p></li><li><p>rfc822.header</p></li><li><p>rfc822.size</p></li><li><p>rfc822.text</p></li><li><p>fast</p></li><li><p>all</p></li><li><p>full</p></li>
</ul><p>It would be a good idea to see \s-1RFC\s0 3501 for what all these means. Examples:   my $Res = $IMAP-&gt;fetch(&apos;1:*&apos;, &apos;rfc822.size&apos;);   my $Res = $IMAP-&gt;fetch([1,2,3], &apos;(bodystructure envelope)&apos;); Return results: The results returned by the \s-1IMAP\s0 server are parsed into a Perl structure. See the section <strong>\s-1FETCH\s0 \s-1RESULTS\s0</strong> for all the interesting details. Note that message can disappear on you, so you may not get back all the entries you expect in the hash There is one piece of magic. If your request is for a single uid, (eg \*(L"123\*(R"), and no data is return, we return undef, because it's easier to handle as an error condition.</p><p>Perform standard \s-1IMAP\s0 copy command to copy a set of messages from one folder to another. Perform standard \s-1IMAP\s0 append command to append a new message into a folder. The $MessageData to append can either be a Perl scalar containing the data, or a file handle to read the data from. In each case, the data must be in proper \s-1RFC\s0 822 format with &#92;r&#92;n line terminators. Any optional fields not needed should be removed, not left blank. Examples:   # msg.txt should have &#92;r&#92;n line terminators   open(F, "msg.txt");   $IMAP-&gt;append(&apos;inbox&apos;, &#92;*F);</p><p>  my $MsgTxt =&lt;&lt;MSG;   From: blah&#92;@xyz.com   To: whoever&#92;@whereever.com   ...   MSG</p><p>  $MsgTxt =~ s/&#92;n/&#92;015&#92;012/g;   $IMAP-&gt;append(&apos;inbox&apos;, { Literal =&gt; $MsgTxt }); Perform standard \s-1IMAP\s0 search command. The result is an array reference to a list of message IDs (or UIDs if in Uid mode) of messages that are in the $MsgIdSet and also meet the search criteria. @SearchCriteria is a list of search specifications, for example to look for \s-1ASCII\s0 messages bigger than 2000 bytes you would set the list to be:   my @SearchCriteria = (&apos;CHARSET&apos;, &apos;US-ASCII&apos;, &apos;LARGER&apos;, &apos;2000&apos;); Examples:   my $Res = $IMAP-&gt;search(&apos;1:*&apos;, &apos;NOT&apos;, &apos;DELETED&apos;);   $Res = [ 1, 2, 5 ]; Perform standard \s-1IMAP\s0 store command. Changes the flags associated with a set of messages. Examples:   $IMAP-&gt;store(&apos;1:*&apos;, &apos;+flags&apos;, &apos;(&#92;&#92;deleted)&apos;);   $IMAP-&gt;store(&apos;1:*&apos;, &apos;-flags.silent&apos;, &apos;(&#92;&#92;read)&apos;);</p>
<dl class='dl-vertical'>
  <dt>
    <em></em><em>expunge()</em><em></em>
  </dt>
  <dd>
    <p>Perform standard \s-1IMAP\s0 expunge command. This actually deletes any messages marked as deleted.</p>
  </dd>
  <dt>
    <em>uidexpunge($MsgIdSet)</em>
  </dt>
  <dd>
    <p>Perform \s-1IMAP\s0 uid expunge command as per \s-1RFC\s0 2359. Perform extension \s-1IMAP\s0 sort command. The result is an array reference to a list of message IDs (or UIDs if in Uid mode) in sorted order. It would probably be a good idea to look at the sort \s-1RFC\s0 5256 details at somewhere like : http://www.ietf.org/rfc/rfc5256.txt Examples:   my $Res = $IMAP-&gt;sort(&apos;(subject)&apos;, &apos;US-ASCII&apos;, &apos;NOT&apos;, &apos;DELETED&apos;);   $Res = [ 5, 2, 3, 1, 4 ]; Perform extension \s-1IMAP\s0 thread command. The $ThreadType should be one of '\s-1REFERENCES\s0' or '\s-1ORDEREDSUBJECT\s0'. You should check the \*(C`capability()\*(C' of the server to see if it supports one or both of these. Examples   my $Res = $IMAP-&gt;thread(&apos;REFERENCES&apos;, &apos;US-ASCII&apos;, &apos;NOT&apos;, &apos;DELETED&apos;);   $Res = [ [10, 15, 20], [11], [ [ 12, 16 ], [13, 17] ];</p>
  </dd>
  <dt>
    <em>fetch_flags($MessageIds)</em>
  </dt>
  <dd>
    <p>Perform an \s-1IMAP\s0 'fetch flags' command to retrieve the specified flags for the specified messages. This is just a special fast path version of \*(C`fetch\*(C'. Perform an \s-1IMAP\s0 'fetch' command to retrieve the specified meta items. These must be simple items that return only atoms (eg no flags, bodystructure, body, envelope, etc) This is just a special fast path version of \*(C`fetch\*(C'.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMAP HELPER FUNCTIONS</h2>
        <div class="sectioncontent">
<p>This is a helper function that can be used to further parse the results of a fetched bodystructure. Given a top level body structure, and a part number, it returns the reference to the bodystructure sub part which that part number refers to. Examples:   # Fetch body structure   my $FR = $IMAP-&gt;fetch(1, &apos;bodystructure&apos;);   my $BS = $FR-&gt;{1}-&gt;{bodystructure};</p><p>  # Parse further to find particular sub part   my $P12 = $IMAP-&gt;get_body_part($BS, &apos;1.2&apos;);   $P12-&gt;{&apos;IMAP-&gt;Partnum&apos;} eq &apos;1.2&apos; || die "Unexpected IMAP part number";</p>
<dl class='dl-vertical'>
  <dt>
    <em>find_message($BodyStruct)</em>
  </dt>
  <dd>
    <p>This is a helper function that can be used to further parse the results of a fetched bodystructure. It returns a hash reference with the following items.   text =&gt; $best_text_part   html =&gt; $best_html_part (optional)   textlist =&gt; [ ... text/html (if no alt text bits)/image (if inline) parts ... ]   htmllist =&gt; [ ... text (if no alt html bits)/html/image (if inline) parts ... ]   att =&gt; [ {      bs =&gt; $part, text =&gt; 0/1, html =&gt; 0/1, msg =&gt; 1/0,    }, { ... }, ... ] For instance, consider a message with text and html pages that's then gone through a list software manager that attaches a header/footer   multipart/mixed     text/plain, cd=inline - A     multipart/mixed       multipart/alternative         multipart/mixed           text/plain, cd=inline - B           image/jpeg, cd=inline - C           text/plain, cd=inline - D         multipart/related           text/html - E           image/jpeg - F       image/jpeg, cd=attachment - G       application/x-excel - H       message/rfc822 - J     text/plain, cd=inline - K In this case, we'd have the following list items   text =&gt; B   html =&gt; E   textlist =&gt; [ A, B, C, D, K ]   htmllist =&gt; [ A, E, K ]   att =&gt; [     { bs =&gt; C, text =&gt; 1, html =&gt; 1 },     { bs =&gt; F, text =&gt; 1, html =&gt; 0 },     { bs =&gt; G, text =&gt; 1, html =&gt; 1 },     { bs =&gt; H, text =&gt; 1, html =&gt; 1 },     { bs =&gt; J, text =&gt; 0, html =&gt; 0, msg =&gt; 1 },   ] Examples:   # Fetch body structure   my $FR = $IMAP-&gt;fetch(1, &apos;bodystructure&apos;);   my $BS = $FR-&gt;{1}-&gt;{bodystructure};</p><p>  # Parse further to find message components   my $MC = $IMAP-&gt;find_message($BS);   $MC = { &apos;plain&apos; =&gt; ... text body struct ref part ...,           &apos;html&apos; =&gt; ... html body struct ref part (if present) ...           &apos;htmllist&apos; =&gt; [ ... html body struct ref parts (if present) ... ] };</p><p>  # Now get the text part of the message   my $MT = $IMAP-&gt;fetch(1, &apos;body[&apos; . $MC-&gt;{text}-&gt;{&apos;IMAP-Part&apos;} . &apos;]&apos;); This method generates a ContentID based on $Token and $PartBS. The same value should always be returned for a given $Token and $PartBS This is a helper function that can be used to further parse the results of a fetched bodystructure. It recursively parses the bodystructure and returns a hash of Content-ID to bodystruct part references. This is useful when trying to determine \s-1CID\s0 links from an \s-1HTML\s0 message. If you pass a Mail::IMAPTalk object as the second parameter, the \s-1CID\s0 map built may be even more detailed. It seems some stupid versions of exchange put details in the Content-Location header rather than the Content-Type header. If that's the case, this will try and fetch the header from the message Examples:   # Fetch body structure   my $FR = $IMAP-&gt;fetch(1, &apos;bodystructure&apos;);   my $BS = $FR-&gt;{1}-&gt;{bodystructure};</p><p>  # Parse further to get CID links   my $CL = build_cid_map($BS);   $CL = { &apos;2958293123&apos; =&gt; ... ref to body part ..., ... };</p>
  </dd>
  <dt>
    <em>obliterate($CyrusName)</em>
  </dt>
  <dd>
    <p>Given a username (optionally username&#92;@domain) immediately delete all messages belonging to this user.  Uses \s-1LOCALDELETE\s0.  Quite FastMail Patchd Cyrus specific.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMAP CALLBACKS</h2>
        <div class="sectioncontent">
<p>By default, these methods do nothing, but you can dervice from Mail::IMAPTalk and override these methods to trap any things you want to catch Called when the currently selected folder is being changed (eg 'select' called and definitely a different folder is being selected, or 'unselect' methods called)</p>
<dl class='dl-vertical'>
  <dt>
    <em>cb_folder_changed($Folder)</em>
  </dt>
  <dd>
    <p>Called when a command changes the contents of a folder (eg copy, append, etc). $Folder is the name of the folder that's changing.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FETCH RESULTS</h2>
        <div class="sectioncontent">
<p>The 'fetch' operation is probably the most common thing you'll do with an \s-1IMAP\s0 connection. This operation allows you to retrieve information about a message or set of messages, including header fields, flags or parts of the message body.</p><p>\*(C`Mail::IMAPTalk\*(C' will always parse the results of a fetch call into a Perl like structure, though 'bodystructure', 'envelope' and 'uid' responses may have additional parsing depending on the \*(C`parse_mode\*(C' state and the \*(C`uid\*(C' state (see below).</p><p>For an example case, consider the following \s-1IMAP\s0 commands and responses (C is what the client sends, S is the server response).</p><p>  C: a100 fetch 5,6 (flags rfc822.size uid)   S: * 1 fetch (UID 1952 FLAGS (&#92;recent &#92;seen) RFC822.SIZE 1150)   S: * 2 fetch (UID 1958 FLAGS (&#92;recent) RFC822.SIZE 110)   S: a100 OK Completed</p><p>The fetch command can be sent by calling:</p><p>  my $Res = $IMAP-&gt;fetch(&apos;1:*&apos;, &apos;(flags rfc822.size uid)&apos;);</p><p>The result in response will look like this:</p><p>  $Res = {     1 =&gt; {       &apos;uid&apos; =&gt; 1952,       &apos;flags&apos; =&gt; [ &apos;&#92;&#92;recent&apos;, &apos;&#92;&#92;seen&apos; ],       &apos;rfc822.size&apos; =&gt; 1150     },     2 =&gt; {       &apos;uid&apos; =&gt; 1958,       &apos;flags&apos; =&gt; [ &apos;&#92;&#92;recent&apos; ],       &apos;rfc822.size&apos; =&gt; 110     }   };</p><p>A couple of points to note:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>The message IDs have been turned into a hash from message \s-1ID\s0 to fetch response result.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>The response items (e.g. uid, flags, etc) have been turned into a hash for each message, and also changed to lower case values.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Other bracketed (...) lists have become array references.</p>
  </dd>

</dl>
<p>In general, this is how all fetch responses are parsed. There is one major difference however when the \s-1IMAP\s0 connection is in 'uid' mode. In this case, the message IDs in the main hash are changed to message UIDs, and the 'uid' entry in the inner hash is removed. So the above example would become:</p><p>  my $Res = $IMAP-&gt;fetch(&apos;1:*&apos;, &apos;(flags rfc822.size)&apos;);</p><p>  $Res = {     1952 =&gt; {       &apos;flags&apos; =&gt; [ &apos;&#92;&#92;recent&apos;, &apos;&#92;&#92;seen&apos; ],       &apos;rfc822.size&apos; =&gt; 1150     },     1958 =&gt; {       &apos;flags&apos; =&gt; [ &apos;&#92;&#92;recent&apos; ],       &apos;rfc822.size&apos; =&gt; 110     }   };</p><h3>Bodystructure</h3>
<p>When dealing with messages, we need to understand the \s-1MIME\s0 structure of the message, so we can work out what is the text body, what is attachments, etc. This is where the 'bodystructure' item from an \s-1IMAP\s0 server comes in.</p><p>  C: a101 fetch 1 (bodystructure)   S: * 1 fetch (BODYSTRUCTURE ("TEXT" "PLAIN" NIL NIL NIL "QUOTED-PRINTABLE" 255 11 NIL ("INLINE" NIL) NIL))   S: a101 OK Completed</p><p>The fetch command can be sent by calling:</p><p>  my $Res = $IMAP-&gt;fetch(1, &apos;bodystructure&apos;);</p><p>As expected, the resultant response would look like this:</p><p>  $Res = {     1 =&gt; {       &apos;bodystructure&apos; =&gt; [         &apos;TEXT&apos;, &apos;PLAIN&apos;, undef, undef, undef, &apos;QUOTED-PRINTABLE&apos;,           255, 11, UNDEF, [ &apos;INLINE&apos;, undef ], undef       ]     }   };</p><p>However, if you set the \*(C`parse_mode(BodyStructure =\*(C' 1)&gt;, then the result would be:</p><p>  $Res = {     &apos;1&apos; =&gt; {       &apos;bodystructure&apos; =&gt; {         &apos;MIME-Type&apos; =&gt; &apos;text&apos;,         &apos;MIME-Subtype&apos; =&gt; &apos;plain&apos;,         &apos;MIME-TxtType&apos; =&gt; &apos;text/plain&apos;,         &apos;Content-Type&apos; =&gt; {},         &apos;Content-ID&apos; =&gt; undef,         &apos;Content-Description&apos; =&gt; undef,         &apos;Content-Transfer-Encoding&apos; =&gt; &apos;QUOTED-PRINTABLE&apos;,         &apos;Size&apos; =&gt; &apos;3569&apos;,         &apos;Lines&apos; =&gt; &apos;94&apos;,         &apos;Content-MD5&apos; =&gt; undef,         &apos;Disposition-Type&apos; =&gt; &apos;inline&apos;,         &apos;Content-Disposition&apos; =&gt; {},         &apos;Content-Language&apos; =&gt; undef,         &apos;Remainder&apos; =&gt; [],         &apos;IMAP-Partnum&apos; =&gt; &apos;&apos;       }     }   };</p><p>A couple of points to note here:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>All the positional fields from the bodystructure list response have been turned into nicely named key/value hash items.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>The MIME-Type and MIME-Subtype fields have been made lower case.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>An IMAP-Partnum item has been added. The value in this field can be passed as the 'section' number of an \s-1IMAP\s0 body fetch call to retrieve the text of that \s-1IMAP\s0 section.</p>
  </dd>

</dl>
<p>In general, the following items are defined for all body structures:</p><ul>
<li><p>MIME-Type</p></li><li><p>MIME-Subtype</p></li><li><p>Content-Type</p></li><li><p>Disposition-Type</p></li><li><p>Content-Disposition</p></li><li><p>Content-Language</p></li>
</ul><p>For all bodystructures \s-1EXCEPT\s0 those that have a MIME-Type of 'multipart', the following are defined:</p><ul>
<li><p>Content-ID</p></li><li><p>Content-Description</p></li><li><p>Content-Transfer-Encoding</p></li><li><p>Size</p></li><li><p>Content-MD5</p></li><li><p>Remainder</p></li><li><p>IMAP-Partnum</p></li>
</ul><p>For bodystructures where MIME-Type is 'text', an extra item 'Lines' is defined.</p><p>For bodystructures where MIME-Type is 'message' and MIME-Subtype is 'rfc822', the extra items 'Message-Envelope', 'Message-Bodystructure' and 'Message-Lines' are defined. The 'Message-Bodystructure' item is itself a reference to an entire bodystructure hash with all the format information of the contained message. The 'Message-Envelope' item is a hash structure with the message header information. See the <strong>Envelope</strong> entry below.</p><p>For bodystructures where MIME-Type is 'multipart', an extra item 'MIME-Subparts' is defined. The 'MIME-Subparts' item is an array reference, with each item being a reference to an entire bodystructure hash with all the format information of each \s-1MIME\s0 sub-part.</p><p>For further processing, you can use the <strong></strong><strong>find_message()</strong><strong></strong> function. This will analyse the body structure and find which part corresponds to the main text/html message parts to display. You can also use the <strong></strong><strong>find_cid_parts()</strong><strong></strong> function to find \s-1CID\s0 links in an html message.</p>
<h3>Envelope</h3>
<p>The envelope structure contains most of the addressing header fields from an email message. The following shows an example envelope fetch (the response from the \s-1IMAP\s0 server has been neatened up here)</p><p>  C: a102 fetch 1 (envelope)   S: * 1 FETCH (ENVELOPE       ("Tue, 7 Nov 2000 08:31:21 UT"      # Date        "FW: another question"             # Subject        (("John B" NIL "jb" "abc.com"))    # From        (("John B" NIL "jb" "abc.com"))    # Sender        (("John B" NIL "jb" "abc.com"))    # Reply-To        (("Bob H" NIL "bh" "xyz.com")      # To         ("K Jones" NIL "kj" "lmn.com"))        NIL                                # Cc        NIL                                # Bcc        NIL                                # In-Reply-To        NIL)                               # Message-ID      )   S: a102 OK Completed</p><p>The fetch command can be sent by calling:</p><p>  my $Res = $IMAP-&gt;fetch(1, &apos;envelope&apos;);</p><p>And you get the idea of what the resultant response would be. Again if you change \*(C`parse_mode(Envelope =\*(C' 1)&gt;, you get a neat structure as follows:</p><p>  $Res = {     &apos;1&apos; =&gt; {       &apos;envelope&apos; =&gt; {         &apos;Date&apos; =&gt; &apos;Tue, 7 Nov 2000 08:31:21 UT&apos;,         &apos;Subject&apos; =&gt; &apos;FW: another question&apos;,         &apos;From&apos; =&gt; &apos;"John B" &lt;jb@abc.com&gt;&apos;,         &apos;Sender&apos; =&gt; &apos;"John B" &lt;jb@abc.com&gt;&apos;,         &apos;Reply-To&apos; =&gt; &apos;"John B" &lt;jb@abc.com&gt;&apos;,         &apos;To&apos; =&gt; &apos;"Bob H" &lt;bh@xyz.com&gt;, "K Jones" &lt;kj@lmn.com&gt;&apos;,         &apos;Cc&apos; =&gt; &apos;&apos;,         &apos;Bcc&apos; =&gt; &apos;&apos;,         &apos;In-Reply-To&apos; =&gt; undef,         &apos;Message-ID&apos; =&gt; undef,</p><p>        &apos;From-Raw&apos; =&gt; [ [ &apos;John B&apos;, undef, &apos;jb&apos;, &apos;abc.com&apos; ] ],         &apos;Sender-Raw&apos; =&gt; [ [ &apos;John B&apos;, undef, &apos;jb&apos;, &apos;abc.com&apos; ] ],         &apos;Reply-To-Raw&apos; =&gt; [ [ &apos;John B&apos;, undef, &apos;jb&apos;, &apos;abc.com&apos; ] ],         &apos;To-Raw&apos; =&gt; [           [ &apos;Bob H&apos;, undef, &apos;bh&apos;, &apos;xyz.com&apos; ],           [ &apos;K Jones&apos;, undef, &apos;kj&apos;, &apos;lmn.com&apos; ],         ],         &apos;Cc-Raw&apos; =&gt; [],         &apos;Bcc-Raw&apos; =&gt; [],       }     }   };</p><p>All the fields here are from straight from the email headers. See \s-1RFC\s0 822 for more details.</p>
<h3>Annotation</h3>
<p>If the server supports \s-1RFC\s0 5257 (\s-1ANNOTATE\s0 Extension), then you can fetch per-message annotations.</p><p>Annotation responses would normally be returned as a a nested set of arrays. However it's much easier to access the results as a nested set of hashes, so the results are so converted if the Annotation parse mode is enabled, which is on by default.</p><p>Part of an example from the \s-1RFC\s0</p><p>   S: * 12 FETCH (UID 1123 ANNOTATION       (/comment (value.priv "My comment"          size.priv "10")       /altsubject (value.priv "Rhinoceroses!"          size.priv "13")</p><p>So the fetch command:</p><p>  my $Res = $IMAP-&gt;fetch(1123, &apos;annotation&apos;, [ &apos;/*&apos;, [ &apos;value.priv&apos;, &apos;size.priv&apos; ] ]);</p><p>Would have the result:</p><p>  $Res = {     &apos;1123&apos; =&gt; {       &apos;annotation&apos; =&gt; {         &apos;/comment&apos; =&gt; {           &apos;value.priv&apos; =&gt; &apos;My comment&apos;,           &apos;size.priv =&gt; 10         },         &apos;/altsubject&apos; =&gt; {           &apos;value.priv&apos; =&gt; &apos;"Rhinoceroses&apos;,           &apos;size.priv =&gt; 13         }       }     }   }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNAL METHODS</h2>
        <div class="sectioncontent">
<p>Executes a standard \s-1IMAP\s0 command.</p>
<dl class='dl-vertical'>
  <dt>
    <em>Method arguments</em>
  </dt>
  <dd>
    <p>Text string of command to call \s-1IMAP\s0 server with (e.g. 'select', 'search', etc). 1 if command involved message ids and can be prefixed with \s-1UID\s0, 0 otherwise. Responses to look for from command (eg 'list', 'fetch', etc). Commands which return results usually return them untagged. The following is an example of fetching flags from a number of messages.   C123 uid fetch 1:* (flags)   * 1 FETCH (FLAGS (&#92;Seen) UID 1)   * 2 FETCH (FLAGS (&#92;Seen) UID 2)   C123 OK Completed Between the sending of the command and the '\s-1OK\s0 Completed' response, we have to pick up all the untagged '\s-1FETCH\s0' response items so we would pass 'fetch' (always use lower case) as the $RespItems to extract. This can also be a hash ref of callback functions. See _parse_response for more examples Any extra arguments to pass to command.</p><p>Helper method used by the <strong>_imap_cmd</strong> method to actually build (and quote where necessary) the command arguments and then send the actual command. Helper method used by the <strong>_send_cmd</strong> method to actually build (and quote where necessary) the command arguments and then send the actual command. Helper method called by <strong>_imap_cmd</strong> after sending the command. This methods retrieves data from the \s-1IMAP\s0 socket and parses it into Perl structures and returns the results. $RespItems is either a string, which is the untagged response(s) to find and return, or for custom processing, it can be a hash ref. If a hash ref, then each key will be an untagged response to look for, and each value a callback function to call for the corresponding untagged response. Each callback will be called with 2 or 3 arguments; the untagged response string, the remainder of the line parsed into an array ref, and for fetch type responses, the id will be passed as the third argument. One other piece of magic, if you pass a 'responseitem' key, then the value should be a string, and will be the untagged response returned from the function Helper method which checks that the server has a certain capability. If not, it sets the internal last error, $@ and returns undef. Helper method which outputs any tracing data. Return true if a folder is currently selected and that folder is $FolderName</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNAL SOCKET FUNCTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>_next_atom($Self)</em>
  </dt>
  <dd>
    <p>Returns the next atom from the current line. Uses $Self-&gt;{ReadLine} for line data, or if undef, fills it with a new line of data from the \s-1IMAP\s0 connection socket and then begins processing. If the next atom is:</p><ul>
<li><p>An unquoted string, simply returns the string.</p></li><li><p>A quoted string, unquotes the string, changes any occurances of &#92;\*(L" to \*(R" and returns the string.</p></li><li><p>A literal (e.g. {NBytes}&#92;r&#92;n), reads the number of bytes of data in the literal into a scalar or file (depending on \*(C`literal_handle_control\*(C').</p></li><li><p>A bracketed structure, reads all the sub-atoms within the structure and returns an array reference with all the sub-atoms.</p></li>
</ul><p>In each case, after parsing the atom, it removes any trailing space separator, and then returns the remainder of the line to $Self-&gt;{ReadLine} ready for the next call to \*(C`_next_atom()\*(C'.</p>
  </dd>
  <dt>
    <em>_next_simple_atom($Self)</em>
  </dt>
  <dd>
    <p>Faster version of <em>_next_atom()</em> for known simple cases</p>
  </dd>
  <dt>
    <em>_remaining_atoms($Self)</em>
  </dt>
  <dd>
    <p>Returns all the remaining atoms for the current line in the read line buffer as an array reference. Leaves $Self-&gt;{ReadLine} eq ''. See \*(C`_next_atom()\*(C'</p>
  </dd>
  <dt>
    <em>_remaining_line($Self)</em>
  </dt>
  <dd>
    <p>Returns the remaining data in the read line buffer ($Self-&gt;{ReadLine}) as a scalar string/data value.</p>
  </dd>
  <dt>
    <em>_fill_imap_read_buffer($Self)</em>
  </dt>
  <dd>
    <p>Wait until data is available on the \s-1IMAP\s0 connection socket (or a timeout occurs). Read the data into the internal buffer $Self-&gt;{ReadBuf}. You can then use \*(C`_imap_socket_read_line()\*(C', \*(C`_imap_socket_read_bytes()\*(C' or \*(C`_copy_imap_socket_to_handle()\*(C' to read data from the buffer in lines or bytes at a time.</p>
  </dd>
  <dt>
    <em>_imap_socket_read_line($Self)</em>
  </dt>
  <dd>
    <p>Read a &#92;r&#92;n terminated list from the buffered \s-1IMAP\s0 connection socket. Read a certain number of bytes from the buffered \s-1IMAP\s0 connection socket. Write the data in $Data to the \s-1IMAP\s0 connection socket. Copy a given number of bytes from one handle to another. The number of bytes specified ($NBytes) must be available on the \s-1IMAP\s0 socket, otherwise the function will 'die' with an error if it runs out of data. If $NBytes is not specified (undef), the function will attempt to seek to the end of the file to find the size of the file. Copies data from the \s-1IMAP\s0 socket to a file handle. This is different to <em>_copy_handle_to_handle()</em> because we internally buffer the \s-1IMAP\s0 socket so we can't just use it to copy from the socket handle, we have to copy the contents of our buffer first. The number of bytes specified must be available on the \s-1IMAP\s0 socket, if the function runs out of data it will 'die' with an error.</p>
  </dd>
  <dt>
    <em>_quote($String)</em>
  </dt>
  <dd>
    <p>Returns an \s-1IMAP\s0 quoted version of a string. This place \*(L"...\*(R" around the string, and replaces any internal \*(L" with &#92;\*(R".</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNAL PARSING FUNCTIONS</h2>
        <div class="sectioncontent">
<p>Parses an array reference list of ($Key, $Value) pairs into a hash. Makes sure that all the keys are lower cased (lc) first. Changes a folder name based on the current root folder prefix as set with the \*(C`set_root_prefix()\*(C' call. If $WildCard is true, then a folder name with % or * is left alone.</p>
<dl class='dl-vertical'>
  <dt>
    <em>_unfix_folder_name($FolderName)</em>
  </dt>
  <dd>
    <p>Unchanges a folder name based on the current root folder prefix as set with the \*(C`set_root_prefix()\*(C' call.</p>
  </dd>
  <dt>
    <em>_fix_message_ids($MessageIds)</em>
  </dt>
  <dd>
    <p>Used by \s-1IMAP\s0 commands to handle a number of different ways that message IDs can be specified.</p>
  </dd>
  <dt>
    <em>Method arguments</em>
  </dt>
  <dd>
    <p>String or array ref which specified the message IDs or UIDs.</p><p>The $MessageIds parameter may take the following forms:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>array ref</strong>
  </dt>
  <dd>
    <p>Array is turned into a string of comma separated \s-1ID\s0 numbers.</p>
  </dd>
  <dt>
    <strong>1:*</strong>
  </dt>
  <dd>
    <p>Normally a * would result in the message \s-1ID\s0 string being quoted. This ensure that such a range string is not quoted because some servers (e.g. cyrus) don't like.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <em>_parse_email_address($EmailAddressList)</em>
  </dt>
  <dd>
    <p>Converts a list of \s-1IMAP\s0 email address structures as parsed and returned from an \s-1IMAP\s0 fetch (envelope) call into a single \s-1RFC\s0 822 email string (e.g. \*(L"Person 1 Name\*(R" &lt;ename@ecorp.com&gt;, \*(L"Person 2 Name\*(R" &lt;...&gt;, etc) to finally return to the user. This is used to parse an envelope structure returned from a fetch call. See the documentation section '\s-1FETCH\s0 \s-1RESULTS\s0' for more information. Converts an \s-1IMAP\s0 envelope structure as parsed and returned from an \s-1IMAP\s0 fetch (envelope) call into a convenient hash structure. If $IncludeRaw is true, includes the XXX-Raw fields, otherwise these are left out. If $DecodeUTF8 is true, then checks if the fields contain any quoted-printable chars, and decodes them to a Perl \s-1UTF8\s0 string if they do. See the documentation section '\s-1FETCH\s0 \s-1RESULTS\s0' from more information. Parses a standard \s-1IMAP\s0 body structure and turns it into a Perl friendly nested hash structure. This routine is recursive and you should not pass a value for $PartNum when called for the top level bodystructure item.  Note that this routine destroys the array reference structure passed in as $BodyStructure. See the documentation section '\s-1FETCH\s0 \s-1RESULTS\s0' from more information</p>
  </dd>
  <dt>
    <em>_parse_fetch_annotation($AnnotateItem)</em>
  </dt>
  <dd>
    <p>Takes the result from a single \s-1IMAP\s0 annotation item into a Perl friendly structure. See the documentation section '\s-1FETCH\s0 \s-1RESULTS\s0' from more information.</p>
  </dd>
  <dt>
    <em>_parse_fetch_result($FetchResult)</em>
  </dt>
  <dd>
    <p>Takes the result from a single \s-1IMAP\s0 fetch response line and parses it into a Perl friendly structure. See the documentation section '\s-1FETCH\s0 \s-1RESULTS\s0' from more information. Take a body[header.fields (xyz)] fetch response and parse out the header fields and values</p>
  </dd>
  <dt>
    <em>_decode_utf8($Value)</em>
  </dt>
  <dd>
    <p>Decodes the passed quoted printable value to a Perl \s-1UTF8\s0 string.</p>
  </dd>
  <dt>
    <em>_expand_sequence(@Sequences)</em>
  </dt>
  <dd>
    <p>Expand a list of \s-1IMAP\s0 id sequences into a full list of ids</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERL METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>\s-1</em><em>DESTROY\s0()</em><em></em>
  </dt>
  <dd>
    <p>Called by Perl when this object is destroyed. Logs out of the \s-1IMAP\s0 server if still connected.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Mail::IMAPTalk&hellip;</h2>
        <div class="sectioncontent">
<p><em>Net::IMAP</em>, <em>Mail::IMAPClient</em>, <em>IMAP::Admin</em>, \s-1RFC\s0 3501</p><p>Latest news/details can also be found at:</p><p>http://cpan.robm.fastmail.fm/mailimaptalk/</p><p>Available on github at:</p><p>https://github.com/robmueller/mail-imaptalk/ &lt;https://github.com/robmueller/mail-imaptalk/&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Rob Mueller &lt;cpan@robm.fastmail.fm&gt;. Thanks to Jeremy Howard &lt;j+daemonize@howard.fm&gt; for socket code, support and documentation setup.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2003-2011 by Opera Software Australia Pty Ltd</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Mail::Field::Received.3pm.html"><span aria-hidden="true">&larr;</span> Mail::Field::Received.3pm: Mostly rfc822-compliant parser of received headers</a></li>
   <li class="next"><a href="Mail::ListDetector.3pm.html">Mail::ListDetector.3pm: Perl extension for detecting mailing list messages <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

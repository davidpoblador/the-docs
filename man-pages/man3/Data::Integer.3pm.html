<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Data::Integer: Details of the native integer data type</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Details of the native integer data type">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Data::Integer (3pm) manual">
  <meta name="twitter:description" content="Details of the native integer data type">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdata-integer-perl-Data::Integer-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Data::Integer.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Data::Integer (3pm) manual" />
  <meta property="og:description" content="Details of the native integer data type" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdata-integer-perl-Data::Integer-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Data::Integer<small> (3pm)</small></h1>
        <p class="lead">Details of the native integer data type</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::Integer.3pm.html">
      <span itemprop="name">Data::Integer: Details of the native integer data type</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdata-integer-perl/">
      <span itemprop="name">libdata-integer-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::Integer.3pm.html">
      <span itemprop="name">Data::Integer: Details of the native integer data type</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        use Data::Integer qw(natint_bits);

        $n = natint_bits;

        # and other constants; see text

        use Data::Integer qw(nint sint uint nint_is_sint nint_is_uint);

        $ni = nint($ni);
        $si = sint($si);
        $ui = uint($ui);
        if(nint_is_sint($ni)) { ...
        if(nint_is_uint($ni)) { ...

        use Data::Integer qw(
                nint_sgn sint_sgn uint_sgn
                nint_abs sint_abs uint_abs
                nint_cmp sint_cmp uint_cmp
                nint_min sint_min uint_min
                nint_max sint_max uint_max
                nint_neg sint_neg uint_neg
                nint_add sint_add uint_add
                nint_sub sint_sub uint_sub
        );

        $sn = nint_sgn($ni);
        $sn = sint_sgn($si);
        $sn = uint_sgn($ui);
        $ni = nint_abs($ni);
        $si = sint_abs($si);
        $ui = uint_abs($ui);
        @sorted_nints = sort { nint_cmp($a, $b) } @nints;
        @sorted_sints = sort { sint_cmp($a, $b) } @sints;
        @sorted_uints = sort { uint_cmp($a, $b) } @uints;
        $ni = nint_min($na, $nb);
        $si = sint_min($sa, $sb);
        $ui = uint_min($ua, $ub);
        $ni = nint_max($na, $nb);
        $si = sint_max($sa, $sb);
        $ui = uint_max($ua, $ub);
        $ni = nint_neg($ni);
        $si = sint_neg($si);
        $ui = uint_neg($ui);
        $ni = nint_add($na, $nb);
        $si = sint_add($sa, $sb);
        $ui = uint_add($ua, $ub);
        $ni = nint_sub($na, $nb);
        $si = sint_sub($sa, $sb);
        $ui = uint_sub($ua, $ub);

        use Data::Integer qw(
                sint_shl uint_shl
                sint_shr uint_shr
                sint_rol uint_rol
                sint_ror uint_ror
        );

        $si = sint_shl($si, $dist);
        $ui = uint_shl($ui, $dist);
        $si = sint_shr($si, $dist);
        $ui = uint_shr($ui, $dist);
        $si = sint_rol($si, $dist);
        $ui = uint_rol($ui, $dist);
        $si = sint_ror($si, $dist);
        $ui = uint_ror($ui, $dist);

        use Data::Integer qw(
                nint_bits_as_sint nint_bits_as_uint
                sint_bits_as_uint uint_bits_as_sint
        );

        $si = nint_bits_as_sint($ni);
        $ui = nint_bits_as_uint($ni);
        $ui = sint_bits_as_uint($si);
        $si = uint_bits_as_sint($ui);

        use Data::Integer qw(
                sint_not uint_not
                sint_and uint_and
                sint_nand uint_nand
                sint_andn uint_andn
                sint_or uint_or
                sint_nor uint_nor
                sint_orn uint_orn
                sint_xor uint_xor
                sint_nxor uint_nxor
                sint_mux uint_mux
        );

        $si = sint_not($si);
        $ui = uint_not($ui);
        $si = sint_and($sa, $sb);
        $ui = uint_and($ua, $ub);
        $si = sint_nand($sa, $sb);
        $ui = uint_nand($ua, $ub);
        $si = sint_andn($sa, $sb);
        $ui = uint_andn($ua, $ub);
        $si = sint_or($sa, $sb);
        $ui = uint_or($ua, $ub);
        $si = sint_nor($sa, $sb);
        $ui = uint_nor($ua, $ub);
        $si = sint_orn($sa, $sb);
        $ui = uint_orn($ua, $ub);
        $si = sint_xor($sa, $sb);
        $ui = uint_xor($ua, $ub);
        $si = sint_nxor($sa, $sb);
        $ui = uint_nxor($ua, $ub);
        $si = sint_mux($sa, $sb, $sc);
        $ui = uint_mux($ua, $ub, $uc);

        use Data::Integer qw(
                sint_madd uint_madd
                sint_msub uint_msub
                sint_cadd uint_cadd
                sint_csub uint_csub
                sint_sadd uint_sadd
                sint_ssub uint_ssub
        );

        $si = sint_madd($sa, $sb);
        $ui = uint_madd($ua, $ub);
        $si = sint_msub($sa, $sb);
        $ui = uint_msub($ua, $ub);
        ($carry, $si) = sint_cadd($sa, $sb, $carry);
        ($carry, $ui) = uint_cadd($ua, $ub, $carry);
        ($carry, $si) = sint_csub($sa, $sb, $carry);
        ($carry, $ui) = uint_csub($ua, $ub, $carry);
        $si = sint_sadd($sa, $sb);
        $ui = uint_sadd($ua, $ub);
        $si = sint_ssub($sa, $sb);
        $ui = uint_ssub($ua, $ub);

        use Data::Integer qw(natint_hex hex_natint);

        print natint_hex($value);
        $value = hex_natint($string);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is about the native integer numerical data type.  A native integer is one of the types of datum that can appear in the numeric part of a Perl scalar.  This module supplies constants describing the native integer type.</p><p>There are actually two native integer representations: signed and unsigned.  Both are handled by this module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NATIVE INTEGERS</h2>
        <div class="sectioncontent">
<p>Each native integer format represents a value using binary place value, with some fixed number of bits.  The number of bits is the same for both signed and unsigned representations.  In each case the least-significant bit has the value 1, the next 2, the next 4, and so on.  In the unsigned representation, this pattern continues up to and including the most-significant bit, which for a 32-bit machine therefore has the value 2^31 (2147483648).  The unsigned format cannot represent any negative numbers.</p><p>In the signed format, the most-significant bit is exceptional, having the negation of the value that it does in the unsigned format.  Thus on a 32-bit machine this has the value -2^31 (-2147483648).  Values with this bit set are negative, and those with it clear are non-negative; this bit is also known as the \*(L"sign bit\*(R".</p><p>It is usual in machine arithmetic to use one of these formats at a time, for example to add two signed numbers yielding a signed result. However, Perl has a trick: a scalar with a native integer value contains an additional flag bit which indicates whether the signed or unsigned format is being used.  It is therefore possible to mix signed and unsigned numbers in arithmetic, at some extra expense.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTANTS</h2>
        <div class="sectioncontent">
<p>Each of the extreme-value constants has two names, a short one and a long one.  The short names are more convenient to use, but the long names are clearer in a context where other similar constants exist.</p><p>Due to the risks of Perl changing the behaviour of a native integer value that has been involved in floating point arithmetic (see \*(L"\s-1BUGS\s0\*(R"), the extreme-value constants are actually non-constant functions that always return a fresh copy of the appropriate value.  The returned value is always a pure native integer value, unsullied by floating point or string operations.</p>
<dl class='dl-vertical'>
  <dt>
    natint_bits
  </dt>
  <dd>
    <p>The width, in bits, of the native integer data types.</p>
  </dd>
  <dt>
    min_nint
  </dt>
  <dd>
    
  </dd>
  <dt>
    min_natint
  </dt>
  <dd>
    <p>The minimum representable value in either representation.  This is -2^(natint_bits - 1).</p>
  </dd>
  <dt>
    max_nint
  </dt>
  <dd>
    
  </dd>
  <dt>
    max_natint
  </dt>
  <dd>
    <p>The maximum representable value in either representation.  This is 2^natint_bits - 1.</p>
  </dd>
  <dt>
    min_sint
  </dt>
  <dd>
    
  </dd>
  <dt>
    min_signed_natint
  </dt>
  <dd>
    <p>The minimum representable value in the signed representation.  This is -2^(natint_bits - 1).</p>
  </dd>
  <dt>
    max_sint
  </dt>
  <dd>
    
  </dd>
  <dt>
    max_signed_natint
  </dt>
  <dd>
    <p>The maximum representable value in the signed representation.  This is 2^(natint_bits - 1) - 1.</p>
  </dd>
  <dt>
    min_uint
  </dt>
  <dd>
    
  </dd>
  <dt>
    min_unsigned_natint
  </dt>
  <dd>
    <p>The minimum representable value in the unsigned representation. This is zero.</p>
  </dd>
  <dt>
    max_uint
  </dt>
  <dd>
    
  </dd>
  <dt>
    max_unsigned_natint
  </dt>
  <dd>
    <p>The maximum representable value in the unsigned representation.  This is 2^natint_bits - 1.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>Each \*(L"nint_\*(R", \*(L"sint_\*(R", or \*(L"uint_\*(R" function operates on one of the three integer formats.  \*(L"nint_\*(R" functions operate on Perl's union of signed and unsigned; \*(L"sint_\*(R" functions operate on signed integers; and \*(L"uint_\*(R" functions operate on unsigned integers.  Except where indicated otherwise, the function returns a value of its primary type.</p><p>Parameters <em>A</em>, <em>B</em>, and <em>C</em>, where present, must be numbers of the appropriate type: specifically, with a numerical value that can be represented in that type.  If there are multiple flavours of zero, due to floating point funkiness, all zeroes are treated the same.  Parameters with other names have other requirements, explained with each function.</p><p>The functions attempt to detect unsuitable arguments, and \*(C`die\*(C' if an invalid argument is detected, but they can't notice some kinds of incorrect argument.  Generally, it is the caller's responsibility to provide a sane numerical argument, and supplying an invalid argument will cause mayhem.  Only the numeric value of plain scalar arguments is used; the string value is completely ignored, so dualvars are not a problem.</p><h3>Canonicalisation and classification</h3>
<p>These are basic glue functions.</p>
<dl class='dl-vertical'>
  <dt>
    nint(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint(A)
  </dt>
  <dd>
    <p>These functions each take an argument in a specific integer format and return its numerical value.  This is the argument canonicalisation that is performed by all of the functions in this module, presented in isolation.</p>
  </dd>
  <dt>
    nint_is_sint(A)
  </dt>
  <dd>
    <p>Takes a native integer of either type.  Returns a truth value indicating whether this value can be exactly represented as a signed native integer.</p>
  </dd>
  <dt>
    nint_is_uint(A)
  </dt>
  <dd>
    <p>Takes a native integer of either type.  Returns a truth value indicating whether this value can be exactly represented as an unsigned native integer.</p>
  </dd>

</dl>

<h3>Arithmetic</h3>
<p>These functions operate on numerical values rather than just bit patterns. They will all \*(C`die\*(C' if the true numerical result doesn't fit into the result format, rather than give a wrong answer.</p>
<dl class='dl-vertical'>
  <dt>
    nint_sgn(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint_sgn(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_sgn(A)
  </dt>
  <dd>
    <p>Returns +1 if the argument is positive, 0 if the argument is zero, or -1 if the argument is negative.</p>
  </dd>
  <dt>
    nint_abs(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint_abs(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_abs(A)
  </dt>
  <dd>
    <p>Absolute value (magnitude, discarding sign).</p>
  </dd>
  <dt>
    nint_cmp(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint_cmp(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_cmp(A, B)
  </dt>
  <dd>
    <p>Arithmetic comparison.  Returns -1, 0, or +1, indicating whether A is less than, equal to, or greater than B.</p>
  </dd>
  <dt>
    nint_min(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint_min(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_min(A, B)
  </dt>
  <dd>
    <p>Arithmetic minimum.  Returns the arithmetically lesser of the two arguments.</p>
  </dd>
  <dt>
    nint_max(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint_max(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_max(A, B)
  </dt>
  <dd>
    <p>Arithmetic maximum.  Returns the arithmetically greater of the two arguments.</p>
  </dd>
  <dt>
    nint_neg(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint_neg(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_neg(A)
  </dt>
  <dd>
    <p>Negation: returns -A.</p>
  </dd>
  <dt>
    nint_add(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint_add(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_add(A, B)
  </dt>
  <dd>
    <p>Addition: returns A + B.</p>
  </dd>
  <dt>
    nint_sub(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    sint_sub(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_sub(A, B)
  </dt>
  <dd>
    <p>Subtraction: returns A - B.</p>
  </dd>

</dl>

<h3>Bit shifting</h3>
<p>These functions all operate on the bit patterns representing integers, mostly ignoring the numerical values represented.  In most cases the results for particular numerical arguments are influenced by the word size, because that determines where a bit being left-shifted will drop off the end of the word and where a bit will be shifted in during a rightward shift.</p><p>With the exception of rightward shifts (see below), each pair of functions performs exactly the same operations on the bit sequences. There inevitably can't be any functions here that operate on Perl's union of signed and unsigned; you must choose, by which function you call, which type the result is to be tagged as.</p>
<dl class='dl-vertical'>
  <dt>
    sint_shl(A, \s-1DIST\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_shl(A, \s-1DIST\s0)
  </dt>
  <dd>
    <p>Bitwise left shift (towards more-significant bits).  <em>\s-1DIST\s0</em> is the distance to shift, in bits, and must be an integer in the range [0, natint_bits).  Zeroes are shifted in from the right.</p>
  </dd>
  <dt>
    sint_shr(A, \s-1DIST\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_shr(A, \s-1DIST\s0)
  </dt>
  <dd>
    <p>Bitwise right shift (towards less-significant bits).  <em>\s-1DIST\s0</em> is the distance to shift, in bits, and must be an integer in the range [0, natint_bits). When performing an unsigned right shift, zeroes are shifted in from the left.  A signed right shift is different: the sign bit gets duplicated, so right-shifting a negative number always gives a negative result.</p>
  </dd>
  <dt>
    sint_rol(A, \s-1DIST\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_rol(A, \s-1DIST\s0)
  </dt>
  <dd>
    <p>Bitwise left rotation (towards more-significant bits, with the most-significant bit wrapping round to the least-significant bit). <em>\s-1DIST\s0</em> is the distance to rotate, in bits, and must be an integer in the range [0, natint_bits).</p>
  </dd>
  <dt>
    sint_ror(A, \s-1DIST\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_ror(A, \s-1DIST\s0)
  </dt>
  <dd>
    <p>Bitwise right rotation (towards less-significant bits, with the least-significant bit wrapping round to the most-significant bit). <em>\s-1DIST\s0</em> is the distance to rotate, in bits, and must be an integer in the range [0, natint_bits).</p>
  </dd>

</dl>

<h3>Format conversion</h3>
<p>These functions convert between the various native integer formats by reinterpreting the bit patterns used to represent the integers. The bit pattern remains unchanged; its meaning changes, and so the numerical value changes.  Perl scalars preserve the numerical value, rather than just the bit pattern, so from the Perl point of view these are functions that change numbers into other numbers.</p>
<dl class='dl-vertical'>
  <dt>
    nint_bits_as_sint(A)
  </dt>
  <dd>
    <p>Converts a native integer of either type to a signed integer, by reinterpreting the bits.  The most-significant bit (whether a sign bit or not) becomes a sign bit.</p>
  </dd>
  <dt>
    nint_bits_as_uint(A)
  </dt>
  <dd>
    <p>Converts a native integer of either type to an unsigned integer, by reinterpreting the bits.  The most-significant bit (whether a sign bit or not) becomes an ordinary most-significant bit.</p>
  </dd>
  <dt>
    sint_bits_as_uint(A)
  </dt>
  <dd>
    <p>Converts a signed integer to an unsigned integer, by reinterpreting the bits.  The sign bit becomes an ordinary most-significant bit.</p>
  </dd>
  <dt>
    uint_bits_as_sint(A)
  </dt>
  <dd>
    <p>Converts an unsigned integer to a signed integer, by reinterpreting the bits.  The most-significant bit becomes a sign bit.</p>
  </dd>

</dl>

<h3>Bitwise operations</h3>
<p>These functions all operate on the bit patterns representing integers, completely ignoring the numerical values represented.  They are mostly not influenced by the word size, in the sense that they will produce the same numerical result for the same numerical arguments regardless of word size.  However, a few are affected by the word size: those on unsigned operands that return a non-zero result if given zero arguments.</p><p>Each pair of functions performs exactly the same operations on the bit sequences.  There inevitably can't be any functions here that operate on Perl's union of signed and unsigned; you must choose, by which function you call, which type the result is to be tagged as.</p>
<dl class='dl-vertical'>
  <dt>
    sint_not(A)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_not(A)
  </dt>
  <dd>
    <p>Bitwise complement (\s-1NOT\s0).</p>
  </dd>
  <dt>
    sint_and(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_and(A, B)
  </dt>
  <dd>
    <p>Bitwise conjunction (\s-1AND\s0).</p>
  </dd>
  <dt>
    sint_nand(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_nand(A, B)
  </dt>
  <dd>
    <p>Bitwise inverted conjunction (\s-1NAND\s0).</p>
  </dd>
  <dt>
    sint_andn(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_andn(A, B)
  </dt>
  <dd>
    <p>Bitwise conjunction with inverted argument (A \s-1AND\s0 (\s-1NOT\s0 B)).</p>
  </dd>
  <dt>
    sint_or(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_or(A, B)
  </dt>
  <dd>
    <p>Bitwise disjunction (\s-1OR\s0).</p>
  </dd>
  <dt>
    sint_nor(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_nor(A, B)
  </dt>
  <dd>
    <p>Bitwise inverted disjunction (\s-1NOR\s0).</p>
  </dd>
  <dt>
    sint_orn(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_orn(A, B)
  </dt>
  <dd>
    <p>Bitwise disjunction with inverted argument (A \s-1OR\s0 (\s-1NOT\s0 B)).</p>
  </dd>
  <dt>
    sint_xor(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_xor(A, B)
  </dt>
  <dd>
    <p>Bitwise symmetric difference (\s-1XOR\s0).</p>
  </dd>
  <dt>
    sint_nxor(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_nxor(A, B)
  </dt>
  <dd>
    <p>Bitwise symmetric similarity (\s-1NXOR\s0).</p>
  </dd>
  <dt>
    sint_mux(A, B, C)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_mux(A, B, C)
  </dt>
  <dd>
    <p>Bitwise multiplex.  The output has a bit from B wherever A has a 1 bit, and a bit from C wherever A has a 0 bit.  That is, the result is (A \s-1AND\s0 B) \s-1OR\s0 ((\s-1NOT\s0 A) \s-1AND\s0 C).</p>
  </dd>

</dl>

<h3>Machine arithmetic</h3>
<p>These functions perform arithmetic operations that are inherently influenced by the word size.  They always produce a well-defined output if given valid inputs.  There inevitably can't be any functions here that operate on Perl's union of signed and unsigned; you must choose, by which function you call, which type the result is to be tagged as.</p>
<dl class='dl-vertical'>
  <dt>
    sint_madd(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_madd(A, B)
  </dt>
  <dd>
    <p>Modular addition.  The result for unsigned addition is (A + B) mod 2^natint_bits.  The signed version behaves similarly, but with a different result range.</p>
  </dd>
  <dt>
    sint_msub(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_msub(A, B)
  </dt>
  <dd>
    <p>Modular subtraction.  The result for unsigned subtraction is (A - B) mod 2^natint_bits.  The signed version behaves similarly, but with a different result range.</p>
  </dd>
  <dt>
    sint_cadd(A, B, \s-1CARRY_IN\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_cadd(A, B, \s-1CARRY_IN\s0)
  </dt>
  <dd>
    <p>Addition with carry.  Two word arguments (A and B) and an input carry bit (\s-1CARRY_IN\s0, which must have the value 0 or 1) are all added together. Returns a list of two items: an output carry and an output word (of the same signedness as the inputs).  Precisely, the output list (\s-1CARRY_OUT\s0, R) is such that CARRY_OUT*2^natint_bits + R = A + B + \s-1CARRY_IN\s0.</p>
  </dd>
  <dt>
    sint_csub(A, B, \s-1CARRY_IN\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_csub(A, B, \s-1CARRY_IN\s0)
  </dt>
  <dd>
    <p>Subtraction with carry (borrow).  The second word argument (B) and an input carry bit (\s-1CARRY_IN\s0, which must have the value 0 or 1) are subtracted from the first word argument (A).  Returns a list of two items: an output carry and an output word (of the same signedness as the inputs).  Precisely, the output list (\s-1CARRY_OUT\s0, R) is such that R - CARRY_OUT*2^natint_bits = A - B - \s-1CARRY_IN\s0.</p>
  </dd>
  <dt>
    sint_sadd(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_sadd(A, B)
  </dt>
  <dd>
    <p>Saturating addition.  The result is A + B if that will fit into the result format, otherwise the minimum or maximum value of the result format is returned depending on the direction in which the addition overflowed.</p>
  </dd>
  <dt>
    sint_ssub(A, B)
  </dt>
  <dd>
    
  </dd>
  <dt>
    uint_ssub(A, B)
  </dt>
  <dd>
    <p>Saturating subtraction.  The result is A - B if that will fit into the result format, otherwise the minimum or maximum value of the result format is returned depending on the direction in which the subtraction overflowed.</p>
  </dd>

</dl>

<h3>String conversion</h3>

<dl class='dl-vertical'>
  <dt>
    natint_hex(\s-1VALUE\s0)
  </dt>
  <dd>
    <p>\s-1VALUE\s0 must be a native integer value.  The function encodes \s-1VALUE\s0 in hexadecimal, returning that representation as a string.  Specifically, the output is of the form "<em>s</em><strong>0x</strong><em>dddd</em>\*(L", where \*(R"<em>s</em>\*(L" is the sign and \*(R"<em>dddd</em>" is a sequence of hexadecimal digits.</p>
  </dd>
  <dt>
    hex_natint(\s-1STRING\s0)
  </dt>
  <dd>
    <p>Generates and returns a native integer value from a string encoding it in hexadecimal.  Specifically, the input format is "[<em>s</em>][<strong>0x</strong>]<em>dddd</em>\*(L", where \*(R"<em>s</em>\*(L" is the sign and \*(R"<em>dddd</em>" is a sequence of one or more hexadecimal digits.  The input is interpreted case insensitively. If the value given in the string cannot be exactly represented in the native integer type, the function \*(C`die\*(C's. The core Perl function \*(C`hex\*(C' (see \*(L"hex\*(R" in perlfunc) does a similar job to this function, but differs in several ways.  Principally, \*(C`hex\*(C' doesn't handle negative values, and it gives the wrong answer for values that don't fit into the native integer type.  In Perl 5.6 it also gives the wrong answer for values that don't fit into the native floating point type.  It also doesn't enforce strict syntax on the input string.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>In Perl 5.6, when a native integer scalar is used in any arithmetic other than specifically integer arithmetic, it gets partially transformed into a floating point scalar.  Even if its numerical value can be represented exactly in floating point, so that floating point arithmetic uses the correct numerical value, some operations are affected by the floatness. In particular, the stringification of the scalar doesn't necessarily represent its exact value if it is tagged as floating point.</p><p>Because of this transforming behaviour, if you need to stringify a native integer it is best to ensure that it doesn't get used in any non-integer arithmetic first.  If an integer scalar must be used in standard Perl arithmetic, it may be copied first and the copy operated upon to avoid causing side effects on the original.  If an integer scalar might have already been transformed, it can be cleaned by passing it through the canonicalisation function \*(C`nint\*(C'.  The functions in this module all avoid modifying their arguments, and always return pristine integers.</p><p>Perl 5.8+ still internally modifies integer scalars in the same circumstances, but seems to have corrected all the misbehaviour that resulted from it.</p><p>Also in Perl 5.6, default Perl arithmetic doesn't necessarily work correctly on native integers.  (This is part of the motivation for the myriad arithmetic functions in this module.)  Default arithmetic here is strictly floating point, so if there are native integers that cannot be exactly represented in floating point then the arithmetic will approximate the values before operating on them.  Perl 5.8+ attempts to use native integer operations where possible in its default arithmetic, but as of Perl 5.8.8 it doesn't always succeed.  For reliable integer arithmetic, integer operations must still be requested explicitly.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Data::Integer&hellip;</h2>
        <div class="sectioncontent">
<p>Data::Float, Scalar::Number, <em>perlnumber</em>\|(1)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2007, 2010 Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Data::Hexdumper.3pm.html"><span aria-hidden="true">&larr;</span> Data::Hexdumper.3pm: Make binary data human-readable</a></li>
   <li class="next"><a href="Data::JavaScript.3pm.html">Data::JavaScript.3pm: Dump perl data structures into javascript code <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mm: Shared memory allocation</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Shared memory allocation">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mm (3) manual">
  <meta name="twitter:description" content="Shared memory allocation">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmm-dev-mm-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/mm.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mm (3) manual" />
  <meta property="og:description" content="Shared memory allocation" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmm-dev-mm-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mm<small> (3)</small></h1>
        <p class="lead">Shared memory allocation</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mm.3.html">
      <span itemprop="name">mm: Shared memory allocation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmm-dev/">
      <span itemprop="name">libmm-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mm.3.html">
      <span itemprop="name">mm: Shared memory allocation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>\s-1OSSP\s0 mm \s-11.4.2 (15-Aug-2006)\s0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 #include "mm.h"
</pre>
<p><strong> Global Malloc-Replacement \s-1API\s0</strong></p><p> int     <strong>MM_create</strong>(size_t size, const char *file);  int     <strong>MM_permission</strong>(mode_t mode, uid_t owner, gid_t group);  void    <strong>MM_reset</strong>(void);  void    <strong>MM_destroy</strong>(void);  int     <strong>MM_lock</strong>(mm_lock_mode mode);  int     <strong>MM_unlock</strong>(void);  void   *<strong>MM_malloc</strong>(size_t size);  void   *<strong>MM_realloc</strong>(void *ptr, size_t size);  void    <strong>MM_free</strong>(void *ptr);  void   *<strong>MM_calloc</strong>(size_t number, size_t size);  char   *<strong>MM_strdup</strong>(const char *str);  size_t  <strong>MM_sizeof</strong>(void *ptr);  size_t  <strong>MM_maxsize</strong>(void);  size_t  <strong>MM_available</strong>(void);  char   *<strong>MM_error</strong>(void);</p><p><strong> Standard Malloc-Style \s-1API\s0</strong></p><p> MM     *<strong>mm_create</strong>(size_t size, char *file);  int     <strong>mm_permission</strong>(MM *mm, mode_t mode, uid_t owner, gid_t group);  void    <strong>mm_reset</strong>(MM *mm);  void    <strong>mm_destroy</strong>(MM *mm);  int     <strong>mm_lock</strong>(MM *mm, mm_lock_mode mode);  int     <strong>mm_unlock</strong>(MM *mm);  void   *<strong>mm_malloc</strong>(MM *mm, size_t size);  void   *<strong>mm_realloc</strong>(MM *mm, void *ptr, size_t size);  void    <strong>mm_free</strong>(MM *mm, void *ptr);  void   *<strong>mm_calloc</strong>(MM *mm, size_t number, size_t size);  char   *<strong>mm_strdup</strong>(MM *mm, const char *str);  size_t  <strong>mm_sizeof</strong>(MM *mm, void *ptr);  size_t  <strong>mm_maxsize</strong>(void);  size_t  <strong>mm_available</strong>(MM *mm);  char   *<strong>mm_error</strong>(void);  void    <strong>mm_display_info</strong>(MM *mm);</p><p><strong> Low-level Shared Memory \s-1API\s0</strong></p><p> void   *<strong>mm_core_create</strong>(size_t size, char *file);  int     <strong>mm_core_permission</strong>(void *core, mode_t mode, uid_t owner, gid_t group);  void    <strong>mm_core_delete</strong>(void *core);  int     <strong>mm_core_lock</strong>(void *core, mm_lock_mode mode);  int     <strong>mm_core_unlock</strong>(void *core);  size_t  <strong>mm_core_size</strong>(void *core);  size_t  <strong>mm_core_maxsegsize</strong>(void);  size_t  <strong>mm_core_align2page</strong>(size_t size);  size_t  <strong>mm_core_align2click</strong>(size_t size);</p><p><strong> Internal Library \s-1API\s0</strong></p><p> void    <strong>mm_lib_error_set</strong>(unsigned int, const char *str);  char   *<strong>mm_lib_error_get</strong>(void);  int     <strong>mm_lib_version</strong>(void);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>\s-1OSSP\s0 mm</strong> library is a 2-layer abstraction library which simplifies the usage of shared memory between forked (and this way strongly related) processes under Unix platforms. On the first (lower) layer it hides all platform dependent implementation details (allocation and locking) when dealing with shared memory segments and on the second (higher) layer it provides a high-level <em>malloc</em>\|(3)-style \s-1API\s0 for a convenient and well known way to work with data-structures inside those shared memory segments.</p><p>The abbreviation <strong>\s-1OSSP\s0 mm</strong> is historically and originally comes from the phrase ``<em>memory mapped</em>'' as used by the \s-1POSIX\s0.1 <em>mmap</em>\|(2) function. Because this facility is internally used by this library on most platforms to establish the shared memory segments.</p><p><strong>&#92;$1</strong></p><p>This library is structured into three main APIs which are internally based on each other:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>Global Malloc-Replacement \s-1API\s0</strong>
  </dt>
  <dd>
    <p>This is the most high-level \s-1API\s0 which directly can be used as replacement \s-1API\s0 for the \s-1POSIX\s0.1 memory allocation \s-1API\s0 (<em>malloc</em>\|(2) and friends). This is useful when converting <em>heap</em> based data structures to <em>shared memory</em> based data structures without the need to change the code dramatically.  All which is needed is to prefix the \s-1POSIX\s0.1 memory allocation functions with `\*(C`MM_\*(C'', i.e. `\*(C`malloc\*(C'' becomes `\*(C`MM_malloc\*(C'', `\*(C`strdup\*(C'' becomes `\*(C`MM_strdup\*(C'', etc. This \s-1API\s0 internally uses just a global `\*(C`MM *\*(C'' pool for calling the corresponding functions (those with prefix `\*(C`mm_\*(C'') of the <em>Standard Malloc-Style \s-1API\s0</em>.</p>
  </dd>
  <dt>
    <strong>Standard Malloc-Style \s-1API\s0</strong>
  </dt>
  <dd>
    <p>This is the standard high-level memory allocation \s-1API\s0. Its interface is similar to the <em>Global Malloc-Replacement \s-1API\s0</em> but it uses an explicit `\*(C`MM *\*(C'' pool to operate on. That is why every function of this \s-1API\s0 has an argument of type `\*(C`MM *\*(C'' as its first argument. This \s-1API\s0 provides a comfortable way to work with small dynamically allocated shared memory chunks inside large statically allocated shared memory segments. It is internally based on the <em>Low-Level Shared Memory \s-1API\s0</em> for creating the underlying shared memory segment.</p>
  </dd>
  <dt>
    <strong>Low-Level Shared Memory \s-1API\s0</strong>
  </dt>
  <dd>
    <p>This is the basis of the whole <strong>\s-1OSSP\s0 mm</strong> library. It provides low-level functions for creating shared memory segments with mutual exclusion (in short <em>mutex</em>) capabilities in a portable way. Internally the shared memory and mutex facility is implemented in various platform-dependent ways. A list of implementation variants follows under the next topic. Internally the shared memory facility is implemented in various platform-dependent ways. Each way has its own advantages and disadvantages (in addition to the fact that some variants aren't available at all on some platforms). The <strong>\s-1OSSP\s0 mm</strong> library's configuration procedure tries hard to make a good decision. The implemented variants are now given for overview and background reasons with their advantages and disadvantages and in an ascending order, i.e. the <strong>\s-1OSSP\s0 mm</strong> configuration mechanism chooses the last available one in the list as the preferred variant.</p>
  </dd>
  <dt>
    Classical <em>mmap</em>\|(2) on temporary file (\s-1MMFILE\s0)
  </dt>
  <dd>
    <p><em>Advantage:</em> maximum portable. <em>Disadvantage:</em> needs a temporary file on the filesystem.</p>
  </dd>
  <dt>
    <em>mmap</em>\|(2) via \s-1POSIX\s0.1 <em>shm_open</em>\|(3) on temporary file (\s-1MMPOSX\s0)
  </dt>
  <dd>
    <p><em>Advantage:</em> standardized by \s-1POSIX\s0.1 and theoretically portable. <em>Disadvantage:</em> needs a temporary file on the filesystem and is is usually not available on existing Unix platform. <em>Advantage:</em> widely available and mostly portable on \s-1SVR4\s0 platforms. <em>Disadvantage:</em> needs the \*(C`/dev/zero\*(C' device and a <em>mmap</em>\|(2) which supports memory mapping through this device.</p>
  </dd>
  <dt>
    SysV \s-1IPC\s0 <em>shmget</em>\|(2) (\s-1IPCSHM\s0)
  </dt>
  <dd>
    <p><em>Advantage:</em> does not need a temporary file or external device. <em>Disadvantage:</em> although available on mostly all modern Unix platforms, it has strong restrictions like the maximum size of a single shared memory segment (can be as small as 100KB, but depends on the platform). <em>Advantage:</em> does not need a temporary file or external device. <em>Disadvantage:</em> usually only available on \s-1BSD\s0 platforms and derivatives. As for the shared memory facility, internally the locking facility is implemented in various platform-dependent ways. They are again listed in ascending order, i.e. the <strong>\s-1OSSP\s0 mm</strong> configuration mechanism chooses the last available one in the list as the preferred variant. The list of implemented variants is:</p>
  </dd>
  <dt>
    4.2BSD-style <em>flock</em>\|(2) on temporary file (\s-1FLOCK\s0)
  </dt>
  <dd>
    <p><em>Advantage:</em> exists on a lot of platforms, especially on older Unix derivatives. <em>Disadvantage:</em> needs a temporary file on the filesystem and has to re-open file-descriptors to it in each(!) <em>fork</em>\|(2)'ed child process.</p>
  </dd>
  <dt>
    SysV \s-1IPC\s0 <em>semget</em>\|(2) (\s-1IPCSEM\s0)
  </dt>
  <dd>
    <p><em>Advantage:</em> exists on a lot of platforms and does not need a temporary file. <em>Disadvantage:</em> an unmeant termination of the application leads to a semaphore leak because the facility does not allow a ``remove in advance'' trick (as the \s-1IPC\s0 shared memory facility does) for safe cleanups.</p>
  </dd>
  <dt>
    SVR4-style <em>fcntl</em>\|(2) on temporary file (\s-1FCNTL\s0)
  </dt>
  <dd>
    <p><em>Advantage:</em> exists on a lot of platforms and is also the most powerful variant (although not always the fastest one). <em>Disadvantage:</em> needs a temporary file. The memory allocation strategy the <em>Standard Malloc-Style \s-1API\s0</em> functions use internally is the following:</p>
  </dd>
  <dt>
    <strong>Allocation</strong>
  </dt>
  <dd>
    <p>If a chunk of memory has to be allocated, the internal list of free chunks is searched for a minimal-size chunk which is larger or equal than the size of the to be allocated chunk (a <em>best fit</em> strategy). If a chunk is found which matches this best-fit criteria, but is still a lot larger than the requested size, it is split into two chunks: One with exactly the requested size (which is the resulting chunk given back) and one with the remaining size (which is immediately re-inserted into the list of free chunks). If no fitting chunk is found at all in the list of free chunks, a new one is created from the spare area of the shared memory segment until the segment is full (in which case an <em>out of memory</em> error occurs).</p>
  </dd>
  <dt>
    <strong>Deallocation</strong>
  </dt>
  <dd>
    <p>If a chunk of memory has to be deallocated, it is inserted in sorted manner into the internal list of free chunks. The insertion operation automatically merges the chunk with a previous and/or a next free chunk if possible, i.e. if the free chunks stay physically seamless (one after another) in memory, to automatically form larger free chunks out of smaller ones. This way the shared memory segment is automatically defragmented when memory is deallocated.</p>
  </dd>

</dl>
<p>This strategy reduces memory waste and fragmentation caused by small and frequent allocations and deallocations to a minimum.</p><p>The internal implementation of the list of free chunks is not specially optimized (for instance by using binary search trees or even <em>splay</em> trees, etc), because it is assumed that the total amount of entries in the list of free chunks is always small (caused both by the fact that shared memory segments are usually a lot smaller than heaps and the fact that we always defragment by merging the free chunks if possible).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API FUNCTIONS</h2>
        <div class="sectioncontent">
<p>In the following, all \s-1API\s0 functions are described in detail. The order directly follows the one in the <strong>\s-1SYNOPSIS\s0</strong> section above.</p>
<dl class='dl-vertical'>
  <dt>
    int <strong>MM_create</strong>(size_t <em>size</em>, const char *<em>file</em>);
  </dt>
  <dd>
    <p>This initializes the global shared memory pool with <em>size</em> and <em>file</em> and has to be called <em>before</em> any <em>fork</em>\|(2) operations are performed by the application.</p>
  </dd>
  <dt>
    int <strong>MM_permission</strong>(mode_t <em>mode</em>, uid_t <em>owner</em>, gid_t <em>group</em>);
  </dt>
  <dd>
    <p>This sets the filesystem <em>mode</em>, <em>owner</em> and <em>group</em> for the global shared memory pool (has effects only if the underlying shared memory segment implementation is actually based on external auxiliary files).  The arguments are directly passed through to <em>chmod</em>\|(2) and <em>chown</em>\|(2).</p>
  </dd>
  <dt>
    void <strong>MM_reset</strong>(void);
  </dt>
  <dd>
    <p>This resets the global shared memory pool: all chunks that have been allocated in the pool are marked as free and are eligible for reuse. The global memory pool itself is not destroyed.</p>
  </dd>
  <dt>
    void <strong>MM_destroy</strong>(void);
  </dt>
  <dd>
    <p>This destroys the global shared memory pool and should be called <em>after</em> all child processes were killed.</p>
  </dd>
  <dt>
    int <strong>MM_lock</strong>(mm_lock_mode <em>mode</em>);
  </dt>
  <dd>
    <p>This locks the global shared memory pool for the current process in order to perform either shared/read-only (<em>mode</em> is \*(C`MM_LOCK_RD\*(C') or exclusive/read-write (<em>mode</em> is \*(C`MM_LOCK_RW\*(C') critical operations inside the global shared memory pool.</p>
  </dd>
  <dt>
    int <strong>MM_unlock</strong>(void);
  </dt>
  <dd>
    <p>This unlocks the global shared memory pool for the current process after the critical operations were performed inside the global shared memory pool.</p>
  </dd>
  <dt>
    void *<strong>MM_malloc</strong>(size_t <em>size</em>);
  </dt>
  <dd>
    <p>Identical to the \s-1POSIX\s0.1 <em>malloc</em>\|(3) function but instead of allocating memory from the <em>heap</em> it allocates it from the global shared memory pool.</p>
  </dd>
  <dt>
    void <strong>MM_free</strong>(void *<em>ptr</em>);
  </dt>
  <dd>
    <p>Identical to the \s-1POSIX\s0.1 <em>free</em>\|(3) function but instead of deallocating memory in the <em>heap</em> it deallocates it in the global shared memory pool.</p>
  </dd>
  <dt>
    void *<strong>MM_realloc</strong>(void *<em>ptr</em>, size_t <em>size</em>);
  </dt>
  <dd>
    <p>Identical to the \s-1POSIX\s0.1 <em>realloc</em>\|(3) function but instead of reallocating memory in the <em>heap</em> it reallocates it inside the global shared memory pool.</p>
  </dd>
  <dt>
    void *<strong>MM_calloc</strong>(size_t <em>number</em>, size_t <em>size</em>);
  </dt>
  <dd>
    <p>Identical to the \s-1POSIX\s0.1 <em>calloc</em>\|(3) function but instead of allocating and initializing memory from the <em>heap</em> it allocates and initializes it from the global shared memory pool.</p>
  </dd>
  <dt>
    char *<strong>MM_strdup</strong>(const char *<em>str</em>);
  </dt>
  <dd>
    <p>Identical to the \s-1POSIX\s0.1 <em>strdup</em>\|(3) function but instead of creating the string copy in the <em>heap</em> it creates it in the global shared memory pool.</p>
  </dd>
  <dt>
    size_t <strong>MM_sizeof</strong>(const void *<em>ptr</em>);
  </dt>
  <dd>
    <p>This function returns the size in bytes of the chunk starting at <em>ptr</em> when <em>ptr</em> was previously allocated with <em>MM_malloc</em>\|(3). The result is undefined if <em>ptr</em> was not previously allocated with <em>MM_malloc</em>\|(3).</p>
  </dd>
  <dt>
    size_t <strong>MM_maxsize</strong>(void);
  </dt>
  <dd>
    <p>This function returns the maximum size which is allowed as the first argument to the <em>MM_create</em>\|(3) function.</p>
  </dd>
  <dt>
    size_t <strong>MM_available</strong>(void);
  </dt>
  <dd>
    <p>Returns the amount in bytes of still available (free) memory in the global shared memory pool.</p>
  </dd>
  <dt>
    char *<strong>MM_error</strong>(void);
  </dt>
  <dd>
    <p>Returns the last error message which occurred inside the <strong>\s-1OSSP\s0 mm</strong> library.</p>
  </dd>
  <dt>
    \s-1MM\s0 *<strong>mm_create</strong>(size_t <em>size</em>, const char *<em>file</em>);
  </dt>
  <dd>
    <p>This creates a shared memory pool which has space for approximately a total of <em>size</em> bytes with the help of <em>file</em>. Here <em>file</em> is a filesystem path to a file which need not to exist (and perhaps is never created because this depends on the platform and chosen shared memory and mutex implementation). The return value is a pointer to a \*(C`MM\*(C' structure which should be treated as opaque by the application. It describes the internals of the created shared memory pool. In case of an error \*(C`NULL\*(C' is returned.  A <em>size</em> of 0 means to allocate the maximum allowed size which is platform dependent and is between a few \s-1KB\s0 and the soft limit of 64MB.</p>
  </dd>
  <dt>
    int <strong>mm_permission</strong>(\s-1MM\s0 *<em>mm</em>, mode_t <em>mode</em>, uid_t <em>owner</em>, gid_t <em>group</em>);
  </dt>
  <dd>
    <p>This sets the filesystem <em>mode</em>, <em>owner</em> and <em>group</em> for the shared memory pool <em>mm</em> (has effects only when the underlying shared memory segment implementation is actually based on external auxiliary files).  The arguments are directly passed through to <em>chmod</em>\|(2) and <em>chown</em>\|(2).</p>
  </dd>
  <dt>
    void <strong>mm_reset</strong>(\s-1MM\s0 *<em>mm</em>);
  </dt>
  <dd>
    <p>This resets the shared memory pool <em>mm</em>: all chunks that have been allocated in the pool are marked as free and are eligible for reuse. The memory pool itself is not destroyed.</p>
  </dd>
  <dt>
    void <strong>mm_destroy</strong>(\s-1MM\s0 *<em>mm</em>);
  </dt>
  <dd>
    <p>This destroys the complete shared memory pool <em>mm</em> and with it all chunks which were allocated in this pool. Additionally any created files on the filesystem corresponding to the shared memory pool are unlinked.</p>
  </dd>
  <dt>
    int <strong>mm_lock</strong>(\s-1MM\s0 *<em>mm</em>, mm_lock_mode <em>mode</em>);
  </dt>
  <dd>
    <p>This locks the shared memory pool <em>mm</em> for the current process in order to perform either shared/read-only (<em>mode</em> is \*(C`MM_LOCK_RD\*(C') or exclusive/read-write (<em>mode</em> is \*(C`MM_LOCK_RW\*(C') critical operations inside the global shared memory pool.</p>
  </dd>
  <dt>
    int <strong>mm_unlock</strong>(\s-1MM\s0 *<em>mm</em>);
  </dt>
  <dd>
    <p>This unlocks the shared memory pool <em>mm</em> for the current process after critical operations were performed inside the global shared memory pool.</p>
  </dd>
  <dt>
    void *<strong>mm_malloc</strong>(\s-1MM\s0 *<em>mm</em>, size_t <em>size</em>);
  </dt>
  <dd>
    <p>This function allocates <em>size</em> bytes from the shared memory pool <em>mm</em> and returns either a (virtual memory word aligned) pointer to it or \*(C`NULL\*(C' in case of an error (out of memory). It behaves like the \s-1POSIX\s0.1 <em>malloc</em>\|(3) function but instead of allocating memory from the <em>heap</em> it allocates it from the shared memory segment underlying <em>mm</em>.</p>
  </dd>
  <dt>
    void <strong>mm_free</strong>(\s-1MM\s0 *<em>mm</em>, void *<em>ptr</em>);
  </dt>
  <dd>
    <p>This deallocates the chunk starting at <em>ptr</em> in the shared memory pool <em>mm</em>. It behaves like the \s-1POSIX\s0.1 <em>free</em>\|(3) function but instead of deallocating memory from the <em>heap</em> it deallocates it from the shared memory segment underlying <em>mm</em>.</p>
  </dd>
  <dt>
    void *<strong>mm_realloc</strong>(\s-1MM\s0 *<em>mm</em>, void *<em>ptr</em>, size_t <em>size</em>);
  </dt>
  <dd>
    <p>This function reallocates the chunk starting at <em>ptr</em> inside the shared memory pool <em>mm</em> with the new size of <em>size</em> bytes.  It behaves like the \s-1POSIX\s0.1 <em>realloc</em>\|(3) function but instead of reallocating memory in the <em>heap</em> it reallocates it in the shared memory segment underlying <em>mm</em>.</p>
  </dd>
  <dt>
    void *<strong>mm_calloc</strong>(\s-1MM\s0 *<em>mm</em>, size_t <em>number</em>, size_t <em>size</em>);
  </dt>
  <dd>
    <p>This is similar to <em>mm_malloc</em>\|(3), but additionally clears the chunk. It behaves like the \s-1POSIX\s0.1 <em>calloc</em>\|(3) function.  It allocates space for <em>number</em> objects, each <em>size</em> bytes in length from the shared memory pool <em>mm</em>.  The result is identical to calling <em>mm_malloc</em>\|(3) with an argument of ``<em>number</em> * <em>size</em>'', with the exception that the allocated memory is initialized to nul bytes.</p>
  </dd>
  <dt>
    char *<strong>mm_strdup</strong>(\s-1MM\s0 *<em>mm</em>, const char *<em>str</em>);
  </dt>
  <dd>
    <p>This function behaves like the \s-1POSIX\s0.1 <em>strdup</em>\|(3) function.  It allocates sufficient memory inside the shared memory pool <em>mm</em> for a copy of the string <em>str</em>, does the copy, and returns a pointer to it.  The pointer may subsequently be used as an argument to the function <em>mm_free</em>\|(3). If insufficient shared memory is available, \*(C`NULL\*(C' is returned.</p>
  </dd>
  <dt>
    size_t <strong>mm_sizeof</strong>(\s-1MM\s0 *<em>mm</em>, const void *<em>ptr</em>);
  </dt>
  <dd>
    <p>This function returns the size in bytes of the chunk starting at <em>ptr</em> when <em>ptr</em> was previously allocated with <em>mm_malloc</em>\|(3) inside the shared memory pool <em>mm</em>. The result is undefined when <em>ptr</em> was not previously allocated with <em>mm_malloc</em>\|(3).</p>
  </dd>
  <dt>
    size_t <strong>mm_maxsize</strong>(void);
  </dt>
  <dd>
    <p>This function returns the maximum size which is allowed as the first argument to the <em>mm_create</em>\|(3) function.</p>
  </dd>
  <dt>
    size_t <strong>mm_available</strong>(\s-1MM\s0 *<em>mm</em>);
  </dt>
  <dd>
    <p>Returns the amount in bytes of still available (free) memory in the shared memory pool <em>mm</em>.</p>
  </dd>
  <dt>
    char *<strong>mm_error</strong>(void);
  </dt>
  <dd>
    <p>Returns the last error message which occurred inside the <strong>\s-1OSSP\s0 mm</strong> library.</p>
  </dd>
  <dt>
    void <strong>mm_display_info</strong>(\s-1MM\s0 *<em>mm</em>);
  </dt>
  <dd>
    <p>This is debugging function which displays a summary page for the shared memory pool <em>mm</em> describing various internal sizes and counters.</p>
  </dd>
  <dt>
    void *<strong>mm_core_create</strong>(size_t <em>size</em>, const char *<em>file</em>);
  </dt>
  <dd>
    <p>This creates a shared memory area which is at least <em>size</em> bytes in size with the help of <em>file</em>. The value <em>size</em> has to be greater than 0 and less or equal the value returned by <em>mm_core_maxsegsize</em>\|(3). Here <em>file</em> is a filesystem path to a file which need not to exist (and perhaps is never created because this depends on the platform and chosen shared memory and mutex implementation).  The return value is either a (virtual memory word aligned) pointer to the shared memory segment or \*(C`NULL\*(C' in case of an error. The application is guaranteed to be able to access the shared memory segment from byte 0 to byte <em>size</em>-1 starting at the returned address.</p>
  </dd>
  <dt>
    int <strong>mm_core_permission</strong>(void *<em>core</em>, mode_t <em>mode</em>, uid_t <em>owner</em>, gid_t <em>group</em>);
  </dt>
  <dd>
    <p>This sets the filesystem <em>mode</em>, <em>owner</em> and <em>group</em> for the shared memory segment <em>code</em> (has effects only when the underlying shared memory segment implementation is actually based on external auxiliary files).  The arguments are directly passed through to <em>chmod</em>\|(2) and <em>chown</em>\|(2).</p>
  </dd>
  <dt>
    void <strong>mm_core_delete</strong>(void *<em>core</em>);
  </dt>
  <dd>
    <p>This deletes a shared memory segment <em>core</em> (as previously returned by a <em>mm_core_create</em>\|(3) call). After this operation, accessing the segment starting at <em>core</em> is no longer allowed and will usually lead to a segmentation fault.</p>
  </dd>
  <dt>
    int <strong>mm_core_lock</strong>(const void *<em>core</em>, mm_lock_mode <em>mode</em>);
  </dt>
  <dd>
    <p>This function acquires an advisory lock for the current process on the shared memory segment <em>core</em> for either shared/read-only (<em>mode</em> is \*(C`MM_LOCK_RD\*(C') or exclusive/read-write (<em>mode</em> is \*(C`MM_LOCK_RW\*(C') critical operations between <em>fork</em>\|(2)'ed child processes.</p>
  </dd>
  <dt>
    int <strong>mm_core_unlock</strong>(const void *<em>core</em>);
  </dt>
  <dd>
    <p>This function releases a previously acquired advisory lock for the current process on the shared memory segment <em>core</em>.</p>
  </dd>
  <dt>
    size_t <strong>mm_core_size</strong>(const void *<em>core</em>);
  </dt>
  <dd>
    <p>This returns the size in bytes of <em>core</em>. This size is exactly the size which was used for creating the shared memory area via <em>mm_core_create</em>\|(3). The function is provided just for convenience reasons to not require the application to remember the memory size behind <em>core</em> itself.</p>
  </dd>
  <dt>
    size_t <strong>mm_core_maxsegsize</strong>(void);
  </dt>
  <dd>
    <p>This returns the number of bytes of a maximum-size shared memory segment which is allowed to allocate via the \s-1MM\s0 library. It is between a few \s-1KB\s0 and the soft limit of 64MB.</p>
  </dd>
  <dt>
    size_t <strong>mm_core_align2page</strong>(size_t <em>size</em>);
  </dt>
  <dd>
    <p>This is just a utility function which can be used to align the number <em>size</em> to the next virtual memory <em>page</em> boundary used by the underlying platform. The memory page boundary under Unix platforms is usually somewhere between 2048 and 16384 bytes. You do not have to align the <em>size</em> arguments of other <strong>\s-1OSSP\s0 mm</strong> library functions yourself, because this is already done internally. This function is exported by the <strong>\s-1OSSP\s0 mm</strong> library just for convenience reasons in case an application wants to perform similar calculations for other purposes.</p>
  </dd>
  <dt>
    size_t <strong>mm_core_align2word</strong>(size_t <em>size</em>);
  </dt>
  <dd>
    <p>This is another utility function which can be used to align the number <em>size</em> to the next virtual memory <em>word</em> boundary used by the underlying platform. The memory word boundary under Unix platforms is usually somewhere between 4 and 16 bytes.  You do not have to align the <em>size</em> arguments of other <strong>\s-1OSSP\s0 mm</strong> library functions yourself, because this is already done internally.  This function is exported by the <strong>\s-1OSSP\s0 mm</strong> library just for convenience reasons in case an application wants to perform similar calculations for other purposes.</p>
  </dd>
  <dt>
    void <strong>mm_lib_error_set</strong>(unsigned int, const char *str);
  </dt>
  <dd>
    <p>This is a function which is used internally by the various \s-1MM\s0 function to set an error string. It's usually not called directly from applications.</p>
  </dd>
  <dt>
    char *<strong>mm_lib_error_get</strong>(void);
  </dt>
  <dd>
    <p>This is a function which is used internally by <em>MM_error</em>\|(3) and <em>mm_error</em>\|(3) functions to get the current error string. It is usually not called directly from applications.</p>
  </dd>
  <dt>
    int <strong>mm_lib_version</strong>(void);
  </dt>
  <dd>
    <p>This function returns a hex-value ``0x<em>V</em><em>\s-1RR\s0</em><em>T</em><em>\s-1LL\s0</em>'' which describes the current <strong>\s-1OSSP\s0 mm</strong> library version. <em>V</em> is the version, <em>\s-1RR\s0</em> the revisions, <em>\s-1LL\s0</em> the level and <em>T</em> the type of the level (alphalevel=0, betalevel=1, patchlevel=2, etc). For instance <strong>\s-1OSSP\s0 mm</strong> version 1.0.4 is encoded as 0x100204. The reason for this unusual mapping is that this way the version number is steadily <em>increasing</em>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESTRICTIONS</h2>
        <div class="sectioncontent">
<p>The maximum size of a continuous shared memory segment one can allocate depends on the underlying platform. This cannot be changed, of course.  But currently the high-level <em>malloc</em>\|(3)-style \s-1API\s0 just uses a single shared memory segment as the underlying data structure for an \*(C`MM\*(C' object which means that the maximum amount of memory an \*(C`MM\*(C' object represents also depends on the platform.</p><p>This could be changed in later versions by allowing at least the high-level <em>malloc</em>\|(3)-style \s-1API\s0 to internally use multiple shared memory segments to form the \*(C`MM\*(C' object. This way \*(C`MM\*(C' objects could have arbitrary sizes, although the maximum size of an allocatable continuous chunk still is bounded by the maximum size of a shared memory segment.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO mm&hellip;</h2>
        <div class="sectioncontent">
<p><em>mm-config</em>\|(1).</p><p><em>malloc</em>\|(3), <em>calloc</em>\|(3), <em>realloc</em>\|(3), <em>strdup</em>\|(3), <em>free</em>\|(3), <em>mmap</em>\|(2), <em>shmget</em>\|(2), <em>shmctl</em>\|(2), <em>flock</em>\|(2), <em>fcntl</em>\|(2), <em>semget</em>\|(2), <em>semctl</em>\|(2), <em>semop</em>\|(2).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HOME</h2>
        <div class="sectioncontent">
<p>http://www.ossp.org/pkg/lib/mm/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p>This library was originally written in January 1999 by <em>Ralf S.</em> Engelschall &lt;rse@engelschall.com&gt; for use in the <strong>Extended \s-1API\s0</strong> (\s-1EAPI\s0) of the <strong>Apache</strong> \s-1HTTP\s0 server project (see http://www.apache.org/), which was originally invented for <strong>mod_ssl</strong> (see http://www.modssl.org/).</p><p>Its base idea (a malloc-style \s-1API\s0 for handling shared memory) was originally derived from the non-publically available <em>mm_malloc</em> library written in October 1997 by <em>Charles Randall</em> &lt;crandall@matchlogic.com&gt; for MatchLogic, Inc.</p><p>In 2000 this library joined the <strong>\s-1OSSP\s0</strong> project where all other software development projects of <em>Ralf S. Engelschall</em> are located.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p> Ralf S. Engelschall  rse@engelschall.com  www.engelschall.com</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mlpack_util_SaveRestoreUtility.3.html"><span aria-hidden="true">&larr;</span> mlpack_util_SaveRestoreUtility.3: Mlpack::util::saverestoreutility -</a></li>
   <li class="next"><a href="mmap64.3.html">mmap64.3: Map or unmap files or devices into memory <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>POE::Component::JobQueue: A component to manage queues and worker pools</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A component to manage queues and worker pools">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="POE::Component::JobQueue (3pm) manual">
  <meta name="twitter:description" content="A component to manage queues and worker pools">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpoe-component-jobqueue-perl-POE::Component::JobQueue-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/POE::Component::JobQueue.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="POE::Component::JobQueue (3pm) manual" />
  <meta property="og:description" content="A component to manage queues and worker pools" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpoe-component-jobqueue-perl-POE::Component::JobQueue-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">POE::Component::JobQueue<small> (3pm)</small></h1>
        <p class="lead">A component to manage queues and worker pools</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/POE::Component::JobQueue.3pm.html">
      <span itemprop="name">POE::Component::JobQueue: A component to manage queues and worker pools</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpoe-component-jobqueue-perl/">
      <span itemprop="name">libpoe-component-jobqueue-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/POE::Component::JobQueue.3pm.html">
      <span itemprop="name">POE::Component::JobQueue: A component to manage queues and worker pools</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use POE qw(Component::JobQueue);

  # Passive queue waits for enqueue events.
  POE::Component::JobQueue-&gt;spawn
    ( Alias         =&gt; &apos;passive&apos;,         # defaults to &apos;queuer&apos;
      WorkerLimit   =&gt; 16,                # defaults to 8
      Worker        =&gt; &#92;&spawn_a_worker,  # code which will start a session
      Passive       =&gt;
      { Prioritizer =&gt; &#92;&job_comparer,    # defaults to sub { 1 } # FIFO
      },
    );

  # Active queue fetches jobs and spawns workers.
  POE::Component::JobQueue-&gt;spawn
    ( Alias          =&gt; &apos;active&apos;,          # defaults to &apos;queuer&apos;
      WorkerLimit    =&gt; 32,                # defaults to 8
      Worker         =&gt; &#92;&fetch_and_spawn, # fetch a job and start a session
      Active         =&gt;
      { PollInterval =&gt; 1,                 # defaults to undef (no polling)
        AckAlias     =&gt; &apos;respondee&apos;,       # defaults to undef (no respondee)
        AckState     =&gt; &apos;response&apos;,        # defaults to undef
      },
    );

  # Enqueuing a job in a passive queue.
  $kernel-&gt;post( &apos;passive&apos;,   # post to &apos;passive&apos; alias
                 &apos;enqueue&apos;,   # &apos;enqueue&apos; a job
                 &apos;postback&apos;,  # which of our states is notified when it&apos;s done
                 @job_params, # job parameters
               );

  # Passive worker function.
  sub spawn_a_worker {
    my ($postback, @job_params) = @_;     # same parameters as posted
    POE::Session-&gt;create
      ( inline_states =&gt; &#92;%inline_states, # handwaving over details here
        args          =&gt; [ $postback,     # $postback-&gt;(@results) to return
                           @job_params,   # parameters of this job
                         ],
      );
  }

  # Active worker function.
  sub fetch_and_spawn {
    my $meta_postback = shift;               # called to create a postback
    my @job_params = &fetch_next_job();      # fetch the next job&apos;s parameters
    if (@job_params) {                       # if there&apos;s a job to do...
      my $postback = $meta_postback-&gt;(@job_params); # ... create a postback
      POE::Session-&gt;create                          # ... create a session
        ( inline_states =&gt; &#92;%inline_states,  # handwaving over details here
          args          =&gt; [ $postback,      # $postback-&gt;(@results) to return
                             @job_params,    # parameters of this job
                           ],
        );
    }
  }

  # Invoke a postback to acknowledge that a job is done.
  $postback-&gt;( @job_results );

  # This is the sub which is called when a postback is invoked.
  sub postback_handler {
    my ($request_packet, $response_packet) = @_[ARG0, ARG1];

    my @original_job_params = @{$request_packet};  # original post/fetch
    my @job_results         = @{$response_packet}; # passed to the postback

    print "original job parameters: (@original_job_params)&#92;n";
    print "results of finished job: (@job_results)&#92;n";
  }

  # Stop a running queue
  $kernel-&gt;call( &apos;active&apos; =&gt; &apos;stop&apos; );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>POE::Component::JobQueue manages a finite pool of worker sessions as they handle an arbitrarily large number of tasks.  It often is used as a form of flow control, preventing a large group of tasks from exhausting some sort of resource.</p><p>PoCo::JobQueue implements two kinds of queue: active and passive. Both kinds of queue use a Worker coderef to spawn sessions that process jobs, but how they use the Worker differs between them.</p><p>Active queues' Worker code fetches a new job from a resource that must be polled.  For example, it may read a new line from a file.  Passive queues, on the other hand, are given jobs with 'enqueue' events. Their Worker functions are passed the next job as parameters.</p><p>JobQueue components are not proper objects.  Instead of being created, as most objects are, they are \*(L"spawned\*(R" as separate sessions.  To avoid confusion (and hopefully not cause other confusion), they must be spawned wich a \*(C`spawn\*(C' method, not created anew with a \*(C`new\*(C' one.</p><p>POE::Component::JobQueue's \*(C`spawn\*(C' method takes different parameters depending whether it's going to be an active or a passive session. Regardless, there are a few parameters which are the same for both: \*(C`Alias\*(C' sets the name by which the session will be known.  If no alias is given, the component defaults to \*(L"queuer\*(R".  The alias lets several sessions interact with job queues without keeping (or even knowing) hard references to them.  It's possible to spawn several queues with different aliases. \*(C`WorkerLimit\*(C' sets the limit on the number of worker sessions which will run in parallel.  It defaults arbitrarily to 8.  No more than this number of workers will be active at once.</p>
<dl class='dl-vertical'>
  <dt>
    Worker =&gt; &#92;&worker
  </dt>
  <dd>
    <p>\*(C`Worker\*(C' is a coderef which is called whenever it's time to spawn a new session.  What it receives as parameters and what it's expected to do are slightly different for active and passive sessions. Active workers receive just one parameter: a meta-postback.  This is used to build a postback once the next job's parameters are known. They're expected to actively fetch the next job's parameters and spawn a new session if necessary. See \*(C`sub fetch_and_spawn\*(C' in the \s-1SYNOPSIS\s0 for an example of an active worker function.&gt; Passive workers' arguments include a pre-built postback and the next job's parameters.  Since the JobQueue component already knows what the job parameters are, it's done most of the work for the worker.  All that's left is to spawn the session that will process the job. See \*(C`sub spawn_a_worker\*(C' in the \s-1SYNOPSIS\s0 for an example of a passive worker function. When a postback is called, it posts its parameters (plus the parameters passed when it was created) to the session it belongs to. Postbacks are discussed in the POE::Session manpage.</p>
  </dd>

</dl>
<p>These parameters are unique to passive queues:</p>
<dl class='dl-vertical'>
  <dt>
    Passive =&gt; &#92;%passive_parameters
  </dt>
  <dd>
    <p>\*(C`Passive\*(C' contains a hashref of passive queue parameters.  The \*(C`Passive\*(C' parameter block's presence indicates that the queue will be passive, but its contents may be empty since all its parameters are optional:   Passive =&gt; { }, # all passive parameters take default values A queue can't be both active and passive at the same time. The \*(C`Passive\*(C' block takes up to one parameter.</p>
  </dd>
  <dt>
    Prioritizer =&gt; &#92;&prioritizer_function
  </dt>
  <dd>
    <p>\*(C`Prioritizer\*(C' holds a function that defines how a job queue will be ordered.  The prioritizer function receives references to two jobs, and it returns a value which tells the JobQueue component which job should be dealt with first. In the Unix tradition, lower priorities go first.  This transforms the prioritizer into a simple sort function, which it has been modelled after.  Like sort's sorter sub, the prioritizer returns -1 if the first job goes before the second one; 0 if both jobs have the same priority; and 1 if the first job goes after the second.  It's easier to write an example than to describe it:   sub low_priorities_first {     my ($first_job, $second_job) = @_;     return $first_job-&gt;{priority} &lt;=&gt; $second_job-&gt;{priority};   } The first argument always refers to the new job being enqueued. The default prioritizer always returns 1.  Since the first argument always refers to the new job being enqueued, this effects a \s-1FIFO\s0 queue.  Replacing it with a prioritizer that always returns -1 will turn the JobQueue into a stack (last in, first out).</p>
  </dd>

</dl>
<p>These parameters are unique to active queues:</p>
<dl class='dl-vertical'>
  <dt>
    Active =&gt; &#92;%active_parameters
  </dt>
  <dd>
    <p>\*(C`Active\*(C' contains a hashref of active queue parameters.  The \*(C`Active\*(C' parameter block's presence indicates that the queue will be active, but its contens may be empty since all its parameters are optional.   Active =&gt; { }, # all active parameters take default values A queue can't be both active and passive at the same time. The \*(C`Active\*(C' block takes up to three parameters.</p><p>Active \*(C`Worker\*(C' functions indicate that they've run out of jobs by failing to spawn new sessions.  When this happens, an active queue may go into \*(L"polling\*(R" mode.  In this mode, the \*(C`Worker\*(C' is called periodically to see if new jobs have appeared in whatever it's getting them from. \*(C`PollInterval\*(C', if present, tells the job queue how often to call \*(C`Worker\*(C' in the absence of new sessions.  If it's omitted, the active queue stops after the first time it runs out of jobs. \*(C`AckAlias\*(C' and \*(C`AckState\*(C' tell the active job queue where to send acknowledgements of jobs which have been completed.  If one is specified, then both must be.</p>
  </dd>

</dl>
<p>Sessions communicate asynchronously with passive JobQueue components. They post \*(L"enqueue\*(R" requests to it, and it posts job results back.</p><p>Requests are posted to the component's \*(L"enqueue\*(R" state.  They include the name of a state to post responses back to, and a list of job parameters.  For example:</p><p>  $kernel-&gt;post( &apos;queue&apos;, &apos;enqueue&apos;, # queuer session alias & state                  &apos;job_results&apos;,      # my state to receive responses                  @job_parameters,    # parameters of the job                );</p><p>Once the job is completed, the handler for 'job_results' will be called with the job parameters and results.  See \*(C`sub postback_handler\*(C' in the \s-1SYNOPSIS\s0 for an example results handler.</p><p>Active JobQueue components act as event generators.  They don't receive jobs from the outside; instead, they poll for them and post acknowledgements as they're completed.</p><p>Running queues can be stopped by posting a \*(L"stop\*(R" state to the component. Any currently running workers will be allowed to complete, but no new workers will be started.</p><p>  $kernel-&gt;call( &apos;queue&apos; =&gt; &apos;stop&apos; ); # Stop the running queue</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO POE::Component::JobQueue&hellip;</h2>
        <div class="sectioncontent">
<p>This component is built upon and \s-1POE\s0.  Please see its source code and the documentation for its foundation modules to learn more.</p><p>Also see the test program, t/01_queues.t, in the POE::Component::JobQueue distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUG TRACKER</h2>
        <div class="sectioncontent">
<p>https://rt.cpan.org/Dist/Display.html?Status=Active&Queue=POE-Component-JobQueue</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REPOSITORY</h2>
        <div class="sectioncontent">
<p>http://thirdlobe.com/svn/poco-jobqueue/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER RESOURCES</h2>
        <div class="sectioncontent">
<p>http://search.cpan.org/dist/POE-Component-JobQueue/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR & COPYRIGHTS</h2>
        <div class="sectioncontent">
<p>POE::Component::JobQueue is Copyright 1999-2009 by Rocco Caputo.  All rights are reserved.  POE::Component::JobQueue is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="POE::Component::Jabber::XMPP.3pm.html"><span aria-hidden="true">&larr;</span> POE::Component::Jabber::XMPP.3pm: Connect using the xmpp jabber protocol</a></li>
   <li class="next"><a href="POE::Component::PubSub.3pm.html">POE::Component::PubSub.3pm: A generic publish/subscribe poe::component that enables poe::sessions to publish events to which other poe::sessions may subscribe. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

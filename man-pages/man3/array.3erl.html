<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>array: Functional, extendible arrays.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Functional, extendible arrays.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="array (3erl) manual">
  <meta name="twitter:description" content="Functional, extendible arrays.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-array-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/array.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="array (3erl) manual" />
  <meta property="og:description" content="Functional, extendible arrays." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-array-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">array<small> (3erl)</small></h1>
        <p class="lead">Functional, extendible arrays.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/array.3erl.html">
      <span itemprop="name">array: Functional, extendible arrays.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/array.3erl.html">
      <span itemprop="name">array: Functional, extendible arrays.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Functional, extendible arrays. Arrays can have fixed size, or can grow automatically as needed. A default value is used for entries that have not been explicitly set.</p><p>Arrays uses <em>zero</em> based indexing. This is a deliberate design choice and differs from other erlang datastructures, e.g. tuples.</p><p>Unless specified by the user when the array is created, the default value is the atom <em>undefined</em>. There is no difference between an unset entry and an entry which has been explicitly set to the same value as the default one (cf. <strong>reset/2</strong>). If you need to differentiate between unset and set entries, you must make sure that the default value cannot be confused with the values of set entries.</p><p>The array never shrinks automatically; if an index <em>I</em> has been used successfully to set an entry, all indices in the range [0,<em>I</em>] will stay accessible unless the array size is explicitly changed by calling <strong>resize/2</strong>.</p><p>Examples:</p>
<pre>
  %% Create a fixed-size array with entries 0-9 set to 'undefined'
  A0 = array:new(10).
  10 = array:size(A0).

  %% Create an extendible array and set entry 17 to 'true',
  %% causing the array to grow automatically
  A1 = array:set(17, true, array:new()).
  18 = array:size(A1).

  %% Read back a stored value
  true = array:get(17, A1).

  %% Accessing an unset entry returns the default value
  undefined = array:get(3, A1).

  %% Accessing an entry beyond the last set entry also returns the
  %% default value, if the array does not have fixed size
  undefined = array:get(18, A1).

  %% "sparse" functions ignore default-valued entries
  A2 = array:set(4, false, A1).
  [{4, false}, {17, true}] = array:sparse_to_orddict(A2).

  %% An extendible array can be made fixed-size later
  A3 = array:fix(A2).

  %% A fixed-size array does not grow automatically and does not
  %% allow accesses beyond the last set entry
  {'EXIT',{badarg,_}} = (catch array:set(18, true, A3)).
  {'EXIT',{badarg,_}} = (catch array:get(18, A3)).
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>array(Type)</strong>

</pre>
<p>A functional, extendible array. The representation is not documented and is subject to change without notice. Note that arrays cannot be directly compared for equality.</p>
<pre>
<strong>array()</strong>

</pre>
<p><em>array()</em> is equivalent to <em>array(term())</em>.</p>
<pre>
<strong>array_indx()</strong> = integer() &gt;= 0

</pre>

<pre>
<strong>array_opts()</strong> = <strong>array_opt()</strong> | [<strong>array_opt()</strong>]

</pre>

<pre>
<strong>array_opt()</strong> = {fixed, boolean()}

            | fixed

            | {default, Type :: term()}

            | {size, N :: integer() &gt;= 0}

            | (N :: integer() &gt;= 0)

</pre>

<pre>
<strong>indx_pairs(Type)</strong> = [<strong>indx_pair</strong>(Type)]

</pre>

<pre>
<strong>indx_pair(Type)</strong> = {Index :: <strong>array_indx()</strong>, Type}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
default(Array :: array(Type)) -&gt; Value :: Type

</pre>
<p>Get the value used for uninitialized entries.</p><p><em>See also:</em> <strong>new/2</strong>.</p>
<pre>
<strong></strong>
fix(Array :: array(Type)) -&gt; array(Type)

</pre>
<p>Fix the size of the array. This prevents it from growing automatically upon insertion; see also <strong>set/3</strong>.</p><p><em>See also:</em> <strong>relax/1</strong>.</p>
<pre>
<strong></strong>
foldl(Function, InitialAcc :: A, Array :: array(Type)) -&gt; B

</pre>
<p>Types:</p><p>Function =</p>
<pre>
    fun((Index :: <strong>array_indx()</strong>, Value :: Type, Acc :: A) -&gt; B)
</pre>
<p>Fold the elements of the array using the given function and initial accumulator value. The elements are visited in order from the lowest index to the highest. If <em>Function</em> is not a function, the call fails with reason <em>badarg</em>.</p><p><em>See also:</em> <strong>foldr/3</strong>, <strong>map/2</strong>, <strong>sparse_foldl/3</strong>.</p>
<pre>
<strong></strong>
foldr(Function, InitialAcc :: A, Array :: array(Type)) -&gt; B

</pre>
<p>Types:</p><p>Function =</p>
<pre>
    fun((Index :: <strong>array_indx()</strong>, Value :: Type, Acc :: A) -&gt; B)
</pre>
<p>Fold the elements of the array right-to-left using the given function and initial accumulator value. The elements are visited in order from the highest index to the lowest. If <em>Function</em> is not a function, the call fails with reason <em>badarg</em>.</p><p><em>See also:</em> <strong>foldl/3</strong>, <strong>map/2</strong>.</p>
<pre>
<strong></strong>
from_list(List :: [Value :: Type]) -&gt; array(Type)

</pre>
<p>Equivalent to <strong>from_list(List, undefined)</strong>.</p>
<pre>
<strong></strong>
from_list(List :: [Value :: Type], Default :: term()) -&gt;
<strong></strong>
             array(Type)

</pre>
<p>Convert a list to an extendible array. <em>Default</em> is used as the value for uninitialized entries of the array. If <em>List</em> is not a proper list, the call fails with reason <em>badarg</em>.</p><p><em>See also:</em> <strong>new/2</strong>, <strong>to_list/1</strong>.</p>
<pre>
<strong></strong>
from_orddict(Orddict :: indx_pairs(Value :: Type)) -&gt; array(Type)

</pre>
<p>Equivalent to <strong>from_orddict(Orddict, undefined)</strong>.</p>
<pre>
<strong></strong>
from_orddict(Orddict :: indx_pairs(Value :: Type),
<strong></strong>
             Default :: Type) -&gt;
<strong></strong>
                array(Type)

</pre>
<p>Convert an ordered list of pairs <em>{Index, Value}</em> to a corresponding extendible array. <em>Default</em> is used as the value for uninitialized entries of the array. If <em>Orddict</em> is not a proper, ordered list of pairs whose first elements are nonnegative integers, the call fails with reason <em>badarg</em>.</p><p><em>See also:</em> <strong>new/2</strong>, <strong>to_orddict/1</strong>.</p>
<pre>
<strong></strong>
get(I :: array_indx(), Array :: array(Type)) -&gt; Value :: Type

</pre>
<p>Get the value of entry <em>I</em>. If <em>I</em> is not a nonnegative integer, or if the array has fixed size and <em>I</em> is larger than the maximum index, the call fails with reason <em>badarg</em>.</p><p>If the array does not have fixed size, this function will return the default value for any index <em>I</em> greater than <em>size(Array)-1</em>.</p><p><em>See also:</em> <strong>set/3</strong>.</p>
<pre>
<strong></strong>
is_array(X :: term()) -&gt; boolean()

</pre>
<p>Returns <em>true</em> if <em>X</em> appears to be an array, otherwise <em>false</em>. Note that the check is only shallow; there is no guarantee that <em>X</em> is a well-formed array representation even if this function returns <em>true</em>.</p>
<pre>
<strong></strong>
is_fix(Array :: array()) -&gt; boolean()

</pre>
<p>Check if the array has fixed size. Returns <em>true</em> if the array is fixed, otherwise <em>false</em>.</p><p><em>See also:</em> <strong>fix/1</strong>.</p>
<pre>
<strong></strong>
map(Function, Array :: array(Type1)) -&gt; array(Type2)

</pre>
<p>Types:</p><p>Function = fun((Index :: <strong>array_indx()</strong>, Type1) -&gt; Type2)</p><p>Map the given function onto each element of the array. The elements are visited in order from the lowest index to the highest. If <em>Function</em> is not a function, the call fails with reason <em>badarg</em>.</p><p><em>See also:</em> <strong>foldl/3</strong>, <strong>foldr/3</strong>, <strong>sparse_map/2</strong>.</p>
<pre>
<strong></strong>
new() -&gt; array()

</pre>
<p>Create a new, extendible array with initial size zero.</p><p><em>See also:</em> <strong>new/1</strong>, <strong>new/2</strong>.</p>
<pre>
<strong></strong>
new(Options :: array_opts()) -&gt; array()

</pre>
<p>Create a new array according to the given options. By default, the array is extendible and has initial size zero. Array indices start at 0.</p><p><em>Options</em> is a single term or a list of terms, selected from the following:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>N::integer() &gt;= 0</em> or <em>{size, N::integer() &gt;= 0}</em>: Specifies the initial size of the array; this also implies <em>{fixed, true}</em>. If <em>N</em> is not a nonnegative integer, the call fails with reason <em>badarg</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>fixed</em> or <em>{fixed, true}</em>: Creates a fixed-size array; see also <strong>fix/1</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{fixed, false}</em>: Creates an extendible (non fixed-size) array.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{default, Value}</em>: Sets the default value for the array to <em>Value</em>.</p>
  </dd>

</dl>
<p>Options are processed in the order they occur in the list, i.e., later options have higher precedence.</p><p>The default value is used as the value of uninitialized entries, and cannot be changed once the array has been created.</p><p>Examples:</p>
<pre>
     array:new(100)
</pre>
<p>creates a fixed-size array of size 100.</p>
<pre>
     array:new({default,0})
</pre>
<p>creates an empty, extendible array whose default value is 0.</p>
<pre>
     array:new([{size,10},{fixed,false},{default,-1}])
</pre>
<p>creates an extendible array with initial size 10 whose default value is -1.</p><p><em>See also:</em> <strong>fix/1</strong>, <strong>from_list/2</strong>, <strong>get/2</strong>, <strong>new/0</strong>, <strong>new/2</strong>, <strong>set/3</strong>.</p>
<pre>
<strong></strong>
new(Size :: integer() &gt;= 0, Options :: array_opts()) -&gt; array()

</pre>
<p>Create a new array according to the given size and options. If <em>Size</em> is not a nonnegative integer, the call fails with reason <em>badarg</em>. By default, the array has fixed size. Note that any size specifications in <em>Options</em> will override the <em>Size</em> parameter.</p><p>If <em>Options</em> is a list, this is simply equivalent to <em>new([{size, Size} | Options]</em>, otherwise it is equivalent to <em>new([{size, Size} | [Options]]</em>. However, using this function directly is more efficient.</p><p>Example:</p>
<pre>
     array:new(100, {default,0})
</pre>
<p>creates a fixed-size array of size 100, whose default value is 0.</p><p><em>See also:</em> <strong>new/1</strong>.</p>
<pre>
<strong></strong>
relax(Array :: array(Type)) -&gt; array(Type)

</pre>
<p>Make the array resizable. (Reverses the effects of <strong>fix/1</strong>.)</p><p><em>See also:</em> <strong>fix/1</strong>.</p>
<pre>
<strong></strong>
reset(I :: array_indx(), Array :: array(Type)) -&gt; array(Type)

</pre>
<p>Reset entry <em>I</em> to the default value for the array. If the value of entry <em>I</em> is the default value the array will be returned unchanged. Reset will never change size of the array. Shrinking can be done explicitly by calling <strong>resize/2</strong>.</p><p>If <em>I</em> is not a nonnegative integer, or if the array has fixed size and <em>I</em> is larger than the maximum index, the call fails with reason <em>badarg</em>; cf. <strong>set/3</strong></p><p><em>See also:</em> <strong>new/2</strong>, <strong>set/3</strong>.</p>
<pre>
<strong></strong>
resize(Array :: array(Type)) -&gt; array(Type)

</pre>
<p>Change the size of the array to that reported by <strong>sparse_size/1</strong>. If the given array has fixed size, the resulting array will also have fixed size.</p><p><em>See also:</em> <strong>resize/2</strong>, <strong>sparse_size/1</strong>.</p>
<pre>
<strong></strong>
resize(Size :: integer() &gt;= 0, Array :: array(Type)) -&gt;
<strong></strong>
          array(Type)

</pre>
<p>Change the size of the array. If <em>Size</em> is not a nonnegative integer, the call fails with reason <em>badarg</em>. If the given array has fixed size, the resulting array will also have fixed size.</p>
<pre>
<strong></strong>
set(I :: array_indx(), Value :: Type, Array :: array(Type)) -&gt;
<strong></strong>
       array(Type)

</pre>
<p>Set entry <em>I</em> of the array to <em>Value</em>. If <em>I</em> is not a nonnegative integer, or if the array has fixed size and <em>I</em> is larger than the maximum index, the call fails with reason <em>badarg</em>.</p><p>If the array does not have fixed size, and <em>I</em> is greater than <em>size(Array)-1</em>, the array will grow to size <em>I+1</em>.</p><p><em>See also:</em> <strong>get/2</strong>, <strong>reset/2</strong>.</p>
<pre>
<strong></strong>
size(Array :: array()) -&gt; integer() &gt;= 0

</pre>
<p>Get the number of entries in the array. Entries are numbered from 0 to <em>size(Array)-1</em>; hence, this is also the index of the first entry that is guaranteed to not have been previously set.</p><p><em>See also:</em> <strong>set/3</strong>, <strong>sparse_size/1</strong>.</p>
<pre>
<strong></strong>
sparse_foldl(Function, InitialAcc :: A, Array :: array(Type)) -&gt; B

</pre>
<p>Types:</p><p>Function =</p>
<pre>
    fun((Index :: <strong>array_indx()</strong>, Value :: Type, Acc :: A) -&gt; B)
</pre>
<p>Fold the elements of the array using the given function and initial accumulator value, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If <em>Function</em> is not a function, the call fails with reason <em>badarg</em>.</p><p><em>See also:</em> <strong>foldl/3</strong>, <strong>sparse_foldr/3</strong>.</p>
<pre>
<strong></strong>
sparse_foldr(Function, InitialAcc :: A, Array :: array(Type)) -&gt; B

</pre>
<p>Types:</p><p>Function =</p>
<pre>
    fun((Index :: <strong>array_indx()</strong>, Value :: Type, Acc :: A) -&gt; B)
</pre>
<p>Fold the elements of the array right-to-left using the given function and initial accumulator value, skipping default-valued entries. The elements are visited in order from the highest index to the lowest. If <em>Function</em> is not a function, the call fails with reason <em>badarg</em>.</p><p><em>See also:</em> <strong>foldr/3</strong>, <strong>sparse_foldl/3</strong>.</p>
<pre>
<strong></strong>
sparse_map(Function, Array :: array(Type1)) -&gt; array(Type2)

</pre>
<p>Types:</p><p>Function = fun((Index :: <strong>array_indx()</strong>, Type1) -&gt; Type2)</p><p>Map the given function onto each element of the array, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If <em>Function</em> is not a function, the call fails with reason <em>badarg</em>.</p><p><em>See also:</em> <strong>map/2</strong>.</p>
<pre>
<strong></strong>
sparse_size(Array :: array()) -&gt; integer() &gt;= 0

</pre>
<p>Get the number of entries in the array up until the last non-default valued entry. In other words, returns <em>I+1</em> if <em>I</em> is the last non-default valued entry in the array, or zero if no such entry exists.</p><p><em>See also:</em> <strong>resize/1</strong>, <strong>size/1</strong>.</p>
<pre>
<strong></strong>
sparse_to_list(Array :: array(Type)) -&gt; [Value :: Type]

</pre>
<p>Converts the array to a list, skipping default-valued entries.</p><p><em>See also:</em> <strong>to_list/1</strong>.</p>
<pre>
<strong></strong>
sparse_to_orddict(Array :: array(Type)) -&gt;
<strong></strong>
                     indx_pairs(Value :: Type)

</pre>
<p>Convert the array to an ordered list of pairs <em>{Index, Value}</em>, skipping default-valued entries.</p><p><em>See also:</em> <strong>to_orddict/1</strong>.</p>
<pre>
<strong></strong>
to_list(Array :: array(Type)) -&gt; [Value :: Type]

</pre>
<p>Converts the array to a list.</p><p><em>See also:</em> <strong>from_list/2</strong>, <strong>sparse_to_list/1</strong>.</p>
<pre>
<strong></strong>
to_orddict(Array :: array(Type)) -&gt; indx_pairs(Value :: Type)

</pre>
<p>Convert the array to an ordered list of pairs <em>{Index, Value}</em>.</p><p><em>See also:</em> <strong>from_orddict/2</strong>, <strong>sparse_to_orddict/1</strong>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="application.3erl.html"><span aria-hidden="true">&larr;</span> application.3erl: Generic otp application functions</a></li>
   <li class="next"><a href="asn1ct.3erl.html">asn1ct.3erl: Asn.1 compiler and compile-time support functions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

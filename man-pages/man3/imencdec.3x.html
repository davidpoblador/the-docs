<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>imencdec: Imencdec- encoding/decoding asimage data from/to usable data structures libafterimage/imencdec.h</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Imencdec- encoding/decoding asimage data from/to usable data structures libafterimage/imencdec.h">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="imencdec (3x) manual">
  <meta name="twitter:description" content="Imencdec- encoding/decoding asimage data from/to usable data structures libafterimage/imencdec.h">
  <meta name="twitter:image" content="https://www.carta.tech/images/libafterimage-dev-imencdec-3x.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3x/imencdec.3x.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="imencdec (3x) manual" />
  <meta property="og:description" content="Imencdec- encoding/decoding asimage data from/to usable data structures libafterimage/imencdec.h" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libafterimage-dev-imencdec-3x.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">imencdec<small> (3x)</small></h1>
        <p class="lead">Imencdec- encoding/decoding asimage data from/to usable data structures libafterimage/imencdec.h</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/imencdec.3x.html">
      <span itemprop="name">imencdec: Imencdec- encoding/decoding asimage data from/to usable data structures libafterimage/imencdec.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libafterimage-dev/">
      <span itemprop="name">libafterimage-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/imencdec.3x.html">
      <span itemprop="name">imencdec: Imencdec- encoding/decoding asimage data from/to usable data structures libafterimage/imencdec.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">NAMEimencdec</h2>
        <div class="sectioncontent">
<p>defines main structures and function for image storing, extraction and conversion to/from usable formats.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>this header defines structures and functions to be used by outside applications for reading and writing into ASImages. ASImage pixel data maybe stored in sevral different formats, and should not be accessed directly, but only through encoder/decoder facility.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO imencdec&hellip;</h2>
        <div class="sectioncontent">
<p>Structures :</p>
<pre>
         ASImageBevel
         ASImageDecoder
         ASImageOutput
</pre>
<p>Functions :</p>
<pre>
  Encoding :
         asimage_add_line(),    asimage_add_line_mono(),
         asimage_print_line(), get_asimage_chanmask(),
         move_asimage_channel(), copy_asimage_channel(),
         copy_asimage_lines()
</pre>

<pre>
  Decoding
         start_image_decoding(), stop_image_decoding(),
         asimage_decode_line (), set_decoder_shift(),
         set_decoder_back_color()
</pre>

<pre>
  Output :
         start_image_output(), set_image_output_back_color(),
         toggle_image_output_direction(), stop_image_output()
</pre>
<p>Other libAfterImage modules :</p>
<pre>
         ascmap.h asfont.h asimage.h asvisual.h blender.h export.h
         import.h transform.h ximage.h
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sasha Vasko &lt;sasha at aftercode dot net&gt; libAfterImage/ASImageBevel</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASImageBevel</h2>
        <div class="sectioncontent">
<p>describes bevel to be drawn around the image.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Bevel is used to create 3D effect while drawing buttons, or any other image that needs to be framed. Bevel is drawn using 2 primary colors: one for top and left sides - hi color, and another for bottom and right sides - low color. There are additionally 3 auxiliary colors: hihi is used for the edge of top-left corner, hilo is used for the edge of top-right and bottom-left corners, and lolo is used for the edge of bottom-right corner. Colors are specified as ARGB and contain alpha component, thus allowing for semitransparent bevels.</p><p>Bevel consists of outline and inline. Outline is drawn outside of the image boundaries and its size adds to image size as the result. Alpha component of the outline is constant. Inline is drawn on top of the image and its alpha component is fading towards the center of the image, thus creating illusion of smooth disappearing edge.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef struct ASImageBevel { #define BEVEL_SOLID_INLINE  (0x01&lt;&lt;0)</p>
<pre>
    ASFlagType type ;                /* reserved for future use */
</pre>

<pre>
    /* primary bevel colors */
    ARGB32  hi_color ;      /* top and left side color */
    ARGB32  lo_color ;      /* bottom and right side color */
</pre>

<pre>
    /* these will be placed in the corners */
    ARGB32  hihi_color ;    /* color of the top-left corner */
    ARGB32  hilo_color ;    /* color of the top-right and
                             * bottom-left corners */
    ARGB32  lolo_color ;    /* color of the bottom-right corner */
</pre>

<pre>
    /* outlines define size of the line drawn around the image */
    unsigned short left_outline ;
    unsigned short top_outline ;
    unsigned short right_outline ;
    unsigned short bottom_outline ;
    /* inlines define size of the semitransparent line drawn
     * inside the image */
    unsigned short left_inline ;
    unsigned short top_inline ;
    unsigned short right_inline ;
    unsigned short bottom_inline ;
</pre>
<p>}ASImageBevel;</p><p>libAfterImage/ASImageDecoder</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASImageDecoder</h2>
        <div class="sectioncontent">
<p>describes the status of reading any particular ASImage, as well as providing detail on how it should be done.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>ASImageDecoder works as an abstraction layer and as the way to automate several operations. Most of the transformations in libAfterImage are performed as operations on ASScanline data structure, that holds all or some of the channels of single image scanline. In order to automate data extraction from ASImage into ASScanline ASImageDecoder has been designed.</p><p>It has following features : 1) All missing scanlines, or channels of scanlines will be filled with supplied back_color 2) It is possible to leave out some channels of the image, extracting only subset of channels. It is done by setting only needed flags in filter member. 3) It is possible to extract sub-image of the image by setting offset_x and offset_y to top-left corner of sub-image, out_width - to width of the sub-image and calling decode_image_scanline method as many times as height of the sub-image. 4) It is possible to apply bevel to extracted sub-image, by setting bevel member to specific ASImageBevel structure.</p><p>Extracted Scanlines will be stored in buffer and it will be updated after each call to decode_image_scanline().</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>/* low level driver (what data to use - native, XImage or ARGB): */ typedef void (*decode_asscanline_func)( struct ASImageDecoder *imdec,</p>
<pre>
                                        unsigned int skip, int y );
</pre>
<p>/* high level driver (bevel or not bevel): */ typedef void (*decode_image_scanline_func)</p>
<pre>
                (struct ASImageDecoder *imdec);
</pre>
<p>typedef struct ASImageDecoder {</p>
<pre>
    struct ASVisual *asv;
    struct ASImage  *im ;
    ASFlagType      filter;      /* flags that mask set of
                                  * channels to be extracted
                                  * from the image */
</pre>

<pre>
    ARGB32          back_color;  /* we fill missing scanlines
                                  * with this default - black*/
    unsigned int    offset_x,    /* left margin on source image
                                  * before which we skip everything */
                    out_width;   /* actual length of the output
                                  * scanline */
    unsigned int    offset_y,    /* top margin */
                    out_height;
    ASImageBevel    *bevel;      /* bevel to wrap everything
                                  * around with */
</pre>

<pre>
    /* offsets of the drawn bevel baseline on resulting image : */
    int            bevel_left, bevel_top,
                    bevel_right, bevel_bottom ;
</pre>

<pre>
    /* scanline buffer containing current scanline */
    struct ASScanline buffer; /* matches the out_width */
</pre>

<pre>
    /* internal data : */
    unsigned short    bevel_h_addon, bevel_v_addon ;
    int               next_line ;
</pre>

<pre>
    struct ASScanline   *xim_buffer; /* matches the size of the
                               * original XImage */
</pre>

<pre>
    decode_asscanline_func     decode_asscanline ;
    decode_image_scanline_func decode_image_scanline ;
</pre>
<p>}ASImageDecoder;</p><p>libAfterImage/asimage/quality</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>Defines level of output quality/speed ratio</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASIMAGE_QUALITY_POOR</h2>
        <div class="sectioncontent">
<p>there will be no dithering and interpolation used while transforming ASIMAGE_QUALITY_FAST there will be no dithering and used while transforming but interpolation will be used. ASIMAGE_QUALITY_GOOD simplified dithering is performed in addition to interpolation. ASIMAGE_QUALITY_TOP full dithering and interpolation. ASIMAGE_QUALITY_DEFAULT requests current default setting - typically same as ASIMAGE_QUALITY_GOOD. MAX_GRADIENT_DITHER_LINES defines number of lines to use for dithering, while rendering gradients, in order to create smooth effect. Higher number will slow things down, but will create better gradients.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>#define ASIMAGE_QUALITY_POOR    0 #define ASIMAGE_QUALITY_FAST    1 #define ASIMAGE_QUALITY_GOOD    2 #define ASIMAGE_QUALITY_TOP     3 #define ASIMAGE_QUALITY_DEFAULT -1</p><p>#define MAX_GRADIENT_DITHER_LINES   ASIMAGE_QUALITY_TOP+1</p><p>libAfterImage/asimage/ASImageOutput</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASImageOutput</h2>
        <div class="sectioncontent">
<p>describes the output state of the transformation result. It is used to transparently write results into ASImage or XImage with different levels of quality.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>libAfterImage allows for transformation result to be stored in both ASImage ( useful for long term storage and subsequent processing ) and XImage ( useful for transfer of the result onto the X Server). At the same time there are 4 different quality levels of output implemented. They differ in the way special technics, like error diffusion and interpolation are applyed, and allow for fine grained selection of quality/speed ratio. ASIMAGE_QUALITY_GOOD should be good enough for most applications. The following additional output features are implemented : 1) Filling of the missing channels with supplied values. 2) Error diffusion to improve quality while converting from internal</p>
<pre>
      24.8 format to 8 bit format.
</pre>
<p>3) Tiling of the output. If tiling_step is greater then 0, then each</p>
<pre>
      scanlines will be copied into lines found tiling_step one from
      another, upto the edge of the image.
</pre>
<p>4) Reverse order of output. Output image will be mirrored along y</p>
<pre>
      axis if bottom_to_top is set to True.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>The output_image_scanline method should be called for each scanline to be stored. Convenience functions listed below should be used to safely alter state of the output instead of direct manipulation of the data members. (makes you pity you don't write in C++ doesn't it ?)</p><p>Also There is a trick in the way how output_image_scanline handles empty scanlines while writing ASImage. If back_color of empty scanline matches back_color of ASImageOutput - then particular line is erased! If back_colors are same - then particular line of ASImage gets filled with the back_color of ASScanline. First approach is useful when resulting image will be used in subsequent call to merge_layers - in such case knowing back_color of image is good enough and we don't need to store lines with the same color. In case where ASImage will be converted into Pixmap/XImage - second approach is preferable, since that conversion does not take into consideration image's back color - we may want to change it in the future.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO imencdec&hellip;</h2>
        <div class="sectioncontent">
<p>start_image_output() set_image_output_back_color() toggle_image_output_direction() stop_image_output()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef void (*encode_image_scanline_func)( struct ASImageOutput *imout,</p>
<pre>
                                            struct ASScanline *to_store );
</pre>
<p>typedef void (*output_image_scanline_func)( struct ASImageOutput *,</p>
<pre>
                                            struct ASScanline *, int );
</pre>
<p>typedef struct ASImageOutput {</p>
<pre>
    struct ASVisual         *asv;
    struct ASImage          *im ;
    ASAltImFormats   out_format ;
    CARD32           chan_fill[4];
    int              buffer_shift;  /* -1 means - buffer is empty,
                                     * 0 - no shift,
                                     * 8 - use 8 bit precision */
    int              next_line ;    /* next scanline to be written */
    unsigned int     tiling_step;   /* each line written will be
                                     * repeated with this step until
                                     * we exceed image size */
    unsigned int     tiling_range;  /* Limits region in which we need
                                     * to tile. If set to 0 then image
                                     * height is used */
    int              bottom_to_top; /* -1 if we should output in
                                     * bottom to top order,
                                     * +1 otherwise*/
</pre>

<pre>
    int              quality ;      /* see above */
</pre>

<pre>
    output_image_scanline_func
        output_image_scanline ;  /* high level interface - division,
                                  * error diffusion as well
                                  * as encoding */
    encode_image_scanline_func
        encode_image_scanline ;  /* low level interface -
                                  * encoding only */
</pre>

<pre>
    /* internal data members : */
    struct ASScanline        buffer[2], *used, *available;
</pre>
<p>}ASImageOutput;</p><p>libAfterImage/asimage/start_image_decoding()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEstart_image_decoding()</h2>
        <div class="sectioncontent">
<p>- allocates and initializes decoder structure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImageDecoder *start_image_decoding( ASVisual *asv,ASImage *im,</p>
<pre>
                                      ASFlagType filter,
                                      int offset_x, int offset_y,
                                      unsigned int out_width,
                                      unsigned int out_height,
                                      ASImageBevel *bevel );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure ( needed mostly to see if we are in BGR mode or not );</p>
  </dd>
  <dt>
    im
  </dt>
  <dd>
    <p>- ASImage we are going to decode;</p>
  </dd>
  <dt>
    filter
  </dt>
  <dd>
    <p>- bitmask where set bits mark channels that has to be decoded.</p>
  </dd>
  <dt>
    offset_x
  </dt>
  <dd>
    <p>- left margin inside im, from which we should start reading pixel data, effectively clipping source image.</p>
  </dd>
  <dt>
    offset_y
  </dt>
  <dd>
    <p>- top margin inside im, from which we should start reading scanlines, effectively clipping source image. Note that when edge of the image is reached, subsequent requests for scanlines will wrap around to the top of the image, and not offset_y.</p>
  </dd>
  <dt>
    out_width-
  </dt>
  <dd>
    <p>width of the scanline needed. If it is larger then source image - then image data will be tiled in it. If it is smaller - then image data will be clipped.</p>
  </dd>
  <dt>
    out_height
  </dt>
  <dd>
    <p>- height of the output drawable. -1 means that same as image height. if out_height is greater then image height, then image will be tiled.</p>
  </dd>
  <dt>
    bevel
  </dt>
  <dd>
    <p>- NULL or pointer to valid ASImageBevel structure if decoded data should be overlayed with bevel at the time of decoding.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>start_image_decoding() returns pointer to newly allocated ASImageDecoder structure on success, NULL on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Normal process of reading image data from ASImage consists of 3 steps : 1) start decoding by calling start_image_decoding. 2) call decode_image_scanline() method of returned structure, for each scanline upto desired height of the target image. Decoded data will be returned in buffer member of the ASImageDecoder structure. 3) finish decoding and deallocated all the used memory by calling stop_image_decoding() libAfterImage/asimage/set_decoder_bevel_geom()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEset_decoder_bevel_geom()</h2>
        <div class="sectioncontent">
<p>- changes default placement of the bevel on decoded image.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void set_decoder_bevel_geom( ASImageDecoder *imdec, int x, int y,</p>
<pre>
                             unsigned int width, unsigned int height );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    imdec
  </dt>
  <dd>
    <p>- pointer to pointer to structure, previously created by start_image_decoding.</p>
  </dd>
  <dt>
    x,y
  </dt>
  <dd>
    <p>- left top position of the inner border of the Bevel outline as related to the origin of subimage being decoded.</p>
  </dd>
  <dt>
    width,
  </dt>
  <dd>
    
  </dd>
  <dt>
    height
  </dt>
  <dd>
    <p>- widtha and height of the inner border of the bevel outline.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>For example if you only need to render small part of the button, that is being rendered from transparency image. NOTE This call modifies bevel_h_addon and bevel_v_addon of ASImageDecoder structure. libAfterImage/asimage/set_decoder_shift()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEset_decoder_shift()</h2>
        <div class="sectioncontent">
<p>- changes the shift value of decoder - 8 or 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void set_decoder_shift( ASImageDecoder *imdec, int shift );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    imdec
  </dt>
  <dd>
    <p>- pointer to pointer to structure, previously created by start_image_decoding.</p>
  </dd>
  <dt>
    shift
  </dt>
  <dd>
    <p>- new value to be used as the shift while decoding image. valid values are 8 and 0.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This function should be used instead of directly modifyeing value of shift memebr of ASImageDecoder structure. libAfterImage/asimage/set_decoder_back_color()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEset_decoder_back_color()</h2>
        <div class="sectioncontent">
<p>- changes the back color to be used while decoding the image.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void set_decoder_back_color( ASImageDecoder *imdec, ARGB32 back_color );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    imdec
  </dt>
  <dd>
    <p>- pointer to pointer to structure, previously created by start_image_decoding.</p>
  </dd>
  <dt>
    back_color
  </dt>
  <dd>
    <p>- ARGB32 color value to be used as the background color to fill empty spaces in decoded ASImage.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This function should be used instead of directly modifyeing value of back_color memebr of ASImageDecoder structure. libAfterImage/asimage/stop_image_decoding()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEstop_image_decoding()</h2>
        <div class="sectioncontent">
<p>- finishes decoding, frees all allocated memory.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void stop_image_decoding( ASImageDecoder **pimdec );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    pimdec
  </dt>
  <dd>
    <p>- pointer to pointer to structure, previously created by start_image_decoding.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>pimdec  - pointer to ASImageDecoder will be reset to NULL.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO imencdec&hellip;</h2>
        <div class="sectioncontent">
<p>start_image_decoding() libAfterImage/asimage/start_image_output()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEstart_image_output()</h2>
        <div class="sectioncontent">
<p>- initializes output structure</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImageOutput *start_image_output ( struct ASVisual *asv,</p>
<pre>
                                    ASImage *im,
                                    ASAltImFormats format,
                                    int shift, int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    im
  </dt>
  <dd>
    <p>- destination ASImage</p>
  </dd>
  <dt>
    format
  </dt>
  <dd>
    <p>- indicates that output should be written into alternative format, such as supplied XImage, ARGB32 array etc.</p>
  </dd>
  <dt>
    shift
  </dt>
  <dd>
    <p>- precision of scanline data. Supported values are 0 - no precision, and 8 - 24.8 precision. Value of that argument defines by how much scanline data is shifted rightwards.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- what algorithms should be used while writing data out, i.e. full error diffusion, fast error diffusion, no error diffusion.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>start_image_output() creates and initializes new ASImageOutput structure based on supplied parameters. Created structure can be subsequently used to write scanlines into destination image. It is effectively hiding differences of XImage and ASImage and other available output formats. outpt_image_scanline() method of the structure can be used to write out single scanline. Each written scanlines moves internal pointer to the next image line, and possibly writes several scanlines at once if tiling_step member is not 0. libAfterImage/asimage/set_image_output_back_color()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEset_image_output_back_color()</h2>
        <div class="sectioncontent">
<p>- changes background color of output</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void set_image_output_back_color ( ASImageOutput *imout,</p>
<pre>
                                   ARGB32 back_color );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    imout
  </dt>
  <dd>
    <p>- ASImageOutput structure, previously created with start_image_output();</p>
  </dd>
  <dt>
    back_color
  </dt>
  <dd>
    <p>- new background color value in ARGB format. This color will be used to fill empty parts of outgoing scanlines. libAfterImage/asimage/toggle_image_output_direction()</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEtoggle_image_output_direction()</h2>
        <div class="sectioncontent">
<p>- reverses vertical direction of output</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void toggle_image_output_direction( ASImageOutput *imout );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    imout
  </dt>
  <dd>
    <p>- ASImageOutput structure, previously created with start_image_output();</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>reverses vertical direction output. If previously scanlines has been written from top to bottom, for example, after this function is called they will be written in opposite direction. Current line does not change, unless it points to the very first or the very last image line. In this last case it will be moved to the opposing end of the image. libAfterImage/asimage/stop_image_output()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEstop_image_output()</h2>
        <div class="sectioncontent">
<p>- finishes output, frees all the allocated memory.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void stop_image_output( ASImageOutput **pimout );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    pimout
  </dt>
  <dd>
    <p>- pointer to pointer to ASImageOutput structure, previously created with call to start_image_output().</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>pimout      - pointer to ASImageOutput will be reset to NULL.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Completes image output process. Flushes all the internal buffers. Deallocates all the allocated memory. Resets pointer to NULL to avoid dereferencing invalid pointers.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="export.3x.html"><span aria-hidden="true">&larr;</span> export.3x: Export- functionality for writing images into files libafterimage/export.h</a></li>
   <li class="next"><a href="import.3x.html">import.3x: Import- functionality for reading images from files libafterimage/import.h <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

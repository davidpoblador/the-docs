<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Courier::Filter::Overview: Architectural and administrative overview of courier::filter</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Architectural and administrative overview of courier::filter">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Courier::Filter::Overview (3pm) manual">
  <meta name="twitter:description" content="Architectural and administrative overview of courier::filter">
  <meta name="twitter:image" content="https://www.carta.tech/images/courier-filter-perl-Courier::Filter::Overview-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Courier::Filter::Overview.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Courier::Filter::Overview (3pm) manual" />
  <meta property="og:description" content="Architectural and administrative overview of courier::filter" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/courier-filter-perl-Courier::Filter::Overview-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Courier::Filter::Overview<small> (3pm)</small></h1>
        <p class="lead">Architectural and administrative overview of courier::filter</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Courier::Filter::Overview.3pm.html">
      <span itemprop="name">Courier::Filter::Overview: Architectural and administrative overview of courier::filter</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/courier-filter-perl/">
      <span itemprop="name">courier-filter-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Courier::Filter::Overview.3pm.html">
      <span itemprop="name">Courier::Filter::Overview: Architectural and administrative overview of courier::filter</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Courier::Filter is a purely Perl-based mail filter framework for the Courier \s-1MTA\s0.</p><h3>The Courier \s-1MTA\s0's \fBcourierfilter\fP interface</h3>
<p>Courier offers an interface for daemon-style processes to act as mail filters, called <strong>courierfilter</strong>s.  For every incoming mail message, right after the \s-1DATA\s0 command in the \s-1SMTP\s0 transaction phase has completed, Courier calls every registered mail filter through a \s-1UNIX\s0 domain socket the filter is listening on, and feeds it the file names of the incoming message and one or more control files.  The mail filter processes the message and its control file(s), and returns an SMTP-style status response.  If the status response is a positive (\*(L"2xx\*(R") one, Courier accepts the message.  Otherwise, Courier rejects the message using the returned response code and text.  For details about the courierfilter interface, see courierfilter.</p>
<h3>About \fBCourier::Filter\fP</h3>
<p>Courier::Filter implements the courierfilter interface as a framework for mail filter modules that frees modules from the duties of creating and handling the \s-1UNIX\s0 domain sockets, waiting for connections from Courier, and reading and parsing message and control files.  Thus, authors of filter modules can concentrate on writing the actual filter logic without having to care about things that can easily be abstracted and can be performed by the framework.</p><p>Courier::Filter allows multiple filter modules to be installed, and filter modules can be stacked and grouped hierarchically, and even a module's polarity can be reversed, so some modules can be used for explicitly <em>accepting</em> messages while others are used in the traditional way for <em>rejecting</em> messages.</p>
<h3>Courier::Filter compared to other courierfilter implementations</h3>
<p>There are some alternative implementations of the courierfilter interface:</p>
<dl class='dl-vertical'>
  <dt>
    <em>Writing your own standalone courierfilter</em>
  </dt>
  <dd>
    <p>If you need an ultra-high performance mail filter, writing a standalone courierfilter in C/\*(C+ is a good choice.  You will have maximum freedom for optimizing your filter for performance and resource consumption.  But regardless of which language you use, you will have to implement all the \s-1UNIX\s0 domain socket and connection handling and message and control file processing yourself.  And you don't get the modularity and module grouping capabilities for free either.</p>
  </dd>
  <dt>
    <em>courierperlfilter</em>
  </dt>
  <dd>
    <p>Courier brings a sample Perl-based courierfilter called <strong>courierperlfilter</strong>. It is a C executable that employs Perl embedding (see perlembed) to execute a Perl script for every incoming message, which is about as performant as the purely Perl-based Courier::Filter.  But for every Perl-based courierfilter you want to run, you have to use a separate instance of courierperlfilter, or implement your own modularity and module grouping.  Also, the included template Perl script is not very modular in itself, and Courier::Filter's message and control file parsing features are missing.</p>
  </dd>
  <dt>
    <em>pythonfilter</em>
  </dt>
  <dd>
    <p><strong>pythonfilter</strong> by Gordon Messmer is a purely Python-based, modular, threaded courierfilter framework, similar to Courier::Filter.  If you primarily speak Python, this is clearly your choice.  pythonfilter also provides infrastructure to filter modules for modifying messages, even with versions of Courier prior to 0.57.1, which did not directly allow global mail filters to modify messages. As of version 1.1, pythonfilter supports only a linear topology in the configuration of its filter modules.</p>
  </dd>

</dl>

<h3>Using Courier::Filter</h3>
<p>First, Courier::Filter (of course) and the filter modules that you plan to use for filtering your incoming mail need to be installed somewhere in your Perl include path (see the last lines of `perl -V`).  You may also need to adjust the <strong>Courier::Config</strong> class (in \*(C`Courier/Config.pm\*(C') to reflect your system's paths.  As for the filter modules, you can either use prepared ones (see \*(L"Bundled Courier::Filter modules\*(R" for a list of modules that come with Courier::Filter), or you can write your own (see \*(L"How filter modules work\*(R").</p><p>Second, you need to create a configuration file for Courier::Filter. Courier::Filter usually seeks for it at \*(C`/etc/courier/filters/courier-filter-perl.conf\*(C' (see Courier::Config on how to configure that).  This file is a Perl snippet that must \*(C`use\*(C' the filter modules you want to use, and then fill in the $options global variable with the desired configuration options, instantiating filter modules and loggers as required.</p><p>If you plan to use non-ASCII string literals in your configuration file, it should be encoded in \s-1UTF-8\s0 (which is the native internal character encoding of Perl 5.8+ and Courier::Filter), and if it is, it <em>must</em> do \*(C`use utf8\*(C'.  (It is possible for the configuration file to be encoded differently, but you still <em>must</em> explicitly specify the used encoding, see encoding for how to do that.)</p><p>For example, this is how a simple configuration file could look like:</p>
<pre>
    use utf8;

    use Courier::Filter::Logger::File;
    use Courier::Filter::Module::Header;

    $options = {
        logger      =&gt; Courier::Filter::Logger::File-&gt;new(
            file_name   =&gt; &apos;/var/log/courier-filter-perl.log&apos;,
            timestamp   =&gt; 1
        },

        modules     =&gt; [
            Courier::Filter::Module::Header-&gt;new(
                fields      =&gt; {
                    subject     =&gt; qr/fuzzybuzzy/
                },
                response    =&gt; &apos;No fuzzybuzzy, please!&apos;
            )
        ]
    };
</pre>
<p>These options will be used when creating the \*(C`Courier::Filter\*(C' object.  For a detailed explanation of supported configuration options and how filter modules can be grouped, even hierarchically, see \*(L"<em>new()</em>\*(R" in Courier::Filter.</p><p>Third, you need to make Courier aware of Courier::Filter by installing a symlink in \*(C`/etc/courier/filters/active/\*(C' pointing to the \*(C`courier-filter-perl\*(C' executable (which is used for bootstrapping Courier::Filter):</p><p>    $ ln -s $PATH_TO/courier-filter-perl /etc/courier/filters/active/</p><p>Finally, you may start (or restart) Courier::Filter (including any other installed courierfilters; Courier must of course already be running):</p><p>    $ sudo courierfilter restart</p><p>In syslog, you should see the following message and no further error messages:</p><p>    Jan 24 01:42:15 yourhost courierfilter: Starting courier-filter-perl</p><p>Any errors occurring while Courier::Filter is running will appear in syslog as well.  A broken filter module will not crash Courier::Filter, but will record any Perl error messages in syslog, and <em>reject</em> incoming mail messages with a <em>temporary</em> status code, so as not to enable attackers to circumvent the configured Courier::Filter mail filtering.</p>
<h3>How filter modules work</h3>
<p>Filter modules are Perl classes that are derived from the class <strong>Courier::Filter::Module</strong>.  See perlobj for an explanation of Perl's object orientation features.</p><p>Filter modules are to be instantiated in the \*(C`courier-filter-perl.conf\*(C' configuration file, with either <strong>normal polarity</strong> (the default) or <strong>inverse</strong> polarity.  Then, for every incoming mail message, Courier::Filter asks each configured filter module in turn for consideration of the message's acceptability.</p><p>Every module tries to match its filter criteria against the current message, yielding a so-called <em>match result</em>, which can be either an <strong>explicit match</strong>, an <strong>implicit mismatch</strong>, or an <strong>explicit mismatch</strong>.  (Filter modules usually never return an <em>explicit</em> mismatch, but only an <em>implicit</em> one; see \*(L"Writing filter modules\*(R" if you want to know why.)</p><p>According to the filter module's polarity, the match result is then translated into a so-called <em>acceptability result</em>, which can be either an <strong>explicit</strong> reject, an <strong>implicit accept</strong>, or an <strong>explicit accept</strong>.</p><p>This is how <em>match results</em> are translated into <em>acceptability results</em> under normal and inverse polarity:</p><p>     polarity | match result      | acceptability result     ----------+-------------------+----------------------               | explicit match    | explicit reject      normal   | implicit mismatch | implicit accept               | explicit mismatch | explicit accept     ----------+-------------------+----------------------               | explicit match    | explicit accept      inverse  | implicit mismatch | implicit accept               | explicit mismatch | explicit reject</p><p>Generally, Courier::Filter interprets the acceptability result as follows:</p><ul>
<li><p>If a module states an <strong>explicit reject</strong> for the current message, Courier::Filter aborts the consideration process and rejects the message.</p></li><li><p>If a module states an <strong>implicit accept</strong>, Courier::Filter continues the consideration process with the next module in turn.</p></li><li><p>If a module states an <strong>explicit accept</strong>, Courier::Filter skips the rest of the group of modules and assumes the whole group to be an <strong>implicit accept</strong>.</p></li>
</ul><p>If no <strong>explicit reject</strong> has occured when Courier::Filter finishes asking all filter modules, the message is accepted.</p><p>(For details on how to use advanced <em>filter module grouping</em>, see the description of the \*(C`modules\*(C' option in \*(L"<em>new()</em>\*(R" in Courier::Filter.)</p><p>Abstracting the concept of a \*(L"match\*(R" from the concept of \*(L"acceptance\*(R" makes it possible to use filter modules with normal polarity for \*(L"black-listing\*(R" certain message characteristics, and filter modules with inverse polarity for \*(L"white-listing\*(R", while still allowing all modules to be written in a uniform sense of logic.  That is, there are no dedicated \*(L"accepting\*(R" and \*(L"rejecting\*(R" modules, but only \*(L"matching\*(R" modules.  (E.g. there are no \*(L"HeaderAccept\*(R" and \*(L"HeaderReject\*(R" modules, but only a \*(L"Header\*(R" module.)</p>
<h3>Writing filter modules</h3>
<p>The main objective of Courier::Filter is to make it very easy to write new filter modules, so while the previous section described how filter modules work in general, we will now look at the details of writing your own filter modules. From here on you really should know what you are doing, so if you are not familiar with Perl's object orientation features, now is the time to read perlobj plus any documents referenced from there.</p><p>As already mentioned, filter modules are Perl classes derived from the class <strong>Courier::Filter::Module</strong>, which is an abstract base class and thus cannot be instantiated itself.</p><p>To ask a filter module for consideration of the message, Courier::Filter calls \*(C`$module-&gt;consider()\*(C', passing a <strong>Courier::Message</strong> object. \*(C`$module-&gt;consider()\*(C' (if not overrided from <strong>Courier::Filter::Module</strong>) then calls \*(C`$module-&gt;match()\*(C', passing through the message object.</p><p>The \*(C`match()\*(C' method really is where a filter module decides whether a message matches the filter criteria, and this is usually the only method of <strong>Courier::Filter::Module</strong> that needs to be overrided.  That method may use any configuration information from the filter module object (see Courier::Filter::Module, and of course your own class), and any information from the message object (see Courier::Message).</p><p>If a filter module wants to call external commands using \*(C`system()\*(C', or functions from Perl modules that directly operate on files, it can efficiently bypass the message and control files processing features of Courier::Message by using the message object's \*(C`control_file_names\*(C' and \*(C`file_name\*(C' properties only.</p><p>Finally, after the message has been examined, \*(C`match()\*(C' must return a <em>match</em> result of...</p>
<dl class='dl-vertical'>
  <dt>
    <strong>true</strong>
  </dt>
  <dd>
    <p>if the module wants to state an <strong>explicit match</strong> (the first return value being the \s-1SMTP\s0 status response <em>text</em>, an optional second one being the \s-1SMTP\s0 status response <em>code</em>),</p>
  </dd>
  <dt>
    <strong>undef</strong>
  </dt>
  <dd>
    <p>if the module wants to state an <strong>implicit mismatch</strong>, that is, indifference of whether the message should be accepted or rejected,</p>
  </dd>
  <dt>
    <strong>false</strong>
  </dt>
  <dd>
    <p>if the module wants to state an <strong>explicit mismatch</strong>.</p>
  </dd>

</dl>
<p>\*(C`consider()\*(C' then translates the <em>match result</em> into a <em>acceptability</em> result as described in \*(L"How filter modules work\*(R".</p><p>\*(C`match()\*(C' should usually never return an <em>explicit</em> mismatch (<strong>false</strong>), but an <em>implicit</em> one (<strong>undef</strong>) instead for the message to pass <em>this filter</em> module, while still allowing any further modules to <em>explicitly</em> reject (under normal polarity) or accept (under inverse polarity) the message.  See the description of the \*(C`modules\*(C' option in \*(L"<em>new()</em>\*(R" in Courier::Filter for specifics on how Courier::Filter uses acceptability results.</p>
<h3>A sample HeaderSimple filter module</h3>
<p>Now let's see in practice how to write a simple filter module.  For instance, we will create a simple variant of the \*(C`Header\*(C' module that matches a specified message header field against a specified string.  Let's call it \*(C`HeaderSimple\*(C'.</p><p>First, we create a Perl module for the class <strong>Courier::Filter::Module::HeaderSimple</strong>, with the file name \*(C`Courier/Filter/Module/HeaderSimple.pm\*(C'.  (That is, you need to install the file \*(C`HeaderSimple.pm\*(C' in the proper place in your Perl include path.)</p><p>Second, in that Perl module, we state the package/class name, and the name of the base class, which is usually <strong>Courier::Filter::Module</strong>:</p><p>    package Courier::Filter::Module::HeaderSimple;     use base qw(Courier::Filter::Module);</p><p>Third, we override the \*(C`match()\*(C' method by defining a rudimentary \*(C`match\*(C' sub:</p><p>    sub match {         my ($self, $message) = @_;</p><p>        # ...     }</p><p>The first argument of the \*(C`match()\*(C' method is (as usual in Perl's object orientation model) the module object itself, which provides access to its configuration options.  The second argument is the message object that is to be examined.  The ellipsis (\*(L"...\*(R") is where we will place our own filter logic.</p><p>Now, we expect our module to be instantiated like this:</p><p>    Courier::Filter::Module::HeaderSimple-&gt;new(         field       =&gt; &apos;subject&apos;,         value       =&gt; &apos;viagra&apos;,         response    =&gt; &apos;Go away, spammer!&apos;     )</p><p>which makes the configuration options available from the hash keys \*(C`$self-&gt;{field}\*(C', \*(C`$self-&gt;{value}\*(C', and \*(C`$self-&gt;{response}\*(C'.</p><p>We want to test whether the configured header field of the message matches the configured value, and if so, return the configured response, so we write:</p><p>    return $self-&gt;{response}         if $message-&gt;header($self-&gt;{field}) =~ m/&#92;Q$self-&gt;{value}&#92;E/;     return undef;         # otherwise.</p><p>That's it.  This is how the complete filter module looks like:</p><p>    package Courier::Filter::Module::HeaderSimple;     use base qw(Courier::Filter::Module);</p><p>    sub match {         my ($self, $message) = @_;</p><p>        return $self-&gt;{response}             if $message-&gt;header($self-&gt;{field}) =~ m/&#92;Q$self-&gt;{value}&#92;E/;         return undef;             # otherwise.     }</p>
<h3>Testing Courier::Filter modules</h3>
<p>You may dry-test filter modules using the \*(C`test-filter-module\*(C' utility.  See its manpage for details.</p><p>You may also switch any or all installed filter modules into \*(L"testing\*(R" mode so you can test them without risking messages being actually rejected.  See \*(L"<em>new()</em>\*(R" in Courier::Filter and \*(L"<em>new()</em>\*(R" in Courier::Filter::Module.</p>
<h3>Bundled Courier::Filter modules</h3>
<p>The following prepared filter modules are included with this version of Courier::Filter:</p>
<dl class='dl-vertical'>
  <dt>
    <em>BlankBody</em>
  </dt>
  <dd>
    <p>Detection of messages with blank bodies (symptom of stupid spammers)</p>
  </dd>
  <dt>
    <em>\s-1DNSBL\s0</em>
  </dt>
  <dd>
    <p>Checking of the calling \s-1MTA\s0's \s-1IP\s0 address against one or more \s-1DNS\s0 black-lists</p>
  </dd>
  <dt>
    <em>\s-1SPF\s0</em>
  </dt>
  <dd>
    <p>\s-1SPF\s0 (Sender Policy Framework) authorization checking of the calling \s-1MTA\s0's \s-1IP\s0 address against the envelope sender domain (classic inbound \s-1SPF\s0 checking)</p>
  </dd>
  <dt>
    <em>SPFout</em>
  </dt>
  <dd>
    <p>\s-1SPF\s0 authorization checking of the local system's \s-1IP\s0 address against the envelope sender domain (so-called outbound \s-1SPF\s0 checking)</p>
  </dd>
  <dt>
    <em>Envelope</em>
  </dt>
  <dd>
    <p>Literal and reg-exp matching of one or more \s-1RFC\s0 2821 message envelope fields</p>
  </dd>
  <dt>
    <em>Header</em>
  </dt>
  <dd>
    <p>Literal and reg-exp matching of one or more \s-1RFC\s0 2822 message header fields</p>
  </dd>
  <dt>
    <em>FakeDate</em>
  </dt>
  <dd>
    <p>Detection of implausible and malformed \*(L"Date\*(R" and \*(L"Resent-Date\*(R" header fields</p>
  </dd>
  <dt>
    <em>ClamAVd</em>
  </dt>
  <dd>
    <p>Malware detection using the ClamAV anti-virus scanner</p>
  </dd>
  <dt>
    <em>SpamAssassin</em>
  </dt>
  <dd>
    <p>Spam detection using SpamAssassin</p>
  </dd>
  <dt>
    <em>Parts</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>MIMEParts</em> (\s-1DEPRECATED\s0)
  </dt>
  <dd>
    <p>Size and \s-1MD5\s0 sum matching of message (\s-1MIME\s0 multipart and \s-1ZIP\s0 archive) parts</p>
  </dd>
  <dt>
    <em>SendCopy</em>
  </dt>
  <dd>
    <p>Pseudo-filter for sending message copies to additional recipients</p>
  </dd>

</dl>

<h3>Bundled Courier::Filter loggers</h3>
<p>The following prepared loggers are included with this version of Courier::Filter:</p>
<dl class='dl-vertical'>
  <dt>
    <em>IOHandle</em>
  </dt>
  <dd>
    <p>Logging to I/O handles</p>
  </dd>
  <dt>
    <em>Syslog</em>
  </dt>
  <dd>
    <p>Logging to syslog (based on the <strong>IOHandle</strong> logger)</p>
  </dd>
  <dt>
    <em>File</em>
  </dt>
  <dd>
    <p>Logging to files (based on the <strong>IOHandle</strong> logger)</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Courier::Filter::Overview&hellip;</h2>
        <div class="sectioncontent">
<p>courier-filter-perl, test-filter-module, Courier::Filter, Courier::Filter::Module, Courier::Message, Courier::Config</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REFERENCES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    The <strong>courierfilter</strong> interface
  </dt>
  <dd>
    <p>http://www.courier-mta.org/courierfilter.html &lt;http://www.courier-mta.org/courierfilter.html&gt;</p>
  </dd>
  <dt>
    <strong>courierperlfilter</strong>
  </dt>
  <dd>
    <p>http://www.courier-mta.org/courierperlfilter.html &lt;http://www.courier-mta.org/courierperlfilter.html&gt;</p>
  </dd>
  <dt>
    <strong>pythonfilter</strong>
  </dt>
  <dd>
    <p>http://phantom.dragonsdawn.net/~gordon/courier-patches/courier-pythonfilter/ &lt;http://phantom.dragonsdawn.net/~gordon/courier-patches/courier-pythonfilter/&gt;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AVAILABILITY and SUPPORT</h2>
        <div class="sectioncontent">
<p>The latest version of Courier::Filter is available on \s-1CPAN\s0 and at http://www.mehnle.net/software/courier-filter &lt;http://www.mehnle.net/software/courier-filter&gt;.</p><p>Support is usually (but not guaranteed to be) given by the author, Julian Mehnle &lt;julian@mehnle.net&gt;, preferably through the Courier \s-1MTA\s0's courier-users mailing list &lt;courier-users@lists.sourceforge.net&gt;, which is subscribable through http://lists.sourceforge.net/lists/listinfo/courier-users &lt;http://lists.sourceforge.net/lists/listinfo/courier-users&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR and LICENSE</h2>
        <div class="sectioncontent">
<p>Courier::Filter is Copyright (C) 2003-2008 Julian Mehnle &lt;julian@mehnle.net&gt;. All rights reserved.</p><p>Courier::Filter is free software.  You may use, modify, and distribute it under the same terms as Perl itself, i.e. under the \s-1GNU\s0 \s-1GPL\s0 or the Artistic License.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Courier::Filter::Module::SpamAssassin.3pm.html"><span aria-hidden="true">&larr;</span> Courier::Filter::Module::SpamAssassin.3pm: Spamassassin message filter module for the courier::filter framework</a></li>
   <li class="next"><a href="Courier::Filter::Util.3pm.html">Courier::Filter::Util.3pm: Utility class used by the courier::filter framework <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

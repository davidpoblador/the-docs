<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CGI::Ajax: A perl-specific system for writing asynchronous web applications</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A perl-specific system for writing asynchronous web applications">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="CGI::Ajax (3pm) manual">
  <meta name="twitter:description" content="A perl-specific system for writing asynchronous web applications">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcgi-ajax-perl-CGI::Ajax-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/CGI::Ajax.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="CGI::Ajax (3pm) manual" />
  <meta property="og:description" content="A perl-specific system for writing asynchronous web applications" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcgi-ajax-perl-CGI::Ajax-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">CGI::Ajax<small> (3pm)</small></h1>
        <p class="lead">A perl-specific system for writing asynchronous web applications</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/CGI::Ajax.3pm.html">
      <span itemprop="name">CGI::Ajax: A perl-specific system for writing asynchronous web applications</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcgi-ajax-perl/">
      <span itemprop="name">libcgi-ajax-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/CGI::Ajax.3pm.html">
      <span itemprop="name">CGI::Ajax: A perl-specific system for writing asynchronous web applications</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use strict;
  use CGI;      # or any other CGI:: form handler/decoder
  use CGI::Ajax;

  my $cgi = new CGI;
  my $pjx = new CGI::Ajax( &apos;exported_func&apos; =&gt; &#92;&perl_func );
  print $pjx-&gt;build_html( $cgi, &#92;&Show_HTML);

  sub perl_func {
    my $input = shift;
    # do something with $input
    my $output = $input . " was the input!";
    return( $output );
  }

  sub Show_HTML {
    my $html = &lt;&lt;EOHTML;
    &lt;HTML&gt;
    &lt;BODY&gt;
      Enter something:
        &lt;input type="text" name="val1" id="val1"
         onkeyup="exported_func( [&apos;val1&apos;], [&apos;resultdiv&apos;] );"&gt;
      &lt;br&gt;
      &lt;div id="resultdiv"&gt;&lt;/div&gt;
    &lt;/BODY&gt;
    &lt;/HTML&gt;
  EOHTML
    return $html;
  }
</pre>
<p>When you use CGI::Ajax within Applications that send their own header information, you can skip the header:</p><p>  my $pjx = new CGI::Ajax(     &apos;exported_func&apos; =&gt; &#92;&perl_func,     &apos;skip_header&apos;   =&gt; 1,   );   $pjx-&gt;<strong>skip_header</strong>(1);</p><p>  print $pjx-&gt;build_html( $cgi, &#92;&Show_HTML);</p><p><em>There are several fully-functional examples in the 'scripts/'</em> directory of the distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>CGI::Ajax is an object-oriented module that provides a unique mechanism for using perl code asynchronously from javascript- enhanced \s-1HTML\s0 pages.  CGI::Ajax unburdens the user from having to write extensive javascript, except for associating an exported method with a document-defined event (such as onClick, onKeyUp, etc).  CGI::Ajax also mixes well with \s-1HTML\s0 containing more complex javascript.</p><p>CGI::Ajax supports methods that return single results or multiple results to the web page, and supports returning values to multiple \s-1DIV\s0 elements on the \s-1HTML\s0 page.</p><p>Using CGI::Ajax, the \s-1URL\s0 for the \s-1HTTP\s0 \s-1GET/POST\s0 request is automatically generated based on \s-1HTML\s0 layout and events, and the page is then dynamically updated with the output from the perl function.  Additionally, CGI::Ajax supports mapping \s-1URL\s0's to a CGI::Ajax function name, so you can separate your code processing over multiple scripts.</p><p>Other than using the Class::Accessor module to generate CGI::Ajax' accessor methods, CGI::Ajax is completely self-contained - it does not require you to install a larger package or a full Content Management System, etc.</p><p>We have added <em>support</em> for other \s-1CGI\s0 handler/decoder modules, like CGI::Simple or CGI::Minimal, but we can't test these since we run mod_perl2 only here.  CGI::Ajax checks to see if a <em>header()</em> method is available to the \s-1CGI\s0 object, and then uses it. If <em>method()</em> isn't available, it creates it's own minimal header.</p><p>A primary goal of CGI::Ajax is to keep the module streamlined and maximally flexible.  We are trying to keep the generated javascript code to a minimum, but still provide users with a variety of methods for deploying CGI::Ajax. And \s-1VERY\s0 little user javascript.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>The CGI::Ajax module allows a Perl subroutine to be called asynchronously, when triggered from a javascript event on the \s-1HTML\s0 page.  To do this, the subroutine must be <em>registered</em>, usually done during:</p><p>  my $pjx = new CGI::Ajax( &apos;JSFUNC&apos; =&gt; &#92;&PERLFUNC );</p><p>This maps a perl subroutine (\s-1PERLFUNC\s0) to an automatically generated Javascript function (\s-1JSFUNC\s0).  Next you setup a trigger this function when an event occurs (e.g. \*(L"onClick\*(R"):</p><p>  onClick="JSFUNC([&apos;source1&apos;,&apos;source2&apos;], [&apos;dest1&apos;,&apos;dest2&apos;]);"</p><p>where 'source1', 'dest1', 'source2', 'dest2' are the \s-1DIV\s0 ids of \s-1HTML\s0 elements in your page...</p><p>  &lt;input type=text id=source1&gt;   &lt;input type=text id=source2&gt;   &lt;div id=dest1&gt;&lt;/div&gt;   &lt;div id=dest2&gt;&lt;/div&gt;</p><p>CGI::Ajax sends the values from source1 and source2 to your Perl subroutine and returns the results to dest1 and dest2.</p><h3>4 Usage Methods</h3>

<dl class='dl-vertical'>
  <dt>
    1 Standard CGI::Ajax example
  </dt>
  <dd>
    <p>Start by defining a perl subroutine that you want available from javascript.  In this case we'll define a subrouting that determines whether or not an input is odd, even, or not a number (NaN):   use strict;   use CGI::Ajax;   use CGI;</p><p>  sub evenodd_func {     my $input = shift;</p><p>    # see if input is defined     if ( not defined $input ) {       return("input not defined or NaN");     }</p><p>    # see if value is a number (*thanks Randall!*)     if ( $input !~ /&#92;A&#92;d+&#92;z/ ) {       return("input is NaN");     }</p><p>    # got a number, so mod by 2     $input % 2 == 0 ? return("EVEN") : return("ODD");   } Alternatively, we could have used coderefs to associate an exported name...   my $evenodd_func = sub {     # exactly the same as in the above subroutine   }; Next we define a function to generate the web page - this can be done many different ways, and can also be defined as an anonymous sub.  The only requirement is that the sub send back the html of the page.  You can do this via a string containing the html, or from a coderef that returns the html, or from a function (as shown here)...   sub Show_HTML {     my $html = &lt;&lt;EOT;   &lt;HTML&gt;   &lt;HEAD&gt;&lt;title&gt;CGI::Ajax Example&lt;/title&gt;   &lt;/HEAD&gt;   &lt;BODY&gt;     Enter a number:&nbsp;     &lt;input type="text" name="somename" id="val1" size="6"        OnKeyUp="evenodd( [&apos;val1&apos;], [&apos;resultdiv&apos;] );"&gt;     &lt;br&gt;     &lt;hr&gt;     &lt;div id="resultdiv"&gt;     &lt;/div&gt;   &lt;/BODY&gt;   &lt;/HTML&gt; EOT     return $html;   } The exported Perl subrouting is triggered using the \*(C`OnKeyUp\*(C' event handler of the input \s-1HTML\s0 element.  The subroutine takes one value from the form, the input element <strong>'val1'</strong>, and returns the the result to an \s-1HTML\s0 div element with an id of <strong>'resultdiv'</strong>. Sending in the input id in an array format is required to support multiple inputs, and similarly, to output multiple the results, you can use an array for the output divs, but this isn't mandatory - as will be explained in the <strong>Advanced</strong> usage. Now create a \s-1CGI\s0 object and a CGI::Ajax object, associating a reference to our subroutine with the name we want available to javascript.   my $cgi = new CGI();   my $pjx = new CGI::Ajax( &apos;evenodd&apos; =&gt; &#92;&evenodd_func ); And if we used a coderef, it would look like this...   my $pjx = new CGI::Ajax( &apos;evenodd&apos; =&gt; $evenodd_func ); Now we're ready to print the output page; we send in the cgi object and the HTML-generating function.   print $pjx-&gt;build_html($cgi,&#92;&Show_HTML); CGI::Ajax has support for passing in extra \s-1HTML\s0 header information to the \s-1CGI\s0 object.  This can be accomplished by adding a third argument to the <em>build_html()</em> call.  The argument needs to be a hashref containing Key=&gt;value pairs that \s-1CGI\s0 objects understand:   print $pjx-&gt;build_html($cgi,&#92;&Show_HTML,     {-charset=&gt;&apos;UTF-8, -expires=&gt;&apos;-1d&apos;}); See \s-1CGI\s0 for more <em>header()</em> method options.  (\s-1CGI\s0.pm, not the Perl6 \s-1CGI\s0) That's it for the CGI::Ajax standard method.  Let's look at something more advanced.</p>
  </dd>
  <dt>
    2 Advanced CGI::Ajax example
  </dt>
  <dd>
    <p>Let's say we wanted to have a perl subroutine process multiple values from the \s-1HTML\s0 page, and similarly return multiple values back to distinct divs on the page.  This is easy to do, and requires no changes to the perl code - you just create it as you would any perl subroutine that works with multiple input values and returns multiple values.  The significant change happens in the event handler javascript in the \s-1HTML\s0...   onClick="exported_func([&apos;input1&apos;,&apos;input2&apos;],[&apos;result1&apos;,&apos;result2&apos;]);" Here we associate our javascript function (\*(L"exported_func\*(R") with two \s-1HTML\s0 element ids ('input1','input2'), and also send in two \s-1HTML\s0 element ids to place the results in ('result1','result2').</p>
  </dd>
  <dt>
    3 Sending Perl Subroutine Output to a Javascript function
  </dt>
  <dd>
    <p>Occassionally, you might want to have a custom javascript function process the returned information from your Perl subroutine. This is possible, and the only requierment is that you change your event handler code...   onClick="exported_func([&apos;input1&apos;],[js_process_func]);" In this scenario, \*(C`js_process_func\*(C' is a javascript function you write to take the returned value from your Perl subroutine and process the results.  <em>Note that a javascript function is not</em> quoted \*(-- if it were, then CGI::Ajax would look for a \s-1HTML\s0 element with that id.  Beware that with this usage, <strong>you are responsible</strong> for distributing the results to the appropriate place on the \s-1HTML\s0 page.  If the exported Perl subroutine returns, e.g. 2 values, then \*(C`js_process_func\*(C' would need to process the input by working through an array, or using the javascript Function \*(C`arguments\*(C' object.   function js_process_func() {     var input1 = arguments[0]     var input2 = arguments[1];     // do something and return results, or set HTML divs using     // innerHTML     document.getElementById(&apos;outputdiv&apos;).innerHTML = input1;   }</p>
  </dd>
  <dt>
    4 URL/Outside Script CGI::Ajax example
  </dt>
  <dd>
    <p>There are times when you may want a different script to return content to your page.  This could be because you have an existing script already written to perform a particular task, or you want to distribute a part of your application to another script.  This can be accomplished in CGI::Ajax by using a \s-1URL\s0 in place of a locally-defined Perl subroutine.  In this usage, you alter you creation of the CGI::Ajax object to link an exported javascript function name to a local \s-1URL\s0 instead of a coderef or a subroutine.   my $url = &apos;scripts/other_script.pl&apos;;   my $pjx = new CGI::Ajax( &apos;external&apos; =&gt; $url ); This will work as before in terms of how it is called from you event handler:   onClick="external([&apos;input1&apos;,&apos;input2&apos;],[&apos;resultdiv&apos;]);" The other_script.pl will get the values via a \s-1CGI\s0 object and accessing the 'args' key.  The values of the <strong>'args'</strong> key will be an array of everything that was sent into the script.   my @input = $cgi-&gt;params(&apos;args&apos;);   $input[0]; # contains first argument   $input[1]; # contains second argument, etc... This is good, but what if you need to send in arguments to the other script which are directly from the calling Perl script, i.e. you want a calling Perl script's variable to be sent, not the value from an \s-1HTML\s0 element on the page?  This is possible using the following syntax:   onClick="exported_func([&apos;args_\|_$input1&apos;,&apos;args_\|_$input2&apos;],                          [&apos;resultdiv&apos;]);" Similary, if the external script required a constant as input (e.g.  \*(C`script.pl?args=42\*(C', you would use this syntax:   onClick="exported_func([&apos;args_\|_42&apos;],[&apos;resultdiv&apos;]);" In both of the above examples, the result from the external script would get placed into the <em>resultdiv</em> element on our (the calling script's) page. If you are sending more than one argument from an external perl script back to a javascript function, you will need to split the string (\s-1AJAX\s0 applications communicate in strings only) on something. Internally, we use '_\|_pjx_\|_', and this string is checked for.  If found, CGI::Ajax will automatically split it.  However, if you don't want to use '_\|_pjx_\|_', you can do it yourself: For example, from your Perl script, you would...         return("A|B"); # join with "|" and then in the javascript function you would have something like...         process_func() {                 var arr = arguments[0].split("|");                 // arr[0] eq &apos;A&apos;                 // arr[1] eq &apos;B&apos;         } In order to rename parameters, in case the outside script needs specifically-named parameters and not CGI::Ajax' <em>'args'</em> default parameter name, change your event handler associated with an \s-1HTML\s0 event like this   onClick="exported_func([&apos;myname_\|_$input1&apos;,&apos;myparam_\|_$input2&apos;],                          [&apos;resultdiv&apos;]);" The \s-1URL\s0 generated would look like this... \*(C`script.pl?myname=input1&myparam=input2\*(C' You would then retrieve the input in the outside script with this...   my $p1 = $cgi-&gt;params(&apos;myname&apos;);   my $p1 = $cgi-&gt;params(&apos;myparam&apos;); Finally, what if we need to get a value from our \s-1HTML\s0 page and we want to send that value to an outside script but the outside script requires a named parameter different from <em>'args'</em>?  You can accomplish this with CGI::Ajax using the <em>getVal()</em> javascript method (which returns an array, thus the \*(C`getVal()[0]\*(C' notation):   onClick="exported_func([&apos;myparam_\|_&apos; + getVal(&apos;div_id&apos;)[0]],                          [&apos;resultdiv&apos;]);" This will get the value of our \s-1HTML\s0 element with and <em>id</em> of <em>div_id</em>, and submit it to the url attached to <em>myparam_\|_</em>.  So if our exported handler referred to a \s-1URI\s0 called <em>script/scr.pl</em>, and the element on our \s-1HTML\s0 page called <em>div_id</em> contained the number '42', then the \s-1URL\s0 would look like this \*(C`script/scr.pl?myparam=42\*(C'.  The result from this outside \s-1URL\s0 would get placed back into our \s-1HTML\s0 page in the element <em>resultdiv</em>.  See the example script that comes with the distribution called <em>pjx_url.pl</em> and its associated outside script <em>convert_degrees.pl</em> for a working example. <strong>N.B.</strong> These examples show the use of outside scripts which are other perl scripts - <em>but you are not limited to Perl</em>! The outside script could just as easily have been \s-1PHP\s0 or any other \s-1CGI\s0 script, as long as the return from the other script is just the result, and not addition \s-1HTML\s0 code (like \s-1FORM\s0 elements, etc).</p>
  </dd>

</dl>

<h3>\s-1GET\s0 versus \s-1POST\s0</h3>
<p>Note that all the examples so far have used the following syntax:</p><p>  onClick="exported_func([&apos;input1&apos;],[&apos;result1&apos;]);"</p><p>There is an optional third argument to a CGI::Ajax exported function that allows change the submit method.  The above event could also have been coded like this...</p><p>  onClick="exported_func([&apos;input1&apos;],[&apos;result1&apos;], &apos;GET&apos;);"</p><p>By default, CGI::Ajax sends a <em>'\s-1GET\s0'</em> request.  If you need it, for example your \s-1URL\s0 is getting way too long, you can easily switch to a <em>'\s-1POST\s0'</em> request with this syntax...</p><p>  onClick="exported_func([&apos;input1&apos;],[&apos;result1&apos;], &apos;POST&apos;);"</p><p><em>('\s-1POST\s0' and 'post' are supported)</em></p>
<h3>Page Caching</h3>
<p>We have implemented a method to prevent page cacheing from undermining the \s-1AJAX\s0 methods in a page.  If you send in an input argument to a CGI::Ajax-exported function called '\s-1NO_CACHE\s0', the a special parameter will get attached to the end or your url with a random number in it.  This will prevent a browser from caching your request.</p><p>  onClick="exported_func([&apos;input1&apos;,&apos;NO_CACHE&apos;],[&apos;result1&apos;]);"</p><p>The extra param is called pjxrand, and won't interfere with the order of processing for the rest of your parameters.</p><p>Also see the \s-1<em>CACHE\s0()</em> method of changing the default cache behavior.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>build_html()</em>
  </dt>
  <dd>
    <p>    Purpose: Associates a cgi obj ($cgi) with pjx object, inserts              javascript into &lt;HEAD&gt;&lt;/HEAD&gt; element and constructs              the page, or part of the page.  AJAX applications              are designed to update only the section of the              page that needs it - the whole page doesn&apos;t have              to be redrawn.  L&lt;CGI::Ajax&gt; applications use the              build_html() method to take care of this: if the CGI              parameter C&lt;fname&gt; exists, then the return from the              L&lt;CGI::Ajax&gt;-exported function is sent to the page.              Otherwise, the entire page is sent, since without              an C&lt;fname&gt; param, this has to be the first time              the page is being built.</p><p>  Arguments: The CGI object, and either a coderef, or a string              containing html.  Optionally, you can send in a third              parameter containing information that will get passed              directly to the CGI object header() call.     Returns: html or updated html (including the header)   Called By: originating cgi script</p>
  </dd>
  <dt>
    <em>show_javascript()</em>
  </dt>
  <dd>
    <p>    Purpose: builds the text of all the javascript that needs to be              inserted into the calling scripts html &lt;head&gt; section   Arguments:     Returns: javascript text   Called By: originating web script        Note: This method is also overridden so when you just print              a CGI::Ajax object it will output all the javascript needed              for the web page.</p>
  </dd>
  <dt>
    <em>register()</em>
  </dt>
  <dd>
    <p>    Purpose: adds a function name and a code ref to the global coderef              hash, after the original object was created   Arguments: function name, code reference     Returns: none   Called By: originating web script</p>
  </dd>
  <dt>
    <em>fname()</em>
  </dt>
  <dd>
    <p>    Purpose: Overrides the default parameter name used for              passing an exported function name. Default value              is "fname".</p><p>  Arguments: fname("new_name"); # sets the new parameter name              The overriden fname should be consistent throughout              the entire application. Otherwise results are unpredicted.</p><p>    Returns: With no parameters fname() returns the current fname name</p>
  </dd>
  <dt>
    \s-1<em>JSDEBUG\s0()</em>
  </dt>
  <dd>
    <p>    Purpose: Show the AJAX URL that is being generated, and stop              compression of the generated javascript, both of which can aid              during debugging.  If set to 1, then the core js will get              compressed, but the user-defined functions will not be              compressed.  If set to 2 (or anything greater than 1 or 0),              then none of the javascript will get compressed.</p><p>  Arguments: <strong>JSDEBUG</strong>(0); # turn javascript debugging off              <strong>JSDEBUG</strong>(1); # turn javascript debugging on, some javascript compression              <strong>JSDEBUG</strong>(2); # turn javascript debugging on, no javascript compresstion     Returns: prints a link to the url that is being generated automatically by              the Ajax object. this is VERY useful for seeing what              CGI::Ajax is doing. Following the link, will show a page              with the output that the page is generating.</p><p>  Called By: $pjx-&gt;<strong>JSDEBUG</strong>(1) # where $pjx is a CGI::Ajax object;</p>
  </dd>
  <dt>
    \s-1<em>DEBUG\s0()</em>
  </dt>
  <dd>
    <p>    Purpose: Show debugging information in web server logs   Arguments: <strong>DEBUG</strong>(0); # turn debugging off (default)              <strong>DEBUG</strong>(1); # turn debugging on     Returns: prints debugging information to the web server logs using              STDERR   Called By: $pjx-&gt;<strong>DEBUG</strong>(1) # where $pjx is a CGI::Ajax object;</p>
  </dd>
  <dt>
    \s-1<em>CACHE\s0()</em>
  </dt>
  <dd>
    <p>    Purpose: Alter the default result caching behavior.   Arguments: <strong>CACHE</strong>(0); # effectively the same as having NO_CACHE passed in every call     Returns: A change in the behavior of build_html such that the javascript              produced will always act as if the NO_CACHE argument is passed,              regardless of its presence.   Called By: $pjx-&gt;<strong>CACHE</strong>(0) # where $pjx is a CGI::Ajax object;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Follow any bugs at our homepage....</p><p>  http://www.perljax.us</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>Check out the news/discussion/bugs lists at our homepage:</p><p>  http://www.perljax.us</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>  Brian C. Thomas     Brent Pedersen   CPAN ID: BCT   bct.x42@gmail.com   bpederse@gmail.com</p><p>  significant contribution by:       Peter Gordon &lt;peter@pg-consultants.com&gt; # CGI::Application + scripts       Kyraha  http://michael.kyraha.com/      # getVal(), multiple forms       Jan Franczak &lt;jan.franczak@gmail.com&gt;   # CACHE support       Shibi NS                                # use -&gt;isa instead of -&gt;can</p><p>  others:       RENEEB &lt;RENEEB [...] cpan.org&gt;       stefan.scherer       RBS       Andrew</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">A NOTE ABOUT THE MODULE NAME</h2>
        <div class="sectioncontent">
<p>This module was initiated using the name \*(L"Perljax\*(R", but then registered with \s-1CPAN\s0 under the \s-1WWW\s0 group \*(L"\s-1CGI::\s0\*(R", and so became \*(L"CGI::Perljax\*(R".  Upon further deliberation, we decided to change it's name to CGI::Ajax.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>The full text of the license can be found in the \s-1LICENSE\s0 file included with this module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO CGI::Ajax&hellip;</h2>
        <div class="sectioncontent">
<p>Data::Javascript \s-1CGI\s0 Class::Accessor</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="CDDB_get.3pm.html"><span aria-hidden="true">&larr;</span> CDDB_get.3pm: Read the cddb entry for an audio cd in your drive</a></li>
   <li class="next"><a href="CGI::Application::Dispatch.3pm.html">CGI::Application::Dispatch.3pm: Dispatch requests to cgi::application based objects <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mdb_readers: Reader lock table -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Reader lock table -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mdb_readers (3) manual">
  <meta name="twitter:description" content="Reader lock table -">
  <meta name="twitter:image" content="https://www.carta.tech/images/lmdb-doc-mdb_readers-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/mdb_readers.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mdb_readers (3) manual" />
  <meta property="og:description" content="Reader lock table -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/lmdb-doc-mdb_readers-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mdb_readers<small> (3)</small></h1>
        <p class="lead">Reader lock table -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mdb_readers.3.html">
      <span itemprop="name">mdb_readers: Reader lock table -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/lmdb-doc/">
      <span itemprop="name">lmdb-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mdb_readers.3.html">
      <span itemprop="name">mdb_readers: Reader lock table -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>Readers don't acquire any locks for their data access. Instead, they simply record their transaction ID in the reader table. The reader mutex is needed just to find an empty slot in the reader table. The slot's address is saved in thread-specific data so that subsequent read transactions started by the same thread need no further locking to proceed.</p><p>If <strong>MDB_NOTLS</strong> is set, the slot address is not saved in thread-specific data.</p><p>No reader table is used if the database is on a read-only filesystem, or if <strong>MDB_NOLOCK</strong> is set.</p><p>Since the database uses multi-version concurrency control, readers don't actually need any locking. This table is used to keep track of which readers are using data from which old transactions, so that we'll know when a particular old transaction is no longer in use. Old transactions that have discarded any data pages can then have those pages reclaimed for use by a later write transaction.</p><p>The lock table is constructed such that reader slots are aligned with the processor's cache line size. Any slot is only ever used by one thread. This alignment guarantees that there will be no contention or cache thrashing as threads update their own slot info, and also eliminates any need for locking when accessing a slot.</p><p>A writer thread will scan every slot in the table to determine the oldest outstanding reader transaction. Any freed pages older than this will be reclaimed by the writer. The writer doesn't use any locks when scanning this table. This means that there's no guarantee that the writer will see the most up-to-date reader info, but that's not required for correct operation - all we need is to know the upper bound on the oldest reader, we don't care at all about the newest reader. So the only consequence of reading stale information here is that old pages might hang around a while longer before being reclaimed. That's actually good anyway, because the longer we delay reclaiming old pages, the more likely it is that a string of contiguous pages can be found after coalescing old pages from many old transactions together.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Data Structure Documentation</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_rxbody</h2>
        <div class="sectioncontent">
<p>The information we store in a single slot of the reader table. In addition to a transaction ID, we also record the process and thread ID that owns a slot, so that we can detect stale information, e.g. threads or processes that went away without cleaning up.</p><p><strong>Note:</strong></p><p>We currently don't check for stale records. We simply re-init the table when we know that we're the only process opening the lock file.</p><p><strong>Data Fields</strong></p><p><strong>txnid_t</strong> <strong>mrb_txnid</strong></p><p>MDB_PID_T <strong>mrb_pid</strong></p><p>MDB_THR_T <strong>mrb_tid</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBtxnid_t\fP MDB_rxbody::mrb_txnid</h3>
<p>Current Transaction ID when this transaction began, or (txnid_t)-1. Multiple readers that start at the same time will probably have the same ID here. Again, it's not important to exclude them from anything; all we need to know is which version of the DB they started from so we can avoid overwriting any data used in that particular version.</p>
<h3>MDB_PID_T MDB_rxbody::mrb_pid</h3>
<p>The process ID of the process owning this reader txn.</p>
<h3>MDB_THR_T MDB_rxbody::mrb_tid</h3>
<p>The thread ID of the thread owning this txn.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_reader</h2>
        <div class="sectioncontent">
<p>The actual reader record, with cacheline padding.</p><p><strong>Data Fields</strong></p><p>union {</p>
<pre>
   <strong>MDB_rxbody</strong> <strong>mrx</strong>
</pre>

<pre>
   char <strong>pad</strong> [(sizeof(<strong>MDB_rxbody</strong>)+<strong>CACHELINE</strong>-1)&~(<strong>CACHELINE</strong>-1)]
</pre>
<p>} <strong>mru</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>char MDB_reader::pad[(sizeof(\fBMDB_rxbody\fP)+\fBCACHELINE\fP-1)&~(\fBCACHELINE\fP-1)]</h3>
<p>cache line alignment</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_txbody</h2>
        <div class="sectioncontent">
<p>The header for the reader table. The table resides in a memory-mapped file. (This is a different file than is used for the main database.)</p><p>For POSIX the actual mutexes reside in the shared memory of this mapped file. On Windows, mutexes are named objects allocated by the kernel; we store the mutex names in this mapped file so that other processes can grab them. This same approach is also used on MacOSX/Darwin (using named semaphores) since MacOSX doesn't support process-shared POSIX mutexes. For these cases where a named object is used, the object name is derived from a 64 bit FNV hash of the environment pathname. As such, naming collisions are extremely unlikely. If a collision occurs, the results are unpredictable.</p><p><strong>Data Fields</strong></p><p>uint32_t <strong>mtb_magic</strong></p><p>uint32_t <strong>mtb_format</strong></p><p>pthread_mutex_t <strong>mtb_mutex</strong></p><p><strong>txnid_t</strong> <strong>mtb_txnid</strong></p><p>unsigned <strong>mtb_numreaders</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>uint32_t MDB_txbody::mtb_magic</h3>
<p>Stamp identifying this as an LMDB file. It must be set to <strong>MDB_MAGIC</strong>.</p>
<h3>uint32_t MDB_txbody::mtb_format</h3>
<p>Format of this lock file. Must be set to <strong>MDB_LOCK_FORMAT</strong>.</p>
<h3>pthread_mutex_t MDB_txbody::mtb_mutex</h3>
<p>Mutex protecting access to this table. This is the reader lock that <strong>LOCK_MUTEX_R</strong> acquires.</p>
<h3>\fBtxnid_t\fP MDB_txbody::mtb_txnid</h3>
<p>The ID of the last transaction committed to the database. This is recorded here only for convenience; the value can always be determined by reading the main database meta pages.</p>
<h3>unsigned MDB_txbody::mtb_numreaders</h3>
<p>The number of slots that have been used in the reader table. This always records the maximum count, it is not decremented when readers release their slots.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_txninfo</h2>
        <div class="sectioncontent">
<p>The actual reader table definition.</p><p><strong>Data Fields</strong></p><p>union {</p>
<pre>
   <strong>MDB_txbody</strong> <strong>mtb</strong>
</pre>

<pre>
   char <strong>pad</strong> [(sizeof(<strong>MDB_txbody</strong>)+<strong>CACHELINE</strong>-1)&~(<strong>CACHELINE</strong>-1)]
</pre>
<p>} <strong>mt1</strong></p><p>union {</p>
<pre>
   pthread_mutex_t <strong>mt2_wmutex</strong>
</pre>

<pre>
   char <strong>pad</strong> [(MNAME_LEN+<strong>CACHELINE</strong>-1)&~(<strong>CACHELINE</strong>-1)]
</pre>
<p>} <strong>mt2</strong></p><p><strong>MDB_reader</strong> <strong>mti_readers</strong> [1]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Macro Definition Documentation</h2>
        <div class="sectioncontent">
<h3>#define DEFAULT_READERS   126</h3>
<p>Number of slots in the reader table. This value was chosen somewhat arbitrarily. 126 readers plus a couple mutexes fit exactly into 8KB on my development machine. Applications should set the table size using <strong>mdb_env_set_maxreaders()</strong>.</p>
<h3>#define CACHELINE   64</h3>
<p>The size of a CPU cache line in bytes. We want our lock structures aligned to this size to avoid false cache line sharing in the lock table. This value works for most CPUs. For Itanium this should be 128.</p>
<h3>#define MDB_LOCK_FORMAT</h3>
<p><strong>Value:</strong></p>
<pre>
((uint32_t)       ((MDB_LOCK_VERSION)        /* Flags which describe functionality */        + (((MDB_PIDLOCK) != 0) &lt;&lt; 16)))
</pre>
<p>Lockfile format signature: version, features and field layout</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for LMDB from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mdb_put.3.html"><span aria-hidden="true">&larr;</span> mdb_put.3: Write flags -</a></li>
   <li class="next"><a href="mdb_todo.3.html">mdb_todo.3: Todo list  this feature is currently unimplemented. the relocation function is called whenever it is necessary to move the data of an item to a different position in the database (e.g. through tree balancing operations, shifts as a result of adds or deletes, etc.). it is intended to allow address/position-dependent data items to be stored in a database in an environment opened with the mdb_fixedmap option. currently the relocation feature is unimplemented and setting this function has no effect.  parameters: txn a transaction handle returned by mdb_txn_begin()  dbi a database handle returned by mdb_dbi_open()  rel a mdb_rel_func function  returns: a non-zero error value on failure and 0 on success. some possible errors are: <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

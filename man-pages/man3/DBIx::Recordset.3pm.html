<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DBIx::Recordset: Perl extension for dbi recordsets</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl extension for dbi recordsets">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="DBIx::Recordset (3pm) manual">
  <meta name="twitter:description" content="Perl extension for dbi recordsets">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdbix-recordset-perl-DBIx::Recordset-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/DBIx::Recordset.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="DBIx::Recordset (3pm) manual" />
  <meta property="og:description" content="Perl extension for dbi recordsets" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdbix-recordset-perl-DBIx::Recordset-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">DBIx::Recordset<small> (3pm)</small></h1>
        <p class="lead">Perl extension for dbi recordsets</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::Recordset.3pm.html">
      <span itemprop="name">DBIx::Recordset: Perl extension for dbi recordsets</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdbix-recordset-perl/">
      <span itemprop="name">libdbix-recordset-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::Recordset.3pm.html">
      <span itemprop="name">DBIx::Recordset: Perl extension for dbi recordsets</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use DBIx::Recordset;

 # Setup a new object and select some recods...
 *set = DBIx::Recordset -&gt; Search ({&apos;!DataSource&apos; =&gt; &apos;dbi:Oracle:....&apos;,
                                    &apos;!Table&apos;      =&gt; &apos;users&apos;,
                                    &apos;$where&apos;      =&gt; &apos;name = ? and age &gt; ?&apos;,
                                    &apos;$values&apos;     =&gt; [&apos;richter&apos;, 25] }) ;

 # Get the values of field foo ...
 print "First Records value of foo is $set[0]{foo}&#92;n" ;
 print "Second Records value of foo is $set[1]{foo}&#92;n" ;
 # Get the value of the field age of the current record ...
 print "Age is $set{age}&#92;n" ;

 # Do another select with the already created object...
 $set -&gt; Search ({name =&gt; &apos;bar&apos;}) ;

 # Show the result...
 print "All users with name bar:&#92;n" ;
 while ($rec = $set -&gt; Next)
    {
    print $rec -&gt; {age} ;
    }

 # Setup another object and insert a new record
 *set2 = DBIx::Recordset -&gt; Insert ({&apos;!DataSource&apos; =&gt; &apos;dbi:Oracle:....&apos;,
                                     &apos;!Table&apos;      =&gt; &apos;users&apos;,
                                     &apos;name&apos;        =&gt; &apos;foo&apos;,
                                     &apos;age&apos;         =&gt; 25 }) ;


 # Update this record (change age from 25 to 99)...
 $set -&gt; Update ({age =&gt; 99}, {name =&gt; &apos;foo&apos;}) ;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>DBIx::Recordset is a perl module for abstraction and simplification of database access.</p><p>The goal is to make standard database access (select/insert/update/delete) easier to handle and independend of the underlying \s-1DBMS\s0. Special attention is made on web applications to make it possible to handle the state-less access and to process the posted data of formfields, but DBIx::Recordset is not limited to web applications.</p><p><strong>DBIx::Recordset</strong> uses the \s-1DBI\s0 \s-1API\s0 to access the database, so it should work with every database for which a \s-1DBD\s0 driver is available (see also DBIx::Compat).</p><p>Most public functions take a hash reference as parameter, which makes it simple to supply various different arguments to the same function. The parameter hash can also be taken from a hash containing posted formfields like those available with \s-1CGI\s0.pm, mod_perl, HTML::Embperl and others.</p><p>Before using a recordset it is necessary to setup an object. Of course the setup step can be made with the same function call as the first database access, but it can also be handled separately.</p><p>Most functions which set up an object return a <strong>typglob</strong>. A typglob in Perl is an object which holds pointers to all datatypes with the same name. Therefore a typglob must always have a name and <strong>can't</strong> be declared with <strong>my</strong>. You can only use it as <strong>global</strong> variable or declare it with <strong>local</strong>. The trick for using a typglob is that setup functions can return a <strong>reference to an object</strong>, an <strong>array</strong> and a <strong>hash</strong> at the same time.</p><p>The object is used to access the object's methods, the array is used to access the records currently selected in the recordset and the hash is used to access the current record.</p><p>If you don't like the idea of using typglobs you can also set up the object, array and hash separately, or just set the ones you need.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ARGUMENTS</h2>
        <div class="sectioncontent">
<p>Since most methods take a hash reference as argument, here is a description of the valid arguments first.</p><h3>Setup Parameters</h3>
<p>All parameters starting with an '!' are only recognized at setup time. If you specify them in later function calls they will be ignored. You can also preset these parameters with the TableAttr method of DBIx::Database.  This allows you to presetup most parameters for the whole database and they will be use every time you create a new DBIx::Recordset object, without specifying it every time.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>!DataSource</strong>
  </dt>
  <dd>
    <p>Specifies the database to which to connect. This information can be given in the following ways:</p>
<dl class='dl-vertical'>
  <dt>
    Driver/DB/Host.
  </dt>
  <dd>
    <p>Same as the first parameter to the \s-1DBI\s0 connect function.</p>
  </dd>
  <dt>
    DBIx::Recordset object
  </dt>
  <dd>
    <p>Takes the same database handle as the given DBIx::Recordset object.</p>
  </dd>
  <dt>
    DBIx::Database object
  </dt>
  <dd>
    <p>Takes Driver/DB/Host from the given database object. See DBIx::Database for details about DBIx::Database object. When using more then one Recordset object, this is the most efficient method.</p>
  </dd>
  <dt>
    DBIx::Datasbase object name
  </dt>
  <dd>
    <p>Takes Driver/DB/Host from the database object which is saved under the given name ($saveas parameter to DBIx::Database -&gt; new)</p>
  </dd>
  <dt>
    an \s-1DBI\s0 database handle
  </dt>
  <dd>
    <p>Uses given database handle.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>!Table</strong>
  </dt>
  <dd>
    <p>Tablename. Multiple tables are comma-separated.</p>
  </dd>
  <dt>
    <strong>!Username</strong>
  </dt>
  <dd>
    <p>Username. Same as the second parameter to the \s-1DBI\s0 connect function.</p>
  </dd>
  <dt>
    <strong>!Password</strong>
  </dt>
  <dd>
    <p>Password. Same as the third parameter to the \s-1DBI\s0 connect function.</p>
  </dd>
  <dt>
    <strong>!DBIAttr</strong>
  </dt>
  <dd>
    <p>Reference to a hash which holds the attributes for the \s-1DBI\s0 connect function. See perldoc \s-1DBI\s0 for a detailed description.</p>
  </dd>
  <dt>
    <strong>!Fields</strong>
  </dt>
  <dd>
    <p>Fields which should be returned by a query. If you have specified multiple tables the fieldnames should be unique. If the names are not unique you must specify them along with the tablename (e.g. tab1.field). \s-1NOTE\s0 1: Fieldnames specified with !Fields can't be overridden. If you plan to use other fields with this object later, use $Fields instead. \s-1NOTE\s0 2: The keys for the returned hash normally don't have a table part. Only the fieldname part forms the key. (See !LongNames for an exception.) \s-1NOTE\s0 3: Because the query result is returned in a hash, there can only be one out of multiple fields with the same name fetched at once. If you specify multiple fields with the same name, only one is returned from a query. Which one this actually is depends on the \s-1DBD\s0 driver. (See !LongNames for an exception.) \s-1NOTE\s0 4: Some databases (e.g. mSQL) require you to always qualify a fieldname with a tablename if more than one table is accessed in one query.</p>
  </dd>
  <dt>
    <strong>!TableFilter</strong>
  </dt>
  <dd>
    <p>The TableFilter parameter specifies which tables should be honoured when DBIx::Recordset searches for links between tables (see below). When given as parameter to DBIx::Database it filters for which tables DBIx::Database retrieves metadata. Only thoses tables are used which starts with prefix given by \*(C`!TableFilter\*(C'. Also the DBIx::Recordset link detection tries to use this value as a prefix of table names, so you can leave out this prefix when you write a fieldname that should be detected as a link to another table.</p>
  </dd>
  <dt>
    <strong>!LongNames</strong>
  </dt>
  <dd>
    <p>When set to 1, the keys of the hash returned for each record not only consist of the fieldnames, but are built in the form table.field.</p>
  </dd>
  <dt>
    <strong>!Order</strong>
  </dt>
  <dd>
    <p>Fields which should be used for ordering any query. If you have specified multiple tables the fieldnames should be unique. If the names are not unique you must specify them among with the tablename (e.g. tab1.field). \s-1NOTE\s0 1: Fieldnames specified with !Order can't be overridden. If you plan to use other fields with this object later, use $order instead.</p>
  </dd>
  <dt>
    <strong>!TabRelation</strong>
  </dt>
  <dd>
    <p>Condition which describes the relation between the given tables (e.g. tab1.id = tab2.id) (See also !TabJoin.)   Example</p><p>  &apos;!Table&apos;       =&gt; &apos;tab1, tab2&apos;,   &apos;!TabRelation&apos; =&gt; &apos;tab1.id=tab2.id&apos;,   &apos;name&apos;         =&gt; &apos;foo&apos;</p><p>  This will generate the following SQL statement:</p><p>  SELECT * FROM tab1, tab2 WHERE name = &apos;foo&apos; and tab1.id=tab2.id ;</p>
  </dd>
  <dt>
    <strong>!TabJoin</strong>
  </dt>
  <dd>
    <p>!TabJoin allows you to specify an <strong>\s-1INNER/RIGHT/LEFT\s0 \s-1JOIN\s0</strong> which is used in a <strong>\s-1SELECT\s0</strong> statement. (See also !TabRelation.)   Example</p><p>  &apos;!Table&apos;   =&gt; &apos;tab1, tab2&apos;,   &apos;!TabJoin&apos; =&gt; &apos;tab1 LEFT JOIN tab2 ON (tab1.id=tab2.id)&apos;,   &apos;name&apos;     =&gt; &apos;foo&apos;</p><p>  This will generate the following SQL statement:</p><p>  SELECT * FROM tab1 LEFT JOIN tab2 ON  (tab1.id=tab2.id) WHERE name = &apos;foo&apos; ;</p>
  </dd>
  <dt>
    <strong>!PrimKey</strong>
  </dt>
  <dd>
    <p>Name of the primary key. When this key appears in a \s-1WHERE\s0 parameter list (see below), DBIx::Recordset will ignore all other keys in the list, speeding up \s-1WHERE\s0 expression preparation and execution. Note that this key does \s-1NOT\s0 have to correspond to a field tagged as \s-1PRIMARY\s0 \s-1KEY\s0 in a \s-1CREATE\s0 \s-1TABLE\s0 statement.</p>
  </dd>
  <dt>
    <strong>!Serial</strong>
  </dt>
  <dd>
    <p>Name of the primary key. In contrast to \*(C`!PrimKey\*(C' this field is treated as an autoincrement field. If the database does not support autoincrement fields, but sequences the field is set to the next value of a sequence (see \*(C`!Sequence\*(C' and \*(C`!SeqClass\*(C') upon each insert. If a \*(C`!SeqClass\*(C' is given the values are always retrived from the sequence class regardless if the \s-1DBMS\s0 supports autoincrement or not. The value from this field from the last insert could be retrieved by the function \*(C`LastSerial\*(C'.</p>
  </dd>
  <dt>
    <strong>!Sequence</strong>
  </dt>
  <dd>
    <p>Name of the sequence to use for this table when inserting a new record and \*(C`!Serial\*(C' is defind. Defaults to &lt;tablename&gt;_seq.</p>
  </dd>
  <dt>
    <strong>!SeqClass</strong>
  </dt>
  <dd>
    <p>Name and Parameter for a class that can generate unique sequence values. This is a string that holds comma separated values. The first value is the class name and the following parameters are given to the new constructor. See also <em>DBIx::Recordset::FileSeq</em> and <em>DBIx::Recordset::DBSeq</em>. Example:  '!SeqClass' =&gt; 'DBIx::Recordset::FileSeq, /tmp/seq'</p>
  </dd>
  <dt>
    <strong>!WriteMode</strong>
  </dt>
  <dd>
    <p>!WriteMode specifies which write operations to the database are allowed and which are disabled. You may want to set !WriteMode to zero if you only need to query data, to avoid accidentally changing the content of the database. <strong>\s-1NOTE:\s0</strong> The !WriteMode only works for the DBIx::Recordset methods. If you disable !WriteMode, it is still possible to use <strong>do</strong> to send normal \s-1SQL\s0 statements to the database engine to write/delete any data. !WriteMode consists of some flags, which may be added together:</p>
<dl class='dl-vertical'>
  <dt>
    DBIx::Recordset::wmNONE (0)
  </dt>
  <dd>
    <p>Allow <strong>no</strong> write access to the table(s)</p>
  </dd>
  <dt>
    DBIx::Recordset::wmINSERT (1)
  </dt>
  <dd>
    <p>Allow \s-1INSERT\s0</p>
  </dd>
  <dt>
    DBIx::Recordset::wmUPDATE (2)
  </dt>
  <dd>
    <p>Allow \s-1UPDATE\s0</p>
  </dd>
  <dt>
    DBIx::Recordset::wmDELETE (4)
  </dt>
  <dd>
    <p>Allow \s-1DELETE\s0</p>
  </dd>
  <dt>
    DBIx::Recordset::wmCLEAR (8)
  </dt>
  <dd>
    <p>To allow \s-1DELETE\s0 for the whole table, wmDELETE must be also specified. This is necessary for assigning a hash to a hash which is tied to a table. (Perl will first erase the whole table, then insert the new data.)</p>
  </dd>
  <dt>
    DBIx::Recordset::wmALL (15)
  </dt>
  <dd>
    <p>Allow every access to the table(s)</p>
  </dd>

</dl>
<p>Default is wmINSERT + wmUPDATE + wmDELETE</p>
  </dd>
  <dt>
    <strong>!StoreAll</strong>
  </dt>
  <dd>
    <p>If present, this will cause DBIx::Recordset to store all rows which will be fetched between consecutive accesses, so it's possible to access data in a random order. (e.g. row 5, 2, 7, 1 etc.) If not specified, rows will only be fetched into memory if requested, which means that you will have to access rows in ascending order. (e.g. 1,2,3 if you try 3,2,4 you will get an undef for row 2 while 3 and 4 is ok) see also <strong>\s-1DATA\s0 \s-1ACCESS\s0</strong> below.</p>
  </dd>
  <dt>
    <strong>!HashAsRowKey</strong>
  </dt>
  <dd>
    <p>By default, the hash returned by the setup function is tied to the current record. You can use it to access the fields of the current record. If you set this parameter to true, the hash will by tied to the whole database. This means that the key of the hash will be used as the primary key in the table to select one row. (This parameter only has an effect on functions which return a typglob.)</p>
  </dd>
  <dt>
    <strong>!IgnoreEmpty</strong>
  </dt>
  <dd>
    <p>This parameter defines how <strong>empty</strong> and <strong>undefined</strong> values are handled. The values 1 and 2 may be helpful when using DBIx::Recordset inside a \s-1CGI\s0 script, because browsers send empty formfields as empty strings.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>0 (default)</strong>
  </dt>
  <dd>
    <p>An undefined value is treated as \s-1SQL\s0 <strong>\s-1NULL\s0</strong>: an empty string remains an empty string.</p>
  </dd>
  <dt>
    <strong>1</strong>
  </dt>
  <dd>
    <p>All fields with an undefined value are ignored when building the \s-1WHERE\s0 expression.</p>
  </dd>
  <dt>
    <strong>2</strong>
  </dt>
  <dd>
    <p>All fields with an undefined value or an empty string are ignored when building the \s-1WHERE\s0 expression.</p>
  </dd>

</dl>
<p><strong>\s-1NOTE:\s0</strong> The default for versions before 0.18 was 2.</p>
  </dd>
  <dt>
    <strong>!Filter</strong>
  </dt>
  <dd>
    <p>Filters can be used to pre/post-process the data which is read from/written to the database. The !Filter parameter takes a hash reference which contains the filter functions. If the key is numeric, it is treated as a type value and the filter is applied to all fields of that type. If the key if alphanumeric, the filter is applied to the named field.  Every filter description consists of an array with at least two elements.  The first element must contain the input function, and the second element must contain the output function. Either may be undef, if only one of them are necessary. The data is passed to the input function before it is written to the database. The input function must return the value in the correct format for the database. The output function is applied to data read from the database before it is returned to the user.  Example:</p><p>     &apos;!Filter&apos;   =&gt;         {         DBI::SQL_DATE     =&gt;             [                 sub { shift =~ /(&#92;d&#92;d)&#92;.(&#92;d&#92;d)&#92;.(&#92;d&#92;d)/ ; "19$3$2$1"},                 sub { shift =~ /&#92;d&#92;d(&#92;d&#92;d)(&#92;d&#92;d)(&#92;d&#92;d)/ ; "$3.$2.$1"}             ],</p><p>        &apos;datefield&apos; =&gt;             [                 sub { shift =~ /(&#92;d&#92;d)&#92;.(&#92;d&#92;d)&#92;.(&#92;d&#92;d)/ ; "19$3$2$1"},                 sub { shift =~ /&#92;d&#92;d(&#92;d&#92;d)(&#92;d&#92;d)(&#92;d&#92;d)/ ; "$3.$2.$1"}             ],</p><p>        } Both filters convert a date in the format dd.mm.yy to the database format 19yymmdd and vice versa. The first one does this for all fields of the type \s-1SQL_DATE\s0, the second one does this for the fields with the name datefield. The <strong>!Filter</strong> parameter can also be passed to the function <strong>TableAttr</strong> of the <strong>DBIx::Database</strong> object. In this case it applies to all DBIx::Recordset objects which use these tables. A third parameter can be optionally specified. It could be set to \*(C`DBIx::Recordset::rqINSERT\*(C', \*(C`DBIx::Recordset::rqUPDATE\*(C', or the sum of both. If set, the InputFunction (which is called during \s-1UPDATE\s0 or \s-1INSERT\s0) is always called for this field in updates and/or inserts depending on the value. If there is no data specified for this field as an argument to a function which causes an \s-1UPDATE/INSERT\s0, the InputFunction is called with an argument of <strong>undef</strong>. During \s-1UPDATE\s0 and \s-1INSERT\s0 the input function gets either the string 'insert' or 'update' passed as second parameter.</p>
  </dd>
  <dt>
    <strong>!LinkName</strong>
  </dt>
  <dd>
    <p>This allows you to get a clear text description of a linked table, instead of (or in addition to) the !LinkField. For example, if you have a record with all your bills, and each record contains a customer number, setting !LinkName DBIx::Recordset can automatically retrieve the name of the customer instead of (or in addition to) the bill record itself.</p>
<dl class='dl-vertical'>
  <dt>
    1 select additional fields
  </dt>
  <dd>
    <p>This will additionally select all fields given in <strong>!NameField</strong> of the Link or the table attributes (see TableAttr).</p>
  </dd>
  <dt>
    2 build name in uppercase of !MainField
  </dt>
  <dd>
    <p>This takes the values of <strong>!NameField</strong> of the Link or the table attributes (see TableAttr) and joins the content of these fields together into a new field, which has the same name as the !MainField, but in uppercase.</p>
  </dd>
  <dt>
    2 replace !MainField with the contents of !NameField
  </dt>
  <dd>
    <p>Same as 2, but the !MainField is replaced with \*(L"name\*(R" of the linked record.</p>
  </dd>

</dl>
<p>See also <strong>!Links</strong> and <strong>\s-1WORKING\s0 \s-1WITH\s0 \s-1MULTIPLE\s0 \s-1TABLES\s0</strong> below</p>
  </dd>
  <dt>
    <strong>!Links</strong>
  </dt>
  <dd>
    <p>This parameter can be used to link multiple tables together. It takes a reference to a hash, which has - as keys, names for a special <strong>\*(L"linkfield\*(R"</strong> and - as value, a parameter hash. The parameter hash can contain all the <strong>Setup parameters</strong>. The setup parameters are taken to construct a new recordset object to access the linked table. If !DataSource is omitted (as it normally should be), the same DataSource (and database handle), as the main object is taken. There are special parameters which can only occur in a link definition (see next paragraph). For a detailed description of how links are handled, see <strong>\s-1WORKING\s0 \s-1WITH\s0 \s-1MULTIPLE\s0 \s-1TABLES\s0</strong> below.</p>
  </dd>

</dl>

<h3>Link Parameters</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>!MainField</strong>
  </dt>
  <dd>
    <p>The <strong>!MailField</strong> parameter holds a fieldname which is used to retrieve a key value for the search in the linked table from the main table. If omitted, it is set to the same value as <strong>!LinkedField</strong>.</p>
  </dd>
  <dt>
    <strong>!LinkedField</strong>
  </dt>
  <dd>
    <p>The fieldname which holds the key value in the linked table. If omitted, it is set to the same value as <strong>!MainField</strong>.</p>
  </dd>
  <dt>
    <strong>!NameField</strong>
  </dt>
  <dd>
    <p>This specifies the field or fields which will be used as a \*(L"name\*(R" for the destination table. It may be a string or a reference to an array of strings. For example, if you link to an address table, you may specify the field \*(L"nickname\*(R" as the name field for that table, or you may use ['name', 'street', 'city']. Look at <strong>!LinkName</strong> for more information.</p>
  </dd>
  <dt>
    <strong>!DoOnConnect</strong>
  </dt>
  <dd>
    <p>You can give an \s-1SQL\s0 Statement (or an array reference of \s-1SQL\s0 statements), that will be executed every time, just after an connect to the db. As third possibilty you can give an hash reference. After every successful connect, DBIx::Recordset excutes the statements, in the element which corresponds to the name of the driver. '*' is executed for all drivers.</p>
  </dd>
  <dt>
    <strong>!Default</strong>
  </dt>
  <dd>
    <p>Specifies default values for new rows that are inserted via hash or array access. The Insert method ignores this parameter.</p>
  </dd>
  <dt>
    <strong>!TieRow</strong>
  </dt>
  <dd>
    <p>Setting this parameter to zero will cause DBIx::Recordset to <strong>not</strong> tie the returned rows to an DBIx::Recordset::Row object and instead returns an simple hash. The benefit of this is that it will speed up things, but you aren't able to write to such an row, nor can you use the link feature with such a row.</p>
  </dd>
  <dt>
    <strong>!Debug</strong>
  </dt>
  <dd>
    <p>Set the debug level. See \s-1DEBUGGING\s0.</p>
  </dd>
  <dt>
    <strong>!PreFetch</strong>
  </dt>
  <dd>
    <p>Only for tieing a hash! Gives an where expression (either as string or as hashref) that is used to prefetch records from that database. All following accesses to the tied hash only access this prefetched data and don't execute any database queries. See \*(C`!Expires\*(C' how to force a refetch. Giving a '*' as value to \*(C`!PreFetch\*(C' fetches the whole table into memory.  The following example prefetches all record with id &lt; 7:</p><p> tie %dbhash, &apos;DBIx::Recordset::Hash&apos;, {&apos;!DataSource&apos;   =&gt;  $DSN,                                         &apos;!Username&apos;     =&gt;  $User,                                         &apos;!Password&apos;     =&gt;  $Password,                                         &apos;!Table&apos;        =&gt;  &apos;foo&apos;,                                         &apos;!PreFetch&apos;     =&gt;  {                                                              &apos;*id&apos; =&gt; &apos;&lt;&apos;,                                                              &apos;id&apos; =&gt; 7                                                             },                                         &apos;!PrimKey&apos;      =&gt;  &apos;id&apos;} ;</p><p> The following example prefetches all records:</p><p> tie %dbhash, &apos;DBIx::Recordset::Hash&apos;, {&apos;!DataSource&apos;   =&gt;  $DSN,                                         &apos;!Username&apos;     =&gt;  $User,                                         &apos;!Password&apos;     =&gt;  $Password,                                         &apos;!Table&apos;        =&gt;  &apos;bar&apos;,                                         &apos;!PreFetch&apos;     =&gt;  &apos;*&apos;,                                         &apos;!PrimKey&apos;      =&gt;  &apos;id&apos;} ;</p>
  </dd>
  <dt>
    <strong>!Expires</strong>
  </dt>
  <dd>
    <p>Only for tieing a hash! If the values is numeric, the prefetched data will be refetched is it is older then the given number of seconds. If the values is a \s-1CODEREF\s0 the function is called and the data is refetched is the function returns true.</p>
  </dd>
  <dt>
    <strong>!MergeFunc</strong>
  </dt>
  <dd>
    <p>Only for tieing a hash! Gives an reference to an function that is called when more then one record for a given hash key is found to merge the records into one. The function receives a reference to both records a arguments. If more the two records are found, the function is called again for each following record, which is already merged data as first parameter.  The following example sets up a hash, that, when more then one record with the same id is  found, the field C&lt;sum&gt; is added and the first record is returned, where the C&lt;sum&gt; field  contains the sum of B&lt;all&gt; found records:</p><p> tie %dbhash, &apos;DBIx::Recordset::Hash&apos;, {&apos;!DataSource&apos;   =&gt;  $DSN,                                         &apos;!Username&apos;     =&gt;  $User,                                         &apos;!Password&apos;     =&gt;  $Password,                                         &apos;!Table&apos;        =&gt;  &apos;bar&apos;,                                         &apos;!MergeFunc&apos;    =&gt;  sub { my ($a, $b) = @_ ; $a-&gt;{sum} += $b-&gt;{sum} ; },                                         &apos;!PrimKey&apos;      =&gt;  &apos;id&apos;} ;</p>
  </dd>

</dl>

<h3>Where Parameters</h3>
<p>The following parameters are used to build an \s-1SQL\s0 \s-1WHERE\s0 expression Give an \s-1SQL\s0 \s-1WHERE\s0 expression literaly. If $where is specified, all other where parameters described below are ignored. The only expection is $values which can be used to give the values to bind to the placeholders in $where Values which should be bound to the placeholders given in $where.  Example:</p><p> *set = DBIx::Recordset -&gt; Search ({&apos;!DataSource&apos; =&gt; &apos;dbi:Oracle:....&apos;,                                     &apos;!Table&apos;      =&gt; &apos;users&apos;,                                     &apos;$where&apos;      =&gt; &apos;name = ? and age &gt; ?&apos;,                                     &apos;$values&apos;     =&gt; [&apos;richter&apos;, 25] }) ; <strong>\s-1NOTE:\s0</strong> Filters defined with \*(C`!Filter\*(C' are <strong>not</strong> applied to these values, because DBIx::Recordset has no chance to know with values belongs to which field.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>{fieldname}</strong>
  </dt>
  <dd>
    <p>Value for field. The value will be quoted automatically, if necessary. The value can also be an array ref in which case the values are put together with the operator passed via <strong></strong><strong>$valueconj</strong><strong></strong> (default: or)   Example:</p><p>  &apos;name&apos; =&gt; [ &apos;mouse&apos;, &apos;cat&apos;] will expand to name=&apos;mouse&apos; or name=&apos;cat&apos;</p>
  </dd>
  <dt>
    <strong>'{fieldname}</strong>
  </dt>
  <dd>
    <p>Value for field. The value will always be quoted. This is only necessary if DBIx::Recordset cannot determine the correct type for a field.</p>
  </dd>
  <dt>
    <strong>#{fieldname}</strong>
  </dt>
  <dd>
    <p>Value for field. The value will never be quoted, but will converted a to number. This is only necessary if DBIx::Recordset cannot determine the correct type for a field.</p>
  </dd>
  <dt>
    <strong>&#92;{fieldname}</strong>
  </dt>
  <dd>
    <p>Value for field. The value will not be converted in any way, i.e. you have to quote it before supplying it to DBIx::Recordset if necessary.</p>
  </dd>
  <dt>
    <strong>+{fieldname}|{fieldname}..</strong>
  </dt>
  <dd>
    <p>Values for multiple fields. The value must be in one/all fields depending on $compconj  Example:  '+name|text' =&gt; 'abc' will expand to name='abc' or text='abc' 'or' or 'and' (default is 'or'). Specifies the conjunction between multiple fields. (see above) Regular expression for splitting a field value in multiple values (default is '&#92;t') The conjunction for multiple values could be specified with <strong></strong><strong>$valueconj</strong><strong></strong>. By default, only one of the values must match the field.  Example:  &apos;name&apos; =&gt; "mouse&#92;tcat" will expand to name=&apos;mouse&apos; or name=&apos;cat&apos;</p><p> NOTE: The above example can also be written as &apos;name&apos; =&gt; [ &apos;mouse&apos;, &apos;cat&apos;] 'or' or 'and' (default is 'or'). Specifies the conjunction for multiple values. 'or' or 'and' (default is 'and') conjunction between fields Default operator if not otherwise specified for a field. (default is '=')</p>
  </dd>
  <dt>
    <strong>*{fieldname}</strong>
  </dt>
  <dd>
    <p>Operator for the named field  Example:  &apos;value&apos; =&gt; 9, &apos;*value&apos; =&gt; &apos;&gt;&apos; expand to value &gt; 9 Could also be an array ref, so you can pass different operators for the values. This is mainly handy when you need to select a range   Example:</p><p>    $set -&gt; Search  ({id          =&gt; [5,    7   ],                      &apos;*id&apos;        =&gt; [&apos;&gt;=&apos;, &apos;&lt;=&apos;],                      &apos;$valueconj&apos; =&gt; &apos;and&apos;})  ;</p><p>  This will expanded to "id &gt;= 5 and id &lt;= 7" \s-1NOTE:\s0 To get a range you need to specify the $valueconj parameter as \*(C`and\*(C' because it defaults to \*(C`or\*(C'. <strong></strong><strong>$expr</strong><strong></strong> can be used to group parts of the where expression for proper priority. To specify more the one sub expression, add a numerical index to $expr (e.g. $expr1, $expr2)   Example:</p><p>    $set -&gt; Search  ({id          =&gt; 5,                      &apos;$expr&apos;      =&gt;                         {                         &apos;name&apos;  =&gt; &apos;Richter&apos;,                         &apos;country&apos; =&gt; &apos;de&apos;,                         &apos;$conj&apos;   =&gt; &apos;or&apos;                         }                       }) ;</p><p>    This will expand to</p><p>        (name = &apos;Richter&apos; or country = &apos;de&apos;) and id = 5</p>
  </dd>

</dl>

<h3>Search parameters</h3>
<p>First row to fetch. The row specified here will appear as index 0 in the data array. Maximum number of rows to fetch. Every attempt to fetch more rows than specified here will return undef, even if the select returns more rows. Add the number supplied with <strong></strong><strong>$max</strong><strong></strong> to <strong></strong><strong>$start</strong><strong></strong>. This is intended to implement a next button. Subtract the number supplied with <strong></strong><strong>$max</strong><strong></strong> from <strong></strong><strong>$start</strong><strong></strong>. This is intended to implement a previous button. Fieldname(s) for ordering (\s-1ORDER\s0 \s-1BY\s0) (must be comma-separated, could also contain \s-1USING\s0) Fieldname(s) for grouping (\s-1GROUP\s0 \s-1BY\s0) (must be comma-separated, could also contain \s-1HAVING\s0). String which is appended to the end of a \s-1SELECT\s0 statement, can contain any data. Fields which should be returned by a query. If you have specified multiple tables the fieldnames should be unique. If the names are not unique you must specify them along with the tablename (e.g. tab1.field). \s-1NOTE\s0 1: If <strong>!fields</strong> is supplied at setup time, this can not be overridden by $fields. \s-1NOTE\s0 2: The keys for the returned hash normally don't have a table part. Only the fieldname part forms the key. (See !LongNames for an exception.) \s-1NOTE\s0 3: Because the query result is returned in a hash, there can only be one out of multiple fields  with the same name fetched at once. If you specify multiple fields with same name, only one is returned from a query. Which one this actually is, depends on the \s-1DBD\s0 driver. (See !LongNames for an exception.) Name of primary key. DBIx::Recordset assumes that if specified, this is a unique key to the given table(s). DBIx::Recordset can not verify this. You are responsible for specifying the right key. If such a primary exists in your table, you should specify it here, because it helps DBIx::Recordset optimize the building of \s-1WHERE\s0 expressions. See also <strong>!PrimKey</strong></p>
<h3>Execute parameters</h3>
<p>The following parameters specify which action is to be executed:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>=search</strong>
  </dt>
  <dd>
    <p>search data</p>
  </dd>
  <dt>
    <strong>=update</strong>
  </dt>
  <dd>
    <p>update record(s)</p>
  </dd>
  <dt>
    <strong>=insert</strong>
  </dt>
  <dd>
    <p>insert record</p>
  </dd>
  <dt>
    <strong>=delete</strong>
  </dt>
  <dd>
    <p>delete record(s)</p>
  </dd>
  <dt>
    <strong>=empty</strong>
  </dt>
  <dd>
    <p>setup empty object</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>*set = DBIx::Recordset -&gt; Setup (&#92;%params)</strong>
  </dt>
  <dd>
    <p>Setup a new object and connect it to a database and table(s). Collects information about the tables which are needed later. Returns a typglob which can be used to access the object ($set), an array (@set) and a hash (%set). <strong>params:</strong> setup Same as above, but setup only the object, do not tie anything (no array, no hash) <strong>params:</strong> setup Ties an array to a recordset object. The result of a query which is executed by the returned object can be accessed via the tied array. If the array contents are modified, the database is updated accordingly (see Data access below for more details). The first form ties the array to an already existing object, the second one setup a new object. <strong>params:</strong> setup Ties a hash to a recordset object. The hash can be used to access/update/insert single rows of a table: the hash key is identical to the primary key value of the table. (see Data access below for more details) The first form ties the hash to an already existing object, the second one sets up a new object. <strong>params:</strong> setup Ties a hash to a recordset object. The hash can be used to access the fields of the current record of the recordset object. (See Data access below for more details.) The first form ties the hash to an already existing object, the second one sets up a new object. <strong>params:</strong> setup Selects records from the recordsets table(s). The first syntax setups a new DBIx::Recordset object and does the select. The second and third syntax selects from an existing DBIx::Recordset object. <strong>params:</strong> setup (only syntax 1), where  (without $order and $fields) <strong>where:</strong>  (only syntax 3) string for \s-1SQL\s0 \s-1WHERE\s0 expression <strong>fields:</strong> comma separated list of fieldnames to select <strong>order:</strong>  comma separated list of fieldnames to sort on</p>
  </dd>
  <dt>
    <strong>*set = DBIx::Recordset -&gt; Search (&#92;%params)</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>set -&gt; Search (&#92;%params)</strong>
  </dt>
  <dd>
    <p>Does a search on the given tables and prepares data to access them via @set or %set. The first syntax also sets up a new object. <strong>params:</strong> setup (only syntax 1), where, search</p>
  </dd>
  <dt>
    <strong>*set = DBIx::Recordset -&gt; Insert (&#92;%params)</strong>
  </dt>
  <dd>
    <p>Inserts a new record in the recordset table(s). Params should contain one entry for every field for which you want to insert a value. Fieldnames may be prefixed with a '&#92;' in which case they are not processed (quoted) in any way. <strong>params:</strong> setup (only syntax 1), fields Updates one or more records in the recordset table(s). Parameters should contain one entry for every field you want to update. The $where contains the \s-1SQL\s0 \s-1WHERE\s0 condition as a string or as a reference to a hash. If $where is omitted, the where conditions are buily from the parameters. If !PrimKey is given for the table, only that !PrimKey is used for the \s-1WHERE\s0 clause. Fieldnames may be prefixed with a '&#92;', in which case they are not processed (quoted) in any way. <strong>params:</strong> setup (only syntax 1+2), where (only if $where is omitted), fields</p>
  </dd>
  <dt>
    <strong>*set = DBIx::Recordset -&gt; Delete (&#92;%params)</strong>
  </dt>
  <dd>
    <p>Deletes one or more records from the recordsets table(s). <strong>params:</strong> setup (only syntax 1), where</p>
  </dd>
  <dt>
    <strong>*set = DBIx::Recordset -&gt; DeleteWithLinks (&#92;%params)</strong>
  </dt>
  <dd>
    <p>Deletes one or more records from the recordsets table(s). Additonal all record of links with have the \*(C`!OnDelete\*(C' set, are either deleted or the correspending field is set to undef. What to do is determinated by the constants \*(C`odDELETE\*(C' and \*(C`odCLEAR\*(C'. This is very helpful to guaratee the inetgrity of the database. <strong>params:</strong> setup (only syntax 1), where</p>
  </dd>
  <dt>
    <strong>*set = DBIx::Recordset -&gt; Execute (&#92;%params)</strong>
  </dt>
  <dd>
    <p>Executes one of the above methods, depending on the given arguments. If multiple execute parameters are specified, the priority is  =search  =update  =insert  =delete  =empty If none of the above parameters are specified, a search is performed. A search is always performed.  On an \*(C`=update\*(C', the \*(C`!PrimKey\*(C', if given, is looked upon and used for the where part of the \s-1SQL\s0 statement, while all other parameters are updated. <strong>params:</strong> setup (only syntax 1), execute, where, search, fields Same as \s-1DBI\s0. Executes a single \s-1SQL\s0 statement on the open database. Set the record pointer to the initial state, so the next call to \*(C`Next\*(C' returns the first row. Position the record pointer to the first row and returns it. Position the record pointer to the next row and returns it. Position the record pointer to the previous row and returns it. Returns the current row. Returns a reference to an array of all fieldnames of all tables used by the object. Returns a reference to an array of the fieldnames from the last query. Returns a reference to an array of all fieldtypes of all tables used by the object. Returns a reference to an array of the fieldtypes from the last query. Adds a new row to a recordset. The first one adds an empty row, the second one will assign initial data to it. The Add method returns an index into the array where the new record is located.   Example:</p><p>  # Add an empty record   $i = $set -&gt; Add () ;   # Now assign some data   $set[$i]{id} = 5 ;   $set[$i]{name} = &apos;test&apos; ;   # and here it is written to the database   # (without Flush it is written, when the record goes out of scope)   $set -&gt; Flush () ; Add will also set the current record to the newly created empty record. So, you can assign the data by simply using the current record.   # Add an empty record   $set -&gt; Add () ;   # Now assign some data to the new record   $set{id} = 5 ;   $set{name} = &apos;test&apos; ; Returns true if there are more records to fetch from the current recordset. If the $ignoremax parameter is specified and is true, MoreRecords ignores the $max parameter of the last Search. To tell you if there are more records, More actually fetches the next record from the database and stores it in memory. It does not, however, change the current record. Returns a \s-1HTML\s0 form which contains a previous and a next button and all data from %fdat, as hidden fields. When calling the Search method, You must set the $max parameter to the number of rows you want to see at once. After the search and the retrieval of the rows, you can call PrevNextForm to generate the needed buttons for scrolling through the recordset. The second for allows you the specifies addtional parameter, which creates first, previous, next, last and goto buttons. Example:  $set -&gt; PrevNextForm ({-first =&gt; &apos;First&apos;,  -prev =&gt; &apos;&lt;&lt;Back&apos;,                         -next  =&gt; &apos;Next&gt;&gt;&apos;, -last =&gt; &apos;Last&apos;,                         -goto  =&gt; &apos;Goto #&apos;}, &#92;%fdat) The goto button lets you jump to an random record number. If you obmit any of the parameters, the corresponding button will not be shown. The Flush method flushes all data to the database and therefore makes sure that the db is up-to-date. Normally, DBIx::Recordset holds the update in memory until the row is destroyed, by either a new Select/Search or by the Recordsetobject itself is destroyed. With this method you can make sure that every update is really written to the db. Returns true if there is at least one dirty row containing unflushed data.</p>
  </dd>
  <dt>
    <strong>DBIx::Recordset::Undef ($name)</strong>
  </dt>
  <dd>
    <p>Undef takes the name of a typglob and will destroy the array, the hash, and the object. All unwritten data is  written to the db.  All db connections are closed and all memory is freed.   Example:   # this destroys $set, @set and %set   DBIx::Recordset::Undef (&apos;set&apos;) ; Starts a transaction. Calls the \s-1DBI\s0 method begin. Rolls back a transaction. Calls the \s-1DBI\s0 method rollback and makes sure that all internal buffers of DBIx::Recordset are flushed. Commits a transaction. Calls the \s-1DBI\s0 method commit and makes sure that all internal buffers of DBIx::Recordset are flushed. Returns the \s-1DBI\s0 database handle. Returns the \s-1DBI\s0 statement handle of the last select. Returns the name of the table of the recordset object. Returns the name of the table of the recordset object, but removes the string given with !TableFilter, if it is the prefix of the table name. Returns the primary key given in the !PrimKey parameter. Returns the table filter given in the !TableFilter parameter. Returns the record number of the record which will be returned for index 0. Returns the last executed \s-1SQL\s0 Statement. Return the last value of the field defined with !Serial Closes the connection to the database. If $linkname is undef, returns reference to a hash of all links of the object. Otherwise, it returns a reference to the link with the given name. Returns reference to a hash of all links of the object. Returns the name of the link for that field, or &lt;undef&gt; if there is no link for that field. get and/or set an attribute of the table</p><p>key to set/get if present, set key to this value Optional, let you specify another table, then the one use by the recordset object.</p><p>Returns an hash ref with some statistical values.</p>
  </dd>
  <dt>
    <strong>DBIx::Recordset -&gt; LastError ()</strong>
  </dt>
  <dd>
    <p>Returns the last error message, if any. If called in an array context the first element receives the last error message and the second the last error code.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA ACCESS</h2>
        <div class="sectioncontent">
<p>The data which is returned by a <strong>Select</strong> or a <strong>Search</strong> can be accessed in two ways:</p><p>1.) Through an array. Each item of the array corresponds to one of the selected records. Each array-item is a reference to a hash containing an entry for every field.</p><p>Example:  $set[1]{id}	    access the field 'id' of the second record found  $set[3]{name}	    access the field 'name' of the fourth record found</p><p>The record is fetched from the \s-1DBD\s0 driver when you access it the first time and is stored by DBIx::Recordset for later access. If you don't access the records one after each other, the skipped records are not stored and therefore can't be accessed anymore, unless you specify the <strong>!StoreAll</strong> parameter.</p><p>2.) DBIx::Recordset holds a <strong>current record</strong> which can be accessed directly via a hash. The current record is the one you last accessed via the array. After a Select or Search, it is reset to the first record. You can change the current record via the methods <strong>Next</strong>, <strong>Prev</strong>, <strong>First</strong>, <strong>Add</strong>.</p><p>Example:  $set{id}	    access the field 'id' of the current record  $set{name}	    access the field 'name' of the current record</p><p>Instead of doing a <strong>Select</strong> or <strong>Search</strong> you can directly access one row of a table when you have tied a hash to DBIx::Recordset::Hash or have specified the <strong>!HashAsRowKey</strong> Parameter. The hashkey will work as primary key to the table. You must specify the <strong>!PrimKey</strong> as setup parameter.</p><p>Example:  $set{4}{name}	    access the field 'name' of the row with primary key = 4</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MODIFYING DATA DIRECTLY</h2>
        <div class="sectioncontent">
<p>One way to update/insert data into the database is by using the Update, Insert or Execute method of the DBIx::Recordset object. A second way is to directly assign new values to the result of a previous Select/Search.</p><p>Example:</p>
<pre>
  # setup a new object and search all records with name xyz
  *set = DBIx::Recordset -&gt; Search ({'!DataSource' =&gt; 'dbi:db:tab',
</pre>
<p>				     '!PrimKey =&gt; 'id', 				     '!Table'  =&gt; 'tabname', 				     'name'    =&gt; 'xyz'}) ;</p><p>  #now you can update an existing record by assigning new values   #Note: if possible, specify a PrimKey for update to work faster   $set[0]{&apos;name&apos;} = &apos;zyx&apos; ;</p><p>  # or insert a new record by setting up an new array row   $set[9]{&apos;name&apos;} = &apos;foo&apos; ;   $set[9]{&apos;id&apos;}   = 10 ;</p><p>  # if you don&apos;t know the index of a new row you can obtain   # one by using Add   my $i = $set -&gt; Add () ;   $set[$i]{&apos;name&apos;} = &apos;more foo&apos; ;   $set[$i]{&apos;id&apos;}   = 11 ;</p><p>  # or add an empty record via Add and assign the values to the current   # record   $set -&gt; Add () ;   $set{&apos;name&apos;} = &apos;more foo&apos; ;   $set{&apos;id&apos;}   = 11 ;</p><p>  # or insert the data directly via Add   $set -&gt; Add ({&apos;name&apos; =&gt; &apos;even more foo&apos;,                 &apos;id&apos;   =&gt; 12}) ;</p><p>  # NOTE: up to this point, NO data is actually written to the db!</p><p>  # we are done with that object,  Undef will flush all data to the db   DBIx::Recordset::Undef (&apos;set&apos;) ;</p><p>\s-1IMPORTANT:\s0 The data is not written to the database until you explicitly call <strong>flush</strong>, or a new query is started, or the object is destroyed. This is to keep the actual writes to the database to a minimum.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WORKING WITH MULTIPLE TABLES</h2>
        <div class="sectioncontent">
<p>DBIx::Recordset has some nice features to make working with multiple tables and their relations easier.</p><h3>Joins</h3>
<p>First, you can specify more than one table to the <strong>!Table</strong> parameter. If you do so, you need to specify how both tables are related. You do this with <strong>!TabRelation</strong> parameter. This method will access all the specified tables simultanously.</p>
<h3>Join Example:</h3>
<p>If you have the following two tables, where the field street_id is a pointer to the table street:</p><p>  table name   name      char (30),   street_id  integer</p><p>  table street   id        integer,   street    char (30),   city      char (30)</p><p>You can perform the following search:</p><p>  *set = DBIx::Recordset -&gt; Search ({&apos;!DataSource&apos; =&gt; &apos;dbi:drv:db&apos;,                      &apos;!Table&apos;      =&gt; &apos;name, street&apos;,                      &apos;!TabRelation&apos;=&gt; &apos;name.street_id = street.id&apos;}) ;</p><p>The result is that you get a set which contains the fields <strong>name</strong>, <strong>street_id</strong>, <strong>street</strong>, <strong>city</strong> and <strong>id</strong>, where id is always equal to street_id. If there are multiple streets for one name, you will get as many records for that name as there are streets present for it. For this reason, this approach works best when you have a 1:1 relation.</p><p>It is also possible to specify <strong>JOINs</strong>. Here's how:</p><p>  *set = DBIx::Recordset -&gt; Search ({             &apos;!DataSource&apos; =&gt; &apos;dbi:drv:db&apos;,             &apos;!Table&apos;   =&gt; &apos;name, street&apos;,             &apos;!TabJoin&apos; =&gt; &apos;name LEFT JOIN street ON (name.street_id=street.id)&apos;}) ;</p><p>The difference between this and the first example is that this version also returns a record even if neither table contains a record for the given id. The way it's done depends on the \s-1JOIN\s0 you are given (\s-1LEFT/RIGHT/INNER\s0) (see your \s-1SQL\s0 documentation for details about JOINs).</p>
<h3>Links</h3>
<p>If you have 1:n relations between two tables, the following may be a better way to handle it:</p><p>  *set = DBIx::Recordset -&gt; Search ({&apos;!DataSource&apos; =&gt; &apos;dbi:drv:db&apos;,                      &apos;!Table&apos;      =&gt; &apos;name&apos;,                      &apos;!Links&apos;      =&gt; {                         &apos;-street&apos;  =&gt; {                             &apos;!Table&apos; =&gt; &apos;street&apos;,                             &apos;!LinkedField&apos; =&gt; &apos;id&apos;,                             &apos;!MainField&apos;   =&gt; &apos;street_id&apos;                             }                         }                     }) ;</p><p>After that query, every record will contain the fields <strong>name</strong> and <strong>street_id</strong>. Additionally, there is a pseudofield named <strong>-street</strong>, which could be used to access another recordset object, which is the result of a query where <strong>street_id = id</strong>. Use</p><p>  $set{name} to access the name field   $set{-street}{street} to access the first street (as long as the                                     current record of the subobject isn&apos;t                                     modified)</p><p>  $set{-street}[0]{street}      first street   $set{-street}[1]{street}      second street   $set{-street}[2]{street}      third street</p><p>  $set[2]{-street}[1]{street} to access the second street of the                                     third name</p><p>You can have multiple linked tables in one recordset; you can also nest linked tables or link a table to itself.</p><p><strong>\s-1NOTE:\s0</strong> If you select only some fields and not all, the field which is specified by '!MainField' must be also given in the '!Fields' or '$fields' parameter.</p><p><strong>\s-1NOTE:\s0</strong> See also <strong>Automatic detection of links</strong> below</p>
<h3>LinkName</h3>
<p>In the LinkName feature you may specify a \*(L"name\*(R" for every table. A name is one or more fields which gives a human readable \*(L"key\*(R" of that record. For example in the above example <strong>id</strong> is the key of the record, but the human readable form is <strong>street</strong>.</p><p>  *set = DBIx::Recordset -&gt; Search ({&apos;!DataSource&apos; =&gt; &apos;dbi:drv:db&apos;,                      &apos;!Table&apos;      =&gt; &apos;name&apos;,                      &apos;!LinkName&apos;   =&gt; 1,                      &apos;!Links&apos;      =&gt; {                         &apos;-street&apos;  =&gt; {                             &apos;!Table&apos; =&gt; &apos;street&apos;,                             &apos;!LinkedField&apos; =&gt; &apos;id&apos;,                             &apos;!MainField&apos;   =&gt; &apos;street_id&apos;,                             &apos;!NameField&apos;   =&gt; &apos;street&apos;                             }                         }                     }) ;</p><p>For every record in the table, this example will return the fields:</p><p>  name  street_id  street</p><p>If you have more complex records, you may also specify more than one field in !NameField and pass it as an reference to an array e.g. ['street', 'city']. In this case, the result will contain</p><p>  name  street_id  street  city</p><p>If you set !LinkName to 2, the result will contain the fields</p><p>  name  street_id  STREET_ID</p><p>where \s-1STREET_ID\s0 contains the values of the street and city fields joined together. If you set !LinkName to 3, you will get only</p><p>  name  street_id</p><p>where street_id contains the values of the street and city fields joined together.</p><p>\s-1NOTE:\s0 The !NameField can also be specified as a table attribute with the function TableAttr. In this case you don't need to specify it in every link. When a !NameField is given in a link description, it overrides the table attribute.</p>
<h3>Automatic detection of links</h3>
<p>DBIx::Recordset and DBIx::Database will try to automatically detect links between tables based on the field and table names. For this feature to work, the field which points to another table must consist of the table name and the field name of the destination joined together with an underscore (as in the above example name.street_id). Then it will automatically recognized as a pointer to street.id.</p><p>  *set = DBIx::Recordset -&gt; Search ({&apos;!DataSource&apos; =&gt; &apos;dbi:drv:db&apos;,                                      &apos;!Table&apos;      =&gt; &apos;name&apos;) ;</p><p>is enough. DBIx::Recordset will automatically add the !Links attribute. Additionally, DBIx::Recordset adds a backlink (which starts with a star ('*')), so for the table street, in our above example, there will be a link, named *name, which is a pointer from table street to all records in the table name where street.id is equal to name.street_id.</p><p>You may use the !Links attribute to specify links which can not be automatically detected.</p><p>\s-1NOTE:\s0 To specify more then one link from one table to another table, you may prefix the field name with an specifier followed by two underscores. Example:  first_\|_street_id, second_\|_street_id. The link (and backlink) names are named with the prefix, e.g. -first_\|_street and the backlink *first_\|_name.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DBIx::Database</h2>
        <div class="sectioncontent">
<p>The DBIx::Database object gathers information about a datasource. Its main purpose is to create, at startup, an object which retrieves all necessary information from the database.  This object detects links between tables and stores this information for use by the DBIx::Recordset objects. There are additional methods which allow you to add kinds of information which cannot be retreived automatically.</p><p>Example:</p><p>  $db = DBIx::Database -&gt; new ({&apos;!DataSource&apos;   =&gt;  $DSN,                                 &apos;!Username&apos;     =&gt;  $User,                                 &apos;!Password&apos;     =&gt;  $Password,                                 &apos;!KeepOpen&apos;     =&gt; 1}) ;</p><p>   *set = DBIx::Recordset -&gt; Search ({&apos;!DataSource&apos;   =&gt;  $db,                                       &apos;!Table&apos;        =&gt;  &apos;foo&apos;,                                      })  ; Specifies the database to which to connect. Driver/DB/Host. Same as the first parameter to the \s-1DBI\s0 connect function. Username (optional) Password (optional)</p>
<dl class='dl-vertical'>
  <dt>
    &#92;%attr
  </dt>
  <dd>
    <p>Attributes (optional) Same as the attribute parameter to the \s-1DBI\s0 connect function. Name for this DBIx::Database object to save as. The name can be used in DBIx::Database::Get, or as !DataSource parameter in call to the DBIx::Recordset object. This is intended as mechanism to retrieve the necessary metadata; for example, when your web server starts (e.g. in the startup.pl file of mod_perl). Here you can give the database object a name. Later in your mod_perl or Embperl scripts, you can use this metadata by specifying this name. This will speed up the setup of DBIx::Recordset object without the need to pass a reference to the DBIx::Database object. Normaly the database connection will be closed after the metadata has been retrieved from the database. This makes sure you don't get trouble when using the new method in a mod_perl startup file. You can keep the connection open to use them in further setup calls to DBIx::Recordset objects. When the database is not kept open, you must specify the \*(C`!Password\*(C' parameter each time the recordset has to be reopend. same as setup parameter !TableFilter same as setup parameter !DoOnConnect If set, forces <em>DBIx::Database</em> to \*(C`undef\*(C' any preexisting database handle and call connect in any case. This is useful in together with <em>Apache::DBI</em>. While the database connection are still kept open by <em>Apache::DBI</em>, <em>Apache::DBI</em> preforms a test if the handle is still vaild (which DBIx::Database itself wouldn't).</p>
  </dd>

</dl>
<p>You also can specify a hashref which can contain the following parameters:</p><p>!DataSource, !Username, !Password, !DBIAttr, !SaveAs, !KeepOpen, !TableFilter, !DoOnConnect, !Reconnect returns the database handle (only if you specify !KeepOpen when calling \*(C`new\*(C'). $name = The name of the DBIx::Database object you wish to retrieve</p><p>Get a DBIx::Database object which has already been set up based on the name. get and/or set an attribute for an specfic table. Name of table(s). You may use '*' instead of the table name to specify a default value which applies to all tables for which no other value is specified. key to set/get if present, set key to this value Get and/or set a link description for an table. If no $linkname is given, returns all links for that table. Name of table(s) Name of link to set/get if present, this must be a reference to a hash with the link decription. See !Links for more information. Get and/or set the meta data for the given table. Name of table(s) If present, this must be a reference to a hash with the new metadata. You should only use this if you really know what you are doing. Clears the metadata for the given table, The next call to DBIx::Database -&gt; new will recreate the metadata. Useful if your table has changed (e.g. by \s-1ALTER\s0 \s-1TABLE\s0). This returns a reference to a hash of the keys to all the tables of the datasource. Returns a reference to an array of all fieldnames for the given table. Returns a reference to an array of all fieldtypes for the given table. Same as \s-1DBI\s0. Executes a single \s-1SQL\s0 statement on the open database. The CreateTables method is used to create an modify the schema of your database. The idea is to define the schema as a Perl data structure and give it to this function, it will compare the actual schema of the database with the one provided and creates new tables, new fields or drop fields as necessary. It also sets the permission on the tables and is able to create indices for the tables. It will <strong>never</strong> drop a whole table! \s-1NOTE:\s0 Create tables cannot deteminate changes of the datatype of a fields, because \s-1DBI\s0 is not able to provide this information in a standard way. Either the name of a file which contains the schema or a array ref. See below how this schema must look like. schemaname (only used for Oracle) User that should be granted access. See \*(C`!Grant\*(C' parameter. If set to true, access privilegs are revoked and granted again for already existing tables. That is necessary when $user changes. If set to true contrains are cleared/set for already existing fields. \s-1DBI\s0 doesn't provide a database independ way to check which contrains already exists.</p><h3>Schema definition</h3>
<p>If give as a filename, the file must contain an hash %DBDefault and an array @DBSchema. The first gives default and the second is an array of hashs. Every of this hash defines one table.</p><p>Example:</p><p>  %DBDefault =</p><p>    (     &apos;!Grant&apos; =&gt;         [         &apos;select&apos;,         &apos;insert&apos;,         &apos;update&apos;,         &apos;delete&apos;,         ],     )      ;</p><p>  @DBSchema = (</p><p>    {     &apos;!Table&apos; =&gt; &apos;language&apos;,     &apos;!Fields&apos; =&gt;         [         &apos;id&apos;            =&gt; &apos;char (2)&apos;,         &apos;directory&apos;     =&gt; &apos;varchar(40)&apos;,         &apos;name&apos;          =&gt; &apos;varchar(40)&apos;,         &apos;europe&apos;        =&gt; &apos;bool&apos;,         ],     &apos;!PrimKey&apos; =&gt; &apos;id&apos;,     &apos;!Default&apos; =&gt;         {         &apos;europe&apos;    =&gt; 1,         },     &apos;!Init&apos; =&gt;         [         {&apos;id&apos; =&gt; &apos;de&apos;, &apos;directory&apos; =&gt; &apos;html_49&apos;, &apos;name&apos; =&gt; &apos;deutsch&apos;},         {&apos;id&apos; =&gt; &apos;en&apos;, &apos;directory&apos; =&gt; &apos;html_76&apos;, &apos;name&apos; =&gt; &apos;english&apos;},         {&apos;id&apos; =&gt; &apos;fr&apos;, &apos;directory&apos; =&gt; &apos;html_31&apos;, &apos;name&apos; =&gt; &apos;french&apos;},         ],    &apos;!Index&apos; =&gt;         [         &apos;directory&apos; =&gt; &apos;&apos;,         ]</p><p>    },</p><p>  );</p><p>The hash which defines a table can have the following keys:</p>
<dl class='dl-vertical'>
  <dt>
    !Table
  </dt>
  <dd>
    <p>Gives the table name</p>
  </dd>
  <dt>
    !Fields
  </dt>
  <dd>
    <p>Array with field names and types. There a some types which a translated database specifc. You can define more database specific translation in Compat.pm.</p>
<dl class='dl-vertical'>
  <dt>
    bit
  </dt>
  <dd>
    <p>boolean</p>
  </dd>
  <dt>
    counter
  </dt>
  <dd>
    <p>If an autoincrementing integer. For databases (like Oracle) that doesn't have such a datatype a sequence is generated to provide the autoincrement value and the fields will be of type integer.</p>
  </dd>
  <dt>
    tinytext
  </dt>
  <dd>
    <p>variables length text with up to 255 characters</p>
  </dd>
  <dt>
    text
  </dt>
  <dd>
    <p>variables length text</p>
  </dd>

</dl>

  </dd>
  <dt>
    !PrimKey
  </dt>
  <dd>
    <p>Name of the primary key</p>
  </dd>
  <dt>
    !For
  </dt>
  <dd>
    <p>Can contain the same key as the table definintion, but is only executed for a specifc database. Example:     &apos;!For&apos; =&gt; {         &apos;Oracle&apos; =&gt; {             &apos;!Constraints&apos; =&gt;                 {                 &apos;web_id&apos;           =&gt; [&apos;foreign key&apos; =&gt; &apos;REFERENCES web (id)&apos;],</p><p>                &apos;prim_\|_menu_id&apos;    =&gt; [&apos;!Name&apos;       =&gt; &apos;web_prim_menu_id&apos;,                                        &apos;foreign key&apos; =&gt; &apos;REFERENCES menu (id)&apos;,                                        &apos;not null&apos;    =&gt; &apos;&apos;],                 }             },         },</p>
  </dd>
  <dt>
    !Contraints
  </dt>
  <dd>
    <p>Used to define constraints. See example under \*(C`!For\*(C'.</p>
<dl class='dl-vertical'>
  <dt>
    !Name =&gt; &lt;name&gt;
  </dt>
  <dd>
    
  </dd>
  <dt>
    &lt;constraint&gt; =&gt; &lt;second part&gt;
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>
  <dt>
    !Init
  </dt>
  <dd>
    <p>Used to initialy populate the table.</p>
  </dd>
  <dt>
    !Default
  </dt>
  <dd>
    <p>Used to set a default value for a field, when the table is created. This doesn't have any affect for further INSERTs/UPDATEs.</p>
  </dd>
  <dt>
    !Grant
  </dt>
  <dd>
    <p>Give the rights that should be grant to $user</p>
  </dd>
  <dt>
    !Index
  </dt>
  <dd>
    <p>Gives the names for the fields for which indices should be created. If the second parameter for an index is not empty, it gives the index name, otherwise a default name is used. Drops <strong>all</strong> tables. Use with care! schemaname (only used for Oracle) User that should be revoked access. See \*(C`!Grant\*(C' parameter.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Casesensitive/insensitiv</h2>
        <div class="sectioncontent">
<p>In \s-1SQL\s0 all names (field/tablenames etc.) should be case insensitive. Various \s-1DBMS\s0 handle the case of names differently. For that reason <em>DBIx::Recordset</em> translates all names to lower case, ensuring your application will run with any \s-1DBMS\s0, regardless of whether names are returned in lower/uppercase by the \s-1DBMS\s0. Some \s-1DBMS\s0 are case-sensitive (I know at least Sybase, depending on your collate settings). To use such a case-sensitive \s-1DBMS\s0, it is best to create your database with all names written in lowercase. In a situation where this isn't possible, you can set $PreserveCase to 1. In this case DBIx::Recordset will not perform any case translation. <strong>\s-1NOTE:\s0</strong> $PreserveCase is still experimental and may change in future releases. Some operations in Perl (i.e. \*(C`foreach\*(C', assigning arrays) need to know the size of the whole array. When Perl needs to know the size of an array it call the method \*(C`FETCHSIZE\*(C'. Since not all \s-1DBD\s0 drivers/DBMS returns the number of selected rows after an \s-1SQL\s0 \*(C`SELECT\*(C', the only way to really determine the number of selected rows would be to fetch them all from the \s-1DBMS\s0. Since this could cause a lot of work, it may be very inefficent. Therefore <em>DBIx::Recordset</em> by default calls <em>die()</em> when Perl calls \s-1FETCHSIZE\s0. If you know your \s-1DBD\s0 drivers returns the correct value in $sth -&gt; \*(C`rows\*(C' after the execution of an \*(C`SELECT\*(C', you can set $FetchsizeWarn to zero to let \*(C`FETCHSIZE\*(C' return the value from $sth -&gt; \*(C`rows\*(C'. Setting it to 1 will cause <em>DBIx::Recordset</em> to only issue a warning, but perform the operation.</p><p><strong>\s-1NOTE:\s0</strong> Since I don't have enough experience with the behaviour of this feature with different \s-1DBMS\s0, this is considered experimental.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUGGING</h2>
        <div class="sectioncontent">
<p>DBIx::Recordset is able to write a logfile so you can see what's happening inside. There are two public variables and the \*(C`!Debug\*(C' parameter used for this purpose: Debuglevel  0 = off  1 = log only errors  2 = show connect, disconnect and \s-1SQL\s0 Statements  3 = some more infos  4 = much infos $DBIx::Recordset::Debug sets the default debug level for new objects, \*(C`!Debug\*(C' can be used to set the debuglevel on a per object basis.</p>
<dl class='dl-vertical'>
  <dt>
    DBIx::Recordset::LOG
  </dt>
  <dd>
    <p>The filehandle used for logging. The default is \s-1STDOUT\s0, unless you are running under HTML::Embperl, in which case the default is the Embperl logfile.</p>
  </dd>

</dl>
<p> Example:</p><p>    # open the log file     open LOG, "&gt;test.log" or die "Cannot open test.log" ;</p><p>    # assign filehandle     *DBIx::Recordset::LOG = &#92;*LOG ;</p><p>    # set debugging level     $DBIx::Recordset::Debug = 2 ;</p><p>    # now you can create a new DBIx::Recordset object</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SECURITY</h2>
        <div class="sectioncontent">
<p>Since one possible application of DBIx::Recordset is its use in a web-server environment, some attention should paid to security issues.</p><p>The current version of DBIx::Recordset does not include extended security management, but some features can be used to make your database access safer. (More security features will come in future releases.)</p><p>First of all, use the security feature of your database. Assign the web server process as few rights as possible.</p><p>The greatest security risk is when you feed DBIx::Recordset a hash which contains the formfield data posted to the web server. Somebody who knows DBIx::Recordset can post other parameters than those you would expect a normal user to post. For this reason, a primary issue is to override all parameters which should <strong>never</strong> be posted by your script.</p><p>Example:  *set = DBIx::Recordset -&gt; Search ({%fdat, 				                    ('!DataSource'	=&gt; \*(L"dbi:$Driver:$DB\*(R", 				                     '!Table'	=&gt;  \*(L"$Table\*(R")}) ;</p><p>(assuming your posted form data is in %fdat). The above call will make sure that nobody from outside can override the values supplied by $Driver, $DB and $Table.</p><p>It is also wise to initialize your objects by supplying parameters which can not be changed.</p><p>Somewhere in your script startup (or at server startup time) add a setup call:</p><p> *set = DBIx::Recordset-&gt; Setup ({&apos;!DataSource&apos;  =&gt;  "dbi:$Driver:$DB",                                                 &apos;!Table&apos;          =&gt;  "$Table",                                                 &apos;!Fields&apos;         =&gt;  "a, b, c"}) ;</p><p>Later, when you process a request you can write:</p><p> $set -&gt; Search (&#92;%fdat) ;</p><p>This will make sure that only the database specified by $Driver, $DB, the table specified by $Table and the Fields a, b, and c can be accessed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Compatibility with different DBD drivers</h2>
        <div class="sectioncontent">
<p>I have put a great deal of effort into making DBIx::Recordset run with various \s-1DBD\s0 drivers. The problem is that not all necessary information is specified via the \s-1DBI\s0 interface (yet). So I have made the module <strong>DBIx::Compat</strong> which gives information about the difference between various \s-1DBD\s0 drivers and their underlying database systems. Currently, there are definitions for:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>DBD::mSQL</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>DBD::mysql</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>DBD::Pg</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>DBD::Solid</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1DBD::ODBC\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1DBD::CSV\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>DBD::Oracle (requires DBD::Oracle 0.60 or higher)</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>DBD::Sysbase</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>DBD::Informix</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>DBD::InterBase</strong>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>DBIx::Recordset has been tested with all those \s-1DBD\s0 drivers (on Linux 2.0.32, except \s-1DBD::ODBC\s0, which has been tested on Windows '95 using Access 7 and with \s-1MS\s0 \s-1SQL\s0 Server).</p><p>If you want to use another \s-1DBD\s0 driver with DBIx::Recordset, it may be necessary to create an entry for that driver. See <strong>perldoc DBIx::Compat</strong> for more information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>The following are some examples of how to use DBIx::Recordset. The Examples are from the test.pl. The examples show the DBIx::Recordset call first, followed by the generated \s-1SQL\s0 command.</p><p> *set = DBIx::Recordset-&gt; Setup ({&apos;!DataSource&apos;  =&gt;  "dbi:$Driver:$DB",                                             &apos;!Table&apos;      =&gt;  "$Table"}) ;</p><p>Setup a DBIx::Recordset for driver $Driver, database $DB to access table $Table.</p><p> $set -&gt; Select () ;</p><p> SELECT * from &lt;table&gt; ;</p><p> $set -&gt; Select ({&apos;id&apos;=&gt;2}) ;  is the same as  $set1 -&gt; Select (&apos;id=2&apos;) ;</p><p> SELECT * from &lt;table&gt; WHERE id = 2 ;</p><p> $set -&gt; Search({ &apos;$fields&apos; =&gt; &apos;id, balance AS paid - total &apos; }) ;</p><p> SELECT id, balance AS paid - total FROM &lt;table&gt;</p><p> $set -&gt; Select ({name =&gt; "Second Name&#92;tFirst Name"}) ;</p><p> SELECT * from &lt;table&gt; WHERE name = &apos;Second Name&apos; or name = &apos;First Name&apos; ;</p><p> $set1 -&gt; Select ({value =&gt; "9991 9992&#92;t9993",                        &apos;$valuesplit&apos; =&gt; &apos; |&#92;t&apos;}) ;</p><p> SELECT * from &lt;table&gt; WHERE value = 9991 or value = 9992 or value = 9993 ;</p><p> $set -&gt; Select ({&apos;+name&value&apos; =&gt; "9992"}) ;</p><p> SELECT * from &lt;table&gt; WHERE name = &apos;9992&apos; or value = 9992 ;</p><p> $set -&gt; Select ({&apos;+name&value&apos; =&gt; "Second Name&#92;t9991"}) ;</p><p> SELECT * from &lt;table&gt; WHERE (name = &apos;Second Name&apos; or name = &apos;9991) or                             (value = 0 or value = 9991) ;</p><p> $set -&gt; Search ({id =&gt; 1,name =&gt; &apos;First Name&apos;,addon =&gt; &apos;Is&apos;}) ;</p><p> SELECT * from &lt;table&gt; WHERE id = 1 and name = &apos;First Name&apos; and addon = &apos;Is&apos; ;</p><p> $set1 -&gt; Search ({&apos;$start&apos;=&gt;0,&apos;$max&apos;=&gt;2, &apos;$order&apos;=&gt;&apos;id&apos;})  or die "not ok ($DBI::errstr)" ;</p><p> SELECT * from &lt;table&gt; ORDER BY id ;  B&lt;Note:&gt; Because of the B&lt;start&gt; and B&lt;max&gt; only records 0,1 will be returned</p><p> $set1 -&gt; Search ({&apos;$start&apos;=&gt;0,&apos;$max&apos;=&gt;2, &apos;$next&apos;=&gt;1, &apos;$order&apos;=&gt;&apos;id&apos;})  or die "not ok ($DBI::errstr)" ;</p><p> SELECT * from &lt;table&gt; ORDER BY id ;  B&lt;Note:&gt; Because of the B&lt;start&gt;, B&lt;max&gt; and B&lt;next&gt; only records 2,3 will be returned</p><p> $set1 -&gt; Search ({&apos;$start&apos;=&gt;2,&apos;$max&apos;=&gt;1, &apos;$prev&apos;=&gt;1, &apos;$order&apos;=&gt;&apos;id&apos;})  or die "not ok ($DBI::errstr)" ;</p><p> SELECT * from &lt;table&gt; ORDER BY id ;  B&lt;Note:&gt; Because of the B&lt;start&gt;, B&lt;max&gt; and B&lt;prev&gt; only records 0,1,2 will be returned</p><p> $set1 -&gt; Search ({&apos;$start&apos;=&gt;5,&apos;$max&apos;=&gt;5, &apos;$next&apos;=&gt;1, &apos;$order&apos;=&gt;&apos;id&apos;})  or die "not ok ($DBI::errstr)" ;</p><p> SELECT * from &lt;table&gt; ORDER BY id ;  B&lt;Note:&gt; Because of the B&lt;start&gt;, B&lt;max&gt; and B&lt;next&gt; only records 5-9 will be returned</p><p> *set6 = DBIx::Recordset -&gt; Search ({  &apos;!DataSource&apos;   =&gt;  "dbi:$Driver:$DB",                                                         &apos;!Table&apos;            =&gt;  "t1, t2",                                                         &apos;!TabRelation&apos;  =&gt;         "t1.value=t2.value",                                         &apos;!Fields&apos;       =&gt;  &apos;id, name, text&apos;,                                         &apos;id&apos;            =&gt;  "2&#92;t4" }) or die "not ok ($DBI::errstr)" ;</p><p> SELECT id, name, text FROM t1, t2 WHERE (id=2 or id=4) and t1.value=t2.value ;</p><p> $set6 -&gt; Search ({&apos;name&apos;            =&gt;  "Fourth Name" }) or die "not ok ($DBI::errstr)" ;  SELECT id, name, text FROM t1, t2 WHERE (name = &apos;Fourth Name&apos;) and t1.value=t2.value ;</p><p> $set6 -&gt; Search ({&apos;id&apos;            =&gt;  3,                   &apos;$operator&apos;     =&gt;  &apos;&lt;&apos; }) or die "not ok ($DBI::errstr)" ;</p><p> SELECT id, name, text FROM t1, t2 WHERE (id &lt; 3) and t1.value=t2.value ;</p><p> $set6 -&gt; Search ({&apos;id&apos;            =&gt;  4,                   &apos;name&apos;          =&gt;  &apos;Second Name&apos;,                   &apos;*id&apos;           =&gt;  &apos;&lt;&apos;,                   &apos;*name&apos;         =&gt;  &apos;&lt;&gt;&apos; }) or die "not ok ($DBI::errstr)" ;</p><p> SELECT id, name, text FROM t1, t2 WHERE (id&lt;4 and name &lt;&gt; &apos;Second Name&apos;) and t1.value=t2.value ;</p><p> $set6 -&gt; Search ({&apos;id&apos;            =&gt;  2,                   &apos;name&apos;          =&gt;  &apos;Fourth Name&apos;,                   &apos;*id&apos;           =&gt;  &apos;&lt;&apos;,                   &apos;*name&apos;         =&gt;  &apos;=&apos;,                   &apos;$conj&apos;         =&gt;  &apos;or&apos; }) or die "not ok ($DBI::errstr)" ;</p><p> SELECT id, name, text FROM t1, t2 WHERE (id&lt;2 or name=&apos;Fourth Name&apos;) and t1.value=t2.value ;</p><p> $set6 -&gt; Search ({&apos;+id|addon&apos;     =&gt;  "7&#92;tit",                   &apos;name&apos;          =&gt;  &apos;Fourth Name&apos;,                   &apos;*id&apos;           =&gt;  &apos;&lt;&apos;,                   &apos;*addon&apos;        =&gt;  &apos;=&apos;,                   &apos;*name&apos;         =&gt;  &apos;&lt;&gt;&apos;,                   &apos;$conj&apos;         =&gt;  &apos;and&apos; }) or die "not ok ($DBI::errstr)" ;</p><p> SELECT id, name, text FROM t1, t2 WHERE (t1.value=t2.value) and (  ((name &lt;&gt; Fourth Name)) and (  (  id &lt; 7  or  addon = 7)  or  (  id &lt; 0  or  addon = 0)))</p><p> $set6 -&gt; Search ({&apos;+id|addon&apos;     =&gt;  "6&#92;tit",                   &apos;name&apos;          =&gt;  &apos;Fourth Name&apos;,                   &apos;*id&apos;           =&gt;  &apos;&gt;&apos;,                   &apos;*addon&apos;        =&gt;  &apos;&lt;&gt;&apos;,                   &apos;*name&apos;         =&gt;  &apos;=&apos;,                   &apos;$compconj&apos;     =&gt;  &apos;and&apos;,                   &apos;$conj&apos;         =&gt;  &apos;or&apos; }) or die "not ok ($DBI::errstr)" ;</p><p> SELECT id, name, text FROM t1, t2 WHERE (t1.value=t2.value) and (  ((name = Fourth Name)) or (  (  id &gt; 6 and addon &lt;&gt; 6)  or  (  id &gt; 0 and addon &lt;&gt; 0))) ;</p><p> *set7 = DBIx::Recordset -&gt; Search ({  &apos;!DataSource&apos;   =&gt;  "dbi:$Driver:$DB",                                     &apos;!Table&apos;        =&gt;  "t1, t2",                                     &apos;!TabRelation&apos;  =&gt;  "t1.id=t2.id",                                     &apos;!Fields&apos;       =&gt;  &apos;name, typ&apos;}) or die "not ok ($DBI::errstr)" ;</p><p> SELECT name, typ FROM t1, t2 WHERE t1.id=t2.id ;</p><p> %h = (&apos;id&apos;    =&gt; 22,       &apos;name2&apos; =&gt; &apos;sqlinsert id 22&apos;,       &apos;value2&apos;=&gt; 1022) ;</p><p> *set9 = DBIx::Recordset -&gt; Insert ({%h,                                     (&apos;!DataSource&apos;   =&gt;  "dbi:$Driver:$DB",                                      &apos;!Table&apos;        =&gt;  "$Table[1]")}) or die "not ok ($DBI::errstr)" ;</p><p> INSERT INTO &lt;table&gt; (id, name2, value2) VALUES (22, &apos;sqlinsert id 22&apos;, 1022) ;</p><p> %h = (&apos;id&apos;    =&gt; 22,       &apos;name2&apos; =&gt; &apos;sqlinsert id 22u&apos;,       &apos;value2&apos;=&gt; 2022) ;</p><p> $set9 -&gt; Update (&#92;%h, &apos;id=22&apos;) or die "not ok ($DBI::errstr)" ;</p><p> UPDATE &lt;table&gt; WHERE id=22 SET id=22, name2=&apos;sqlinsert id 22u&apos;, value2=2022 ;</p><p> %h = (&apos;id&apos;    =&gt; 21,       &apos;name2&apos; =&gt; &apos;sqlinsert id 21u&apos;,       &apos;value2&apos;=&gt; 2021) ;</p><p> *set10 = DBIx::Recordset -&gt; Update ({%h,                                     (&apos;!DataSource&apos;   =&gt;  "dbi:$Driver:$DB",                                      &apos;!Table&apos;        =&gt;  "$Table[1]",                                      &apos;!PrimKey&apos;      =&gt;  &apos;id&apos;)}) or die "not ok ($DBI::errstr)" ;</p><p> UPDATE &lt;table&gt; WHERE id=21 SET name2=&apos;sqlinsert id 21u&apos;, value2=2021 ;</p><p> %h = (&apos;id&apos;    =&gt; 21,       &apos;name2&apos; =&gt; &apos;Ready for delete 21u&apos;,       &apos;value2&apos;=&gt; 202331) ;</p><p> *set11 = DBIx::Recordset -&gt; Delete ({%h,                                     (&apos;!DataSource&apos;   =&gt;  "dbi:$Driver:$DB",                                      &apos;!Table&apos;        =&gt;  "$Table[1]",                                      &apos;!PrimKey&apos;      =&gt;  &apos;id&apos;)}) or die "not ok ($DBI::errstr)" ;</p><p> DELETE FROM &lt;table&gt; WHERE id = 21 ;</p><p> *set12 = DBIx::Recordset -&gt; Execute ({&apos;id&apos;  =&gt; 20,                                    &apos;*id&apos; =&gt; &apos;&lt;&apos;,                                    &apos;!DataSource&apos;   =&gt;  "dbi:$Driver:$DB",                                    &apos;!Table&apos;        =&gt;  "$Table[1]",                                    &apos;!PrimKey&apos;      =&gt;  &apos;id&apos;}) or die "not ok ($DBI::errstr)" ;</p><p> SELECT * FROM &lt;table&gt; WHERE id&lt;20 ;</p><p> *set13 = DBIx::Recordset -&gt; Execute ({&apos;=search&apos; =&gt; &apos;ok&apos;,                     &apos;name&apos;  =&gt; &apos;Fourth Name&apos;,                     &apos;!DataSource&apos;   =&gt;  "dbi:$Driver:$DB",                     &apos;!Table&apos;        =&gt;  "$Table[0]",                     &apos;!PrimKey&apos;      =&gt;  &apos;id&apos;}) or die "not ok ($DBI::errstr)" ;</p><p> SELECT * FROM &lt;table&gt;  WHERE   ((name = Fourth Name))</p><p> $set12 -&gt; Execute ({&apos;=insert&apos; =&gt; &apos;ok&apos;,                     &apos;id&apos;     =&gt; 31,                     &apos;name2&apos;  =&gt; &apos;insert by exec&apos;,                     &apos;value2&apos;  =&gt; 3031,  # Execute should ignore the following params, since it is already setup                     &apos;!DataSource&apos;   =&gt;  "dbi:$Driver:$DB",                     &apos;!Table&apos;        =&gt;  "quztr",                     &apos;!PrimKey&apos;      =&gt;  &apos;id99&apos;}) or die "not ok ($DBI::errstr)" ;</p><p> SELECT * FROM &lt;table&gt; ;</p><p> $set12 -&gt; Execute ({&apos;=update&apos; =&gt; &apos;ok&apos;,                     &apos;id&apos;     =&gt; 31,                     &apos;name2&apos;  =&gt; &apos;update by exec&apos;}) or die "not ok ($DBI::errstr)" ;</p><p> UPDATE &lt;table&gt; SET name2=update by exec,id=31 WHERE id=31 ;</p><p> $set12 -&gt; Execute ({&apos;=insert&apos; =&gt; &apos;ok&apos;,                     &apos;id&apos;     =&gt; 32,                     &apos;name2&apos;  =&gt; &apos;insert/upd by exec&apos;,                     &apos;value2&apos;  =&gt; 3032}) or die "not ok ($DBI::errstr)" ;</p><p> INSERT INTO &lt;table&gt; (name2,id,value2) VALUES (insert/upd by exec,32,3032) ;</p><p> $set12 -&gt; Execute ({&apos;=delete&apos; =&gt; &apos;ok&apos;,                     &apos;id&apos;     =&gt; 32,                     &apos;name2&apos;  =&gt; &apos;ins/update by exec&apos;,                     &apos;value2&apos;  =&gt; 3032}) or die "not ok ($DBI::errstr)" ;</p><p> DELETE FROM &lt;table&gt; WHERE id=32 ;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>As far as possible for me, support will be available via the \s-1DBI\s0 Users' mailing list. (dbi-user@fugue.com)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>G.Richter (richter@dev.ecos.de)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO DBIx::Recordset&hellip;</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>Perl</em>\|(1)
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1<em>DBI\s0</em>\|(3)
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>DBIx::Compat</em>\|(3)
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>HTML::Embperl</em>\|(3) http://perl.apache.org/embperl/
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>Tie::DBI</em>\|(3) http://stein.cshl.org/~lstein/Tie-DBI/
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="DBIx::README.3pm.html"><span aria-hidden="true">&larr;</span> DBIx::README.3pm: Easy dbi helper (perl inside sql and blessed results)</a></li>
   <li class="next"><a href="DBIx::Recordset::DBSeq.3pm.html">DBIx::Recordset::DBSeq.3pm: Sequence generator in dbi database <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>POE::Component::Syndicator: A poe component base class which implements the observer pattern</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A poe component base class which implements the observer pattern">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="POE::Component::Syndicator (3pm) manual">
  <meta name="twitter:description" content="A poe component base class which implements the observer pattern">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpoe-component-syndicator-perl-POE::Component::Syndicator-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/POE::Component::Syndicator.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="POE::Component::Syndicator (3pm) manual" />
  <meta property="og:description" content="A poe component base class which implements the observer pattern" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpoe-component-syndicator-perl-POE::Component::Syndicator-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">POE::Component::Syndicator<small> (3pm)</small></h1>
        <p class="lead">A poe component base class which implements the observer pattern</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/POE::Component::Syndicator.3pm.html">
      <span itemprop="name">POE::Component::Syndicator: A poe component base class which implements the observer pattern</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpoe-component-syndicator-perl/">
      <span itemprop="name">libpoe-component-syndicator-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/POE::Component::Syndicator.3pm.html">
      <span itemprop="name">POE::Component::Syndicator: A poe component base class which implements the observer pattern</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 package POE::Component::IRC;

 use strict;
 use warnings;
 use POE;
 use base &apos;POE::Component::Syndicator&apos;;

 # our constructor
 sub spawn {
     my ($package, %args) = @_;

     # process arguments...

     my $self = bless &#92;%args, $package;

     # set up our plugin system and POE session
     $self-&gt;_syndicator_init(
         prefix        =&gt; &apos;irc_&apos;,
         reg_prefix    =&gt; &apos;PCI_&apos;,
         types         =&gt; [SERVER =&gt; &apos;S&apos;, USER =&gt; &apos;U&apos;],
         object_states =&gt; [qw(
             syndicator_started
             shutdown
         )],
     );

     return $self;
 }

 sub syndicator_started {
     my ($kernel, $self) = @_[KERNEL, OBJECT];

     # connect to a server, etc...
 }

 # plugin handler for SERVER event &apos;hlagh&apos;
 sub S_hlagh {
     # ...
 }

 sub shutdown {
     my ($kernel, $self) = @_[KERNEL, OBJECT];

     # disconnect from a server, etc...

     # shut down the syndicator
     $self-&gt;_syndicator_destroy();
 }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>POE::Component::Syndicator is a base class for \s-1POE\s0 components which need to handle a persistent resource (e.g. a connection to an \s-1IRC\s0 server) for one or more sessions in an extendable way.</p><p>This module (as well as Object::Pluggable, which this module inherits from) was born out of POE::Component::IRC, the guts of which quickly spread to other \s-1POE\s0 components. Now they can all inherit from this module instead.</p><p>The component provides an event queue, which can be managed with the methods documented below. It handles delivery of events to the object itself, all interested plugins, and all interested sessions.</p><h3>Component lifetime</h3>
<p>You start by calling \*(C`_syndicator_init\*(C', which will create a \s-1POE\s0 session with your object as its heap, and a few event handlers installed. The events described in \*(L"Local events\*(R" delimit the start and end of the session's lifetime. In between those, interested plugins and sessions will receive various events, usually starting with \*(C`syndicator_registered\*(C'. In this phase, your subclass and plugins can call the methods and send the events documented below. When the component has been shut down, sessions (but not plugins) will receive a \*(C`syndicator_shutdown\*(C' event. After this, the component will become unusable.</p>
<h3>A note on events</h3>
<p>In this document, an <em>event</em> (unless explicitly referred to as a <em>\s-1POE\s0 event</em>) is defined as a message originating from POE::Component::Syndicator, delivered to plugins (and the subclass) via plugin methods and to registered sessions as \s-1POE\s0 events.</p><p>Interested sessions are considered consumers only, so they always receive copies of event arguments, whereas interested plugins and subclasses receive scalar references to them. This allows them to alter, add, or remove event arguments before sessions (or even other plugins) receive them. For more information about plugins, see Object::Pluggable's documentation. A subclass does not have to register for plugin events.</p><p>Two event types are supported: \s-1SERVER\s0 and \s-1USER\s0, though their names can be overridden (see \*(C`_syndicator_init\*(C').</p><p><em>\s-1SERVER\s0 events</em></p><p>These represent data received from the network or some other outside resource (usually a server, hence the default name).</p><p>\s-1SERVER\s0 events are generated by the \*(C`send_event*\*(C' methods. These events are delivered to the subclass and plugins (method \*(C`S_foo\*(C') and interested sessions (event \*(C`syndicator_foo\*(C').</p><p><em>\s-1USER\s0 events</em></p><p>These represent commands about to be sent to a server or some other resource.</p><p>\s-1USER\s0 events are generated by \*(C`send_user_event\*(C'. In addition, all \s-1POE\s0 events sent to this component's session (e.g. with \*(C`yield\*(C') which do not have a handler will generate corresponding \s-1USER\s0 events. \s-1USER\s0 events are considered more private, so they are only delivered to the subclass and plugins, not to sessions.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PRIVATE METHODS</h2>
        <div class="sectioncontent">
<p>The following methods should only be called by a subclass. You should call this in your constructor. It initializes Object::Pluggable, creates the Syndicator's \s-1POE\s0 session, and calls the \*(C`syndicator_started\*(C' \s-1POE\s0 events. It takes the following arguments:</p><p><strong>'prefix'</strong>, a prefix for all your event names, when sent to interested sessions. If you don't supply this, Object::Pluggable's default (<strong>'pluggable'</strong>) will be used.</p><p><strong>'reg_prefix'</strong>, the prefix for the \*(C`register()\*(C'/\*(C`unregister()\*(C' plugin methods  If you don't supply this, Object::Pluggable's default (<strong>'plugin_'</strong>) will be used.</p><p><strong>'debug'</strong>, a boolean, if true, will cause a warning to be printed every time a plugin event handler raises an exception.</p><p><strong>'types'</strong>, a 2-element arrayref of the types of events that your component will support, or a 4-element (2 pairs) arrayref where the event types are keys and their abbrevations (used as plugin event method prefixes) are values (see \*(L"A note on events\*(R" and Object::Pluggable for more information). The two event types are fundamentally different, so make sure you supply them in the right order. If you don't provide this argument, \*(C`[ SERVER =&gt; &apos;S&apos;, USER =&gt; &apos;U&apos; ]\*(C' will be used.</p><p><strong>'register_signal'</strong>, the name of the register signal (see \*(L"\s-1SIGNALS\s0\*(R"). Defaults to <strong>'\s-1SYNDICATOR_REGISTER\s0'</strong>.</p><p><strong>'shutdown_signal'</strong>, the name of the shutdown signal (see \*(L"\s-1SIGNALS\s0\*(R"). Defaults to <strong>'\s-1SYNDICATOR_SHUTDOWN\s0'</strong>.</p><p><strong>'object_states'</strong> an arrayref of additional object states to add to the \s-1POE\s0 session. Same as the 'object_states' argument to POE::Session's \*(C`create\*(C' method. You'll want to add a handler for at least the \*(C`syndicator_started\*(C' event.</p><p><strong>'options'</strong>, a hash of options for POE::Session's constructor.</p><p>If you call \*(C`_syndicator_init\*(C' from inside another \s-1POE\s0 session, the component will automatically register that session as wanting all events. That session will first receive a \*(C`syndicator_registered\*(C' event. Call this method when you want Syndicator to clean up (delete all plugins, etc) and make sure it won't keep the \s-1POE\s0 session alive after all remaining events have been processed. A \*(C`syndicator_shutdown\*(C' event (or similar, depending on the prefix you chose) will be generated. Any argument passed to \*(C`_syndicator_destroy\*(C' will be passed along with that event.</p><p><strong>Note:</strong> this method will clear all alarms for the \s-1POE\s0 session.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PUBLIC METHODS</h2>
        <div class="sectioncontent">
<p>Returns the component's \s-1POE\s0 session id. Returns the component's \s-1POE\s0 session alias. This method provides an alternative, object-based means of posting events to the component. First argument is the event to post, following arguments are sent as arguments to the resultant post. This method provides an alternative, object-based means of calling events to the component. First argument is the event to call, following arguments are sent as arguments to the resultant call. Adds a new \s-1SERVER\s0 event onto the end of the queue. The event will be processed after other pending events, if any. First argument is an event name, the rest are the event arguments.</p><p> $component-&gt;send_event(&apos;irc_public, &apos;foo!bar@baz.com&apos;, [&apos;#mychan&apos;], &apos;message&apos;); Adds a new \s-1SERVER\s0 event to the start of the queue. The event will be the next one to be processed. First argument is an event name, the rest are the event arguments. Sends a new \s-1SERVER\s0 event immediately. Execution of the current \s-1POE\s0 event will be suspended (i.e. this call will block) until the new event has been processed by the component class and all plugins. First argument is an event name, the rest are the event arguments. Sends a new \s-1USER\s0 event immediately. You should call this before every command you send to your remote server/resource. Only the subclass and plugins will see this event. Takes two arguments, an event name and an arrayref of arguments. Returns one of the \*(C`EAT\*(C' constants listed in Object::Pluggable::Constants. After this method returns, the arrayref's contents may have been modified by the subclass or plugins.</p><p> $component-&gt;send_user_event(&apos;PRIVMSG&apos;, &apos;#mychan&apos;, &apos;message&apos;); This method provides a way of posting delayed events to the component. The first argument is an arrayref consisting of the delayed command to post and any command arguments. The second argument is the time in seconds that one wishes to delay the command being posted.</p><p> my $alarm_id = $component-&gt;delay([&apos;mode&apos;, $channel, &apos;+o&apos;, $dude], 60); This method removes a previously scheduled delayed event from the component. Takes one argument, the \*(C`alarm_id\*(C' that was returned by a \*(C`delay\*(C' method call. Returns an arrayref of arguments to the event that was originally requested to be delayed.</p><p> my $arrayref = $component-&gt;delay_remove($alarm_id);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EVENTS</h2>
        <div class="sectioncontent">
<h3>Local events</h3>
<p>The component will send the following \s-1POE\s0 events to its session.</p><p><em></em><strong>\*(C`syndicator_started\*(C'</strong><em></em></p><p>Called after the session has been started (like \*(C`_start\*(C' in POE::Kernel. This is where you should do your POE-related setup work such as adding new event handlers to the session.</p><p><em></em><strong>\*(C`syndicator_stopped\*(C'</strong><em></em></p><p>Called right before the session is about to die (like \*(C`_stop\*(C' in POE::Kernel).</p>
<h3>Input events</h3>
<p>Other \s-1POE\s0 sessions can send the following \s-1POE\s0 events to the Syndicator's session.</p><p><em></em><strong>\*(C`register\*(C'</strong><em></em></p><p>Takes any amount of arguments: a list of event names that your session wants to listen for, minus the prefix (specified in \*(L"_syndicator_init\*(R" in \*(C`syndicator_init\*(C').</p><p> $kernel-&gt;post(&apos;my syndicator&apos;, &apos;register&apos;, qw(join part quit kick));</p><p>Registering for the special event <strong>'all'</strong> will cause it to send all events to your session. Calling it with no event names is equivalent to calling it with <strong>'all'</strong> as an argumente.</p><p>Registering will generate a \*(C`syndicator_registered\*(C' event that your session can trap.</p><p>Registering with multiple component sessions can be tricky, especially if one wants to marry up sessions/objects, etc. Check the \s-1SIGNALS\s0 section for an alternative method of registering with multiple components.</p><p><em></em><strong>\*(C`unregister\*(C'</strong><em></em></p><p>Takes any amount of arguments: a list of event names which you <em>don't</em> want to receive. If you've previously done a \*(C`register\*(C' for a particular event which you no longer care about, this event will tell the component to stop sending them to you. (If you haven't, it just ignores you. No big deal.) Calling it with no event names is equivalent to calling it with <strong>'all'</strong> as an argument.</p><p>If you have registered for the special event <strong>'all'</strong>, attempting to unregister individual events will not work. This is a 'feature'.</p><p><em></em><strong>\*(C`shutdown\*(C'</strong><em></em></p><p>By default, POE::Component::Syndicator sessions never go away. You can send its session a \*(C`shutdown\*(C' event manually to make it delete itself. Terminating multiple Syndicators can be tricky. Check the \*(L"\s-1SIGNALS\s0\*(R" section for a method of doing that.</p><p><em></em><strong>\*(C`_default\*(C'</strong><em></em></p><p>Any \s-1POE\s0 events sent to the Syndicator's session which do not have a handler will go to the Syndicator's \*(C`_default\*(C' handler, will generate \*(L"\s-1USER\s0 events\*(R" of the same name. If you install your own \*(C`_default\*(C' handler, make sure you do the same thing before you handle an event:</p><p> use Object::Pluggable::Constants &apos;PLUGIN_EAT_ALL&apos;;</p><p> $poe_kernel-&gt;state(&apos;_default&apos;, $self, &apos;_\|_default&apos;);</p><p> sub _\|_default {      my ($self, $event, $args) = @_[OBJECT, ARG0, ARG1];</p><p>     # do nothing if a plugin eats the event      return if $self-&gt;send_user_event($event, [@$args]) == PLUGIN_EAT_ALL;</p><p>     # handle the event      # ...  }</p><p>Note that the handler for the \*(C`_default\*(C' event must be named something other than '_default', because that name is reserved for the plugin-type default handler (see the Object::Pluggable docs).</p>
<h3>Output events</h3>
<p>The Syndicator will send the following events at various times. The <strong>'syndicator_'</strong> prefix in these event names can be customized with a <strong>'prefix'</strong> argument to \*(L"_syndicator_init\*(R" in \*(C`_syndicator_init\*(C'.</p><p><em></em><strong>\*(C`syndicator_registered\*(C'</strong><em></em></p><p>Sent once to the requesting session on registration (see \*(C`register\*(C'). \*(C`ARG0\*(C' is a reference to the component's object.</p><p><em></em><strong>\*(C`syndicator_shutdown\*(C'</strong><em></em></p><p>Sent to all interested sessions when the component has been shut down. See \*(C`_syndicator_destroy\*(C'.</p><p><em></em><strong>\*(C`syndicator_delay_set\*(C'</strong><em></em></p><p>Sent to the subclass, plugins, and all interested sessions on a successful addition of a delayed event using the \*(C`delay\*(C' method. \*(C`ARG0\*(C' will be the alarm_id which can be used later with \*(C`delay_remove\*(C'. Subsequent parameters are the arguments that were passed to \*(C`delay\*(C'.</p><p><em></em><strong>\*(C`syndicator_delay_removed\*(C'</strong><em></em></p><p>Sent to the subclass, plugins, and all interested sessions when a delayed event is successfully removed. \*(C`ARG0\*(C' will be the alarm_id that was removed. Subsequent parameters are the arguments that were passed to \*(C`delay\*(C'.</p><p><em>All other events</em></p><p>All other events sent by the Syndicator are \s-1USER\s0 events (generated with \*(C`send_user_event\*(C') and \s-1SERVER\s0 events (generated with \*(C`send_event*\*(C') which will be delivered normally. Your subclass and plugins are responsible for generating them.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNALS</h2>
        <div class="sectioncontent">
<p>The component will handle a number of custom signals that you may send using POE::Kernel's \*(C`signal\*(C' method. They allow any session to communicate with every instance of the component in certain ways without having references to their objects or knowing about their sessions. The names of these signals can be customized with \*(C`_syndicator_init\*(C'. Registers for an event with the component. See \*(C`register\*(C'. Causes a 'shutdown' event to be sent to your session. Any arguments to the signal will be passed along to the event. That's where you should clean up and call \*(C`_syndicator_destroy\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Hinrik O\*:rn Sigur\*(d-sson, hinrik.sig@gmail.com, Chris \*(C`BinGOs\*(C' Williams chris@bingosnet.co.uk, Apocalypse apocal@cpan.org, and probably others.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2011 Hinrik O\*:rn Sigur\*(d-sson</p><p>This program is free software, you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="POE::Component::Server::SOAP::Response.3pm.html"><span aria-hidden="true">&larr;</span> POE::Component::Server::SOAP::Response.3pm: Emulates a simplehttp::response object, used to store soap data</a></li>
   <li class="next"><a href="POE::Filter::HTTP::Parser.3pm.html">POE::Filter::HTTP::Parser.3pm: A http poe filter for http clients or servers <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

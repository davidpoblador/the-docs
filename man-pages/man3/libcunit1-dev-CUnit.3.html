<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CUnit: A unit testing framework for c</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A unit testing framework for c">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="CUnit (3) manual">
  <meta name="twitter:description" content="A unit testing framework for c">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcunit1-dev-CUnit-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libcunit1-dev-CUnit.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="CUnit (3) manual" />
  <meta property="og:description" content="A unit testing framework for c" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcunit1-dev-CUnit-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">CUnit<small> (3)</small></h1>
        <p class="lead">A unit testing framework for c</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/CUnit.3.html">
      <span itemprop="name">CUnit: A unit testing framework for c</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcunit1-dev/">
      <span itemprop="name">libcunit1-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/CUnit.3.html">
      <span itemprop="name">CUnit: A unit testing framework for c</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>#include &lt;CUnit/CUnit.h&gt;</strong></p>
  </dt>
  <dd>
    <p>ASSERT definitions, test management.</p>
  </dd>
  <dt>
    <p><strong>#include &lt;CUnit/Automated.h&gt;</strong></p>
  </dt>
  <dd>
    <p>Automated interface with xml output.</p>
  </dd>
  <dt>
    <p><strong>#include &lt;CUnit/Basic.h&gt;</strong></p>
  </dt>
  <dd>
    <p>Basic interface with console output.</p>
  </dd>
  <dt>
    <p><strong>#include &lt;CUnit/Console.h&gt;</strong></p>
  </dt>
  <dd>
    <p>Interactive console interface.</p>
  </dd>
  <dt>
    <p><strong>#include &lt;CUnit/CUCurses.h&gt;</strong></p>
  </dt>
  <dd>
    <p>Interactive curses interface.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>CUnit is a system for writing, administering, and running unit tests in C. It uses a simple framework for building test structures, and provides a rich set of assertions for testing common data types.  CUnit is built as a static library which is linked with the user's testing code.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STRUCTURE & GENERAL USAGE</h2>
        <div class="sectioncontent">
<p>CUnit is a combination of a platform-independent framework with various user interfaces. The core framework provides basic support for managing a test registry, suites, and test cases. The user interfaces facilitate interaction with the framework to run tests and view results.</p><p>The basic hierarchichal organization of CUnit is depicted here:</p>
<pre>
                  Test Registry
                        |
           -----------------------------
           |                           |
        Suite '1'      . . . .      Suite 'N'
           |                           |
     ---------------             ---------------
     |             |             |             |
  Test '11' ... Test '1M'     Test 'N1' ... Test 'NM'
</pre>
<p>Individual test cases are packaged into suites, which are registered with the active test registry.  Suites can have setup and teardown functions which are automatically called before and after running the suite's tests. All suites/tests in the registry may be run using a single function call, or selected suites or tests can be run.</p><p>The typical usage of CUnit is: 1. Write functions for tests (and suite init/cleanup if necessary). 2. Initialize the test registry using <strong>CU_initialize_registry()</strong> 3. Add test suites to the registry using <strong>CU_add_suite()</strong> 4. Add test cases to the suites using <strong>CU_add_test()</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p>5. Run tests using the desired interface, e.g.</p>
  </dt>
  <dd>
    <p><strong>CU_console_run_tests()</strong> to use the interactive console. 6. Cleanup the test registry using <strong>CU_cleanup_registry()</strong></p>
  </dd>

</dl>
<p>All public names in CUnit are prefixed with 'CU_'.  This helps minimize clashes with names in user code.  Note that earlier versions CUnit used different names without this prefix.  The older API names are deprecated but still supported.  To use the older names, user code must now be compiled with <strong>USE_DEPRECATED_CUNIT_NAMES</strong> defined.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING TEST FUNCTIONS</h2>
        <div class="sectioncontent">
<p>A "test" is a C function having the signature: <strong>void test_func(void).</strong> There are no restrictions on the content of a test function, except that it should not modify the CUnit framework (e.g. add suites or tests, modify the test registry, or initiate a test run).  A test function may call other functions (which also may not modify the framework). Registering a test will cause it's function to be run when the test is run.</p><p>CUnit provides a set of assertions for testing logical conditions.  The success or failure of these assertions is tracked by the framework, and can be viewed when a test run is complete.  Each assertion tests a single logical condition, and fails if the condition evaluates to CU_FALSE. Upon failure, the test continues unless the user chooses the 'xxx_FATAL' version of an assertion.  In that case, the test function returns immediately.</p><p>CUnit provides a set of assertions for testing logical conditions.  The success or failure of these assertions is tracked by the framework, and can be viewed when a test run is complete.</p><p>Each assertion tests a single logical condition, and fails if the condition evaluates to CU_FALSE.  Upon failure, the test function continues unless the user chooses the 'xxx_FATAL' version of an assertion.  In that case, the test function is aborted and returns immediately. <strong>FATAL versions of assertions should be used with caution!</strong> There is no opportunity for the test function to clean up after itself once a FATAL assertion fails.  The normal suite cleanup function is not affected, however.</p><p>There are also special "assertions" for registering a pass or fail with the framework without performing a logical test.  These are useful for testing flow of control or other conditions not requiring a logical test.</p><p>Other functions called by a registered test function may use the CUnit assertions freely.  These assertions will be counted for the calling function.  They may also use FATAL versions of assertions - failure will abort the original test function and its entire call chain.</p><p>The assertions defined by CUnit are:</p><p><strong>#include &lt;CUnit/CUnit.h&gt;</strong></p><p><strong>CU_ASSERT(int expression)</strong></p><p><strong>CU_ASSERT_FATAL(int expression)</strong></p><p><strong>CU_TEST(int expression)</strong></p><p><strong>CU_TEST_FATAL(int expression)</strong></p><p>Assert that expression is CU_TRUE (non-zero).</p><p><strong>CU_ASSERT_TRUE(value)</strong></p><p><strong>CU_ASSERT_TRUE_FATAL(value)</strong></p><p>Assert that value is CU_TRUE (non-zero).</p><p><strong>CU_ASSERT_FALSE(value)</strong></p><p><strong>CU_ASSERT_FALSE_FATAL(value)</strong></p><p>Assert that value is CU_FALSE (zero).</p><p><strong>CU_ASSERT_EQUAL(actual, expected)</strong></p><p><strong>CU_ASSERT_EQUAL_FATAL(actual, expected)</strong></p><p>Assert that actual == expected.</p><p><strong>CU_ASSERT_NOT_EQUAL(actual, expected)</strong></p><p><strong>CU_ASSERT_NOT_EQUAL_FATAL(actual, expected)</strong></p><p>Assert that actual != expected.</p><p><strong>CU_ASSERT_PTR_EQUAL(actual, expected)</strong></p><p><strong>CU_ASSERT_PTR_EQUAL_FATAL(actual, expected)</strong></p><p>Assert that pointers actual == expected.</p><p><strong>CU_ASSERT_PTR_NOT_EQUAL(actual, expected)</strong></p><p><strong>CU_ASSERT_PTR_NOT_EQUAL_FATAL(actual, expected)</strong></p><p>Assert that pointers actual != expected.</p><p><strong>CU_ASSERT_PTR_NULL(value)</strong></p><p><strong>CU_ASSERT_PTR_NULL_FATAL(value)</strong></p><p>Assert that pointer value == NULL.</p><p><strong>CU_ASSERT_PTR_NOT_NULL(value)</strong></p><p><strong>CU_ASSERT_PTR_NOT_NULL_FATAL(value)</strong></p><p>Assert that pointer value != NULL.</p><p><strong>CU_ASSERT_STRING_EQUAL(actual, expected)</strong></p><p><strong>CU_ASSERT_STRING_EQUAL_FATAL(actual, expected)</strong></p><p>Assert that strings actual and expected are equivalent.</p><p><strong>CU_ASSERT_STRING_NOT_EQUAL(actual, expected)</strong></p><p><strong>CU_ASSERT_STRING_NOT_EQUAL_FATAL(actual, expected)</strong></p><p>Assert that strings actual and expected differ.</p><p><strong>CU_ASSERT_NSTRING_EQUAL(actual, expected, count)</strong></p><p><strong>CU_ASSERT_NSTRING_EQUAL_FATAL(actual, expected, count)</strong></p><p>Assert that 1st count chars of actual and expected are the same.</p><p><strong>CU_ASSERT_NSTRING_NOT_EQUAL(actual, expected, count)</strong></p><p><strong>CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(actual, expected, count)</strong></p><p>Assert that 1st count chars of actual and expected differ.</p><p><strong>CU_ASSERT_DOUBLE_EQUAL(actual, expected, granularity)</strong></p><p><strong>CU_ASSERT_DOUBLE_EQUAL_FATAL(actual, expected, granularity)</strong></p><p>Assert that |actual - expected| &lt;= |granularity|.</p><p>Math library must be linked in for this assertion.</p><p><strong>CU_ASSERT_DOUBLE_NOT_EQUAL(actual, expected, granularity)</strong></p><p><strong>CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(actual, expected, granularity)</strong></p><p>Assert that |actual - expected| &gt; |granularity|.</p><p>Math library must be linked in for this assertion.</p><p><strong>CU_PASS(message)</strong></p><p>Register a success without performing a logical test.</p><p><strong>CU_FAIL(message)</strong></p><p><strong>CU_FAIL_FATAL(message)</strong></p><p>Register a failure without performing a logical test.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE TEST REGISTRY</h2>
        <div class="sectioncontent">
<p>The test registry is the repository for suites and associated tests. The user normally only needs to initialize the registry before use and clean up afterwards.  However, other functions are provided to manipulate the registry when necessary.</p><p>The main functions needed by clients are:</p><p><strong>#include &lt;CUnit/TestDB.h&gt;</strong> (included automatically by &lt;CUnit/CUnit.h&gt;)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_ErrorCode CU_initialize_registry(void)</strong></p>
  </dt>
  <dd>
    <p>Initializes the framework.  This function should be called before any other CUnit functions.  Failure to do so will likely result in a crash. An error status code is returned:</p>
<dl class='dl-vertical'>
  <dt>
    <p>CUE_SUCCESS</p>
  </dt>
  <dd>
    <p>if initialization is successful.</p>
  </dd>
  <dt>
    <p>CUE_NOMEMORY</p>
  </dt>
  <dd>
    <p>if memory allocation failed.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong>CU_BOOL CU_registry_initialized(void)</strong></p>
  </dt>
  <dd>
    <p>Checks whether the framework has been initialized.  This may be useful if the registry setup is distributed over multiple files that need to make sure the registry is ready for test registration.</p>
  </dd>
  <dt>
    <p><strong>void CU_cleanup_registry(void)</strong></p>
  </dt>
  <dd>
    <p>Cleans up and releases memory used by the framework.  No CUnit functions (other than <strong>CU_initialize_registry()</strong> ) should be called after this function.  Failure to call <strong>CU_cleanup_registry()</strong> will result in memory leaks.  Note also that this function will destroy all suites (and associated tests) in the registry.</p>
  </dd>

</dl>
<p>Other registry functions are primarily for internal and testing purposes. However, general users may find use for them and should be aware of them. These include:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_pTestRegistry CU_get_registry(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve a pointer to the active test registry.  The registry is a variable of data type CU_Testregistry (declared in &lt;CUnit/TestDB.h&gt;). Note that the returned pointer will be invalidated by a call to <strong>CU_cleanup_registry()</strong> or <strong>CU_initialize_registry()</strong> .</p>
  </dd>
  <dt>
    <p><strong>CU_pTestRegistry CU_set_registry(CU_pTestRegistry pTestRegistry)</strong></p>
  </dt>
  <dd>
    <p>Replace the active registry with the specified one.  A pointer to the previous registry is returned. <strong>It is the caller's responsibility to destroy the old registry.</strong> This can be accomplished using <strong>CU_destroy_existing_registry()</strong> on the returned pointer.  Alternatively, the old registry can be set as the active one.  A subsequent call to <strong>CU_cleanup_registry()</strong> will then destroy it automatically.  Care should be taken not to explicitly destroy a registry that is set as the active one.  This will result in multiple frees of the same memory and a likely crash.</p>
  </dd>
  <dt>
    <p><strong>CU_pTestRegistry CU_create_new_registry(void)</strong></p>
  </dt>
  <dd>
    <p>Create a new registry and return a pointer to it.  The new registry will not contain any suites or tests.  It is the caller's responsibility to destroy the new registry by one of the mechanisms described previously.</p>
  </dd>
  <dt>
    <p><strong>void CU_destroy_existing_registry(CU_pTestRegistry* ppRegistry)</strong></p>
  </dt>
  <dd>
    <p>Destroy the specified test registry, including any registered suites.  This function should not be called for a registry which is set as the active test registry.  This will result in a multiple free of the same memory when <strong>CU_cleanup_registry()</strong> is called.  ppRegistry may not be NULL, but the pointer it points to may be.  Note that *ppRegistry will be NULL on return.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MANAGING TESTS AND SUITES</h2>
        <div class="sectioncontent">
<p>In order for a test to be run by CUnit, it must be added to a test collection (suite) which is registered with the test registry.</p><h3>Adding Suites to the Registry</h3>
<p>The first step in setting up a test system is creating and registering one or more test collections (suites).  Each suite has a name which may be used to reference the suite.  Therefore, it is recommended (but not required) that each registered suite have a unique name.  The current implementation does not support the creation of suites independent of the test registry.  Suites are simultaneously created and added to the active registry as follows.</p><p><strong>#include &lt;CUnit/TestDB.h&gt;</strong> (included automatically by &lt;CUnit/CUnit.h&gt;)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_pSuite CU_add_suite(const char* strName, CU_InitializeFunc pInit,</strong></p>
  </dt>
  <dd>
    <p>CU_CleanupFunc pClean)" This creates and registers a new suite having the specified name, initialization function, and cleanup function.  A pointer to the new suite is returned for use in adding tests to the suite.  This pointer will be NULL if a fatal error occurs.  In addition, the framework error status is set as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p>CUE_SUCCESS</p>
  </dt>
  <dd>
    <p>The suite was successfully created and registered.</p>
  </dd>
  <dt>
    <p>CUE_NOREGISTRY</p>
  </dt>
  <dd>
    <p>Error: Test Registry is not initialized.</p>
  </dd>
  <dt>
    <p>CUE_NO_SUITENAME</p>
  </dt>
  <dd>
    <p>Error: Suite name is not specified or NULL.</p>
  </dd>
  <dt>
    <p>CUE_DUP_SUITE</p>
  </dt>
  <dd>
    <p>Warning: The registry already has a suite with this name.</p>
  </dd>
  <dt>
    <p>CUE_NOMEMORY</p>
  </dt>
  <dd>
    <p>Error: Memory allocation failed.</p>
  </dd>

</dl>
<ul>
<li><p>The initialization and cleanup functions are optional.  Both are C functions having the signature <strong>int func_name(void).</strong> These functions can perform setup and teardown operations needed to support the suite's tests.  They are called before and after the suite's tests are run, even if only 1 of the suite's tests is run.  They take no arguments, and should return NULL if they complete successfully (non-NULL otherwise).  If either function is not required for a particular suite, pass NULL to <strong>CU_add_suite().</strong></p></li>
</ul>
  </dd>

</dl>

<h3>Adding Tests to Suites</h3>
<p>Tests are created and added to suites.  Each test has a name which may be used to reference the test later.  Therefore, it is recommended (but not required) that the name be unique among all tests added to a single suite. The current implementation does not support the creation of tests independent of registered suites.  Tests are simultaneously created and added to a suite as follows.</p><p><strong>#include &lt;CUnit/TestDB.h&gt;</strong> (included automatically by &lt;CUnit/CUnit.h&gt;)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_pTest  CU_add_test(CU_pSuite pSuite, const char* strName, CU_TestFunc</strong></p>
  </dt>
  <dd>
    <p>pTestFunc)" This creates a new test having the specified name and test function, and adds it to the indicated suite.  The suite should have been previously created using <strong>CU_add_suite().</strong> A pointer to the new test is returned, which will be NULL if a fatal error occurred.  In addition, the framework error status is set as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p>CUE_SUCCESS</p>
  </dt>
  <dd>
    <p>The test was successfully created and added.</p>
  </dd>
  <dt>
    <p>CUE_NOREGISTRY</p>
  </dt>
  <dd>
    <p>Error: Test Registry is not initialized.</p>
  </dd>
  <dt>
    <p>CUE_NOSUITE</p>
  </dt>
  <dd>
    <p>Error: Specified suite is NULL or invalid.</p>
  </dd>
  <dt>
    <p>CUE_NO_TESTNAME</p>
  </dt>
  <dd>
    <p>Error: Test name is not specified or NULL.</p>
  </dd>
  <dt>
    <p>CUE_NOTEST</p>
  </dt>
  <dd>
    <p>Error: Test function is not specified or NULL.</p>
  </dd>
  <dt>
    <p>CUE_DUP_TEST</p>
  </dt>
  <dd>
    <p>Warning: The suite already has a test with this name.</p>
  </dd>
  <dt>
    <p>CUE_NOMEMORY</p>
  </dt>
  <dd>
    <p>Error: Memory allocation failed.</p>
  </dd>

</dl>

  </dd>

</dl>

<h3>Activation of Suites and Tests</h3>
<p>A suite or test must be active to be executed during a test run (all suites and tests are active by default upon creation).  The active state of a suite or test is available as pSuite-&gt;fActive and pTest-&gt;fActive, respectively.  The flag will be CU_TRUE when the entity is active, CU_FALSE otherwise.  Use the following functions to selectively deactivate suites and tests to choose subsets of tests to run dynamically.  Note that it is a framework error to deactivate a test or suite and then specifically request that it be run.</p><p><strong>#include &lt;CUnit/TestDB.h&gt;</strong> (included automatically by &lt;CUnit/CUnit.h&gt;)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_ErrorCode CU_set_suite_active(CU_pSuite pSuite, CU_BOOL fNewActive)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>CU_ErrorCode CU_set_test_active(CU_pTest pTest, CU_BOOL fNewActive)</strong></p>
  </dt>
  <dd>
    <p>Pass CU_TRUE to these functions to activate a suite/test, CU_FALSE to deactivate it.  These functions return CUE_NOSUITE and CUE_NOTEST, respectively, if the specified suite or test is NULL.</p>
  </dd>

</dl>

<h3>Modifying Other Attributes of Suites and Tests</h3>
<p>Normally the attributes of suites and tests are set at creation time.  In some cases, a client may wish to manipulate these to modify the test structure dynamically.  The following functions are provided for this purpose, and should be used instead of directly setting the value of the data structure members.  All return CUE_SUCCESS on success, and the indicated error code on failure.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_ErrorCode CU_set_suite_name(CU_pSuite pSuite, const char *strNewName)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>CU_ErrorCode CU_set_test_name(CU_pTest pTest, const char *strNewName)</strong></p>
  </dt>
  <dd>
    <p>These functions change the name of registered suites and tests.  The current names are available as the <strong>pSuite-&gt;pName&lt;/I&gt;</strong> and <strong>pTest-&gt;pName</strong> data structure members.  If the suite or test is NULL, then CUE_NOSUITE or CUE_NOTEST is returned, respectively.  If strNewName is NULL, then CUE_NO_SUITENAME or CUE_NO_TESTNAME is returned, respectively.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_ErrorCode CU_set_suite_initfunc(CU_pSuite pSuite, CU_InitializeFunc pNewInit)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>CU_ErrorCode CU_set_suite_cleanupfunc(CU_pSuite pSuite, CU_CleanupFunc pNewClean)</strong></p>
  </dt>
  <dd>
    <p>These functions change the initialization and cleanup functions for a registered suite. The current functions are available as the <strong>pSuite-&gt;pInitializeFunc</strong> and <strong>pSuite-&gt;pCleanupFunc</strong> data structure members.  If the suite is NULL then CUE_NOSUITE is returned.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_ErrorCode CU_set_test_func(CU_pTest pTest, CU_TestFunc pNewFunc)</strong></p>
  </dt>
  <dd>
    <p>This function changes the test function for a registered test.  The current test function is available as the <strong>pTest-&gt;pTestFunc&lt;/I&gt;</strong> data structure member.  If either pTest or pNewFunc is NULL, then CUE_NOTEST is returned.</p>
  </dd>

</dl>

<h3>Lookup of Individual Suites and Tests</h3>
<p>In most cases, clients will have references to registered suites and tests as pointers returned from <strong>CU_add_suite()</strong> and <strong>CU_add_test().</strong> Occassionally, a client may need to be able to retrieve a reference to a suite or test. The following functions are provided to assist clients with this when the client has some information about the entity (name or order of registration).  In cases where nothing is known about the suite or test, the client will need to iterate the internal data structures to enumerate the suites and tests.  This is not directly supported in the client API.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_pSuite CU_get_suite(const char* strName)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>CU_pSuite CU_get_suite_at_pos(unsigned int pos)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_suite_pos(CU_pSuite pSuite)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_suite_pos_by_name(const char* strName)</strong></p>
  </dt>
  <dd>
    <p>&lt;/P&gt; These functions facilitate lookup of suites registered in the active test registry. The first 2 functions allow lookup of the suite by name or position and return NULL if the suite cannot be found.  The position is a 1-based index in the range [1 .. <strong>CU_get_registry()</strong> -&gt;uiNumberOfSuites].  This may be helpful when suites having duplicate names are registered, in which case lookup by name can only retrieve the 1st suite having that name.  The second 2 functions help the client identify the position of a registered suite. These return 0 if the suite cannot be found.  In addition, all these functions set the CUnit error state to CUE_NOREGISTRY&gt; if the registry is not initialized.  As appropriate, CUE_NO_SUITENAME is set if strName is NULL, and CUE_NOSUITE is set if pSuite is NULL.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_pTest CU_get_test(CU_pSuite pSuite, const char *strName)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>CU_pTest CU_get_test_at_pos&lt;(CU_pSuite pSuite, unsigned int pos)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_test_pos&lt;(CU_pSuite pSuite, CU_pTest pTest)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_test_pos_by_name(CU_pSuite pSuite, const char *strName)</strong></p>
  </dt>
  <dd>
    <p>These functions facilitate lookup of tests registered in suites.  The first 2 functions allow lookup of the test by name or position and return NULL if the test cannot found.  The position is a 1-based index in the range [1 .. pSuite-&gt;uiNumberOfSuites].  This may be helpful when tests having duplicate names are registered, in which case lookup by name can only retrieve the 1st test having that name.  The second 2 functions help the client identify the position of a test in a suite. These return 0 if the test cannot be found.  In addition, all these functions set the CUnit error state to CUE_NOREGISTRY if the registry is not initialized, and to CUE_NOSUITE if pSuite is NULL.  As appropriate, CUE_NO_TESTNAME is set if strName is NULL, and CUE_NOTEST is set if pTest is NULL.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RUNNING TESTS</h2>
        <div class="sectioncontent">
<p>CUnit supports running all tests in all registered suites, but individual tests or suites can also be run.  During each run, the framework keeps track of the number of suites, tests, and assertions run, passed, and failed. Note that the previous results are cleared each time a test run is initiated (even if it fails).</p><p>While CUnit provides primitive functions for running suites and tests, most users will want to use one of the user interfaces.  These interfaces handle the details of interaction with the framework and provide output of test details and results for the user.  For more about the primitive functions, see <strong>&lt;CUnit/testRun.h&gt;.</strong></p><h3>Test Results</h3>
<p>The interfaces present results of test runs, but client code may sometimes need to access the results directly.  These results include various run counts, as well as a linked list of failure records holding the failure details.  Test results must be retrieved before attempting to run other tests, which resets the result information.  Functions for accessing the test results are:</p><p><strong>#include &lt;CUnit/TestRun.h&gt;</strong> (included automatically by &lt;CUnit/CUnit.h&gt;)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>unsigned int CU_get_number_of_suites_run(void)'</strong></p>
  </dt>
  <dd>
    <p>Retrieve the number of suites run.  Suite having initialization functions which fail are not run.  To get the total number of registered suites, use <strong>CU_get_registry()-&gt;uiNumberOfSuites.</strong></p>
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_number_of_suites_failed(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the number of suites which had initialization or cleanup functions which failed (returned non-NULL).</p>
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_number_of_tests_run(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the number of tests run.  Tests in suites having initialization functions which fail are not run.  To get the total number of registered tests , use <strong>CU_get_registry()-&gt;uiNumberOfTests.</strong></p>
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_number_of_tests_failed(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the number of tests which contained at least 1 failed assertion.</p>
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_number_of_asserts(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the number of CUnit assertions made during the test run.</p>
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_number_of_successes(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the number of assertions which passed.</p>
  </dd>
  <dt>
    <p><strong>unsigned int CU_get_number_of_failures(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the number of assertions which failed.</p>
  </dd>
  <dt>
    <p><strong>const CU_pRunSummary CU_get_run_summary(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve a <strong>CU_RunSummary</strong> containing all the run count information.  This data structure is declared in <strong>&lt;CUnit/TestRun.h&gt;</strong> and includes the (self-explanatory) <em>unsigned int</em> fields nSuitesRun, nSuitesFailed, nTestsRun, nTestsFailed, nAsserts, and nAssertsFailed.</p>
  </dd>
  <dt>
    <p><strong>const CU_pFailureRecord CU_get_failure_list(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the head of the linked list of failure records for the last run.  Each assertion failure or suite init/cleanup function failure is registered in a new <strong>CU_FailureRecord</strong> in the linked list.  This data structure is declared in <strong>&lt;CUnit/TestRun.h&gt;</strong> and includes the following fields:</p><p><strong>unsigned int uiLineNumber</strong></p><p><strong>char*        strFileName</strong></p><p><strong>char*        strCondition</strong></p><p><strong>CU_pTest     pTest</strong></p><p><strong>CU_pSuite    pSuite</strong></p>
  </dd>

</dl>

<h3>Automated Interface</h3>
<p>The automated interface is non-interactive.  The current implementation only supports running all registered suites.  Results are output to an xml file to be viewed by appropriate external tools.  Registered tests can also be listed to an xml file for viewing.  The following public functions are available:</p><p><strong>#include &lt;CUnit/Automated.h&gt;</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void CU_automated_run_tests(void)</strong></p>
  </dt>
  <dd>
    <p>Run all tests in all registered (and active) suites. Results are output to a file named <em>ROOT-Results.xml.</em> The filename 'ROOT' is set using <strong>CU_set_output_filename(),</strong> or else the default 'CUnitAutomated' is used.  This means that the same filename is used each run (and the results file overwritten) if the user does not explicitly set the 'ROOT' for each run.</p>
  </dd>
  <dt>
    <p><strong>CU_ErrorCode CU_list_tests_to_file(void)</strong></p>
  </dt>
  <dd>
    <p>Lists the registered suites and associated tests to file.  The listing file is named <em>ROOT-Listing.xml.</em> The filename 'ROOT' is set using <strong>CU_set_output_filename(),</strong> or else the default 'CUnitAutomated' is used.  This means that the same filename is used each run (and the listing file overwritten) if the user does not explicitly set the 'ROOT' for each run.</p>
  </dd>
  <dt>
    <p><strong>void CU_set_output_filename(const char* szFilenameRoot)</strong></p>
  </dt>
  <dd>
    <p>Set the filename root to use for automated results and listing files.</p>
  </dd>

</dl>

<h3>Basic Interface (non-interactive)</h3>
<p>The basic interface is also non-interactive, with results output to stdout. This interface supports running individual suites or tests, and allows client code to control the type of output displayed during each run.  This interface provides the most flexibility to clients desiring simplified access to the CUnit API.  The following public functions are provided:</p><p><strong>#include &lt;CUnit/Basic.h&gt;</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_ErrorCode CU_basic_run_tests(void)</strong></p>
  </dt>
  <dd>
    <p>Run all tests in all registered suites.  Only the active suites are run, and it is not considered an error if inactive suites are encountered and skipped. Returns the 1st error code occurring during the test run.  The type of output is controlled by the current run mode, which can be set using <strong>CU_basic_set_mode().</strong></p>
  </dd>
  <dt>
    <p><strong>CU_ErrorCode CU_basic_run_suite(CU_pSuite pSuite)</strong></p>
  </dt>
  <dd>
    <p>Run all tests in single specified suite.  Returns the 1st error code occurring during the test run. <strong>CU_basic_run_suite()</strong> itself generates CUE_NOSUITE if pSuite is NULL, and CUE_SUITE_INACTIVE if the requested suite is not active.  The type of output is controlled by the current run mode.</p>
  </dd>
  <dt>
    <p><strong>CU_ErrorCode CU_basic_run_test(CU_pSuite pSuite, CU_pTest pTest)</strong></p>
  </dt>
  <dd>
    <p>Run a single test in a specified suite.  Returns the 1st error code occurring during the test run. <strong>BU_basic_run_test()</strong> itself generates CUE_NOSUITE of pSuite is NULL; CUE_NOTEST if pTest is NULL; CUE_SUITE_INACTIVE if pSuite is not active for execution, CUE_TEST_NOT_IN_SUITE if pTest is not a registered member of pSuite, and CUE_TEST_INACTIVE if pTest is not active for execution. The type of output is controlled by the current run mode.</p>
  </dd>
  <dt>
    <p><strong>void CU_basic_set_mode(CU_BasicRunMode mode)</strong></p>
  </dt>
  <dd>
    <p>Set the basic run mode, which controls the output during the run.  Choices are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>CU_BRM_NORMAL</p>
  </dt>
  <dd>
    <p>Failures and run summary are printed.</p>
  </dd>
  <dt>
    <p>CU_BRM_SILENT</p>
  </dt>
  <dd>
    <p>No output is printed except error messages.</p>
  </dd>
  <dt>
    <p>CU_BRM_VERBOSE</p>
  </dt>
  <dd>
    <p>Maximum output of run details.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong>CU_BasicRunMode CU_basic_get_mode(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the current basic run mode code.</p>
  </dd>
  <dt>
    <p><strong>void CU_basic_show_failures(CU_pFailureRecord pFailure)</strong></p>
  </dt>
  <dd>
    <p>Prints a summary of all failures to stdout.  Does not depend on the run mode.</p>
  </dd>

</dl>

<h3>Interactive Console Interface</h3>
<p>The console interface is interactive.  All the client needs to do is initiate the console session, and the user controls the test run interactively.  This include selection & running of suites and tests, and viewing test results.</p><p><strong>#include &lt;CUnit/Console.h&gt;</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void CU_console_run_tests(void)</strong></p>
  </dt>
  <dd>
    <p>Initiate an interactive test run in the console.</p>
  </dd>

</dl>

<h3>Interactive Curses Interface</h3>
<p>The curses interface is interactive.  All the client needs to do is initiate the curses session, and the user controls the test run interactively.  This include selection & running of suites and tests, and viewing test results.  Use of this interface requires linking the ncurses library into the application.</p><p><strong>#include &lt;CUnit/CUCurses.h&gt;</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void CU_curses_run_tests(void)</strong></p>
  </dt>
  <dd>
    <p>Initiate an interactive test run in curses.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERROR HANDLING</h2>
        <div class="sectioncontent">
<h3>CUnit Error Status Codes</h3>
<p>Many CUnit functions set a framework error code when an exception occurs. The error codes are an <em>enum</em> named <strong>CU_ErrorCode</strong> declared in header file <strong>&lt;CUnit/CUError.h&gt;</strong> (included automatically by <strong>&lt;CUnit/CUnit.h&gt;</strong> ).  The following functions are provided for retrieving the framework error status:</p><p><strong>#include &lt;CUnit/CUError.h&gt;</strong> (included automatically by &lt;CUnit/CUnit.h&gt;)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CU_ErrorCode CU_get_error(void)</strong></p>
  </dt>
  <dd>
    <p>Returns the framework error status code.</p>
  </dd>
  <dt>
    <p><strong>const char* CU_get_error_msg(void)</strong></p>
  </dt>
  <dd>
    <p>Returns a message for the current error code.</p>
  </dd>

</dl>

<h3>Error Actions</h3>
<p>By default, CUnit continues running tests when a framework error occurs. In this context, failed assertions are not considered "framework errors". All other error conditions including suite initialization or cleanup failures, inactive suites or tests which are run explicitly, etc. are included. This 'error action' can be changed by the user if desired.  The following functions are provided:</p><p><strong>#include &lt;CUnit/CUError.h&gt;</strong> (included automatically by &lt;CUnit/CUnit.h&gt;)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void CU_set_error_action(CU_ErrorAction action)</strong></p>
  </dt>
  <dd>
    <p>Set the framework error action.</p>
  </dd>
  <dt>
    <p><strong>CU_ErrorAction CU_get_error_action(void)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the current error action.</p>
  </dd>

</dl>
<p>The error actions are defined in <strong>enum CU_ErrorAction</strong> in header file <strong>&lt;CUnit/CUError.h&gt;</strong> (included automatically by <strong>&lt;CUnit/CUnit.h&gt;</strong> ) as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p>CUEA_IGNORE</p>
  </dt>
  <dd>
    <p>Continue test runs on framework errors (default).</p>
  </dd>
  <dt>
    <p>CUEA_FAIL</p>
  </dt>
  <dd>
    <p>Stop test runs on a framework error.</p>
  </dd>
  <dt>
    <p>CUEA_ABORT</p>
  </dt>
  <dd>
    <p>Exit the application on a framework error.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Anil Kumar     &lt;anilsaharan@users.sourceforge.net&gt;</p><p>Jerry St.Clair &lt;jds2@users.sourceforge.net&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WEBSITE</h2>
        <div class="sectioncontent">
<p>http://cunit.sourceforge.net</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="CURLOPT_XOAUTH2_BEARER.3.html"><span aria-hidden="true">&larr;</span> CURLOPT_XOAUTH2_BEARER.3: Specify oauth 2 access token</a></li>
   <li class="next"><a href="libcunit1-ncurses-dev-CUnit.3.html">CUnit.3: A unit testing framework for c <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

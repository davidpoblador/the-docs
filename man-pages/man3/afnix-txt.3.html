<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>afnix-txt: Standard text processing module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Standard text processing module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="afnix-txt (3) manual">
  <meta name="twitter:description" content="Standard text processing module">
  <meta name="twitter:image" content="https://www.carta.tech/images/afnix-afnix-txt-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/afnix-txt.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="afnix-txt (3) manual" />
  <meta property="og:description" content="Standard text processing module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/afnix-afnix-txt-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">afnix-txt<small> (3)</small></h1>
        <p class="lead">Standard text processing module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-txt.3.html">
      <span itemprop="name">afnix-txt: Standard text processing module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/afnix/">
      <span itemprop="name">afnix</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-txt.3.html">
      <span itemprop="name">afnix-txt: Standard text processing module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD TEXT PROCESSING MODULE</h2>
        <div class="sectioncontent">
<p>The Standard Text Processing module is an original implementation of an object collection dedicated to text processing. Although text scaning is the current operation perfomed in the field of text processing, the module provides also specialized object to store and index text data. Text sorting and transliteration is also part of this module.</p><p><strong>Scanning concepts</strong></p><p>Text scanning is the ability to extract lexical elements or lexemes from a stream. A scanner or lexical analyzer is the principal object used to perform this task. A scanner is created by adding special object that acts as a pattern matcher. When a pattern is matched, a special object called a lexeme is returned.</p><p><em>Pattern object</em></p><p>A Pattern object is a special object that acts as model for the string to match. There are several ways to build a pattern. The simplest way to build it is with a regular expression. Another type of pattern is a balanced pattern. In its first form, a pattern object can be created with a regular expression object.</p>
<pre>
# create a pattern object
const pat (afnix:txt:Pattern "$d+")
</pre>
<p>In this example, the pattern object is built to detect integer objects.</p>
<pre>
pat:check "123" # true
pat:match "123" # 123
</pre>
<p>The check method return true if the input string matches the pattern. The match method returns the string that matches the pattern. Since the pattern object can also operates with stream object, the match method is appropriate to match a particular string. The pattern object is, as usual, available with the appropriate predicate.</p>
<pre>
afnix:txt:pattern-p pat # true
</pre>
<p>Another form of pattern object is the balanced pattern. A balanced pattern is determined by a starting string and an ending string. There are two types of balanced pattern. One is a single balanced pattern and the other one is the recursive balanced pattern. The single balanced pattern is appropriate for those lexical element that are defined by a character. For example, the classical C-string is a single balanced pattern with the double quote character.</p>
<pre>
# create a balanced pattern
const pat (afnix:txt:Pattern "ELEMENT" "&lt;" "&gt;")
pat:check "&lt;xml&gt;" # true
pat:match "&lt;xml&gt;" # xml
</pre>
<p>In the case of the C-string, the pattern might be more appropriately defined with an additional escape character. Such character is used by the pattern matcher to grab characters that might be part of the pattern definition.</p>
<pre>
# create a balanced pattern
const pat (afnix:txt:Pattern "STRING" "'" '&#92;')
pat:check "'hello'" # true
pat:match "'hello'" # "hello"
</pre>
<p>In this form, a balanced pattern with an escape character is created. The same string is used for both the starting and ending string. Another constructor that takes two strings can be used if the starting and ending strings are different. The last pattern form is the balanced recursive form. In this form, a starting and ending string are used to delimit the pattern. However, in this mode, a recursive use of the starting and ending strings is allowed. In order to have an exact match, the number of starting string must equal the number of ending string. For example, the C-comment pattern can be viewed as recursive balanced pattern.</p>
<pre>
# create a c-comment pattern
const pat (afnix:txt:Pattern "STRING" "/*" "*/" )
</pre>
<p><em>Lexeme object</em></p><p>The Lexeme object is the object built by a scanner that contains the matched string. A lexeme is therefore a tagged string. Additionally, a lexeme can carry additional information like a source name and index.</p>
<pre>
# create an empty lexeme
const lexm (afnix:txt:Lexeme)
afnix:txt:lexeme-p lexm # true
</pre>
<p>The default lexeme is created with any value. A value can be set with the set-value method and retrieved with the get-value methods.</p>
<pre>
lexm:set-value "hello"
lexm:get-value # hello
</pre>
<p>Similar are the set-tag and get-tag methods which operate with an integer. The source name and index are defined as well with the same methods.</p>
<pre>
# check for the source
lexm:set-source "world"
lexm:get-source # world
# check for the source index
lexm:set-index 2000
lexm:get-index # 2000
</pre>
<p><strong>Text scanning</strong></p><p>Text scanning is the ability to extract lexical elements or lexemes from an input stream. Generally, the lexemes are the results of a matching operation which is defined by a pattern object. As a result, the definition of a scanner object is the object itself plus one or several pattern object.</p><p><em>Scanner construction</em></p><p>By default, a scanner is created without pattern objects. The length method returns the number of pattern objects. As usual, a predicate is associated with the scanner object.</p>
<pre>
# the default scanner
const  scan (afnix:txt:Scanner)
afnix:txt:scanner-p scan # true
# the length method
scan:length # 0
</pre>
<p>The scanner construction proceeds by adding pattern objects. Each pattern can be created independently, and later added to the scanner. For example, a scanner that reads real, integer and string can be defined as follow:</p>
<pre>
# create the scanner pattern
const REAL    (
  afnix:txt:Pattern "REAL"    [$d+.$d*])
const STRING  (
  afnix:txt:Pattern "STRING"  "&quot;" '&#92;')
const INTEGER (
  afnix:txt:Pattern "INTEGER" [$d+|"0x"$x+])
# add the pattern to the scanner
scanner:add INTEGER REAL STRING
</pre>
<p>The order of pattern integration defines the priority at which a token is recognized. The symbol name for each pattern is optional since the functional programming permits the creation of patterns directly. This writing style makes the scanner definition easier to read.</p><p><em>Using the scanner</em></p><p>Once constructed, the scanner can be used as is. A stream is generally the best way to operate. If the scanner reaches the end-of-stream or cannot recognize a lexeme, the nil object is returned. With a loop, it is easy to get all lexemes.</p>
<pre>
while (trans valid (is:valid-p)) {
  # try to get the lexeme
  trans lexm (scanner:scan is)
  # check for nil lexeme and print the value
  if (not (nil-p lexm)) (println (lexm:get-value))
  # update the valid flag
  valid:= (and (is:valid-p) (not (nil-p lexm)))
}
</pre>
<p>In this loop, it is necessary first to check for the end of the stream. This is done with the help of the special loop construct that initialize the valid symbol. As soon as the the lexeme is built, it can be used. The lexeme holds the value as well as it tag.</p><p><strong>Text sorting</strong></p><p>Sorting is one the primary function implemented inside the text processing module. There are three sorting functions available in the module.</p><p><em>Ascending and descending order sorting</em></p><p>The sort-ascent function operates with a vector object and sorts the elements in ascending order. Any kind of objects can be sorted as long as they support a comparison method. The elements are sorted in placed by using a quick sort algorithm.</p>
<pre>
# create an unsorted vector
const v-i (Vector 7 5 3 4 1 8 0 9 2 6)
# sort the vector in place
afnix:txt:sort-ascent v-i
# print the vector
for (e) (v) (println e)
</pre>
<p>The sort-descent function is similar to the sort-ascent function except that the object are sorted in descending order.</p><p><em>Lexical sorting</em></p><p>The sort-lexical function operates with a vector object and sorts the elements in ascending order using a lexicographic ordering relation. Objects in the vector must be literal objects or an exception is raised.</p><p><strong>Transliteration</strong></p><p>Transliteration is the process of changing characters my mapping one to another one. The transliteration process operates with a character source and produces a target character with the help of a mapping table. The transliteration process is not necessarily reversible as often indicated in the literature.</p><p><em>Literate object</em></p><p>The Literate object is a transliteration object that is bound by default with the identity function mapping. As usual, a predicate is associate with the object.</p>
<pre>
# create a transliterate object
const tl (afnix:txt:Literate)
# check the object
afnix:txt:literate-p tl # true
</pre>
<p>The transliteration process can also operate with an escape character in order to map double character sequence into a single one, as usually found inside programming language.</p>
<pre>
# create a transliterate object by escape
const tl (afnix:txt:Literate '&#92;')
</pre>
<p><em>Transliteration configuration</em></p><p>The set-map configures the transliteration mapping table while the set-escape-map configure the escape mapping table. The mapping is done by setting the source character and the target character. For instance, if one want to map the tabulation character to a white space, the mapping table is set as follow:</p>
<pre>
tl:set-map '\t' ' '
</pre>
<p>The escape mapping table operates the same way. It should be noted that the mapping algorithm translate first the input character, eventually yielding to an escape character and then the escape mapping takes place. Note also that the set-escape method can be used to set the escape character.</p>
<pre>
tl:set-map '\t' ' '
</pre>
<p><em>Transliteration process</em></p><p>The transliteration process is done either with a string or an input stream. In the first case, the translate method operates with a string and returns a translated string. On the other hand, the read method returns a character when operating with a stream.</p>
<pre>
# set the mapping characters
tl:set-map '\h' '\w'
tl:set-map '&#92;' '\o'
tl:set-map '\l' '\r'
tl:set-map '\o' '\d'
# translate a string
tl:translate "helo" # word
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD TEXT PROCESSING REFERENCE</h2>
        <div class="sectioncontent">
<p><strong>Pattern</strong></p><p>The Pattern class is a pattern matching class based either on regular expression or balanced string. In the regex mode, the pattern is defined with a regex and a matching is said to occur when a regex match is achieved. In the balanced string mode, the pattern is defined with a start pattern and end pattern strings. The balanced mode can be a single or recursive. Additionally, an escape character can be associated with the class. A name and a tag is also bound to the pattern object as a mean to ease the integration within a scanner.</p><p><em>Predicate</em></p><p>pattern-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Pattern (none)</strong></p><p>The Pattern constructor creates an empty pattern.</p><p><strong>Pattern (String|Regex)</strong></p><p>The Pattern constructor creates a pattern object associated with a regular expression. The argument can be either a string or a regular expression object. If the argument is a string, it is converted into a regular expression object.</p><p><strong>Pattern (String String)</strong></p><p>The Pattern constructor creates a balanced pattern. The first argument is the start pattern string. The second argument is the end balanced string.</p><p><strong>Pattern (String String Character)</strong></p><p>The Pattern constructor creates a balanced pattern with an escape character. The first argument is the start pattern string. The second argument is the end balanced string. The third character is the escape character.</p><p><strong>Pattern (String String Boolean)</strong></p><p>The Pattern constructor creates a recursive balanced pattern. The first argument is the start pattern string. The second argument is the end balanced string.</p><p><em>Constants</em></p><p><strong>REGEX</strong></p><p>The REGEX constant indicates that the pattern is a regular expression.</p><p><strong>BALANCED</strong></p><p>The BALANCED constant indicates that the pattern is a balanced pattern.</p><p><strong>RECURSIVE</strong></p><p>The RECURSIVE constant indicates that the pattern is a recursive balanced pattern.</p><p><em>Methods</em></p><p><strong>check -&gt; Boolean (String)</strong></p><p>The check method checks the pattern against the input string. If the verification is successful, the method returns true, false otherwise.</p><p><strong>match -&gt; String (String|InputStream)</strong></p><p>The match method attempts to match an input string or an input stream. If the matching occurs, the matching string is returned. If the input is a string, the end of string is used as an end condition. If the input stream is used, the end of stream is used as an end condition.</p><p><strong>set-tag -&gt; none (Integer)</strong></p><p>The set-tag method sets the pattern tag. The tag can be further used inside a scanner.</p><p><strong>get-tag -&gt; Integer (none)</strong></p><p>The get-tag method returns the pattern tag.</p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the pattern name. The name is symbol identifier for that pattern.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the pattern name.</p><p><strong>set-regex -&gt; none (String|Regex)</strong></p><p>The set-regex method sets the pattern regex either with a string or with a regex object. If the method is successfully completed, the pattern type is switched to the REGEX type.</p><p><strong>set-escape -&gt; none (Character)</strong></p><p>The set-escape method sets the pattern escape character. The escape character is used only in balanced mode.</p><p><strong>get-escape -&gt; Character (none)</strong></p><p>The get-escape method returns the escape character.</p><p><strong>set-balanced -&gt; none (String| String String)</strong></p><p>The set-balanced method sets the pattern balanced string. With one argument, the same balanced string is used for starting and ending. With two arguments, the first argument is the starting string and the second is the ending string.</p><p><strong>Lexeme</strong></p><p>The Lexeme class is a literal object that is designed to hold a matching pattern. A lexeme consists in string (i.e. the lexeme value), a tag and eventually a source name (i.e. file name) and a source index (line number).</p><p><em>Predicate</em></p><p>lexeme-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>Lexeme (none)</strong></p><p>The Lexeme constructor creates an empty lexeme.</p><p><strong>Lexeme (String)</strong></p><p>The Lexeme constructor creates a lexeme by value. The string argument is the lexeme value.</p><p><em>Methods</em></p><p><strong>set-tag -&gt; none (Integer)</strong></p><p>The set-tag method sets the lexeme tag. The tag can be further used inside a scanner.</p><p><strong>get-tag -&gt; Integer (none)</strong></p><p>The get-tag method returns the lexeme tag.</p><p><strong>set-value -&gt; none (String)</strong></p><p>The set-value method sets the lexeme value. The lexeme value is generally the result of a matching operation.</p><p><strong>get-value -&gt; String (none)</strong></p><p>The get-value method returns the lexeme value.</p><p><strong>set-index -&gt; none (Integer)</strong></p><p>The set-index method sets the lexeme source index. The lexeme source index can be for instance the source line number.</p><p><strong>get-index -&gt; Integer (none)</strong></p><p>The get-index method returns the lexeme source index.</p><p><strong>set-source -&gt; none (String)</strong></p><p>The set-source method sets the lexeme source name. The lexeme source name can be for instance the source file name.</p><p><strong>get-source -&gt; String (none)</strong></p><p>The get-source method returns the lexeme source name.</p><p><strong>Scanner</strong></p><p>The Scanner class is a text scanner or lexical analyzer that operates on an input stream and permits to match one or several patterns. The scanner is built by adding patterns to the scanner object. With an input stream, the scanner object attempts to build a buffer that match at least one pattern. When such matching occurs, a lexeme is built. When building a lexeme, the pattern tag is used to mark the lexeme.</p><p><em>Predicate</em></p><p>scanner-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Scanner (none)</strong></p><p>The Scanner constructor creates an empty scanner.</p><p><em>Methods</em></p><p><strong>add -&gt; none (Pattern*)</strong></p><p>The add method adds 0 or more pattern objects to the scanner. The priority of the pattern is determined by the order in which the patterns are added.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of pattern objects in this scanner.</p><p><strong>get -&gt; Pattern (Integer)</strong></p><p>The get method returns a pattern object by index.</p><p><strong>check -&gt; Lexeme (String)</strong></p><p>The check method checks that a string is matched by the scanner and returns the associated lexeme.</p><p><strong>scan -&gt; Lexeme (InputStream)</strong></p><p>The scan method scans an input stream until a pattern is matched. When a matching occurs, the associated lexeme is returned.</p><p><strong>Literate</strong></p><p>The Literate class is transliteration mapping class. Transliteration is the process of changing characters my mapping one to another one. The transliteration process operates with a character source and produces a target character with the help of a mapping table. This transliteration object can also operate with an escape table. In the presence of an escape character, an escape mapping table is used instead of the regular one.</p><p><em>Predicate</em></p><p>literate-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Literate (none)</strong></p><p>The Literate constructor creates a default transliteration object.</p><p><strong>Literate (Character)</strong></p><p>The Literate constructor creates a default transliteration object with an escape character. The argument is the escape character.</p><p><em>Methods</em></p><p><strong>read -&gt; Character (InputStream)</strong></p><p>The read method reads a character from the input stream and translate it with the help of the mapping table. A second character might be consumed from the stream if the first character is an escape character.</p><p><strong>getu -&gt; Character (InputStream)</strong></p><p>The getu method reads a Unicode character from the input stream and translate it with the help of the mapping table. A second character might be consumed from the stream if the first character is an escape character.</p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method resets all the mapping table and install a default identity one.</p><p><strong>set-map -&gt; none (Character Character)</strong></p><p>The set-map method set the mapping table by using a source and target character. The first character is the source character. The second character is the target character.</p><p><strong>get-map -&gt; Character (Character)</strong></p><p>The get-map method returns the mapping character by character. The source character is the argument.</p><p><strong>translate -&gt; String (String)</strong></p><p>The translate method translate a string by transliteration and returns a new string.</p><p><strong>set-escape -&gt; none (Character)</strong></p><p>The set-escape method set the escape character.</p><p><strong>get-escape -&gt; Character (none)</strong></p><p>The get-escape method returns the escape character.</p><p><strong>set-escape-map -&gt; none (Character Character)</strong></p><p>The set-escape-map method set the escape mapping table by using a source and target character. The first character is the source character. The second character is the target character.</p><p><strong>get-escape-map -&gt; Character (Character)</strong></p><p>The get-escape-map method returns the escape mapping character by character. The source character is the argument.</p><p><em>Functions</em></p><p><strong>sort-ascent -&gt; none (Vector)</strong></p><p>The sort-ascent function sorts in ascending order the vector argument. The vector is sorted in place.</p><p><strong>sort-descent -&gt; none (Vector)</strong></p><p>The sort-descent function sorts in descending order the vector argument. The vector is sorted in place.</p><p><strong>sort-lexical -&gt; none (Vector)</strong></p><p>The sort-lexical function sorts in lexicographic order the vector argument. The vector is sorted in place.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="afnix-sys.3.html"><span aria-hidden="true">&larr;</span> afnix-sys.3: Standard system access module</a></li>
   <li class="next"><a href="afnix-xml.3.html">afnix-xml.3: Standard xml module <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

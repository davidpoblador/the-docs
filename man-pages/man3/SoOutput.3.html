<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoOutput: The sooutput class is an abstraction of an output stream.  sooutput offers the ability to write basic types to a file or a memory buffer in either ascii or binary format.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sooutput class is an abstraction of an output stream.  sooutput offers the ability to write basic types to a file or a memory buffer in either ascii or binary format.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoOutput (3) manual">
  <meta name="twitter:description" content="The sooutput class is an abstraction of an output stream.  sooutput offers the ability to write basic types to a file or a memory buffer in either ascii or binary format.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoOutput-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoOutput.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoOutput (3) manual" />
  <meta property="og:description" content="The sooutput class is an abstraction of an output stream.  sooutput offers the ability to write basic types to a file or a memory buffer in either ascii or binary format." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoOutput-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoOutput<small> (3)</small></h1>
        <p class="lead">The sooutput class is an abstraction of an output stream.  sooutput offers the ability to write basic types to a file or a memory buffer in either ascii or binary format.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoOutput.3.html">
      <span itemprop="name">SoOutput: The sooutput class is an abstraction of an output stream.  sooutput offers the ability to write basic types to a file or a memory buffer in either ascii or binary format.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoOutput.3.html">
      <span itemprop="name">SoOutput: The sooutput class is an abstraction of an output stream.  sooutput offers the ability to write basic types to a file or a memory buffer in either ascii or binary format.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SoOutput.h&gt;</p><h3>Public Types</h3>
<p>enum <strong>Stage</strong> { <strong>COUNT_REFS</strong>, <strong>WRITE</strong> }</p><p>enum <strong>Annotations</strong> { <strong>ADDRESSES</strong> = 0x01, <strong>REF_COUNTS</strong> = 0x02 }</p>
<h3>Public Member Functions</h3>
<p><strong>SoOutput</strong> (void)</p><p><strong>SoOutput</strong> (<strong>SoOutput</strong> *dictOut)</p><p>virtual <strong>~SoOutput</strong> ()</p><p>virtual void <strong>setFilePointer</strong> (FILE *newFP)</p><p>virtual FILE * <strong>getFilePointer</strong> (void) const </p><p>virtual SbBool <strong>openFile</strong> (const char *const fileName)</p><p>virtual void <strong>closeFile</strong> (void)</p><p>SbBool <strong>setCompression</strong> (const <strong>SbName</strong> &compmethod, const float level=0.5f)</p><p>virtual void <strong>setBuffer</strong> (void *bufPointer, size_t initSize, SoOutputReallocCB *reallocFunc, int32_t offset=0)</p><p>virtual SbBool <strong>getBuffer</strong> (void *&bufPointer, size_t &nBytes) const </p><p>virtual size_t <strong>getBufferSize</strong> (void) const </p><p>virtual void <strong>resetBuffer</strong> (void)</p><p>virtual void <strong>setBinary</strong> (const SbBool flag)</p><p>virtual SbBool <strong>isBinary</strong> (void) const </p><p>virtual void <strong>setHeaderString</strong> (const <strong>SbString</strong> &str)</p><p>virtual void <strong>resetHeaderString</strong> (void)</p><p>virtual void <strong>setFloatPrecision</strong> (const int precision)</p><p>void <strong>setStage</strong> (<strong>Stage</strong> stage)</p><p><strong>Stage</strong> <strong>getStage</strong> (void) const </p><p>void <strong>incrementIndent</strong> (const int levels=1)</p><p>void <strong>decrementIndent</strong> (const int levels=1)</p><p>virtual void <strong>write</strong> (const char c)</p><p>virtual void <strong>write</strong> (const char *s)</p><p>virtual void <strong>write</strong> (const <strong>SbString</strong> &s)</p><p>virtual void <strong>write</strong> (const <strong>SbName</strong> &n)</p><p>virtual void <strong>write</strong> (const int i)</p><p>virtual void <strong>write</strong> (const unsigned int i)</p><p>virtual void <strong>write</strong> (const short s)</p><p>virtual void <strong>write</strong> (const unsigned short s)</p><p>virtual void <strong>write</strong> (const float f)</p><p>virtual void <strong>write</strong> (const double d)</p><p>virtual void <strong>writeBinaryArray</strong> (const unsigned char *c, const int length)</p><p>virtual void <strong>writeBinaryArray</strong> (const int32_t *const l, const int length)</p><p>virtual void <strong>writeBinaryArray</strong> (const float *const f, const int length)</p><p>virtual void <strong>writeBinaryArray</strong> (const double *const d, const int length)</p><p>virtual void <strong>indent</strong> (void)</p><p>virtual void <strong>reset</strong> (void)</p><p>void <strong>setCompact</strong> (SbBool flag)</p><p>SbBool <strong>isCompact</strong> (void) const </p><p>void <strong>setAnnotation</strong> (uint32_t bits)</p><p>uint32_t <strong>getAnnotation</strong> (void)</p><p>int <strong>addReference</strong> (const <strong>SoBase</strong> *base)</p><p>int <strong>findReference</strong> (const <strong>SoBase</strong> *base) const </p><p>void <strong>setReference</strong> (const <strong>SoBase</strong> *base, int refid)</p><p>void <strong>addDEFNode</strong> (<strong>SbName</strong> name)</p><p>SbBool <strong>lookupDEFNode</strong> (<strong>SbName</strong> name)</p><p>void <strong>removeDEFNode</strong> (<strong>SbName</strong> name)</p><p>void <strong>pushProto</strong> (<strong>SoProto</strong> *proto)</p><p><strong>SoProto</strong> * <strong>getCurrentProto</strong> (void) const </p><p>void <strong>popProto</strong> (void)</p><p>void <strong>addRoute</strong> (<strong>SoFieldContainer</strong> *from, const <strong>SbName</strong> &fromfield, <strong>SoFieldContainer</strong> *to, const <strong>SbName</strong> &tofield)</p><p>void <strong>resolveRoutes</strong> (void)</p>
<h3>Static Public Member Functions</h3>
<p>static const <strong>SbName</strong> * <strong>getAvailableCompressionMethods</strong> (unsigned int &num)</p><p>static <strong>SbString</strong> <strong>getDefaultASCIIHeader</strong> (void)</p><p>static <strong>SbString</strong> <strong>getDefaultBinaryHeader</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p>SbBool <strong>isToBuffer</strong> (void) const </p><p>size_t <strong>bytesInBuf</strong> (void) const </p><p>SbBool <strong>makeRoomInBuf</strong> (size_t nBytes)</p><p>void <strong>convertShort</strong> (short s, char *to)</p><p>void <strong>convertInt32</strong> (int32_t l, char *to)</p><p>void <strong>convertFloat</strong> (float f, char *to)</p><p>void <strong>convertDouble</strong> (double d, char *to)</p><p>void <strong>convertShortArray</strong> (short *from, char *to, int len)</p><p>void <strong>convertInt32Array</strong> (int32_t *from, char *to, int len)</p><p>void <strong>convertFloatArray</strong> (float *from, char *to, int len)</p><p>void <strong>convertDoubleArray</strong> (double *from, char *to, int len)</p>
<h3>Static Protected Member Functions</h3>
<p>static <strong>SbString</strong> <strong>padHeader</strong> (const <strong>SbString</strong> &inString)</p>
<h3>Protected Attributes</h3>
<p>SbBool <strong>wroteHeader</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoOutput</strong> class is an abstraction of an output stream.</p><p><strong>SoOutput</strong> offers the ability to write basic types to a file or a memory buffer in either ASCII or binary format.</p><p><strong>See also:</strong></p><p><strong>SoInput</strong>, <strong>SoWriteAction</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoOutput::Stage\fP</h3>
<p>Enumerates the possible stages of a write operation (writing needs to be done in mutiple passes).</p><p><strong>See also:</strong></p><p><strong>setStage()</strong>, <strong>getStage()</strong></p>
<h3>enum \fBSoOutput::Annotations\fP</h3>
<p>Values from this enum is used for debugging purposes to annotate the output from a write operation.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoOutput::SoOutput (void)</h3>
<p>The default constructor makes an <strong>SoOutput</strong> instance which will write to the standard output.</p><p><strong>See also:</strong></p><p><strong>setFilePointer()</strong>, <strong>openFile()</strong>, <strong>setBuffer()</strong></p>
<h3>SoOutput::SoOutput (\fBSoOutput\fP *dictOut)</h3>
<p>Constructs an <strong>SoOutput</strong> which has a copy of the set of named references from <em>dictOut</em>.</p>
<h3>SoOutput::~SoOutput (void)\fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SoOutput::setFilePointer (FILE *newFP)\fC [virtual]\fP</h3>
<p>Set up a new file pointer which we will write to.</p><p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p><p><strong>See also:</strong></p><p><strong>openFile()</strong>, <strong>setBuffer()</strong>, <strong>getFilePointer()</strong></p>
<h3>FILE * SoOutput::getFilePointer (void) const\fC [virtual]\fP</h3>
<p>Returns the current filepointer. If we're writing to a memory buffer, NULL is returned.</p><p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p><p><strong>See also:</strong></p><p><strong>setFilePointer()</strong></p>
<h3>SbBool SoOutput::openFile (const char *constfileName)\fC [virtual]\fP</h3>
<p>Opens a file for writing. If the file can not be opened or is not writeable, <em>FALSE</em> will be returned.</p><p>Files opened by this method will automatically be closed if the user supplies another filepointer, another filename for writing, or if the <strong>SoOutput</strong> instance is deleted.</p><p><strong>See also:</strong></p><p><strong>setFilePointer()</strong>, <strong>setBuffer()</strong>, <strong>closeFile()</strong></p>
<h3>void SoOutput::closeFile (void)\fC [virtual]\fP</h3>
<p>Closes the currently opened file, but only if the file was passed to <strong>SoOutput</strong> through the <strong>openFile()</strong> method.</p><p><strong>See also:</strong></p><p><strong>openFile()</strong></p>
<h3>SbBool SoOutput::setCompression (const \fBSbName\fP &compmethod, const floatlevel = \fC0.5f\fP)</h3>
<p>Sets the compression method and level used when writing the file. <em>compmethod</em> is the compression library/method to use when compressing. <em>level</em> is the compression level, where 0.0 means no compression and 1.0 means maximum compression.</p><p>Currently <em>BZIP2</em>, <em>GZIP</em> are the only compression methods supported, and you have to compile Coin with zlib and bzip2-support to enable them.</p><p>Supply <em>compmethod</em> = <em>NONE</em> or <em>level</em> = 0.0 if you want to disable compression. The compression is disabled by default.</p><p>Please note that it's not possible to compress when writing to a memory buffer.</p><p>This method will return <em>TRUE</em> if the compression method selected is available. If it's not available, <em>FALSE</em> will be returned and compression is disabled.</p><p><strong>See also:</strong></p><p><strong>getAvailableCompressionMethods()</strong></p><p><strong>Since:</strong></p><p>Coin 2.1</p>
<h3>const \fBSbName\fP * SoOutput::getAvailableCompressionMethods (unsigned int &num)\fC [static]\fP</h3>
<p>Returns the array of available compression methods. The number of elements in the array will be stored in <em>num</em>.</p><p><strong>See also:</strong></p><p><strong>setCompression()</strong></p><p><strong>Since:</strong></p><p>Coin 2.1</p>
<h3>void SoOutput::setBuffer (void *bufPointer, size_tinitSize, SoOutputReallocCB *reallocFunc, int32_toffset = \fC0\fP)\fC [virtual]\fP</h3>
<p>Sets up a memory buffer of size <em>initSize</em> for writing. Writing will start at <em>bufPointer</em> + <em>offset</em>.</p><p>If the buffer is filled up, <em>reallocFunc</em> is called to get more memory. If <em>reallocFunc</em> returns <em>NULL</em>, further writing is disabled.</p><p>Important note: remember that the resultant memory buffer after write operations have completed may reside somewhere else in memory than on <em>bufPointer</em> if <em>reallocFunc</em> is set. It is a good idea to make it a habit to always use <strong>getBuffer()</strong> to retrieve the memory buffer pointer after write operations.</p><p>Here's a complete, stand-alone usage example which shows how to write a scene graph to a memory buffer:</p>
<pre>
#include &lt;Inventor/SoDB.h&gt;
#include &lt;Inventor/actions/SoWriteAction.h&gt;
#include &lt;Inventor/nodes/SoCone.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;

static char * buffer;
static size_t buffer_size = 0;

static void *
buffer_realloc(void * bufptr, size_t size)
{
  buffer = (char *)realloc(bufptr, size);
  buffer_size = size;
  return buffer;
}

static SbString
buffer_writeaction(SoNode * root)
{
  SoOutput out;
  buffer = (char *)malloc(1024);
  buffer_size = 1024;
  out.setBuffer(buffer, buffer_size, buffer_realloc);

  SoWriteAction wa(&out);
  wa.apply(root);

  SbString s(buffer);
  free(buffer);
  return s;
}

int
main(int argc, char ** argv)
{
  SoDB::init();

  SoSeparator * root = new SoSeparator;
  root-&gt;ref();

  root-&gt;addChild(new SoCone);

  SbString s = buffer_writeaction(root);
  (void)fprintf(stdout, "%s\n", s.getString());

  root-&gt;unref();
  return 0;
}
</pre>
<p><strong>See also:</strong></p><p><strong>getBuffer()</strong>, <strong>getBufferSize()</strong>, <strong>resetBuffer()</strong></p>
<h3>SbBool SoOutput::getBuffer (void *&bufPointer, size_t &nBytes) const\fC [virtual]\fP</h3>
<p>Returns the current buffer in <em>bufPointer</em> and the current write position of the buffer in <em>nBytes</em>. If we're writing into a file and not a memory buffer, <em>FALSE</em> is returned and the other return values will be undefined.</p><p><strong>See also:</strong></p><p><strong>getBufferSize()</strong></p>
<h3>size_t SoOutput::getBufferSize (void) const\fC [virtual]\fP</h3>
<p>Returns total size of memory buffer.</p><p><strong>See also:</strong></p><p><strong>getBuffer()</strong></p>
<h3>void SoOutput::resetBuffer (void)\fC [virtual]\fP</h3>
<p>Reset the memory buffer write pointer back to the beginning of the buffer.</p>
<h3>void SoOutput::setBinary (const SbBoolflag)\fC [virtual]\fP</h3>
<p>Set whether or not to write the output as a binary stream.</p><p><strong>See also:</strong></p><p><strong>isBinary()</strong></p>
<h3>SbBool SoOutput::isBinary (void) const\fC [virtual]\fP</h3>
<p>Returns a flag which indicates whether or not we're writing the output as a binary stream.</p><p><strong>See also:</strong></p><p><strong>setBinary()</strong></p>
<h3>void SoOutput::setHeaderString (const \fBSbString\fP &str)\fC [virtual]\fP</h3>
<p>Set the output file header string.</p><p><strong>See also:</strong></p><p><strong>resetHeaderString()</strong>, <strong>getDefaultASCIIHeader()</strong>, <strong>getDefaultBinaryHeader()</strong></p>
<h3>void SoOutput::resetHeaderString (void)\fC [virtual]\fP</h3>
<p>Reset the header string to the default one.</p><p><strong>See also:</strong></p><p><strong>setHeaderString()</strong>, <strong>getDefaultASCIIHeader()</strong>, <strong>getDefaultBinaryHeader()</strong></p>
<h3>void SoOutput::setFloatPrecision (const intprecision)\fC [virtual]\fP</h3>
<p>Set the precision used when writing floating point numbers to ASCII files. <em>precision</em> should be between 0 and 8. The double precision will be set to <em>precision</em> * 2.</p>
<h3>void SoOutput::setStage (\fBStage\fPstage)</h3>
<p>Sets an indicator on the current stage. This is necessary to do as writing has to be done in multiple stages to account for the export of references/connections within the scene graphs.</p><p>This method is basically just used from within <strong>SoWriteAction</strong>, and should usually not be of interest to the application programmer. Do not use it unless you <em>really</em> know what you are doing.</p><p><strong>See also:</strong></p><p><strong>getStage()</strong></p>
<h3>\fBSoOutput::Stage\fP SoOutput::getStage (void) const</h3>
<p>Returns an indicator on the current write stage. Writing is done in two passes, one to count and check connections, one to do the actual ascii or binary export of data.</p><p>You should not need to use this method, as it is meant for internal purposes in Coin.</p><p><strong>See also:</strong></p><p><strong>setStage()</strong></p>
<h3>void SoOutput::incrementIndent (const intlevels = \fC1\fP)</h3>
<p>Increase indentation level in the file.</p><p><strong>See also:</strong></p><p><strong>decrementIndent()</strong>, <strong>indent()</strong></p>
<h3>void SoOutput::decrementIndent (const intlevels = \fC1\fP)</h3>
<p>Decrease indentation level in the file.</p><p><strong>See also:</strong></p><p><strong>incrementIndent()</strong>, <strong>indent()</strong></p>
<h3>void SoOutput::write (const charc)\fC [virtual]\fP</h3>
<p>Write the character in <em>c</em>.</p><p>For binary write, the character plus 3 padding zero characters will be written.</p>
<h3>void SoOutput::write (const char *s)\fC [virtual]\fP</h3>
<p>Write the character string pointed to by <em>s</em>.</p><p>For binary write, a 4-byte MSB-ordered integer with the string length, plus the string plus padding zero characters to get on a 4-byte boundary (if necessary) will be written.</p>
<h3>void SoOutput::write (const \fBSbString\fP &s)\fC [virtual]\fP</h3>
<p>Write the character string in <em>s</em>. The string will be written with apostrophes. Cast <strong>SbString</strong> to char * to write without apostrophes.</p><p>If we are supposed to write in binary format, no apostrophes will be added, and writing will be done in the exact same manner as with <strong>SoOutput::write(const char * s)</strong>.</p>
<h3>void SoOutput::write (const \fBSbName\fP &n)\fC [virtual]\fP</h3>
<p>Write the character string in <em>n</em>. The name will be enclosed by apostrophes. If you want to write an <strong>SbName</strong> instance without the apostrophes, cast the argument to a char *.</p><p>If we are supposed to write in binary format, no apostrophes will be added, and writing will be done in the exact same manner as with <strong>SoOutput::write(const char * s)</strong>.</p>
<h3>void SoOutput::write (const inti)\fC [virtual]\fP</h3>
<p>Write <em>i</em> as a character string, or as an architecture independent binary pattern if the <strong>setBinary()</strong> flag is activated.</p>
<h3>void SoOutput::write (const unsigned inti)\fC [virtual]\fP</h3>
<p>Write <em>i</em> as a character string, or as an architecture independent binary pattern if the <strong>setBinary()</strong> flag is activated.</p>
<h3>void SoOutput::write (const shorts)\fC [virtual]\fP</h3>
<p>Write <em>s</em> as a character string, or as an architecture independent binary pattern if the <strong>setBinary()</strong> flag is activated.</p>
<h3>void SoOutput::write (const unsigned shorts)\fC [virtual]\fP</h3>
<p>Write <em>s</em> as a character string, or as an architecture independent binary pattern if the <strong>setBinary()</strong> flag is activated. If we're writing in ASCII format, the value will be written in base 16 (hexadecimal).</p>
<h3>void SoOutput::write (const floatf)\fC [virtual]\fP</h3>
<p>Write <em>f</em> as a character string.</p>
<h3>void SoOutput::write (const doubled)\fC [virtual]\fP</h3>
<p>Write <em>d</em> as a character string.</p>
<h3>void SoOutput::writeBinaryArray (const unsigned char *constc, const intlength)\fC [virtual]\fP</h3>
<p>Write the given number of bytes to either a file or a memory buffer in binary format.</p>
<h3>void SoOutput::writeBinaryArray (const int32_t *constl, const intlength)\fC [virtual]\fP</h3>
<p>Write an <em>length</em> array of int32_t values in binary format.</p>
<h3>void SoOutput::writeBinaryArray (const float *constf, const intlength)\fC [virtual]\fP</h3>
<p>Write an array of float values in binary format.</p>
<h3>void SoOutput::writeBinaryArray (const double *constd, const intlength)\fC [virtual]\fP</h3>
<p>Write an array of double values in binary format.</p>
<h3>void SoOutput::indent (void)\fC [virtual]\fP</h3>
<p>Call this method after writing a newline to a file to indent the next line to the correct position.</p><p><strong>See also:</strong></p><p><strong>incrementIndent()</strong>, <strong>decrementIndent()</strong></p>
<h3>void SoOutput::reset (void)\fC [virtual]\fP</h3>
<p>Reset all value and make ready for using another filepointer or buffer.</p>
<h3>void SoOutput::setCompact (SbBoolflag)</h3>
<p>Set up the output to be more compact than with the default write routines.</p>
<h3>SbBool SoOutput::isCompact (void) const</h3>
<p>Returns whether or not the write routines tries to compact the data when writing it (i.e. using less whitespace, etc).</p><p>Note that 'compact' in this sense does <em>not</em> mean 'bitwise compression', as it could easily be mistaken for.</p>
<h3>void SoOutput::setAnnotation (uint32_tbits)</h3>
<p>Set up annotation of different aspects of the output data. This is not useful for much else than debugging purposes, I s'pose.</p>
<h3>uint32_t SoOutput::getAnnotation (void)</h3>
<p>Returns the current annotation debug bitflag settings.</p>
<h3>\fBSbString\fP SoOutput::getDefaultASCIIHeader (void)\fC [static]\fP</h3>
<p>Return the default header string written to ASCII files.</p><p><strong>See also:</strong></p><p><strong>setHeaderString()</strong>, <strong>resetHeaderString()</strong>, <strong>getDefaultBinaryHeader()</strong></p>
<h3>\fBSbString\fP SoOutput::getDefaultBinaryHeader (void)\fC [static]\fP</h3>
<p>Return the default header string written to binary files.</p><p><strong>See also:</strong></p><p><strong>setHeaderString()</strong>, <strong>resetHeaderString()</strong>, <strong>getDefaultASCIIHeader()</strong></p>
<h3>int SoOutput::addReference (const \fBSoBase\fP *base)</h3>
<p>Makes a unique id for <em>base</em> and adds a mapping into our dictionary.</p>
<h3>int SoOutput::findReference (const \fBSoBase\fP *base) const</h3>
<p>Returns the unique identifier for <em>base</em> or -1 if not found.</p>
<h3>void SoOutput::setReference (const \fBSoBase\fP *base, intrefid)</h3>
<p>Sets the reference for <em>base</em> manually.</p>
<h3>void SoOutput::addDEFNode (\fBSbName\fPname)</h3>
<p>Adds <em>name</em> to the set of currently DEF'ed node names so far in the output process.</p>
<h3>SbBool SoOutput::lookupDEFNode (\fBSbName\fPname)</h3>
<p>Checks whether <em>name</em> is already DEF'ed at this point in the output process. Returns TRUE if <em>name</em> is DEF'ed.</p>
<h3>void SoOutput::removeDEFNode (\fBSbName\fPname)</h3>
<p>Removes <em>name</em> from the set of DEF'ed node names. Used after the last reference to a DEF'ed node if we want to reuse the DEF at a later point in the file.</p>
<h3>void SoOutput::pushProto (\fBSoProto\fP *proto)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>\fBSoProto\fP * SoOutput::getCurrentProto (void) const</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoOutput::popProto (void)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoOutput::addRoute (\fBSoFieldContainer\fP *from, const \fBSbName\fP &fromfield, \fBSoFieldContainer\fP *to, const \fBSbName\fP &tofield)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoOutput::resolveRoutes (void)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>SbBool SoOutput::isToBuffer (void) const\fC [protected]\fP</h3>
<p>Returns <em>TRUE</em> of we're set up to write to a memory buffer.</p>
<h3>size_t SoOutput::bytesInBuf (void) const\fC [protected]\fP</h3>
<p>Returns current write position.</p><p>Note that for memory buffer writing, this includes the offset from <strong>SoOutput::setBuffer()</strong>, if any.</p>
<h3>SbBool SoOutput::makeRoomInBuf (size_tbytes)\fC [protected]\fP</h3>
<p>Check that the current memory buffer has enough space to contain the given number of bytes needed for the next write operation.</p><p>Returns <em>FALSE</em> if there's not enough space left, otherwise <em>TRUE</em>.</p><p>Note that there will automatically be made an attempt at allocating more memory if the realloction callback function argument of <strong>setBuffer()</strong> was not <em>NULL</em>.</p>
<h3>void SoOutput::convertShort (shorts, char *to)\fC [protected]\fP</h3>
<p>Convert the short integer in <em>s</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.</p><p><strong>See also:</strong></p><p><strong>SoInput::convertShort()</strong></p>
<h3>void SoOutput::convertInt32 (int32_tl, char *to)\fC [protected]\fP</h3>
<p>Convert the 32-bit integer in <em>l</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.</p><p><strong>See also:</strong></p><p><strong>SoInput::convertInt32()</strong></p>
<h3>void SoOutput::convertFloat (floatf, char *to)\fC [protected]\fP</h3>
<p>Convert the single-precision floating point number in <em>f</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.</p><p><strong>See also:</strong></p><p><strong>SoInput::convertFloat()</strong></p>
<h3>void SoOutput::convertDouble (doubled, char *to)\fC [protected]\fP</h3>
<p>Convert the double-precision floating point number in <em>d</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.</p><p><strong>See also:</strong></p><p><strong>SoInput::convertDouble()</strong></p>
<h3>void SoOutput::convertShortArray (short *from, char *to, intlen)\fC [protected]\fP</h3>
<p>Convert <em>len</em> short integer values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first).</p>
<h3>void SoOutput::convertInt32Array (int32_t *from, char *to, intlen)\fC [protected]\fP</h3>
<p>Convert <em>len</em> 32-bit integer values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first).</p>
<h3>void SoOutput::convertFloatArray (float *from, char *to, intlen)\fC [protected]\fP</h3>
<p>Convert <em>len</em> single-precision floating point values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first).</p>
<h3>void SoOutput::convertDoubleArray (double *from, char *to, intlen)\fC [protected]\fP</h3>
<p>Convert <em>len</em> double-precision floating point values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first).</p>
<h3>\fBSbString\fP SoOutput::padHeader (const \fBSbString\fP &inString)\fC [static]\fP, \fC [protected]\fP</h3>
<p>Pads the header we're writing so it contains the correct amount of bytes for the alignment of the following binary writes.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>SbBool SoOutput::wroteHeader\fC [protected]\fP</h3>
<p>Indicates whether or not the file format header has been written out. As long as this is <em>FALSE</em>, the header will be written once upon the first invocation of any write method in the class.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoOrthographicCamera.3.html"><span aria-hidden="true">&larr;</span> SoOrthographicCamera.3: The soorthographiccamera class defines a camera node with orthographic rendering.  orthographic rendering will not give a particularly realistic impression of the scene, but non-realistic rendering is for various reasons widely used in applications for e.g. computer aided design.</a></li>
   <li class="next"><a href="SoOutput.h.3.html">SoOutput.h.3: Sooutput.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Nmap::Parser: Parse nmap scan data with perl</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parse nmap scan data with perl">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Nmap::Parser (3pm) manual">
  <meta name="twitter:description" content="Parse nmap scan data with perl">
  <meta name="twitter:image" content="https://www.carta.tech/images/libnmap-parser-perl-Nmap::Parser-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Nmap::Parser.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Nmap::Parser (3pm) manual" />
  <meta property="og:description" content="Parse nmap scan data with perl" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libnmap-parser-perl-Nmap::Parser-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Nmap::Parser<small> (3pm)</small></h1>
        <p class="lead">Parse nmap scan data with perl</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Nmap::Parser.3pm.html">
      <span itemprop="name">Nmap::Parser: Parse nmap scan data with perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libnmap-parser-perl/">
      <span itemprop="name">libnmap-parser-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Nmap::Parser.3pm.html">
      <span itemprop="name">Nmap::Parser: Parse nmap scan data with perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Nmap::Parser;
  my $np = new Nmap::Parser;
</pre>
<p>  $np-&gt;parsescan($nmap_path, $nmap_args, @ips);     #or   $np-&gt;parsefile($file_xml);</p><p>  my $session    = $np-&gt;get_session();     #a Nmap::Parser::Session object</p><p>  my $host       = $np-&gt;get_host($ip_addr);     #a Nmap::Parser::Host object</p><p>  my $service = $host-&gt;tcp_service(80);     #a Nmap::Parser::Host::Service object</p><p>  my $os         = $host-&gt;os_sig();     #a Nmap::Parser::Host::OS object</p><p> #---------------------------------------</p><p> my $np2 = new Nmap::Parser;</p><p> $np2-&gt;callback(&#92;&my_callback);</p><p> $np2-&gt;parsefile($file_xml);     #or  $np2-&gt;parsescan($nmap_path, $nmap_args, @ips);</p><p> sub my_callback {</p><p>   my $host = shift;     #Nmap::Parser::Host object     #.. see documentation for all methods ...</p><p> }</p><p><em>For a full listing of methods see the documentation corresponding to each object.</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module implements a interface to the information contained in an nmap scan. It is implemented by parsing the xml scan data that is generated by nmap. This will enable anyone who utilizes nmap to quickly create fast and robust security scripts that utilize the powerful port scanning abilities of nmap.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>This module has an internal framework to make it easy to retrieve the desired information of a scan. Every nmap scan is based on two main sections of informations: the scan session, and the scan information of all hosts. The session information will be stored as a Nmap::Parser::Session object. This object will contain its own methods to obtain the desired information. The same is true for any hosts that were scanned using the Nmap::Parser::Host object. There are two sub objects under Nmap::Parser::Host. One is the Nmap::Parser::Host::Service object which will be used to obtain information of a given service running on a given port. The second is the Nmap::Parser::Host::OS object which contains the operating system signature information (\s-1OS\s0 guessed names, classes, osfamily..etc).</p><p>  Nmap::Parser                        -- Core parser      |      +--Nmap::Parser::Session         -- Nmap scan session information      |      +--Nmap::Parser::Host            -- General host information      |  |      |  |-Nmap::Parser::Host::Service -- Port service information      |  |      |  |-Nmap::Parser::Host::OS      -- Operating system signature information</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p><strong>&#92;$1</strong></p><p>The main idea behind the core module is, you will first parse the information and then extract data. Therefore, all parse*() methods should be executed before any get_*() methods.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>parse($string)</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>parse($filehandle)</strong>
  </dt>
  <dd>
    <p>Parses the nmap scan information in $string. Note that is usually only used if you have the whole xml scan information in $string or if you are piping the scan information.</p>
  </dd>
  <dt>
    <strong>parsefile($xml_file)</strong>
  </dt>
  <dd>
    <p>Parses the nmap scan data in $xml_file. This file can be generated from an nmap scan by using the '-oX filename.xml' option with nmap. If you get an error or your program dies due to parsing, please check that the xml information is compliant. The file is closed no matter how \*(C`parsefile()\*(C' returns.</p>
  </dd>
  <dt>
    <strong>parsescan($nmap,$args,@ips)</strong>
  </dt>
  <dd>
    <p>This method runs an nmap scan where $nmap is the path to the nmap executable, $args are the nmap command line parameters, and @ips are the list of \s-1IP\s0 addresses to scan. <em>parsescan()</em> will automagically run the nmap scan and parse the information. <em>See section \s-1EXAMPLES\s0 for a short tutorial</em> <em>Note: You cannot have one of the nmap options to be '-oX', '-oN' or '-oG'. Your</em> program will die if you try and pass any of these options because it decides the type of output nmap will generate. The \s-1IP\s0 addresses can be nmap-formatted addresses (see <em>nmap</em><em>\|(1)</em> If you get an error or your program dies due to parsing, please check that the xml information is compliant. If you are using <em>parsescan()</em> or an open filehandle , make sure that the nmap scan that you are performing is successful in returning xml information. (Sometimes using loopback addresses causes nmap to fail).</p>
  </dd>
  <dt>
    <strong></strong><strong>purge()</strong><strong></strong>
  </dt>
  <dd>
    <p>Cleans the xml scan data from memory. This is useful if you have a program where you are parsing lots of nmap scan data files with persistent variables.</p>
  </dd>
  <dt>
    <strong>callback(&#92;&code_ref)</strong>
  </dt>
  <dd>
    <p>Sets the parsing mode to be done using the callback function. It takes the parameter of a code reference or a reference to a function. If no code reference is given, it resets the mode to normal (no callback).  $np-&gt;callback(&#92;&my_function); #sets callback, my_function() will be called  $np-&gt;callback(); #resets it, no callback function called. Back to normal.</p>
  </dd>
  <dt>
    <strong></strong><strong>get_session()</strong><strong></strong>
  </dt>
  <dd>
    <p>Obtains the Nmap::Parser::Session object which contains the session scan information.</p>
  </dd>
  <dt>
    <strong>get_host($ip_addr)</strong>
  </dt>
  <dd>
    <p>Obtains the Nmap::Parser::Host object for the given $ip_addr.</p>
  </dd>
  <dt>
    <strong>del_host($ip_addr)</strong>
  </dt>
  <dd>
    <p>Deletes the stored Nmap::Parser::Host object whose \s-1IP\s0 is $ip_addr.</p>
  </dd>
  <dt>
    <strong></strong><strong>all_hosts()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>all_hosts($status)</strong>
  </dt>
  <dd>
    <p>Returns an array of all the Nmap::Parser::Host objects for the scan. If the optional status is given, it will only return those hosts that match that status. The status can be any of the following: \*(C`(up|down|unknown|skipped)\*(C'</p>
  </dd>
  <dt>
    <strong></strong><strong>get_ips()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>get_ips($status)</strong>
  </dt>
  <dd>
    <p>Returns the list of \s-1IP\s0 addresses that were scanned in this nmap session. They are sorted using ipv4_sort. If there are IPv6 addresses, or mixed, it might not be in correct sorted order. If the optional status is given, it will only return those \s-1IP\s0 addresses that match that status. The status can be any of the following: \*(C`(up|down|unknown|skipped)\*(C'</p>
  </dd>
  <dt>
    <strong>ipv4_sort(@ips)</strong>
  </dt>
  <dd>
    <p>This function takes a list of IPv4 addresses and returns the correctly sorted version of the list. This object contains the scan session information of the nmap scan.</p>
  </dd>
  <dt>
    <strong></strong><strong>finish_time()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the numeric time that the nmap scan finished.</p>
  </dd>
  <dt>
    <strong></strong><strong>nmap_version()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the version of nmap used for the scan.</p>
  </dd>
  <dt>
    <strong></strong><strong>numservices()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>numservices($type)</strong>
  </dt>
  <dd>
    <p>If numservices is called without argument, it returns the total number of services that were scanned for all types. If $type is given, it returns the number of services for that given scan type. See <em>scan_types()</em> for more info.</p>
  </dd>
  <dt>
    <strong></strong><strong>scan_args()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a string which contains the nmap executed command line used to run the scan.</p>
  </dd>
  <dt>
    <strong>scan_type_proto($type)</strong>
  </dt>
  <dd>
    <p>Returns the protocol type of the given scan type (provided by $type). See <em>scan_types()</em> for more info.</p>
  </dd>
  <dt>
    <strong></strong><strong>scan_types()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the list of scan types that were performed. It can be any of the following: \*(C`(syn|ack|bounce|connect|null|xmas|window|maimon|fin|udp|ipproto)\*(C'.</p>
  </dd>
  <dt>
    <strong></strong><strong>start_str()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the human readable format of the start time.</p>
  </dd>
  <dt>
    <strong></strong><strong>start_time()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the numeric form of the time the nmap scan started.</p>
  </dd>
  <dt>
    <strong></strong><strong>time_str()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the human readable format of the finish time.</p>
  </dd>
  <dt>
    <strong></strong><strong>xml_version()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the version of nmap xml file. This object represents the information collected from a scanned host.</p>
  </dd>
  <dt>
    <strong></strong><strong>status()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the state of the host. It is usually one of these \*(C`(up|down|unknown|skipped)\*(C'.</p>
  </dd>
  <dt>
    <strong></strong><strong>addr()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the main \s-1IP\s0 address of the host. This is usually the IPv4 address. If there is no IPv4 address, the IPv6 is returned (hopefully there is one).</p>
  </dd>
  <dt>
    <strong></strong><strong>addrtype()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the address type of the address given by <em>addr()</em> .</p>
  </dd>
  <dt>
    <strong></strong><strong>all_hostnames()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a list of all hostnames found for the given host.</p>
  </dd>
  <dt>
    <strong></strong><strong>extraports_count()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the number of extraports found.</p>
  </dd>
  <dt>
    <strong></strong><strong>extraports_state()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the state of all the extraports found.</p>
  </dd>
  <dt>
    <strong></strong><strong>hostname()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>hostname($index)</strong>
  </dt>
  <dd>
    <p>As a basic call, <em>hostname()</em> returns the first hostname obtained for the given host. If there exists more than one hostname, you can provide a number, which is used as the location in the array. The index starts at 0;  #in the case that there are only 2 hostnames  hostname() eq <strong>hostname</strong>(0);  <a href="../man1/hostname.1.html"><strong>hostname</strong>(1)</a>; #second hostname found  hostname(400) eq <a href="../man1/hostname.1.html"><strong>hostname</strong>(1)</a> #nothing at 400; return the name at the last index</p>
  </dd>
  <dt>
    <strong></strong><strong>ipv4_addr()</strong><strong></strong>
  </dt>
  <dd>
    <p>Explicitly return the IPv4 address.</p>
  </dd>
  <dt>
    <strong></strong><strong>ipv6_addr()</strong><strong></strong>
  </dt>
  <dd>
    <p>Explicitly return the IPv6 address.</p>
  </dd>
  <dt>
    <strong></strong><strong>mac_addr()</strong><strong></strong>
  </dt>
  <dd>
    <p>Explicitly return the \s-1MAC\s0 address.</p>
  </dd>
  <dt>
    <strong></strong><strong>mac_vendor()</strong><strong></strong>
  </dt>
  <dd>
    <p>Return the vendor information of the \s-1MAC\s0.</p>
  </dd>
  <dt>
    <strong></strong><strong>os_sig()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns an Nmap::Parser::Host::OS object that can be used to obtain all the Operating System signature (fingerprint) information. See Nmap::Parser::Host::OS for more details.  $os = $host-&gt;os_sig;  $os-&gt;name;  $os-&gt;osfamily;</p>
  </dd>
  <dt>
    <strong></strong><strong>tcpsequence_class()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>tcpsequence_index()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>tcpsequence_values()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the class, index and values information respectively of the tcp sequence.</p>
  </dd>
  <dt>
    <strong></strong><strong>ipidsequence_class()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>ipidsequence_values()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the class and values information respectively of the ipid sequence.</p>
  </dd>
  <dt>
    <strong></strong><strong>tcptssequence_class()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>tcptssequence_values()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the class and values information respectively of the tcpts sequence.</p>
  </dd>
  <dt>
    <strong></strong><strong>uptime_lastboot()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the human readable format of the timestamp of when the host had last rebooted.</p>
  </dd>
  <dt>
    <strong></strong><strong>uptime_seconds()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the number of seconds that have passed since the host's last boot from when the scan was performed.</p>
  </dd>
  <dt>
    <strong></strong><strong>tcp_ports()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>udp_ports()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the sorted list of TCP|UDP ports respectively that were scanned on this host. Optionally a string argument can be given to these functions to filter the list.  $host-&gt;tcp_ports('open') #returns all only 'open' ports (even 'open|filtered')  $host-&gt;udp_ports('open|filtered'); #matches exactly ports with 'open|filtered' <em>Note that if a port state is set to 'open|filtered' (or any combination), it will</em> be counted as an 'open' port as well as a 'filtered' one.</p>
  </dd>
  <dt>
    <strong></strong><strong>tcp_port_count()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>udp_port_count()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the total of TCP|UDP ports scanned respectively.</p>
  </dd>
  <dt>
    <strong>tcp_port_state($portid)</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>udp_port_state($portid)</strong>
  </dt>
  <dd>
    <p>Returns the state of the given port, provided by the port number in $portid.</p>
  </dd>
  <dt>
    <strong></strong><strong>tcp_open_ports()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>udp_open_ports()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the list of open TCP|UDP ports respectively. Note that if a port state is for example, 'open|filtered', it will appear on this list as well.</p>
  </dd>
  <dt>
    <strong></strong><strong>tcp_filtered_ports()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>udp_filtered_ports()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the list of filtered TCP|UDP ports respectively. Note that if a port state is for example, 'open|filtered', it will appear on this list as well.</p>
  </dd>
  <dt>
    <strong></strong><strong>tcp_closed_ports()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>udp_closed_ports()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the list of closed TCP|UDP ports respectively. Note that if a port state is for example, 'closed|filtered', it will appear on this list as well.</p>
  </dd>
  <dt>
    <strong>tcp_service($portid)</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>udp_service($portid)</strong>
  </dt>
  <dd>
    <p>Returns the Nmap::Parser::Host::Service object of a given service running on port, provided by $portid. See Nmap::Parser::Host::Service for more info.  $svc = $host-&gt;tcp_service(80);  $svc-&gt;name;  $svc-&gt;proto;</p>
  </dd>

</dl>
<p><em>Nmap::Parser::Host::Service</em></p><p>This object represents the service running on a given port in a given host. This object is obtained by using the tcp_service($portid) or udp_service($portid) method from the Nmap::Parser::Host object. If a portid is given that does not exist on the given host, these functions will still return an object (so your script doesn't die). Its good to use <em>tcp_ports()</em> or <em>udp_ports()</em> to see what ports were collected.</p>
<dl class='dl-vertical'>
  <dt>
    <strong></strong><strong>confidence()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the confidence level in service detection.</p>
  </dd>
  <dt>
    <strong></strong><strong>extrainfo()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns any additional information nmap knows about the service.</p>
  </dd>
  <dt>
    <strong></strong><strong>method()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the detection method.</p>
  </dd>
  <dt>
    <strong></strong><strong>name()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the service name.</p>
  </dd>
  <dt>
    <strong></strong><strong>owner()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the process owner of the given service. (If available)</p>
  </dd>
  <dt>
    <strong></strong><strong>port()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the port number where the service is running on.</p>
  </dd>
  <dt>
    <strong></strong><strong>product()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the product information of the service.</p>
  </dd>
  <dt>
    <strong></strong><strong>proto()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the protocol type of the service.</p>
  </dd>
  <dt>
    <strong></strong><strong>rpcnum()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the \s-1RPC\s0 number.</p>
  </dd>
  <dt>
    <strong></strong><strong>tunnel()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the tunnel value. (If available)</p>
  </dd>
  <dt>
    <strong></strong><strong>version()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the version of the given product of the running service.</p>
  </dd>

</dl>
<p><em>Nmap::Parser::Host::OS</em></p><p>This object represents the Operating System signature (fingerprint) information of the given host. This object is obtained from an Nmap::Parser::Host object using the \*(C`os_sig()\*(C' method. One important thing to note is that the order of \s-1OS\s0 names and classes are sorted by <strong>\s-1DECREASING\s0 \s-1ACCURACY\s0</strong>. This is more important than alphabetical ordering. Therefore, a basic call to any of these functions will return the record with the highest accuracy. (Which is probably the one you want anyways).</p>
<dl class='dl-vertical'>
  <dt>
    <strong></strong><strong>all_names()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the list of all the guessed \s-1OS\s0 names for the given host.</p>
  </dd>
  <dt>
    <strong></strong><strong>class_accuracy()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>class_accuracy($index)</strong>
  </dt>
  <dd>
    <p>A basic call to <em>class_accuracy()</em> returns the osclass accuracy of the first record. If $index is given, it returns the osclass accuracy for the given record. The index starts at 0.</p>
  </dd>
  <dt>
    <strong></strong><strong>class_count()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the total number of \s-1OS\s0 class records obtained from the nmap scan.</p>
  </dd>
  <dt>
    <strong></strong><strong>name()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>name($index)</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>names()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>names($index)</strong>
  </dt>
  <dd>
    <p>A basic call to <em>name()</em> returns the \s-1OS\s0 name of the first record which is the name with the highest accuracy. If $index is given, it returns the name for the given record. The index starts at 0.</p>
  </dd>
  <dt>
    <strong></strong><strong>name_accuracy()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>name_accuracy($index)</strong>
  </dt>
  <dd>
    <p>A basic call to <em>name_accuracy()</em> returns the \s-1OS\s0 name accuracy of the first record. If $index is given, it returns the name for the given record. The index starts at 0.</p>
  </dd>
  <dt>
    <strong></strong><strong>name_count()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the total number of \s-1OS\s0 names (records) for the given host.</p>
  </dd>
  <dt>
    <strong></strong><strong>osfamily()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>osfamily($index)</strong>
  </dt>
  <dd>
    <p>A basic call to <em>osfamily()</em> returns the \s-1OS\s0 family information of the first record. If $index is given, it returns the \s-1OS\s0 family information for the given record. The index starts at 0.</p>
  </dd>
  <dt>
    <strong></strong><strong>osgen()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>osgen($index)</strong>
  </dt>
  <dd>
    <p>A basic call to <em>osgen()</em> returns the \s-1OS\s0 generation information of the first record. If $index is given, it returns the \s-1OS\s0 generation information for the given record. The index starts at 0.</p>
  </dd>
  <dt>
    <strong></strong><strong>portused_closed()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the closed port number used to help identify the \s-1OS\s0 signatures. This might not be available for all hosts.</p>
  </dd>
  <dt>
    <strong></strong><strong>portused_open()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the open port number used to help identify the \s-1OS\s0 signatures. This might not be available for all hosts.</p>
  </dd>
  <dt>
    <strong></strong><strong>type()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>type($index)</strong>
  </dt>
  <dd>
    <p>A basic call to <em>type()</em> returns the \s-1OS\s0 type information of the first record. If $index is given, it returns the \s-1OS\s0 type information for the given record. The index starts at 0.</p>
  </dd>
  <dt>
    <strong></strong><strong>vendor()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>vendor($index)</strong>
  </dt>
  <dd>
    <p>A basic call to <em>vendor()</em> returns the \s-1OS\s0 vendor information of the first record. If $index is given, it returns the \s-1OS\s0 vendor information for the given record. The index starts at 0.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>I think some of us best learn from examples. These are a couple of examples to help create custom security audit tools using some of the nice features of the Nmap::Parser module. Hopefully this can double as a tutorial. More tutorials (articles) can be found at www.nmapparser.com You can run a nmap scan and have the parser parse the information automagically. The only constraint is that you cannot use '-oX', '-oN', or '-oG' as one of your arguments for nmap command line parameters passed to <em>parsescan()</em>.</p><p> use Nmap::Parser;</p><p> my $np = new Nmap::Parser;  my @hosts = @ARGV; #get hosts from cmd line</p><p> #runs the nmap command with hosts and parses it automagically  $np-&gt;parsescan('/usr/bin/nmap','-sS O -p 1-1023',@hosts);</p><p> for my $host ($np-&gt;all_hosts()){         print $host-&gt;hostname."&#92;n";         #do mor stuff...  } This is probably the easiest way to write a script with using Nmap::Parser, if you don't need the general scan session information. During the parsing process, the parser will obtain information of every host. The callback function (in this case '<em>booyah()</em>')  is called after the parsing of every host (sequentially). When the callback returns, the parser will delete all information of the host it had sent to the callback. This callback function is called for every host that the parser encounters. <em>The callback function must be</em> setup before parsing</p><p> use Nmap::Parser;  my $np = new Nmap::Parser;</p><p> $np-&gt;callback( &#92;&booyah );</p><p> $np-&gt;parsefile('nmap_results.xml');     # or use parsescan()</p><p> sub booyah {     my $host = shift; #Nmap::Parser::Host object, just parsed     print 'IP: ',$host-&gt;addr,"&#92;n";          # ... do more stuff with $host ...</p><p>    #when it returns, host object will be deleted from memory     #(good for processing VERY LARGE files or scans)  } Using multiple instances of Nmap::Parser is extremely useful in helping audit/monitor the network <strong>P</strong>olicy (ohh noo! its that 'P' word!). In this example, we have a set of hosts that had been scanned previously for tcp services where the image was saved in <em>base_image.xml</em>. We now will scan the same hosts, and compare if any new tcp have been open since then (good way to look for suspicious new services). Easy security <strong>C</strong>ompliance detection. (ooh noo! The 'C' word too!).</p><p> use Nmap::Parser;  use vars qw($nmap_exe $nmap_args @ips);  my $base = new Nmap::Parser;  my $curr = new Nmap::Parser;</p><p> $base-&gt;parsefile('base_image.xml'); #load previous state  $curr-&gt;parsescan($nmap_exe, $nmap_args, @ips); #scan current hosts</p><p> for my $ip ($curr-&gt;get_ips )  {         #assume that IPs in base == IPs in curr scan         my $ip_base = $base-&gt;get_host($ip);         my $ip_curr = $curr-&gt;get_host($ip);         my %port = ();</p><p>        #find ports that are open that were not open before         #by finding the difference in port lists         my @diff =  grep { $port{$_} &lt; 2}                    (map {$port{$_}++; $_}                    ( $ip_curr-&gt;tcp_open_ports , $ip_base-&gt;tcp_open_ports ));</p><p>        print "$ip has these new ports open: ".join(',',@diff) if(scalar @diff);</p><p>        for (@diff){print "$_ seems to be ",$ip_curr-&gt;tcp_service($_)-&gt;name,"&#92;n";}</p><p> }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>If you have questions about how to use the module, or any of its features, you can post messages to the Nmap::Parser module forum on CPAN::Forum. &lt;http://www.cpanforum.com/dist/Nmap-Parser&gt; Please submit any bugs to: &lt;http://sourceforge.net/tracker/?group_id=97509&atid=618345&gt;</p><p><strong>Please make sure that you submit the xml-output file of the scan which you are having</strong> trouble. This can be done by running your scan with the <em>-oX filename.xml</em> nmap switch. Please remove any important \s-1IP\s0 addresses for security reasons.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Nmap::Parser&hellip;</h2>
        <div class="sectioncontent">
<p> nmap, XML::Twig</p><p>The Nmap::Parser page can be found at: &lt;http://www.nmapparser.com&gt;. It contains the latest developments on the module. The nmap security scanner homepage can be found at: &lt;http://www.insecure.org/nmap/&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Anthony G Persaud &lt;apersaud@gmail.com&gt; &lt;http://www.anthonypersaud.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>This program is free software; you can redistribute it and/or modify it under the terms of the \s-1GNU\s0 General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0 General Public License for more details.</p><p>&lt;http://www.opensource.org/licenses/gpl-license.php&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="News::Scan::Thread.3pm.html"><span aria-hidden="true">&larr;</span> News::Scan::Thread.3pm: Keep track of threads in a usenet newsgroup</a></li>
   <li class="next"><a href="Normalize::Text::Music_Fields.3pm.html">Normalize::Text::Music_Fields.3pm: Normalize names of people's and (musical) works. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>std::multimap: Std::multimap _key, _tp, _compare, _alloc  -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Std::multimap _key, _tp, _compare, _alloc  -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="std::multimap (3cxx) manual">
  <meta name="twitter:description" content="Std::multimap _key, _tp, _compare, _alloc  -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libstdc++-4.8-doc-std::multimap-3cxx.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3cxx/libstdc++-4.8-doc-std::multimap.3cxx.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="std::multimap (3cxx) manual" />
  <meta property="og:description" content="Std::multimap _key, _tp, _compare, _alloc  -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libstdc++-4.8-doc-std::multimap-3cxx.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">std::multimap<small> (3cxx)</small></h1>
        <p class="lead">Std::multimap _key, _tp, _compare, _alloc  -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::multimap.3cxx.html">
      <span itemprop="name">std::multimap: Std::multimap _key, _tp, _compare, _alloc  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libstdc++-4.8-doc/">
      <span itemprop="name">libstdc++-4.8-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::multimap.3cxx.html">
      <span itemprop="name">std::multimap: Std::multimap _key, _tp, _compare, _alloc  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<h3>Public Types</h3>
<p>typedef _Alloc <strong>allocator_type</strong></p><p>typedef _Rep_type::const_iterator <strong>const_iterator</strong></p><p>typedef</p><p>_Alloc_traits::const_pointer <strong>const_pointer</strong>"</p><p>typedef</p><p>_Alloc_traits::const_reference <strong>const_reference</strong>"</p><p>typedef</p><p><strong>_Rep_type::const_reverse_iterator</strong> <strong>const_reverse_iterator</strong>"</p><p>typedef _Rep_type::difference_type <strong>difference_type</strong></p><p>typedef _Rep_type::iterator <strong>iterator</strong></p><p>typedef _Compare <strong>key_compare</strong></p><p>typedef _Key <strong>key_type</strong></p><p>typedef _Tp <strong>mapped_type</strong></p><p>typedef _Alloc_traits::pointer <strong>pointer</strong></p><p>typedef _Alloc_traits::reference <strong>reference</strong></p><p>typedef <strong>_Rep_type::reverse_iterator</strong> <strong>reverse_iterator</strong></p><p>typedef _Rep_type::size_type <strong>size_type</strong></p><p>typedef <strong>std::pair</strong>&lt; const _Key,</p><p>_Tp &gt; <strong>value_type</strong>"</p>
<h3>Public Member Functions</h3>
<p><strong>multimap</strong> ()</p><p><strong>multimap</strong> (const _Compare &__comp, const allocator_type &__a=allocator_type())</p><p><strong>multimap</strong> (const <strong>multimap</strong> &__x)</p><p><strong>multimap</strong> (<strong>multimap</strong> &&__x) noexcept(is_nothrow_copy_constructible&lt; _Compare &gt;::value)</p><p><strong>multimap</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l, const _Compare &__comp=_Compare(), const allocator_type &__a=allocator_type())</p><p><strong>multimap</strong> (const allocator_type &__a)</p><p><strong>multimap</strong> (const <strong>multimap</strong> &__m, const allocator_type &__a)</p><p><strong>multimap</strong> (<strong>multimap</strong> &&__m, const allocator_type &__a) noexcept(is_nothrow_copy_constructible&lt; _Compare &gt;::value &&_Alloc_traits::_S_always_equal())</p><p><strong>multimap</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l, const allocator_type &__a)</p><p>template&lt;typename _InputIterator &gt; <strong>multimap</strong> (_InputIterator __first, _InputIterator __last, const allocator_type &__a)</p><p>template&lt;typename _InputIterator &gt; <strong>multimap</strong> (_InputIterator __first, _InputIterator __last)</p><p>template&lt;typename _InputIterator &gt; <strong>multimap</strong> (_InputIterator __first, _InputIterator __last, const _Compare &__comp, const allocator_type &__a=allocator_type())</p><p>iterator <strong>begin</strong> () noexcept</p><p>const_iterator <strong>begin</strong> () const noexcept</p><p>const_iterator <strong>cbegin</strong> () const noexcept</p><p>const_iterator <strong>cend</strong> () const noexcept</p><p>void <strong>clear</strong> () noexcept</p><p>size_type <strong>count</strong> (const key_type &__x) const </p><p><strong>const_reverse_iterator</strong> <strong>crbegin</strong> () const noexcept</p><p><strong>const_reverse_iterator</strong> <strong>crend</strong> () const noexcept</p><p>template&lt;typename... _Args&gt; iterator <strong>emplace</strong> (_Args &&...__args)</p><p>template&lt;typename... _Args&gt; iterator <strong>emplace_hint</strong> (const_iterator __pos, _Args &&...__args)</p><p>bool <strong>empty</strong> () const noexcept</p><p>iterator <strong>end</strong> () noexcept</p><p>const_iterator <strong>end</strong> () const noexcept</p><p><strong>std::pair</strong>&lt; iterator, iterator &gt; <strong>equal_range</strong> (const key_type &__x)</p><p><strong>std::pair</strong>&lt; const_iterator,</p><p>const_iterator &gt; <strong>equal_range</strong> (const key_type &__x) const "</p><p>iterator <strong>erase</strong> (const_iterator __position)</p><p>_GLIBCXX_ABI_TAG_CXX11 iterator <strong>erase</strong> (iterator __position)</p><p>size_type <strong>erase</strong> (const key_type &__x)</p><p>iterator <strong>erase</strong> (const_iterator __first, const_iterator __last)</p><p>iterator <strong>find</strong> (const key_type &__x)</p><p>const_iterator <strong>find</strong> (const key_type &__x) const </p><p>allocator_type <strong>get_allocator</strong> () const noexcept</p><p>iterator <strong>insert</strong> (const <strong>value_type</strong> &__x)</p><p>template&lt;typename _Pair , typename  = typename std::enable_if&lt;std::is_constructible&lt;value_type,						    _Pair&&&gt;::value&gt;::type&gt; iterator <strong>insert</strong> (_Pair &&__x)</p><p>iterator <strong>insert</strong> (const_iterator __position, const <strong>value_type</strong> &__x)</p><p>template&lt;typename _Pair , typename  = typename std::enable_if&lt;std::is_constructible&lt;value_type,						    _Pair&&&gt;::value&gt;::type&gt; iterator <strong>insert</strong> (const_iterator __position, _Pair &&__x)</p><p>template&lt;typename _InputIterator &gt; void <strong>insert</strong> (_InputIterator __first, _InputIterator __last)</p><p>void <strong>insert</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l)</p><p>key_compare <strong>key_comp</strong> () const </p><p>iterator <strong>lower_bound</strong> (const key_type &__x)</p><p>const_iterator <strong>lower_bound</strong> (const key_type &__x) const </p><p>size_type <strong>max_size</strong> () const noexcept</p><p><strong>multimap</strong> & <strong>operator=</strong> (const <strong>multimap</strong> &__x)</p><p><strong>multimap</strong> & <strong>operator=</strong> (<strong>multimap</strong> &&__x) noexcept(_Alloc_traits::_S_nothrow_move())</p><p><strong>multimap</strong> & <strong>operator=</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l)</p><p><strong>reverse_iterator</strong> <strong>rbegin</strong> () noexcept</p><p><strong>const_reverse_iterator</strong> <strong>rbegin</strong> () const noexcept</p><p><strong>reverse_iterator</strong> <strong>rend</strong> () noexcept</p><p><strong>const_reverse_iterator</strong> <strong>rend</strong> () const noexcept</p><p>size_type <strong>size</strong> () const noexcept</p><p>void <strong>swap</strong> (<strong>multimap</strong> &__x) noexcept(_Alloc_traits::_S_nothrow_swap())</p><p>iterator <strong>upper_bound</strong> (const key_type &__x)</p><p>const_iterator <strong>upper_bound</strong> (const key_type &__x) const </p><p>value_compare <strong>value_comp</strong> () const </p>
<h3>Friends</h3>
<p>template&lt;typename _K1 , typename _T1 , typename _C1 , typename _A1 &gt; bool <strong>operator&lt;</strong> (const <strong>multimap</strong>&lt; _K1, _T1, _C1, _A1 &gt; &, const <strong>multimap</strong>&lt; _K1, _T1, _C1, _A1 &gt; &)</p><p>template&lt;typename _K1 , typename _T1 , typename _C1 , typename _A1 &gt; bool <strong>operator==</strong> (const <strong>multimap</strong>&lt; _K1, _T1, _C1, _A1 &gt; &, const <strong>multimap</strong>&lt; _K1, _T1, _C1, _A1 &gt; &)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;class std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;</h3>
<p>A standard container made up of (key,value) pairs, which can be retrieved based on a key, in logarithmic time.</p><p><strong>Template Parameters:</strong></p><p><em>_Key</em> Type of key objects.</p><p><em>_Tp</em> Type of mapped objects.</p><p><em>_Compare</em> Comparison function object type, defaults to less&lt;_Key&gt;.</p><p><em>_Alloc</em> Allocator type, defaults to allocator&lt;pair&lt;const _Key, _Tp&gt;.</p><p>Meets the requirements of a container, a reversible container, and an associative container (using equivalent keys). For a multimap&lt;Key,T&gt; the key_type is Key, the mapped_type is T, and the value_type is std::pair&lt;const Key,T&gt;.</p><p>Multimaps support bidirectional iterators.</p><p>The private tree data is declared exactly the same way for map and multimap; the distinction is made entirely in how the tree functions are called (*_unique versus *_equal, same as the standard).</p><p>Definition at line 95 of file stl_multimap.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP ()\fC [inline]\fP</h3>
<p>Default constructor creates no elements.</p><p>Definition at line 160 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (const _Compare &__comp, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP, \fC [explicit]\fP</h3>
<p>Creates a multimap with no elements.</p><p><strong>Parameters:</strong></p><p><em>__comp</em> A comparison object.</p><p><em>__a</em> An allocator object.</p><p>Definition at line 169 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (const \fBmultimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt; &__x)\fC [inline]\fP</h3>
<p>Multimap copy constructor.</p><p><strong>Parameters:</strong></p><p><em>__x</em> A multimap of identical element and allocator types.</p><p>The newly-created multimap uses a copy of the allocation object used by <em>__x</em>.</p><p>Definition at line 180 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (\fBmultimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt; &&__x)\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Multimap move constructor.</p><p><strong>Parameters:</strong></p><p><em>__x</em> A multimap of identical element and allocator types.</p><p>The newly-created multimap contains the exact contents of <em>__x</em>. The contents of <em>__x</em> are a valid, but unspecified multimap.</p><p>Definition at line 191 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (initializer_list&lt; \fBvalue_type\fP &gt;__l, const _Compare &__comp = \fC_Compare()\fP, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP</h3>
<p>Builds a multimap from an initializer_list.</p><p><strong>Parameters:</strong></p><p><em>__l</em> An initializer_list.</p><p><em>__comp</em> A comparison functor.</p><p><em>__a</em> An allocator object.</p><p>Create a multimap consisting of copies of the elements from the initializer_list. This is linear in N if the list is already sorted, and NlogN otherwise (where N is <em>__l.size()</em>).</p><p>Definition at line 205 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (const allocator_type &__a)\fC [inline]\fP, \fC [explicit]\fP</h3>
<p>Allocator-extended default constructor.</p><p>Definition at line 213 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (const \fBmultimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt; &__m, const allocator_type &__a)\fC [inline]\fP</h3>
<p>Allocator-extended copy constructor.</p><p>Definition at line 217 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (\fBmultimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt; &&__m, const allocator_type &__a)\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Allocator-extended move constructor.</p><p>Definition at line 221 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (initializer_list&lt; \fBvalue_type\fP &gt;__l, const allocator_type &__a)\fC [inline]\fP</h3>
<p>Allocator-extended initialier-list constructor.</p><p>Definition at line 227 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename _InputIterator &gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (_InputIterator__first, _InputIterator__last, const allocator_type &__a)\fC [inline]\fP</h3>
<p>Allocator-extended range constructor.</p><p>Definition at line 233 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename _InputIterator &gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (_InputIterator__first, _InputIterator__last)\fC [inline]\fP</h3>
<p>Builds a multimap from a range.</p><p><strong>Parameters:</strong></p><p><em>__first</em> An input iterator.</p><p><em>__last</em> An input iterator.</p><p>Create a multimap consisting of copies of the elements from [__first,__last). This is linear in N if the range is already sorted, and NlogN otherwise (where N is distance(__first,__last)).</p><p>Definition at line 249 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename _InputIterator &gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::\fBmultimap\fP (_InputIterator__first, _InputIterator__last, const _Compare &__comp, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP</h3>
<p>Builds a multimap from a range.</p><p><strong>Parameters:</strong></p><p><em>__first</em> An input iterator.</p><p><em>__last</em> An input iterator.</p><p><em>__comp</em> A comparison functor.</p><p><em>__a</em> An allocator object.</p><p>Create a multimap consisting of copies of the elements from [__first,__last). This is linear in N if the range is already sorted, and NlogN otherwise (where N is distance(__first,__last)).</p><p>Definition at line 265 of file stl_multimap.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::begin ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read/write iterator that points to the first pair in the multimap. Iteration is done in ascending order according to the keys.</p><p>Definition at line 350 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; const_iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::begin () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first pair in the multimap. Iteration is done in ascending order according to the keys.</p><p>Definition at line 359 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; const_iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first pair in the multimap. Iteration is done in ascending order according to the keys.</p><p>Definition at line 423 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; const_iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::cend () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last pair in the multimap. Iteration is done in ascending order according to the keys.</p><p>Definition at line 432 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::clear ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Erases all elements in a multimap. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 736 of file stl_multimap.h.</p><p>Referenced by std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator=().</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; size_type \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::count (const key_type &__x) const\fC [inline]\fP</h3>
<p>Finds the number of elements with given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pairs to be located.</p><p><strong>Returns:</strong></p><p>Number of elements with specified key.</p><p>Definition at line 793 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_reverse_iterator\fP \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::crbegin () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) reverse iterator that points to the last pair in the multimap. Iteration is done in descending order according to the keys.</p><p>Definition at line 441 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_reverse_iterator\fP \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::crend () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) reverse iterator that points to one before the first pair in the multimap. Iteration is done in descending order according to the keys.</p><p>Definition at line 450 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename... _Args&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace (_Args &&...__args)\fC [inline]\fP</h3>
<p>Build and insert a std::pair into the multimap.</p><p><strong>Parameters:</strong></p><p><em>__args</em> Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor).</p><p><strong>Returns:</strong></p><p>An iterator that points to the inserted (key,value) pair.</p><p>This function builds and inserts a (key, value) pair into the multimap. Contrary to a std::map the multimap does not rely on unique keys and thus multiple pairs with the same key can be inserted.</p><p>Insertion requires logarithmic time.</p><p>Definition at line 490 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename... _Args&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace_hint (const_iterator__pos, _Args &&...__args)\fC [inline]\fP</h3>
<p>Builds and inserts a std::pair into the multimap.</p><p><strong>Parameters:</strong></p><p><em>__pos</em> An iterator that serves as a hint as to where the pair should be inserted.</p><p><em>__args</em> Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor).</p><p><strong>Returns:</strong></p><p>An iterator that points to the inserted (key,value) pair.</p><p>This function inserts a (key, value) pair into the multimap. Contrary to a std::map the multimap does not rely on unique keys and thus multiple pairs with the same key can be inserted. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p><p>For more on <em>hinting</em>, see: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html</p><p>Insertion requires logarithmic time (if the hint is not taken).</p><p>Definition at line 517 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; bool \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::empty () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns true if the multimap is empty.</p><p>Definition at line 457 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::end ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read/write iterator that points one past the last pair in the multimap. Iteration is done in ascending order according to the keys.</p><p>Definition at line 368 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; const_iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::end () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last pair in the multimap. Iteration is done in ascending order according to the keys.</p><p>Definition at line 377 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::pair\fP&lt;iterator, iterator&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range (const key_type &__x)\fC [inline]\fP</h3>
<p>Finds a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pairs to be located.</p><p><strong>Returns:</strong></p><p>Pair of iterators that possibly points to the subsequence matching given key.</p><p>This function is equivalent to</p>
<pre>
std::make_pair(c.lower_bound(val),
               c.upper_bound(val))

</pre>
<p> (but is faster than making the calls separately).</p><p>Definition at line 860 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::pair\fP&lt;const_iterator, const_iterator&gt; \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range (const key_type &__x) const\fC [inline]\fP</h3>
<p>Finds a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pairs to be located.</p><p><strong>Returns:</strong></p><p>Pair of read-only (constant) iterators that possibly points to the subsequence matching given key.</p><p>This function is equivalent to</p>
<pre>
std::make_pair(c.lower_bound(val),
               c.upper_bound(val))

</pre>
<p> (but is faster than making the calls separately).</p><p>Definition at line 877 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase (const_iterator__position)\fC [inline]\fP</h3>
<p>Erases an element from a multimap.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator pointing to the element to be erased.</p><p><strong>Returns:</strong></p><p>An iterator pointing to the element immediately following <em>position</em> prior to the element being erased. If no such element exists, end() is returned.</p><p>This function erases an element, pointed to by the given iterator, from a multimap. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 631 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; size_type \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase (const key_type &__x)\fC [inline]\fP</h3>
<p>Erases elements according to the provided key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of element to be erased.</p><p><strong>Returns:</strong></p><p>The number of elements erased.</p><p>This function erases all elements located by the given key from a multimap. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 667 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase (const_iterator__first, const_iterator__last)\fC [inline]\fP</h3>
<p>Erases a [first,last) range of elements from a multimap.</p><p><strong>Parameters:</strong></p><p><em>__first</em> Iterator pointing to the start of the range to be erased.</p><p><em>__last</em> Iterator pointing to the end of the range to be erased .</p><p><strong>Returns:</strong></p><p>The iterator <em>__last</em>.</p><p>This function erases a sequence of elements from a multimap. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 688 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::find (const key_type &__x)\fC [inline]\fP</h3>
<p>Tries to locate an element in a multimap.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pair to be located.</p><p><strong>Returns:</strong></p><p>Iterator pointing to sought-after element, or end() if not found.</p><p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after pair. If unsuccessful it returns the past-the-end ( end() ) iterator.</p><p>Definition at line 769 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; const_iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::find (const key_type &__x) const\fC [inline]\fP</h3>
<p>Tries to locate an element in a multimap.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pair to be located.</p><p><strong>Returns:</strong></p><p>Read-only (constant) iterator pointing to sought-after element, or end() if not found.</p><p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns a constant iterator pointing to the sought after pair. If unsuccessful it returns the past-the-end ( end() ) iterator.</p><p>Definition at line 784 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; allocator_type \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::get_allocator () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Get a copy of the memory allocation object.</p><p>Definition at line 340 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert (const \fBvalue_type\fP &__x)\fC [inline]\fP</h3>
<p>Inserts a std::pair into the multimap.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Pair to be inserted (see std::make_pair for easy creation of pairs).</p><p><strong>Returns:</strong></p><p>An iterator that points to the inserted (key,value) pair.</p><p>This function inserts a (key, value) pair into the multimap. Contrary to a std::map the multimap does not rely on unique keys and thus multiple pairs with the same key can be inserted.</p><p>Insertion requires logarithmic time.</p><p>Definition at line 537 of file stl_multimap.h.</p><p>Referenced by std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert(), and std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator=().</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert (const_iterator__position, const \fBvalue_type\fP &__x)\fC [inline]\fP</h3>
<p>Inserts a std::pair into the multimap.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator that serves as a hint as to where the pair should be inserted.</p><p><em>__x</em> Pair to be inserted (see std::make_pair for easy creation of pairs).</p><p><strong>Returns:</strong></p><p>An iterator that points to the inserted (key,value) pair.</p><p>This function inserts a (key, value) pair into the multimap. Contrary to a std::map the multimap does not rely on unique keys and thus multiple pairs with the same key can be inserted. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p><p>For more on <em>hinting</em>, see: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html</p><p>Insertion requires logarithmic time (if the hint is not taken).</p><p>Definition at line 571 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename _InputIterator &gt; void \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert (_InputIterator__first, _InputIterator__last)\fC [inline]\fP</h3>
<p>A template function that attempts to insert a range of elements.</p><p><strong>Parameters:</strong></p><p><em>__first</em> Iterator pointing to the start of the range to be inserted.</p><p><em>__last</em> Iterator pointing to the end of the range.</p><p>Complexity similar to that of the range constructor.</p><p>Definition at line 598 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert (initializer_list&lt; \fBvalue_type\fP &gt;__l)\fC [inline]\fP</h3>
<p>Attempts to insert a list of std::pairs into the multimap.</p><p><strong>Parameters:</strong></p><p><em>__l</em> A std::initializer_list&lt;value_type&gt; of pairs to be inserted.</p><p>Complexity similar to that of the range constructor.</p><p>Definition at line 610 of file stl_multimap.h.</p><p>References std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert().</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; key_compare \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::key_comp () const\fC [inline]\fP</h3>
<p>Returns the key comparison object out of which the multimap was constructed.</p><p>Definition at line 745 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound (const key_type &__x)\fC [inline]\fP</h3>
<p>Finds the beginning of a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pair to be located.</p><p><strong>Returns:</strong></p><p>Iterator pointing to first element equal to or greater than key, or end().</p><p>This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or end() if no such element exists.</p><p>Definition at line 808 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; const_iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound (const key_type &__x) const\fC [inline]\fP</h3>
<p>Finds the beginning of a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pair to be located.</p><p><strong>Returns:</strong></p><p>Read-only (constant) iterator pointing to first element equal to or greater than key, or end().</p><p>This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful the iterator will point to the next greatest element or, if no such greater element exists, to end().</p><p>Definition at line 823 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; size_type \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::max_size () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the maximum size of the multimap.</p><p>Definition at line 467 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBmultimap\fP& \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator= (const \fBmultimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt; &__x)\fC [inline]\fP</h3>
<p>Multimap assignment operator. The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p><strong>Parameters:</strong></p><p><em>__x</em> A multimap of identical element and allocator types.</p><p>All the elements of <em>__x</em> are copied, but unlike the copy constructor, the allocator object is not copied.</p><p>Definition at line 288 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBmultimap\fP& \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator= (\fBmultimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt; &&__x)\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Multimap move assignment operator.</p><p><strong>Parameters:</strong></p><p><em>__x</em> A multimap of identical element and allocator types.</p><p>The contents of <em>__x</em> are moved into this multimap (without copying if the allocators compare equal or get moved on assignment). Afterwards <em>__x</em> is in a valid, but unspecified state.</p><p>Definition at line 304 of file stl_multimap.h.</p><p>References std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;::clear(), and std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert().</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBmultimap\fP& \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator= (initializer_list&lt; \fBvalue_type\fP &gt;__l)\fC [inline]\fP</h3>
<p>Multimap list assignment operator.</p><p><strong>Parameters:</strong></p><p><em>__l</em> An initializer_list.</p><p>This function fills a multimap with copies of the elements in the initializer list <em>__l</em>.</p><p>Note that the assignment completely changes the multimap and that the resulting multimap's size is the same as the number of elements assigned. Old data may be lost.</p><p>Definition at line 330 of file stl_multimap.h.</p><p>References std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;::clear(), and std::multimap&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert().</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBreverse_iterator\fP \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::rbegin ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read/write reverse iterator that points to the last pair in the multimap. Iteration is done in descending order according to the keys.</p><p>Definition at line 386 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_reverse_iterator\fP \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::rbegin () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) reverse iterator that points to the last pair in the multimap. Iteration is done in descending order according to the keys.</p><p>Definition at line 395 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBreverse_iterator\fP \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::rend ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read/write reverse iterator that points to one before the first pair in the multimap. Iteration is done in descending order according to the keys.</p><p>Definition at line 404 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_reverse_iterator\fP \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::rend () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) reverse iterator that points to one before the first pair in the multimap. Iteration is done in descending order according to the keys.</p><p>Definition at line 413 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; size_type \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::size () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the size of the multimap.</p><p>Definition at line 462 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::swap (\fBmultimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt; &__x)\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Swaps data with another multimap.</p><p><strong>Parameters:</strong></p><p><em>__x</em> A multimap of the same element and allocator types.</p><p>This exchanges the elements between two multimaps in constant time. (It is only swapping a pointer, an integer, and an instance of the Compare type (which itself is often stateless and empty), so it should be quite fast.) Note that the global std::swap() function is specialized such that std::swap(m1,m2) will feed to this function.</p><p>Definition at line 723 of file stl_multimap.h.</p><p>Referenced by std::swap().</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::upper_bound (const key_type &__x)\fC [inline]\fP</h3>
<p>Finds the end of a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pair to be located.</p><p><strong>Returns:</strong></p><p>Iterator pointing to the first element greater than key, or end().</p><p>Definition at line 833 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; const_iterator \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::upper_bound (const key_type &__x) const\fC [inline]\fP</h3>
<p>Finds the end of a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of (key, value) pair to be located.</p><p><strong>Returns:</strong></p><p>Read-only (constant) iterator pointing to first iterator greater than key, or end().</p><p>Definition at line 843 of file stl_multimap.h.</p>
<h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; value_compare \fBstd::multimap\fP&lt; _Key, _Tp, _Compare, _Alloc &gt;::value_comp () const\fC [inline]\fP</h3>
<p>Returns a value comparison object, built from the key comparison object out of which the multimap was constructed.</p><p>Definition at line 753 of file stl_multimap.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for libstdc++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libstdc++-4.9-doc-std::move_iterator.3cxx.html"><span aria-hidden="true">&larr;</span> std::move_iterator.3cxx: Std::move_iterator _iterator  -</a></li>
   <li class="next"><a href="libstdc++-4.9-doc-std::multimap.3cxx.html">std::multimap.3cxx: Std::multimap _key, _tp, _compare, _alloc  - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Text::DelimMatch: Perl extension to find regexp delimited strings with proper nesting</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl extension to find regexp delimited strings with proper nesting">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Text::DelimMatch (3pm) manual">
  <meta name="twitter:description" content="Perl extension to find regexp delimited strings with proper nesting">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdelimmatch-perl-Text::DelimMatch-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Text::DelimMatch.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Text::DelimMatch (3pm) manual" />
  <meta property="og:description" content="Perl extension to find regexp delimited strings with proper nesting" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdelimmatch-perl-Text::DelimMatch-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Text::DelimMatch<small> (3pm)</small></h1>
        <p class="lead">Perl extension to find regexp delimited strings with proper nesting</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Text::DelimMatch.3pm.html">
      <span itemprop="name">Text::DelimMatch: Perl extension to find regexp delimited strings with proper nesting</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdelimmatch-perl/">
      <span itemprop="name">libdelimmatch-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Text::DelimMatch.3pm.html">
      <span itemprop="name">Text::DelimMatch: Perl extension to find regexp delimited strings with proper nesting</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Text::DelimMatch;

  $mc = new Text::DelimMatch, $startdelim, $enddelim;

  $mc-&gt;quote(&apos;"&apos;);
  $mc-&gt;escape("&#92;&#92;");
  $mc-&gt;double_escape(&apos;"&apos;);
  $mc-&gt;<strong>case_sensitive</strong>(1);

  ($prefix, $match, $remainder) = $mc-&gt;match($string);
  ($prefix, $nextmatch, $remainder) = $mc-&gt;match();

  $middle = $mc-&gt;strip_delim($match); # returns $match w/o start and end delim
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>These routines allow you to match delimited substrings in a buffer.  The delimiters can be specified with any regular expression and the start and end delimiters need not be the same.  If the delimited text is properly nested, entire nested groups are returned.</p><p>In addition, you may specify quoting and escaping characters that contribute to the recognition of start and end delimiters.</p><p>For example, if you specify the start and end delimiters as '&#92;(' and '&#92;)', respectively, and the double quote character as a quoting character, and the backslash as an escaping character, then the delimited substring in this buffer is \*(L"(ma(t)c&#92;)h)\*(R":</p><p>  &apos;prefix text "(quoted text)" &#92;(escaped &#92;" text) (ma(t)c&#92;)h) postfix text&apos;</p><p>In order to support this rather complex interface, the matching context is encapsulated in an object.  The object, Text::DelimMatch, has the following public methods: Creates a new object.  All of the arguments are optional, and can be set with other methods, but they must be passed in the specified order: start delimiter, end delimiter, escape characters, double escape characters, and a set of quote characters. In an array context, returns ($pre, $match, $post) where $pre is the text preceding the first match, $match is the matched text (including the delimiters), and $post is the rest of the text in the buffer. In a scalar context, returns $match. If $string is not provided on subsequent calls, the $post from the previous match is used, unless keep is false.  If keep is false, the match always fails. Returns $string with the start and end delimiters removed. Set the start and end delimiters.  Only one set of delimiters can be in use at any one time. Returns the delimters in use before this call. Specifies the start and end quote characters.  Multiple quote character pairs are supported, so this function is additive.  To clear the current settings, pass no arguments, e.g., $mc-&gt;<em>quote()</em>. If only $start is passed, $end is assumed to be the same. In matching, quotes occur in pairs.  In other words, if (\*(L",\*(R") and (',') are both specified as quote pairs and a string beginning with \*(L" is found, it is ended only by another \*(R", not by '. Returns the quote hash in use before this call. Specifies a set of escaping characters.  This can only be a string of characters.  $esc can be a regexp set or a simple string.  If it is a simple string, it will be translated into the regexp set \*(L"[ quotemeta($esc) ]\*(R". Returns the escape characters in use before this call. Specifies a set of double-escaping characters, i.e., characters that are considered escaped if they occur in pairs.  For example, in some languages,   &apos;Don&apos;&apos;t you see?&apos; defines a string containing a single apostrophe. $esc can only be a string of characters.  $esc can be a regexp set or a simple string.  If it is a simple string, it will be translated into the regexp set \*(L"[ quotemeta($esc) ]\*(R". Returns the double-escaping characters in use before this call. Sets case sensitivity to $bool or true if $bool is not specified. Returns the case sensitivity in use before this call. Sets keep to $bool or true if $bool is not specified. Keep, which is true by default, specifies whether or not the matching context object keeps a local copy of the buffer used in matching.  Keeping a local copy allows repeated matching on the same buffer, but might be a bad idea if the buffer is a terabyte long. ;-) Returns the keep setting in use before this call. Sets returndelim to $bool or true if $bool is not specified. Returndelim, which is true by default, specifies whether or not the start and end delimiters are returned with the matching string. Returns the returndelim setting in use before this call. Returns the last error that occured.  If $seterr is passed, the error is set to that value.  Some common kinds of bad input are detected and an error condition is raised.  If an error condition is raised, all matching fails until the error is cleared. The most common error is a bad regular expression, for example specifing the start delimiter as \*(L"(\*(R" instead of \*(L"&#92;&#92;(\*(R".  Remember, these are regexps!</p>
<dl class='dl-vertical'>
  <dt>
    pre_matched
  </dt>
  <dd>
    <p>Returns the prefix text from the last match if keep is true.  Sets an error and returns an empty string if keep is false.</p>
  </dd>
  <dt>
    matched
  </dt>
  <dd>
    <p>Returns the matched text from the last match if keep is true.  Sets an error and returns an empty string if keep is false.</p>
  </dd>
  <dt>
    post_matched
  </dt>
  <dd>
    <p>Returns the postfix text from the last match if keep is true.  Sets an error and returns an empty string if keep is false. Sets debug to $bool or true if $bool is not specified. If debug is true, informative and progress messages are printed to \s-1STDOUT\s0 by some methods. Returns the debugging setting in use before this call.</p>
  </dd>
  <dt>
    dump
  </dt>
  <dd>
    <p>For debugging, prints all of the instance variables for a particular object. For debugging.  Some classes of delimited strings can be located with much faster algorithms than can be used in the most general case.  If slow is true, the slower, general algorithm is always used.</p>
  </dd>

</dl>
<p>For simplicity, and backward compatibility with the previous (limited release) incarnation of this module, the following functions are also available directly: If $three is true, returns ($pre, $match, $post) in an array context otherwise returns (\*(L"$pre$match\*(R", $post).  In a scalar context, returns \*(L"$pre$match\*(R". If $three is true, returns ($pre, $match, $post) in an array context otherwise returns (\*(L"$pre$match\*(R", $post).  In a scalar context, returns $post.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>  $mc = new Text::DelimMatch &apos;"&apos;;   $mc-&gt;(&apos;pre "match" post&apos;) == &apos;"match"&apos;;</p><p>  $mc-&gt;delim("&#92;&#92;(", "&#92;&#92;)");   $mc-&gt;(&apos;pre (match) post&apos;)   == (&apos;pre &apos;, &apos;(match)&apos;, &apos; post&apos;);   $mc-&gt;(&apos;pre (ma(t)ch) post&apos;) == (&apos;pre &apos;, &apos;(ma(t)ch)&apos;, &apos; post&apos;);</p><p>  $mc-&gt;quote(&apos;"&apos;);   $mc-&gt;escape("&#92;&#92;");   $mc-&gt;(&apos;pre (ma")"tch) post&apos;) == (&apos;pre &apos;, &apos;(ma")"tch)&apos;, &apos; post&apos;);   $mc-&gt;(&apos;pre (ma(t)c&#92;)h&#92;") post&apos;) == (&apos;pre &apos;, &apos;(ma(t)c&#92;)h&#92;")&apos;, &apos; post&apos;);</p><p>See also test.pl in the distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Norman Walsh, ndw@nwalsh.com</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 1997-2002 Norman Walsh. All rights reserved.  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WARRANTY</h2>
        <div class="sectioncontent">
<p>\s-1THIS\s0 \s-1PACKAGE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1AND\s0 \s-1WITHOUT\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0, \s-1INCLUDING\s0, \s-1WITHOUT\s0 \s-1LIMITATION\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTIBILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Text::DelimMatch&hellip;</h2>
        <div class="sectioncontent">
<p><em>perl</em>\|(1).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Text::DHCPLeases::Object::Iterator.3pm.html"><span aria-hidden="true">&larr;</span> Text::DHCPLeases::Object::Iterator.3pm: Lease object iterator class</a></li>
   <li class="next"><a href="Text::Diff.3pm.html">Text::Diff.3pm: Perform diffs on files and record sets <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

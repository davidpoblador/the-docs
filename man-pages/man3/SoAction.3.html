<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoAction: The soaction class is the base class for all traversal actions.  applying actions is the basic mechanism in coin for executing various operations on scene graphs or paths within scene graphs, including search operations, rendering, interaction through picking, etc.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soaction class is the base class for all traversal actions.  applying actions is the basic mechanism in coin for executing various operations on scene graphs or paths within scene graphs, including search operations, rendering, interaction through picking, etc.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoAction (3) manual">
  <meta name="twitter:description" content="The soaction class is the base class for all traversal actions.  applying actions is the basic mechanism in coin for executing various operations on scene graphs or paths within scene graphs, including search operations, rendering, interaction through picking, etc.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoAction-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoAction.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoAction (3) manual" />
  <meta property="og:description" content="The soaction class is the base class for all traversal actions.  applying actions is the basic mechanism in coin for executing various operations on scene graphs or paths within scene graphs, including search operations, rendering, interaction through picking, etc." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoAction-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoAction<small> (3)</small></h1>
        <p class="lead">The soaction class is the base class for all traversal actions.  applying actions is the basic mechanism in coin for executing various operations on scene graphs or paths within scene graphs, including search operations, rendering, interaction through picking, etc.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoAction.3.html">
      <span itemprop="name">SoAction: The soaction class is the base class for all traversal actions.  applying actions is the basic mechanism in coin for executing various operations on scene graphs or paths within scene graphs, including search operations, rendering, interaction through picking, etc.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoAction.3.html">
      <span itemprop="name">SoAction: The soaction class is the base class for all traversal actions.  applying actions is the basic mechanism in coin for executing various operations on scene graphs or paths within scene graphs, including search operations, rendering, interaction through picking, etc.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/actions/SoAction.h&gt;</p><p>Inherited by <strong>SoAudioRenderAction</strong>, <strong>SoCallbackAction</strong>, <strong>SoGetBoundingBoxAction</strong>, <strong>SoGetMatrixAction</strong>, <strong>SoGetPrimitiveCountAction</strong>, <strong>SoGLRenderAction</strong>, <strong>SoHandleEventAction</strong>, <strong>SoIntersectionDetectionAction</strong>, <strong>SoPickAction</strong>, <strong>SoSearchAction</strong>, <strong>SoSimplifyAction</strong>, <strong>SoToVRMLAction</strong>, and <strong>SoWriteAction</strong>.</p><h3>Public Types</h3>
<p>enum <strong>AppliedCode</strong> { <strong>NODE</strong> = 0, <strong>PATH</strong> = 1, <strong>PATH_LIST</strong> = 2 }</p><p>enum <strong>PathCode</strong> { <strong>NO_PATH</strong> = 0, <strong>IN_PATH</strong> = 1, <strong>BELOW_PATH</strong> = 2, <strong>OFF_PATH</strong> = 3 }</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>~SoAction</strong> (void)</p><p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const =0</p><p>virtual SbBool <strong>isOfType</strong> (<strong>SoType</strong> type) const </p><p>virtual void <strong>apply</strong> (<strong>SoNode</strong> *root)</p><p>virtual void <strong>apply</strong> (<strong>SoPath</strong> *path)</p><p>virtual void <strong>apply</strong> (const <strong>SoPathList</strong> &pathlist, SbBool obeysrules=FALSE)</p><p>void <strong>apply</strong> (<strong>SoAction</strong> *beingApplied)</p><p>virtual void <strong>invalidateState</strong> (void)</p><p><strong>AppliedCode</strong> <strong>getWhatAppliedTo</strong> (void) const </p><p><strong>SoNode</strong> * <strong>getNodeAppliedTo</strong> (void) const </p><p><strong>SoPath</strong> * <strong>getPathAppliedTo</strong> (void) const </p><p>const <strong>SoPathList</strong> * <strong>getPathListAppliedTo</strong> (void) const </p><p>const <strong>SoPathList</strong> * <strong>getOriginalPathListAppliedTo</strong> (void) const </p><p>SbBool <strong>isLastPathListAppliedTo</strong> (void) const </p><p><strong>PathCode</strong> <strong>getPathCode</strong> (int &numindices, const int *&indices)</p><p>void <strong>traverse</strong> (<strong>SoNode</strong> *const node)</p><p>SbBool <strong>hasTerminated</strong> (void) const </p><p>const <strong>SoPath</strong> * <strong>getCurPath</strong> (void)</p><p><strong>SoState</strong> * <strong>getState</strong> (void) const </p><p><strong>PathCode</strong> <strong>getCurPathCode</strong> (void) const </p><p>virtual <strong>SoNode</strong> * <strong>getCurPathTail</strong> (void)</p><p>void <strong>usePathCode</strong> (int &numindices, const int *&indices)</p><p>void <strong>pushCurPath</strong> (const int childindex, <strong>SoNode</strong> *node=NULL)</p><p>void <strong>popCurPath</strong> (const <strong>PathCode</strong> prevpathcode)</p><p>void <strong>pushCurPath</strong> (void)</p><p>void <strong>popPushCurPath</strong> (const int childindex, <strong>SoNode</strong> *node=NULL)</p><p>void <strong>popCurPath</strong> (void)</p><p>void <strong>switchToPathTraversal</strong> (<strong>SoPath</strong> *path)</p><p>void <strong>switchToNodeTraversal</strong> (<strong>SoNode</strong> *node)</p>
<h3>Static Public Member Functions</h3>
<p>static void <strong>initClass</strong> (void)</p><p>static void <strong>initClasses</strong> (void)</p><p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>nullAction</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p>
<h3>Protected Member Functions</h3>
<p><strong>SoAction</strong> (void)</p><p>virtual void <strong>beginTraversal</strong> (<strong>SoNode</strong> *node)</p><p>virtual void <strong>endTraversal</strong> (<strong>SoNode</strong> *node)</p><p>void <strong>setTerminated</strong> (const SbBool flag)</p><p>virtual const</p><p><strong>SoEnabledElementsList</strong> & <strong>getEnabledElements</strong> (void) const "</p><p>virtual SbBool <strong>shouldCompactPathList</strong> (void) const </p>
<h3>Static Protected Member Functions</h3>
<p>static <strong>SoEnabledElementsList</strong> * <strong>getClassEnabledElements</strong> (void)</p><p>static <strong>SoActionMethodList</strong> * <strong>getClassActionMethods</strong> (void)</p>
<h3>Protected Attributes</h3>
<p><strong>SoState</strong> * <strong>state</strong></p><p><strong>SoActionMethodList</strong> * <strong>traversalMethods</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoAction</strong> class is the base class for all traversal actions.</p><p>Applying actions is the basic mechanism in Coin for executing various operations on scene graphs or paths within scene graphs, including search operations, rendering, interaction through picking, etc.</p><p>The basic operation is to instantiate an action, set it up with miscellaneous parameters if necessary, then call it's <strong>apply()</strong> method on the root node of the scenegraph (or sub-graph of a scenegraph). The action then traverses the scenegraph from the root node, depth-first and left-to-right, applying it's specific processing at the nodes where it is applicable.</p><p>(The <strong>SoAction</strong> and it's derived classes in Coin is an implementation of the design pattern commonly known as the 'Visitor' pattern.)</p><p>Here's a simple example that shows how to use the <strong>SoWriteAction</strong> to dump a scenegraph in the Inventor format to a file:</p>
<pre>
int write_scenegraph(const char * filename, SoNode * root)
{
  SoOutput output;
  if (!output.openFile(filename)) return 0;

  // This is where the action is.  ;-)
  SoWriteAction wa(&output);
  wa.apply(root);

  return 1;
}
</pre>
<p>After traversal, some action types have stored information about the (sub-)scenegraph that was traversed, which you can then inquire about through methods like <strong>SoGetBoundingBoxAction::getBoundingBox()</strong>, <strong>SoRayPickAction::getPickedPoint()</strong>, <strong>SoGetPrimitiveCountAction::getTriangleCount()</strong>, etc etc.</p><p>See the various built-in actions for further information (ie the subclasses of this class), or look at the example code applications of the Coin library to see how actions are generally used.</p><p>For extending the Coin library with your own classes, we strongly recommend that you make yourself acquainted with the excellent «The Inventor Toolmaker» book (ISBN 0-201-62493-1), which describes the tasks involved in detail. This book was written by the original SGI Inventor designers and explains many of the underlying design ideas, aswell as having lots of hands-on examples on how to extend the Coin toolkit in ways that are true to the fundamental design ideas. («The Inventor Toolmaker» is also available at SGI's online library, at no cost. See Download The Inventor Toolmaker.) Reading the sourcecode of the built-in classes in Coin should also provide very helpful.</p><p>The following example shows the basic outline on how to set up your own extension action class:</p>
<pre>
// This is sample code on how you can get progress indication on Coin
// export operations by extending the library with your own action
// class. The new class inherits SoWriteAction. The code is presented
// as a stand-alone example.
//
// The general technique is to inherit SoWriteAction and override it's
// "entry point" into each node of the scenegraph. The granularity of
// the progress callbacks is on a per-node basis, which should usually
// be good enough.

#include &lt;Inventor/SoDB.h&gt;
#include &lt;Inventor/actions/SoWriteAction.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;



class MyWriteAction : public SoWriteAction {
  SO_ACTION_HEADER(SoWriteAction);

public:
  MyWriteAction(SoOutput * out);
  virtual ~MyWriteAction();

  static void initClass(void);

protected:
  virtual void beginTraversal(SoNode * node);

private:
  static void actionMethod(SoAction *, SoNode *);
  int nrnodes;
  int totalnrnodes;
};


SO_ACTION_SOURCE(MyWriteAction);

MyWriteAction::MyWriteAction(SoOutput * out)
  : SoWriteAction(out)
{
  SO_ACTION_CONSTRUCTOR(MyWriteAction);
}

MyWriteAction::~MyWriteAction()
{
}

void
MyWriteAction::initClass(void)
{
  SO_ACTION_INIT_CLASS(MyWriteAction, SoWriteAction);

  SO_ACTION_ADD_METHOD(SoNode, MyWriteAction::actionMethod);
}

void
MyWriteAction::beginTraversal(SoNode * node)
{
  this-&gt;nrnodes = 0;
  this-&gt;totalnrnodes = 0;
  SoWriteAction::beginTraversal(node);
}

void
MyWriteAction::actionMethod(SoAction * a, SoNode * n)
{
  // To abort the export process in mid-writing, we could just avoid
  // calling in to the SoNode::writeS() method.
  SoNode::writeS(a, n);

  MyWriteAction * mwa = (MyWriteAction *)a;
  SoOutput * out = mwa-&gt;getOutput();
  if (out-&gt;getStage() == SoOutput::COUNT_REFS) {
    mwa-&gt;totalnrnodes++;
  }
  else { //  (out-&gt;getStage() == SoOutput::WRITE)
    mwa-&gt;nrnodes++;
    SbString s;
    s.sprintf(" # wrote node %p (%d/%d) \n", n, mwa-&gt;nrnodes, mwa-&gt;totalnrnodes);
    out-&gt;write(s.getString());
  }
}


int
main(int argc, char ** argv)
{
  if (argc &lt; 2) {
    (void)fprintf(stderr, "\n\nUsage: %s &lt;filename&gt;\n\n", argv[0]);
    <strong>exit</strong>(1);
  }

  SoDB::init();
  MyWriteAction::initClass();

  SoInput in;
  if (!in.openFile(argv[1])) { <strong>exit</strong>(1); }

  SoSeparator * root = SoDB::readAll(&in);
  if (!root) { <strong>exit</strong>(1); }

  root-&gt;ref();

  SoOutput out;
  MyWriteAction mwa(&out);
  mwa.apply(root);

  root-&gt;unref();

  return 0;
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoAction::AppliedCode\fP</h3>
<p>Enumerated values for what the action was applied to.</p>
<h3>enum \fBSoAction::PathCode\fP</h3>
<p>Enumerated values for how the action is applied to a scene graph.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoAction::~SoAction (void)\fC [virtual]\fP</h3>
<p>Destructor, free resources.</p>
<h3>SoAction::SoAction (void)\fC [protected]\fP</h3>
<p>Default constructor, does all necessary toplevel initialization.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SoAction::initClass (void)\fC [static]\fP</h3>
<p>Initializes the run-time type system for this class, and sets up the enabled elements and action method list.</p>
<h3>void SoAction::initClasses (void)\fC [static]\fP</h3>
<p>Initialize all the <strong>SoAction</strong> subclasses. Automatically called from <strong>SoAction::initClass()</strong>.</p>
<h3>\fBSoType\fP SoAction::getClassTypeId (void)\fC [static]\fP</h3>
<p>Returns the run-time type object associated with instances of this class.</p>
<h3>\fBSoType\fP SoAction::getTypeId (void) const\fC [pure virtual]\fP</h3>
<p>Returns the type identification of an action derived from a class inheriting <strong>SoAction</strong>. This is used for run-time type checking and 'downward' casting.</p><p>Usage example:</p>
<pre>
void bar(SoAction * action)
{
  if (action-&gt;getTypeId() == SoGLRenderAction::getClassTypeId()) {
    // safe downward cast, know the type
    SoGLRenderAction * glrender = (SoGLRenderAction *)action;
  }
  return; // ignore if not renderaction
}
</pre>
<p>For application programmers wanting to extend the library with new actions: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR.</p><p>For more information on writing Coin extensions, see the <strong>SoAction</strong> class documentation.</p><p>Returns the actual type id of an object derived from a class inheriting <strong>SoAction</strong>. Needs to be overridden in <em>all</em> subclasses.</p><p>Implemented in <strong>SoCallbackAction</strong>, <strong>SoIntersectionDetectionAction</strong>, <strong>SoGLRenderAction</strong>, <strong>SoRayPickAction</strong>, <strong>SoGetMatrixAction</strong>, <strong>SoHandleEventAction</strong>, <strong>SoGetBoundingBoxAction</strong>, <strong>SoGlobalSimplifyAction</strong>, <strong>SoShapeSimplifyAction</strong>, <strong>SoGetPrimitiveCountAction</strong>, <strong>SoSearchAction</strong>, <strong>SoPickAction</strong>, <strong>SoAudioRenderAction</strong>, <strong>SoReorganizeAction</strong>, <strong>SoWriteAction</strong>, <strong>SoBoxHighlightRenderAction</strong>, <strong>SoLineHighlightRenderAction</strong>, <strong>SoSimplifyAction</strong>, <strong>SoToVRMLAction</strong>, and <strong>SoToVRML2Action</strong>.</p>
<h3>SbBool SoAction::isOfType (\fBSoType\fPtype) const\fC [virtual]\fP</h3>
<p>Returns TRUE if the type of this object is either of the same type or a subclass of <em>type</em>.</p>
<h3>void SoAction::apply (\fBSoNode\fP *root)\fC [virtual]\fP</h3>
<p>Applies the action to the scene graph rooted at <em>root</em>.</p><p>Note that you should <em>not</em> apply an action to a node with a zero reference count. The behavior in that case is undefined.</p><p>Reimplemented in <strong>SoIntersectionDetectionAction</strong>, <strong>SoReorganizeAction</strong>, <strong>SoBoxHighlightRenderAction</strong>, <strong>SoLineHighlightRenderAction</strong>, <strong>SoSimplifyAction</strong>, <strong>SoToVRMLAction</strong>, and <strong>SoToVRML2Action</strong>.</p>
<h3>void SoAction::apply (\fBSoPath\fP *path)\fC [virtual]\fP</h3>
<p>Applies the action to the parts of the graph defined by <em>path</em>.</p><p>Note that an <strong>SoPath</strong> will also contain all nodes that may influence e.g. geometry nodes in the path. So for instance applying an <strong>SoGLRenderAction</strong> on an <strong>SoPath</strong> will render that path as expected in the view, where geometry will get its materials, textures, and other appearance settings correctly.</p><p>If the <em>path</em> ends in an <strong>SoGroup</strong> node, the action will also traverse the tail node's children.</p><p>Reimplemented in <strong>SoIntersectionDetectionAction</strong>, <strong>SoReorganizeAction</strong>, <strong>SoBoxHighlightRenderAction</strong>, <strong>SoLineHighlightRenderAction</strong>, <strong>SoSimplifyAction</strong>, <strong>SoToVRMLAction</strong>, and <strong>SoToVRML2Action</strong>.</p>
<h3>void SoAction::apply (const \fBSoPathList\fP &pathlist, SbBoolobeysrules = \fCFALSE\fP)\fC [virtual]\fP</h3>
<p>Applies action to the graphs defined by <em>pathlist</em>. If <em>obeysrules</em> is set to TRUE<em>, </em><em>pathlist</em><em> must obey the following four conditions (which is the case for path lists returned from search actions for non-group nodes and path lists returned from picking actions):</em></p><p>All paths must start at the same head node. All paths must be sorted in traversal order. The paths must be unique. No path can continue through the end point of another path.</p><p><strong>See also:</strong></p><p><strong>SoAction::apply(SoPath * path)</strong></p><p>Reimplemented in <strong>SoIntersectionDetectionAction</strong>, <strong>SoReorganizeAction</strong>, <strong>SoBoxHighlightRenderAction</strong>, <strong>SoLineHighlightRenderAction</strong>, <strong>SoSimplifyAction</strong>, <strong>SoToVRMLAction</strong>, and <strong>SoToVRML2Action</strong>.</p>
<h3>void SoAction::apply (\fBSoAction\fP *beingApplied)</h3>
<p>Applies this action object to the same as <em>beingApplied</em> is being applied to.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.1</p>
<h3>void SoAction::invalidateState (void)\fC [virtual]\fP</h3>
<p>Invalidates the state, forcing it to be recreated at the next <strong>apply()</strong> invocation.</p><p>Reimplemented in <strong>SoGLRenderAction</strong>.</p>
<h3>void SoAction::nullAction (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This method is used for filling up the lookup tables with void methods.</p>
<h3>\fBSoAction::AppliedCode\fP SoAction::getWhatAppliedTo (void) const</h3>
<p>Returns a code indicating what (node, path, or pathlist) the action instance is being applied to.</p>
<h3>\fBSoNode\fP * SoAction::getNodeAppliedTo (void) const</h3>
<p>Returns a pointer to the node the action is being applied to.</p><p>If action is not being applied to a node (but a path or a pathlist), the method returns NULL.</p>
<h3>\fBSoPath\fP * SoAction::getPathAppliedTo (void) const</h3>
<p>Returns the pointer to the path the action is being applied to. The path is managed by the action instance and should not be destroyed or modified by the caller.</p><p>If action is not being applied to a path (but a node or a pathlist), the method returns NULL.</p>
<h3>const \fBSoPathList\fP * SoAction::getPathListAppliedTo (void) const</h3>
<p>Returns the pointer to the path list the action is currently being applied to. The path list is managed by the action instance and should not be destroyed or modified by the caller.</p><p>If action is not being applied to a path list (but a node or a path), the method returns NULL.</p><p>The returned pathlist pointer need not be equal to the list <strong>apply()</strong> was called with, as the action may have reorganized the path list for efficiency reasons.</p><p><strong>See also:</strong></p><p>void <strong>SoAction::apply(const SoPathList &, SbBool)</strong></p>
<h3>const \fBSoPathList\fP * SoAction::getOriginalPathListAppliedTo (void) const</h3>
<p>Returns a pointer to the original path list the action is being applied to.</p><p>If the action is not being applied to a path list (but a node or a path), the method returns NULL.</p>
<h3>SbBool SoAction::isLastPathListAppliedTo (void) const</h3>
<p>This method is not supported in Coin. It should probably have been private in OIV.</p>
<h3>\fBSoAction::PathCode\fP SoAction::getPathCode (int &numindices, const int *&indices)</h3>
<p>Returns a code that indicates where the current node lies with respect to the path(s) the action is being applied to. The arguments <em>indices</em> and <em>numindices</em> are only set if the method returns IN_PATH<em>.</em></p>
<h3>void SoAction::traverse (\fBSoNode\fP *constnode)</h3>
<p>Traverses a scene graph rooted at <em>node</em>, invoking the action methods of the nodes in the graph.</p>
<h3>SbBool SoAction::hasTerminated (void) const</h3>
<p>Returns TRUE if the action was prematurely terminated.</p><p>Note that the termination flag will be FALSE if the action simply completed its run over the scene graph in the 'ordinary' fashion, i.e. was not explicitly aborted from any of the nodes in the graph.</p><p><strong>See also:</strong></p><p><strong>setTerminated()</strong></p>
<h3>const \fBSoPath\fP * SoAction::getCurPath (void)</h3>
<p>Returns a pointer to the path generated during traversal, from the root of the traversed graph to the current node.</p>
<h3>\fBSoState\fP * SoAction::getState (void) const</h3>
<p>Returns a pointer to the state of the action instance. The state contains the current set of elements used during traversal.</p>
<h3>\fBSoAction::PathCode\fP SoAction::getCurPathCode (void) const\fC [inline]\fP</h3>
<p>Returns the current traversal path code.</p>
<h3>\fBSoNode\fP * SoAction::getCurPathTail (void)\fC [virtual]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Reimplemented in <strong>SoCallbackAction</strong>.</p>
<h3>void SoAction::usePathCode (int &numindices, const int *&indices)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoAction::pushCurPath (const intchildindex, \fBSoNode\fP *node = \fCNULL\fP)</h3>
<p>Get ready to traverse the <em>childindex'th</em> child. Use this method if the path code might change as a result of this.</p><p>This method is very internal. Do not use unless you know what you're doing.</p>
<h3>void SoAction::popCurPath (const \fBPathCode\fPprevpathcode)</h3>
<p>Pops the current path, and sets the path code to <em>prevpathcode</em>.</p><p>This method is very internal. Do not use unless you know what you're doing.</p>
<h3>void SoAction::pushCurPath (void)</h3>
<p>Pushes a NULL node onto the current path. Use this before traversing all children when you know that the path code will not change while traversing children.</p><p>This method is very internal. Do not use unless you know what you're doing.</p>
<h3>void SoAction::popPushCurPath (const intchildindex, \fBSoNode\fP *node = \fCNULL\fP)</h3>
<p>Get ready to traverse the <em>childindex'th</em> child. Use this method if you know the path code will not change as a result of this.</p><p>This method is very internal. Do not use unless you know what you're doing.</p>
<h3>void SoAction::popCurPath (void)</h3>
<p>Pops of the last child in the current path. Use this if you know the path code hasn't changed since the current path was pushed.</p><p>This method is very internal. Do not use unless you know what you're doing.</p>
<h3>void SoAction::switchToPathTraversal (\fBSoPath\fP *path)</h3>
<p>Store our state, traverse the given <em>path</em>, restore our state and continue traversal.</p>
<h3>void SoAction::switchToNodeTraversal (\fBSoNode\fP *node)</h3>
<p>Store our state, traverse the subgraph rooted at the given <em>node</em>, restore our state and continue traversal.</p>
<h3>void SoAction::beginTraversal (\fBSoNode\fP *node)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This virtual method is called from <strong>SoAction::apply()</strong>, and is the entry point for the actual scenegraph traversal.</p><p>It can be overridden to initialize the action at traversal start, for specific initializations in the action subclasses inheriting <strong>SoAction</strong>.</p><p>Default method just calls <strong>traverse()</strong>, which any overridden implementation of the method must do too (or call <strong>SoAction::beginTraversal()</strong>) to trigger the scenegraph traversal.</p><p>Reimplemented in <strong>SoCallbackAction</strong>, <strong>SoGLRenderAction</strong>, <strong>SoRayPickAction</strong>, <strong>SoGetBoundingBoxAction</strong>, <strong>SoGetPrimitiveCountAction</strong>, <strong>SoSearchAction</strong>, <strong>SoToVRMLAction</strong>, <strong>SoReorganizeAction</strong>, <strong>SoHandleEventAction</strong>, <strong>SoToVRML2Action</strong>, <strong>SoGetMatrixAction</strong>, <strong>SoPickAction</strong>, <strong>SoWriteAction</strong>, <strong>SoAudioRenderAction</strong>, <strong>SoGlobalSimplifyAction</strong>, <strong>SoShapeSimplifyAction</strong>, and <strong>SoSimplifyAction</strong>.</p>
<h3>void SoAction::endTraversal (\fBSoNode\fP *node)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This virtual method can be overridden to execute code after the scene graph traversal. Default method does nothing.</p><p>Reimplemented in <strong>SoGLRenderAction</strong>.</p>
<h3>void SoAction::setTerminated (const SbBoolflag)\fC [protected]\fP</h3>
<p>Set the termination flag.</p><p>Typically set to TRUE from nodes upon special conditions being met during scene graph traversal -- like the correct node being found when doing <strong>SoSearchAction</strong> traversal or when grabbing the event from an <strong>SoHandleEventAction</strong>.</p><p><strong>See also:</strong></p><p><strong>hasTerminated()</strong></p>
<h3>const \fBSoEnabledElementsList\fP & SoAction::getEnabledElements (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a list of the elements used by action instances of this class upon traversal operations.</p><p>Reimplemented in <strong>SoCallbackAction</strong>, <strong>SoIntersectionDetectionAction</strong>, <strong>SoGLRenderAction</strong>, <strong>SoRayPickAction</strong>, <strong>SoGetMatrixAction</strong>, <strong>SoHandleEventAction</strong>, <strong>SoGetBoundingBoxAction</strong>, <strong>SoGlobalSimplifyAction</strong>, <strong>SoShapeSimplifyAction</strong>, <strong>SoGetPrimitiveCountAction</strong>, <strong>SoSearchAction</strong>, <strong>SoPickAction</strong>, <strong>SoAudioRenderAction</strong>, <strong>SoReorganizeAction</strong>, <strong>SoWriteAction</strong>, <strong>SoBoxHighlightRenderAction</strong>, <strong>SoLineHighlightRenderAction</strong>, <strong>SoSimplifyAction</strong>, <strong>SoToVRMLAction</strong>, and <strong>SoToVRML2Action</strong>.</p>
<h3>SbBool SoAction::shouldCompactPathList (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoEnabledElementsList\fP * SoAction::getClassEnabledElements (void)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>This method not available in the original OIV API, see <strong>SoSubAction.h</strong> for explanation.</p>
<h3>\fBSoActionMethodList\fP * SoAction::getClassActionMethods (void)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>This method not available in the original OIV API, see <strong>SoSubAction.h</strong> for explanation.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>SoAction::state\fC [protected]\fP</h3>
<p>Pointer to the traversal state instance of the action.</p>
<h3>SoAction::traversalMethods\fC [protected]\fP</h3>
<p>Stores the list of 'nodetype to actionmethod' mappings for the particular action instance.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoAccumulatedElement.3.html"><span aria-hidden="true">&larr;</span> SoAccumulatedElement.3: The soaccumulatedelement class is an abstract class for storing accumulated state.  this is the superclass of elements where new element data accumulates with older data.</a></li>
   <li class="next"><a href="SoActionMethodList.3.html">SoActionMethodList.3: The soactionmethodlist class contains function pointers for action methods.  an soactionmethodlist contains one function pointer per node type. each action contains an soactiomethodlist to know which functions to call during scene graph traversal. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

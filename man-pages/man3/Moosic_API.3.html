<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Moosic_API: How to write your own moosic client.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="How to write your own moosic client.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Moosic_API (3) manual">
  <meta name="twitter:description" content="How to write your own moosic client.">
  <meta name="twitter:image" content="https://www.carta.tech/images/moosic-Moosic_API-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/Moosic_API.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Moosic_API (3) manual" />
  <meta property="og:description" content="How to write your own moosic client." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/moosic-Moosic_API-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Moosic_API<small> (3)</small></h1>
        <p class="lead">How to write your own moosic client.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/Moosic_API.3.html">
      <span itemprop="name">Moosic_API: How to write your own moosic client.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/moosic/">
      <span itemprop="name">moosic</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/Moosic_API.3.html">
      <span itemprop="name">Moosic_API: How to write your own moosic client.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Introduction</h2>
        <div class="sectioncontent">
<p>\*(L"moosicd\*(R" is a program that implements the server portion of the Moosic jukebox system.  This server provides services for manipulating a queue of songs to be played, as well as for controlling the playing of these songs.  A Moosic client sends requests to the server, and receives data in response to these requests. The \*(L"moosic\*(R" command line utility is the canonical Moosic client, and provides a way to control a Moosic server from an interactive command shell or from a shell script.  However, you might not be satisfied by the interface that is provided by the \*(L"moosic\*(R" command, so I have written this document to describe how to communicate with a Moosic server in your own programs.</p><p>[This document was written by Daniel Pearson &lt;daniel@nanoo.org&gt;, and has been placed into the public domain.]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Section 0: Instructions for Impatient Developers</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Plan to write your program with Python and xmlrpclib. xmlrpclib is included with Python 2.2 or later, but if you need to use an earlier version of Python, xmlrpclib can be downloaded from &lt;http://www.pythonware.com/products/xmlrpc/&gt;.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>If you can't or don't want to write your program with Python and xmlrpclib, you won't benefit from this section and will have to read section 2 of this document.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Create a proxy which communicates with moosicd:</p>
<pre>
   &gt;&gt;&gt; import moosic.client.factory
   &gt;&gt;&gt; proxy = moosic.client.factory.LocalMoosicProxy()
</pre>

  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>Read section 3 for the documentation of all the methods supported by the proxy object.</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>Use the proxy to get information from the server and to send commands to it. For example:    &gt;&gt;&gt; proxy.list()    []    &gt;&gt;&gt; proxy.is_queue_running()    True    &gt;&gt;&gt; proxy.haltqueue()    True    &gt;&gt;&gt; proxy.is_queue_running()    False    &gt;&gt;&gt; proxy.append([xmlrpc.Binary(i) for i in    ...       [&apos;/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3&apos;,    ...        &apos;/home/daniel/music/Fiona_Apple/When_The_Pawn/04-Love_Ridden.ogg&apos;,    ...        "/home/daniel/music/Zelda/Great_Fairy&apos;s_Fountain.mid"]])    True    &gt;&gt;&gt; proxy.list()    [&lt;xmlrpclib.Binary instance at 0x843cf3c&gt;,     &lt;xmlrpclib.Binary instance at 0x8440e94&gt;,     &lt;xmlrpclib.Binary instance at 0x8440ebc&gt;]    &gt;&gt;&gt; [i.data for i in proxy.list()]    [&apos;/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3&apos;,     &apos;/home/daniel/music/Fiona_Apple/When_The_Pawn/04-Love_Ridden.ogg&apos;,     "/home/daniel/music/Zelda/Great_Fairy&apos;s_Fountain.mid"]    &gt;&gt;&gt; proxy.sort()    True    &gt;&gt;&gt; [i.data for i in proxy.list()]    [&apos;/home/daniel/music/Fiona_Apple/When_The_Pawn/04-Love_Ridden.ogg&apos;,     &apos;/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3&apos;,     "/home/daniel/music/Zelda/Great_Fairy&apos;s_Fountain.mid"]</p>
  </dd>
  <dt>
    6.
  </dt>
  <dd>
    <p>If you wish to communicate with a moosicd that is listening for requests on an \s-1IP\s0 socket instead of a Unix domain socket, you should use InetMoosicProxy instead of LocalMoosicProxy.  Here's an example:    &gt;&gt;&gt; import moosic.client.factory    &gt;&gt;&gt; proxy = moosic.client.factory.InetMoosicProxy(&apos;example.com&apos;, 8080)</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Section 1: The Moosic Server's Data Model</h2>
        <div class="sectioncontent">
<p>This section describes, in precise terms, the data objects that can be accessed and manipulated by sending requests to the Moosic server.</p>
<dl class='dl-vertical'>
  <dt>
    song queue
  </dt>
  <dd>
    <p>This is the foremost data object maintained by the Moosic server. It is an ordered sequence of strings that represents the queue of songs that are waiting to be played.  Each item in this list identifies a song that will be played by the Moosic server.  Usually, these items are the names of files on disk that contain each song, but this does not have to be the case.  For instance, an \s-1HTTP\s0 \s-1URL\s0 might be used to name a song if a program that can play songs from the Web is appropriately registered with the Moosic server (see \*(L"player configuration\*(R" later in this section).</p>
  </dd>
  <dt>
    current song
  </dt>
  <dd>
    <p>This is a string that identifies the song that is currently being played by the Moosic server.  If nothing is currently playing, then this will be the empty string.</p>
  </dd>
  <dt>
    queue running flag
  </dt>
  <dd>
    <p>This is a boolean value that indicates whether the Moosic server will start playing a new song as soon as the current song has finished and the song queue is not empty.</p>
  </dd>
  <dt>
    pause flag
  </dt>
  <dd>
    <p>This is a boolean value that indicates whether the current song is paused or not.</p>
  </dd>
  <dt>
    loop mode flag
  </dt>
  <dd>
    <p>This is a boolean value that sets \*(L"loop mode\*(R".  When loop mode is on, songs are returned to the end of the song queue when they finish playing instead of being discarded.</p>
  </dd>
  <dt>
    history
  </dt>
  <dd>
    <p>This is a list of songs that the Moosic server has finished playing.  Note that songs named in this list may have finished playing early at the request of a user (i.e. through use of the \*(L"next\*(R" command).  Each entry in this list is actually a 3-tuple of (song, start time, finish time).</p>
  </dd>
  <dt>
    maximum history size
  </dt>
  <dd>
    <p>This is the maximum number of songs that will be stored in the history list. Old entries are removed from the history to make room for newer entries when this limit is reached.</p>
  </dd>
  <dt>
    player configuration
  </dt>
  <dd>
    <p>This is an ordered mapping that associates regular expressions (text patterns) to programs.  For each regular expression, the associated program is expected to be able to play any queue items that match that regular expression.  Each program is a list in which the name of the executable file that contains the program is the first element and the program's arguments are the rest of the elements.</p>
  </dd>
  <dt>
    last queue update
  </dt>
  <dd>
    <p>This is the time at which the song queue was last modified.  It a floating-point number that represents time as the number of seconds since the epoch.</p>
  </dd>
  <dt>
    server version
  </dt>
  <dd>
    <p>This is a string that describes the version of the program that implements the Moosic server.  It has no specific, well-defined semantics.</p>
  </dd>
  <dt>
    \s-1API\s0 version
  </dt>
  <dd>
    <p>This is a pair of integers, one representing the \*(L"major\*(R" version, and the other representing the \*(L"minor\*(R" version.  These numbers are meant to provide some useful compatibility information to Moosic clients.  As this \s-1API\s0 changes, these numbers will change in the following ways.  If the \s-1API\s0 has been changed in a backward-compatible way (e.g. a new method was added or an existing method was overloaded), then the minor version will increase and the major version will remain unchanged.  However, if the \s-1API\s0 has been changed in such a way that existing code that uses the \s-1API\s0 might break (e.g.  a method was removed or its return value or parameter types were changed), then the major version will increase and the minor version may be reset to any value (although it will usually be reset zero).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Section 2: The Low-Level Details of Client-Server Communication</h2>
        <div class="sectioncontent">
<p>The information in this section is generally only necessary to people who wish to write a Moosic client in a programming language other than Python.  If you are using Python to write a Moosic client, then you can use the classes LocalMoosicProxy and InetMoosicProxy from the moosic_factory.py module, and blissfully ignore most of these gory details.  However, Python programmers can also benefit from reading this section, as it will deepen their understanding of Moosic's inter-process communication model.</p><p>The first thing to know about writing your own Moosic client is that communication between the client and server is done through a BSD-style socket. Read the \*(L"socket\*(R" manual page (and related manual pages) on a Unix system if you are unfamiliar with \s-1BSD\s0 sockets.  The socket used by Moosic belongs to the Unix-domain protocol family (\s-1PF_UNIX\s0 or \s-1PF_LOCAL\s0) and has a type of \s-1SOCK_STREAM\s0. This means that a Moosic client can only communicate with a Moosic server that is running on the same computer as the client.  This limitation is a very purposeful part of Moosic's design.  It has the advantage of vastly reducing the consequences of any security flaws that Moosic might have.</p><p>If you really, really think that you need the client and the server to run on separate hosts, then you can run moosicd with the -t option, which tells it to listen on a \s-1TCP/IP\s0 socket instead of a Unix domain socket.  I recommend firewalling such a port very carefully.</p><p>Regardless of which kind of socket is used by the server, XML-RPC is used as the data protocol for requests and responses.  For an introduction to XML-RPC, see the XML-RPC homepage &lt;http://www.xmlrpc.com/&gt; and the XML-RPC \s-1HOWTO\s0 http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto.html &lt;http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto.html&gt;.  Python users should note that if the XML-RPC \s-1HOWTO\s0 tells you that you need to install a third-party library to use XML-RPC, it is assuming that you are using a Python version earlier than 2.2.  Since version 2.2, Python has included the xmlrpclib module in its standard library.</p><p>In summary, all you need to do to talk to a Moosic server in your own program is to send XML-RPC requests to the appropriate address.  By default, the appropriate address for contacting moosicd is the file named \*(L"socket\*(R" in a directory named \*(L".moosic\*(R" in the home directory of the user that started moosicd (i.e. \*(L"~/.moosic/socket\*(R").  If moosicd is started with the -c option, then the directory that contains \*(L"socket\*(R" will be the argument provided to the -c option instead of ~/.moosic.  If moosicd is started with the -t option, then clients will have to address it by using a (host, port) pair instead of a filename.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Section 3: Valid Moosic Server Methods</h2>
        <div class="sectioncontent">
<p>moosicd's XML-RPC server implements the introspection \s-1API\s0 mentioned on http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto-api-introspection.html &lt;http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto-api-introspection.html&gt;, so the \s-1API\s0 presented by moosicd is essentially self-documenting.  Thus, the information in this section has been automatically generated by querying a running Moosic server.</p><p>The Moosic \s-1API\s0 contains the following methods:</p>
<dl class='dl-vertical'>
  <dt>
    array <strong>api_version</strong> ()
  </dt>
  <dd>
    <p>   Returns the version number for the API that the server implements.</p><p>       Arguments: None.        Return value: The version number, which is a 2-element array of            integers.  The first element is the major version, and the second            element is the minor version.</p>
  </dd>
  <dt>
    boolean <strong>append</strong> (array)
  </dt>
  <dd>
    <p>   Adds items to the end of the queue.</p><p>       Argument: An array of (base64-encoded) strings, representing the items to be            added.          * When adding local filenames to the queue, only absolute pathnames should            be used.  Using relative pathnames would be foolish because the server            has no idea what the client&apos;s current working directory is.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>clear</strong> ()
  </dt>
  <dd>
    <p>   Removes all items from the queue.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>crop</strong> (array)
  </dt>
  <dd>
    <p>   Remove all queued items that do not fall within the given range.</p><p>       Arguments: An array of integers that represents a range.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>crop_list</strong> (array)
  </dt>
  <dd>
    <p>   Removes all items except for those referenced by a list of positions.</p><p>       Arguments: An array of integers that represents a list of the positions of            the items to be kept.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    base64 <strong>current</strong> ()
  </dt>
  <dd>
    <p>   Returns the name of the currently playing song.</p><p>       Arguments: None.        Return value: The name of the currently playing song.</p>
  </dd>
  <dt>
    double <strong>current_time</strong> ()
  </dt>
  <dd>
    <p>   Returns the amount of time that the current song has been playing.</p><p>       Arguments: None.        Return value: The number of seconds that the current song has been playing.</p>
  </dd>
  <dt>
    boolean <strong>cut</strong> (array)
  </dt>
  <dd>
    <p>   Remove all queued items that fall within the given range.</p><p>       Arguments: An array of integers that represents a range.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>cut_list</strong> (array)
  </dt>
  <dd>
    <p>   Removes the items referenced by a list of positions within the queue.</p><p>       Arguments: An array of integers that represents a list of the positions of            the items to be removed.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>die</strong> ()
  </dt>
  <dd>
    <p>   Tells the server to terminate itself.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>filter</strong> (base64)
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>filter</strong> (base64, array)
  </dt>
  <dd>
    <p>   Removes all items that don&apos;t match the given regular expression.</p><p>       Arguments: A regular expression that specifies which items to keep.          * Optionally, an array of integers may be given as a second argument.            This argument represents a range to which the filtering will be            limited.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    int <strong>get_history_limit</strong> ()
  </dt>
  <dd>
    <p>   Gets the limit on the size of the history list stored in memory.</p><p>       Arguments: None.        Return value: The maximum number of history entries that the server will            remember.</p>
  </dd>
  <dt>
    array <strong>getconfig</strong> ()
  </dt>
  <dd>
    <p>   Returns a list of the server&apos;s filetype-player associations.</p><p>       Arguments: None.        Return value: An array of pairs. The first element of each pair is a            (base64-encoded) string that represents a regular expression pattern,            and the second element is a (base64-encoded) string that represents the            system command that should be used to handle songs that match the            corresponding pattern.</p>
  </dd>
  <dt>
    boolean <strong>halt_queue</strong> ()
  </dt>
  <dd>
    <p>   Stops any new songs from being played. Use run_queue() to reverse this        state.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>haltqueue</strong> ()
  </dt>
  <dd>
    <p>   Stops any new songs from being played. Use run_queue() to reverse this        state.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    array <strong>history</strong> ()
  </dt>
  <dd>
    
  </dd>
  <dt>
    array <strong>history</strong> (int)
  </dt>
  <dd>
    <p>   Returns a list of the items that were recently played.</p><p>       Arguments: If a positive integer argument is given, then no more than that            number of entries will be returned.  If a number is not specified, or if            zero is given, then the entire history is returned.  The result is            undefined if a negative integer argument is given (but does not raise an            exception).        Return value: An array of triples, each representing a song that was played            along with the times that it started and finished playing.          * The first member of the pair is a (base64-encoded) string which            represents the song that was previously played.          * The second member of the pair is a floating point number which            represents the time that the song started playing in seconds since the            epoch.          * The third member of the pair is a floating point number which            represents the time that the song finished playing in seconds since the            epoch.</p>
  </dd>
  <dt>
    struct <strong>indexed_list</strong> ()
  </dt>
  <dd>
    
  </dd>
  <dt>
    struct <strong>indexed_list</strong> (array)
  </dt>
  <dd>
    <p>   Lists the song queue&apos;s contents. If a range is specified, only the        items that fall within that range are listed.</p><p>       This differs from list() only in its return value, and is useful when you        want to know the starting position of your selected range within the song        queue (which can be different than the starting index of the specified range        if, for example, the starting index is a negative integer).</p><p>       Arguments: Either none, or an array of integers that represents a range.          * If no range is given, the whole list is returned.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: A struct with two elements. This first is "list", an array of            (base64-encoded) strings, representing the selected range from the song            queue&apos;s contents. The second is "start", an integer index value that            represents the position of the first item of the returned list in the            song queue.</p>
  </dd>
  <dt>
    boolean <strong>insert</strong> (array, int)
  </dt>
  <dd>
    <p>   Inserts items at a given position in the queue.</p><p>       Arguments: The first argument is an array of (base64-encoded) strings,            representing the items to be added.          * The second argument specifies the position in the queue where the items            will be inserted.          * When adding local filenames to the queue, only absolute pathnames should            be used.  Using relative pathnames would be foolish because the server            has no idea what the client&apos;s current working directory is.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>is_looping</strong> ()
  </dt>
  <dd>
    <p>   Tells you whether loop mode is on or not.</p><p>       If loop mode is on, songs are returned to the end of the song queue after        they finish playing.  If loop mode is off, songs that have finished playing        are not returned to the queue.</p><p>       Arguments: None.        Return value: True if loop mode is set, False if it is not.</p>
  </dd>
  <dt>
    boolean <strong>is_paused</strong> ()
  </dt>
  <dd>
    <p>   Tells you whether the current song is paused or not.</p><p>       Arguments: None.        Return value: True if the current song is paused, otherwise False.</p>
  </dd>
  <dt>
    boolean <strong>is_queue_running</strong> ()
  </dt>
  <dd>
    <p>   Tells you whether the queue consumption (advancement) is activated.</p><p>       Arguments: None.        Return value: True if new songs are going to be played from the queue after            the current song is finished, otherwise False.</p>
  </dd>
  <dt>
    double <strong>last_queue_update</strong> ()
  </dt>
  <dd>
    <p>   Returns the time at which the song queue was last modified.</p><p>       This method is intended for use by GUI clients that don&apos;t want to waste time        downloading the entire contents of the song queue if it hasn&apos;t changed.</p><p>       Arguments: None.        Return value: A floating-point number that represents time as the number of            seconds since the epoch.</p>
  </dd>
  <dt>
    int <strong>length</strong> ()
  </dt>
  <dd>
    <p>   Returns the number of items in the song queue.</p><p>       Arguments: None.        Return value: The number of items in the song queue.</p>
  </dd>
  <dt>
    array <strong>list</strong> ()
  </dt>
  <dd>
    
  </dd>
  <dt>
    array <strong>list</strong> (array)
  </dt>
  <dd>
    <p>   Lists the song queue&apos;s contents. If a range is specified, only the        items that fall within that range are listed.</p><p>       Arguments: Either none, or an array of integers that represents a range.          * If no range is given, the whole list is returned.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: An array of (base64-encoded) strings, representing the            selected range from the song queue&apos;s contents.</p>
  </dd>
  <dt>
    boolean <strong>move</strong> (array, int)
  </dt>
  <dd>
    <p>   Moves a range of items to a new position within the queue.</p><p>       Arguments: The first argument is an array of integers that represents a            range of items to be moved.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.          * The second argument, "destination", specifies the position in the queue            where the items will be moved.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>move_list</strong> (array, int)
  </dt>
  <dd>
    <p>   Moves the items referenced by a list of positions to a new position.</p><p>       Arguments: The first argument is an array of integers that represents a            list of the positions of the items to be moved.          * The second argument, "destination", specifies the position in the queue            where the items will be moved.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>next</strong> ()
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>next</strong> (int)
  </dt>
  <dd>
    <p>   Stops the current song (if any), and jumps ahead to a song that is        currently in the queue. The skipped songs are recorded in the history as if        they had been played. When called without arguments, this behaves very        much like the skip() method, except that it will have an effect even if        nothing is currently playing.</p><p>       Arguments: A single integer that tells how far forward into the song queue            to advance. A value of 1 will cause the first song in the queue to play,            2 will cause the second song in the queue to play, and so on. If no            argument is given, a value of 1 is assumed.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>no_op</strong> ()
  </dt>
  <dd>
    <p>   Does nothing, successfully.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>pause</strong> ()
  </dt>
  <dd>
    <p>   Pauses the currently playing song.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>prepend</strong> (array)
  </dt>
  <dd>
    <p>   Adds items to the beginning of the queue.</p><p>       Argument: An array of (base64-encoded) strings, representing the items to be            added.          * When adding local filenames to the queue, only absolute pathnames should            be used.  Using relative pathnames would be foolish because the server            has no idea what the client&apos;s current working directory is.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>previous</strong> ()
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>previous</strong> (int)
  </dt>
  <dd>
    <p>   Stops the current song (if any), removes the most recently played song        from the history, and puts these songs at the head of the queue. When loop        mode is on, the songs at the tail of the song queue are used instead of the        most recently played songs in the history.</p><p>       Arguments: A single integer that tells how far back in the history list to            retreat. A value of 1 will cause the most recent song to play, 2 will            cause the second most recent song to play, and so on. If no argument is            given, a value of 1 is assumed.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>putback</strong> ()
  </dt>
  <dd>
    <p>   Places the currently playing song at the beginning of the queue.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    int <strong>queue_length</strong> ()
  </dt>
  <dd>
    <p>   Returns the number of items in the song queue.</p><p>       Arguments: None.        Return value: The number of items in the song queue.</p>
  </dd>
  <dt>
    boolean <strong>reconfigure</strong> ()
  </dt>
  <dd>
    <p>   Tells the server to reread its player configuration file.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>remove</strong> (base64)
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>remove</strong> (base64, array)
  </dt>
  <dd>
    <p>   Removes all items that match the given regular expression.</p><p>       Arguments: A regular expression that specifies which items to remove.          * Optionally, an array of integers may be given as a second argument.            This argument represents a range to which the removal will be limited.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>replace</strong> (array)
  </dt>
  <dd>
    <p>   Replaces the contents of the queue with the given items.</p><p>       This is equivalent to calling clear() and prepend() in succession, except that this        operation is atomic.</p><p>       Argument: An array of (base64-encoded) strings, representing the items to be            added.          * When adding local filenames to the queue, only absolute pathnames            should be used.  Using relative pathnames would be foolish because            the server isn&apos;t aware of the client&apos;s current working directory.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>reverse</strong> ()
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>reverse</strong> (array)
  </dt>
  <dd>
    <p>   Reverses the order of the items in the queue.</p><p>       Arguments: Either none, or an array of integers that represents a range.          * If no range is given, the whole list is affected.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>run_queue</strong> ()
  </dt>
  <dd>
    <p>   Allows new songs to be played again after halt_queue() has been called.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>runqueue</strong> ()
  </dt>
  <dd>
    <p>   Allows new songs to be played again after halt_queue() has been called.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>set_history_limit</strong> (int)
  </dt>
  <dd>
    <p>   Sets the limit on the size of the history list stored in memory.</p><p>       This will irrevocably discard history entries if the new limit is lower than        the current size of the history list.</p><p>       Arguments: The new maximum number of history entries. If this value is            negative, the history limit will be set to zero.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>set_loop_mode</strong> (boolean)
  </dt>
  <dd>
    <p>   Turns loop mode on or off.</p><p>       If loop mode is on, songs are returned to the end of the song queue after        they finish playing.  If loop mode is off, songs that have finished playing        are not returned to the queue.</p><p>       Arguments: True if you want to turn loop mode on, False if you want to turn            it off.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    base64 <strong>showconfig</strong> ()
  </dt>
  <dd>
    <p>   Returns a textual description of the server&apos;s player configuration.</p><p>       Arguments: None.        Return value: A (base64-encoded) string that shows which programs will be            used to play the various file-types recognized by the Moosic server.</p>
  </dd>
  <dt>
    boolean <strong>shuffle</strong> ()
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>shuffle</strong> (array)
  </dt>
  <dd>
    <p>   Rearrange the contents of the queue into a random order.</p><p>       Arguments: Either none, or an array of integers that represents a range.          * If no range is given, the whole list is affected.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>skip</strong> ()
  </dt>
  <dd>
    <p>   Skips the rest of the current song to play the next song in the queue.        This only has an effect if there actually is a current song.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>sort</strong> ()
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>sort</strong> (array)
  </dt>
  <dd>
    <p>   Arranges the contents of the queue into sorted order.</p><p>       Arguments: Either none, or an array of integers that represents a range.          * If no range is given, the whole list is affected.          * If the range contains a single integer, it will represent all members            of the queue whose index is greater than or equal to the value of the            integer.          * If the range contains two integers, it will represent all members of            the queue whose index is greater than or equal to the value of the            first integer and less than the value of the second integer.          * If the range contains more than two integers, an error will occur.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>stop</strong> ()
  </dt>
  <dd>
    <p>   Stops playing the current song and stops new songs from playing. The        current song is returned to the head of the song queue and is not recorded        in the history list. If loop mode is on, the current song won&apos;t be placed at        the end of the song queue when it is stopped.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>sub</strong> (base64, base64)
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>sub</strong> (base64, base64, array)
  </dt>
  <dd>
    <p>   Performs a regular expression substitution on the items in the queue.</p><p>       Arguments: The first is a (base64-encoded) regular expression that specifies            the text to be replaced.          * The second argument is the (base64-encoded) string that will be used to            replace the first occurrence of the regular expression within each queue            item. Any backslash escapes in this string will be processed, including            special character translation (e.g. "&#92;n" to newline) and backreferences            to groups within the match.          * Optionally, an array of integers may be given as a third argument.            This argument represents a range to which the substitution will be            limited. This range is interpreted in the same way as the range argument            in other Moosic methods.          * If performing a replacement changes an item in the queue into the empty            string, then it is removed from the queue.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>sub_all</strong> (base64, base64)
  </dt>
  <dd>
    
  </dd>
  <dt>
    boolean <strong>sub_all</strong> (base64, base64, array)
  </dt>
  <dd>
    <p>   Performs a global regular expression substitution on the items in the queue.</p><p>       Arguments: The first is a (base64-encoded) regular expression that specifies            the text to be replaced.          * The second argument is the (base64-encoded) string that will be used to            replace all occurrences of the regular expression within each queue            item. Any backslash escapes in this string will be processed, including            special character translation (e.g. "&#92;n" to newline) and backreferences            to the substrings matched by individual groups in the pattern.          * Optionally, an array of integers may be given as a third argument.            This argument represents a range to which the substitution will be            limited. This range is interpreted in the same way as the range argument            in other Moosic methods.          * If performing a replacement changes an item in the queue into the empty            string, then it is removed from the queue.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>swap</strong> (array, array)
  </dt>
  <dd>
    <p>   Swaps the items contained in one range with the items contained in the        other range.</p><p>       Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    array <strong>system.listMethods</strong> ()
  </dt>
  <dd>
    <p>   Return an array of all available XML-RPC methods on this server.</p>
  </dd>
  <dt>
    string <strong>system.methodHelp</strong> (string)
  </dt>
  <dd>
    <p>   Given the name of a method, return a help string.</p>
  </dd>
  <dt>
    array <strong>system.methodSignature</strong> (string)
  </dt>
  <dd>
    <p>   Given the name of a method, return an array of legal signatures. Each            signature is an array of strings. The first item of each signature is            the return type, and any others items are parameter types.</p>
  </dd>
  <dt>
    array <strong>system.multicall</strong> (array)
  </dt>
  <dd>
    <p>   Process an array of calls, and return an array of results. Calls            should be structs of the form {&apos;methodName&apos;: string, &apos;params&apos;: array}.            Each result will either be a single-item array containg the result            value, or a struct of the form {&apos;faultCode&apos;: int, &apos;faultString&apos;:            string}. This is useful when you need to make lots of small calls            without lots of round trips.</p>
  </dd>
  <dt>
    boolean <strong>toggle_loop_mode</strong> ()
  </dt>
  <dd>
    <p>   Turns loop mode on if it is off, and turns it off if it is on.</p><p>       If loop mode is on, songs are returned to the end of the song queue after        they finish playing.  If loop mode is off, songs that have finished playing        are not returned to the queue.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>toggle_pause</strong> ()
  </dt>
  <dd>
    <p>   Pauses the current song if it is playing, and unpauses if it is paused.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    boolean <strong>unpause</strong> ()
  </dt>
  <dd>
    <p>   Unpauses the current song.</p><p>       Arguments: None.        Return value: Nothing meaningful.</p>
  </dd>
  <dt>
    string <strong>version</strong> ()
  </dt>
  <dd>
    <p>   Returns the Moosic server&apos;s version string.</p><p>       Arguments: None.        Return value: The version string for the Moosic server.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Section 4: Writing a Moosic Client in Python</h2>
        <div class="sectioncontent">
<p>As demonstrated in section 0, communicating with a Moosic server is very easy to do with Python.  In this section, I'll merely elaborate on the details that were omitted from section 0 for the sake of brevity.</p><p>First of all, you should know that <em>LocalMoosicProxy()</em> can be called with a filename argument to specify the location of the Moosic server's socket file. This is useful if moosicd was started with the \*(L"-c\*(R" option.  Refer to the moosic_factory.py module's documentation (moosic_factory.html).</p><p>Next, note that many of the Moosic server's methods accept or return special types of objects from the xmlrpclib module, namely Boolean and Binary.  These object types serve the purpose of bridging the small mismatch between the data-types supported by XML-RPC and Python's intrinsic data-types.  Boolean objects present no unusual problem, since they evaluate to a correct truth value without any extra effort.  However, you must take care when using the Moosic methods that accept or return Binary objects.  Read the documentation for the xmlrpclib module for details on how to work with these objects.  The basic technique boils down to wrapping up a string inside a Binary object before sending it to the server, and using the \*(L"data\*(R" attribute to access the string data within the Binary objects returned by the server.  Regular strings can't be used because XML-RPC's normal string data-type can't handle multiple 8-bit strings within a single request if the strings use different encodings.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Section 5: Writing a Moosic Client in Another Language</h2>
        <div class="sectioncontent">
<p>If you are not using Python to write your Moosic client, the first issue to deal with is deciding upon an XML-RPC implementation.  For most popular programming languages, there are multiple XML-RPC implementations available.  Most of the possibilities are listed at &lt;http://www.xmlrpc.com/directory/1568/implementations&gt;.  Since XML-RPC is an open specification, you can create your own implementation if you don't like any of the ones that already exist.</p><p>Once you've got an XML-RPC library that you like, the big hurdle to overcome is to make that library send its \s-1RPC\s0 calls over a Unix socket instead of an \s-1IP\s0 socket.  I was able to do this pretty easily with Python's xmlrpclib since it is designed to allow pluggable transport methods:  all I had to do was subclass my own Transport type and plug it back into the original library's classes.  (If your language and/or library of choice makes this task difficult, then you may begin to understand why some Python programmers are so smug.)</p><p>After you are capable of sending XML-RPC requests through a Unix socket, you can go ahead and start sending requests to a Moosic server.  Refer to the end of section 2 for information on how to address a Moosic server.  Refer to section 3 for a list of valid server requests.</p><p>If you can't be bothered to find or hack together an XML-RPC library that works with Unix sockets, then you can still talk to a Moosic server that is listening on an \s-1IP\s0 socket, but this is less than ideal since listening on an \s-1IP\s0 socket is not default behavior for most Moosic servers.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Section 6: API Version History (ChangeLog)</h2>
        <div class="sectioncontent">
<ul>
<li><p>1.8 First implemented in moosicd 1.5.1. The following methods were added:     swap</p></li><li><p>1.7 First implemented by moosicd 1.5.0. The following methods were added:     skip, current_time The following methods had their behavior significantly changed:     previous, next Specifically, the <em>previous()</em> method no longer activates queue advancement if it had been disabled before.  This means that calling <em>previous()</em> no longer necessarily causes a song to start playing.  The <em>next()</em> method was changed to more closely parallel the behavior of <em>previous()</em>: it takes a single optional integer argument to allow immediate advancement by more than one song at a time, and it has an effect even when no song is currently playing.  The new <em>skip()</em> method implements the exact same behavior that was previously exhibited by <em>next()</em>. Last, and most importantly, the name of the default socket file for communicating with the server via unix sockets was changed from $CONFIG_DIR/socket-$HOSTNAME to $CONFIG_DIR/socket.  If you are a Python programmer and you use the updated moosic_factory.py file from Moosic version 1.5.0, then you don't have to make any changes.  Otherwise, you must change your client's code to connect to the file named \*(L"socket\*(R" instead of the file named \*(L"socket-something.example.com\*(R".  If your client only talks to the Moosic server through \s-1TCP/IP\s0, then you don't have to make any changes, of course.</p></li><li><p>1.6 First implemented by moosicd 1.4.10. The following methods were added:     getconfig</p></li><li><p>1.5 First implemented by moosicd 1.4.6. The following methods were added:     sub, sub_all, stop</p></li><li><p>1.4 First implemented by moosicd 1.4.5. The following methods were added:     previous</p></li><li><p>1.3 First implemented by moosicd 1.4.4. The following methods were added:     replace, replace_range, last_queue_update</p></li><li><p>1.2 First implemented by moosicd 1.4.2. The following methods were added:     cut_list, crop_list</p></li><li><p>1.1 First implemented by moosicd 1.4.1. The following methods were added:     is_looping, set_loop_mode, toggle_loop_mode</p></li><li><p>1.0 First implemented by moosicd 1.4.0. The following methods were included:     api_version, append, clear, crop, current, cut, die, filter,     get_history_limit, halt_queue, haltqueue, history, indexed_list, insert,     is_paused, is_queue_running, length, list, move, move_list, next, no_op,     pause, prepend, putback, queue_length, reconfigure, remove, reverse,     run_queue, runqueue, set_history_limit, showconfig, shuffle, sort,     system.listMethods, system.methodHelp, system.methodSignature,     system.multicall, toggle_pause, unpause, version</p></li>
</ul>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="MinMaxOctree.3.html"><span aria-hidden="true">&larr;</span> MinMaxOctree.3: Create/destroy a min-max octree for optimized rendering</a></li>
   <li class="next"><a href="MrmCloseHierarchy.3.html">MrmCloseHierarchy.3: Mrmclosehierarchy  closes a uid hierarchy "mrmclosehierarchy" "uil functions" "mrmclosehierarchy" "uid hierarchy" <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

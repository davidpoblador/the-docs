<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SQL::Statement::Syntax: Documentation of sql::statement's sql syntax</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Documentation of sql::statement's sql syntax">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SQL::Statement::Syntax (3pm) manual">
  <meta name="twitter:description" content="Documentation of sql::statement's sql syntax">
  <meta name="twitter:image" content="https://www.carta.tech/images/libsql-statement-perl-SQL::Statement::Syntax-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/SQL::Statement::Syntax.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SQL::Statement::Syntax (3pm) manual" />
  <meta property="og:description" content="Documentation of sql::statement's sql syntax" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libsql-statement-perl-SQL::Statement::Syntax-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SQL::Statement::Syntax<small> (3pm)</small></h1>
        <p class="lead">Documentation of sql::statement's sql syntax</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/SQL::Statement::Syntax.3pm.html">
      <span itemprop="name">SQL::Statement::Syntax: Documentation of sql::statement's sql syntax</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libsql-statement-perl/">
      <span itemprop="name">libsql-statement-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/SQL::Statement::Syntax.3pm.html">
      <span itemprop="name">SQL::Statement::Syntax: Documentation of sql::statement's sql syntax</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>See SQL::Statement for usage.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The SQL::Statement module can be used either from a \s-1DBI\s0 driver like \s-1DBD::CSV\s0 or directly.  The syntax below applies to both situations.  In the case of DBDs, each \s-1DBD\s0 can implement its own sub-dialect so be sure to check the \s-1DBD\s0 documentation also.</p><p>SQL::Statement is meant primarly as a base class for \s-1DBD\s0 drivers and as such concentrates on a small but useful subset of \s-1SQL\s0. It does *not* in any way pretend to be a complete \s-1SQL\s0 parser for all dialects of \s-1SQL\s0.  The module will continue to add new supported syntax, and users may also extend the syntax (see \*(L"#Extending the \s-1SQL\s0 syntax\*(R").</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<h3>Default Supported \s-1SQL\s0 syntax - Summary</h3>
<p><strong>\s-1SQL\s0 Statements</strong></p>
<pre>
   CALL &lt;function&gt;
   CREATE [TEMP] TABLE &lt;table&gt; &lt;column_def_clause&gt;
   CREATE [TEMP] TABLE &lt;table&gt; AS &lt;select statement&gt;
   CREATE [TEMP] TABLE &lt;table&gt; AS IMPORT()
   CREATE FUNCTION &lt;user_defined_function&gt; [ NAME &lt;perl_subroutine&gt; ]
   CREATE KEYWORD  &lt;user_defined_keyword&gt;  [ NAME &lt;perl_subroutine&gt; ]
   CREATE OPERATOR &lt;user_defined_operator&gt; [ NAME &lt;perl_subroutine&gt; ]
   CREATE TYPE     &lt;user_defined_type&gt;     [ NAME &lt;perl_subroutine&gt; ]
   DELETE FROM &lt;table&gt; [&lt;where_clause&gt;]
   DROP TABLE [IF EXISTS] &lt;table&gt;
   DROP FUNCTION &lt;function&gt;
   DROP KEYWORD  &lt;keyword&gt;
   DROP OPERATOR &lt;operator&gt;
   DROP TYPE     &lt;type&gt;
   INSERT [INTO] &lt;table&gt; [&lt;column_list&gt;] VALUES &lt;value_list&gt;
   LOAD &lt;user_defined_functions_module&gt;
   SELECT &lt;function&gt;
   SELECT &lt;select_clause&gt;
          &lt;from_clause&gt;
          [&lt;where_clause&gt;]
          [ ORDER BY ocol1 [ASC|DESC], ... ocolN [ASC|DESC]] ]
          [ GROUP BY gcol1 [, ... gcolN] ]
          [ LIMIT [start,] length ]
   UPDATE &lt;table&gt; SET &lt;set_clause&gt; [&lt;where_clause&gt;]
</pre>
<p><strong>Explicit Join Qualifiers</strong></p><p>   NATURAL, INNER, OUTER, LEFT, RIGHT, FULL</p><p><strong>Built-in Functions</strong></p><p>   * Aggregate : MIN, MAX, AVG, SUM, COUNT    * Date/Time : CURRENT_DATE, CURDATE, CURRENT_TIME, CURTIME, CURRENT_TIMESTAMP, NOW,                  UNIX_TIMESTAMP    * String    : ASCII, CHAR, BIT_LENGTH, CHARACTER_LENGTH, CHAR_LENGTH, COALESCE,                  NVL, IFNULL, CONV, CONCAT, DECODE, HEX, OCT, BIN, INSERT, LEFT, RIGHT,                  LOCATE, POSITION, LOWER, UPPER, LCASE, UCASE, LTRIM, RTRIM, OCTET_LENGTH,                  REGEX, REPEAT, REPLACE, SOUNDEX, SPACE, SUBSTITUTE, SUBSTRING, SUBSTR,                  TRANSLATE, TRIM, UNHEX    * Numeric   : ABS, CEILING, CEIL, FLOOR, ROUND, EXP, LOG, LN, LOG10, MOD, POWER,                  RAND, SIGN, SQRT, TRUNCATE, TRUNC    * Trig      : ACOS, ACOSEC, ACOSECH, ACOSH, ACOT, ACOTAN, ACOTANH, ACOTH, ACSC,                  ACSCH, ASEC, ASECH, ASIN, ASINH, ATAN, ATAN2, ATANH, COS, COSEC,                  COSECH, COSH, COT, COTAN, COTANH, COTH, CSC, CSCH, DEG2DEG, DEG2GRAD,                  DEG2RAD, DEGREES, GRAD2DEG, GRAD2GRAD, GRAD2RAD, PI, RAD2DEG, RAD2GRAD,                  RAD2RAD, RADIANS, SEC, SECH, SIN, SINH, TAN, TANH    * System    : DBNAME, USERNAME, USER</p><p><strong>Special Utility Functions</strong></p><p>  * IMPORT  - imports a table from an external RDBMS or perl structure   * RUN     - prepares and executes statements in a file of SQL statements</p><p><strong>Operators and Predicates</strong></p><p>   = , &lt;&gt; , &lt; , &gt; , &lt;= , &gt;= , IS [NOT] (NULL|TRUE|FALSE) , LIKE , CLIKE , IN , BETWEEN</p><p><strong>Identifiers</strong> and <strong>Aliases</strong></p><p>   * regular identifiers are case insensitive (though see note on table names)    * delimited identifiers (inside double quotes) are case sensitive    * column and table aliases are supported</p><p><strong>Concatenation</strong></p><p>   * use either ANSI SQL || or the CONCAT() function    * e.g. these are the same:  {foo || bar} {CONCAT(foo,bar)}</p><p><strong>Comments</strong></p><p>   * comments must occur before or after statements, cannot be embedded    * SQL-style single line -- and C-style multi-line /* */ comments are supported</p><p><strong>NULLs</strong></p><p>   * currently NULLs and empty strings are identical in non-ANSI dialect.    * use {col IS NULL} to find NULLs, not {col=&apos;&apos;} (though both may work depending on dialect)</p><p>See below for further details.</p>
<h3>Syntax - Details</h3>
<p><em>\s-1CREATE\s0 \s-1TABLE\s0</em></p><p>Creates permanent and in-memory tables.</p><p> CREATE [TEMP] TABLE &lt;table_name&gt; ( &lt;column_definitions&gt; )  CREATE [TEMP] TABLE &lt;table_name&gt; AS &lt;select statement&gt;  CREATE [TEMP] TABLE &lt;table_name&gt; AS IMPORT()</p><p>Column definitions are standard \s-1SQL\s0 column names, types, and constraints, see \*(L"Column Definitions\*(R".</p><p>  # create a permanent table   #   $dbh-&gt;do("CREATE TABLE qux (id INT PRIMARY KEY,word VARCHAR(30))");</p><p>The \*(L"\s-1AS\s0 \s-1SELECT\s0\*(R" clause creates and populates the new table using the data and column structure specified in the select statement.</p><p>  # create and populate a table from a query to two other tables   #   $dbh-&gt;do("CREATE TABLE qux AS SELECT id,word FROM foo NATURAL JOIN bar");</p><p>If the optional keyword \s-1TEMP\s0 (or its synonym \s-1TEMPORARY\s0) is used, the table will be an in-memory table, available  for the life of the current database handle or until  a \s-1DROP\s0 \s-1TABLE\s0 command is issued.</p><p>  # create a temporary table   #   $dbh-&gt;do("CREATE TEMP TABLE qux (id INT PRIMARY KEY,word VARCHAR(30))");</p><p>\s-1TEMP\s0 tables can be modified with \s-1SQL\s0 commands but the updates are not automatically reflected back to any permanent tables they may be associated with.  To save a \s-1TEMP\s0 table - just use an \s-1AS\s0 \s-1SELECT\s0 clause:</p><p> $dbh = DBI-&gt;connect( &apos;dbi:CSV:&apos; );  $dbh-&gt;do("CREATE TEMP TABLE qux_temp AS (id INT, word VARCHAR(30))");  #  # ... modify qux_temp with INSERT, UPDATE, DELETE statements, then save it  #  $dbh-&gt;do("CREATE TABLE qux_permanent AS SELECT * FROM qux_temp");</p><p>Tables, both temporary and permanent may also be created directly from perl arrayrefs and from heterogeneous queries to any \s-1DBI\s0 accessible data source, see the \s-1<em>IMPORT\s0()</em> function.</p><p> CREATE [ {LOCAL|GLOBAL} TEMPORARY ] TABLE $table         (            $col_1 $col_type1 $col_constraints1,            ...,            $col_N $col_typeN $col_constraintsN,         )         [ ON COMMIT {DELETE|PRESERVE} ROWS ]</p><p>     * col_type must be a valid data type as defined in the        "valid_data_types" section of the dialect file for the        current dialect</p><p>     * col_constraints may be "PRIMARY KEY" or one or both of        "UNIQUE" and/or "NOT NULL"</p><p>     * IMPORTANT NOTE: temporary tables, data types and column        constraints are checked for syntax violations but are        currently otherwise *IGNORED* -- they are recognized by        the parser, but not by the execution engine</p><p>     * The following valid ANSI SQL92 options are not currently        supported: table constraints, named constraints, check        constraints, reference constraints, constraint        attributes, collations, default clauses, domain names as        data types</p><p><em>\s-1DROP\s0 \s-1TABLE\s0</em></p><p> DROP TABLE $table [ RESTRICT | CASCADE ]</p><p>     * IMPORTANT NOTE: drop behavior (cascade or restrict) is        checked for valid syntax but is otherwise *IGNORED* -- it        is recognized by the parser, but not by the execution        engine</p><p><em>\s-1INSERT\s0 \s-1INTO\s0</em></p><p> INSERT INTO $table [ ( $col1, ..., $colN ) ] VALUES ( $val1, ... $valN )</p><p>     * default values are not currently supported      * inserting from a subquery is not currently supported</p><p><em>\s-1DELETE\s0 \s-1FROM\s0</em></p><p> DELETE FROM $table [ WHERE search_condition ]</p><p>     * see "search_condition" below</p><p><em>\s-1UPDATE\s0</em></p><p> UPDATE $table SET $col1 = $val1, ... $colN = $valN [ WHERE search_condition ]</p><p>     * default values are not currently supported      * see "search_condition" below</p><p><em>\s-1SELECT\s0</em></p><p>      SELECT select_clause         FROM from_clause      [ WHERE search_condition ]   [ ORDER BY $ocol1 [ASC|DESC], ... $ocolN [ASC|DESC] ]      [ LIMIT [start,] length ]</p><p>      * select clause ::=              [DISTINCT|ALL] *            | [DISTINCT|ALL] col1 [,col2, ... colN]            | set_function1 [,set_function2, ... set_functionN]</p><p>      * set function ::=              COUNT ( [ALL] * )            | COUNT | MIN | MAX | AVG | SUM ( [DISTINCT|ALL] col_name )</p><p>      * from clause ::=              table1 [, table2, ... tableN]            | table1 NATURAL [join_type] JOIN table2            | table1 [join_type] table2 USING (col1,col2, ... colN)            | table1 [join_type] JOIN table2 ON table1.colA = table2.colB</p><p>      * join type ::=              INNER            | [OUTER] LEFT | RIGHT | FULL</p><p>      * if join_type is not specified, INNER is the default       * if DISTINCT or ALL is not specified, ALL is the default       * if start position is omitted from LIMIT clause, position 0 is         the default       * ON clauses may only contain equal comparisons and AND combiners       * self-joins are not currently supported       * if implicit joins are used, the WHERE clause must contain         an equijoin condition for each table       * multiple ANSI joins are not supported; use implicit joins for these       * this also means that combinations of INNER and non-INNER joins are         not supported</p><p><em>\s-1SEARCH\s0 \s-1CONDITION\s0</em></p><p>       [NOT] $val1 $op1 $val1 [ ... AND|OR $valN $opN $valN ]</p><p><em>\s-1OPERATORS\s0</em></p><p>       $op  = |  &lt;&gt; |  &lt; | &gt; | &lt;= | &gt;=               | IS [NOT] NULL | IS [NOT] TRUE | IS [NOT] FALSE               | LIKE | CLIKE | BETWEEN | IN</p><p>  The "CLIKE" operator works exactly the same as the "LIKE"   operator, but is case insensitive.  For example:</p><p>      WHERE foo LIKE &apos;bar%&apos;   # succeeds if foo is "barbaz"                               # fails if foo is "BARBAZ" or "Barbaz"</p><p>      WHERE foo CLIKE &apos;bar%&apos;  # succeeds for "barbaz", "Barbaz", and "BARBAZ"</p><p><em>BUILT-IN \s-1AND\s0 USER-DEFINED \s-1FUNCTIONS\s0</em></p><p>There are many built-in functions and you can also create your own new functions from perl subroutines.  See SQL::Statement::Functions for documentation of functions.</p><p><em>Identifiers (table & column names)</em></p><p>Regular identifiers (table and column names *without* quotes around them) are case \s-1INSENSITIVE\s0 so column foo, fOo, \s-1FOO\s0 all refer to the same column.  Internally they are used in their lower case representation, so do not rely on SQL::Statement retaining your case.</p><p>Delimited identifiers (table and column names *with* quotes around them) are case \s-1SENSITIVE\s0 so column \*(L"foo\*(R", \*(L"fOo\*(R", \*(L"\s-1FOO\s0\*(R" each refer to different columns.</p><p>A delimited identifier is *never* equal to a regular identifer (so \*(L"foo\*(R" and foo are two different columns).  But don't do that :-).</p><p>Remember thought that, in \s-1DBD::CSV\s0 if table names are used directly as file names, the case sensitivity depends on the \s-1OS\s0 e.g. on Windows files named foo, \s-1FOO\s0, and fOo are the same as each other while on Unix they are different.</p><p><em>Special Utility \s-1SQL\s0 Functions</em></p><p>\s-1<em>IMPORT\s0()</em></p><p>Imports the data and structure of a table from an external data source into a permanent or temporary table.</p><p> $dbh-&gt;do("CREATE TABLE qux AS IMPORT(?)",{},$oracle_sth);</p><p> $dbh-&gt;do("CREATE TABLE qux AS IMPORT(?)",{},$AoA);</p><p> $dbh-&gt;do("CREATE TABLE qux AS IMPORT(?)",{},$AoH);</p><p>\s-1<em>IMPORT\s0()</em> can also be used anywhere that table_names can:</p><p> $sth=$dbh-&gt;prepare("     SELECT * FROM IMPORT(?) AS T1 NATURAL JOIN IMPORT(?) AS T2 WHERE T1.id ...  ");  $sth-&gt;execute( $pg_sth, $mysql_sth );</p><p>The \s-1<em>IMPORT\s0()</em> function imports the data and structure of a table from an external data source.  The \s-1<em>IMPORT\s0()</em> function is always used with a placeholder parameter which may be 1) a prepared and executed statement handle for any \s-1DBI\s0 accessible data source;  or 2) an AoA whose first row is column names and whose succeeding rows are data 3) an AoH.</p><p>The \s-1<em>IMPORT\s0()</em> function may be used in the \s-1AS\s0 clause of a \s-1CREATE\s0 statement, and in the \s-1FROM\s0 clause of any statement.  When used in a \s-1FROM\s0 clause, it should be used with a column alias e.g. \s-1SELECT\s0 * \s-1FROM\s0 \s-1IMPORT\s0(?) \s-1AS\s0 TableA \s-1WHERE\s0 ...</p><p>You can also write your own \s-1<em>IMPORT\s0()</em> functions to treat anything as a data source.  See User-Defined Function in SQL::Statement::Functions.</p><p>Examples:</p><p> # create a CSV file from an Oracle query  #  $dbh = DBI-&gt;connect(&apos;dbi:CSV:&apos;);  $oracle_sth = $oracle_dbh-&gt;prepare($any_oracle_query);  $oracle_sth-&gt;execute(@params);  $dbh-&gt;do("CREATE TABLE qux AS IMPORT(?)",{},$oracle_sth);</p><p> # create an in-memory table from an AoA  #  $dbh      = DBI-&gt;connect( &apos;dbi:File:&apos; );  $arrayref = [[&apos;id&apos;,&apos;word&apos;],[1,&apos;foo&apos;],[2,&apos;bar&apos;],];  $dbh-&gt;do("CREATE TEMP TABLE qux AS IMPORT(?)",{},$arrayref);</p><p> # query a join of a PostgreSQL table and a MySQL table  #  $dbh        = DBI-&gt;connect( &apos;dbi:File:&apos; );  $pg_dbh     = DBI-&gt;connect( ... DBD::pg connect params );  $mysql_dbh  = DBI-&gt;connect( ... DBD::mysql connect params );  $pg_sth     = $pg_dbh-&gt;prepare( ... any pg query );  $pg_sth     = $pg_dbh-&gt;prepare( ... any mysql query );  #  $sth=$dbh-&gt;prepare("     SELECT * FROM IMPORT(?) AS T1 NATURAL JOIN IMPORT(?) AS T2  ");  $sth-&gt;execute( $pg_sth, $mysql_sth );</p><p>\s-1<em>RUN\s0()</em></p><p>Run \s-1SQL\s0 statements from a user supplied file.  <strong>Please Note:</strong> this function is experimental, please let me know if you have problems.</p><p> RUN( sql_file )</p><p>If the file contains non-SELECT statements such as \s-1CREATE\s0 and \s-1INSERT\s0, use the \s-1<em>RUN\s0()</em> function with $dbh-&gt;<em>do()</em>.  For example, this prepares and executes all of the \s-1SQL\s0 statements in a file called \*(L"populate.sql\*(R":</p><p> $dbh-&gt;do(" CALL RUN( &apos;populate.sql&apos;) ");</p><p>If the file contains \s-1SELECT\s0 statements, the \s-1<em>RUN\s0()</em> function may be used anywhere a table name may be used, for example, if you have a file called \*(L"query.sql\*(R" containing \*(L"\s-1SELECT\s0 * \s-1FROM\s0 Employee\*(R", then these two lines are exactly the same:</p><p> my $sth = $dbh-&gt;prepare(" SELECT * FROM Employee ");</p><p> my $sth = $dbh-&gt;prepare(" SELECT * FROM RUN( &apos;query.sql&apos; ) ");</p><p>If the file contains a statement with placeholders, the values for the placehoders can be passed in the call to $sth-&gt;<em>execute()</em> as normal. If the query.sql file contains \*(L"\s-1SELECT\s0 id,name \s-1FROM\s0 x \s-1WHERE\s0 id=?\*(R", then these two are the same:</p><p> my $sth = $dbh-&gt;prepare(" SELECT id,name FROM x WHERE id=?");  $sth-&gt;execute(64);</p><p> my $sth = $dbh-&gt;prepare(" SELECT * FROM RUN( &apos;query.sql&apos; ) ");  $sth-&gt;execute(64);</p><p><strong>Note</strong> This function assumes that the \s-1SQL\s0 statements in the file are separated by a semi-colon+newline combination (/;&#92;n/).  If you wish to use different separators or import \s-1SQL\s0 from a different source, just override the \s-1<em>RUN\s0()</em> function with your own user-defined-function.</p>
<h3>Further details</h3>

<dl class='dl-vertical'>
  <dt>
    Integers
  </dt>
  <dd>
    
  </dd>
  <dt>
    Reals
  </dt>
  <dd>
    <p>Syntax obvious</p>
  </dd>
  <dt>
    Strings
  </dt>
  <dd>
    <p>Surrounded by either single quotes; some characters need to be escaped with a backslash, in particular the backslash itself (&#92;&#92;), the \s-1NUL\s0 byte (&#92;0), Line feeds (&#92;n), Carriage return (&#92;r), and the quotes (&#92;'). <strong>Note:</strong> Quoting \*(L"Strings\*(R" using double quotes are recognized as quoted identifiers (column or table names).</p>
  </dd>
  <dt>
    Parameters
  </dt>
  <dd>
    <p>Parameters represent scalar values, like Integers, Reals and Strings do. However, their values are read inside <em>Execute()</em> and not inside <em>Prepare()</em>. Parameters are represented by question marks (?).</p>
  </dd>
  <dt>
    Identifiers
  </dt>
  <dd>
    <p>Identifiers are table or column names. Syntactically they consist of alphabetic characters, followed by an arbitrary number of alphanumeric characters. Identifiers like \s-1SELECT\s0, \s-1INSERT\s0, \s-1INTO\s0, \s-1ORDER\s0, \s-1BY\s0, \s-1WHERE\s0, ... are forbidden and reserved for other tokens.  Identifiers are always compared case-insensitively, i.e. \*(C`select foo from bar\*(C' will be evaluated the same as \*(C`SELECT FOO FROM BAR\*(C' (\*(C`FOO\*(C' will be evaluated as \*(C`foo\*(C', similar for \*(C`BAR\*(C'). Since SQL::Statement is internally using lower cased identifiers (unquoted), everytime a wildcard is used, the delivered names of the identifiers are lower cased.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Extending SQL syntax using SQL</h2>
        <div class="sectioncontent">
<p>The Supported \s-1SQL\s0 syntax shown above is the default for SQL::Statement but it can be extended (or contracted) either on-the-fly or on a permanent basis. In other words, you can modify the \s-1SQL\s0 syntax accepted as valid by the parser and accepted as executable by the executer.  There are two methods for extending the syntax - 1) with \s-1SQL\s0 commands that can be issued directly in SQL::Statement or form a \s-1DBD\s0 or 2) by subclassing SQL::Parser.</p><p>The following \s-1SQL\s0 commands modify the default \s-1SQL\s0 syntax:</p><p>  CREATE/DROP FUNCTION   CREATE/DROP KEYWORD   CREATE/DROP TYPE   CREATE/DROP OPERATOR</p><p>A simple example would be a situation in which you have a table named '\s-1TABLE\s0'.  Since table is an \s-1ANSI\s0 reserved key word, by default SQL::Statement will produce an error when you attempt to create or access it.  You could put the table name inside double quotes since quoted identifiers can validly be reserved words, or you could rename the table.  If neither of those are options, you would do this:</p><p>  DROP KEYWORD table</p><p>Once that statement is issued, the parser will no longer object to 'table' as a table name.  Careful though, if you drop too many keywords you may confuse the parser, especially keywords like \s-1FROM\s0 and \s-1WHERE\s0 that are central to parsing the statement.</p><p>In the reverse situation, suppose you want to parse some \s-1SQL\s0 that defines a column as type \s-1BIG_BLOB\s0.  Since '\s-1BIG_BLOB\s0' isn't a recognized \s-1ANSI\s0 data type, an error will be produced by default.  To make the parser treat it as a valid data type, you do this:</p><p> CREATE TYPE big_blob</p><p>Keywords and types are case-insensitive.</p><p>Suppose you are working with some \s-1SQL\s0 that contains the <em>cosh()</em> function (an Oracle function for hyperbolic cosine, whatever that is :-).  The <em>cosh()</em> function is not currently implemented in SQL::Statement so the parser would die with an error.  But you can easily trick the parser into accepting the function:</p><p> CREATE FUNCTION cosh</p><p>Once the parser has read that \s-1CREATE\s0 \s-1FUNCTION\s0 statement, it will no longer object to the use of the <em>cosh()</em> function in \s-1SQL\s0 statements.</p><p>If your only interest is in parsing \s-1SQL\s0 statements, then \*(C`CREATE FUNCTION cosh\*(C' is sufficient.  But if you actually want to be able to use the <em>cosh()</em> function in executable statements, you need to supply a perl subroutine that performs the <em>cosh()</em> function:</p><p>  CREATE FUNCTION cosh AS perl_subroutine_name</p><p>The subroutine name can refer to a subroutine in your current script, or to a subroutine in any available package.  See SQL::Statement::Functions for details of how to create and load functions.</p><p>Functions can be used as  predicates in search clauses, for example:</p><p> SELECT * FROM x WHERE c1=7 AND SOUNDEX(c3,&apos;foo&apos;) AND c8=&apos;bar&apos;</p><p>In the \s-1SQL\s0 above, the \*(C`SOUNDEX()\*(C' function full predicate - it plays the same role as \*(C`c1=7 or c8=&apos;bar&apos;\*(C'.</p><p>Functions can also serve as predicate operators.  An operator, unlike a full predicate, has something on the left and right sides.  An equal sign is an operator, so is \s-1LIKE\s0.  If you really want to you can get the parser to not accept \s-1LIKE\s0 as an operator with</p><p> DROP OPERATOR like</p><p>Or, you can invent your own operator.  Suppose you have an operator \*(C`REVERSE_OF\*(C' that is true if the string on its left side when reversed is equal to the string on the right side:</p><p>  CREATE OPERATOR reverse_of   SELECT * FROM x WHERE c1=7 AND c3 REVERSE_OF &apos;foo&apos;</p><p>The operator could just as well have been written as a function:</p><p>  CREATE FUNCTION reverse_of   SELECT * FROM x WHERE c1=7 AND REVERSE_OF(c3,&apos;foo&apos;)</p><p>Like functions, if you want to actually execute a user-defined operator as distinct from just parsing it, you need to assign the operator to a perl subroutine.  This is done exactly like assigning functions:</p><p>  CREATE OPERATOR reverse_of AS perl_subroutine_name</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Extending SQL syntax using subclasses</h2>
        <div class="sectioncontent">
<p>In addition to using the \s-1SQL\s0 shown above to modify the parser's behavior, you can also extend the \s-1SQL\s0 syntax by subclassing SQL::Parser. See SQL::Parser for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR & COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2005, Jeff Zucker &lt;jzuckerATcpan.org&gt;, all rights reserved. Copyright (c) 2009, Jens Rehsack &lt;rehsackATcpan.org&gt;, all rights reserved.</p><p>This document may be freely modified and distributed under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SQL::Statement::Structure.3pm.html"><span aria-hidden="true">&larr;</span> SQL::Statement::Structure.3pm: Parse and examine structure of sql queries</a></li>
   <li class="next"><a href="SQL::Statement::Term.3pm.html">SQL::Statement::Term.3pm: Term for column values <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

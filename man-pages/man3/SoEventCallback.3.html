<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoEventCallback: The soeventcallback class provides functionality for catching events.  use soeventcallback nodes in the scenegraph for catching user interaction events with the scenegraph's render canvas.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soeventcallback class provides functionality for catching events.  use soeventcallback nodes in the scenegraph for catching user interaction events with the scenegraph's render canvas.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoEventCallback (3) manual">
  <meta name="twitter:description" content="The soeventcallback class provides functionality for catching events.  use soeventcallback nodes in the scenegraph for catching user interaction events with the scenegraph's render canvas.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoEventCallback-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoEventCallback.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoEventCallback (3) manual" />
  <meta property="og:description" content="The soeventcallback class provides functionality for catching events.  use soeventcallback nodes in the scenegraph for catching user interaction events with the scenegraph's render canvas." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoEventCallback-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoEventCallback<small> (3)</small></h1>
        <p class="lead">The soeventcallback class provides functionality for catching events.  use soeventcallback nodes in the scenegraph for catching user interaction events with the scenegraph's render canvas.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoEventCallback.3.html">
      <span itemprop="name">SoEventCallback: The soeventcallback class provides functionality for catching events.  use soeventcallback nodes in the scenegraph for catching user interaction events with the scenegraph's render canvas.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoEventCallback.3.html">
      <span itemprop="name">SoEventCallback: The soeventcallback class provides functionality for catching events.  use soeventcallback nodes in the scenegraph for catching user interaction events with the scenegraph's render canvas.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/nodes/SoEventCallback.h&gt;</p><p>Inherits <strong>SoNode</strong>.</p><h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> <strong>SoEventCallback</strong> (void)</p><p>void <strong>setPath</strong> (<strong>SoPath</strong> *path)</p><p>const <strong>SoPath</strong> * <strong>getPath</strong> (void)</p><p>void <strong>addEventCallback</strong> (<strong>SoType</strong> eventtype, <strong>SoEventCallbackCB</strong> *f, void *userdata=NULL)</p><p>void <strong>removeEventCallback</strong> (<strong>SoType</strong> eventtype, <strong>SoEventCallbackCB</strong> *f, void *userdata=NULL)</p><p><strong>SoHandleEventAction</strong> * <strong>getAction</strong> (void) const </p><p>const <strong>SoEvent</strong> * <strong>getEvent</strong> (void) const </p><p>const <strong>SoPickedPoint</strong> * <strong>getPickedPoint</strong> (void) const </p><p>void <strong>setHandled</strong> (void)</p><p>SbBool <strong>isHandled</strong> (void) const </p><p>void <strong>grabEvents</strong> (void)</p><p>void <strong>releaseEvents</strong> (void)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual <strong>~SoEventCallback</strong> ()</p><p>virtual void <strong>handleEvent</strong> (<strong>SoHandleEventAction</strong> *action)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoEventCallback</strong> class provides functionality for catching events.</p><p>Use <strong>SoEventCallback</strong> nodes in the scenegraph for catching user interaction events with the scenegraph's render canvas.</p><p>This is how event handling works in Coin: when the user interacts with the render canvas, for instance by using the mouse pointer or by hitting the keyboard, the GUI interface toolkit (ie SoQt, SoWin, SoXt, Sc21 ...) will catch the event and translate it from a windowsystem-specific event to a generic Coin event. (For the types of generic Coin events, see the classes derived from <strong>SoEvent</strong>.) This event will then be wrapped inside a <strong>SoHandleEventAction</strong> and applied to the scenegraph. All this happens within the So[Qt|Xt|Win|...] toolkit.</p><p>The <strong>SoHandleEventAction</strong> then traverses the scenegraph, delivering the event to any node type which 'is interested' in it. The <strong>SoEventCallback</strong> nodetype catches the action and forwards the event to a callback function set up by the application programmer.</p><p>Be careful about which position in the scenegraph you insert <strong>SoEventCallback</strong> nodes if you are also using any of the built-in Coin library elements which are interested in user interaction events (like for instance the dragger and manipulator classes and the <strong>SoSelection</strong> nodes). These Coin elements might catch the event for themselves, short-circuiting the <strong>SoHandleEventAction</strong> traversal so the event will never reach the <strong>SoEventCallback</strong> node(s) you insert.</p><p><strong>FILE FORMAT/DEFAULTS:</strong></p>
<pre>
EventCallback {
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoEventCallback::SoEventCallback (void)</h3>
<p>Constructor.</p>
<h3>SoEventCallback::~SoEventCallback ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoEventCallback::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Implements <strong>SoBase</strong>.</p>
<h3>const \fBSoFieldData\fP * SoEventCallback::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoFieldContainer</strong>.</p>
<h3>void SoEventCallback::setPath (\fBSoPath\fP *pathptr)</h3>
<p>Sets the path that must be picked before the registered callbacks are invoked. If NULL, callbacks will be invoked for every event that matches the callback event type.</p><p><strong>See also:</strong></p><p><strong>getPath()</strong></p>
<h3>const \fBSoPath\fP * SoEventCallback::getPath (void)</h3>
<p>Returns the path that must be picked before callbacks are invoked.</p><p><strong>See also:</strong></p><p><strong>setPath()</strong></p>
<h3>void SoEventCallback::addEventCallback (\fBSoType\fPeventtype, \fBSoEventCallbackCB\fP *f, void *userdata = \fCNULL\fP)</h3>
<p>Set up a callback function <em>f</em> which will be invoked for the given <em>eventtype</em>. <em>userdata</em> will be given as the first argument to the function.</p>
<h3>void SoEventCallback::removeEventCallback (\fBSoType\fPeventtype, \fBSoEventCallbackCB\fP *f, void *userdata = \fCNULL\fP)</h3>
<p>Unregister the given callback function <em>f</em>.</p>
<h3>\fBSoHandleEventAction\fP * SoEventCallback::getAction (void) const</h3>
<p>Returns the <strong>SoHandleEventAction</strong> instance currently traversing the scene graph with the SoEvent-derived event object.</p>
<h3>const \fBSoEvent\fP * SoEventCallback::getEvent (void) const</h3>
<p>Returns a pointer to the event object which is currently being sent through the scenegraph.</p><p>If your application code handles the event, you probably want to call <strong>SoEventCallback::setHandled()</strong> to notify the <strong>SoHandleEventAction</strong> that it should stop traversing the scenegraph with the event.</p>
<h3>const \fBSoPickedPoint\fP * SoEventCallback::getPickedPoint (void) const</h3>
<p>Returns the picked point for the current handle event traversal.</p><p>This is obviously only related to events which can be considered 'pick-style' events, like mousebutton presses.</p>
<h3>void SoEventCallback::setHandled (void)</h3>
<p>Use this method from a callback function to notify the node that the event has been handled.</p><p>The rest of the callbacks registered with the node will still be called, but further <strong>SoEventCallback</strong> nodes in the scene will not be notified about the event, neither will any other Coin elements in the scenegraph (like for instance <strong>SoDragger</strong> objects, <strong>SoSelection</strong> nodes or manipulators).</p><p>Since callbacks registered within the same <strong>SoEventCallback</strong> node will still be invoked after the event has been handled, it is likely that you should use <strong>SoEventCallback::isHandled()</strong> to check for this condition from your callback functions.</p>
<h3>SbBool SoEventCallback::isHandled (void) const</h3>
<p>Check whether or not the event from the <strong>SoHandleEventAction</strong> has been handled.</p>
<h3>void SoEventCallback::grabEvents (void)</h3>
<p>Set up the node so all future events (until <strong>releaseEvents()</strong> is called) in Coin will be directly forwarded to this node.</p>
<h3>void SoEventCallback::releaseEvents (void)</h3>
<p>Do not grab event handling any more.</p><p><strong>See also:</strong></p><p><strong>grabEvents()</strong></p>
<h3>void SoEventCallback::handleEvent (\fBSoHandleEventAction\fP *action)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Invokes the registered callback functions.</p><p>Reimplemented from <strong>SoNode</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoEvent.3.html"><span aria-hidden="true">&larr;</span> SoEvent.3: The soevent class is the base class for all coin events.  coin contains its own set of event classes, independent of the underlying window system.</a></li>
   <li class="next"><a href="SoEventCallback.h.3.html">SoEventCallback.h.3: Soeventcallback.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

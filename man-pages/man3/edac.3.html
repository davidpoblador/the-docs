<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>edac: Edac error reporting library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Edac error reporting library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="edac (3) manual">
  <meta name="twitter:description" content="Edac error reporting library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libedac-dev-edac-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/edac.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="edac (3) manual" />
  <meta property="og:description" content="Edac error reporting library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libedac-dev-edac-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">edac<small> (3)</small></h1>
        <p class="lead">Edac error reporting library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/edac.3.html">
      <span itemprop="name">edac: Edac error reporting library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libedac-dev/">
      <span itemprop="name">libedac-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/edac.3.html">
      <span itemprop="name">edac: Edac error reporting library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<strong>#include &lt;edac.h&gt;</strong>

<strong>cc ... -ledac</strong>

<strong>edac_handle * edac_handle_create (</strong><em>void</em><strong>);</strong>

<strong>void edac_handle_destroy (edac_handle *</strong><em>edac</em><strong>);</strong>

<strong>int edac_handle_init (edac_handle *</strong><em>edac</em><strong>);</strong>

<strong>unsigned int edac_mc_count (edac_handle *</strong><em>edac</em><strong>);</strong>

<strong>int edac_handle_reset (edac_handle *</strong><em>edac</em><strong>);</strong>

<strong>int edac_error_totals (edac_handle *</strong><em>edac</em><strong>, struct edac_totals *</strong><em>totals</em><strong>);</strong>

<strong>edac_mc * edac_next_mc (edac_handle *</strong><em>edac</em><strong>);</strong>

<strong>int edac_mc_get_info (edac_mc *</strong><em>mc</em><strong>, struct edac_mc_info *</strong><em>info</em><strong>);</strong>

<strong>edac_mc *edac_next_mc_info (edac_handle *</strong><em>edac</em><strong>,</strong>
<strong>                            struct edac_mc_info *</strong><em>info</em><strong>);</strong>

<strong>int edac_mc_reset (struct edac_mc *</strong><em>mc</em><strong>);</strong>

<strong>edac_csrow * edac_next_csrow (struct edac_mc *</strong><em>mc</em><strong>);</strong>

<strong>int edac_csrow_get_info (edac_csrow *</strong><em>csrow</em><strong>,</strong>
<strong>                         struct edac_csrow_info *</strong><em>info</em><strong>);</strong>

<strong>edac_csrow * edac_next_csrow_info (edac_mc *</strong><em>mc</em><strong>,</strong>
<strong>                                   struct edac_csrow_info *</strong><em>info</em><strong>);</strong>

<strong>const char * edac_strerror (edac_handle *</strong><em>edac</em><strong>);</strong>

<strong>edac_for_each_mc_info (edac_handle *</strong><em>edac</em><strong>, edac_mc *</strong><em>mc</em><strong>,</strong>
<strong>                       struct edac_csrow_info *</strong><em>info</em><strong>)    { ... }</strong>

<strong>edac_for_each_csrow_info (edac_mc *</strong><em>mc</em><strong>, edac_csrow *</strong><em>csrow</em><strong>,</strong>
<strong>                          struct edac_csrow_info *</strong><em>info</em><strong>) { ... }</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <em>libedac</em> library offers a very simple programming interface to the information exported from in-kernel EDAC (Error Detection and Correction) drivers in sysfs. The <strong>edac-util</strong>(8) utility uses <em>libedac</em> to report errors in a user-friendly manner from the command line.</p><p>EDAC errors for most systems are recorded in sysfs on a per memory controller (MC) basis. Memory controllers are further subdivided by csrow and channel. The <em>libedac</em> library provides a method to loop through multiple MCs, and their corresponding csrows, obtaining information about each component from sysfs along the way. There is also a simple single call to retrieve the total error counts for a given machine.</p><p>In order to use <em>libedac</em> an <strong>edac_handle</strong> must first be opened via the call <strong>edac_handle_create</strong>(). Once the handle is created, sysfs data can be loaded into the handle with <strong>edac_handle_init</strong>(). A final call to <strong>edac_handle_destroy</strong>() will free all memory and open files associated with the edac handle.</p><p><strong>edac_handle_create</strong>() will return <strong>NULL</strong> on failure to allocate memory.</p><p>The <strong>edac_strerror</strong> function will return a descriptive string representation of the last error for the <em>libedac</em> handle <em>edac</em>.</p><p>The <strong>edac_error_totals</strong>() function will return the total counts of memory and pci errors in the <em>totals</em> structure passed to the function. The <em>totals</em> structure is of type <em>edac_totals</em> which has the form:</p>
<pre>
struct edac_totals {
   unsigned int  ce_total;         /* Total corrected errors   */
   unsigned int  ue_total;         /* Total uncorrected errors */
   unsigned int  pci_parity_total; /* Total PCI Parity errors  */
};
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMORY CONTROLLER INFORMATION</h2>
        <div class="sectioncontent">
<p>Systems may have one or more memory controllers (MCs) with EDAC information. The number of MCs detected by EDAC drivers may be queried with the <strong>edac_mc_count</strong>() function, while the <strong>edac_next_mc</strong> function will return a handle to the next memory controller in the <em>libedac</em> handle\'s internal list. This memory controller is represented by the opaque <strong>edac_mc</strong> type.</p><p><strong>edac_next_mc</strong> will return <strong>NULL</strong> when there are no further memory controllers to return. Thus the following example code is another method to count all EDAC MCs (assuming the EDAC library handle <em>edac</em> has already been initialized):</p>
<pre>
int i = 0;
edac_mc *mc;
while ((mc = edac_next_mc (edac)))
    i++;
return (i);
</pre>
<p>To query information about an <strong>edac_mc</strong>, use the <strong>edac_mc_get_info</strong> function. This function fills in the given <strong>info</strong> structure, which is of type <strong>edac_mc_info</strong>:</p>
<pre>
struct edac_mc_info {
    char           id[];           /* Id of memory controller */
    char           mc_name[];      /* Name of MC              */
    unsigned int   size_mb;        /* Amount of RAM in MB     */
    unsigned int   ce_count;       /* Corrected error count   */
    unsigned int   ce_noinfo_count;/* noinfo Corrected errors */
    unsigned int   ue_count;       /* Uncorrected error count */
    unsigned int   ue_noinfo_count;/* noinfo Uncorrected errors*/
};
</pre>
<p>The function <strong>edac_next_mc_info</strong>() can be used to loop through all EDAC memory controllers and obtain MC information in a single call. It is a combined <strong>edac_next_mc</strong>() and <strong>edac_mc_get_info</strong>().</p><p>The function <strong>edac_handle_reset</strong>() will reset the internal memory controller iterator in the <em>libedac</em> handle. A subsequent call to <strong>edac_next_mc</strong>() would thus return the first EDAC MC.</p><p>A convenience macro, <strong>edac_for_each_mc_info</strong>(), is provided which defines a for loop that iterates through all memory controller  objects for a given EDAC handle, returning the MC information in the <em>info</em> structure on each iteration. For example (assuming initialized <em>libedac</em> handle <em>edac</em>):</p>
<pre>
edac_mc *mc;
struct edac_mc_info info;
int count = 0;

edac_for_each_mc_info (edac, mc, info) {
    count++;
    printf ("MC info: id=%s name=%s&#92;n", info.id, info.mc_name);
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CSROW INFORMATION</h2>
        <div class="sectioncontent">
<p>Each EDAC memory controller may have one or more <em>csrow</em>s associated with it. Similar to the MC iterator functions described above, the <strong>edac_next_csrow</strong>() function allows <em>libedac</em> users to loop through all csrows within a given MC. Once the last csrow is reached, the function will return <strong>NULL</strong>.</p><p>The <strong>edac_csrow_get_info</strong>() function returns information about <strong>edac_csrow</strong><strong> in the </strong><strong>edac_csrow_info</strong> structure, which has the contents:</p>
<pre>
struct edac_csrow_info {
    char          id[];      /* CSROW Identity (e.g. csrow0)  */
    unsigned int  size_mb;   /* CSROW size in MB              */
    unsigned int  ce_count;  /* Total corrected errors        */
    unsigned int  ue_count;  /* Total uncorrected errors      */
    struct edac_channel channel[EDAC_MAX_CHANNELS];
};

struct edac_channel {
    int           valid;            /* Is this channel valid */
    unsigned int  ce_count;         /* Corrected error count */
    int           dimm_label_valid; /* Is DIMM label valid?  */
    char          dimm_label[];     /* DIMM name             */
};
</pre>
<p>The <strong>edac_next_csrow_info</strong>() function is a combined version of <strong>edac_next_csrow</strong>() and <strong>edac_csrow_get_info</strong>() for convenience.</p><p>The <strong>edac_mc_reset</strong>() function is provided to reset the <strong>edac_mc</strong> internal csrow iterator.</p><p>A convenience macro, <strong>edac_for_each_csrow_info</strong>(), is provided which defines a for loop that iterates through all csrow objects in an EDAC memory controller, returning the csrow information in the <em>info</em> structure on each iteration.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Initialize <em>libedac</em> handle:</p>
<pre>
edac_handle *edac;

if (!(edac = edac_handle_create ())) {
    fprintf (stderr, "edac_handle_create: Out of memory!&#92;n");
    exit (1);
}

if (edac_handle_init (edac) &lt; 0) {
   fprintf (stderr, "Unable to get EDAC data: %s&#92;n",
                    edac_strerror (edac));
   exit (1);
}

printf ("EDAC initialized with %d MCs&#92;n", edac_mc_count (edac));

edac_handle_destroy (edac);
</pre>
<p>Report all DIMM labels for MC:csrow:channel combinations</p>
<pre>
edac_mc *mc;
edac_csrow *csrow;
struct edac_mc_info mci;
struct edac_csrow_info csi;

edac_for_each_mc_info (ctx-&gt;edac, mc, mci) {
    edac_for_each_csrow_info (mc, csrow, csi) {
        char *label[2] = { "unset", "unset" };

        if (csi.channel[0].dimm_label_valid)
            label[0] = csi.channel[0].dimm_label;
        if (csi.channel[1].dimm_label_valid)
            label[1] = csi.channel[1].dimm_label;

        printf ("%s:%s:ch0 = %s&#92;n", mci.id, csi.id, label[0]);
        printf ("%s:%s:ch1 = %s&#92;n", mci.id, csi.id, label[1]);
    }
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO edac&hellip;</h2>
        <div class="sectioncontent">
<p><strong>edac-util</strong>(8), <a href="../man8/edac-ctl.8.html"><strong>edac-ctl</strong>(8)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ecvt_r.3.html"><span aria-hidden="true">&larr;</span> ecvt_r.3: Convert a floating-point number to a string</a></li>
   <li class="next"><a href="edata.3.html">edata.3: End of program segments <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

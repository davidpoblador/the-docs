<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoDragger: The sodragger class is the base class for all draggers.  draggers is a mechanism used for letting the end-users of your application code interact with elements in 3d, by scaling, rotating or translating geometry or other instances in the scene (like cameras or lightsources).</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sodragger class is the base class for all draggers.  draggers is a mechanism used for letting the end-users of your application code interact with elements in 3d, by scaling, rotating or translating geometry or other instances in the scene (like cameras or lightsources).">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoDragger (3) manual">
  <meta name="twitter:description" content="The sodragger class is the base class for all draggers.  draggers is a mechanism used for letting the end-users of your application code interact with elements in 3d, by scaling, rotating or translating geometry or other instances in the scene (like cameras or lightsources).">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoDragger-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoDragger.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoDragger (3) manual" />
  <meta property="og:description" content="The sodragger class is the base class for all draggers.  draggers is a mechanism used for letting the end-users of your application code interact with elements in 3d, by scaling, rotating or translating geometry or other instances in the scene (like cameras or lightsources)." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoDragger-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoDragger<small> (3)</small></h1>
        <p class="lead">The sodragger class is the base class for all draggers.  draggers is a mechanism used for letting the end-users of your application code interact with elements in 3d, by scaling, rotating or translating geometry or other instances in the scene (like cameras or lightsources).</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoDragger.3.html">
      <span itemprop="name">SoDragger: The sodragger class is the base class for all draggers.  draggers is a mechanism used for letting the end-users of your application code interact with elements in 3d, by scaling, rotating or translating geometry or other instances in the scene (like cameras or lightsources).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoDragger.3.html">
      <span itemprop="name">SoDragger: The sodragger class is the base class for all draggers.  draggers is a mechanism used for letting the end-users of your application code interact with elements in 3d, by scaling, rotating or translating geometry or other instances in the scene (like cameras or lightsources).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/draggers/SoDragger.h&gt;</p><p>Inherits <strong>SoInteractionKit</strong>.</p><p>Inherited by <strong>SoCenterballDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoPointLightDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoScaleUniformDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTabBoxDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTrackballDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoTransformerDragger</strong>, <strong>SoTranslate1Dragger</strong>, and <strong>SoTranslate2Dragger</strong>.</p><h3>Public Types</h3>
<p>enum <strong>ProjectorFrontSetting</strong> { <strong>FRONT</strong>, <strong>BACK</strong>, <strong>USE_PICK</strong> }</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> virtual const <strong>SoNodekitCatalog</strong> * <strong>getNodekitCatalog</strong> (void) const </p><p>virtual void <strong>callback</strong> (<strong>SoCallbackAction</strong> *action)</p><p>virtual void <strong>GLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>getMatrix</strong> (<strong>SoGetMatrixAction</strong> *action)</p><p>virtual void <strong>rayPick</strong> (<strong>SoRayPickAction</strong> *action)</p><p>virtual void <strong>search</strong> (<strong>SoSearchAction</strong> *action)</p><p>virtual void <strong>write</strong> (<strong>SoWriteAction</strong> *action)</p><p>virtual void <strong>getPrimitiveCount</strong> (<strong>SoGetPrimitiveCountAction</strong> *action)</p><p>void <strong>setProjectorEpsilon</strong> (const float epsilon)</p><p>float <strong>getProjectorEpsilon</strong> (void) const </p><p>void <strong>addStartCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>removeStartCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>addMotionCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>removeMotionCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>addFinishCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>removeFinishCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>addValueChangedCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>removeValueChangedCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>setMinGesture</strong> (int pixels)</p><p>int <strong>getMinGesture</strong> (void) const </p><p>SbBool <strong>enableValueChangedCallbacks</strong> (SbBool newval)</p><p>const <strong>SbMatrix</strong> & <strong>getMotionMatrix</strong> (void)</p><p>void <strong>addOtherEventCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>removeOtherEventCallback</strong> (<strong>SoDraggerCB</strong> *func, void *data=NULL)</p><p>void <strong>registerChildDragger</strong> (<strong>SoDragger</strong> *child)</p><p>void <strong>unregisterChildDragger</strong> (<strong>SoDragger</strong> *child)</p><p>void <strong>registerChildDraggerMovingIndependently</strong> (<strong>SoDragger</strong> *child)</p><p>void <strong>unregisterChildDraggerMovingIndependently</strong> (<strong>SoDragger</strong> *child)</p><p><strong>SbMatrix</strong> <strong>getLocalToWorldMatrix</strong> (void)</p><p><strong>SbMatrix</strong> <strong>getWorldToLocalMatrix</strong> (void)</p><p><strong>SbVec3f</strong> <strong>getLocalStartingPoint</strong> (void)</p><p><strong>SbVec3f</strong> <strong>getWorldStartingPoint</strong> (void)</p><p>void <strong>getPartToLocalMatrix</strong> (const <strong>SbName</strong> &partname, <strong>SbMatrix</strong> &parttolocalmatrix, <strong>SbMatrix</strong> &localtopartmatrix)</p><p>void <strong>transformMatrixLocalToWorld</strong> (const <strong>SbMatrix</strong> &frommatrix, <strong>SbMatrix</strong> &tomatrix)</p><p>void <strong>transformMatrixWorldToLocal</strong> (const <strong>SbMatrix</strong> &frommatrix, <strong>SbMatrix</strong> &tomatrix)</p><p>void <strong>transformMatrixToLocalSpace</strong> (const <strong>SbMatrix</strong> &frommatrix, <strong>SbMatrix</strong> &tomatrix, const <strong>SbName</strong> &fromspacepartname)</p><p>virtual void <strong>setMotionMatrix</strong> (const <strong>SbMatrix</strong> &newmatrix)</p><p>void <strong>valueChanged</strong> (void)</p><p>const <strong>SbMatrix</strong> & <strong>getStartMotionMatrix</strong> (void)</p><p>virtual void <strong>saveStartParameters</strong> (void)</p><p>const <strong>SoPath</strong> * <strong>getPickPath</strong> (void) const </p><p>const <strong>SoEvent</strong> * <strong>getEvent</strong> (void) const </p><p><strong>SoPath</strong> * <strong>createPathToThis</strong> (void)</p><p>const <strong>SoPath</strong> * <strong>getSurrogatePartPickedOwner</strong> (void) const </p><p>const <strong>SbName</strong> & <strong>getSurrogatePartPickedName</strong> (void) const </p><p>const <strong>SoPath</strong> * <strong>getSurrogatePartPickedPath</strong> (void) const </p><p>void <strong>setStartingPoint</strong> (const <strong>SoPickedPoint</strong> *newpoint)</p><p>void <strong>setStartingPoint</strong> (const <strong>SbVec3f</strong> &newpoint)</p><p>const <strong>SbViewVolume</strong> & <strong>getViewVolume</strong> (void)</p><p>void <strong>setViewVolume</strong> (const <strong>SbViewVolume</strong> &vol)</p><p>const <strong>SbViewportRegion</strong> & <strong>getViewportRegion</strong> (void)</p><p>void <strong>setViewportRegion</strong> (const <strong>SbViewportRegion</strong> &reg)</p><p><strong>SoHandleEventAction</strong> * <strong>getHandleEventAction</strong> (void) const </p><p>void <strong>setHandleEventAction</strong> (<strong>SoHandleEventAction</strong> *newAction)</p><p>void <strong>setTempPathToThis</strong> (const <strong>SoPath</strong> *somethingclose)</p><p>virtual void <strong>grabEventsSetup</strong> (void)</p><p>virtual void <strong>grabEventsCleanup</strong> (void)</p><p>void <strong>workFieldsIntoTransform</strong> (<strong>SbMatrix</strong> &mtx)</p><p>void <strong>setFrontOnProjector</strong> (<strong>ProjectorFrontSetting</strong> newval)</p><p><strong>ProjectorFrontSetting</strong> <strong>getFrontOnProjector</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static const <strong>SoNodekitCatalog</strong> * <strong>getClassNodekitCatalog</strong> (void)</p><p>static void <strong>setMinScale</strong> (float newminscale)</p><p>static float <strong>getMinScale</strong> (void)</p><p>static void <strong>workValuesIntoTransform</strong> (<strong>SbMatrix</strong> &mtx, const <strong>SbVec3f</strong> *translationptr, const <strong>SbRotation</strong> *rotationptr, const <strong>SbVec3f</strong> *scalefactorptr, const <strong>SbRotation</strong> *scaleorientationptr, const <strong>SbVec3f</strong> *centerptr)</p><p>static void <strong>getTransformFast</strong> (<strong>SbMatrix</strong> &mtx, <strong>SbVec3f</strong> &translation, <strong>SbRotation</strong> &rotation, <strong>SbVec3f</strong> &scalefactor, <strong>SbRotation</strong> &scaleorientation, const <strong>SbVec3f</strong> &center)</p><p>static void <strong>getTransformFast</strong> (<strong>SbMatrix</strong> &mtx, <strong>SbVec3f</strong> &translation, <strong>SbRotation</strong> &rotation, <strong>SbVec3f</strong> &scalefactor, <strong>SbRotation</strong> &scaleorientation)</p><p>static <strong>SbMatrix</strong> <strong>appendTranslation</strong> (const <strong>SbMatrix</strong> &mtx, const <strong>SbVec3f</strong> &translation, const <strong>SbMatrix</strong> *conversion=NULL)</p><p>static <strong>SbMatrix</strong> <strong>appendScale</strong> (const <strong>SbMatrix</strong> &mtx, const <strong>SbVec3f</strong> &scale, const <strong>SbVec3f</strong> &scalecenter, const <strong>SbMatrix</strong> *conversion=NULL)</p><p>static <strong>SbMatrix</strong> <strong>appendRotation</strong> (const <strong>SbMatrix</strong> &mtx, const <strong>SbRotation</strong> &rot, const <strong>SbVec3f</strong> &rotcenter, const <strong>SbMatrix</strong> *conversion=NULL)</p><p>static void <strong>initClass</strong> (void)</p><p>static void <strong>initClasses</strong> (void)</p>
<h3>Public Attributes</h3>
<p><strong>SoSFBool</strong> <strong>isActive</strong></p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p><strong>SoDragger</strong> (void)</p><p>virtual <strong>~SoDragger</strong> (void)</p><p><strong>SbVec2f</strong> <strong>getNormalizedLocaterPosition</strong> (void)</p><p><strong>SbVec2s</strong> <strong>getLocaterPosition</strong> (void)</p><p><strong>SbVec2s</strong> <strong>getStartLocaterPosition</strong> (void) const </p><p>void <strong>setStartLocaterPosition</strong> (<strong>SbVec2s</strong> p)</p><p>SbBool <strong>isAdequateConstraintMotion</strong> (void)</p><p>virtual SbBool <strong>shouldGrabBasedOnSurrogate</strong> (const <strong>SoPath</strong> *pickpath, const <strong>SoPath</strong> *surrogatepath)</p><p>void <strong>setCameraInfo</strong> (<strong>SoAction</strong> *action)</p><p>virtual void <strong>handleEvent</strong> (<strong>SoHandleEventAction</strong> *ha)</p><p>void <strong>transferMotion</strong> (<strong>SoDragger</strong> *child)</p><p>void <strong>setIgnoreInBbox</strong> (SbBool newval)</p><p>SbBool <strong>isIgnoreInBbox</strong> (void)</p><p>virtual void <strong>getBoundingBox</strong> (<strong>SoGetBoundingBoxAction</strong> *action)</p><p>void <strong>setActiveChildDragger</strong> (<strong>SoDragger</strong> *newchilddragger)</p><p><strong>SoDragger</strong> * <strong>getActiveChildDragger</strong> (void) const </p><p>virtual void <strong>setDefaultOnNonWritingFields</strong> (void)</p><p>void <strong>updateDraggerCache</strong> (const <strong>SoPath</strong> *path)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p><p>static const <strong>SoNodekitCatalog</strong> ** <strong>getClassNodekitCatalogPtr</strong> (void)</p><p>static void <strong>childTransferMotionAndValueChangedCB</strong> (void *, <strong>SoDragger</strong> *)</p><p>static void <strong>childValueChangedCB</strong> (void *, <strong>SoDragger</strong> *)</p><p>static void <strong>childStartCB</strong> (void *, <strong>SoDragger</strong> *)</p><p>static void <strong>childMotionCB</strong> (void *, <strong>SoDragger</strong> *)</p><p>static void <strong>childFinishCB</strong> (void *, <strong>SoDragger</strong> *)</p><p>static void <strong>childOtherEventCB</strong> (void *, <strong>SoDragger</strong> *)</p>
<h3>Protected Attributes</h3>
<p><strong>SoSFNode</strong> <strong>motionMatrix</strong></p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoDragger</strong> class is the base class for all draggers.</p><p>Draggers is a mechanism used for letting the end-users of your application code interact with elements in 3D, by scaling, rotating or translating geometry or other instances in the scene (like cameras or lightsources).</p><p>For a very thorough introduction and tutorial to the dragger classes and general concepts, we advise you to consult «The Inventor Mentor», ISBN 0-201-62495-8, chapter 15.</p><p>This is the common superclass for all dragger classes.</p><p>It holds the current motion matrix, and offers lots of convenience methods to build from for it's subclasses -- that is, the non-abstract dragger classes to use as nodes in your scenegraph.</p><p>The motion matrix is used to modify the model matrix during traversal, and this is a common dragger mechanism -- all draggers should update this during dragging.</p><p>A number of the Coin dragger classes have built-in convenience wrapper classes, called <em>manipulators</em>. See for instance the <strong>SoTrackballDragger</strong> / <strong>SoTrackballManip</strong> pair.</p><p>The matching manipulator class for any dragger class has basically two convenient additions to the functionality of the stand-alone dragger: 1) it makes swapping the dragger in and out of the scenegraph very straightforward (something which is often done for draggers in 3D user interfaces), 2) it wraps up the dragger with <strong>SoSurroundScale</strong> and <strong>SoAntiSquish</strong> nodes where applicable, so the dragger geometry automatically scales up or down to match the geometry it influences.</p><p>This last functionality can also be duplicated in a rather straightforward manner outside of the context of a manipulator, as can be seen from the usage example in the <strong>SoSurroundScale</strong> class documentation.</p><p>The appearance of draggers can be modified by either using the <strong>SoDragger::setPart()</strong> method (see usage example below) or by setting up external Inventor-format files which the geometry parts are read from. The latter method can be done by setting the environment variable SO_DRAGGER_DIR<strong> to point to a directory with replacement geometry files. The name of the new files and the name of the nodes / sub-graphs with the replacement geometries must follow a rigid scheme. We advise you to look at the Coin sourcecode directory Coin/data/draggerDefaults/ to see how the replacement geometry files should be named. Setting SO_DRAGGER_DIR</strong> to this directory and modifying the files there provides a convenient way to play around with new dragger geometry arrangements.</p><p>As mentioned above, <strong>SoDragger::setPart()</strong> can be used to modify the appearance of a dragger by changing it's default geometry. One common technique is for instance to take advantage of this to use only <em>parts</em> of a dragger, by replacing / disabling the geometry that you don't want the end-user to interact with. The following code example shows how to remove the translation functionality of the <strong>SoTransformBoxDragger</strong>:</p>
<pre>
#include &lt;Inventor/Qt/SoQt.h&gt;
#include &lt;Inventor/Qt/viewers/SoQtExaminerViewer.h&gt;
#include &lt;Inventor/draggers/SoTransformBoxDragger.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;


int
main(int argc, char ** argv)
{
  QWidget * window = SoQt::init(argv[0]);

  SoTransformBoxDragger * dragger = new SoTransformBoxDragger;

  SbString str;
  for (int i = 1; i &lt;= 6; i++) {
    str.sprintf("translator%d.translator", i);
    dragger-&gt;setPart(str.getString(), new SoSeparator);
  }

  SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);
  viewer-&gt;setSceneGraph(dragger);
  viewer-&gt;show();
  SoQt::show(window);

  SoQt::mainLoop();

  delete viewer;
  return 0;
}
</pre>
<p>Draggers are also node kits, and below is the catalog structure for this top-level dragger class.</p><p>Node kit structure (new entries versus parent class marked with arrow prefix):</p>
<pre>
CLASS SoDragger
--&gt;"this"
      "callbackList"
      "topSeparator"
--&gt;      "motionMatrix"
         "geomSeparator"
</pre>
<p>(See <strong>SoBaseKit::printDiagram()</strong> for information about the output formatting.)</p><p>Detailed information on catalog parts:</p>
<pre>
CLASS SoDragger
PVT   "this",  SoDragger  ---
      "callbackList",  SoNodeKitListPart [ SoCallback, SoEventCallback ]
PVT   "topSeparator",  SoSeparator  ---
PVT   "motionMatrix",  SoMatrixTransform  ---
PVT   "geomSeparator",  SoSeparator  ---
</pre>
<p>(See <strong>SoBaseKit::printTable()</strong> for information about the output formatting.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoDragger::ProjectorFrontSetting\fP</h3>
<p>Holds various settings for projectors, which might affect cylindrical and spherical based draggers. Specifies whether dragging should be based on the front or back of the sphere / cylinder, or if the picked point should be used to decide this.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>FRONT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Always use front of projector.</p>
  </dd>
  <dt>
    <p><strong></strong><em>BACK </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Always use back of projector.</p>
  </dd>
  <dt>
    <p><strong></strong><em>USE_PICK </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use picked point to decide front or back of projector.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoDragger::SoDragger (void)\fC [protected]\fP</h3>
<p>A protected constructor for this abstract superclass for all Coin draggers.</p>
<h3>SoDragger::~SoDragger (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Virtual protected destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoDragger::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Reimplemented from <strong>SoInteractionKit</strong>.</p><p>Reimplemented in <strong>SoTrackballDragger</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTransformerDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTranslate1Dragger</strong>, <strong>SoTranslate2Dragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScaleUniformDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoPointLightDragger</strong>, and <strong>SoTabBoxDragger</strong>.</p>
<h3>const \fBSoFieldData\fP * SoDragger::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoInteractionKit</strong>.</p><p>Reimplemented in <strong>SoTrackballDragger</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTransformerDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTranslate1Dragger</strong>, <strong>SoTranslate2Dragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScaleUniformDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoPointLightDragger</strong>, and <strong>SoTabBoxDragger</strong>.</p>
<h3>const \fBSoNodekitCatalog\fP * SoDragger::getNodekitCatalog (void) const\fC [virtual]\fP</h3>
<p>Returns the nodekit catalog which defines the layout of this class' kit.</p><p>Reimplemented from <strong>SoInteractionKit</strong>.</p><p>Reimplemented in <strong>SoTrackballDragger</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTransformerDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTranslate1Dragger</strong>, <strong>SoTranslate2Dragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScaleUniformDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoPointLightDragger</strong>, and <strong>SoTabBoxDragger</strong>.</p>
<h3>void SoDragger::callback (\fBSoCallbackAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoCallbackAction</strong>.</p><p>Simply updates the state according to how the node behaves for the render action, so the application programmer can use the <strong>SoCallbackAction</strong> for extracting information about the scene graph.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>void SoDragger::GLRender (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGLRenderAction</strong>.</p><p>This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoTabPlaneDragger</strong>.</p>
<h3>void SoDragger::getMatrix (\fBSoGetMatrixAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoGetMatrixAction</strong>.</p><p>Updates <em>action</em> by accumulating with the transformation matrix of this node (if any).</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoCenterballDragger</strong>.</p>
<h3>void SoDragger::rayPick (\fBSoRayPickAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoRayPickAction</strong>.</p><p>Checks the ray specification of the <em>action</em> and tests for intersection with the data of the node.</p><p>Nodes influencing relevant state variables for how picking is done also overrides this method.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>void SoDragger::search (\fBSoSearchAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoSearchAction</strong>.</p><p>Compares the search criteria from the <em>action</em> to see if this node is a match. Searching is done by matching up <em>all</em> criteria set up in the <strong>SoSearchAction</strong> -- if <em>any</em> of the requested criteria is a miss, the search is not deemed successful for the node.</p><p><strong>See also:</strong></p><p><strong>SoSearchAction</strong></p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>void SoDragger::write (\fBSoWriteAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoWriteAction</strong>.</p><p>Writes out a node object, and any connected nodes, engines etc, if necessary.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>void SoDragger::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetPrimitiveCountAction</strong>.</p><p>Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the <em>action</em>.</p><p>Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>void SoDragger::setProjectorEpsilon (const floatepsilon)</h3>
<p>Sets the epsilon used for restricting the draggers when the intersection line is almost parallel with the projector direction.</p><p>For line projectors this is based on the dot product between the picking ray and the projector line. For plane projector, the dot product between the plane normal and the picking ray is used.</p><p>Default value is 0.0.</p><p><strong>Since:</strong></p><p>Coin 3.0</p>
<h3>void SoDragger::addStartCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Adds a callback which is called at the start of a drag, after the mouse button 1 is pressed, and dragger is picked.</p>
<h3>void SoDragger::removeStartCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Removes a previously registered start callback.</p><p><strong>See also:</strong></p><p><strong>addStartCallback()</strong></p>
<h3>void SoDragger::addMotionCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Adds a callback which is called for each mouse movement during dragging.</p>
<h3>void SoDragger::removeMotionCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Removes a previously registered motion callback.</p><p><strong>See also:</strong></p><p><strong>addMotionCallback()</strong></p>
<h3>void SoDragger::addFinishCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Adds a callback which is called after dragging is finished.</p>
<h3>void SoDragger::removeFinishCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Removes a finish callback.</p><p><strong>See also:</strong></p><p><strong>addFinishCallback()</strong></p>
<h3>void SoDragger::addValueChangedCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Adds a callback which is called after a dragger has changed a field. It is not called if the <strong>SoDragger::isActive</strong> field is changed.</p><p><strong>See also:</strong></p><p>enableValueChangedCallback()</p>
<h3>void SoDragger::removeValueChangedCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Removes a value changed callback.</p><p><strong>See also:</strong></p><p><strong>addValueChangedCallback()</strong></p>
<h3>void SoDragger::setMinGesture (intpixels)</h3>
<p>Sets the number of pixel movement needed to trigger a constraint gesture. Default is 8 pixels.</p>
<h3>int SoDragger::getMinGesture (void) const</h3>
<p>Returns the gesture pixels threshold value.</p><p><strong>See also:</strong></p><p><strong>setMinGesture()</strong></p>
<h3>SbBool SoDragger::enableValueChangedCallbacks (SbBoolval)</h3>
<p>Enable or disable 'value changed' callbacks.</p><p><strong>See also:</strong></p><p><strong>addValueChangedCallback()</strong></p>
<h3>const \fBSbMatrix\fP & SoDragger::getMotionMatrix (void)</h3>
<p>Returns the motion matrix for this dragger.</p>
<h3>void SoDragger::addOtherEventCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Adds an event callback for events other then drag events. As soon as dragging starts, the dragger grabs all events (until mouse button is released). This method can be used to handle other events during dragging.</p>
<h3>void SoDragger::removeOtherEventCallback (\fBSoDraggerCB\fP *func, void *data = \fCNULL\fP)</h3>
<p>Removes a other event callback.</p><p><strong>See also:</strong></p><p><strong>addOtherEventCallback()</strong></p>
<h3>void SoDragger::registerChildDragger (\fBSoDragger\fP *child)</h3>
<p>Should be called by compound draggers to register child draggers.</p>
<h3>void SoDragger::unregisterChildDragger (\fBSoDragger\fP *child)</h3>
<p>Should be called by compound draggers to unregister child draggers.</p>
<h3>void SoDragger::registerChildDraggerMovingIndependently (\fBSoDragger\fP *child)</h3>
<p>Should be called by compund draggers to register child draggers that should move independently of their parent.</p>
<h3>void SoDragger::unregisterChildDraggerMovingIndependently (\fBSoDragger\fP *child)</h3>
<p>Should be called by compund draggers to unregister child draggers.</p><p><strong>See also:</strong></p><p><strong>registerChildDraggerMovingIndependently()</strong></p>
<h3>\fBSbMatrix\fP SoDragger::getLocalToWorldMatrix (void)</h3>
<p>Returns a matrix that converts from local to world space.</p>
<h3>\fBSbMatrix\fP SoDragger::getWorldToLocalMatrix (void)</h3>
<p>Returns a matrix that converts from world to local space.</p>
<h3>\fBSbVec3f\fP SoDragger::getLocalStartingPoint (void)</h3>
<p>Returns the drag starting point in the local coordinate system.</p>
<h3>\fBSbVec3f\fP SoDragger::getWorldStartingPoint (void)</h3>
<p>Returns the drag starting point in the world coordinate system.</p>
<h3>void SoDragger::getPartToLocalMatrix (const \fBSbName\fP &partname, \fBSbMatrix\fP &parttolocalmatrix, \fBSbMatrix\fP &localtopartmatrix)</h3>
<p>Returns matrices that will convert between local space and the space in which <em>partname</em> lies in.</p>
<h3>void SoDragger::transformMatrixLocalToWorld (const \fBSbMatrix\fP &frommatrix, \fBSbMatrix\fP &tomatrix)</h3>
<p>Convenience method that transforms the local <em>frommatrix</em> to a world coordinate systems matrix.</p>
<h3>void SoDragger::transformMatrixWorldToLocal (const \fBSbMatrix\fP &frommatrix, \fBSbMatrix\fP &tomatrix)</h3>
<p>Convenience method that transforms the world <em>frommatrix</em> to a local coordinate systems matrix.</p>
<h3>void SoDragger::transformMatrixToLocalSpace (const \fBSbMatrix\fP &frommatrix, \fBSbMatrix\fP &tomatrix, const \fBSbName\fP &fromspacepartname)</h3>
<p>Transforms a matrix that lies in the <em>frompartname</em> coordinate system into the local coordinate system.</p>
<h3>void SoDragger::setMotionMatrix (const \fBSbMatrix\fP &matrix)\fC [virtual]\fP</h3>
<p>Sets a new current motion matrix for the dragger geometry.</p><p>Triggers value changed callbacks if <em>matrix</em> is unequal to the previous motion matrix.</p><p>Reimplemented in <strong>SoTranslate2Dragger</strong>, and <strong>SoTranslate1Dragger</strong>.</p>
<h3>void SoDragger::valueChanged (void)</h3>
<p>Can be called by subclasses to trigger value changed callbacks. This might be needed if a field is changed without changing the motion matrix.</p>
<h3>const \fBSbMatrix\fP & SoDragger::getStartMotionMatrix (void)</h3>
<p>Returns the motion matrix as it was when <strong>saveStartParameters()</strong> was called.</p>
<h3>void SoDragger::saveStartParameters (void)\fC [virtual]\fP</h3>
<p>This is invoked to save start parameters, to enable draggers to calculate relative motion.</p><p>Default method in superclass <strong>SoDragger</strong> just saves the motion matrix, but subclasses should overload this method if other data needs to be saved.</p><p>Reimplemented in <strong>SoCenterballDragger</strong>.</p>
<h3>const \fBSoPath\fP * SoDragger::getPickPath (void) const</h3>
<p>Returns the picked path.</p>
<h3>const \fBSoEvent\fP * SoDragger::getEvent (void) const</h3>
<p>Returns the current event.</p>
<h3>\fBSoPath\fP * SoDragger::createPathToThis (void)</h3>
<p>Creates a new path to this dragger. Don't forget to <strong>ref()</strong> and <strong>unref()</strong> since this method creates a fresh copy for you.</p>
<h3>const \fBSoPath\fP * SoDragger::getSurrogatePartPickedOwner (void) const</h3>
<p>Returns the path to the <strong>SoInteractionKit</strong> that holds the current surrogate path.</p>
<h3>const \fBSbName\fP & SoDragger::getSurrogatePartPickedName (void) const</h3>
<p>Returns the name of the path in the <strong>SoInteractionKit</strong> that holds the current surrogate path.</p>
<h3>const \fBSoPath\fP * SoDragger::getSurrogatePartPickedPath (void) const</h3>
<p>Returns the current surrogate path.</p>
<h3>void SoDragger::setStartingPoint (const \fBSoPickedPoint\fP *point)</h3>
<p>Sets the staring point for the drag. <em>point</em> is usually a picked point from a <strong>SoRayPickAction</strong>.</p>
<h3>void SoDragger::setStartingPoint (const \fBSbVec3f\fP &point)</h3>
<p>Sets the starting point for a drag.</p>
<h3>const \fBSbViewVolume\fP & SoDragger::getViewVolume (void)</h3>
<p>Return the current view volume.</p>
<h3>void SoDragger::setViewVolume (const \fBSbViewVolume\fP &vv)</h3>
<p>Sets the current view volume.</p>
<h3>const \fBSbViewportRegion\fP & SoDragger::getViewportRegion (void)</h3>
<p>Returns the current viewport region.</p>
<h3>void SoDragger::setViewportRegion (const \fBSbViewportRegion\fP &vp)</h3>
<p>Sets the current viewport region.</p>
<h3>\fBSoHandleEventAction\fP * SoDragger::getHandleEventAction (void) const</h3>
<p>Return the current (most recent) <strong>SoHandleEventAction</strong>.</p>
<h3>void SoDragger::setHandleEventAction (\fBSoHandleEventAction\fP *action)</h3>
<p>Stores a handle event action.</p>
<h3>void SoDragger::setTempPathToThis (const \fBSoPath\fP *somethingclose)</h3>
<p>This function is part of the original SGI Inventor 2.1 API, but has not been implemented in Coin as it looks like a function which should probably have been private in Open Inventor.</p>
<h3>void SoDragger::grabEventsSetup (void)\fC [virtual]\fP</h3>
<p>Called when dragger starts grabbing events (mouse button down). Overload if you need to do something extra in your dragger.</p><p><strong>See also:</strong></p><p>grabEventCleanup()</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoDragger::grabEventsCleanup (void)\fC [virtual]\fP</h3>
<p>Called when dragger stops grabbing events (mouse button up).</p><p><strong>See also:</strong></p><p>grabEventSetup()</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoDragger::workFieldsIntoTransform (\fBSbMatrix\fP &matrix)</h3>
<p>Examines the fields of the dragger, changes the matrix according to those fields and leaves the rest of the matrix as it was. The following field names are supported: translation, scaleFactor, rotation and scaleOrientation.</p>
<h3>void SoDragger::setFrontOnProjector (\fBProjectorFrontSetting\fPval)</h3>
<p>Controls the behaviour of the <strong>SbProjector</strong>.</p>
<h3>\fBSoDragger::ProjectorFrontSetting\fP SoDragger::getFrontOnProjector (void) const</h3>
<p>Returns the behaviour of the <strong>SbProjector</strong>.</p>
<h3>void SoDragger::setMinScale (floatminscalearg)\fC [static]\fP</h3>
<p>Sets the minimum scale value all scale factors are clamped against. This is used in <strong>workFieldsIntoTransform()</strong>. The default value is 0.01</p>
<h3>float SoDragger::getMinScale (void)\fC [static]\fP</h3>
<p>Returns the minimum scale value.</p><p><strong>See also:</strong></p><p><strong>setMinScale()</strong></p>
<h3>void SoDragger::workValuesIntoTransform (\fBSbMatrix\fP &matrix, const \fBSbVec3f\fP *translationptr, const \fBSbRotation\fP *rotationptr, const \fBSbVec3f\fP *scalefactorptr, const \fBSbRotation\fP *scaleorientationptr, const \fBSbVec3f\fP *centerptr)\fC [static]\fP</h3>
<p>Same as above, but pointers to values are supplied. If a pointer is NULL, the matrix value for that argument is used when reconstructing the matrix.</p>
<h3>void SoDragger::getTransformFast (\fBSbMatrix\fP &matrix, \fBSbVec3f\fP &translation, \fBSbRotation\fP &rotation, \fBSbVec3f\fP &scalefactor, \fBSbRotation\fP &scaleorientation, const \fBSbVec3f\fP &center)\fC [static]\fP</h3>
<p>Can be used when there is no scaleorientation. Faster than <strong>SoDragger::workValuesIntoTransform()</strong>.</p>
<h3>void SoDragger::getTransformFast (\fBSbMatrix\fP &matrix, \fBSbVec3f\fP &translation, \fBSbRotation\fP &rotation, \fBSbVec3f\fP &scalefactor, \fBSbRotation\fP &scaleorientation)\fC [static]\fP</h3>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<h3>\fBSbMatrix\fP SoDragger::appendTranslation (const \fBSbMatrix\fP &matrix, const \fBSbVec3f\fP &translation, const \fBSbMatrix\fP *conversion = \fCNULL\fP)\fC [static]\fP</h3>
<p>Returns <em>matrix</em> after <em>translation</em> has been appended. If <em>conversion</em> != NULL<em> it is used to transform </em><em>translation</em><em> into the space </em><em>matrix</em><em> is defined.</em></p>
<h3>\fBSbMatrix\fP SoDragger::appendScale (const \fBSbMatrix\fP &matrix, const \fBSbVec3f\fP &scale, const \fBSbVec3f\fP &scalecenter, const \fBSbMatrix\fP *conversion = \fCNULL\fP)\fC [static]\fP</h3>
<p>Returns <em>matrix</em> after <em>scale</em> and <em>scalecenter</em> has been appended. If <em>conversion</em> != NULL<em> it is used to transform scale into the space </em><em>matrix</em><em> is defined.</em></p>
<h3>\fBSbMatrix\fP SoDragger::appendRotation (const \fBSbMatrix\fP &matrix, const \fBSbRotation\fP &rot, const \fBSbVec3f\fP &rotcenter, const \fBSbMatrix\fP *conversion = \fCNULL\fP)\fC [static]\fP</h3>
<p>Appends <em>rot</em>, around <em>rotcenter</em>, to <em>matrix</em>. If <em>conversion</em> is != NULL<em>, this is used to move the rotation into that coordinate systems before appending the rotation.</em></p>
<h3>void SoDragger::initClass (void)\fC [static]\fP</h3>
<p>Initializes type system for this dragger class.</p><p>Application programmers should usually not have to invoke this method, see documentation of <strong>SoInteraction::init()</strong>.</p>
<h3>void SoDragger::initClasses (void)\fC [static]\fP</h3>
<p>Initializes all built-in draggers.</p>
<h3>\fBSbVec2f\fP SoDragger::getNormalizedLocaterPosition (void)\fC [protected]\fP</h3>
<p>Returns the position of the locater.</p>
<h3>\fBSbVec2s\fP SoDragger::getLocaterPosition (void)\fC [protected]\fP</h3>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<h3>\fBSbVec2s\fP SoDragger::getStartLocaterPosition (void) const\fC [protected]\fP</h3>
<p>Returns the position when mouse button 1 was pressed.</p>
<h3>void SoDragger::setStartLocaterPosition (\fBSbVec2s\fPpos)\fC [protected]\fP</h3>
<p>The start locater position is automatically set when mouse button 1 goes down, but subclasses can use this method to reset the value.</p>
<h3>SbBool SoDragger::isAdequateConstraintMotion (void)\fC [protected]\fP</h3>
<p>Checks if the mouse pointer has been moved enough after the end-user hit a constraint mode key (which is typically SHIFT, sometimes also CTRL for the built-in draggers) that we should act upon and decide which direction the constraint should be set to.</p>
<h3>SbBool SoDragger::shouldGrabBasedOnSurrogate (const \fBSoPath\fP *pickpath, const \fBSoPath\fP *surrogatepath)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Checks if <em>pickpath</em> contains <em>surrogatepath</em> and returns TRUE<em> if the tail of </em><em>surrogatepath</em><em> is before any dragger in </em><em>pickpath</em><em>.</em></p>
<h3>void SoDragger::setCameraInfo (\fBSoAction\fP *action)\fC [protected]\fP</h3>
<p>Store data about the current camera in the given action.</p>
<h3>void SoDragger::handleEvent (\fBSoHandleEventAction\fP *action)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Action method for <strong>SoHandleEventAction</strong>.</p><p>Inspects the event data from <em>action</em>, and processes it if it is something which this node should react to.</p><p>Nodes influencing relevant state variables for how event handling is done also overrides this method.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p>
<h3>void SoDragger::transferMotion (\fBSoDragger\fP *child)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDragger::setIgnoreInBbox (SbBoolval)\fC [protected]\fP</h3>
<p>Sets whether dragger geometry should be ignored when calculating bbox.</p>
<h3>SbBool SoDragger::isIgnoreInBbox (void)\fC [protected]\fP</h3>
<p>Returns whether dragger geometry should be ignored when calculating bbox.</p>
<h3>void SoDragger::getBoundingBox (\fBSoGetBoundingBoxAction\fP *action)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetBoundingBoxAction</strong>.</p><p>Calculates bounding box and center coordinates for node and modifies the values of the <em>action</em> to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node.</p><p>Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables.</p><p>Reimplemented from <strong>SoBaseKit</strong>.</p><p>Reimplemented in <strong>SoCenterballDragger</strong>.</p>
<h3>void SoDragger::setActiveChildDragger (\fBSoDragger\fP *childdragger)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoDragger\fP * SoDragger::getActiveChildDragger (void) const\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDragger::setDefaultOnNonWritingFields (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>(Be aware that this method is unlikely to be of interest to the application programmer who does not want to extend the library with new custom nodekits or draggers. If you indeed <em>are</em> writing extensions, see the information in the <strong>SoBaseKit</strong> class documentation.)</p><p>This is a virtual method, and the code in it should call <strong>SoField::setDefault()</strong> with argument TRUE<strong> on part fields that should not be written upon scenegraph export operations.</strong></p><p>This is typically done when:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>field value is NULL and part is NULL by default</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    2.
  </dt>
  <dd>
    <p>it is a leaf <strong>SoGroup</strong> or <strong>SoSeparator</strong> node with no children</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    3.
  </dt>
  <dd>
    <p>it is a leaf listpart with no children and an <strong>SoGroup</strong> or <strong>SoSeparator</strong> container</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    4.
  </dt>
  <dd>
    <p>it is a non-leaf part and it's of <strong>SoGroup</strong> type and all fields are at their default values</p>
  </dd>

</dl>
<p>Subclasses should usually override this to do additional settings for new member fields. From the subclass, do remember to call 'upwards' to your superclass' <strong>setDefaultOnNonWritingFields()</strong> method.</p><p>Reimplemented from <strong>SoInteractionKit</strong>.</p><p>Reimplemented in <strong>SoTransformerDragger</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoDragPointDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoTrackballDragger</strong>, <strong>SoCenterballDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTabBoxDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, and <strong>SoPointLightDragger</strong>.</p>
<h3>void SoDragger::childTransferMotionAndValueChangedCB (void *data, \fBSoDragger\fP *child)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDragger::childValueChangedCB (void *, \fBSoDragger\fP *)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDragger::childStartCB (void *data, \fBSoDragger\fP *child)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDragger::childMotionCB (void *, \fBSoDragger\fP *)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDragger::childFinishCB (void *, \fBSoDragger\fP *)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDragger::childOtherEventCB (void *data, \fBSoDragger\fP *child)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDragger::updateDraggerCache (const \fBSoPath\fP *path)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoSFBool\fP SoDragger::isActive</h3>
<p>Is TRUE whenever the user is interacting with the dragger. For compound draggers (draggers consisting of one or more subdraggers), the isActive field is updated only for the active subdragger, not for the compound dragger.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoDragPointDragger.3.html"><span aria-hidden="true">&larr;</span> SoDragPointDragger.3: The sodragpointdragger class provides mechanisms for moving a point in 3d.  here's how the dragger looks with its default geometry in the inactive state:</a></li>
   <li class="next"><a href="SoDragger.h.3.html">SoDragger.h.3: Sodragger.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

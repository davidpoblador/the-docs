<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mail::Bulkmail: Platform independent mailing list module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Platform independent mailing list module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Mail::Bulkmail (3pm) manual">
  <meta name="twitter:description" content="Platform independent mailing list module">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmail-bulkmail-perl-Mail::Bulkmail-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Mail::Bulkmail.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Mail::Bulkmail (3pm) manual" />
  <meta property="og:description" content="Platform independent mailing list module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmail-bulkmail-perl-Mail::Bulkmail-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Mail::Bulkmail<small> (3pm)</small></h1>
        <p class="lead">Platform independent mailing list module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::Bulkmail.3pm.html">
      <span itemprop="name">Mail::Bulkmail: Platform independent mailing list module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmail-bulkmail-perl/">
      <span itemprop="name">libmail-bulkmail-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::Bulkmail.3pm.html">
      <span itemprop="name">Mail::Bulkmail: Platform independent mailing list module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Jim Thomason, jim@jimandkoka.com (http://www.jimandkoka.com)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Mail::Bulkmail /path/to/conf.file
</pre>
<p> my $bulk = Mail::Bulkmail-&gt;new(         "LIST"          =&gt; "~/my.list.txt",         "From"          =&gt; &apos;"Jim Thomason"&lt;jim@jimandkoka.com&gt;&apos;,         "Subject"       =&gt; "This is a test message",         "Message"       =&gt; "Here is my test message"  ) || die Mail::Bulkmail-&gt;error();</p><p> $bulk-&gt;bulkmail() || die $bulk-&gt;error;</p><p>Don't forget to set up your conf file!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Mail::Bulkmail gives a fairly complete set of tools for managing mass-mailing lists. I initially wrote it because the tools I was using at the time were just too damn slow for mailing out to thousands of recipients. I keep working on it because it's reasonably popular and I enjoy it.</p><p>In a nutshell, it allows you to rapidly transmit a message to a mailing list by zipping out the information to them via an \s-1SMTP\s0 relay (your own, of course). Subclasses provide the ability to use mail merges, dynamic messages, and anything else you can think of.</p><p>Mail::Bulkmail 3.00 is a major major <strong>major</strong> upgrade to the previous version (2.05), which was a major upgrade to the previous version (1.11). My software philosophy is that most code should be scrapped and re-written every 6-8 months or so. 2.05 was released in October of 2000, and I'm writing these docs for 3.00 in January of 2003. So I'm at least 3 major re-writes behind. (philosophy is referenced in the \s-1FAQ\s0, below)</p><p>But that's okay, because we're getting it done now.</p><p>3.00 is about as backwards compatible to 2.00 as 2.00 is to 1.00. That is to say, sorta. I've tried to make a note of things where they changed, but I'm sure I missed things. Some things can no longer be done, lots are done differently, some are the same. You will need to change your code to update from 1.x or 2.x to 3.00, though. That's a given.</p><p>So what's new for 3.00? Lots of stuff.</p><p>Immediate changes are:</p><p> * code compartmentalization  * multi-server support  * conf file</p><p>The immediate change is that the code is now compartmentalized. Mail::Bulkmail now just handles ordinary, non-dynamic mailings. See Mail::Bulkmail::Dynamic for the merging and dynamic text abilities from the prior versions.</p><p>Server connections are no longer handled directly in Mail::Bulkmail (Smtp attribute, Port attribute, etc.), there is now a separate Mail::Bulkmail::Server object to handle all of that.</p><p>And everything subclasses off of Mail::Bulkmail::Object, where I have my super-methods to define my objects, some helper stuff, and so on.</p><p>It's just a lot easier for me to maintain, think about it, etc. if it's all separated. It's also easier for you, the user, if you want to make changes to things. Just subclass it, tweak it, and use it. Very straightforward to modify and extend now. 2.x and below *could* do it, but it wasn't really that easy (unless you were making very trivial changes). This should rectify that.</p><p>Another major change is the addition of multi-server support. See the docs in Mail::Bulkmail::Server for more information. You can still specify one \s-1SMTP\s0 relay if that's all you've got, but if you have multiple servers, Mail::Bulkmail can now load balance between them to help take the stress off. No matter what, the biggest bottleneck to all of this is network performance (both to the \s-1SMTP\s0 relay and then from the relay to the rest of the world), so i wanted to try and help alleviate that by using multiple servers. I know that some people were doing that on there own with small changes, but this allows you to do it all invisibly.</p><p>And finally, finally, finally there is a conf file. Documentation on the format is in Mail::Bulkmail::Object. It's pretty easy to use. This is the conf file format that I designed for my own use (along with most of the rest of Mail::Bulkmail::Object). The software also has the ability to read multiple conf files, if so desired. So no more worrying about asking your sysadmin to tweak the values in your module somewhere up in /usr/lib/whatever</p><p>Just have him create the conf file you want, or pass in your own as desired.</p><p>conf_files are specified and further documented in Mail::Bulkmail::Object, in an internal array called @conf_files, right at the top of the module. To specify a universal conf file, put it in that array (or have your sysadmin do so). Alternatively, you can also add a conf_file via the conf_files accessor.</p><p> Mail::Bulkmail-&gt;conf_files(&apos;/path/to/conf_file&apos;, &apos;/path/to/other/conf_file&apos;);  #, etc.</p><p>But the recommended way is to specify your conf file upon module import.</p><p> use Mail::Bulkmail 3.00 "/path/to/conf/file";</p><p>In addition, there is the usual plethora of bug fixes, tweaks, clean-ups, and so on.</p><p>And yes, the horrid long-standing bug in the Tz method is <strong>fixed!</strong> No, honest.</p><p>I'm also trying a new documentation technique. The pod for a given method is now in the module by that method, as opposed to everything being bunched up at the bottom. Personally, I prefer everything being bunched up there for clarities sake. But from a maintenance point of view, spreading it all out makes my life much easier.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">requires</h2>
        <div class="sectioncontent">
<p> Perl 5.6.0, Socket  (It probaly can get by with less than 5.6.0, but I haven&apos;t tested it in such an environment)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ATTRIBUTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    From
  </dt>
  <dd>
    <p>Stores the From address of this mailing. Must be a valid email address, unless Trusting is set. Really really should be a valid email address anyway. From is no longer used as the Sender, as was the behavior in prior versions. Now, Mail::Bulkmail first tries to use the Sender as the Sender, and failing that, falls back on the from.  $bulk-&gt;From(&apos;"Jim Thomason"&lt;jim@jimandkoka.com&gt;&apos;);  print $bulk-&gt;From;</p>
  </dd>
  <dt>
    To
  </dt>
  <dd>
    <p>Stores the To address of this mailing. Must be a valid email address, unless Trusting is set. Really should be a valid email address anyway. To is used if you have use_envelope set to 1. See use_envelope, below. If you are not using the envelope, then the actual email address that we are currently on is used instead and -&gt;To is never used at all.  $bulk-&gt;To(&apos;jimslist:;&apos;);  print $bulk-&gt;To; As of 3.00, -&gt;To may contain either a valid email address or a valid group definition. A group definition is as follows (pseudo-regex):  Groupname:(address(,address)*)?; i.e., \*(L"the group name\*(R", then a colon, then an optional list of email addresses, then a semi-colon  $bulk-&gt;To(&apos;jim@jimandkoka.com&apos;);  $bulk-&gt;To(&apos;MyList:jim@jimandkoka.com&apos;);  $bulk-&gt;To(&apos;MyList:;&apos;); Are all valid addresses. Only the -&gt;To attribute may accept group syntax emails</p>
  </dd>
  <dt>
    Sender
  </dt>
  <dd>
    <p>Stores the Sender address of this mailing. Must be a valid email address, unless Trusting is set. Really really should be a valid email address anyway. Sender is mainly used when speaking \s-1SMTP\s0 to the server, specifically in the \s-1RCPT\s0 \s-1TO\s0 command. The spec defines \*(L"Sender\*(R" as \*(L"he who send the message\*(R" (paraphrasing), which may not actually be who the message is from. 2.00 used the From address as the Sender. You should specify this, but if you don't then the From value is assumed to be the sender.  $bulk-&gt;Sender(&apos;jim@jimandkoka.com&apos;);  print $bulk-&gt;Sender; If this value is not set, then Mail::Bulkmail <strong>will</strong> place a Sender header equal to the From value. Note that the ultimate receiving \s-1SMTP\s0 server is expected to place a Return-Path header in the message. This Return-Path value will be set to the value of the sender of the message, either -&gt;Sender or -&gt;From. This, in turn, will be the address that bounce backs go to. You should not set a Return-Path header yourself, because bad things will result.</p>
  </dd>
  <dt>
    ReplyTo
  </dt>
  <dd>
    <p>Stores the Reply-To address of this mailing. Must be a valid email address, unless Trusting is set. Really really should be a valid email address anyway. Reply-To is used as the address that the user's email client should reply to, if present. If this value is not set, then Mail::Bulkmail <strong>will</strong> place a Reply-To header equal to the From value. Note that even though the attribute is \*(L"ReplyTo\*(R", the header set is \*(L"Reply-To\*(R"  $bulk-&gt;ReplyTo(&apos;jim@jimandkoka.com&apos;);  print $bulk-&gt;ReplyTo;</p>
  </dd>
  <dt>
    Subject
  </dt>
  <dd>
    <p>Boring old accessor that stores the subject of the message. It's really recommended that this is set either at your object or in the conf file, otherwise you'll send out a mailing list with no subject which will probably be ignored.  $bulk-&gt;Subject("This is the list you signed up for");  print $bulk-&gt;Subject;</p>
  </dd>
  <dt>
    \s-1HTML\s0
  </dt>
  <dd>
    <p>Boolean flag. 1/0 only. A lot of people, though obviously not you, because you're reading the pod, just couldn't figure out how to send \s-1HTML\s0 messages. It's easy.  $bulk-&gt;header("Content-type", "text/html"); But it was just too hard for most people. So I added this flag. Here's the order:  Check and see if -&gt;header("Content-type") is set, if so then send it.  Otherwise, check and see if -&gt;HTML is true, if so, then send a content-type of text/html    i.e., an HTML message  Otherwise, send a content-type of text/plain    i.e., a plaintext message  $bulk-&gt;<strong>HTML</strong>(1);  print $bulk-&gt;HTML();</p>
  </dd>
  <dt>
    use_envelope
  </dt>
  <dd>
    <p>Boolean flag. 1/0 only. use_envelope was the coolest thing I added to Bulkmail 2.00, and is arguably still the best thing I've got here in terms of raw power in your lists. Basically, it's like lasing a stick of dynamite. Mail::Bulkmail is fast. Mail::Bulkmail with use_envelope is mind-numbingly fast. For the uninformed, an email message contains two parts, the message itself and the envelope.   Mail servers only care about the envelope (for the most part), since that's where they find out who the message is to and from, and they don't really need to know anything else. A nifty feature of the envelope is that you can submit multiple addresses within the envelope, and then your mail server will automagically send along the message to everyone contained within the envelope.  You end up sending a hell of a lot less data across your connection, your \s-1SMTP\s0 server has less work to do, and everything ends up working out wonderfully. There are two catches.  First of all, with envelope sending turned off, the recipient will have their own email address in the \*(L"To\*(R" field (To: jim@jimandkoka.com, fer instance).  With the envelope on, the recipient will only receive a generic email address (\*(L"To: list@myserver.com\*(R", fer instance)  Most people don't care since that's how most email lists work, but you should be aware of it. Secondly, you <strong>\s-1MUST\s0</strong> and I mean <strong>\s-1MUST\s0</strong> sort your list by domain.  Envelopes can only be bundled up by domain, so that we send all email to a domain in one burst, all of the email to another domain in the next burst, and so on.  So you need to have all of your domains clustered together in your list.  If you don't, your list will still go out, but it will be a <strong>lot</strong> slower, since Mail::Bulkmail has a fair amount more processing to do when you send with then envelope.  This is normally more than offset by the gains received from sending fewer messages.  But with an unsorted list, you never see the big gains and you see a major slow down.  Sort your lists.  $bulk-&gt;<strong>use_envelope</strong>(0);  print $bulk-&gt;use_envelope;</p>
  </dd>
  <dt>
    force80
  </dt>
  <dd>
    <p>Boolean flag 1/0 \s-1RFC\s0 2822 recommends that all messages have no more than 80 characters in a line (78 + \s-1CRLF\s0), but doesn't require it. if force80 is 1, then it will force a message to have only 80 characters per line. It will try to insert carriage returns between word boundaries, but if it can't, then it will cut words in half to force the limit. Regardless of force80, be warned that \s-1RFC\s0 2822 mandates that messages must have no more than 1000 characters per line (998 + \s-1CRLF\s0), and that wrapping will be done no matter what. Again, it will try to wrap at word boundaries, but if it can't, it will cut words in half to force the limit. It is recommended that you just have your message with at most 78 characters + \s-1CRLF\s0 for happiness' sake, and <strong>definitely</strong> at most 998 characters + \s-1CRLF\s0. You may end up with extra CRLFs in your message that you weren't expecting. If your message is not guaranteed to have only &lt; 78 characters + \s-1CRLF\s0 per line, then it's recommended to have force80 on for full compatibility. Note that force80 will be overridden by -&gt;Trusting('wrapping');</p>
  </dd>
  <dt>
    servers
  </dt>
  <dd>
    <p>arrayref of servers. Okay, this is the first major change between 2.x and 3.x. 2.x had methods to connect to one server (-&gt;Smtp, -&gt;Port, etc.). 3.x doesn't have those, and the relevent things are now in Mail::Bulkmail::Server, instead it has a list of servers. servers should contain an arrayref of server objects. You can either create them externally yourself and pass them in in an arrayref,  $bulk-&gt;servers([&#92;$server, &#92;$server2, &#92;$server3]); or you can create them in your conf file. See the Mail::Bulkmail::Object for more info on the format of the conf file, and Mail::Bulkmail::Server for the attributes to specify. servers will automatically be populated with a list of all servers in the server_list in the conf file if you don't specify anything, so you really don't need to worry about it. If you'd rather use a different server_file, then pass the server_file flag to the constructor:  $bulk = Mail::Bulkmail-&gt;new(         &apos;server_file&apos; =&gt; &apos;/path/to/server_file&apos;  ); That will <strong>override and ignore</strong> the server_file in <strong>any</strong> conf file, so use it with caution. Realistically, though, just let the program populate in the values of the servers you specified in the conf file and don't worry about this. Be warned that servers will be populated by the constructor if you do not populate servers at object creation. You may still change servers later (before you begin mailing), but there is the slight performance hit to initialize all of the server objects and then throw them away. This doesn't affect mailing speed in anyway, it'll just take a little longer to get started than it should.</p>
  </dd>
  <dt>
    Message
  </dt>
  <dd>
    <p>This stores the message that you will send out to the recipients of your list.  $bulk-&gt;Message(&apos;Hi there. You&apos;re on my mailing list&apos;);  print $bulk-&gt;Message; Don't put any headers in your Message, since they won't be transmitted as headers. Instead they will show up in the body of your message text. Use the -&gt;header method instead for additional headers This mutator is known to be able to return:  MB020 - could not open file for message  MB021 - could not close file for message  MB022 - invalid headers from message</p>
  </dd>
  <dt>
    message_from_file
  </dt>
  <dd>
    <p>boolean flag. 1/0 only. message_from_file allows you to load your message in from a file. If message_from_file is set to 1, then the value passed to -&gt;<em>Message()</em> will be assumed to be a path to a file on disk. That file will be openned in read mode (if possible), read in, and stored as your message. Note that your entire message text will be read into memory - no matter how large the message may be. This is simply a shortcut so that you don't have to open and read in the message yourself. <strong>\s-1NOTE\s0</strong> This is a bit picky, to put it mildly. No doubt you've read that the constructor actually is taking in its arguments in an array, not a hash. So they're parsed in order, which means you need pass in message_from_file <strong>before</strong> Message. i.e., this will work:  $bulk = Mail::Bulkmail-&gt;new(         &apos;message_from_file&apos; =&gt; 1,         &apos;Message&apos;                       =&gt; &apos;/path/to/message.txt&apos;,  ); But this will not:  $bulk = Mail::Bulkmail-&gt;new(         &apos;Message&apos;                       =&gt; &apos;/path/to/message.txt&apos;,         &apos;message_from_file&apos; =&gt; 1,  ); Ditto for using the mutators. Turn on the flag, i&lt;then&gt; specify the Message.</p>
  </dd>
  <dt>
    headers_from_message
  </dt>
  <dd>
    <p>boolean flag. 1/0 only. headers_from_message allows you to specify mail headers inside your message body. You may still specify additional headers in the traditional manner. Note that if you change the value of -&gt;Message (not recommended, but there are times you may want to do so), then any headers that were previously set via headers_from_message will be <strong>wiped out</strong>. any headers specified in the message will be set when you call -&gt;Message.</p>
  </dd>
  <dt>
    \s-1LIST\s0
  </dt>
  <dd>
    <p>\s-1LIST\s0 stores the list of addresses you're going to mail out to. \s-1LIST\s0 may be either a coderef, globref, arrayref, or string literal. If a string literal, then Mail::Bulkmail will attempt to open that file as your list:  $bulk-&gt;LIST("/path/to/my/list"); If a globref, it is assumed to be an open filehandle:  open (L, "/path/to/my/list");  $bulk-&gt;LIST(&#92;*L); if a coderef, it is assumed to be a function to return your list, or undef when it is done:  sub L {return $listquery-&gt;execute()};  #or whatever your code is  $bulk-&gt;LIST(&#92;&L); The coderef will receive the bulkmail object itself as an argument. if an arrayref, it is assumed to be an array containing your list:  my $list = [qw(jim@jimandkoka.com thomasoniii@yahoo.com)];  $bulk-&gt;LIST($list); Use whichever item is most convenient, and Mail::Bulkmail will take it from there.</p>
  </dd>
  <dt>
    \s-1BAD\s0
  </dt>
  <dd>
    <p>This is an optional log file to keep track of the bad addresses you have, i.e. banned, invalid, or duplicates. \s-1BAD\s0 may be either a coderef, globref, arrayref, or string literal. If a string literal, then Mail::Bulkmail will attempt to open that file (in append mode) as your log:  $bulk-&gt;BAD("/path/to/my/bad.addresses"); If a globref, it is assumed to be an open filehandle in append mode:  open (B, "&gt;&gt;/path/to/my/bad.addresses");  $bulk-&gt;BAD(&#92;*L); if a coderef, it is assumed to be a function to call with the address as an argument:  sub B { print "BAD ADDRESS : ", $_[1], "&#92;n"};  #or whatever your code is  $bulk-&gt;BAD(&#92;&B); The coderef will receive two arguments. The first is the bulkmail object itself, and the second is the data in the form that it was returned from the \s-1LIST\s0 attribute. if an arrayref, then bad addresses will be pushed on to the end of it  $bulk-&gt;BAD(&#92;@bad); Use whichever item is most convenient, and Mail::Bulkmail will take it from there.</p>
  </dd>
  <dt>
    \s-1GOOD\s0
  </dt>
  <dd>
    <p>This is an optional log file to keep track of the good addresses you have, i.e. the ones that Mail::Bulkmail could successfully transmit to the server. Note that there is no guarantee that an email address in the \s-1GOOD\s0 file actually received your mailing - it could have failed at a later point when out of Mail::Bulkmail's control. \s-1GOOD\s0 may be either a coderef, globref, arrayref, or string literal. If a string literal, then Mail::Bulkmail will attempt to open that file (in append mode) as your log:  $bulk-&gt;GOOD("/path/to/my/good.addresses"); If a globref, it is assumed to be an open filehandle in append mode:  open (B, "&gt;&gt;/path/to/my/good.addresses");  $bulk-&gt;GOOD(&#92;*B); if a coderef, it is assumed to be a function to call with the address as an argument:  sub G { print "GOOD ADDRESS : ", $_[1], "&#92;n"}; #or whatever your code is  $bulk-&gt;GOOD(&#92;&G); The coderef will receive two arguments. The first is the bulkmail object itself, and the second is the data in the form that it was returned from the \s-1LIST\s0 attribute. if an arrayref, then bad addresses will be pushed on to the end of it  $bulk-&gt;GOOD(&#92;@good); Use whichever item is most convenient, and Mail::Bulkmail will take it from there. Please note that -&gt;\s-1GOOD\s0 only says that the address was initially accepted for delivery. It could later fail while transmitting the email address, or it could be an valid but non-existent address that bounces later. It is up to the end user to inspect your error logs to make sure no errors occurred, and look for (and weed out) bounces or other failures later.</p>
  </dd>
  <dt>
    server_class
  </dt>
  <dd>
    <p>server_class is a class method that <strong>\s-1MUST\s0</strong> be specified in the conf file. You can initialize it in your program if you really want, but it is <strong>strongly</strong> recommended to be in the conf file so you don't forget it. server_class is used by the constructor to create the server list to populate into -&gt;servers, -&gt;servers is not populated in the constructor. By default, this should probably be Mail::Bulkmail::Server, to allow mailing. Another useful value is Mail::Bulkmail::Dummy See Mail::Bulkmail::Server and Mail::Bulkmail::Dummy for more information on how to create those objects. Also, if you write your own server implementation, this would be where you'd hook it into Mail::Bulkmail</p>
  </dd>
  <dt>
    Trusting
  </dt>
  <dd>
    <p>Trusting specifies your Trusting level. Mail::Bulkmail 3.00 will do its best to make sure that your email addresses are valid and that your message conforms to \s-1RFC\s0 2822. But, there is a slight performance hit to doing that - it does have to check things, do regexes, and so on. It's not very slow, but extrapolated over a huge list, it can be noticeable. So that's where Trusting comes in to play. If you set a Trusting value, then certain tests will be skipped. <strong>Use this at your</strong> own risk. If you tell Mail::Bulkmail to be Trusting, then it won't verify addresses or to make sure your list is under 1,000 characters per line. So if you're Trusting and you pass in bad data, it's your funeral. If there is <strong>any</strong> chance of invalid data, then don't be Trusting. If you're *positive* there's nothing wrong, then you may be Trusting. Trusting values are set one as key/value pairs.  $bulk-&gt;Trusting("email" =&gt; 1);  $bulk-&gt;Trusting("wrapping" =&gt; 1);  $bulk-&gt;Trusting("default" =&gt; 1); And read back with just the key:  $bulk-&gt;Trusting("email");  $bulk-&gt;Trusting("wrapping");  $bulk-&gt;Trusting("default"); default is used as a fall back. So if you didn't specify a Trusting value for \*(L"email\*(R", for example, it will use the \*(L"default\*(R" value. Note that the default is only used if a value is not specified.  $bulk-&gt;Trusting("default" =&gt; 1);  print $bulk-&gt;Trusting("email");        #prints 1  print $bulk-&gt;Trusting("default");      #prints 1  $bulk-&gt;Trusting("default" =&gt; 0);  print $bulk-&gt;Trusting("email");        #prints 0  print $bulk-&gt;Trusting("default");      #prints 0  $bulk-&gt;Trusting("email" =&gt; 1);  print $bulk-&gt;Trusting("email");        #prints 1  print $bulk-&gt;Trusting("default");      #prints 0  $bulk-&gt;Trusting("email" =&gt; 0);  $bulk-&gt;Trusting("default" =&gt; 0);  print $bulk-&gt;Trusting("email");        #prints 0  print $bulk-&gt;Trusting("default");      #prints 1 You may also directly set all values with the integer short cut.  $bulk-&gt;<strong>Trusting</strong>(1);    # everything is Trusting  $bulk-&gt;<strong>Trusting</strong>(0);    # nothing is Trusting If you want to specify Trusting in the conf file, you may only directly specify via the integer shortcut. Otherwise, you must use the list equation.  # all Trusting  Trusting = 1  #none Trusting  Trusting = 0  #email is trusting  Trusting @= email  Trusting @= wrapping This will not work:  Trusting = email If you use that syntax, it will internally do:  $bulk-&gt;Trusting(&apos;email&apos;); which you know will only read the value, not set it. If you use the array syntax, it will properly set the value. Note that -&gt;Trusting('default' =&gt; 0) is not equivalent to -&gt;<em>Trusting</em>\|(0). Consider:  $bulk-&gt;Trusting(&apos;email&apos; =&gt; 1);  print $bulk-&gt;Trusting(&apos;email&apos;);        # prints 1  $bulk-&gt;Trusting("default&apos; =&gt; 0);  print $bulk-&gt;Trusting(&apos;email&apos;);        # still prints 1  $bulk-&gt;<strong>Trusting</strong>(0);  print $bulk-&gt;Trusting(&apos;email&apos;);        # now prints 0 Currently, you may set:  email      - Trusting(&apos;email&apos; =&gt; 1) will not check for valid email addresses  wrapping   - Trusting(&apos;wrapping&apos; =&gt; 1) will not try to wrap the message to reach the 1,000 character per line limit  duplicates - Trusting(&apos;duplicates&apos; =&gt; 1) will not do any duplicates checking      (this is the equivalent of allow_duplicates in older versions)  banned     - Trusting(&apos;banned&apos; =&gt; 1) will not lowercase the local part of a domain in a banned or duplicates check      (this is the opposite of safe_banned in older versions. i.e. $bulk2_05-&gt;<strong>safe_banned</strong>(1) == $bulk_300-&gt;Trusting(&apos;banned&apos; =&gt; 0); It is recommended your conf file be:  Trusting @= duplicates Since you're usually better off weeding duplicates out in advance. All other Trusting values are recommended to be false.</p>
  </dd>
  <dt>
    banned
  </dt>
  <dd>
    <p>banned stores the list of email addresses and domains that are banned. Only store user@domain.com portions of email addresses, don't try to ban \*(L"Jim\*(R"&lt;jim@jimandkoka.com&gt;, for instance. Only ban jim@jimandkoka.com banned may be either a coderef, globref, arrayref, or string literal. If a string literal, then Mail::Bulkmail will attempt to open that file (in append mode) as your log:  $bulk-&gt;banned("/path/to/my/banned.addresses"); If a globref, it is assumed to be an open filehandle in append mode:  open (B, "&gt;&gt;/path/to/my/banned.addresses");  $bulk-&gt;banned(&#92;*B); files should contain one entry per line, each entry being an email address or a domain. For example:  jim@jimandkoka.com  jimandkoka.com  foo@bar.com  bar.com if a coderef, it is assumed to be a function to return your banned list:  sub B {return $bannedquery-&gt;execute()};        #or whatever your code is  $bulk-&gt;banned(&#92;&B); The function should return one entry per execution, either an address or a domain. if an arrayref, then it's an array of banned addresses and domains  $bulk-&gt;banned([qw(jim@jimandkoka.com jimandkoka.com)]); The arrayref can contain email addresses and domains. Use whichever item is most convenient, and Mail::Bulkmail will take it from there. Once banned has been populated, the values are stored internally in a hashref.</p>
  </dd>
  <dt>
    Precedence
  </dt>
  <dd>
    <p>Precedence is a validating accessor to validate the Precedence you have passed for your mailing list. Precedence must be either:  * list (default) - a mailing list  * bulk - bulk mailing of some type  * junk - worthless test message. You can use an alternate Precedence if you set Trusting to 0. But seriously, there's *no* reason to do that. Keeping the appropriate precedence will help the servers on the internet route your message as well as the rest of the email out there more efficiently. So don't be a jerk, and leave it as one of those three. This method is known to be able to return:  MB001 - invalid precedence</p>
  </dd>
  <dt>
    Tz
  </dt>
  <dd>
    <p>Returns the timezone that you're in. You cannot set this value. You'll also never need to worry about it.</p>
  </dd>
  <dt>
    Date
  </dt>
  <dd>
    <p>Returns the date that this email is being sent, in valid \s-1RFC\s0 format. Note that this will be stored in _cached_headers as the date that the first email is sent. Another thing you won't need to worry about.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    new
  </dt>
  <dd>
    <p>The constructor, used to create new Mail::Bulkmail objects. See Mail::Bulkmail::Object for more information on constructors. In a nutshell, the constructor accepts a hash with name/value pairs corresponding to attributes and attribute values. So that:  my $bulk = Mail::Bulkmail-&gt;new(         &apos;LIST&apos; =&gt; &apos;./list.txt&apos;,         &apos;Message&apos; =&gt; "This is my message!",         &apos;HTML&apos; =&gt; 0  ) || die Mail::Bulkmail-&gt;error; is the same as:  my $bulk = Mail::Bulkmail-&gt;new() || die Mail::Bulkmail-&gt;error;  $bulk-&gt;LIST("./list.txt");  $bulk-&gt;Message("This is my message!");  $bulk-&gt;<strong>HTML</strong>(0); *technically* it's not exactly the same, since the constructor will fail with an error if your attribute calls return undef, but it's close enough. It is recommend to tack on an || die after your <em>new()</em> calls, to make sure you're alerted if your object isn't created.  my $bulk = Mail::Bulkmail-&gt;new() || die Mail::Bulkmail-&gt;error(); Otherwise, you won't be alerted if your object isn't created. Upon creation, Mail::Bulkmail will first iterate through the conf file and populate all of the attributes defined in the conf file into your object. It will then iterate through the values you passed to the constructor and mutate the attributes to those values. If you don't pass any arguments to the constructor, it still gets the default values in the conf file. Values passed to the constructor always override values specified in the conf file There is one special constructor flag, \*(L"server_file\*(R", which does not correspond to an attribute or method. \*(L"server_file\*(R" is used to override the server_file specified in the conf file. If you pass a key/value pair to the constructor that doesn't have a corresponding attribute, then it is assuming you are setting a new header.  my $bulk = Mail::Bulkmail-&gt;new(&apos;foo&apos; =&gt; &apos;bar&apos;);  is the same as:  my $bulk = Mail::Bulkmail-&gt;new();  $bulk-&gt;header(&apos;foo&apos; =&gt; &apos;bar&apos;); This method is known to be able to return:  MB003 - could not use server class</p>
  </dd>
  <dt>
    header
  </dt>
  <dd>
    <p>the header method is used to set additional headers for your object that don't have their own methods (such as Subject) header expects the header and value to act as a mutator, or the header to act as an accessor.  $bulk-&gt;header(&apos;X-Header&apos;, "My header value");  print $bulk-&gt;header(&apos;X-Header&apos;); #prints "My header value" Use this to set any additional headers that you would like. Note that you can't use this to bypass validation checks.  $bulk-&gt;Header("Subject", "My Subject") will internally change into $bulk-&gt;Subject("My Subject"); There's no benefit to doing that, it'll just slow you down. If you call header with no values, it returns the _headers hashref, containing key value pairs of header =&gt; value This method is known to be able to return:  MB004 - cannot set CC or BCC header  MB005 - invalid header</p>
  </dd>
  <dt>
    valid_email
  </dt>
  <dd>
    <p>valid_email validates an email address and extracts the user@domain.com part of an address  print $bulk-&gt;valid_email(&apos;jim@jimandkoka.com&apos;)-&gt;{&apos;extracted&apos;};                                 #prints jim@jimandkoka.com  print $bulk-&gt;valid_email(&apos;"Jim Thomason"&lt;jim@jimandkoka.com&gt;&apos;)-&gt;{&apos;extracted&apos;}; #prints jim@jimandkoka.com  print $bulk-&gt;valid_email(&apos;jim@jimandkoka.com&apos;)-&gt;{&apos;extracted&apos;};                                 #prints jim@jimandkoka.com  print $bulk-&gt;valid_email(&apos;jim@@jimandkoka.com&apos;);                                                               #prints nothing (invalid address) Note that as of v3.10, valid_email returns a hash with two keys upon success. 'original' contains the address as you passed it in, 'extracted' is the address person that was yanked out.  {         &apos;original&apos;      =&gt; &apos;Jim Thomason&apos;&lt;jim@jimandkoka.com&apos;,         &apos;extracted&apos;     =&gt; &apos;jim@jimandkoka.com&apos;,  } Given an invalid address, returns undef and sets an error as always. If Trusting is 1, then valid_email only removes comments and extracts the address spec part of the email. i.e., if your address is  some name&lt;some@address.com&gt; It'll just return some@address.com. This is required, because valid_email is also where the address spec is validated. As of 3.00, valid_email should be fully \s-1RFC\s0 2822 compliant, except where otherwise noted (such as forcing a valid domain as per \s-1RFC\s0 2821). And also as of 3.00, Trusting is even more trusting and has a faster return. There are speed reasons to have Trusting set to 1 (such as not having to check the validity of each email address), but if you do that then you must be <strong>positive</strong> that <strong>all</strong> of your addresses are 100% valid. If you have <strong>any</strong> addresses in your list that are invalid and Trusting is set to 1, then you may have bad things happen. You have been warned. This method is known to be able to return:  MB006 - no email address  MB007 - invalid email address</p>
  </dd>
  <dt>
    lc_domain
  </dt>
  <dd>
    <p>given an email address, lowercases the domain. Mainly used internally, but I thought it might be useful externally as well.  print $self-&gt;lc_domain(&apos;Jim@JimANDKoka.com&apos;);  #prints Jim@jimandkoka.com  print $self-&gt;lc_domain(&apos;JIM@JIMANDKOKA.com&apos;);  #prints JIM@jimandkoka.com  print $self-&gt;lc_domain(&apos;jim@jimandkoka.com&apos;);  #prints jim@jimandkoka.com This method is known to be able to return:  MB009 - cannot lowercase domain w/o email</p>
  </dd>
  <dt>
    setDuplicate
  </dt>
  <dd>
    <p>sets an email address as a duplicate.  $bulk-&gt;setDuplicate($email); once an address is set as a duplicate, then isDuplicate will return a true value for that address  print $bulk-&gt;isDuplicate($email2);     #prints 0  $bulk-&gt;setDuplicate($email2);  print $bulk-&gt;isDuplicate($email2);     #prints 1 This is mainly used internally, but I decided to make it external anyway. setDuplicate will always return 1 if you have Trusting('duplicates') set. Be warned that there is a performance hit to using this, since it will eventually store your entire list inside an entire hashref in memory. You're in much better shape if you weed out the duplicates in advance and then set Trusting('duplicates' =&gt; 1) to skip the check and skip storing the values in the hashref. But if you have to use this to weed out values, go to town. This method is known to be able to return:  MB010 - cannot set duplicate w/o email =cut sub setDuplicate { 	my $self	= shift; 	my $email	= shift || return $self-&gt;error(\*(L"Cannot set duplicate without email\*(R", \*(L"\s-1MB010\s0\*(R");         return 1 if $self-&gt;Trusting(&apos;duplicates&apos;);         if (! $self-&gt;Trusting(&apos;banned&apos;)) {                 $self-&gt;_duplicates-&gt;{lc $email} = 1;         }         else {                 $self-&gt;_duplicates-&gt;{$self-&gt;lc_domain($email)} = 1;         };         return 1; };</p>
  </dd>
  <dt>
    isDuplicate
  </dt>
  <dd>
    <p>returns a boolean value as to whether an email address is a duplicate  print $bulk-&gt;isDuplicate($email); #prints 0 or 1 once an address is set as a duplicate, then isDuplicate will return a true value for that address  print $bulk-&gt;isDuplicate($email2);     #prints 0  $bulk-&gt;setDuplicate($email2);  print $bulk-&gt;isDuplicate($email2);     #prints 1 This is mainly used internally, but I decided to make it external anyway. isDuplicate will always return 0 if you have Trusting('duplicates' =&gt; 1) set. Be warned that there is a performance hit to using this, since it will eventually store your entire list inside an entire hashref in memory. You're in much better shape if you weed out the duplicates in advance and then set Trusting('duplicates' =&gt; 1) to skip the check and skip storing the values in the hashref. But if you have to use this to weed out values, go to town.</p>
  </dd>
  <dt>
    isBanned
  </dt>
  <dd>
    <p>returns a boolean value as to whether an email address (or domain) is banned or not  $bulk-&gt;isBanned($email);       #prints 0 or 1  $bulk-&gt;isBanned($domain);      #prints 0 or 1 -&gt;isBanned goes off of the values populated via the banned attribute This is mainly used internally, but I decided to make it external anyway.</p>
  </dd>
  <dt>
    nextServer
  </dt>
  <dd>
    <p>Again, mainly used internally. -&gt;nextServer will iterate over the -&gt;servers array and return the next valid, connected server. If a server is not connected, -&gt;nextServer will try to make it connect. If the server cannot connect, it will go on to the next one. Once all servers are exhausted, it returns undef. nextServer is called if the present server object has reached one of its internal limits. See Mail::Bulkmail::Server for more information on server limits. This method is known to be able to return:  MB011 - No servers (-&gt;servers array is empty)  MB012 - No available servers (cannot connect to any servers)</p>
  </dd>
  <dt>
    extractEmail
  </dt>
  <dd>
    <p>The extract methods return results equivalent to the return of valid_email extracts the email address from the data passed in the bulkmail object. Not necessary in Mail::Bulkmail, since all it does in here is reflect through the same value that is passed. This will be very important in a subclass, though. getNextLine might return values beyond just simple email addresses in subclasses, hashes, objects, whatever. You name it. In that case, extractEmail is necessary to find the actual email address out of whatever it is that was returned from <em>getNextLine()</em>. But here? Nothing to worry about. This method is known to be able to return:  MB013 - cannot extract email w/o email</p>
  </dd>
  <dt>
    extractSender
  </dt>
  <dd>
    <p>The extract methods return results equivalent to the return of valid_email extracts the sender of the message from the data passed in the bulkmail object. Not necessary in Mail::Bulkmail, since all it does in here is return either the Bulkmail object's Sender or its From field. This will be very important in a subclass, though. getNextLine might return values beyond just simple email addresses in subclasses - hashes, object, whatever. You name it. In that case, extractEmail is necessary to find the actual email address out of whatever it is that was returned from <em>getNextLine()</em>. But here? Nothing to worry about.</p>
  </dd>
  <dt>
    extractReplyTo
  </dt>
  <dd>
    <p>The extract methods return results equivalent to the return of valid_email extracts the Reply-To of the message from the data passed in the bulkmail object. Not necessary in Mail::Bulkmail, since all it does in here is return either the Bulkmail object's Sender or its From field. This will be very important in a subclass, though. getNextLine might return values beyond just simple email addresses in subclasses - hashes, object, whatever. You name it. In that case, extractEmail is necessary to find the actual email address out of whatever it is that was returned from <em>getNextLine()</em>. But here? Nothing to worry about.</p>
  </dd>
  <dt>
    preprocess
  </dt>
  <dd>
    <p>This is another method that'll do more in a subclass. When you had off data to either -&gt;mail or -&gt;bulkmail, it gets preprocessed before it's actually used. In Mail::Bulkmail itself, all it does is take a non-reference value and turn it into a reference, or return a reference as is if that was passed. Here, the whole method:  sub preprocess {         my $self        = shift;         my $val         = shift;         return ref $val ? $val : &#92;$val;  }; But in a subclass, this may be much more important. Making sure that your data is uniform or valid, that particular values are populated, additional tests, whatever.</p>
  </dd>
  <dt>
    buildHeaders
  </dt>
  <dd>
    <p>buildHeaders is mainly used internally, like its name implies, it builds the headers for the message. You'll never need to call buildHeaders unless you're subclassing, in which case you may want to override this method with a new routine to build headers in a different fashion. This method is called internally by -&gt;bulkmail and -&gt;mail otherwise and is not something you need to worry about. The first time buildHeaders is called, it populates _cached_headers so as not to have to go through the processing of rebuilding the headers for each address in your list. This method is known to be able to return:  MB014 - no From address  MB015 - no To address</p>
  </dd>
  <dt>
    buildMessage
  </dt>
  <dd>
    <p>buildMessage is mainly used internally, like its name implies, it builds the body of the message You'll never need to call buildMessage unless you're subclassing, in which case you may want to override this method with a new routine to build your message in a different fashion. This method is called internally by -&gt;bulkmail and -&gt;mail otherwise and is not something you need to worry about. This method is known to be able to return:  MB016 - -&gt;Message is not defined</p>
  </dd>
  <dt>
    bulkmail
  </dt>
  <dd>
    <p>This is the bread and butter of the whole set up, and it's easy as pie.  $bulk-&gt;bulkmail(); will take your list, iterate over it, build all your message headers, build your message, and email to everyone on your list, iterating through all of your servers, log all relevant information, and send you happily on your way. Easy as pie. You don't even need to worry about it if you subclass things, because you'd just need to override buildHeaders, buildMessage, getNextLine and extractEmail at most. This method is known to be able to return:  MB017 - duplicate email  MB018 - banned email  MB019 - invalid sender/from</p>
  </dd>
  <dt>
    mail
  </dt>
  <dd>
    <p>Works the same as -&gt;bulkmail, but only operates on one email address instead of a list.  $bulk-&gt;mail(&apos;jim@jimandkoka.com&apos;); Sends your Message as defined in -&gt;Message to jim@jimandkoka.com. You can also optionally pass in a server as the second argument.  $bulk-&gt;mail(&apos;jim@jimandkoka.com&apos;, $server); is the same as above, but relays through that particular server. if you don't pass a server, if tries to bring the next one in via -&gt;nextServer -&gt;mail wants its first argument to be whatever would be normally returned by a call to -&gt;getNextLine($bulk-&gt;\s-1LIST\s0); Right now, that's just a single email address. But that may change in a subclass. So, if you're operating in a subclass, just remember that you may be able (or required) to pass additional information in your first argument. This method is known to be able to return:  MB018 - banned email  MB019 - invalid sender/from address</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FAQ</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    So just how fast is this thing, anyway?&gt;
  </dt>
  <dd>
    <p>I don't know any more, I don't have access to the same gigantic lists I used to anymore.  :~( But, basically, Really fast.  Really stupendously incredibly fast. The last official big benchmark I ran was with v1.11. That list runs through to completion in about an hour and 43 minutes, which meant that Mail::Bulkmail 1.11 could process (at least) 884 messages per minute or about 53,100 per hour. The last message sent out was 4,979 bytes.  4979 x 91,140 people is 453,786,060 bytes of data transferred, or about 453.786 megabytes in 1 hour and 43 minutes.  This is a sustained transfer rate of about 4.4 megabytes per minute, or 264.34 megabytes per hour. So then, that tells you how fast the software was back in 1999, 2 major revisions ago. But, invariably, you want to know what it's like *now*, right? Well, I'll do my best to guesstimate it. However, these tests were not run through an \s-1SMTP\s0 relay, they were run using DummyServer in v3.0 and a hacked 2.05 and (severely) hacked 1.11 to insert similar functionality. All data was sent to /dev/null. Tests were performed on a 5,000 recipient list. First of all, with envelope sending turned off (average times):  v1.11......20 seconds  (1.00)  v3.00......23 seconds  (1.15)  v2.05......50 seconds  (2.5) 1.11 was the speed champ in this case, but that's not surprising considering the fact that it did a lot less processing than the other 2. The fact that 3.00 almost catches it should speak to the improvement in the code in the 3.x release. 2.05 was...clunky. Now then, there's another thing to consider, envelope sending. With envelope sending turned on (average times):  v3.00......12 seconds  (1.00)  v2.05......19 seconds  (1.58)  v1.11......22 seconds  (1.83) This is with an envelope_limit of 100. So the supposed speed gains that envelope sending were supposed to see in 2.05 never really materialized. While doing these tests, I discovered a bug in 2.05's use_envelope routine that would sometimes cause it to slow down substantially. 3.00, with a new routine, was never affected. Incidentally, Bulkmail 2.05 will be faster with trivially low envelope_limits. Bulkmail 3.00 becomes faster with an envelope_limit greater than 2. There is also mail merging (filemapping in 1.x) that should be considered. This was benchmarked with Mail::Bulkmail::Dynamic for 3.00. A simple mail merge with one item was used, and one global item, read from a file, and split on a delimiter (since this was the only functionality that v1.x had). With mail merge turned on (average times):  v1.11......20 seconds  (1.00)  v3.00......35 seconds  (1.75)  v2.05......40 seconds  (2.00) And finally, 2.x and 3.x have both had the capability to generate a dynamic message. This is a minimal test with one dynamic message element, one dynamic header, and a mail merge into the dynamic element:  v3.00......36 seconds  (1.00)  v2.05......44 seconds  (1.22) So 3.x is usually faster than 2.x, but sometimes slower than 1.x. Which makes sense, again due to the added features in 2.x and 3.x. These tests do not take into account the multi-server capability introduced in 3.00. Also note that these speeds are only measuring the time it takes to get from Mail::Bulkmail to your \s-1SMTP\s0 relay. There are no measurements reflecting how long it may take your \s-1SMTP\s0 relay to send the data on to the recipients on your list.</p>
  </dd>
  <dt>
    Am I going to see speeds that fast?
  </dt>
  <dd>
    <p>Maybe, maybe not.  It depends on how busy your \s-1SMTP\s0 server is.  If you have a relatively unused \s-1SMTP\s0 server with a fair amount of horsepower and a fast connection, you can easily get these speeds or beyond.  If you have a relatively busy and/or low powered \s-1SMTP\s0 server or slow connections, you're not going to reach speeds that fast.</p>
  </dd>
  <dt>
    How much faster will Mail::Bulkmail be than my current system?
  </dt>
  <dd>
    <p>This is a very tough question to answer, since it depends highly upon what your current system is.  For the sake of argument, let's assume that for your current system, you open an \s-1SMTP\s0 connection to your server, send a message, and close the connection. And then repeat.  Open, send, close, etc. Mail::Bulkmail will <em>always</em> be faster than this approach since it opens one \s-1SMTP\s0 connection and sends every single message across on that one connection.  How much faster depends on how busy your server is as well as the size of your list. The connection will only be closed if you have an error or if you reach the max number of messages to send in a given server connection. Lets assume (for simplicity's sake) that you have a list of 100,000 people.  We'll also assume that you have a pretty busy \s-1SMTP\s0 server and it takes (on average) 25 seconds for the server to respond to a connection request.  We're making 100,000 connection requests (with your old system).  That means 100,000 x 25 seconds = almost 29 days waiting just to make connections to the server!  Mail::Bulkmail makes one connection, takes 25 seconds for it, and ends up being 100,000x faster! But, now lets assume that you have a very unbusy \s-1SMTP\s0 server and it responds to connection requests in .003 seconds.  We're making 100,000 connection requests.  That means 100,000 x .0003 seconds = about 5 minutes waiting to make connections to the server. Mail::Bulkmail makes on connection, takes .0003 seconds for it, and ends up only being 1666x faster.  But, even though being 1,666 times faster sounds impressive, the world won't stop spinning on its axis if you use your old system and take up an extra 5 minutes. And this doesn't even begin to take into account systems that don't open and close \s-1SMTP\s0 connections for each message. This also doesn't take into account the load balancing between multiple \s-1SMTP\s0 relays that 3.00 can perform. In short, there's no way for me to tell how much faster (if at all) it'll be. Try it and find out.</p>
  </dd>
  <dt>
    Have you benchmarked it against anything else?
  </dt>
  <dd>
    <p>Not scientifically.  I've heard that Mail::Bulkmail 1.10 is about 4-5x faster than Listcaster from Mustang Software, but I don't have any hard numbers.  But nothing beyond that. If you want to benchmark it against some other system and let me know the results, it'll be much appreciated.  :-)</p>
  </dd>
  <dt>
    Can I send spam with this thing?
  </dt>
  <dd>
    <p>No.  Don't be a jerk.</p>
  </dd>
  <dt>
    \s-1SMTP\s0 relay? Wazzat?
  </dt>
  <dd>
    <p>All Mail::Bulkmail does is provide you a quick way to relay information from your local machine through to your \s-1SMTP\s0 relay (which may be the same machine). Your \s-1SMTP\s0 relay then sends the messages on to the rest of the world. So your \s-1SMTP\s0 server must be configured properly to allow you to relay your messages out. It is recommended that this machine be kept behind a firewall for security reasons. Make sure that it's configured properly so it's not an open relay. Ask your SysAdmin for help.</p>
  </dd>
  <dt>
    What about multi-part messages?
  </dt>
  <dd>
    <p>Not yet supported. I'll definitely add internal support for multi-part/alternative in the future. Until then? You can always do the \s-1MIME\s0 encoding yourself, set your own headers, etc. It's perfectly fine to do it yourself, but you will have to do it yourself for now.</p>
  </dd>
  <dt>
    Mail::Bulkmail is really cool, but what'd be even cooler is a front end for the thing! Do you have one of those?
  </dt>
  <dd>
    <p>I don't. But check out Mojo Mail:  http://mojo.skazat.com/ Active community, developer, etc. Looks like a good product.</p>
  </dd>
  <dt>
    You know, you re-invent a lot of wheels.
  </dt>
  <dd>
    <p>Yeah, I do. Hey, c'mon, I write this stuff for the fun of it. And that means that I'm going to do it the way that I want to. :) Besides, I've never had any problem with re-inventing wheels. After all, if the wheel hadn't been re-invented a few times, we'd still be using solid plain wooden wheels. Not to say that I necessarily think that I've invented better things here than are available elsewhere, but I might eventually. Who knows. Anyway, you're more than free to subclass and over-ride things with \*(L"standard\*(R" modules if you'd like. ou can make your own server implementation using Net::SMTP, or your own dynamic message system using Text::Template, or whatever else. Feel free to use the standards if you'd prefer. Me? I enjoy re-inventing wheels, so I'll continue to do so.</p>
  </dd>
  <dt>
    Dude! Warnings is on!
  </dt>
  <dd>
    <p>That's by design. Nothing in the code ever should generate a warning, but if it does, then please please <strong>please</strong> let me know about it so I can patch it. You can always turn off warnings yourself if you're worried/annoyed.</p>
  </dd>
  <dt>
    So what is it with these version numbers anyway?
  </dt>
  <dd>
    <p>I'm going to <em>try</em> to be consistent in how I number the releases. The <strong>hundredths</strong> digit will indicate bug fixes, minor behind-the-scenes changes, etc. The <strong>tenths</strong> digit will indicate new and/or better functionality, as well as some minor new features. The <strong>ones</strong> digit will indicate a major new feature or re-write. Basically, if you have x.ab and x.ac comes out, you want to get it guaranteed.  Same for x.ad, x.ae, etc. If you have x.ac and x.ba comes out, you'll probably want to get it.  Invariably there will be bug fixes from the last \*(L"hundredths\*(R" release, but it'll also have additional features.  These will be the releases to be sure to read up on to make sure that nothing drastic has changes. If you have x.ac and y.ac comes out, you'll want to do research before upgrading. I break things, I lose backwards compatibility, I change stuff around a lot. Just my nature. Porting from one major release to the next is pretty straightforward, but there's still work to be done on your part - it won't just be a drop in replacement. And, depending upon your list and what options you're using, you may or may not see any benefit to upgrading. Read the docs, ask me questions, and test test test. Don't get me wrong, I'm not going to intentially *try* to make things not backwards compatible, but if I come up with what I think is a better way of doing things, I'm going to go with it. And I don't like to pollute modules with a lot of cruft bridgeworks for backwards compatibility. This thing is huge enough as is without having to worry about making sure internal band-aids work. If this'll be a problem, then don't upgrade.</p>
  </dd>
  <dt>
    Is anything missing vs. the old versions?
  </dt>
  <dd>
    <p>Yes. You can't currently extract headers from the message you're sending. This will return in the future, probably. When using dynamic_header_data, you can no longer set a default header to be used if no header is defined for the individual user. This will also probably return in the future. local merges no longer exist. You only have global merges and individual ones. It will now date all messages to the time of the first sent message. You can no longer externally load in a list of duplicates. Come on, did *anybody* ever actually do that? Ya know, I <strong>thought</strong> this error was self-explanatory, but considering the number of people that email me about it, I guess it's not. The issue here is that (say it with me now), you can't bulkmail because the To header hasn't been set. If you're using envelope sending (on by default in Mail::Bulkmail), then you have to specify an address to set in the To: header of the message. This is specified via the -&gt;To accessor.  $bulk-&gt;To("mylist@mysite.com"); So, specify the To header, and then you'll be fine.</p>
  </dd>
  <dt>
    Wow, this module is really cool.  Have you contributed anything else to \s-1CPAN\s0?
  </dt>
  <dd>
    <p>Yes, Carp::Notify and Text::Flowchart</p>
  </dd>
  <dt>
    Was that a shameless plug?
  </dt>
  <dd>
    <p>Why, yes.  Yes it was.</p>
  </dd>
  <dt>
    Anything else you want to tell me?
  </dt>
  <dd>
    <p>Sure, anything you need to know.  Just drop me a message.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>#simple mailing with a list called \*(L"./list.txt\*(R"</p><p> my $bulk = Mail::Bulkmail-&gt;new(         "LIST"          =&gt; "./list.txt",         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "To"            =&gt; &apos;somelist@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;  ) || die Mail::Bulkmail-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#same thing, but turning off envelope sending</p><p> my $bulk = Mail::Bulkmail-&gt;new(         "LIST"                  =&gt; "./list.txt",         "Subject"               =&gt; "A test message",         "Message"               =&gt; "This is my test message",         "From"                  =&gt; &apos;me@mydomain.com&apos;,         "Reply-To"              =&gt; &apos;replies@mydomain.com&apos;,         "use_envelope" =&gt; 0  ) || die Mail::Bulkmail-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#Small example, with a miniature in memory list</p><p> my $bulk = Mail::Bulkmail-&gt;new(         "LIST"          =&gt; [qw(test@mydomain.com me@mydomain.com test2@mydomain.com)],         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "To"            =&gt; &apos;somelist@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;,         "Sender"        =&gt; &apos;sender@mydomain.com&apos;  ) || die Mail::Bulkmail-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#Make sure our error logging is on in a different place, and set up a different server</p><p> my $server = Mail::Bulkmail::Server-&gt;new(         &apos;Smtp&apos; =&gt; "smtp.mydomain.com",         "Port" =&gt; 25  ) || die Mail::Bulkmail::Server-&gt;error();</p><p> my $bulk = Mail::Bulkmail-&gt;new(         "LIST"          =&gt; "./list.txt",         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "To"            =&gt; &apos;somelist@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;,         "ERRFILE"       =&gt; &apos;/etc/mb/error.file.txt&apos;,         "servers"       =&gt; [$server]    #our new server  ) || die Mail::Bulkmail-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#Make sure our error logging is on in a different place, and set up a different server #this time, we'll use a dummy server for debugging purposes</p><p> my $dummy_server = Mail::Bulkmail::DummyServer-&gt;new(         "dummy_file"    =&gt; "/etc/mb/dummy.server.output.txt"  ) || die Mail::Bulkmail::DummyServer-&gt;error();</p><p> my $bulk = Mail::Bulkmail-&gt;new(         "LIST"          =&gt; "./list.txt",         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "To&apos;            =&gt; &apos;somelist@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;,         "ERRFILE"       =&gt; &apos;/etc/mb/error.file.txt&apos;,         "servers"       =&gt; [$dummy_server]      #our new server, which is a dummy server  ) || die Mail::Bulkmail-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#mailing just to one address</p><p> my $bulk = Mail::Bulkmail-&gt;new(         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;,         "Sender"        =&gt; &apos;sender@mydomain.com&apos;  ) || die Mail::Bulkmail-&gt;error();</p><p> $bulk-&gt;mail(&apos;test@yourdomain.com&apos;) || die $bulk-&gt;error;</p><p>#here, a fun one. Use a coderef as our \s-1LIST\s0</p><p> my $query = "select email, domain from table order by domain";  my $stmt = $dbh-&gt;prepare($query) || die;</p><p> $stmt-&gt;execute || die;</p><p> sub get_list {         my $bulk = shift; #we always get our bulkmail object first</p><p>        my $data = $stmt-&gt;fetchrow_hashref();</p><p>        if ($data) {                 return $data-&gt;{"email"};         }         else {                 return undef;         };  };</p><p> $bulk-&gt;LIST(&#92;&get_list);</p><p> #and now, logging to a coderef.</p><p> my $query = (&apos;insert into table good_addresses (email) values (?)&apos;);  my $stmt = $dbh-&gt;prepare($query) || die;</p><p> sub store_to_db {         my $bulk        = shift; #always get our bulkmail object first         my $email       = shift;</p><p>        $stmt-&gt;execute($email) || return $bulk-&gt;error("Could not store to DB!");         return 1;  };</p><p> $bulk-&gt;GOOD(&#92;&store_to_db);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SAMPLE CONFIG FILE</h2>
        <div class="sectioncontent">
<p>This is my current conf file. It's about as close to one that you want to use as possible. Remember, you can set any values you'd like in the conf file, as long as they're scalars or arrayrefs of scalars. For example, if you want a default \*(L"From\*(R" value, then define it in the conf file.</p><p>For more information on conf files, see Mail::Bulkmail::Object. For more information on the server file, see Mail::Bulkmail::Server. This file is also stored in the file \*(L"sample.cfg.file\*(R"</p><p> define package Mail::Bulkmail</p><p> #server_class stores the server object that we&apos;re going to use.  #uncomment the DummyServer line and comment out the Server line for debugging</p><p> server_class = Mail::Bulkmail::Server  #server_class = Mail::Bulkmail::DummyServer</p><p> #log our errors  ERRFILE = /etc/mb/error.txt  BAD    = /etc/mb/bad.txt  GOOD   = /etc/mb/good.txt  banned = /etc/mb/banned.txt</p><p> #if we want a default From value, you can place it here.  #From = me@mydomain.com</p><p> define package Mail::Bulkmail::Server</p><p> #set up the domain we use to say HELO to our relay  Domain = mydomain.com</p><p> #Most servers are going to connect on port 25, so we&apos;ll set this as the default port here  Port = 25</p><p> #We&apos;ll give it 5 tries to connect before we let -&gt;connect fail  Tries = 5</p><p> #Lets try to reconnect to a server 5 times if -&gt;connect fails.  max_connection_attempts = 5</p><p> #100 is a good number for the envelope_limit  envelope_limit = 100</p><p> #Send 1,000 messages to each server in the round before going to the next one.  #set max_messages_per_robin to 0 if you&apos;re only using one server, otherwise you&apos;ll have needless  #overhead  max_messages_per_robin = 0</p><p> #maximum number of messages per connection. Probably best to keep this 0 unless you have a reason  #to do otherwise  max_messages_per_connection = 0</p><p> #maximum number of messages for the server. Probably best to keep this 0 unless you have a reason  #to do otherwise  max_messages= 0</p><p> #maximum number of messages to send before sleeping, probably best to keep this 0 unless you need  #to let your server relax and sleep  max_messages_while_awake = 0</p><p> #sleep for 10 seconds if we&apos;re sleeping. This line is commented out because we don&apos;t need it.  #No harm in uncommenting it, though.  #sleep_length = 10</p><p> #our list of servers  server_file = /etc/mb/servers.txt</p><p> define package Mail::Bulkmail::Dynamic</p><p> #it is highly recommended that quotemeta be 1  quotemeta = 1</p><p> #set up our default delimiters  dynamic_message_delimiter                      = ;  dynamic_message_value_delimiter        = =  dynamic_header_delimiter                       = ;  dynamic_header_value_delimiter         = =</p><p> #we&apos;re going to assume that duplicates have been weeded out, so we&apos;ll allow them.  Trusting       @= duplicates</p><p> #By default, we&apos;ll turn on our envelope. Mail::Bulkmail might as well use it.  #Mail::Bulkmail::Dynamic doesn&apos;t care about this value.  use_envelope           = 1</p><p> define package Mail::Bulkmail::DummyServer</p><p> #Our dummy data file, for when we&apos;re using DummyServer. It&apos;s also useful to send the data to  #/dev/null to test things if you don&apos;t care about the message output.  dummy_file = /etc/mb/dummy.file  #dummy_file = /dev/null</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>Bulkmail doesn't directly generate any errors.  If something fails, it will return undef and set the -&gt;error property of the bulkmail object.  If you've provided an error log file, the error will be printed out to the log file.</p><p>Check the return of your functions, if it's undef, check -&gt;error to find out what happened.</p><p>Be warned that isDuplicate and isBanned will return 0 if an address is not a duplicate or banned, respectively, but this is not an error condition.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Mail::Bulkmail&hellip;</h2>
        <div class="sectioncontent">
<p>Mail::Bulkmail::Object, Mail::Bulkmail::Server, Mail::Bulkmail::Dummy</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT (again)</h2>
        <div class="sectioncontent">
<p>Copyright and (c) 1999, 2000, 2001, 2002, 2003 James A Thomason \s-1III\s0 (jim@jimandkoka.com). All rights reserved. Mail::Bulkmail is distributed under the terms of the Perl Artistic License.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTACT INFO</h2>
        <div class="sectioncontent">
<p>So you don't have to scroll all the way back to the top, I'm Jim Thomason (jim@jimandkoka.com) and feedback is appreciated. Bug reports/suggestions/questions/etc.  Hell, drop me a line to let me know that you're using the module and that it's made your life easier.  :-)</p><p>http://www.jimandkoka.com/jim/perl/ for more perl info, http://www.jimandkoka.com in general</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="MRO::Compat.3pm.html"><span aria-hidden="true">&larr;</span> MRO::Compat.3pm: Mro::* interface compatibility for perls  5.9.5</a></li>
   <li class="next"><a href="Mail::Bulkmail::DummyServer.3pm.html">Mail::Bulkmail::DummyServer.3pm: Dummy class for dummy server objects <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

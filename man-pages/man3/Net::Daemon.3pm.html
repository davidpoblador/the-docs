<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Net::Daemon: Perl extension for portable daemons</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl extension for portable daemons">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Net::Daemon (3pm) manual">
  <meta name="twitter:description" content="Perl extension for portable daemons">
  <meta name="twitter:image" content="https://www.carta.tech/images/libnet-daemon-perl-Net::Daemon-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Net::Daemon.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Net::Daemon (3pm) manual" />
  <meta property="og:description" content="Perl extension for portable daemons" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libnet-daemon-perl-Net::Daemon-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Net::Daemon<small> (3pm)</small></h1>
        <p class="lead">Perl extension for portable daemons</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Net::Daemon.3pm.html">
      <span itemprop="name">Net::Daemon: Perl extension for portable daemons</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libnet-daemon-perl/">
      <span itemprop="name">libnet-daemon-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Net::Daemon.3pm.html">
      <span itemprop="name">Net::Daemon: Perl extension for portable daemons</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  # Create a subclass of Net::Daemon
  require Net::Daemon;
  package MyDaemon;
  @MyDaemon::ISA = qw(Net::Daemon);

  sub Run ($) {
    # This function does the real work; it is invoked whenever a
    # new connection is made.
  }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Net::Daemon is an abstract base class for implementing portable server applications in a very simple way. The module is designed for Perl 5.005 and threads, but can work with <em>fork()</em> and Perl 5.004.</p><p>The Net::Daemon class offers methods for the most common tasks a daemon needs: Starting up, logging, accepting clients, authorization, restricting its own environment for security and doing the true work. You only have to override those methods that aren't appropriate for you, but typically inheriting will safe you a lot of work anyways.</p><h3>Constructors</h3>
<p>  $server = Net::Daemon-&gt;new($attr, $options);</p><p>  $connection = $server-&gt;Clone($socket);</p><p>Two constructors are available: The <strong>new</strong> method is called upon startup and creates an object that will basically act as an anchor over the complete program. It supports command line parsing via \*(L"Getopt::Long (3)\*(R".</p><p>Arguments of <strong>new</strong> are <em></em><strong>$attr</strong><em></em>, an hash ref of attributes (see below) and <em></em><strong>$options</strong><em></em> an array ref of options, typically command line arguments (for example <strong>&#92;@ARGV</strong>) that will be passed to <strong>Getopt::Long::GetOptions</strong>.</p><p>The second constructor is <strong>Clone</strong>: It is called whenever a client connects. It receives the main server object as input and returns a new object. This new object will be passed to the methods that finally do the true work of communicating with the client. Communication occurs over the socket <strong></strong><strong>$socket</strong><strong></strong>, <strong>Clone</strong>'s argument.</p><p>Possible object attributes and the corresponding command line arguments are:</p>
<dl class='dl-vertical'>
  <dt>
    <em>catchint</em> (<strong>--nocatchint</strong>)
  </dt>
  <dd>
    <p>On some systems, in particular Solaris, the functions <em>accept()</em>, <em>read()</em> and so on are not safe against interrupts by signals. For example, if the user raises a \s-1USR1\s0 signal (as typically used to reread config files), then the function returns an error \s-1EINTR\s0. If the <em>catchint</em> option is on (by default it is, use <strong>--nocatchint</strong> to turn this off), then the package will ignore \s-1EINTR\s0 errors whereever possible.</p>
  </dd>
  <dt>
    <em>chroot</em> (<strong>--chroot=dir</strong>)
  </dt>
  <dd>
    <p>(\s-1UNIX\s0 only)  After doing a <em>bind()</em>, change root directory to the given directory by doing a <em>chroot()</em>. This is usefull for security operations, but it restricts programming a lot. For example, you typically have to load external Perl extensions before doing a <em>chroot()</em>, or you need to create hard links to Unix sockets. This is typically done in the config file, see the --configfile option. See also the --group and --user options. If you don't know <em>chroot()</em>, think of an \s-1FTP\s0 server where you can see a certain directory tree only after logging in.</p>
  </dd>
  <dt>
    <em>clients</em>
  </dt>
  <dd>
    <p>An array ref with a list of clients. Clients are hash refs, the attributes <em>accept</em> (0 for denying access and 1 for permitting) and <em>mask</em>, a Perl regular expression for the clients \s-1IP\s0 number or its host name. See \*(L"Access control\*(R" below.</p>
  </dd>
  <dt>
    <em>configfile</em> (<strong>--configfile=file</strong>)
  </dt>
  <dd>
    <p>Net::Daemon supports the use of config files. These files are assumed to contain a single hash ref that overrides the arguments of the new method. However, command line arguments in turn take precedence over the config file. See the \*(L"Config File\*(R" section below for details on the config file.</p>
  </dd>
  <dt>
    <em>debug</em> (<strong>--debug</strong>)
  </dt>
  <dd>
    <p>Turn debugging mode on. Mainly this asserts that logging messages of level \*(L"debug\*(R" are created.</p>
  </dd>
  <dt>
    <em>facility</em> (<strong>--facility=mode</strong>)
  </dt>
  <dd>
    <p>(\s-1UNIX\s0 only) Facility to use for \*(L"Sys::Syslog (3)\*(R". The default is <strong>daemon</strong>.</p>
  </dd>
  <dt>
    <em>group</em> (<strong>--group=gid</strong>)
  </dt>
  <dd>
    <p>After doing a <em>bind()</em>, change the real and effective \s-1GID\s0 to the given. This is usefull, if you want your server to bind to a privileged port (&lt;1024), but don't want the server to execute as root. See also the --user option. \s-1GID\s0's can be passed as group names or numeric values.</p>
  </dd>
  <dt>
    <em>localaddr</em> (<strong>--localaddr=ip</strong>)
  </dt>
  <dd>
    <p>By default a daemon is listening to any \s-1IP\s0 number that a machine has. This attribute allows to restrict the server to the given \s-1IP\s0 number.</p>
  </dd>
  <dt>
    <em>localpath</em> (<strong>--localpath=path</strong>)
  </dt>
  <dd>
    <p>If you want to restrict your server to local services only, you'll prefer using Unix sockets, if available. In that case you can use this option for setting the path of the Unix socket being created. This option implies <strong>--proto=unix</strong>.</p>
  </dd>
  <dt>
    <em>localport</em> (<strong>--localport=port</strong>)
  </dt>
  <dd>
    <p>This attribute sets the port on which the daemon is listening. It must be given somehow, as there's no default.</p>
  </dd>
  <dt>
    <em>logfile</em> (<strong>--logfile=file</strong>)
  </dt>
  <dd>
    <p>By default logging messages will be written to the syslog (Unix) or to the event log (Windows \s-1NT\s0). On other operating systems you need to specify a log file. The special value \*(L"\s-1STDERR\s0\*(R" forces logging to stderr.</p>
  </dd>
  <dt>
    <em>loop-child</em> (<strong>--loop-child</strong>)
  </dt>
  <dd>
    <p>This option forces creation of a new child for loops. (See the <em>loop-timeout</em> option.) By default the loops are serialized.</p>
  </dd>
  <dt>
    <em>loop-timeout</em> (<strong>--loop-timeout=secs</strong>)
  </dt>
  <dd>
    <p>Some servers need to take an action from time to time. For example the Net::Daemon::Spooler attempts to empty its spooling queue every 5 minutes. If this option is set to a positive value (zero being the default), then the server will call its Loop method every \*(L"loop-timeout\*(R" seconds. Don't trust too much on the precision of the interval: It depends on a number of factors, in particular the execution time of the <em>Loop()</em> method. The loop is implemented by using the <em>select</em> function. If you need an exact interval, you should better try to use the <em>alarm()</em> function and a signal handler. (And don't forget to look at the <em>catchint</em> option!) It is recommended to use the <em>loop-child</em> option in conjunction with <em>loop-timeout</em>.</p>
  </dd>
  <dt>
    <em>mode</em> (<strong>--mode=modename</strong>)
  </dt>
  <dd>
    <p>The Net::Daemon server can run in three different modes, depending on the environment. If you are running Perl 5.005 and did compile it for threads, then the server will create a new thread for each connection. The thread will execute the server's <em>Run()</em> method and then terminate. This mode is the default, you can force it with \*(L"--mode=ithreads\*(R" or \*(L"--mode=threads\*(R". If threads are not available, but you have a working <em>fork()</em>, then the server will behave similar by creating a new process for each connection. This mode will be used automatically in the absence of threads or if you use the \*(L"--mode=fork\*(R" option. Finally there's a single-connection mode: If the server has accepted a connection, he will enter the <em>Run()</em> method. No other connections are accepted until the <em>Run()</em> method returns. This operation mode is useful if you have neither threads nor <em>fork()</em>, for example on the Macintosh. For debugging purposes you can force this mode with \*(L"--mode=single\*(R". When running in mode single, you can still handle multiple clients at a time by preforking multiple child processes. The number of childs is configured with the option \*(L"--childs\*(R".</p>
  </dd>
  <dt>
    <em>childs</em>
  </dt>
  <dd>
    <p>Use this parameter to let Net::Daemon run in prefork mode, which means it forks the number of childs processes you give with this parameter, and all child handle connections concurrently. The difference to fork mode is, that the child processes continue to run after a connection has terminated and are able to accept a new connection. This is useful for caching inside the childs process (e.g. DBI::ProxyServer connect_cached attribute)</p>
  </dd>
  <dt>
    <em>options</em>
  </dt>
  <dd>
    <p>Array ref of Command line options that have been passed to the server object via the <strong>new</strong> method.</p>
  </dd>
  <dt>
    <em>parent</em>
  </dt>
  <dd>
    <p>When creating an object with <strong>Clone</strong> the original object becomes the parent of the new object. Objects created with <strong>new</strong> usually don't have a parent, thus this attribute is not set.</p>
  </dd>
  <dt>
    <em>pidfile</em> (<strong>--pidfile=file</strong>)
  </dt>
  <dd>
    <p>(\s-1UNIX\s0 only) If this option is present, a \s-1PID\s0 file will be created at the given location.</p>
  </dd>
  <dt>
    <em>proto</em> (<strong>--proto=proto</strong>)
  </dt>
  <dd>
    <p>The transport layer to use, by default <em>tcp</em> or <em>unix</em> for a Unix socket. It is not yet possible to combine both.</p>
  </dd>
  <dt>
    <em>socket</em>
  </dt>
  <dd>
    <p>The socket that is connected to the client; passed as <strong></strong><strong>$client</strong><strong></strong> argument to the <strong>Clone</strong> method. If the server object was created with <strong>new</strong>, this attribute can be undef, as long as the <strong>Bind</strong> method isn't called. Sockets are assumed to be IO::Socket objects.</p>
  </dd>
  <dt>
    <em>user</em> (<strong>--user=uid</strong>)
  </dt>
  <dd>
    <p>After doing a <em>bind()</em>, change the real and effective \s-1UID\s0 to the given. This is usefull, if you want your server to bind to a privileged port (&lt;1024), but don't want the server to execute as root. See also the --group and the --chroot options. \s-1UID\s0's can be passed as group names or numeric values.</p>
  </dd>
  <dt>
    <em>version</em> (<strong>--version</strong>)
  </dt>
  <dd>
    <p>Supresses startup of the server; instead the version string will be printed and the program exits immediately.</p>
  </dd>

</dl>
<p>Note that most of these attributes (facility, mode, localaddr, localport, pidfile, version) are meaningfull only at startup. If you set them later, they will be simply ignored. As almost all attributes have appropriate defaults, you will typically use the <strong>localport</strong> attribute only.</p>
<h3>Command Line Parsing</h3>
<p>  my $optionsAvailable = Net::Daemon-&gt;Options();</p><p>  print Net::Daemon-&gt;Version(), "&#92;n";</p><p>  Net::Daemon-&gt;Usage();</p><p>The <strong>Options</strong> method returns a hash ref of possible command line options. The keys are option names, the values are again hash refs with the following keys:</p>
<dl class='dl-vertical'>
  <dt>
    template
  </dt>
  <dd>
    <p>An option template that can be passed to <strong>Getopt::Long::GetOptions</strong>.</p>
  </dd>
  <dt>
    description
  </dt>
  <dd>
    <p>A description of this option, as used in <strong>Usage</strong></p>
  </dd>

</dl>
<p>The <strong>Usage</strong> method prints a list of all possible options and returns. It uses the <strong>Version</strong> method for printing program name and version.</p>
<h3>Config File</h3>
<p>If the config file option is set in the command line options or in the in the \*(L"new\*(R" args, then the method</p><p>  $server-&gt;ReadConfigFile($file, $options, $args)</p><p>is invoked. By default the config file is expected to contain Perl source that returns a hash ref of options. These options override the \*(L"new\*(R" args and will in turn be overwritten by the command line options, as present in the $options hash ref.</p><p>A typical config file might look as follows, we use the DBI::ProxyServer as an example:</p><p>    # Load external modules; this is not required unless you use     # the chroot() option.     #require DBD::mysql;     #require DBD::CSV;</p><p>    {         # &apos;chroot&apos; =&gt; &apos;/var/dbiproxy&apos;,         &apos;facility&apos; =&gt; &apos;daemon&apos;,         &apos;pidfile&apos; =&gt; &apos;/var/dbiproxy/dbiproxy.pid&apos;,         &apos;user&apos; =&gt; &apos;nobody&apos;,         &apos;group&apos; =&gt; &apos;nobody&apos;,         &apos;localport&apos; =&gt; &apos;1003&apos;,         &apos;mode&apos; =&gt; &apos;fork&apos;</p><p>        # Access control         &apos;clients&apos; =&gt; [             # Accept the local             {                 &apos;mask&apos; =&gt; &apos;^192&#92;.168&#92;.1&#92;.&#92;d+$&apos;,                 &apos;accept&apos; =&gt; 1             },             # Accept myhost.company.com             {                 &apos;mask&apos; =&gt; &apos;^myhost&#92;.company&#92;.com$&apos;,                 &apos;accept&apos; =&gt; 1             }             # Deny everything else             {                 &apos;mask&apos; =&gt; &apos;.*&apos;,                 &apos;accept&apos; =&gt; 0             }         ]     }</p>
<h3>Access control</h3>
<p>The Net::Daemon package supports a host based access control scheme. By default access is open for anyone. However, if you create an attribute $self-&gt;{'clients'}, typically in the config file, then access control is disabled by default. For any connection the client list is processed: The clients attribute is an array ref to a list of hash refs. Any of the hash refs may contain arbitrary attributes, including the following:</p>
<dl class='dl-vertical'>
  <dt>
    mask
  </dt>
  <dd>
    <p>A Perl regular expression that has to match the clients \s-1IP\s0 number or its host name. The list is processed from the left to the right, whenever a 'mask' attribute matches, then the related hash ref is choosen as client and processing the client list stops.</p>
  </dd>
  <dt>
    accept
  </dt>
  <dd>
    <p>This may be set to true or false (default when omitting the attribute), the former means accepting the client.</p>
  </dd>

</dl>

<h3>Event logging</h3>
<p>  $server-&gt;Log($level, $format, @args);   $server-&gt;Debug($format, @args);   $server-&gt;Error($format, @args);   $server-&gt;Fatal($format, @args);</p><p>The <strong>Log</strong> method is an interface to \*(L"Sys::Syslog (3)\*(R" or \*(L"Win32::EventLog (3)\*(R". It's arguments are <em></em><strong>$level</strong><em></em>, a syslog level like <strong>debug</strong>, <strong>notice</strong> or <strong>err</strong>, a format string in the style of printf and the format strings arguments.</p><p>The <strong>Debug</strong> and <strong>Error</strong> methods are shorthands for calling <strong>Log</strong> with a level of debug and err, respectively. The <strong>Fatal</strong> method is like <strong>Error</strong>, except it additionally throws the given message as exception.</p><p>See <em>Net::Daemon::Log</em>\|(3) for details.</p>
<h3>Flow of control</h3>
<p>  $server-&gt;Bind();   # The following inside Bind():   if ($connection-&gt;Accept()) {       $connection-&gt;Run();   } else {       $connection-&gt;Log(&apos;err&apos;, &apos;Connection refused&apos;);   }</p><p>The <strong>Bind</strong> method is called by the application when the server should start. Typically this can be done right after creating the server object <strong></strong><strong>$server</strong><strong></strong>. <strong>Bind</strong> usually never returns, except in case of errors.</p><p>When a client connects, the server uses <strong>Clone</strong> to derive a connection object <strong></strong><strong>$connection</strong><strong></strong> from the server object. A new thread or process is created that uses the connection object to call your classes <strong>Accept</strong> method. This method is intended for host authorization and should return either \s-1FALSE\s0 (refuse the client) or \s-1TRUE\s0 (accept the client).</p><p>If the client is accepted, the <strong>Run</strong> method is called which does the true work. The connection is closed when <strong>Run</strong> returns and the corresponding thread or process exits.</p>
<h3>Error Handling</h3>
<p>All methods are supposed to throw Perl exceptions in case of errors.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTITHREADING CONSIDERATIONS</h2>
        <div class="sectioncontent">
<p>All methods are working with lexically scoped data and handle data only, the exception being the OpenLog method which is invoked before threading starts. Thus you are safe as long as you don't share handles between threads. I strongly recommend that your application behaves similar. (This doesn't apply to mode 'ithreads'.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>As an example we'll write a simple calculator server. After connecting to this server you may type expressions, one per line. The server evaluates the expressions and prints the result. (Note this is an example, in real life we'd never implement such a security hole. :-)</p><p>For the purpose of example we add a command line option <em>--base</em> that takes 'hex', 'oct' or 'dec' as values: The servers output will use the given base.</p><p>  # -*- perl -*-   #   # Calculator server   #   require 5.004;   use strict;</p><p>  require Net::Daemon;</p><p>  package Calculator;</p><p>  use vars qw($VERSION @ISA);   $VERSION = &apos;0.01&apos;;   @ISA = qw(Net::Daemon); # to inherit from Net::Daemon</p><p>  sub Version ($) { &apos;Calculator Example Server, 0.01&apos;; }</p><p>  # Add a command line option "--base"   sub Options ($) {       my($self) = @_;       my($options) = $self-&gt;SUPER::Options();       $options-&gt;{&apos;base&apos;} = { &apos;template&apos; =&gt; &apos;base=s&apos;,                              &apos;description&apos; =&gt; &apos;--base                  &apos;                                     . &apos;dec (default), hex or oct&apos;                               };       $options;   }</p><p>  # Treat command line option in the constructor   sub new ($$;$) {       my($class, $attr, $args) = @_;       my($self) = $class-&gt;SUPER::new($attr, $args);       if ($self-&gt;{&apos;parent&apos;}) {           # Called via Clone()           $self-&gt;{&apos;base&apos;} = $self-&gt;{&apos;parent&apos;}-&gt;{&apos;base&apos;};       } else {           # Initial call           if ($self-&gt;{&apos;options&apos;}  &&  $self-&gt;{&apos;options&apos;}-&gt;{&apos;base&apos;}) {               $self-&gt;{&apos;base&apos;} = $self-&gt;{&apos;options&apos;}-&gt;{&apos;base&apos;}           }       }       if (!$self-&gt;{&apos;base&apos;}) {           $self-&gt;{&apos;base&apos;} = &apos;dec&apos;;       }       $self;   }</p><p>  sub Run ($) {       my($self) = @_;       my($line, $sock);       $sock = $self-&gt;{&apos;socket&apos;};       while (1) {           if (!defined($line = $sock-&gt;getline())) {               if ($sock-&gt;error()) {                   $self-&gt;Error("Client connection error %s",                                $sock-&gt;error());               }               $sock-&gt;close();               return;           }           $line =~ s/&#92;s+$//; # Remove CRLF           my($result) = eval $line;           my($rc);           if ($self-&gt;{&apos;base&apos;} eq &apos;hex&apos;) {               $rc = printf $sock ("%x&#92;n", $result);           } elsif ($self-&gt;{&apos;base&apos;} eq &apos;oct&apos;) {               $rc = printf $sock ("%o&#92;n", $result);           } else {               $rc = printf $sock ("%d&#92;n", $result);           }           if (!$rc) {               $self-&gt;Error("Client connection error %s",                            $sock-&gt;error());               $sock-&gt;close();               return;           }       }   }</p><p>  package main;</p><p>  my $server = Calculator-&gt;new({&apos;pidfile&apos; =&gt; &apos;none&apos;,                                 &apos;localport&apos; =&gt; 2000}, &#92;@ARGV);   $server-&gt;Bind();</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KNOWN PROBLEMS</h2>
        <div class="sectioncontent">
<p>Most, or even any, known problems are related to the Sys::Syslog module which is by default used for logging events under Unix. I'll quote some examples:</p>
<dl class='dl-vertical'>
  <dt>
    Usage: Sys::Syslog::_PATH_LOG at ...
  </dt>
  <dd>
    <p>This problem is treated in perl bug 20000712.003. A workaround is changing line 277 of Syslog.pm to   my $syslog = &_PATH_LOG() || croak "_PATH_LOG not found in syslog.ph";</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>  Net::Daemon is Copyright (C) 1998, Jochen Wiedmann                                      Am Eisteich 9                                      72555 Metzingen                                      Germany</p><p>                                     Phone: +49 7123 14887                                      Email: joe@ispsoft.de</p><p>  All rights reserved.</p><p>  You may distribute this package under the terms of either the GNU   General Public License or the Artistic License, as specified in the   Perl README file.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Net::Daemon&hellip;</h2>
        <div class="sectioncontent">
<p><em>RPC::pServer</em>\|(3), <em>Netserver::Generic</em>\|(3), <em>Net::Daemon::Log</em>\|(3), <em>Net::Daemon::Test</em>\|(3)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Net::DPAP::Client::Image.3pm.html"><span aria-hidden="true">&larr;</span> Net::DPAP::Client::Image.3pm: Remote dpap image</a></li>
   <li class="next"><a href="Net::Daemon::Log.3pm.html">Net::Daemon::Log.3pm: Utility functions for logging <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

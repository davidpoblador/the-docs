<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Test::Assertions::Manual: A guide to using test::assertions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A guide to using test::assertions">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Test::Assertions::Manual (3pm) manual">
  <meta name="twitter:description" content="A guide to using test::assertions">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtest-assertions-perl-Test::Assertions::Manual-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Test::Assertions::Manual.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Test::Assertions::Manual (3pm) manual" />
  <meta property="og:description" content="A guide to using test::assertions" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtest-assertions-perl-Test::Assertions::Manual-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Test::Assertions::Manual<small> (3pm)</small></h1>
        <p class="lead">A guide to using test::assertions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Test::Assertions::Manual.3pm.html">
      <span itemprop="name">Test::Assertions::Manual: A guide to using test::assertions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtest-assertions-perl/">
      <span itemprop="name">libtest-assertions-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Test::Assertions::Manual.3pm.html">
      <span itemprop="name">Test::Assertions::Manual: A guide to using test::assertions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is a brief guide to how you can use the Test::Assertions module in your code and test scripts. The \*(C`Test::Assertions\*(C' documentation has a comprehensive list of options.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Unit testing</h2>
        <div class="sectioncontent">
<p>To use Test::Assertions for unit testing, import it with the argument \*(L"test\*(R":</p>
<pre>
        use Test::Assertions qw(test);
</pre>
<p>The output of Test::Assertions in test mode is suitable for collation with Test::Harness. Only the \s-1<em>ASSERT\s0()</em> and <em>plan()</em> routines can create any output - all the other routines simply return values.</p><h3>Planning tests</h3>
<p>Test::Assertions offers a \*(L"plan tests\*(R" syntax similar to Test::More:</p><p>        plan tests =&gt; 42;         # Which creates the output:         1..42</p><p>If you find having to increment the number at the top of your test script every time you add a test irritating, you can use the automatic, Do What I Mean, form:</p><p>        plan tests;</p><p>In this case, Test::Assertions will read your code and count the number of \s-1ASSERT\s0 statements and use this for the expected number of tests. A caveat is that it expects all your \s-1ASSERT\s0 statements to be executed once only, hence ASSERTs in if and foreach blocks will fool Test::Assertions and you'll have to maintain the count manually in these cases. Furthermore, it uses <em>caller()</em> to get the filename of the code so it may not work if you invoke your program with a relative filename and then change working directory before calling this automatic \*(L"plan tests;\*(R" form.</p><p>Test::Assertions offers a couple of additional functions - <em>only()</em> and <em>ignore()</em> to control which tests will be reported. Usage is as follows:</p><p>        ignore(2, 5) if($^O eq &apos;MsWin32&apos;);         only(1..10) unless($^O eq &apos;MsWin32&apos;);</p><p>Note that these won't stop the actual test code from being attempted, but the results won't be reported.</p>
<h3>Testing things</h3>
<p>The routines for constructing tests are deliberately \s-1ALL\s0 \s-1CAPS\s0 so you can discriminate at a glance between the test and what is being tested.  To check something does what expected, use \s-1ASSERT:\s0</p><p>        ASSERT(1 == 1);</p><p>This gives the output:</p><p>        ok 1</p><p>An optional 2nd arg may be supplied for a comment to label the test:</p><p>        ASSERT(1 == 1, "an example test");</p><p>This gives the output:</p><p>        ok 1 (an example test)</p><p>In the interest of brevity of documentation, I'll omit the 2nd argument from my examples below. For your real-world tests, labelling the output is strongly recommended so when something fails you know what it is.</p><p>If you are hopelessly addicted to invoking your tests with an <em>ok()</em> routine, Test::Assertions has a concession for Test::Simple/More junkies:</p><p>        use Test::Assertions qw(test/ok);         plan tests =&gt; 1;         ok(1, "ok() works just like ASSERT()");</p>
<h3>More complex tests with helper routines</h3>
<p>Most real-world unit tests will need to check data structures returned from an \s-1API\s0.  The \s-1<em>EQUAL\s0()</em> function compares two data structures deeply (a bit like Test::More's eq_array or eq_hash):</p><p>        ASSERT( EQUAL(&#92;@arr, [1,2,3]) );         ASSERT( EQUAL(&#92;%observed, &#92;%expected) );</p><p>For routines that return large strings or write to files (e.g. templating), you might want to have your expected output held externally in a file.  Test::Assertions provides a few routines to make this easy.  \s-1EQUALS_FILE\s0 compares a string to the contents of a file:</p><p>        ASSERT( EQUALS_FILE($returned, "expected.txt") );</p><p>Whereas \s-1FILES_EQUAL\s0 compares the contents of 2 files:</p><p>        $object_to_test-&gt;write_file("observed.txt");         ASSERT( FILES_EQUAL("observed.txt", "expected.txt") );         unlink("observed.txt"); #always clean up so state on 2nd run is same as 1st run</p><p>If your files contain serialized data structures, e.g. the output of Data::Dumper, you may wish to use <em>do()</em>, or <em>eval()</em> their contents, and use the \s-1<em>EQUAL\s0()</em> routine to compare the structures, rather than comparing the serialized forms directly.</p><p>        my $var1 = do(&apos;file1.datadump&apos;);         my $var2 = do(&apos;file2.datadump&apos;);         ASSERT( EQUAL($var1, $var2), &apos;serialized versions matched&apos; );</p><p>The \s-1MATCHES_FILE\s0 routine compares a string with regex that is read from a file, which is most useful if your string contains dates, timestamps, filepaths, or other items which might change from one run of the test to the next, or across different machines:</p><p>        ASSERT( MATCHES_FILE($string_to_examine, "expected.regex.txt") );</p><p>Another thing you are likely to want to test is code raising exceptions with <em>die()</em>.  The \s-1<em>DIED\s0()</em> function confirms if a coderef raises an exception:</p><p>        ASSERT( DIED(                 sub {                         $object_to_test-&gt;method(@bad_inputs);                 }         ));</p><p>The \s-1DIED\s0 routine doesn't clobber $@, so you can use this in your test description:</p><p>        ASSERT( DIED(                 sub {                         $object_to_test-&gt;method(@bad_inputs);                 }         ), "raises an exception - " . (chomp $@, $@));</p><p>Occasionally you'll want to check if a perl script simply compiles.  Whilst this is no substitute for writing a proper unit test for the script, sometimes it's useful:</p><p>        ASSERT( COMPILES("somescript.pl") );</p><p>An optional second argument forces the code to be compiled under 'strict':</p><p>        ASSERT( COMPILES("somescript.pl", 1) );</p><p>(normally you'll have this in your script anyway).</p>
<h3>Aggregating other tests together</h3>
<p>For complex systems you may have a whole tree of unit tests, corresponding to different areas of functionality of the system.  For example, there may be a set of tests corresponding to the expression evaluation sublanguage within a templating system.   Rather than simply aggregating everything with Test::Harness in one flat list, you may want to aggregate each subtree of related functionality so that the Test::Harness summarisation is across these higher-level units.</p><p>Test::Assertions provides two functions to aggregate the output of other tests.  These work on result strings (starting with \*(L"ok\*(R" or \*(L"not ok\*(R").  \s-1ASSESS\s0 is the lower-level routine working directly on result strings, \s-1ASSESS_FILE\s0 runs a unit test script and parses the output.  In a scalar context they return a summary result string:</p><p>        @results = (&apos;ok 1&apos;, &apos;not ok 2&apos;, &apos;A comment&apos;, &apos;ok 3&apos;);         print scalar ASSESS(&#92;@results);</p><p>would result in something like:</p><p>        not ok (1 errors in 3 tests)</p><p>This output is of course a suitable input to \s-1ASSESS\s0 so complex hierarchies may be created. In an array context, they return a boolean value and a description which is suitable for feeding into \s-1ASSERT\s0 (although \s-1ASSERT\s0's $;$ prototype means it will ignore the description) :</p><p>        ASSERT ASSESS_FILE("expr/set_1.t");         ASSERT ASSESS_FILE("expr/set_2.t");         ASSERT ASSESS_FILE("expr/set_3.t");</p><p>would generate output such as:</p><p>        ok 1         ok 2         ok 3</p><p>Finally Test::Assertions provides a helper routine to interpret result strings:</p><p>        ($bool, $description) = INTERPRET("not ok 4 (test four)");</p><p>would result in:</p><p>        $bool = 0;         $description = "test four";</p><p>which might be useful for writing your own custom collation code.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Using Test::Assertions for run-time checking</h2>
        <div class="sectioncontent">
<p>C programmers often use \s-1ASSERT\s0 macros to trap runtime \*(L"should never happen\*(R" errors in their code. You can use Test::Assertions to do this:</p><p>        use Test::Assertions qq(die);         $rv = some_function();         ASSERT($rv == 0, "some_function returned a non-zero value");</p><p>You can also import Test::Assertions with warn rather than die so that the code continues executing:</p><p>        use constant ASSERTIONS_MODE =&gt; $ENV{ENVIRONMENT} eq &apos;production&apos;? &apos;warn&apos; : &apos;die&apos;;         use Test::Assertions(ASSERTIONS_MODE);</p><p>Environment variables provide a nice way of switching compile-time behaviour from outside the process.</p><h3>Minimising overhead</h3>
<p>Importing Test::Assertions with no arguments results in \s-1ASSERT\s0 statements doing nothing, but unlike \s-1ASSERT\s0 macros in C where the preprocessor filters this out before compilation, there are 2 types of residual overhead:</p>
<dl class='dl-vertical'>
  <dt>
    Runtime overhead
  </dt>
  <dd>
    <p>When Test::Assertions is imported with no arguments, the \s-1ASSERT\s0 statement is aliased to an empty sub. There is a small overhead in executing this.  In practice, unless you do an \s-1ASSERT\s0 on every other line, or in a performance-critical loop, you're unlikely to notice the overhead compared to the other work that your code is doing.</p>
  </dd>
  <dt>
    Compilation overhead
  </dt>
  <dd>
    <p>The Test::Assertions module must be compiled even when it is imported with no arguments. Test::Assertions loads its helper modules on demand and avoids using pragmas to minimise its compilation overhead. Currently Test::Assertions does not go to more extreme measures to cut its compilation overhead in the interests of maintainability and ease of installation.</p>
  </dd>

</dl>
<p>Both can be minimised by using a constant:</p><p>        use constant ENABLE_ASSERTIONS =&gt; $ENV{ENABLE_ASSERTIONS};</p><p>        #Minimise compile-time overhead         if(ENABLE_ASSERTIONS) {                 require Test::Assertions;                 import Test::Assertions qq(die);         }</p><p>        $rv = some_function();</p><p>        #Eliminate runtime overhead         ASSERT($rv == 0, "some_function returned a non-zero value") if(ENABLE_ASSERTIONS);</p><p>Unlike Carp::Assert, Test::Assertions does not come with a \*(L"built-in\*(R" constant (\s-1DEBUG\s0 in the case of Carp::Assert). Define your own constant, attach it to your own compile-time logic (e.g. env vars) and call it whatever you like.</p>
<h3>How expensive is a null \s-1ASSERT\s0?</h3>
<p>Here's an indication of the overhead of calling \s-1ASSERT\s0 when Test::Assertions is imported with no arguments. A comparison is included with Carp::Assert just to show that it's in the same ballpark - we are not advocating one module over the other. As outlined above, using a constant to disable assertions is recommended in performance-critical code.</p><p>        #!/usr/local/bin/perl</p><p>        use Benchmark;         use Test::Assertions;         use Carp::Assert;         use constant ENABLE_ASSERTIONS =&gt; 0;</p><p>        #Compare null ASSERT to simple linear algebra statement         timethis(1e6, sub{                 <strong>ASSERT</strong>(1); #Test::Assertions         });         timethis(1e6, sub{                 <strong>assert</strong>(1); #Carp::Assert         });         timethis(1e6, sub{                 <strong>ASSERT</strong>(1) if ENABLE_ASSERTIONS;         });         timethis(1e6, sub{                 $x=$x*2 + 3;         });</p><p>Results on Sun E250 (with 2x400Mhz CPUs) running perl 5.6.1 on solaris 9:</p><p>        Test::Assertions:           timethis 1000000:  3 wallclock secs ( 3.88 usr +  0.00 sys =  3.88 CPU) @ 257731.96/s (n=1000000)         Carp::Assert:               timethis 1000000:  6 wallclock secs ( 6.08 usr +  0.00 sys =  6.08 CPU) @ 164473.68/s (n=1000000)         Test::Assertions + const:   timethis 1000000: -1 wallclock secs ( 0.07 usr +  0.00 sys =  0.07 CPU) @ 14285714.29/s (n=1000000) (warning: too few iterations for a reliable count)         some algebra:               timethis 1000000:  1 wallclock secs ( 2.50 usr +  0.00 sys =  2.50 CPU) @ 400000.00/s (n=1000000)</p><p>Results for 1.7Ghz pentium M running activestate perl 5.6.1 on win \s-1XP:\s0</p><p>        Test::Assertions:           timethis 1000000:  0 wallclock secs ( 0.42 usr +  0.00 sys =  0.42 CPU) @ 2380952.38/s (n=1000000)         Carp::Assert:               timethis 1000000:  0 wallclock secs ( 0.57 usr +  0.00 sys =  0.57 CPU) @ 1751313.49/s (n=1000000)         Test::Assertions + const:   timethis 1000000: -1 wallclock secs (-0.02 usr +  0.00 sys = -0.02 CPU) @ -50000000.00/s (n=1000000) (warning: too few iterations for a reliable count)         some algebra:               timethis 1000000:  0 wallclock secs ( 0.50 usr +  0.00 sys =  0.50 CPU) @ 1996007.98/s (n=1000000)</p>
<h3>How significant is the compile-time overhead?</h3>
<p>Here's an indication of the compile-time overhead for Test::Assertions v1.050 and Carp::Assert v0.18. The cost of running <em>import()</em> is also included.</p><p>        #!/usr/local/bin/perl</p><p>        use Benchmark;         use lib qw(../lib);</p><p>        timethis(3e2, sub {                 require Test::Assertions;                 delete $INC{"Test/Assertions.pm"};         });</p><p>        timethis(3e2, sub {                 require Test::Assertions;                 import Test::Assertions;                 delete $INC{"Test/Assertions.pm"};         });</p><p>        timethis(3e2, sub {                 require Carp::Assert;                 delete $INC{"Carp/Assert.pm"};         });</p><p>        timethis(3e2, sub {                 require Carp::Assert;                 import Carp::Assert;                 delete $INC{"Carp/Assert.pm"};         });</p><p>Results on Sun E250 (with 2x400Mhz CPUs) running perl 5.6.1 on solaris 9:</p><p>        Test::Assertions:           timethis 300:  6 wallclock secs ( 6.19 usr +  0.10 sys =  6.29 CPU) @ 47.69/s (n=300)         Test::Assertions + import:  timethis 300:  7 wallclock secs ( 6.56 usr +  0.03 sys =  6.59 CPU) @ 45.52/s (n=300)         Carp::Assert:               timethis 300:  3 wallclock secs ( 2.47 usr +  0.32 sys =  2.79 CPU) @ 107.53/s (n=300)         Carp::Assert + import:      timethis 300: 41 wallclock secs (40.58 usr +  0.32 sys = 40.90 CPU) @  7.33/s (n=300)</p><p>Results for 1.7Ghz pentium M running activestate perl 5.6.1 on win \s-1XP:\s0</p><p>        Test::Assertions:           timethis 300:  2 wallclock secs ( 1.45 usr +  0.21 sys =  1.66 CPU) @ 180.51/s (n=300)         Test::Assertions + import:  timethis 300:  2 wallclock secs ( 1.58 usr +  0.29 sys =  1.87 CPU) @ 160.26/s (n=300)         Carp::Assert:               timethis 300:  1 wallclock secs ( 0.99 usr +  0.26 sys =  1.25 CPU) @ 239.62/s (n=300)         Carp::Assert + import:      timethis 300:  6 wallclock secs ( 5.42 usr +  0.38 sys =  5.80 CPU) @ 51.74/s (n=300)</p><p>If using a constant to control compilation is not to your liking, you may want to experiment with SelfLoader or AutoLoader to cut down the compilation overhead further by delaying compilation of some of the subroutines in Test::Assertions (see SelfLoader and AutoLoader for more information) until the first time they are used.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>$Revision: 1.10 $ on $Date: 2005/05/04 15:56:39 $</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>John Alden &lt;cpan _at_ bbc _dot_ co _dot_ uk&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Test::Assertions.3pm.html"><span aria-hidden="true">&larr;</span> Test::Assertions.3pm: A simple set of building blocks for both unit and runtime testing</a></li>
   <li class="next"><a href="Test::Assertions::TestScript.3pm.html">Test::Assertions::TestScript.3pm: Base for test scripts <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

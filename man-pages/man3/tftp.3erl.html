<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>tftp: Trivial ftp</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Trivial ftp">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="tftp (3erl) manual">
  <meta name="twitter:description" content="Trivial ftp">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-tftp-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/tftp.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="tftp (3erl) manual" />
  <meta property="og:description" content="Trivial ftp" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-tftp-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">tftp<small> (3erl)</small></h1>
        <p class="lead">Trivial ftp</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/tftp.3erl.html">
      <span itemprop="name">tftp: Trivial ftp</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/tftp.3erl.html">
      <span itemprop="name">tftp: Trivial ftp</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is a complete implementation of the following IETF standards:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>RFC 1350, The TFTP Protocol (revision 2).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>RFC 2347, TFTP Option Extension.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>RFC 2348, TFTP Blocksize Option.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>RFC 2349, TFTP Timeout Interval and Transfer Size Options.</p>
  </dd>

</dl>
<p>The only feature that not is implemented in this release is the "netascii" transfer mode.</p><p>The <strong>start/1</strong> function starts a daemon process which listens for UDP packets on a port. When it receives a request for read or write it spawns a temporary server process which handles the actual transfer of the file.</p><p>On the client side the <strong>read_file/3</strong> and <strong>write_file/3</strong> functions spawns a temporary client process which establishes contact with a TFTP daemon and performs the actual transfer of the file.</p><p><em>tftp</em> uses a callback module to handle the actual file transfer. Two such callback modules are provided, <em>tftp_binary</em> and <em>tftp_file</em>. See <strong>read_file/3</strong> and <strong>write_file/3</strong> for more information about these. The user can also implement own callback modules, see <strong>CALLBACK FUNCTIONS</strong> below. A callback module provided by the user is registered using the <em>callback</em> option, see <strong>DATA TYPES</strong> below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TFTP SERVER SERVICE START/STOP </h2>
        <div class="sectioncontent">
<p>A TFTP server can be configured to start statically when starting the Inets application. Alternatively it can be started dynamically (when Inets already is started) by calling the Inets application API <em>inets:start(tftpd, ServiceConfig)</em>, or <em>inets:start(tftpd, ServiceConfig, How)</em>, see <strong>inets(3erl)</strong> for details. The <em>ServiceConfig</em> for TFTP is described below in the <strong>COMMON DATA TYPES</strong> section.</p><p>The TFTP server can be stopped using <em>inets:stop(tftpd, Pid)</em>, see <strong>inets(3erl)</strong> for details.</p><p>The TPFT client is of such a temporary nature that it is not handled as a service in the Inets service framework.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMON DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
      ServiceConfig = Options
      Options = [option()]
      option() -- see below

</pre>
<p>Most of the options are common for both the client and the server side, but some of them differs a little. Here are the available options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{debug, Level}</em>: <em>Level = none | error | warning | brief | normal | verbose | all</em></p><p>Controls the level of debug printouts. The default is <em>none</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{host, Host}</em>: <em>Host = hostname()</em> see <strong>inet(3erl)</strong></p><p>The name or IP address of the host where the TFTP daemon resides. This option is only used by the client.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{port, Port}</em>: <em>Port = int()</em></p><p>The TFTP port where the daemon listens. It defaults to the standardized number 69. On the server side it may sometimes make sense to set it to 0, which means that the daemon just will pick a free port (which one is returned by the <em>info/1</em> function).</p><p>If a socket has somehow already has been connected, the {udp, [{fd, integer()}]} option can be used to pass the open file descriptor to gen_udp. This can be automated a bit by using a command line argument stating the prebound file descriptor number. For example, if the Port is 69 and the file descriptor 22 has been opened by setuid_socket_wrap. Then the command line argument "-tftpd_69 22" will trigger the prebound file descriptor 22 to be used instead of opening port 69. The UDP option {udp, [{fd, 22}]} automatically be added. See init:get_argument/ about command line arguments and gen_udp:open/2 about UDP options.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{port_policy, Policy}</em>: <em>Policy = random | Port | {range, MinPort, MaxPort}</em></p><p><em>Port = MinPort = MaxPort = int()</em></p><p>Policy for the selection of the temporary port which is used by the server/client during the file transfer. It defaults to <em>random</em> which is the standardized policy. With this policy a randomized free port used. A single port or a range of ports can be useful if the protocol should pass through a firewall.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{udp, Options}</em>: <em>Options = [Opt]</em> see <strong>gen_udp:open/2</strong></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{use_tsize, Bool}</em>: <em>Bool = bool()</em></p><p>Flag for automated usage of the <em>tsize</em> option. With this set to true, the <em>write_file/3</em> client will determine the filesize and send it to the server as the standardized <em>tsize</em> option. A <em>read_file/3</em> client will just acquire filesize from the server by sending a zero <em>tsize</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{max_tsize, MaxTsize}</em>: <em>MaxTsize = int() | infinity</em></p><p>Threshold for the maximal filesize in bytes. The transfer will be aborted if the limit is exceeded. It defaults to <em>infinity</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{max_conn, MaxConn}</em>: <em>MaxConn = int() | infinity</em></p><p>Threshold for the maximal number of active connections. The daemon will reject the setup of new connections if the limit is exceeded. It defaults to <em>infinity</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{TftpKey, TftpVal}</em>: <em>TftpKey = string()</em></p><p><em>TftpVal = string()</em></p><p>The name and value of a TFTP option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{reject, Feature}</em>: <em>Feature = Mode | TftpKey</em></p><p><em> Mode = read | write</em></p><p><em> TftpKey = string()</em></p><p>Control which features that should be rejected. This is mostly useful for the server as it may restrict usage of certain TFTP options or read/write access.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{callback, {RegExp, Module, State}}</em>: <em>RegExp = string()</em></p><p><em>Module = atom()</em></p><p><em>State = term()</em></p><p>Registration of a callback module. When a file is to be transferred, its local filename will be matched to the regular expressions of the registered callbacks. The first matching callback will be used the during the transfer. See <strong>read_file/3</strong> and <strong>write_file/3</strong>.</p><p>The callback module must implement the <em>tftp</em> behavior, <strong>CALLBACK FUNCTIONS</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{logger, Module}</em>: <em>Module = module()()</em></p><p>Callback module for customized logging of error, warning and info messages. &gt;The callback module must implement the <em>tftp_logger</em> behavior, <strong>LOGGER FUNCTIONS</strong>. The default module is <em>tftp_logger</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{max_retries, MaxRetries}</em>: <em>MaxRetries = int()</em></p><p>Threshold for the maximal number of retries. By default the server/client will try to resend a message up to <em>5</em> times when the timeout expires.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> start(Options) -&gt; {ok, Pid} | {error, Reason}</p><p>Types:</p><p>Options = [option()]</p><p>Pid = pid()</p><p>Reason = term()</p><p>Starts a daemon process which listens for udp packets on a port. When it receives a request for read or write it spawns a temporary server process which handles the actual transfer of the (virtual) file.</p><p><strong></strong> read_file(RemoteFilename, LocalFilename, Options) -&gt; {ok, LastCallbackState} | {error, Reason}</p><p>Types:</p><p>RemoteFilename = string()</p><p>LocalFilename = binary | string()</p><p>Options = [option()]</p><p>LastCallbackState = term()</p><p>Reason = term()</p><p>Reads a (virtual) file <em>RemoteFilename</em> from a TFTP server.</p><p>If <em>LocalFilename</em> is the atom <em>binary</em>, <em>tftp_binary</em> is used as callback module. It concatenates all transferred blocks and returns them as one single binary in <em>LastCallbackState</em>.</p><p>If <em>LocalFilename</em> is a string and there are no registered callback modules, <em>tftp_file</em> is used as callback module. It writes each transferred block to the file named <em>LocalFilename</em> and returns the number of transferred bytes in <em>LastCallbackState</em>.</p><p>If <em>LocalFilename</em> is a string and there are registered callback modules, <em>LocalFilename</em> is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</p><p><strong></strong> write_file(RemoteFilename, LocalFilename, Options) -&gt; {ok, LastCallbackState} | {error, Reason}</p><p>Types:</p><p>RemoteFilename = string()</p><p>LocalFilename = binary() | string()</p><p>Options = [option()]</p><p>LastCallbackState = term()</p><p>Reason = term()</p><p>Writes a (virtual) file <em>RemoteFilename</em> to a TFTP server.</p><p>If <em>LocalFilename</em> is a binary, <em>tftp_binary</em> is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in <em>LastCallbackState</em>.</p><p>If <em>LocalFilename</em> is a string and there are no registered callback modules, <em>tftp_file</em> is used as callback module. It reads the file named <em>LocalFilename</em> block by block and returns the number of transferred bytes in <em>LastCallbackState</em>.</p><p>If <em>LocalFilename</em> is a string and there are registered callback modules, <em>LocalFilename</em> is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</p><p><strong></strong> info(daemons) -&gt; [{Pid, Options}]</p><p>Types:</p><p>Pid = [pid()()]</p><p>Options = [option()]</p><p>Reason = term()</p><p>Returns info about all TFTP daemon processes.</p><p><strong></strong> info(servers) -&gt; [{Pid, Options}]</p><p>Types:</p><p>Pid = [pid()()]</p><p>Options = [option()]</p><p>Reason = term()</p><p>Returns info about all TFTP server processes.</p><p><strong></strong> info(Pid) -&gt; {ok, Options} | {error, Reason}</p><p>Types:</p><p>Options = [option()]</p><p>Reason = term()</p><p>Returns info about a TFTP daemon, server or client process.</p><p><strong></strong> change_config(daemons, Options) -&gt; [{Pid, Result}]</p><p>Types:</p><p>Options = [option()]</p><p>Pid = pid()</p><p>Result = ok | {error, Reason}</p><p>Reason = term()</p><p>Changes config for all TFTP daemon processes.</p><p><strong></strong> change_config(servers, Options) -&gt; [{Pid, Result}]</p><p>Types:</p><p>Options = [option()]</p><p>Pid = pid()</p><p>Result = ok | {error, Reason}</p><p>Reason = term()</p><p>Changes config for all TFTP server processes.</p><p><strong></strong> change_config(Pid, Options) -&gt; Result</p><p>Types:</p><p>Pid = pid()</p><p>Options = [option()]</p><p>Result = ok | {error, Reason}</p><p>Reason = term()</p><p>Changes config for a TFTP daemon, server or client process</p><p><strong></strong> start() -&gt; ok | {error, Reason}</p><p>Types:</p><p>Reason = term()</p><p>Starts the Inets application.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACK FUNCTIONS</h2>
        <div class="sectioncontent">
<p>A <em>tftp</em> callback module should be implemented as a <em>tftp</em> behavior and export the functions listed below.</p><p>On the server side the callback interaction starts with a call to <em>open/5</em> with the registered initial callback state. <em>open/5</em> is expected to open the (virtual) file. Then either the <em>read/1</em> or <em>write/2</em> functions are invoked repeatedly, once per transferred block. At each function call the state returned from the previous call is obtained. When the last block has been encountered the <em>read/1</em> or <em>write/2</em> functions is expected to close the (virtual) file and return its last state. The <em>abort/3</em> function is only used in error situations. <em>prepare/5</em> is not used on the server side.</p><p>On the client side the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to <em>prepare/5</em> with the same arguments as <em>open/5</em> takes. <em>prepare/5</em> is expected to validate the TFTP options, suggested by the user and return the subset of them that it accepts. Then the options is sent to the server which will perform the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to the <em>open/5</em> function on the client side. On the client side the <em>open/5</em> function must accept all option as is or reject the transfer. Then the callback interaction follows the same pattern as described above for the server side. When the last block is encountered in <em>read/1</em> or <em>write/2</em> the returned state is forwarded to the user and returned from <em>read_file</em>/3 or <em>write_file/3</em>.</p><p>If a callback (which performs the file access in the TFTP server) takes too long time (more than the double TFTP timeout), the server will abort the connection and send an error reply to the client. This implies that the server will release resources attached to the connection faster than before. The server simply assumes that the client has given up.</p><p>If the TFTP server receives yet another request from the same client (same host and port) while it already has an active connection to the client, it will simply ignore the new request if the request is equal with the first one (same filename and options). This implies that the (new) client will be served by the already ongoing connection on the server side. By not setting up yet another connection, in parallel with the ongoing one, the server will consumer lesser resources.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> prepare(Peer, Access, Filename, Mode, SuggestedOptions, InitialState) -&gt; {ok, AcceptedOptions, NewState} | {error, {Code, Text}}</p><p>Types:</p><p>Peer = {PeerType, PeerHost, PeerPort}</p><p>PeerType = inet | inet6</p><p>PeerHost = ip_address()</p><p>PeerPort = integer()</p><p>Access = read | write</p><p>Filename = string()</p><p>Mode = string()</p><p>SuggestedOptions = AcceptedOptions = [{Key, Value}]</p><p> Key = Value = string()</p><p>InitialState = [] | [{root_dir, string()}]</p><p>NewState = term()</p><p>Code = undef | enoent | eacces | enospc</p><p> | badop | eexist | baduser | badopt</p><p> | int()</p><p>Text = string()</p><p>Prepares to open a file on the client side.</p><p>No new options may be added, but the ones that are present in <em>SuggestedOptions</em> may be omitted or replaced with new values in <em>AcceptedOptions</em>.</p><p>Will be followed by a call to <em>open/4</em> before any read/write access is performed. <em>AcceptedOptions</em> is sent to the server which replies with those options that it accepts. These will be forwarded to <em>open/4</em> as <em>SuggestedOptions</em>.</p><p><strong></strong> open(Peer, Access, Filename, Mode, SuggestedOptions, State) -&gt; {ok, AcceptedOptions, NewState} | {error, {Code, Text}}</p><p>Types:</p><p>Peer = {PeerType, PeerHost, PeerPort}</p><p>PeerType = inet | inet6</p><p>PeerHost = ip_address()</p><p>PeerPort = integer()</p><p>Access = read | write</p><p>Filename = string()</p><p>Mode = string()</p><p>SuggestedOptions = AcceptedOptions = [{Key, Value}]</p><p> Key = Value = string()</p><p>State = InitialState | term()</p><p> InitialState = [] | [{root_dir, string()}]</p><p>NewState = term()</p><p>Code = undef | enoent | eacces | enospc</p><p> | badop | eexist | baduser | badopt</p><p> | int()</p><p>Text = string()</p><p>Opens a file for read or write access.</p><p>On the client side where the <em>open/5</em> call has been preceded by a call to <em>prepare/5</em>, all options must be accepted or rejected.</p><p>On the server side, where there is no preceding <em>prepare/5</em> call, no new options may be added, but the ones that are present in <em>SuggestedOptions</em> may be omitted or replaced with new values in <em>AcceptedOptions</em>.</p><p><strong></strong> read(State) -&gt; {more, Bin, NewState} | {last, Bin, FileSize} | {error, {Code, Text}}</p><p>Types:</p><p>State = NewState = term()</p><p>Bin = binary()</p><p>FileSize = int()</p><p>Code = undef | enoent | eacces | enospc</p><p> | badop | eexist | baduser | badopt</p><p> | int()</p><p>Text = string()</p><p>Read a chunk from the file.</p><p>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors etc. In both cases there will be no more calls to any of the callback functions.</p><p><strong></strong> write(Bin, State) -&gt; {more, NewState} | {last, FileSize} | {error, {Code, Text}}</p><p>Types:</p><p>Bin = binary()</p><p>State = NewState = term()</p><p>FileSize = int()</p><p>Code = undef | enoent | eacces | enospc</p><p> | badop | eexist | baduser | badopt</p><p> | int()</p><p>Text = string()</p><p>Write a chunk to the file.</p><p>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors etc. In both cases there will be no more calls to any of the callback functions.</p><p><strong></strong> abort(Code, Text, State) -&gt; ok</p><p>Types:</p><p>Code = undef | enoent | eacces | enospc</p><p> | badop | eexist | baduser | badopt</p><p> | int()</p><p>Text = string()</p><p>State = term()</p><p>Invoked when the file transfer is aborted.</p><p>The callback function is expected to clean up its used resources after the aborted file transfer, such as closing open file descriptors etc. The function will not be invoked if any of the other callback functions returns an error, as it is expected that they already have cleaned up the necessary resources. It will however be invoked if the functions fails (crashes).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOGGER FUNCTIONS</h2>
        <div class="sectioncontent">
<p>A <em>tftp_logger</em> callback module should be implemented as a <em>tftp_logger</em> behavior and export the functions listed below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> error_msg(Format, Data) -&gt; ok | exit(Reason)</p><p>Types:</p><p>Format = string()</p><p>Data = [term()]</p><p>Reason = term()</p><p>Log an error message. See <em>error_logger:error_msg/2 for details.</em></p><p><strong></strong> warning_msg(Format, Data) -&gt; ok | exit(Reason)</p><p>Types:</p><p>Format = string()</p><p>Data = [term()]</p><p>Reason = term()</p><p>Log a warning message. See <em>error_logger:warning_msg/2 for details.</em></p><p><strong></strong> info_msg(Format, Data) -&gt; ok | exit(Reason)</p><p>Types:</p><p>Format = string()</p><p>Data = [term()]</p><p>Reason = term()</p><p>Log an info message. See <em>error_logger:info_msg/2 for details.</em></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="test_server_ctrl.3erl.html"><span aria-hidden="true">&larr;</span> test_server_ctrl.3erl: This module provides a low level interface to the test server.</a></li>
   <li class="next"><a href="timer.3erl.html">timer.3erl: Timer functions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

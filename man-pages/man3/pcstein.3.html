<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pcstein: Compute the eigenvectors of a symmetric tridiagonal matrix in parallel, using inverse iteration</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Compute the eigenvectors of a symmetric tridiagonal matrix in parallel, using inverse iteration">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pcstein (3) manual">
  <meta name="twitter:description" content="Compute the eigenvectors of a symmetric tridiagonal matrix in parallel, using inverse iteration">
  <meta name="twitter:image" content="https://www.carta.tech/images/scalapack-doc-pcstein-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pcstein.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pcstein (3) manual" />
  <meta property="og:description" content="Compute the eigenvectors of a symmetric tridiagonal matrix in parallel, using inverse iteration" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/scalapack-doc-pcstein-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pcstein<small> (3)</small></h1>
        <p class="lead">Compute the eigenvectors of a symmetric tridiagonal matrix in parallel, using inverse iteration</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pcstein.3.html">
      <span itemprop="name">pcstein: Compute the eigenvectors of a symmetric tridiagonal matrix in parallel, using inverse iteration</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/scalapack-doc/">
      <span itemprop="name">scalapack-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pcstein.3.html">
      <span itemprop="name">pcstein: Compute the eigenvectors of a symmetric tridiagonal matrix in parallel, using inverse iteration</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>SUBROUTINE PCSTEIN(</p>
  </dt>
  <dd>
    <p>N, D, E, M, W, IBLOCK, ISPLIT, ORFAC, Z, IZ, JZ, DESCZ, WORK, LWORK, IWORK, LIWORK, IFAIL, ICLUSTR, GAP, INFO )</p>
  </dd>
  <dt>
    <p>INTEGER</p>
  </dt>
  <dd>
    <p>INFO, IZ, JZ, LIWORK, LWORK, M, N</p>
  </dd>
  <dt>
    <p>REAL</p>
  </dt>
  <dd>
    <p>ORFAC</p>
  </dd>
  <dt>
    <p>INTEGER</p>
  </dt>
  <dd>
    <p>DESCZ( * ), IBLOCK( * ), ICLUSTR( * ), IFAIL( * ), ISPLIT( * ), IWORK( * )</p>
  </dd>
  <dt>
    <p>REAL</p>
  </dt>
  <dd>
    <p>D( * ), E( * ), GAP( * ), W( * ), WORK( * )</p>
  </dd>
  <dt>
    <p>COMPLEX</p>
  </dt>
  <dd>
    <p>Z( * )</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PURPOSE</h2>
        <div class="sectioncontent">
<p>PCSTEIN computes the eigenvectors of a symmetric tridiagonal matrix in parallel, using inverse iteration. The eigenvectors found correspond to user specified eigenvalues. PCSTEIN does not orthogonalize vectors that are on different processes. The extent of orthogonalization is controlled by the input parameter LWORK. Eigenvectors that are to be orthogonalized are computed by the same process. PCSTEIN decides on the allocation of work among the processes and then calls SSTEIN2 (modified LAPACK routine) on each individual process. If insufficient workspace is allocated, the expected orthogonalization may not be done.</p><p>Note : If the eigenvectors obtained are not orthogonal, increase</p>
<pre>
       LWORK and run the code again.
</pre>
<p>Notes</p><p>=====</p><p>Each global data object is described by an associated description vector.  This vector stores the information required to establish the mapping between an object element and its corresponding process and memory location.</p><p>Let A be a generic term for any 2D block cyclicly distributed array. Such a global array has an associated description vector DESCA. In the following comments, the character _ should be read as "of the global array".</p><p>NOTATION        STORED IN      EXPLANATION</p><p>--------------- -------------- -------------------------------------- DTYPE_A(global) DESCA( DTYPE_ )The descriptor type.  In this case,</p>
<pre>
                               DTYPE_A = 1.
</pre>
<p>CTXT_A (global) DESCA( CTXT_ ) The BLACS context handle, indicating</p>
<pre>
                               the BLACS process grid A is distribu-
                               ted over. The context itself is glo-
                               bal, but the handle (the integer
                               value) may vary.
</pre>
<p>M_A    (global) DESCA( M_ )    The number of rows in the global</p>
<pre>
                               array A.
</pre>
<p>N_A    (global) DESCA( N_ )    The number of columns in the global</p>
<pre>
                               array A.
</pre>
<p>MB_A   (global) DESCA( MB_ )   The blocking factor used to distribute</p>
<pre>
                               the rows of the array.
</pre>
<p>NB_A   (global) DESCA( NB_ )   The blocking factor used to distribute</p>
<pre>
                               the columns of the array.
</pre>
<p>RSRC_A (global) DESCA( RSRC_ ) The process row over which the first</p>
<pre>
                               row of the array A is distributed.
</pre>
<p>CSRC_A (global) DESCA( CSRC_ ) The process column over which the</p>
<pre>
                               first column of the array A is
                               distributed.
</pre>
<p>LLD_A  (local)  DESCA( LLD_ )  The leading dimension of the local</p>
<pre>
                               array.  LLD_A &gt;= MAX(1,LOCr(M_A)).
</pre>
<p>Let K be the number of rows or columns of a distributed matrix, and assume that its process grid has dimension p x q.</p><p>LOCr( K ) denotes the number of elements of K that a process would receive if K were distributed over the p processes of its process column.</p><p>Similarly, LOCc( K ) denotes the number of elements of K that a process would receive if K were distributed over the q processes of its process row.</p><p>The values of LOCr() and LOCc() may be determined via a call to the ScaLAPACK tool function, NUMROC:</p>
<pre>
        LOCr( M ) = NUMROC( M, MB_A, MYROW, RSRC_A, NPROW ),
        LOCc( N ) = NUMROC( N, NB_A, MYCOL, CSRC_A, NPCOL ).
</pre>
<p>An upper bound for these quantities may be computed by:</p>
<pre>
        LOCr( M ) &lt;= ceil( ceil(M/MB_A)/NPROW )*MB_A
</pre>

<pre>
        LOCc( N ) &lt;= ceil( ceil(N/NB_A)/NPCOL )*NB_A
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ARGUMENTS</h2>
        <div class="sectioncontent">
<p>P = NPROW * NPCOL is the total number of processes</p>
<dl class='dl-vertical'>
  <dt>
    <p>N       (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The order of the tridiagonal matrix T.  N &gt;= 0.</p>
  </dd>
  <dt>
    <p>D       (global input) REAL array, dimension (N)</p>
  </dt>
  <dd>
    <p>The n diagonal elements of the tridiagonal matrix T.</p>
  </dd>
  <dt>
    <p>E       (global input) REAL array, dimension (N-1)</p>
  </dt>
  <dd>
    <p>The (n-1) off-diagonal elements of the tridiagonal matrix T.</p>
  </dd>
  <dt>
    <p>M       (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The total number of eigenvectors to be found. 0 &lt;= M &lt;= N.</p>
  </dd>
  <dt>
    <p>W       (global input/global output) REAL array, dim (M)</p>
  </dt>
  <dd>
    <p>On input, the first M elements of W contain all the eigenvalues for which eigenvectors are to be computed. The eigenvalues should be grouped by split-off block and ordered from smallest to largest within the block (The output array W from PSSTEBZ with ORDER='b' is expected here). This array should be replicated on all processes. On output, the first M elements contain the input eigenvalues in ascending order.</p><p>Note : To obtain orthogonal vectors, it is best if eigenvalues are computed to highest accuracy ( this can be done by setting ABSTOL to the underflow threshold = SLAMCH('U') --- ABSTOL is an input parameter to PSSTEBZ )</p>
  </dd>
  <dt>
    <p>IBLOCK  (global input) INTEGER array, dimension (N)</p>
  </dt>
  <dd>
    <p>The submatrix indices associated with the corresponding eigenvalues in W -- 1 for eigenvalues belonging to the first submatrix from the top, 2 for those belonging to the second submatrix, etc. (The output array IBLOCK from PSSTEBZ is expected here).</p>
  </dd>
  <dt>
    <p>ISPLIT  (global input) INTEGER array, dimension (N)</p>
  </dt>
  <dd>
    <p>The splitting points, at which T breaks up into submatrices. The first submatrix consists of rows/columns 1 to <strong>ISPLIT</strong>(1), the second of rows/columns <strong>ISPLIT</strong>(1)+1 through <strong>ISPLIT</strong>(2), etc., and the NSPLIT-th consists of rows/columns ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N (The output array ISPLIT from PSSTEBZ is expected here.)</p>
  </dd>
  <dt>
    <p>ORFAC   (global input) REAL</p>
  </dt>
  <dd>
    <p>ORFAC specifies which eigenvectors should be orthogonalized. Eigenvectors that correspond to eigenvalues which are within ORFAC*||T|| of each other are to be orthogonalized. However, if the workspace is insufficient (see LWORK), this tolerance may be decreased until all eigenvectors to be orthogonalized can be stored in one process. No orthogonalization will be done if ORFAC equals zero. A default value of 10^-3 is used if ORFAC is negative. ORFAC should be identical on all processes.</p>
  </dd>
  <dt>
    <p>Z       (local output) COMPLEX array,</p>
  </dt>
  <dd>
    <p>dimension (DESCZ(DLEN_), N/npcol + NB) Z contains the computed eigenvectors associated with the specified eigenvalues. Any vector which fails to converge is set to its current iterate after MAXITS iterations ( See SSTEIN2 ). On output, Z is distributed across the P processes in block cyclic format.</p>
  </dd>
  <dt>
    <p>IZ      (global input) INTEGER</p>
  </dt>
  <dd>
    <p>Z's global row index, which points to the beginning of the submatrix which is to be operated on.</p>
  </dd>
  <dt>
    <p>JZ      (global input) INTEGER</p>
  </dt>
  <dd>
    <p>Z's global column index, which points to the beginning of the submatrix which is to be operated on.</p>
  </dd>
  <dt>
    <p>DESCZ   (global and local input) INTEGER array of dimension DLEN_.</p>
  </dt>
  <dd>
    <p>The array descriptor for the distributed matrix Z.</p>
  </dd>
  <dt>
    <p>WORK    (local workspace/global output) REAL array,</p>
  </dt>
  <dd>
    <p>dimension ( LWORK ) On output, <strong>WORK</strong>(1) gives a lower bound on the workspace ( LWORK ) that guarantees the user desired orthogonalization (see ORFAC). Note that this may overestimate the minimum workspace needed.</p>
  </dd>
  <dt>
    <p>LWORK   (local input) integer</p>
  </dt>
  <dd>
    <p>LWORK  controls the extent of orthogonalization which can be done. The number of eigenvectors for which storage is allocated on each process is NVEC = floor(( LWORK- max(5*N,NP00*MQ00) )/N). Eigenvectors corresponding to eigenvalue clusters of size NVEC - ceil(M/P) + 1 are guaranteed to be orthogonal ( the orthogonality is similar to that obtained from CSTEIN2). Note : LWORK  must be no smaller than: max(5*N,NP00*MQ00) + ceil(M/P)*N, and should have the same input value on all processes. It is the minimum value of LWORK input on different processes that is significant.</p><p>If LWORK = -1, then LWORK is global input and a workspace query is assumed; the routine only calculates the minimum and optimal size for all work arrays. Each of these values is returned in the first entry of the corresponding work array, and no error message is issued by PXERBLA.</p>
  </dd>
  <dt>
    <p>IWORK   (local workspace/global output) INTEGER array,</p>
  </dt>
  <dd>
    <p>dimension ( 3*N+P+1 ) On return, <strong>IWORK</strong>(1) contains the amount of integer workspace required. On return, the <strong>IWORK</strong>(2) through IWORK(P+2) indicate the eigenvectors computed by each process. Process I computes eigenvectors indexed IWORK(I+2)+1 thru' IWORK(I+3).</p>
  </dd>
  <dt>
    <p>LIWORK  (local input) INTEGER</p>
  </dt>
  <dd>
    <p>Size of array IWORK.  Must be &gt;= 3*N + P + 1</p><p>If LIWORK = -1, then LIWORK is global input and a workspace query is assumed; the routine only calculates the minimum and optimal size for all work arrays. Each of these values is returned in the first entry of the corresponding work array, and no error message is issued by PXERBLA.</p>
  </dd>
  <dt>
    <p>IFAIL   (global output) integer array, dimension (M)</p>
  </dt>
  <dd>
    <p>On normal exit, all elements of IFAIL are zero. If one or more eigenvectors fail to converge after MAXITS iterations (as in CSTEIN), then INFO &gt; 0 is returned. If mod(INFO,M+1)&gt;0, then for I=1 to mod(INFO,M+1), the eigenvector corresponding to the eigenvalue W(IFAIL(I)) failed to converge ( W refers to the array of eigenvalues on output ).</p><p>ICLUSTR (global output) integer array, dimension (2*P) This output array contains indices of eigenvectors corresponding to a cluster of eigenvalues that could not be orthogonalized due to insufficient workspace (see LWORK, ORFAC and INFO). Eigenvectors corresponding to clusters of eigenvalues indexed ICLUSTR(2*I-1) to ICLUSTR(2*I), I = 1 to INFO/(M+1), could not be orthogonalized due to lack of workspace. Hence the eigenvectors corresponding to these clusters may not be orthogonal. ICLUSTR is a zero terminated array --- ( ICLUSTR(2*K).NE.0 .AND. ICLUSTR(2*K+1).EQ.0 ) if and only if K is the number of clusters.</p>
  </dd>
  <dt>
    <p>GAP     (global output) REAL array, dimension (P)</p>
  </dt>
  <dd>
    <p>This output array contains the gap between eigenvalues whose eigenvectors could not be orthogonalized. The INFO/M output values in this array correspond to the INFO/(M+1) clusters indicated by the array ICLUSTR. As a result, the dot product between eigenvectors corresponding to the I^th cluster may be as high as ( O(n)*macheps ) / GAP(I).</p>
  </dd>
  <dt>
    <p>INFO    (global output) INTEGER</p>
  </dt>
  <dd>
    <p>= 0:  successful exit</p><p>&lt; 0:  If the i-th argument is an array and the j-entry had an illegal value, then INFO = -(i*100+j), if the i-th argument is a scalar and had an illegal value, then INFO = -i. &lt; 0 :  if INFO = -I, the I-th argument had an illegal value</p><p>&gt; 0 :  if mod(INFO,M+1) = I, then I eigenvectors failed to converge in MAXITS iterations. Their indices are stored in the array IFAIL. if INFO/(M+1) = I, then eigenvectors corresponding to I clusters of eigenvalues could not be orthogonalized due to insufficient workspace. The indices of the clusters are stored in the array ICLUSTR.</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pcsrscl.3.html"><span aria-hidden="true">&larr;</span> pcsrscl.3: Multiplie an n-element complex distributed vector sub( x ) by the real scalar 1/a</a></li>
   <li class="next"><a href="pctrcon.3.html">pctrcon.3: Estimate the reciprocal of the condition number of a triangular distributed matrix a(ia:ia+n-1,ja:ja+n-1), in either the 1-norm or the infinity-norm <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

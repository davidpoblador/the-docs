<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pdlahqr: I an auxiliary routine used to find the schur decomposition  and or eigenvalues of a matrix already in hessenberg form from  cols ilo to ihi</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="I an auxiliary routine used to find the schur decomposition  and or eigenvalues of a matrix already in hessenberg form from  cols ilo to ihi">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pdlahqr (3) manual">
  <meta name="twitter:description" content="I an auxiliary routine used to find the schur decomposition  and or eigenvalues of a matrix already in hessenberg form from  cols ilo to ihi">
  <meta name="twitter:image" content="https://www.carta.tech/images/scalapack-doc-pdlahqr-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pdlahqr.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pdlahqr (3) manual" />
  <meta property="og:description" content="I an auxiliary routine used to find the schur decomposition  and or eigenvalues of a matrix already in hessenberg form from  cols ilo to ihi" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/scalapack-doc-pdlahqr-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pdlahqr<small> (3)</small></h1>
        <p class="lead">I an auxiliary routine used to find the schur decomposition  and or eigenvalues of a matrix already in hessenberg form from  cols ilo to ihi</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pdlahqr.3.html">
      <span itemprop="name">pdlahqr: I an auxiliary routine used to find the schur decomposition  and or eigenvalues of a matrix already in hessenberg form from  cols ilo to ihi</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/scalapack-doc/">
      <span itemprop="name">scalapack-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pdlahqr.3.html">
      <span itemprop="name">pdlahqr: I an auxiliary routine used to find the schur decomposition  and or eigenvalues of a matrix already in hessenberg form from  cols ilo to ihi</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>SUBROUTINE PDLAHQR(</p>
  </dt>
  <dd>
    <p>WANTT, WANTZ, N, ILO, IHI, A, DESCA, WR, WI, ILOZ, IHIZ, Z, DESCZ, WORK, LWORK, IWORK, ILWORK, INFO )</p>
  </dd>
  <dt>
    <p>LOGICAL</p>
  </dt>
  <dd>
    <p>WANTT, WANTZ</p>
  </dd>
  <dt>
    <p>INTEGER</p>
  </dt>
  <dd>
    <p>IHI, IHIZ, ILO, ILOZ, ILWORK, INFO, LWORK, N, ROTN</p>
  </dd>
  <dt>
    <p>INTEGER</p>
  </dt>
  <dd>
    <p>DESCA( * ), DESCZ( * ), IWORK( * )</p>
  </dd>
  <dt>
    <p>DOUBLE</p>
  </dt>
  <dd>
    <p>PRECISION A( * ), WI( * ), WORK( * ), WR( * ), Z( * )</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PURPOSE</h2>
        <div class="sectioncontent">
<p>PDLAHQR is an auxiliary routine used to find the Schur decomposition</p>
<pre>
  and or eigenvalues of a matrix already in Hessenberg form from
  cols ILO to IHI.
</pre>
<p>Notes</p><p>=====</p><p>Each global data object is described by an associated description vector.  This vector stores the information required to establish the mapping between an object element and its corresponding process and memory location.</p><p>Let A be a generic term for any 2D block cyclicly distributed array. Such a global array has an associated description vector DESCA. In the following comments, the character _ should be read as "of the global array".</p><p>NOTATION        STORED IN      EXPLANATION</p><p>--------------- -------------- -------------------------------------- DTYPE_A(global) DESCA( DTYPE_ )The descriptor type.  In this case,</p>
<pre>
                               DTYPE_A = 1.
</pre>
<p>CTXT_A (global) DESCA( CTXT_ ) The BLACS context handle, indicating</p>
<pre>
                               the BLACS process grid A is distribu-
                               ted over. The context itself is glo-
                               bal, but the handle (the integer
                               value) may vary.
</pre>
<p>M_A    (global) DESCA( M_ )    The number of rows in the global</p>
<pre>
                               array A.
</pre>
<p>N_A    (global) DESCA( N_ )    The number of columns in the global</p>
<pre>
                               array A.
</pre>
<p>MB_A   (global) DESCA( MB_ )   The blocking factor used to distribute</p>
<pre>
                               the rows of the array.
</pre>
<p>NB_A   (global) DESCA( NB_ )   The blocking factor used to distribute</p>
<pre>
                               the columns of the array.
</pre>
<p>RSRC_A (global) DESCA( RSRC_ ) The process row over which the first</p>
<pre>
                               row of the array A is distributed.
</pre>
<p>CSRC_A (global) DESCA( CSRC_ ) The process column over which the</p>
<pre>
                               first column of the array A is
                               distributed.
</pre>
<p>LLD_A  (local)  DESCA( LLD_ )  The leading dimension of the local</p>
<pre>
                               array.  LLD_A &gt;= MAX(1,LOCr(M_A)).
</pre>
<p>Let K be the number of rows or columns of a distributed matrix, and assume that its process grid has dimension p x q.</p><p>LOCr( K ) denotes the number of elements of K that a process would receive if K were distributed over the p processes of its process column.</p><p>Similarly, LOCc( K ) denotes the number of elements of K that a process would receive if K were distributed over the q processes of its process row.</p><p>The values of LOCr() and LOCc() may be determined via a call to the ScaLAPACK tool function, NUMROC:</p>
<pre>
        LOCr( M ) = NUMROC( M, MB_A, MYROW, RSRC_A, NPROW ),
        LOCc( N ) = NUMROC( N, NB_A, MYCOL, CSRC_A, NPCOL ).
</pre>
<p>An upper bound for these quantities may be computed by:</p>
<pre>
        LOCr( M ) &lt;= ceil( ceil(M/MB_A)/NPROW )*MB_A
</pre>

<pre>
        LOCc( N ) &lt;= ceil( ceil(N/NB_A)/NPCOL )*NB_A
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ARGUMENTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>WANTT   (global input) LOGICAL</p>
  </dt>
  <dd>
    <p>= .TRUE. : the full Schur form T is required;</p><p>= .FALSE.: only eigenvalues are required.</p>
  </dd>
  <dt>
    <p>WANTZ   (global input) LOGICAL</p>
  </dt>
  <dd>
    <p>= .TRUE. : the matrix of Schur vectors Z is required;</p><p>= .FALSE.: Schur vectors are not required.</p>
  </dd>
  <dt>
    <p>N       (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The order of the Hessenberg matrix A (and Z if WANTZ). N &gt;= 0.</p>
  </dd>
  <dt>
    <p>ILO     (global input) INTEGER</p>
  </dt>
  <dd>
    <p>IHI     (global input) INTEGER It is assumed that A is already upper quasi-triangular in rows and columns IHI+1:N, and that A(ILO,ILO-1) = 0 (unless ILO = 1). PDLAHQR works primarily with the Hessenberg submatrix in rows and columns ILO to IHI, but applies transformations to all of H if WANTT is .TRUE.. 1 &lt;= ILO &lt;= max(1,IHI); IHI &lt;= N.</p>
  </dd>
  <dt>
    <p>A       (global input/output) DOUBLE PRECISION array, dimension</p>
  </dt>
  <dd>
    <p>(DESCA(LLD_),*) On entry, the upper Hessenberg matrix A. On exit, if WANTT is .TRUE., A is upper quasi-triangular in rows and columns ILO:IHI, with any 2-by-2 or larger diagonal blocks not yet in standard form. If WANTT is .FALSE., the contents of A are unspecified on exit.</p>
  </dd>
  <dt>
    <p>DESCA   (global and local input) INTEGER array of dimension DLEN_.</p>
  </dt>
  <dd>
    <p>The array descriptor for the distributed matrix A.</p>
  </dd>
  <dt>
    <p>WR      (global replicated output) DOUBLE PRECISION array,</p>
  </dt>
  <dd>
    <p>dimension (N) WI      (global replicated output) DOUBLE PRECISION array, dimension (N) The real and imaginary parts, respectively, of the computed eigenvalues ILO to IHI are stored in the corresponding elements of WR and WI. If two eigenvalues are computed as a complex conjugate pair, they are stored in consecutive elements of WR and WI, say the i-th and (i+1)th, with WI(i) &gt; 0 and WI(i+1) &lt; 0. If WANTT is .TRUE., the eigenvalues are stored in the same order as on the diagonal of the Schur form returned in A.  A may be returned with larger diagonal blocks until the next release.</p>
  </dd>
  <dt>
    <p>ILOZ    (global input) INTEGER</p>
  </dt>
  <dd>
    <p>IHIZ    (global input) INTEGER Specify the rows of Z to which transformations must be applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.</p>
  </dd>
  <dt>
    <p>Z       (global input/output) DOUBLE PRECISION array.</p>
  </dt>
  <dd>
    <p>If WANTZ is .TRUE., on entry Z must contain the current matrix Z of transformations accumulated by PDHSEQR, and on exit Z has been updated; transformations are applied only to the submatrix Z(ILOZ:IHIZ,ILO:IHI). If WANTZ is .FALSE., Z is not referenced.</p>
  </dd>
  <dt>
    <p>DESCZ   (global and local input) INTEGER array of dimension DLEN_.</p>
  </dt>
  <dd>
    <p>The array descriptor for the distributed matrix Z.</p>
  </dd>
  <dt>
    <p>WORK    (local output) DOUBLE PRECISION array of size LWORK</p>
  </dt>
  <dd>
    <p>(Unless LWORK=-1, in which case WORK must be at least size 1)</p>
  </dd>
  <dt>
    <p>LWORK   (local input) INTEGER</p>
  </dt>
  <dd>
    <p>WORK(LWORK) is a local array and LWORK is assumed big enough so that LWORK &gt;= 3*N + MAX( 2*MAX(DESCZ(LLD_),DESCA(LLD_)) + 2*LOCc(N), 7*Ceil(N/HBL)/LCM(NPROW,NPCOL)) + MAX( 2*N, (8*LCM(NPROW,NPCOL)+2)**2 ) If LWORK=-1, then <strong>WORK</strong>(1) gets set to the above number and the code returns immediately.</p>
  </dd>
  <dt>
    <p>IWORK   (global and local input) INTEGER array of size ILWORK</p>
  </dt>
  <dd>
    <p>This will hold some of the IBLK integer arrays. This is held as a place holder for a future release. Currently unreferenced.</p>
  </dd>
  <dt>
    <p>ILWORK  (local input) INTEGER</p>
  </dt>
  <dd>
    <p>This will hold the size of the IWORK array. This is held as a place holder for a future release. Currently unreferenced.</p>
  </dd>
  <dt>
    <p>INFO    (global output) INTEGER</p>
  </dt>
  <dd>
    <p>&lt; 0: parameter number -INFO incorrect or inconsistent</p><p>= 0: successful exit</p><p>&gt; 0: PDLAHQR failed to compute all the eigenvalues ILO to IHI in a total of 30*(IHI-ILO+1) iterations; if INFO = i, elements i+1:ihi of WR and WI contain those eigenvalues which have been successfully computed.</p><p>Logic: This algorithm is very similar to _LAHQR.  Unlike _LAHQR, instead of sending one double shift through the largest unreduced submatrix, this algorithm sends multiple double shifts and spaces them apart so that there can be parallelism across several processor row/columns.  Another critical difference is that this algorithm aggregrates multiple transforms together in order to apply them in a block fashion.</p><p>Important Local Variables: IBLK = The maximum number of bulges that can be computed. Currently fixed.  Future releases this won't be fixed. HBL  = The square block size (HBL=DESCA(MB_)=DESCA(NB_)) ROTN = The number of transforms to block together NBULGE = The number of bulges that will be attempted on the current submatrix. IBULGE = The current number of bulges started. K1(*),K2(*) = The current bulge loops from K1(*) to K2(*).</p><p>Subroutines: From LAPACK, this routine calls: DLAHQR     -&gt; Serial QR used to determine shifts and eigenvalues DLARFG     -&gt; Determine the Householder transforms</p><p>This ScaLAPACK, this routine calls: PDLACONSB  -&gt; To determine where to start each iteration DLAMSH     -&gt; Sends multiple shifts through a small submatrix to see how the consecutive subdiagonals change (if PDLACONSB indicates we can start a run in the middle) PDLAWIL    -&gt; Given the shift, get the transformation DLASORTE   -&gt; Pair up eigenvalues so that reals are paired. PDLACP3    -&gt; Parallel array to local replicated array copy & back. DLAREF     -&gt; Row/column reflector applier.  Core routine here. PDLASMSUB  -&gt; Finds negligible subdiagonal elements.</p><p>Current Notes and/or Restrictions: 1.) This code requires the distributed block size to be square and at least six (6); unlike simpler codes like LU, this algorithm is extremely sensitive to block size.  Unwise choices of too small a block size can lead to bad performance. 2.) This code requires A and Z to be distributed identically and have identical contxts.  A future version may allow Z to have a different contxt to 1D row map it to all nodes (so no communication on Z is necessary.) 3.) This release currently does not have a routine for resolving the Schur blocks into regular 2x2 form after this code is completed.  Because of this, a significant performance impact is required while the deflation is done by sometimes a single column of processors. 4.) This code does not currently block the initial transforms so that none of the rows or columns for any bulge are completed until all are started.  To offset pipeline start-up it is recommended that at least 2*LCM(NPROW,NPCOL) bulges are used (if possible) 5.) The maximum number of bulges currently supported is fixed at 32.  In future versions this will be limited only by the incoming WORK and IWORK array. 6.) The matrix A must be in upper Hessenberg form.  If elements below the subdiagonal are nonzero, the resulting transforms may be nonsimilar.  This is also true with the LAPACK routine DLAHQR. 7.) For this release, this code has only been tested for RSRC_=CSRC_=0, but it has been written for the general case. 8.) Currently, all the eigenvalues are distributed to all the nodes.  Future releases will probably distribute the eigenvalues by the column partitioning. 9.) The internals of this routine are subject to change. 10.) To optimize this for your architecture, try tuning DLAREF. 11.) This code has only been tested for WANTZ = .TRUE. and may behave unpredictably for WANTZ set to .FALSE.</p><p>Implemented by:  G. Henry, May 1, 1997</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pdlaevswp.3.html"><span aria-hidden="true">&larr;</span> pdlaevswp.3: Move the eigenvectors (potentially unsorted) from where they are computed, to a scalapack standard block cyclic array, sorted so that the corresponding eigenvalues are sorted</a></li>
   <li class="next"><a href="pdlahrd.3.html">pdlahrd.3: Reduce the first nb columns of a real general n-by-(n-k+1) distributed matrix a(ia:ia+n-1,ja:ja+n-k) so that elements below the k-th subdiagonal are zero <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

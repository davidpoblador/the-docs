<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libxmp: A tracker module player library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A tracker module player library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libxmp (3) manual">
  <meta name="twitter:description" content="A tracker module player library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxmp-dev-libxmp-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libxmp.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libxmp (3) manual" />
  <meta property="og:description" content="A tracker module player library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxmp-dev-libxmp-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libxmp<small> (3)</small></h1>
        <p class="lead">A tracker module player library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libxmp.3.html">
      <span itemprop="name">libxmp: A tracker module player library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxmp-dev/">
      <span itemprop="name">libxmp-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libxmp.3.html">
      <span itemprop="name">libxmp: A tracker module player library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>Libxmp is a module player library supporting many mainstream and obscure module formats including Protracker MOD, Scream Tracker III S3M and Impulse Tracker IT. Libxmp loads the module and renders the sound as linear PCM samples in a buffer at rate and format specified by the user, one frame at a time (standard modules usually play at 50 frames per second).</p><p>Possible applications for libxmp include stand-alone module players, module player plugins for other players, module information extractors, background music replayers for games and other applications, module-to-mp3 renderers, etc.</p><h3>Concepts</h3>
<ul>
<li><p><strong>Player context:</strong> Most libxmp functions require a handle that identifies the module player context. Each context is independent and multiple contexts can be defined simultaneously.</p></li><li><p><strong>Sequence:</strong> Each group of positions in the order list that loops over itself, also known as "subsong". Most modules have only one sequence, but some modules, especially modules used in games can have multiple sequences. "Hidden patterns" outside the main song are also listed as extra sequences, certain module authors such as Skaven commonly place extra patterns at the end of the module.</p></li><li><p><strong>State:</strong> <em>[Added in libxmp 4.2]</em> The player can be in one of three possible states: <em>unloaded</em>, <em>loaded</em>, or <em>playing</em>. The player is in unloaded state after context creation, changing to other states when a module is loaded or played.</p></li><li><p><strong>External sample mixer:</strong> <em>[Added in libxmp 4.2]</em> Special sound channels can be reserved using <em>xmp_start_smix()</em> to play module instruments or external samples. This is useful when libxmp is used to provide background music to games or other applications where sound effects can be played in response to events or user actions</p></li>
</ul>
<h3>A simple example</h3>
<p>This example loads a module, plays it at 44.1kHz and writes it to a raw sound file:</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;xmp.h&gt;

int main(int argc, char **argv)
{
    xmp_context c;
    struct xmp_frame_info mi;
    FILE *f;

    /* The output raw file */
    f = fopen("out.raw", "wb");
    if (f == NULL) {
        fprintf(stderr, "can&apos;t open output file&#92;n");
        exit(EXIT_FAILURE);
    }

    /* Create the player context */
    c = xmp_create_context();

    /* Load our module */
    if (xmp_load_module(c, argv[1]) != 0) {
        fprintf(stderr, "can&apos;t load module&#92;n");
        exit(EXIT_FAILURE);
    }

    /* Play the module */
    xmp_start_player(c, 44100, 0);
    while (xmp_play_frame(c) == 0) {
        xmp_get_frame_info(c, &mi);

        if (mi.loop_count &gt; 0)    /* exit before looping */
            break;

        fwrite(mi.buffer, mi.buffer_size, 1, f);  /* write audio data */
    }
    xmp_end_player(c);
    xmp_release_module(c);        /* unload module */
    xmp_free_context(c);          /* destroy the player context */

    fclose(f);

    exit(EXIT_SUCCESS);
}
</pre>
<p>A player context can load and play a single module at a time. Multiple contexts can be defined if needed.</p><p>Use <em>xmp_test_module()</em> to check if the file is a valid module and retrieve the module name and type. Use <em>xmp_load_module()</em> to load the module to memory. These two calls return 0 on success or &lt;0 in case of error. Error codes are:</p>
<pre>
-XMP_ERROR_INTERNAL   /* Internal error */
-XMP_ERROR_FORMAT     /* Unsupported module format */
-XMP_ERROR_LOAD       /* Error loading file */
-XMP_ERROR_DEPACK     /* Error depacking file */
-XMP_ERROR_SYSTEM     /* System error */
-XMP_ERROR_STATE      /* Incorrect player state */
</pre>
<p>If a system error occurs, the specific error is set in <strong>errno</strong>.</p><p>Parameters to <em>xmp_start_player()</em> are the sampling rate (up to 48kHz) and a bitmapped integer holding one or more of the following mixer flags:</p>
<pre>
XMP_MIX_8BIT          /* Mix to 8-bit instead of 16 */
XMP_MIX_UNSIGNED      /* Mix to unsigned samples */
XMP_MIX_MONO          /* Mix to mono instead of stereo */
XMP_MIX_NEAREST       /* Mix using nearest neighbor interpolation */
XMP_MIX_NOFILTER      /* Disable lowpass filter */
</pre>
<p>After <em>xmp_start_player()</em> is called, each call to <em>xmp_play_frame()</em> will render an audio frame. Call <em>xmp_get_frame_info()</em> to retrieve the buffer address and size. <em>xmp_play_frame()</em> returns 0 on success or -1 if replay should stop.</p><p>Use <em>xmp_end_player()</em>, <em>xmp_release_module()</em> and <em>xmp_free_context()</em> to release memory and end replay.</p>
<h3>SDL example</h3>
<p>To use libxmp with SDL, just provide a callback function that renders module data. The module will play when <strong>SDL_PauseAudio</strong>(0)</strong> is called:</p>
<pre>
#include &lt;SDL/SDL.h&gt;
#include &lt;xmp.h&gt;

static void fill_audio(void *udata, unsigned char *stream, int len)
{
    xmp_play_buffer(udata, stream, len, 0);
}

int sound_init(xmp_context ctx, int sampling_rate, int channels)
{
    SDL_AudioSpec a;

    a.freq = sampling_rate;
    a.format = (AUDIO_S16);
    a.channels = channels;
    a.samples = 2048;
    a.callback = fill_audio;
    a.userdata = ctx;

    if (SDL_OpenAudio(&a, NULL) &lt; 0) {
            fprintf(stderr, "%s&#92;n", SDL_GetError());
            return -1;
    }
}

int main(int argc, char **argv)
{
    xmp_context ctx;

    if ((ctx = xmp_create_context()) == NULL)
            return 1;

    sound_init(ctx, 44100, 2);
    xmp_load_module(ctx, argv[1]);
    xmp_start_player(ctx, 44100, 0);

    <strong>SDL_PauseAudio</strong>(0);

    sleep(10);              // Do something important here

    <strong>SDL_PauseAudio</strong>(1);

    xmp_end_player(ctx);
    xmp_release_module(ctx);
    xmp_free_context(ctx);

    SDL_CloseAudio();
    return 0;
}
</pre>
<p>SDL callbacks run in a separate thread, so don&apos;t forget to protect sections that manipulate module data with <strong>SDL_LockAudio()</strong> and <strong>SDL_UnlockAudio()</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API REFERENCE</h2>
        <div class="sectioncontent">
<h3>Version and player information</h3>

<h3>const char *xmp_version</h3>
<p>A string containing the library version, such as "4.0.0".</p>
<h3>const unsigned int xmp_vercode</h3>
<p>The library version encoded in a integer value. Bits 23-16 contain the major version number, bits 15-8 contain the minor version number, and bits 7-0 contain the release number.</p>
<h3>char **xmp_get_format_list()</h3>
<p>Query the list of supported module formats.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>a NULL-terminated array of strings containing the names of all supported module formats.</p>
  </dd>

</dl>

<h3>Context creation</h3>

<h3>xmp_context xmp_create_context()</h3>
<p>Create a new player context and return an opaque handle to be used in subsequent accesses to this context.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>

</dl>

<h3>void xmp_free_context(xmp_context c)</h3>
<p>Destroy a player context previously created using <em>xmp_create_context()</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>

</dl>

<h3>Module loading</h3>

<h3>int xmp_test_module(char *path, struct xmp_test_info *test_info)</h3>
<p>Test if a file is a valid module. Testing a file does not affect the current player context or any currently loaded module.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>path</strong></p>
  </dt>
  <dd>
    <p>pathname of the module to test.</p>
  </dd>
  <dt>
    <p><strong>test_info</strong></p>
  </dt>
  <dd>
    <p>NULL, or a pointer to a structure used to retrieve the module title and format if the file is a valid module. <strong>struct xmp_test_info</strong> is defined as:</p>
<pre>
struct xmp_test_info {
    char name[XMP_NAME_SIZE];      /* Module title */
    char type[XMP_NAME_SIZE];      /* Module format */
};
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if the file is a valid module, or a negative error code in case of error. Error codes can be <strong>-XMP_ERROR_FORMAT</strong> in case of an unrecognized file format, <strong>-XMP_ERROR_DEPACK</strong> if the file is compressed and uncompression failed, or <strong>-XMP_ERROR_SYSTEM</strong> in case of system error (the system error code is set in <strong>errno</strong>).</p>
  </dd>

</dl>

<h3>int xmp_load_module(xmp_context c, char *path)</h3>
<p>Load a module into the specified player context. (Certain player flags, such as <strong>XMP_PLAYER_SMPCTL</strong> and <strong>XMP_PLAYER_DEFPAN</strong>, must be set before loading the module, see <em>xmp_set_player()</em> for more information.)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>path</strong></p>
  </dt>
  <dd>
    <p>pathname of the module to load.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if sucessful, or a negative error code in case of error. Error codes can be <strong>-XMP_ERROR_FORMAT</strong> in case of an unrecognized file format, <strong>-XMP_ERROR_DEPACK</strong> if the file is compressed and uncompression failed, <strong>-XMP_ERROR_LOAD</strong> if the file format was recognized but the file loading failed, or <strong>-XMP_ERROR_SYSTEM</strong> in case of system error (the system error code is set in <strong>errno</strong>).</p>
  </dd>

</dl>

<h3>int xmp_load_module_from_memory(xmp_context c, void *mem, long size)</h3>
<p><em>[Added in libxmp 4.2]</em> Load a module from memory into the specified player context.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>mem</strong></p>
  </dt>
  <dd>
    <p>a pointer to the module file image in memory. Multi-file modules or compressed modules can&apos;t be loaded from memory.</p>
  </dd>
  <dt>
    <p><strong>size</strong></p>
  </dt>
  <dd>
    <p>the size of the module, or 0 if the size is unknown or not specified. If size is set to 0 certain module formats won&apos;t be recognized, the MD5 digest will not be set, and module-specific quirks won&apos;t be applied.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if sucessful, or a negative error code in case of error. Error codes can be <strong>-XMP_ERROR_FORMAT</strong> in case of an unrecognized file format, <strong>-XMP_ERROR_LOAD</strong> if the file format was recognized but the file loading failed, or <strong>-XMP_ERROR_SYSTEM</strong> in case of system error (the system error code is set in <strong>errno</strong>).</p>
  </dd>

</dl>

<h3>int xmp_load_module_from_file(xmp_context c, FILE *f, long size)</h3>
<p><em>[Added in libxmp 4.3]</em> Load a module from a stream into the specified player context.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>f</strong></p>
  </dt>
  <dd>
    <p>the file stream. On return, the stream position is undefined.</p>
  </dd>
  <dt>
    <p><strong>size</strong></p>
  </dt>
  <dd>
    <p>the size of the module, or 0 if the size is unknown or not specified. If size is set to 0 certain module formats won&apos;t be recognized, the MD5 digest will not be set, and module-specific quirks won&apos;t be applied.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if sucessful, or a negative error code in case of error. Error codes can be <strong>-XMP_ERROR_FORMAT</strong> in case of an unrecognized file format, <strong>-XMP_ERROR_LOAD</strong> if the file format was recognized but the file loading failed, or <strong>-XMP_ERROR_SYSTEM</strong> in case of system error (the system error code is set in <strong>errno</strong>).</p>
  </dd>

</dl>

<h3>void xmp_release_module(xmp_context c)</h3>
<p>Release memory allocated by a module from the specified player context.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>

</dl>

<h3>void xmp_scan_module(xmp_context c)</h3>
<p>Scan the loaded module for sequences and timing. Scanning is automatically performed by <em>xmp_load_module()</em> and this function should be called only if <em>xmp_set_player()</em> is used to change player timing (with parameter <strong>XMP_PLAYER_VBLANK</strong>) in libxmp 4.0.2 or older.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>

</dl>

<h3>void xmp_get_module_info(xmp_context c, struct xmp_module_info *info)</h3>
<p>Retrieve current module data.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>info</strong></p>
  </dt>
  <dd>
    <p>pointer to structure containing the module data. <strong>struct xmp_module_info</strong> is defined as follows:</p>
<pre>
struct xmp_module_info {
    unsigned char md5[16];          /* MD5 message digest */
    int vol_base;                   /* Volume scale */
    struct xmp_module *mod;         /* Pointer to module data */
    char *comment;                  /* Comment text, if any */
    int num_sequences;              /* Number of valid sequences */
    struct xmp_sequence *seq_data;  /* Pointer to sequence data */
};
</pre>
<p>Detailed module data is exposed in the <strong>mod</strong> field:</p>
<pre>
struct xmp_module {
    char name[XMP_NAME_SIZE];       /* Module title */
    char type[XMP_NAME_SIZE];       /* Module format */
    int pat;                        /* Number of patterns */
    int trk;                        /* Number of tracks */
    int chn;                        /* Tracks per pattern */
    int ins;                        /* Number of instruments */
    int smp;                        /* Number of samples */
    int spd;                        /* Initial speed */
    int bpm;                        /* Initial BPM */
    int len;                        /* Module length in patterns */
    int rst;                        /* Restart position */
    int gvl;                        /* Global volume */

    struct xmp_pattern **xxp;       /* Patterns */
    struct xmp_track **xxt;         /* Tracks */
    struct xmp_instrument *xxi;     /* Instruments */
    struct xmp_sample *xxs;         /* Samples */
    struct xmp_channel xxc[64];     /* Channel info */
    unsigned char xxo[XMP_MAX_MOD_LENGTH];  /* Orders */
};
</pre>
<p>See the header file for more information about pattern and instrument data.</p>
  </dd>

</dl>

<h3>Module playing</h3>

<h3>int xmp_start_player(xmp_context c, int rate, int format)</h3>
<p>Start playing the currently loaded module.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>rate</strong></p>
  </dt>
  <dd>
    <p>the sampling rate to use, in Hz (typically 44100). Valid values range from 8kHz to 48kHz.</p>
  </dd>
  <dt>
    <p><strong>flags</strong></p>
  </dt>
  <dd>
    <p>bitmapped configurable player flags, one or more of the following:</p>
<pre>
XMP_FORMAT_8BIT         /* Mix to 8-bit instead of 16 */
XMP_FORMAT_UNSIGNED     /* Mix to unsigned samples */
XMP_FORMAT_MONO         /* Mix to mono instead of stereo */
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if sucessful, or a negative error code in case of error. Error codes can be <strong>-XMP_ERROR_INTERNAL</strong> in case of a internal player error, <strong>-XMP_ERROR_INVALID</strong> if the sampling rate is invalid, or <strong>-XMP_ERROR_SYSTEM</strong> in case of system error (the system error code is set in <strong>errno</strong>).</p>
  </dd>

</dl>

<h3>int xmp_play_frame(xmp_context c)</h3>
<p>Play one frame of the module. Modules usually play at 50 frames per second. Use <em>xmp_get_frame_info()</em> to retrieve the buffer containing audio data.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if sucessful, <strong>-XMP_END</strong> if the module ended or was stopped, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>int xmp_play_buffer(xmp_context c, void *buffer, int size, int loop)</h3>
<p><em>[Added in libxmp 4.1]</em> Fill the buffer with PCM data up to the specified size. This is a convenience function that calls <em>xmp_play_frame()</em> internally to fill the user-supplied buffer. <strong>Don&apos;t call both</strong> xmp_play_frame() and xmp_play_buffer() in the same replay loop. If you don&apos;t need equally sized data chunks, <em>xmp_play_frame()</em> may result in better performance. Also note that silence is added at the end of a buffer if the module ends and no loop is to be performed.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>buffer</strong></p>
  </dt>
  <dd>
    <p>the buffer to fill with PCM data, or NULL to reset the internal state.</p>
  </dd>
  <dt>
    <p><strong>size</strong></p>
  </dt>
  <dd>
    <p>the buffer size in bytes.</p>
  </dd>
  <dt>
    <p><strong>loop</strong></p>
  </dt>
  <dd>
    <p>stop replay when the loop counter reaches the specified value, or 0 to disable loop checking.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if sucessful, <strong>-XMP_END</strong> if module was stopped or the loop counter was reached, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>void xmp_get_frame_info(xmp_context c, struct xmp_frame_info *info)</h3>
<p>Retrieve the current frame data.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>info</strong></p>
  </dt>
  <dd>
    <p>pointer to structure containing current frame data. <strong>struct xmp_frame_info</strong> is defined as follows:</p>
<pre>
struct xmp_frame_info {           /* Current frame information */
    int pos;            /* Current position */
    int pattern;        /* Current pattern */
    int row;            /* Current row in pattern */
    int num_rows;       /* Number of rows in current pattern */
    int frame;          /* Current frame */
    int speed;          /* Current replay speed */
    int bpm;            /* Current bpm */
    int time;           /* Current module time in ms */
    int total_time;     /* Estimated replay time in ms*/
    int frame_time;     /* Frame replay time in us */
    void *buffer;       /* Pointer to sound buffer */
    int buffer_size;    /* Used buffer size */
    int total_size;     /* Total buffer size */
    int volume;         /* Current master volume */
    int loop_count;     /* Loop counter */
    int virt_channels;  /* Number of virtual channels */
    int virt_used;      /* Used virtual channels */
    int sequence;       /* Current sequence */

    struct xmp_channel_info {     /* Current channel information */
        unsigned int period;      /* Sample period */
        unsigned int position;    /* Sample position */
        short pitchbend;          /* Linear bend from base note*/
        unsigned char note;       /* Current base note number */
        unsigned char instrument; /* Current instrument number */
        unsigned char sample;     /* Current sample number */
        unsigned char volume;     /* Current volume */
        unsigned char pan;        /* Current stereo pan */
        unsigned char reserved;   /* Reserved */
        struct xmp_event event;   /* Current track event */
    } channel_info[XMP_MAX_CHANNELS];
};
</pre>
<p>This function should be used to retrieve sound buffer data after <em>xmp_play_frame()</em> is called. Fields <strong>buffer</strong> and <strong>buffer_size</strong> contain the pointer to the sound buffer PCM data and its size. The buffer size will be no larger than <strong>XMP_MAX_FRAMESIZE</strong>.</p>
  </dd>

</dl>

<h3>void xmp_end_player(xmp_context c)</h3>
<p>End module replay and release player memory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>

</dl>

<h3>Player control</h3>

<h3>int xmp_next_position(xmp_context c)</h3>
<p>Skip replay to the start of the next position.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The new position index, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>int xmp_prev_position(xmp_context c)</h3>
<p>Skip replay to the start of the previous position.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The new position index, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>int xmp_set_position(xmp_context c, int pos)</h3>
<p>Skip replay to the start of the given position.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>pos</strong></p>
  </dt>
  <dd>
    <p>the position index to set.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The new position index, <strong>-XMP_ERROR_INVALID</strong> of the new position is invalid or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>void xmp_stop_module(xmp_context c)</h3>
<p>Stop the currently playing module.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>

</dl>

<h3>void xmp_restart_module(xmp_context c)</h3>
<p>Restart the currently playing module.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>

</dl>

<h3>int xmp_seek_time(xmp_context c, int time)</h3>
<p>Skip replay to the specified time.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>time</strong></p>
  </dt>
  <dd>
    <p>time to seek in milliseconds.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The new position index, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>int xmp_channel_mute(xmp_context c, int channel, int status)</h3>
<p>Mute or unmute the specified channel.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>channel</strong></p>
  </dt>
  <dd>
    <p>the channel to mute or unmute.</p>
  </dd>
  <dt>
    <p><strong>status</strong></p>
  </dt>
  <dd>
    <p>0 to mute channel, 1 to unmute or -1 to query the current channel status.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The previous channel status, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>int xmp_channel_vol(xmp_context c, int channel, int vol)</h3>
<p>Set or retrieve the volume of the specified channel.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>channel</strong></p>
  </dt>
  <dd>
    <p>the channel to set or get volume.</p>
  </dd>
  <dt>
    <p><strong>vol</strong></p>
  </dt>
  <dd>
    <p>a value from 0-100 to set the channel volume, or -1 to retrieve the current volume.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The previous channel volume, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>void xmp_inject_event(xmp_context c, int channel, struct xmp_event *event)</h3>
<p>Dynamically insert a new event into a playing module.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>channel</strong></p>
  </dt>
  <dd>
    <p>the channel to insert the new event.</p>
  </dd>
  <dt>
    <p><strong>event</strong></p>
  </dt>
  <dd>
    <p>the event to insert. <strong>struct xmp_event</strong> is defined as:</p>
<pre>
struct xmp_event {
    unsigned char note;   /* Note number (0 means no note) */
    unsigned char ins;    /* Patch number */
    unsigned char vol;    /* Volume (0 to basevol) */
    unsigned char fxt;    /* Effect type */
    unsigned char fxp;    /* Effect parameter */
    unsigned char f2t;    /* Secondary effect type */
    unsigned char f2p;    /* Secondary effect parameter */
    unsigned char _flag;  /* Internal (reserved) flags */
};
</pre>

  </dd>

</dl>

<h3>Player parameter setting</h3>

<h3>int xmp_set_instrument_path(xmp_context c, char *path)</h3>
<p>Set the path to retrieve external instruments or samples. Used by some formats (such as MED2) to read sample files from a different directory in the filesystem.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>path</strong></p>
  </dt>
  <dd>
    <p>the path to retrieve instrument files.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if the instrument path was correctly set, or <strong>-XMP_ERROR_SYSTEM</strong> in case of error (the system error code is set in <strong>errno</strong>).</p>
  </dd>

</dl>

<h3>int xmp_get_player(xmp_context c, int param)</h3>
<p>Retrieve current value of the specified player parameter.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>param</strong></p>
  </dt>
  <dd>
    <p>player parameter to get. Valid parameters are:</p>
<pre>
XMP_PLAYER_AMP      /* Amplification factor */
XMP_PLAYER_MIX      /* Stereo mixing */
XMP_PLAYER_INTERP   /* Interpolation type */
XMP_PLAYER_DSP      /* DSP effect flags */
XMP_PLAYER_FLAGS    /* Player flags */
XMP_PLAYER_CFLAGS   /* Player flags for current module*/
XMP_PLAYER_SMPCTL   /* Control sample loading */
XMP_PLAYER_VOLUME   /* Player master volume */
XMP_PLAYER_STATE    /* Current player state*/
XMP_PLAYER_DEFPAN   /* Default pan separation */
</pre>
<p>See <strong>xmp_set_player</strong> for the list of valid values for each parameter. Valid states are:</p>
<pre>
XMP_STATE_UNLOADED  /* Context created */
XMP_STATE_LOADED    /* Module loaded */
XMP_STATE_PLAYING   /* Module playing */
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The parameter value, or <strong>-XMP_ERROR_STATE</strong> if the parameter is not <strong>XMP_PLAYER_STATE</strong> and the player is not in playing state.</p>
  </dd>

</dl>

<h3>int xmp_set_player(xmp_context c, int param, int val)</h3>
<p>Set player parameter with the specified value.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>param</strong></p>
  </dt>
  <dd>
    <p>player parameter to set. Valid parameters are:</p>
<pre>
XMP_PLAYER_AMP      /* Amplification factor */
XMP_PLAYER_MIX      /* Stereo mixing */
XMP_PLAYER_INTERP   /* Interpolation type */
XMP_PLAYER_DSP      /* DSP effect flags */
XMP_PLAYER_FLAGS    /* Player flags */
XMP_PLAYER_CFLAGS   /* Player flags for current module*/
XMP_PLAYER_SMPCTL   /* Control sample loading */
XMP_PLAYER_VOLUME   /* Player master volume */
XMP_PLAYER_DEFPAN   /* Default pan separation */
</pre>

  </dd>
  <dt>
    <p><strong>val</strong></p>
  </dt>
  <dd>
    <p>the value to set. Valid values are:</p><ul>
<li><p>Amplification factor: ranges from 0 to 3. Default value is 1.</p></li><li><p>Stereo mixing: percentual left/right channel separation. Default is 70.</p></li><li><p>Interpolation type: can be one of the following values:</p>
<pre>
XMP_INTERP_NEAREST  /* Nearest neighbor */
XMP_INTERP_LINEAR   /* Linear (default) */
XMP_INTERP_SPLINE   /* Cubic spline */
</pre>
</li><li><p>DSP effects flags: enable or disable DSP effects. Valid effects are:</p>
<pre>
XMP_DSP_LOWPASS     /* Lowpass filter effect */
XMP_DSP_ALL         /* All effects */
</pre>
</li><li><p>Player flags: tweakable player parameters. Valid flags are:</p>
<pre>
XMP_FLAGS_VBLANK    /* Use vblank timing */
XMP_FLAGS_FX9BUG    /* Emulate Protracker 2.x FX9 bug */
XMP_FLAGS_FIXLOOP   /* Make sample loop value / 2 */
</pre>
</li><li><p><em>[Added in libxmp 4.1]</em> Player flags for current module: same flags as above but after applying module-specific quirks (if any).</p></li><li><p><em>[Added in libxmp 4.1]</em> Control sample load. Valid values are:</p>
<pre>
XMP_SMPCTL_SKIP     /* Don&apos;t load samples */
</pre>
<p>Disabling sample loading when loading a module allows allows computation of module duration without decompressing and loading large sample data, and is useful when duration information is needed for a module that won&apos;t be played immediately.</p></li><li><p><em>[Added in libxmp 4.2]</em> Set the player master volume, in a 0-100 scale.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if parameter was correctly set, <strong>-XMP_ERROR_INVALID</strong> if parameter or values are out of the valid ranges, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTERNAL SAMPLE MIXER API</h2>
        <div class="sectioncontent">
<p>Libxmp 4.2 includes a mini-API that can be used to add sound effects to games and similar applications, provided that you have a low latency sound system. It allows module instruments or external sample files in WAV format to be played in response to arbitrary events.</p><h3>Example</h3>
<p>This example using SDL loads a module and a sound sample, plays the module as background music, and plays the sample when a key is pressed:</p>
<pre>
#include &lt;SDL/SDL.h&gt;
#include &lt;xmp.h&gt;

static void fill_audio(void *udata, unsigned char *stream, int len)
{
    xmp_play_buffer(udata, stream, len, 0);
}

int sound_init(xmp_context ctx, int sampling_rate, int channels)
{
    SDL_AudioSpec a;

    a.freq = sampling_rate;
    a.format = (AUDIO_S16);
    a.channels = channels;
    a.samples = 2048;
    a.callback = fill_audio;
    a.userdata = ctx;

    if (SDL_OpenAudio(&a, NULL) &lt; 0) {
            fprintf(stderr, "%s&#92;n", SDL_GetError());
            return -1;
    }
}

int video_init()
{
    if (SDL_Init(SDL_INIT_VIDEO) &lt; 0) {
        fprintf(stderr, "%s&#92;n", SDL_GetError());
        return -1;
    }
    if (SDL_SetVideoMode(640, 480, 8, 0) == NULL) {
        fprintf(stderr, "%s&#92;n", SDL_GetError());
        return -1;
    }
    atexit(SDL_Quit);
}

int main(int argc, char **argv)
{
    SDL_Event event;
    xmp_context ctx;

    if ((ctx = xmp_create_context()) == NULL)
            return 1;

    video_init();
    sound_init(ctx, 44100, 2);

    xmp_start_smix(ctx, 1, 1);
    xmp_smix_load_sample(ctx, 0, "blip.wav");

    xmp_load_module(ctx, "music.mod");
    xmp_start_player(ctx, 44100, 0);
    xmp_set_player(ctx, XMP_PLAYER_VOLUME, 40);

    <strong>SDL_PauseAudio</strong>(0);

    while (1) {
        if (SDL_WaitEvent(&event)) {
            if (event.type == SDL_KEYDOWN) {
                if (event.key.keysym.sym == SDLK_ESCAPE)
                    break;
                xmp_smix_play_sample(ctx, 0, 60, 64, 0);
            }
        }
    }

    <strong>SDL_PauseAudio</strong>(1);

    xmp_end_player(ctx);
    xmp_release_module(ctx);
    xmp_free_context(ctx);
    xmp_end_smix(ctx);

    SDL_CloseAudio();
    return 0;
}
</pre>

<h3>SMIX API reference</h3>

<h3>int xmp_start_smix(xmp_context c, int nch, int nsmp)</h3>
<p>Initialize the external sample mixer subsystem with the given number of reserved channels and samples.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>nch</strong></p>
  </dt>
  <dd>
    <p>number of reserved sound mixer channels (1 to 64).</p>
  </dd>
  <dt>
    <p><strong>nsmp</strong></p>
  </dt>
  <dd>
    <p>number of external samples.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if the external sample mixer system was correctly initialized, <strong>-XMP_ERROR_INVALID</strong> in case of invalid parameters, <strong>-XMP_ERROR_STATE</strong> if the player is already in playing state, or <strong>-XMP_ERROR_SYSTEM</strong> in case of system error (the system error code is set in <strong>errno</strong>).</p>
  </dd>

</dl>

<h3>int xmp_smix_play_instrument(xmp_context c, int ins, int note, int vol, int chn)</h3>
<p>Play a note using an instrument from the currently loaded module in one of the reserved sound mixer channels.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>ins</strong></p>
  </dt>
  <dd>
    <p>the instrument to play.</p>
  </dd>
  <dt>
    <p><strong>note</strong></p>
  </dt>
  <dd>
    <p>the note number to play (60 = middle C).</p>
  </dd>
  <dt>
    <p><strong>vol</strong></p>
  </dt>
  <dd>
    <p>the volume to use (0 to the maximum volume value used by the current module.</p>
  </dd>
  <dt>
    <p><strong>chn</strong></p>
  </dt>
  <dd>
    <p>the reserved channe to use to play the instrument.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if the instrument was correctly played, <strong>-XMP_ERROR_INVALID</strong> in case of invalid parameters, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>int xmp_smix_play_sample(xmp_context c, int ins, int vol, int chn)</h3>
<p>Play an external sample file in one of the reserved sound channels. The sample must have been previously loaded using <em>xmp_smix_load_sample()</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>ins</strong></p>
  </dt>
  <dd>
    <p>the sample to play.</p>
  </dd>
  <dt>
    <p><strong>vol</strong></p>
  </dt>
  <dd>
    <p>the volume to use (0 to the maximum volume value used by the current module.</p>
  </dd>
  <dt>
    <p><strong>chn</strong></p>
  </dt>
  <dd>
    <p>the reserved channel to use to play the sample.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if the sample was correctly played, <strong>-XMP_ERROR_INVALID</strong> in case of invalid parameters, or <strong>-XMP_ERROR_STATE</strong> if the player is not in playing state.</p>
  </dd>

</dl>

<h3>int xmp_smix_channel_pan(xmp_context c, int chn, int pan)</h3>
<p>Set the reserved channel pan value.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>chn</strong></p>
  </dt>
  <dd>
    <p>the reserved channel number.</p>
  </dd>
  <dt>
    <p><strong>pan</strong></p>
  </dt>
  <dd>
    <p>the pan value to set (0 to 255).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if the pan value was set, or <strong>-XMP_ERROR_INVALID</strong> if parameters are invalid.</p>
  </dd>

</dl>

<h3>int xmp_smix_load_sample(xmp_context c, int num, char *path)</h3>
<p>Load a sound sample from a file. Samples should be in mono WAV (RIFF) format.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>num</strong></p>
  </dt>
  <dd>
    <p>the slot number of the external sample to load.</p>
  </dd>
  <dt>
    <p><strong>path</strong></p>
  </dt>
  <dd>
    <p>pathname of the file to load.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if the sample was correctly loaded, <strong>-XMP_ERROR_INVALID</strong> if the sample slot number is invalid (not reserved using <em>xmp_start_smix()</em>), <strong>-XMP_ERROR_FORMAT</strong> if the file format is unsupported, or <strong>-XMP_ERROR_SYSTEM</strong> in case of system error (the system error code is set in <strong>errno</strong>).</p>
  </dd>

</dl>

<h3>int xmp_smix_release_sample(xmp_context c, int num)</h3>
<p>Release memory allocated by an external sample in the specified player context.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>
  <dt>
    <p><strong>num</strong></p>
  </dt>
  <dd>
    <p>the sample slot number to release.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>Returns:</strong><strong></strong></p>
  </dt>
  <dd>
    <p>0 if memory was correctly released, or <strong>-XMP_ERROR_INVALID</strong> if the sample slot number is invalid.</p>
  </dd>

</dl>

<h3>void xmp_end_smix(xmp_context c)</h3>
<p>Deinitialize and resease memory used by the external sample mixer subsystem.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>Parameters:</strong><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>the player context handle.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Claudio Matsuoka and Hipolito Carraro Jr.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libxml.3.html"><span aria-hidden="true">&larr;</span> libxml.3: Library used to parse xml files</a></li>
   <li class="next"><a href="libxslt.3.html">libxslt.3: Library used to do xsl transformations on xml documents <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

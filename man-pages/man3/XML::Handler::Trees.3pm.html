<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::Handler::Trees: Perlsax handlers for building tree structures</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perlsax handlers for building tree structures">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::Handler::Trees (3pm) manual">
  <meta name="twitter:description" content="Perlsax handlers for building tree structures">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-handler-trees-perl-XML::Handler::Trees-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::Handler::Trees.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::Handler::Trees (3pm) manual" />
  <meta property="og:description" content="Perlsax handlers for building tree structures" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-handler-trees-perl-XML::Handler::Trees-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::Handler::Trees<small> (3pm)</small></h1>
        <p class="lead">Perlsax handlers for building tree structures</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Handler::Trees.3pm.html">
      <span itemprop="name">XML::Handler::Trees: Perlsax handlers for building tree structures</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-handler-trees-perl/">
      <span itemprop="name">libxml-handler-trees-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Handler::Trees.3pm.html">
      <span itemprop="name">XML::Handler::Trees: Perlsax handlers for building tree structures</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use XML::Handler::Trees;
  use XML::Parser::PerlSAX;

  my $p=XML::Parser::PerlSAX-&gt;new();
  my $h=XML::Handler::Tree-&gt;new();
  my $tree=$p-&gt;parse(Handler=&gt;$h,Source=&gt;{SystemId=&gt;&apos;file.xml&apos;});

  my $p=XML::Parser::PerlSAX-&gt;new();
  my $h=XML::Handler::EasyTree-&gt;new(Noempty=&gt;1);
  my $easytree=$p-&gt;parse(Handler=&gt;$h,Source=&gt;{SystemId=&gt;&apos;file.xml&apos;});

  my $p=XML::Parser::PerlSAX-&gt;new();
  my $h=XML::Handler::TreeBuilder-&gt;new();
  $h-&gt;<strong>store_pis</strong>(1);
  my $tree=$p-&gt;parse(Handler=&gt;$h,Source=&gt;{SystemId=&gt;&apos;file.xml&apos;});
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>XML::Handler::Trees provides three PerlSAX handler classes for building tree structures.  XML::Handler::Tree builds the same type of tree as the \*(L"Tree\*(R" style in XML::Parser.  XML::Handler::EasyTree builds the same type of tree as the \*(L"EasyTree\*(R" style added to XML::Parser by XML::Parser::EasyTree.  XML::Handler::TreeBuilder builds the same type of tree as Sean M. Burke's XML::TreeBuilder.  These classes make it possible to construct these tree structures from sources other than XML::Parser.</p><p>All three handlers can be driven by either PerlSAX 1 or PerlSAX 2 drivers.  In all cases, the <em>end_document()</em> method returns a reference to the constructed tree, which normally becomes the return value of the PerlSAX driver.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLASS XML::Handler::Tree</h2>
        <div class="sectioncontent">
<p>This handler builds the same type of tree structure as the \*(L"Tree\*(R" style in XML::Parser.  Some modules such as Dan Brian's XML::SimpleObject work with this type of tree.  See the documentation for XML::Parser for details.</p><h3>\s-1METHODS\s0</h3>
<p>Creates a handler object.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLASS XML::Handler::EasyTree</h2>
        <div class="sectioncontent">
<p>This handler builds a lightweight tree structure representing the \s-1XML\s0 document.  This structure is, at least in this author's opinion, easier to work with than the \*(L"standard\*(R" style of tree.  It is the same type of structure as built by XML::Parser when using XML::Parser::EasyTree, or by the get_simple_tree method in XML::Records.</p><p>The tree is returned as a reference to an array of tree nodes, each of which is a hash reference. All nodes have a 'type' key whose value is the type of the node: 'e' for element nodes, 't' for text nodes, and 'p' for processing instruction nodes. All nodes also have a 'content' key whose value is a reference to an array holding the element's child nodes for element nodes, the string value for text nodes, and the data value for processing instruction nodes. Element nodes also have an 'attrib' key whose value is a reference to a hash of attribute names and values and a 'name' key whose value is the element's name.  Processing instructions also have a 'target' key whose value is the \s-1PI\s0's target.</p><p>EasyTree nodes are ordinary Perl hashes and are not objects.  Contiguous runs of text are always returned in a single node.</p><p>The reason the parser returns an array reference rather than the root element's node is that an \s-1XML\s0 document can legally contain processing instructions outside the root element (the xml-stylesheet \s-1PI\s0 is commonly used this way).</p><p>If namespace information is available (only possible with PerlSAX 2), element and attribute names will be prefixed with their (possibly empty) namespace \s-1URI\s0 enclosed in curly brackets, and namespace prefixes will be stripped from names.</p><h3>\s-1METHODS\s0</h3>
<p>Creates a handler object.  Options can be provided hash-style:</p>
<dl class='dl-vertical'>
  <dt>
    Noempty
  </dt>
  <dd>
    <p>If this is set to a true value, text nodes consisting entirely of whitespace will not be stored in the tree.  The default is false.</p>
  </dd>
  <dt>
    Latin
  </dt>
  <dd>
    <p>If this is set to a true value, characters with Unicode values in the Latin-1 range (160-255) will be stored in the tree as Latin-1 rather than \s-1UTF-8\s0.  The default is false.</p>
  </dd>
  <dt>
    Searchable
  </dt>
  <dd>
    <p>If this is set to a true value, the parser will return a tree of XML::Handler::EasyTree::Searchable objects rather than bare array references, providing access to the navigation methods listed below.  The top-level node returned will be a dummy element node with a name of \*(L"_\|_TOPLEVEL_\|_\*(R". It is false by default.  Setting this option automatically enables the Noempty option.</p>
  </dd>

</dl>

<h3>XML::Handler::EasyTree::Searchable \s-1METHODS\s0</h3>
<p>If the Searchable option is set, all nodes in the tree will be XML::Handler::EasyTree::Searchable objects, which have the same structure as EasyTree nodes but also implement the following methods similar to those in XML::SimpleObject. Returns the name of the node. Ideally, it should return a \*(L"fully qualified\*(R" name, but it doesn't. Returns the text value associated with a node object.  Returns undef if the node has no text children or its first child is not a text node. Returns a child (elements only) of the object with the $name. For the case where there is more than one child that match $name, the array context semantics haven't been completely worked out: - in an array context, all children are returned. - in scalar context, the first child matching $name is returned. In a scalar context, The XML::Parser::SimpleObj class returns an object containing all the children matching $name, unless there is only one child in which case it returns that child (see commented code). I find that behavior confusing. Returns a list of all children (elements only) of the $obj that match $name \*(-- in the order in which they appeared in the original xml text. Returns a list of all the names of the objects children (elements only) in the order in which they appeared in the original text. Returns the string associated with the attribute of the object. If not found returns a null string. Returns a list (in no particular order) of the attribute names associated with the object Returns a textual representation (in xml form) of the object's hierarchy. Only elements are processed. The result will be in whatever character encoding the \s-1SAX\s0 driver delivered (which may not be the same encoding as the original source). Identical to <em>dump_tree()</em>, except that newline and indentation embellishments are added</p>
<h3>\s-1EXAMPLE\s0</h3>
<p> #! /usr/bin/perl -w</p><p> use XML::Handler::Trees;  use XML::Parser::PerlSAX;  use strict;</p><p> my $p=XML::Parser::PerlSAX-&gt;new();  my $h=XML::Handler::EasyTree-&gt;new( Searchable=&gt;1 );  my $easytree=$p-&gt;parse( Handler =&gt; $h, Source =&gt; { SystemId =&gt; &apos;systemB.xml&apos; } );</p><p> my $vme = $easytree-&gt;child( "vmesystem" );</p><p> print "&#92;n";  print "vmesystem config: ", $vme-&gt;attribute( "configuration_name" ), "&#92;n";</p><p> print "&#92;n";  print "vmesystem children: ", join( &apos;, &apos;, $vme-&gt;children_names() ), "&#92;n";</p><p> print "&#92;n";  print "gps model is ", $vme-&gt;child( "gps" )-&gt;child( "model" )-&gt;value(), "&#92;n";  my $gps = $vme-&gt;child( "gps" );  print "gps slot is ", $gps-&gt;child( "slot" )-&gt;value(), "&#92;n";</p><p> print "&#92;n";  print "reconstructed XML: &#92;n";  print $easytree-&gt;dump_tree(), "&#92;n";</p><p> # print "&#92;n";  # print "recontructed XML (pretty): &#92;n";  # print $easytree-&gt;pretty_dump_tree(), "&#92;n";</p><p> print "&#92;n";  exit;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLASS XML::Handler::TreeBuilder</h2>
        <div class="sectioncontent">
<p>This handler builds \s-1XML\s0 document trees constructed of XML::Element objects (XML::Element is a subclass of HTML::Element adapted for \s-1XML\s0).  To use it, XML::TreeBuilder and its prerequisite HTML::Tree need to be installed.  See the documentation for those modules for information on how to work with these tree structures.</p><h3>\s-1METHODS\s0</h3>
<p>Creates a handler which builds a tree rooted in an XML::Element. This determines whether comments will be stored in the tree (not all \s-1SAX\s0 drivers generate comment events).  Currently, this is off by default. This determines whether markup declarations will be stored in the tree. Currently, this is off by default.  The present implementation does not store markup declarations in any case; this method is provided for future use. This determines whether processing instructions will be stored in the tree. Currently, this is off (false) by default.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Eric Bohlman (ebohlman@omsdev.com)</p><p>PerlSAX 2 compatibility added by Matt Sergeant (matt@sergeant.org)</p><p>XML::EasyTree::Searchable written by Stuart McDow (smcdow@moontower.org)</p><p>Copyright (c) 2001 Eric Bohlman.</p><p>Portions of this code Copyright (c) 2001 Matt Sergeant.</p><p>Portions of this code Copyright (c) 2001 Stuart McDow.</p><p>All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::Handler::Trees&hellip;</h2>
        <div class="sectioncontent">
<p> L&lt;perl&gt;  L&lt;XML::Parser&gt;  L&lt;XML::SimpleObject&gt;  L&lt;XML::Parser::EasyTree&gt;  L&lt;XML::TreeBuilder&gt;  L&lt;XML::Element&gt;  L&lt;HTML::Element&gt;  L&lt;PerlSAX&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::Handler::Subs.3pm.html"><span aria-hidden="true">&larr;</span> XML::Handler::Subs.3pm: A perlsax handler base class for calling user-defined subs</a></li>
   <li class="next"><a href="XML::Handler::XMLWriter.3pm.html">XML::Handler::XMLWriter.3pm: A perlsax handler for writing readable xml <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

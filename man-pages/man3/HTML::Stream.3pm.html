<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTML::Stream: Html output stream class, and some markup utilities</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Html output stream class, and some markup utilities">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="HTML::Stream (3pm) manual">
  <meta name="twitter:description" content="Html output stream class, and some markup utilities">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhtml-stream-perl-HTML::Stream-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/HTML::Stream.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HTML::Stream (3pm) manual" />
  <meta property="og:description" content="Html output stream class, and some markup utilities" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhtml-stream-perl-HTML::Stream-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">HTML::Stream<small> (3pm)</small></h1>
        <p class="lead">Html output stream class, and some markup utilities</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::Stream.3pm.html">
      <span itemprop="name">HTML::Stream: Html output stream class, and some markup utilities</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhtml-stream-perl/">
      <span itemprop="name">libhtml-stream-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::Stream.3pm.html">
      <span itemprop="name">HTML::Stream: Html output stream class, and some markup utilities</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Here's small sample of some of the non-OO ways you can use this module:</p>
<pre>
      use HTML::Stream qw(:funcs);

      print html_tag(&apos;A&apos;, HREF=&gt;$link);
      print html_escape("&lt;&lt;Hello & welcome!&gt;&gt;");
</pre>
<p>And some of the \s-1OO\s0 ways as well:</p><p>      use HTML::Stream;       $HTML = new HTML::Stream &#92;*STDOUT;</p><p>      # The vanilla interface...       $HTML-&gt;tag(&apos;A&apos;, HREF=&gt;"$href");       $HTML-&gt;tag(&apos;IMG&apos;, SRC=&gt;"logo.gif", ALT=&gt;"LOGO");       $HTML-&gt;text($copyright);       $HTML-&gt;tag(&apos;_A&apos;);</p><p>      # The chocolate interface...       $HTML -&gt; A(HREF=&gt;"$href");       $HTML -&gt; IMG(SRC=&gt;"logo.gif", ALT=&gt;"LOGO");       $HTML -&gt; t($caption);       $HTML -&gt; _A;</p><p>      # The chocolate interface, with whipped cream...       $HTML -&gt; A(HREF=&gt;"$href")             -&gt; IMG(SRC=&gt;"logo.gif", ALT=&gt;"LOGO")             -&gt; t($caption)             -&gt; _A;</p><p>      # The strawberry interface...       output $HTML [A, HREF=&gt;"$href"],                    [IMG, SRC=&gt;"logo.gif", ALT=&gt;"LOGO"],                    $caption,                    [_A];</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>HTML::Stream</strong> module provides you with an object-oriented (and subclassable) way of outputting \s-1HTML\s0.  Basically, you open up an \*(L"\s-1HTML\s0 stream\*(R" on an existing filehandle, and then do all of your output to the \s-1HTML\s0 stream.  You can intermix HTML-stream-output and ordinary-print-output, if you like.</p><p>There's even a small built-in subclass, <strong>HTML::Stream::Latin1</strong>, which can handle Latin-1 input right out of the box.   But all in good time...</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION (the Neapolitan dessert special)</h2>
        <div class="sectioncontent">
<h3>Function interface</h3>
<p>Let's start out with the simple stuff. This module provides a collection of non-OO utility functions for escaping \s-1HTML\s0 text and producing \s-1HTML\s0 tags, like this:</p><p>    use HTML::Stream qw(:funcs);        # imports functions from @EXPORT_OK</p><p>    print html_tag(A, HREF=&gt;$url);     print &apos;&copy; 1996 by&apos;, html_escape($myname), &apos;!&apos;;     print html_tag(&apos;/A&apos;);</p><p>By the way: that last line could be rewritten as:</p><p>    print html_tag(_A);</p><p>And if you need to get a parameter in your tag that doesn't have an associated value, supply the <em>undefined</em> value (<em>not</em> the empty string!):</p><p>    print html_tag(TD, NOWRAP=&gt;undef, ALIGN=&gt;&apos;LEFT&apos;);</p><p>         &lt;TD NOWRAP ALIGN=LEFT&gt;</p><p>    print html_tag(IMG, SRC=&gt;&apos;logo.gif&apos;, ALT=&gt;&apos;&apos;);</p><p>         &lt;IMG SRC="logo.gif" ALT=""&gt;</p><p>There are also some routines for reversing the process, like:</p><p>    $text = "This &lt;i&gt;isn&apos;t&lt;/i&gt; &quot;fun&quot;...";     print html_unmarkup($text);</p><p>         This isn&apos;t &quot;fun&quot;...</p><p>    print html_unescape($text);</p><p>         This isn&apos;t "fun"...</p><p><em>Yeah, yeah, yeah</em>, I hear you cry.  <em>We've seen this stuff before.</em> But wait!  There's more...</p>
<h3>\s-1OO\s0 interface, vanilla</h3>
<p>Using the function interface can be tedious... so we also provide an <strong>\*(L"\s-1HTML\s0 output stream\*(R"</strong> class.  Messages to an instance of that class generally tell that stream to output some \s-1HTML\s0.  Here's the above example, rewritten using \s-1HTML\s0 streams:</p><p>    use HTML::Stream;     $HTML = new HTML::Stream &#92;*STDOUT;</p><p>    $HTML-&gt;tag(A, HREF=&gt;$url);     $HTML-&gt;ent(&apos;copy&apos;);     $HTML-&gt;text(" 1996 by $myname!");     $HTML-&gt;tag(_A);</p><p>As you've probably guessed:</p><p>    text()   Outputs some text, which will be HTML-escaped.</p><p>    tag()    Outputs an ordinary tag, like &lt;A&gt;, possibly with parameters.              The parameters will all be HTML-escaped automatically.</p><p>    ent()    Outputs an HTML entity, like the &copy; or &lt; .              You mostly don&apos;t need to use it; you can often just put the              Latin-1 representation of the character in the text().</p><p>You might prefer to use \*(C`t()\*(C' and \*(C`e()\*(C' instead of \*(C`text()\*(C' and \*(C`ent()\*(C': they're absolutely identical, and easier to type:</p><p>    $HTML -&gt; tag(A, HREF=&gt;$url);     $HTML -&gt; e(&apos;copy&apos;);     $HTML -&gt; t(" 1996 by $myname!");     $HTML -&gt; tag(_A);</p><p>Now, it wouldn't be nice to give you those \*(C`text()\*(C' and \*(C`ent()\*(C' shortcuts without giving you one for \*(C`tag()\*(C', would it?  Of course not...</p>
<h3>\s-1OO\s0 interface, chocolate</h3>
<p>The known \s-1HTML\s0 tags are even given their own <strong>tag-methods,</strong> compiled on demand.  The above code could be written even more compactly as:</p><p>    $HTML -&gt; A(HREF=&gt;$url);     $HTML -&gt; e(&apos;copy&apos;);     $HTML -&gt; t(" 1996 by $myname!");     $HTML -&gt; _A;</p><p>As you've probably guessed:</p><p>    A(HREF=&gt;$url)   ==   tag(A, HREF=&gt;$url)   ==   &lt;A HREF="/the/url"&gt;     _A              ==   tag(_A)              ==   &lt;/A&gt;</p><p>All of the autoloaded \*(L"tag-methods\*(R" use the tagname in <em>all-uppercase</em>. A "_" prefix on any tag-method means that an end-tag is desired. The "_" was chosen for several reasons: (1) it's short and easy to type, (2) it doesn't produce much visual clutter to look at, (3) \*(C`_TAG\*(C' looks a little like \*(C`/TAG\*(C' because of the straight line.</p><ul>
<li><p><em>I know, I know... it looks like a private method.</em> You get used to it.  Really.</p></li>
</ul><p>I should stress that this module will only auto-create tag methods for <strong>known</strong> \s-1HTML\s0 tags.  So you're protected from typos like this (which will cause a fatal exception at run-time):</p><p>    $HTML -&gt; IMGG(SRC=&gt;$src);</p><p>(You're not yet protected from illegal tag parameters, but it's a start, ain't it?)</p><p>If you need to make a tag known (sorry, but this is currently a <em>global</em> operation, and not stream-specific), do this:</p><p>    accept_tag HTML::Stream &apos;MARQUEE&apos;;       # for you MSIE fans...</p><p><strong>Note: there is no corresponding \*(L"reject_tag\*(R".</strong>  I thought and thought about it, and could not convince myself that such a method would do anything more useful than cause other people's modules to suddenly stop working because some bozo function decided to reject the \*(C`FONT\*(C' tag.</p>
<h3>\s-1OO\s0 interface, with whipped cream</h3>
<p>In the grand tradition of \*(C+, output method chaining is supported in both the Vanilla Interface and the Chocolate Interface. So you can (and probably should) write the above code as:</p><p>    $HTML -&gt; A(HREF=&gt;$url)           -&gt; e(&apos;copy&apos;) -&gt; t(" 1996 by $myname!")           -&gt; _A;</p><p><em>But wait!  Neapolitan ice cream has one more flavor...</em></p>
<h3>\s-1OO\s0 interface, strawberry</h3>
<p>I was jealous of the compact syntax of HTML::AsSubs, but I didn't want to worry about clogging the namespace with a lot of functions like p(), a(), etc. (especially when markup-functions like <em>tr()</em> conflict with existing Perl functions).  So I came up with this:</p><p>    output $HTML [A, HREF=&gt;$url], "Here&apos;s my $caption", [_A];</p><p>Conceptually, arrayrefs are sent to \*(C`html_tag()\*(C', and strings to \*(C`html_escape()\*(C'.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADVANCED TOPICS</h2>
        <div class="sectioncontent">
<h3>Auto-formatting and inserting newlines</h3>
<p><em>Auto-formatting</em> is the name I give to the Chocolate Interface feature whereby newlines (and maybe, in the future, other things) are inserted before or after the tags you output in order to make your \s-1HTML\s0 more readable.  So, by default, this:</p><p>    $HTML -&gt; HTML           -&gt; HEAD           -&gt; TITLE -&gt; t("Hello!") -&gt; _TITLE           -&gt; _HEAD           -&gt; BODY(BGCOLOR=&gt;&apos;#808080&apos;);</p><p>Actually produces this:</p><p>    &lt;HTML&gt;&lt;HTML&gt;     &lt;HEAD&gt;     &lt;TITLE&gt;Hello!&lt;/TITLE&gt;     &lt;/HEAD&gt;     &lt;BODY BGCOLOR="#808080"&gt;</p><p><strong>To turn off autoformatting altogether</strong> on a given HTML::Stream object, use the \*(C`auto_format()\*(C' method:</p><p>    $HTML-&gt;<strong>auto_format</strong>(0);        # stop autoformatting!</p><p><strong>To change whether a newline is automatically output</strong> before/after the begin/end form of a tag at a <strong>global</strong> level, use \*(C`set_tag()\*(C':</p><p>    HTML::Stream-&gt;set_tag(&apos;B&apos;, Newlines=&gt;15);   # 15 means "&#92;n&lt;B&gt;&#92;n &#92;n&lt;/B&gt;&#92;n"     HTML::Stream-&gt;set_tag(&apos;I&apos;, Newlines=&gt;7);    # 7 means  "&#92;n&lt;I&gt;&#92;n &#92;n&lt;/I&gt;  "</p><p><strong>To change whether a newline is automatically output</strong> before/after the begin/end form of a tag <strong>for a given stream</strong> level, give the stream its own private \*(L"tag info\*(R" table, and then use \*(C`set_tag()\*(C':</p><p>    $HTML-&gt;private_tags;     $HTML-&gt;set_tag(&apos;B&apos;, Newlines=&gt;0);     # won&apos;t affect anyone else!</p><p><strong>To output newlines explicitly</strong>, just use the special \*(C`nl\*(C' method in the Chocolate Interface:</p><p>    $HTML-&gt;nl;     # one newline     $HTML-&gt;nl(6);  # six newlines</p><p>I am sometimes asked, \*(L"why don't you put more newlines in automatically?\*(R" Well, mostly because...</p><ul>
<li><p>Sometimes you'll be outputting stuff inside a \*(C`PRE\*(C' environment.</p></li><li><p>Sometimes you really do want to jam things (like images, or table cell delimiters and the things they contain) right up against each other.</p></li>
</ul><p>So I've stuck to outputting newlines in places where it's most likely to be harmless.</p>
<h3>Entities</h3>
<p>As shown above, You can use the \*(C`ent()\*(C' (or \*(C`e()\*(C') method to output an entity:</p><p>    $HTML-&gt;t(&apos;Copyright &apos;)-&gt;e(&apos;copy&apos;)-&gt;t(&apos; 1996 by Me!&apos;);</p><p>But this can be a pain, particularly for generating output with non-ASCII characters:</p><p>    $HTML -&gt; t(&apos;Copyright &apos;)           -&gt; e(&apos;copy&apos;)           -&gt; t(&apos; 1996 by Fran&apos;) -&gt; e(&apos;ccedil&apos;) -&gt; t(&apos;ois, Inc.!&apos;);</p><p>Granted, Europeans can always type the 8-bit characters directly in their Perl code, and just have this:</p><p>    $HTML -&gt; t("Copyright &#92;251 1996 by Fran&#92;347ois, Inc.!&apos;);</p><p>But folks without 8-bit text editors can find this kind of output cumbersome to generate.  Sooooooooo...</p>
<h3>Auto-escaping: changing the way text is escaped</h3>
<p><em>Auto-escaping</em> is the name I give to the act of taking an \*(L"unsafe\*(R" string (one with \*(L"&gt;\*(R", \*(L"&\*(R", etc.), and magically outputting \*(L"safe\*(R" \s-1HTML\s0.</p><p>The default \*(L"auto-escape\*(R" behavior of an \s-1HTML\s0 stream can be a drag if you've got a lot character entities that you want to output, or if you're using the Latin-1 character set, or some other input encoding. Fortunately, you can use the \*(C`auto_escape()\*(C' method to change the way a particular HTML::Stream works at any time.</p><p>First, here's a couple of special invocations:</p><p>    $HTML-&gt;auto_escape(&apos;ALL&apos;);      # Default; escapes [&lt;&gt;"&] and 8-bit chars.     $HTML-&gt;auto_escape(&apos;LATIN_1&apos;);  # Like ALL, but uses Latin-1 entities                                     #   instead of decimal equivalents.     $HTML-&gt;auto_escape(&apos;NON_ENT&apos;);  # Like ALL, but leaves "&" alone.</p><p>You can also install your own auto-escape function (note that you might very well want to install it for just a little bit only, and then de-install it):</p><p>    sub my_auto_escape {         my $text = shift;         HTML::Entities::encode($text);     # start with default         $text =~ s/&#92;(c&#92;)/&copy;/ig;        # (C) becomes copyright         $text =~ s/&#92;&#92;,(c)/&#92;&$1cedil;/ig;   # &#92;,c becomes a cedilla         $text;     }</p><p>    # Start using my auto-escape:     my $old_esc = $HTML-&gt;auto_escape(&#92;&my_auto_escape);</p><p>    # Output some stuff:     $HTML-&gt; IMG(SRC=&gt;&apos;logo.gif&apos;, ALT=&gt;&apos;Fran&#92;,cois, Inc&apos;);     output $HTML &apos;Copyright (C) 1996 by Fran&#92;,cois, Inc.!&apos;;</p><p>    # Stop using my auto-escape:     $HTML-&gt;auto_escape($old_esc);</p><p>If you find yourself in a situation where you're doing this a lot, a better way is to create a <strong>subclass</strong> of HTML::Stream which installs your custom function when constructed.  For an example, see the <strong>HTML::Stream::Latin1</strong> subclass in this module.</p>
<h3>Outputting \s-1HTML\s0 to things besides filehandles</h3>
<p>As of Revision 1.21, you no longer need to supply \*(C`new()\*(C' with a filehandle: <em>any object that responds to a </em><em>print()</em><em> method will do</em>. Of course, this includes <strong>blessed</strong> FileHandles, and IO::Handles.</p><p>If you supply a \s-1GLOB\s0 reference (like \*(C`&#92;*STDOUT\*(C') or a string (like "Module::FH"), HTML::Stream will automatically create an invisible object for talking to that filehandle (I don't dare bless it into a FileHandle, since the underlying descriptor would get closed when the HTML::Stream is destroyed, and you might not want that).</p><p>You say you want to print to a string?  For kicks and giggles, try this:</p><p>    package StringHandle;     sub new {         my $self = &apos;&apos;;         bless &#92;$self, shift;     }     sub print {         my $self = shift;         $$self .= join(&apos;&apos;, @_);     }</p><p>    package main;     use HTML::Stream;</p><p>    my $SH = new StringHandle;     my $HTML = new HTML::Stream $SH;     $HTML -&gt; H1 -&gt; t("Hello & &lt;&lt;welcome&gt;&gt;!") -&gt; _H1;     print "PRINTED STRING: ", $$SH, "&#92;n";</p>
<h3>Subclassing</h3>
<p>This is where you can make your application-specific HTML-generating code <em>much</em> easier to look at.  Consider this:</p><p>    package MY::HTML;     @ISA = qw(HTML::Stream);</p><p>    sub Aside {         $_[0] -&gt; FONT(SIZE=&gt;-1) -&gt; I;     }     sub _Aside {         $_[0] -&gt; _I -&gt; _FONT;     }</p><p>Now, you can do this:</p><p>    my $HTML = new MY::HTML &#92;*STDOUT;</p><p>    $HTML -&gt; Aside           -&gt; t("Don&apos;t drink the milk, it&apos;s spoiled... pass it on...")           -&gt; _Aside;</p><p>If you're defining these markup-like, chocolate-interface-style functions, I recommend using mixed case with a leading capital.  You probably shouldn't use all-uppercase, since that's what this module uses for real \s-1HTML\s0 tags.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PUBLIC INTERFACE</h2>
        <div class="sectioncontent">
<h3>Functions</h3>

<dl class='dl-vertical'>
  <dt>
    html_escape \s-1TEXT\s0
  </dt>
  <dd>
    <p>Given a \s-1TEXT\s0 string, turn the text into valid \s-1HTML\s0 by escaping \*(L"unsafe\*(R" characters.  Currently, the \*(L"unsafe\*(R" characters are 8-bit characters plus:     &lt;  &gt;  =  & <strong>Note:</strong> provided for convenience and backwards-compatibility only. You may want to use the more-powerful <strong>HTML::Entities::encode</strong> function instead.</p>
  </dd>
  <dt>
    html_tag \s-1TAG\s0 [, PARAM=&gt;\s-1VALUE\s0, ...]
  </dt>
  <dd>
    <p>Return the text for a given \s-1TAG\s0, possibly with parameters. As an efficiency hack, only the values are HTML-escaped currently: it is assumed that the tag and parameters will already be safe. For convenience and readability, you can say \*(C`_A\*(C' instead of "/A" for the first tag, if you're into barewords.</p>
  </dd>
  <dt>
    html_unescape \s-1TEXT\s0
  </dt>
  <dd>
    <p>Remove angle-tag markup, and convert the standard ampersand-escapes (\*(C`lt\*(C', \*(C`gt\*(C', \*(C`amp\*(C', \*(C`quot\*(C', and \*(C`#ddd\*(C') into \s-1ASCII\s0 characters. <strong>Note:</strong> provided for convenience and backwards-compatibility only. You may want to use the more-powerful <strong>HTML::Entities::decode</strong> function instead: unlike this function, it can collapse entities like \*(C`copy\*(C' and \*(C`ccedil\*(C' into their Latin-1 byte values.</p>
  </dd>
  <dt>
    html_unmarkup \s-1TEXT\s0
  </dt>
  <dd>
    <p>Remove angle-tag markup from \s-1TEXT\s0, but do not convert ampersand-escapes. Cheesy, but theoretically useful if you want to, say, incorporate externally-provided \s-1HTML\s0 into a page you're generating, and are worried that the \s-1HTML\s0 might contain undesirable markup.</p>
  </dd>

</dl>

<h3>Vanilla</h3>

<dl class='dl-vertical'>
  <dt>
    new [\s-1PRINTABLE\s0]
  </dt>
  <dd>
    <p><em>Class method.</em> Create a new \s-1HTML\s0 output stream. The \s-1PRINTABLE\s0 may be a FileHandle, a glob reference, or any object that responds to a \*(C`print()\*(C' message. If no \s-1PRINTABLE\s0 is given, does a <em>select()</em> and uses that.</p>
  </dd>
  <dt>
    auto_escape [NAME|SUBREF]
  </dt>
  <dd>
    <p><em>Instance method.</em> Set the auto-escape function for this \s-1HTML\s0 stream. If the argument is a subroutine reference \s-1SUBREF\s0, then that subroutine will be used.  Declare such subroutines like this:     sub my_escape {         my $text = shift;     # it&apos;s passed in the first argument         ...         $text;     } If a textual \s-1NAME\s0 is given, then one of the appropriate built-in functions is used.  Possible values are:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1ALL\s0
  </dt>
  <dd>
    <p>Default for HTML::Stream objects.  This escapes angle brackets, ampersands, double-quotes, and 8-bit characters.  8-bit characters are escaped using decimal entity codes (like \*(C`#123\*(C').</p>
  </dd>
  <dt>
    \s-1LATIN_1\s0
  </dt>
  <dd>
    <p>Like "ALL", but uses Latin-1 entity names (like \*(C`ccedil\*(C') instead of decimal entity codes to escape characters.  This makes the \s-1HTML\s0 more readable but it is currently not advised, as \*(L"older\*(R" browsers (like Netscape 2.0) do not recognize many of the \s-1ISO-8859-1\s0 entity names (like \*(C`deg\*(C'). <strong>Warning:</strong> If you specify this option, you'll find that it attempts to \*(L"require\*(R" <strong>HTML::Entities</strong> at run time.  That's because I didn't want to <em>force</em> you to have that module just to use the rest of HTML::Stream. To pick up problems at compile time, you are advised to say:     use HTML::Stream;     use HTML::Entities; in your source code.</p>
  </dd>
  <dt>
    \s-1NON_ENT\s0
  </dt>
  <dd>
    <p>Like "ALL", except that ampersands (&) are <em>not</em> escaped. This allows you to use &-entities in your text strings, while having everything else safely escaped:     output $HTML "If A is an acute angle, then A &gt; 90&deg;";</p>
  </dd>

</dl>
<p>Returns the previously-installed function, in the manner of \*(C`select()\*(C'. No arguments just returns the currently-installed function.</p>
  </dd>
  <dt>
    auto_format \s-1ONOFF\s0
  </dt>
  <dd>
    <p><em>Instance method.</em> Set the auto-formatting characteristics for this \s-1HTML\s0 stream. Currently, all you can do is supply a single defined boolean argument, which turns auto-formatting \s-1ON\s0 (1) or \s-1OFF\s0 (0). The self object is returned. Please use no other values; they are reserved for future use.</p>
  </dd>
  <dt>
    comment \s-1COMMENT\s0
  </dt>
  <dd>
    <p><em>Instance method.</em> Output an \s-1HTML\s0 comment. As of 1.29, a newline is automatically appended.</p>
  </dd>
  <dt>
    ent \s-1ENTITY\s0
  </dt>
  <dd>
    <p><em>Instance method.</em> Output an \s-1HTML\s0 entity.  For example, here's how you'd output a non-breaking space:       $html-&gt;ent(&apos;nbsp&apos;); You may abbreviate this method name as \*(C`e\*(C':       $html-&gt;e(&apos;nbsp&apos;); <strong>Warning:</strong> this function assumes that the entity argument is legal.</p>
  </dd>
  <dt>
    io
  </dt>
  <dd>
    <p>Return the underlying output handle for this \s-1HTML\s0 stream. All you can depend upon is that it is some kind of object which responds to a <em>print()</em> message:     $HTML-&gt;io-&gt;print("This is not auto-escaped or nuthin!");</p>
  </dd>
  <dt>
    nl [\s-1COUNT\s0]
  </dt>
  <dd>
    <p><em>Instance method.</em> Output \s-1COUNT\s0 newlines.  If undefined, \s-1COUNT\s0 defaults to 1.</p>
  </dd>
  <dt>
    tag \s-1TAGNAME\s0 [, PARAM=&gt;\s-1VALUE\s0, ...]
  </dt>
  <dd>
    <p><em>Instance method.</em> Output a tag.  Returns the self object, to allow method chaining. You can say \*(C`_A\*(C' instead of "/A", if you're into barewords.</p>
  </dd>
  <dt>
    text \s-1TEXT\s0...
  </dt>
  <dd>
    <p><em>Instance method.</em> Output some text.  You may abbreviate this method name as \*(C`t\*(C':       $html-&gt;t(&apos;Hi there, &apos;, $yournamehere, &apos;!&apos;); Returns the self object, to allow method chaining.</p>
  </dd>
  <dt>
    text_nbsp \s-1TEXT\s0...
  </dt>
  <dd>
    <p><em>Instance method.</em> Output some text, but with all spaces output as non-breaking-space characters:       $html-&gt;t("To list your home directory, type: ")            -&gt;text_nbsp("ls -l ~yourname.") Returns the self object, to allow method chaining.</p>
  </dd>

</dl>

<h3>Strawberry</h3>

<dl class='dl-vertical'>
  <dt>
    output \s-1ITEM\s0,...,ITEM
  </dt>
  <dd>
    <p><em>Instance method.</em> Go through the items.  If an item is an arrayref, treat it like the array argument to <em>html_tag()</em> and output the result.  If an item is a text string, escape the text and output the result.  Like this:      output $HTML [A, HREF=&gt;$url], "Here&apos;s my $caption!", [_A];</p>
  </dd>

</dl>

<h3>Chocolate</h3>

<dl class='dl-vertical'>
  <dt>
    accept_tag \s-1TAG\s0
  </dt>
  <dd>
    <p><em>Class method.</em> Declares that the tag is to be accepted as valid \s-1HTML\s0 (if it isn't already). For example, this...      # Make sure methods MARQUEE and _MARQUEE are compiled on demand:      HTML::Stream-&gt;accept_tag(&apos;MARQUEE&apos;); ...gives the Chocolate Interface permission to create (via \s-1AUTOLOAD\s0) definitions for the \s-1MARQUEE\s0 and _MARQUEE methods, so you can then say:      $HTML -&gt; MARQUEE -&gt; t("Hi!") -&gt; _MARQUEE; If you want to set the default attribute of the tag as well, you can do so via the <em>set_tag()</em> method instead; it will effectively do an <em>accept_tag()</em> as well.      # Make sure methods MARQUEE and _MARQUEE are compiled on demand,      #   *and*, set the characteristics of that tag.      HTML::Stream-&gt;set_tag(&apos;MARQUEE&apos;, Newlines=&gt;9);</p>
  </dd>
  <dt>
    private_tags
  </dt>
  <dd>
    <p><em>Instance method.</em> Normally, \s-1HTML\s0 streams use a reference to a global table of tag information to determine how to do such things as auto-formatting, and modifications made to that table by \*(C`set_tag\*(C' will affect everyone. However, if you want an \s-1HTML\s0 stream to have a private copy of that table to munge with, just send it this message after creating it. Like this:     my $HTML = new HTML::Stream &#92;*STDOUT;     $HTML-&gt;private_tags; Then, you can say stuff like:     $HTML-&gt;set_tag(&apos;PRE&apos;,   Newlines=&gt;0);     $HTML-&gt;set_tag(&apos;BLINK&apos;, Newlines=&gt;9); And it won't affect anyone else's <em>auto-formatting</em> (although they will possibly be able to use the \s-1BLINK\s0 tag method without a fatal exception \*(C`:-(\*(C' ). Returns the self object.</p>
  </dd>
  <dt>
    set_tag \s-1TAG\s0, [\s-1TAGINFO\s0...]
  </dt>
  <dd>
    <p><em>Class/instance method.</em> Accept the given \s-1TAG\s0 in the Chocolate Interface, and (if \s-1TAGINFO\s0 is given) alter its characteristics when being output.</p><ul>
<li><p><strong>If invoked as a class method,</strong> this alters the \*(L"master tag table\*(R", and allows a new tag to be supported via an autoloaded method:      HTML::Stream-&gt;set_tag(&apos;MARQUEE&apos;, Newlines=&gt;9); Once you do this, <em>all</em> \s-1HTML\s0 streams you open from then on will allow that tag to be output in the chocolate interface.</p></li><li><p><strong>If invoked as an instance method,</strong> this alters the \*(L"tag table\*(R" referenced by that \s-1HTML\s0 stream, usually for the purpose of affecting things like the auto-formatting on that \s-1HTML\s0 stream. <strong>Warning:</strong> by default, an \s-1HTML\s0 stream just references the \*(L"master tag table\*(R" (this makes \*(C`new()\*(C' more efficient), so <em>by default, the</em> instance method will behave exactly like the class method.      my $HTML = new HTML::Stream &#92;*STDOUT;      $HTML-&gt;set_tag(&apos;BLINK&apos;, Newlines=&gt;0);  # changes it for others! If you want to diddle with <em>one</em> stream's auto-formatting <em>only,</em> you'll need to give that stream its own <em>private</em> tag table.  Like this:      my $HTML = new HTML::Stream &#92;*STDOUT;      $HTML-&gt;private_tags;      $HTML-&gt;set_tag(&apos;BLINK&apos;, Newlines=&gt;0);  # doesn&apos;t affect other streams <strong>Note:</strong> this will still force an default entry for \s-1BLINK\s0 in the <em>master</em> tag table: otherwise, we'd never know that it was legal to \s-1AUTOLOAD\s0 a \s-1BLINK\s0 method.   However, it will only alter the <em>characteristics</em> of the \s-1BLINK\s0 tag (like auto-formatting) in the <em>object's</em> tag table.</p></li>
</ul><p>The \s-1TAGINFO\s0, if given, is a set of key=&gt;value pairs with the following possible keys:</p>
<dl class='dl-vertical'>
  <dt>
    Newlines
  </dt>
  <dd>
    <p>Assumed to be a number which encodes how newlines are to be output before/after a tag.   The value is the logical \s-1OR\s0 (or sum) of a set of flags:      0x01    newline before &lt;TAG&gt;         .&lt;TAG&gt;.     .&lt;/TAG&gt;.      0x02    newline after &lt;TAG&gt;          |     |     |      |      0x04    newline before &lt;/TAG&gt;        1     2     4      8      0x08    newline after &lt;/TAG&gt; Hence, to output \s-1BLINK\s0 environments which are preceded/followed by newlines:      set_tag HTML::Stream &apos;BLINK&apos;, Newlines=&gt;9;</p>
  </dd>

</dl>
<p>Returns the self object on success.</p>
  </dd>
  <dt>
    tags
  </dt>
  <dd>
    <p><em>Class/instance method.</em> Returns an unsorted list of all tags in the class/instance tag table (see \*(C`set_tag\*(C' for class/instance method differences).</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSES</h2>
        <div class="sectioncontent">
<h3>HTML::Stream::Latin1</h3>
<p>A small, public package for outputting Latin-1 markup.  Its default auto-escape function is \*(C`LATIN_1\*(C', which tries to output the mnemonic entity markup (e.g., \*(C`&ccedil;\*(C') for \s-1ISO-8859-1\s0 characters.</p><p>So using HTML::Stream::Latin1 like this:</p><p>    use HTML::Stream;</p><p>    $HTML = new HTML::Stream::Latin1 &#92;*STDOUT;     output $HTML "&#92;253A right angle is 90&#92;260, &#92;277No?&#92;273&#92;n";</p><p>Prints this:</p><p>    &laquo;A right angle is 90&deg;, &iquest;No?&raquo;</p><p>Instead of what HTML::Stream would print, which is this:</p><p>    &#171;A right angle is 90&#176;, &#191;No?&#187;</p><p><strong>Warning:</strong> a lot of Latin-1 \s-1HTML\s0 markup is not recognized by older browsers (e.g., Netscape 2.0).  Consider using HTML::Stream; it will output the decimal entities which currently seem to be more \*(L"portable\*(R".</p><p><strong>Note:</strong> using this class \*(L"requires\*(R" that you have HTML::Entities.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERFORMANCE</h2>
        <div class="sectioncontent">
<p>Slower than I'd like.  Both the <em>output()</em> method and the various \*(L"tag\*(R" methods seem to run about 5 times slower than the old just-hardcode-the-darn stuff approach.  That is, in general, this:</p><p>    ### Approach #1...     tag  $HTML &apos;A&apos;, HREF=&gt;"$href";     tag  $HTML &apos;IMG&apos;, SRC=&gt;"logo.gif", ALT=&gt;"LOGO";     text $HTML $caption;     tag  $HTML &apos;_A&apos;;     text $HTML $a_lot_of_text;</p><p>And this:</p><p>    ### Approach #2...     output $HTML [A, HREF=&gt;"$href"],                  [IMG, SRC=&gt;"logo.gif", ALT=&gt;"LOGO"],                  $caption,                  [_A];     output $HTML $a_lot_of_text;</p><p>And this:</p><p>    ### Approach #3...     $HTML -&gt; A(HREF=&gt;"$href")           -&gt; IMG(SRC=&gt;"logo.gif", ALT=&gt;"LOGO")           -&gt; t($caption)           -&gt; _A           -&gt; t($a_lot_of_text);</p><p>Each run about 5x slower than this:</p><p>    ### Approach #4...     print &apos;&lt;A HREF="&apos;, html_escape($href), &apos;&gt;&apos;,           &apos;&lt;IMG SRC="logo.gif" ALT="LOGO"&gt;&apos;,           html_escape($caption),           &apos;&lt;/A&gt;&apos;;     print html_escape($a_lot_of_text);</p><p>Of course, I'd much rather use any of first three <em>(especially #3)</em> if I had to get something done right in a hurry.  Or did you not notice the typo in approach #4?  \*(C`;-)\*(C'</p><p>(\s-1BTW\s0, thanks to Benchmark:: for allowing me to... er... benchmark stuff.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>$Id: Stream.pm,v 1.60 2008/08/06 dstaal Exp $</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHANGE LOG</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Version 1.60   (2008/08/06)
  </dt>
  <dd>
    <p>Fixed up the tests some more, updated changelog.  (Which I'd forgotten about...)</p>
  </dd>
  <dt>
    Version 1.59   (2008/06/01)
  </dt>
  <dd>
    <p>Better tests, better Meta.yml.</p>
  </dd>
  <dt>
    Version 1.58   (2008/05/28)
  </dt>
  <dd>
    <p>Another attempt at cleanup, as well expanding the Meta.yml file.</p>
  </dd>
  <dt>
    Version 1.57   (2008/05/28)
  </dt>
  <dd>
    <p>Cleaned up the Mac-specific files that were getting created in the archive.</p>
  </dd>
  <dt>
    Version 1.56   (2008/05/27)
  </dt>
  <dd>
    <p>Added the start of a testing suite.  In the process, I found an error: \s-1HTML\s0 defines the tag '\s-1NOFRAMES\s0', not '\s-1NOFRAME\s0'.  Both are currently in the tag list, but consider '\s-1NOFRAME\s0' depriciated. The test suite requires Test::More and Test::Output.</p>
  </dd>
  <dt>
    Version 1.55   (2003/10/28)
  </dt>
  <dd>
    <p>New maintainer: Daniel T. Staal.  No major changes in the code, except to complete the tag list to \s-1HTML\s0 4.01 specifications. (With the exception of the 'S' tag, which I want to test, and is depreciated anyway.  Note that the \s-1DOCTYPE\s0 is not actually a \s-1HTML\s0 tag, and is not currently included.)</p>
  </dd>
  <dt>
    Version 1.54   (2001/08/20)
  </dt>
  <dd>
    <p>The terms-of-use have been placed in the distribution file \*(L"\s-1COPYING\s0\*(R". Also, small documentation tweaks were made.</p>
  </dd>
  <dt>
    Version 1.51   (2001/08/16)
  </dt>
  <dd>
    <p>No real changes to code; just improved documentation, and removed HTML::Entities and HTML::Parser from ./etc at \s-1CPAN\s0's request.</p>
  </dd>
  <dt>
    Version 1.47   (2000/06/10)
  </dt>
  <dd>
    <p>No real changes to code; just improved documentation.</p>
  </dd>
  <dt>
    Version 1.45   (1999/02/09)
  </dt>
  <dd>
    <p>Cleanup for Perl 5.005: removed duplicate typeglob assignments.</p>
  </dd>
  <dt>
    Version 1.44   (1998/01/14)
  </dt>
  <dd>
    <p>Win95 install (5.004) now works. Added \s-1SYNOPSIS\s0 to \s-1POD\s0.</p>
  </dd>
  <dt>
    Version 1.41   (1998/01/02)
  </dt>
  <dd>
    <p>Removed $& for efficiency. <em>Thanks, Andreas!</em> Added support for \s-1OPTION\s0, and default now puts newlines after \s-1SELECT\s0 and /SELECT.  Also altered \*(L"\s-1TELEM\s0\*(R" syntax to put newline after end-tags of list element tags (like /OPTION, /LI, etc.).  In theory, this change could produce undesireable results for folks who embed lists inside of \s-1PRE\s0 environments... however, that kind of stuff was done in the days before TABLEs; also, you can always turn it off if you really need to. <em>Thanks to John D Groenveld for these patches.</em> Added <em>text_nbsp()</em>. <em>Thanks to John D Groenveld for the patch.</em> This method may also be invoked as <em>nbsp_text()</em> as in the original patch, but that's sort of a private tip-of-the-hat to the patch author, and the synonym may go away in the future.</p>
  </dd>
  <dt>
    Version 1.37   (1997/02/09)
  </dt>
  <dd>
    <p>No real change; just trying to make \s-1CPAN\s0.pm happier.</p>
  </dd>
  <dt>
    Version 1.32   (1997/01/12)
  </dt>
  <dd>
    <p><strong>\s-1NEW\s0 \s-1TOOL\s0 for generating Perl code which uses HTML::Stream!</strong> Check your toolkit for <strong>html2perlstream</strong>. Added built-in support for escaping 8-bit characters. Added \*(C`LATIN_1\*(C' auto-escape, which uses HTML::Entities to generate mnemonic entities.  This is now the default method for HTML::Stream::Latin1. Added \*(C`auto_format(),\*(C' so you can now turn auto-formatting off/on. Added \*(C`private_tags()\*(C', so it is now possible for \s-1HTML\s0 streams to each have their own \*(L"private\*(R" copy of the %Tags table, for use by \*(C`set_tag()\*(C'. Added \*(C`set_tag()\*(C'.  The tags tables may now be modified dynamically so as to change how formatting is done on-the-fly.  This will hopefully not compromise the efficiency of the chocolate interface (until now, the formatting was compiled into the method itself), and <em>will</em> add greater flexibility for more-complex programs. Added \s-1POD\s0 documentation for all subroutines in the public interface.</p>
  </dd>
  <dt>
    Version 1.29   (1996/12/10)
  </dt>
  <dd>
    <p>Added terminating newline to <em>comment()</em>. <em>Thanks to John D Groenveld for the suggestion and the patch.</em></p>
  </dd>
  <dt>
    Version 1.27   (1996/12/10)
  </dt>
  <dd>
    <p>Added built-in HTML::Stream::Latin1, which does a very simple encoding of all characters above \s-1ASCII\s0 127. Fixed bug in <em>accept_tag()</em>, where 'my' variable was shadowing argument. <em>Thanks to John D Groenveld for the bug report and the patch.</em></p>
  </dd>
  <dt>
    Version 1.26   (1996/09/27)
  </dt>
  <dd>
    <p>Start of history.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>This program is free software.  You may copy or redistribute it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>Warmest thanks to...</p><p>    Eryq                   For writing the orginal version of this module.</p><p>    John Buckman           For suggesting that I write an "html2perlstream",                            and inspiring me to look at supporting Latin-1.     Tony Cebzanov          For suggesting that I write an "html2perlstream"     John D Groenveld       Bug reports, patches, and suggestions     B. K. Oxley (binkley)  For suggesting the support of "writing to strings"                            which became the "printable" interface.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Daniel T. Staal (<em>DStaal@usa.net</em>).</p><p>Enjoy.  Yell if it breaks.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="HTML::SimpleParse.3pm.html"><span aria-hidden="true">&larr;</span> HTML::SimpleParse.3pm: A bare-bones html parser</a></li>
   <li class="next"><a href="HTML::StripScripts.3pm.html">HTML::StripScripts.3pm: Strip scripting constructs out of html <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

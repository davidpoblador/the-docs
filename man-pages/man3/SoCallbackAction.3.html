<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoCallbackAction: The socallbackaction class invokes callbacks at specific nodes.  this action has mechanisms for tracking traversal position and traversal state. in combination with the ability to pass geometry primitives to callback actions set by the user, this does for instance make it rather straightforward to extract the geometry of a scene graph.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The socallbackaction class invokes callbacks at specific nodes.  this action has mechanisms for tracking traversal position and traversal state. in combination with the ability to pass geometry primitives to callback actions set by the user, this does for instance make it rather straightforward to extract the geometry of a scene graph.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoCallbackAction (3) manual">
  <meta name="twitter:description" content="The socallbackaction class invokes callbacks at specific nodes.  this action has mechanisms for tracking traversal position and traversal state. in combination with the ability to pass geometry primitives to callback actions set by the user, this does for instance make it rather straightforward to extract the geometry of a scene graph.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoCallbackAction-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoCallbackAction.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoCallbackAction (3) manual" />
  <meta property="og:description" content="The socallbackaction class invokes callbacks at specific nodes.  this action has mechanisms for tracking traversal position and traversal state. in combination with the ability to pass geometry primitives to callback actions set by the user, this does for instance make it rather straightforward to extract the geometry of a scene graph." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoCallbackAction-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoCallbackAction<small> (3)</small></h1>
        <p class="lead">The socallbackaction class invokes callbacks at specific nodes.  this action has mechanisms for tracking traversal position and traversal state. in combination with the ability to pass geometry primitives to callback actions set by the user, this does for instance make it rather straightforward to extract the geometry of a scene graph.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoCallbackAction.3.html">
      <span itemprop="name">SoCallbackAction: The socallbackaction class invokes callbacks at specific nodes.  this action has mechanisms for tracking traversal position and traversal state. in combination with the ability to pass geometry primitives to callback actions set by the user, this does for instance make it rather straightforward to extract the geometry of a scene graph.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoCallbackAction.3.html">
      <span itemprop="name">SoCallbackAction: The socallbackaction class invokes callbacks at specific nodes.  this action has mechanisms for tracking traversal position and traversal state. in combination with the ability to pass geometry primitives to callback actions set by the user, this does for instance make it rather straightforward to extract the geometry of a scene graph.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/actions/SoCallbackAction.h&gt;</p><p>Inherits <strong>SoAction</strong>.</p><h3>Public Types</h3>
<p>enum <strong>Response</strong> { <strong>CONTINUE</strong>, <strong>ABORT</strong>, <strong>PRUNE</strong> }</p><p>typedef <strong>Response</strong> <strong>SoCallbackActionCB</strong> (void *userdata, <strong>SoCallbackAction</strong> *action, const <strong>SoNode</strong> *node)</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><strong>SoCallbackAction</strong> (void)</p><p><strong>SoCallbackAction</strong> (const <strong>SbViewportRegion</strong> &vp)</p><p>virtual <strong>~SoCallbackAction</strong> (void)</p><p>void <strong>setViewportRegion</strong> (const <strong>SbViewportRegion</strong> &vp)</p><p>void <strong>addPreCallback</strong> (const <strong>SoType</strong> type, <strong>SoCallbackActionCB</strong> *cb, void *userdata)</p><p>void <strong>addPostCallback</strong> (const <strong>SoType</strong> type, <strong>SoCallbackActionCB</strong> *cb, void *userdata)</p><p>void <strong>addPreTailCallback</strong> (<strong>SoCallbackActionCB</strong> *cb, void *userdata)</p><p>void <strong>addPostTailCallback</strong> (<strong>SoCallbackActionCB</strong> *cb, void *userdata)</p><p>void <strong>addTriangleCallback</strong> (const <strong>SoType</strong> type, <strong>SoTriangleCB</strong> *cb, void *userdata)</p><p>void <strong>addLineSegmentCallback</strong> (const <strong>SoType</strong> type, <strong>SoLineSegmentCB</strong> *cb, void *userdata)</p><p>void <strong>addPointCallback</strong> (const <strong>SoType</strong> type, <strong>SoPointCB</strong> *cb, void *userdata)</p><p><strong>SoDecimationTypeElement::Type</strong> <strong>getDecimationType</strong> (void) const </p><p>float <strong>getDecimationPercentage</strong> (void) const </p><p>float <strong>getComplexity</strong> (void) const </p><p><strong>SoComplexity::Type</strong> <strong>getComplexityType</strong> (void) const </p><p>int32_t <strong>getNumCoordinates</strong> (void) const </p><p>const <strong>SbVec3f</strong> & <strong>getCoordinate3</strong> (const int index) const </p><p>const <strong>SbVec4f</strong> & <strong>getCoordinate4</strong> (const int index) const </p><p><strong>SoDrawStyle::Style</strong> <strong>getDrawStyle</strong> (void) const </p><p>unsigned short <strong>getLinePattern</strong> (void) const </p><p>float <strong>getLineWidth</strong> (void) const </p><p>float <strong>getPointSize</strong> (void) const </p><p>const <strong>SbName</strong> & <strong>getFontName</strong> (void) const </p><p>float <strong>getFontSize</strong> (void) const </p><p><strong>SoLightModel::Model</strong> <strong>getLightModel</strong> (void) const </p><p>const <strong>SbVec3f</strong> & <strong>getLightAttenuation</strong> (void) const </p><p>void <strong>getMaterial</strong> (<strong>SbColor</strong> &ambient, <strong>SbColor</strong> &diffuse, <strong>SbColor</strong> &specular, <strong>SbColor</strong> &emission, float &shininess, float &transparency, const int index=0) const </p><p><strong>SoMaterialBinding::Binding</strong> <strong>getMaterialBinding</strong> (void) const </p><p>uint32_t <strong>getNumNormals</strong> (void) const </p><p>const <strong>SbVec3f</strong> & <strong>getNormal</strong> (const int index) const </p><p><strong>SoNormalBinding::Binding</strong> <strong>getNormalBinding</strong> (void) const </p><p>int32_t <strong>getNumProfileCoordinates</strong> (void) const </p><p>const <strong>SbVec2f</strong> & <strong>getProfileCoordinate2</strong> (const int index) const </p><p>const <strong>SbVec3f</strong> & <strong>getProfileCoordinate3</strong> (const int index) const </p><p>const <strong>SoNodeList</strong> & <strong>getProfile</strong> (void) const </p><p><strong>SoShapeHints::VertexOrdering</strong> <strong>getVertexOrdering</strong> (void) const </p><p><strong>SoShapeHints::ShapeType</strong> <strong>getShapeType</strong> (void) const </p><p><strong>SoShapeHints::FaceType</strong> <strong>getFaceType</strong> (void) const </p><p>float <strong>getCreaseAngle</strong> (void) const </p><p>int32_t <strong>getNumTextureCoordinates</strong> (void) const </p><p>const <strong>SbVec2f</strong> & <strong>getTextureCoordinate2</strong> (const int index) const </p><p>const <strong>SbVec3f</strong> & <strong>getTextureCoordinate3</strong> (const int index) const </p><p>const <strong>SbVec4f</strong> & <strong>getTextureCoordinate4</strong> (const int index) const </p><p><strong>SoTextureCoordinateBinding::Binding</strong> <strong>getTextureCoordinateBinding</strong> (void) const </p><p>const <strong>SbColor</strong> & <strong>getTextureBlendColor</strong> (void) const </p><p>const unsigned char * <strong>getTextureImage</strong> (<strong>SbVec2s</strong> &size, int &numcomps) const </p><p>const unsigned char * <strong>getTextureImage</strong> (<strong>SbVec3s</strong> &size, int &numcomps) const </p><p>const <strong>SbMatrix</strong> & <strong>getTextureMatrix</strong> (void) const </p><p><strong>SoTexture2::Model</strong> <strong>getTextureModel</strong> (void) const </p><p><strong>SoTexture2::Wrap</strong> <strong>getTextureWrapS</strong> (void) const </p><p><strong>SoTexture2::Wrap</strong> <strong>getTextureWrapT</strong> (void) const </p><p><strong>SoTexture2::Wrap</strong> <strong>getTextureWrapR</strong> (void) const </p><p>const <strong>SbMatrix</strong> & <strong>getModelMatrix</strong> (void) const </p><p><strong>SoUnits::Units</strong> <strong>getUnits</strong> (void) const </p><p>float <strong>getFocalDistance</strong> (void) const </p><p>const <strong>SbMatrix</strong> & <strong>getProjectionMatrix</strong> (void) const </p><p>const <strong>SbMatrix</strong> & <strong>getViewingMatrix</strong> (void) const </p><p>const <strong>SbViewVolume</strong> & <strong>getViewVolume</strong> (void) const </p><p>const <strong>SbViewportRegion</strong> & <strong>getViewportRegion</strong> (void) const </p><p><strong>SoPickStyle::Style</strong> <strong>getPickStyle</strong> (void) const </p><p>int32_t <strong>getSwitch</strong> (void) const </p><p><strong>Response</strong> <strong>getCurrentResponse</strong> (void) const </p><p>void <strong>invokePreCallbacks</strong> (const <strong>SoNode</strong> *const node)</p><p>void <strong>invokePostCallbacks</strong> (const <strong>SoNode</strong> *const node)</p><p>void <strong>invokeTriangleCallbacks</strong> (const <strong>SoShape</strong> *const shape, const <strong>SoPrimitiveVertex</strong> *const v1, const <strong>SoPrimitiveVertex</strong> *const v2, const <strong>SoPrimitiveVertex</strong> *const v3)</p><p>void <strong>invokeLineSegmentCallbacks</strong> (const <strong>SoShape</strong> *const shape, const <strong>SoPrimitiveVertex</strong> *const v1, const <strong>SoPrimitiveVertex</strong> *const v2)</p><p>void <strong>invokePointCallbacks</strong> (const <strong>SoShape</strong> *const shape, const <strong>SoPrimitiveVertex</strong> *const v)</p><p>SbBool <strong>shouldGeneratePrimitives</strong> (const <strong>SoShape</strong> *shape) const </p><p>virtual <strong>SoNode</strong> * <strong>getCurPathTail</strong> (void)</p><p>void <strong>setCurrentNode</strong> (<strong>SoNode</strong> *const node)</p><p>void <strong>setCallbackAll</strong> (SbBool callbackall)</p><p>SbBool <strong>isCallbackAll</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>addMethod</strong> (const <strong>SoType</strong> type, SoActionMethod method)</p><p>static void <strong>enableElement</strong> (const <strong>SoType</strong> type, const int stackindex)</p><p>static void <strong>initClass</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p>virtual const</p><p><strong>SoEnabledElementsList</strong> & <strong>getEnabledElements</strong> (void) const "</p><p>virtual void <strong>beginTraversal</strong> (<strong>SoNode</strong> *node)</p>
<h3>Static Protected Member Functions</h3>
<p>static <strong>SoEnabledElementsList</strong> * <strong>getClassEnabledElements</strong> (void)</p><p>static <strong>SoActionMethodList</strong> * <strong>getClassActionMethods</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoCallbackAction</strong> class invokes callbacks at specific nodes.</p><p>This action has mechanisms for tracking traversal position and traversal state. In combination with the ability to pass geometry primitives to callback actions set by the user, this does for instance make it rather straightforward to extract the geometry of a scene graph.</p><p>You should be able to use this action for most of your 'simple' traversal needs, instead of cooking up your own code, as the <strong>SoCallbackAction</strong> is rather flexible.</p><p>A common use of this action is to extract geometry of non-primitive shapes as triangles. A full-fledged example that demonstrates this on a scenegraph with two spheres follows:</p>
<pre>
#include &lt;Inventor/SoDB.h&gt;
#include &lt;Inventor/SoPrimitiveVertex.h&gt;
#include &lt;Inventor/actions/SoCallbackAction.h&gt;
#include &lt;Inventor/nodes/SoCoordinate3.h&gt;
#include &lt;Inventor/nodes/SoIndexedFaceSet.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;
#include &lt;Inventor/nodes/SoShape.h&gt;
#include &lt;Inventor/nodes/SoSphere.h&gt;
#include &lt;Inventor/nodes/SoTranslation.h&gt;


static SoCoordinate3 * coord3 = NULL;
static SoIndexedFaceSet * ifs = NULL;

static int coord3idx = 0;


static void
triangle_cb(void * userdata, SoCallbackAction * action,
            const SoPrimitiveVertex * v1,
            const SoPrimitiveVertex * v2,
            const SoPrimitiveVertex * v3)
{
  const SbVec3f vtx[] = { v1-&gt;getPoint(), v2-&gt;getPoint(), v3-&gt;getPoint() };
  const SbMatrix mm = action-&gt;getModelMatrix();

  SbVec3f vx[3];
  for (int j=0; j &lt; 3; j++) { mm.multVecMatrix(vtx[j], vx[j]); }

  // (This is sub-optimal -- should scan for the same vertex
  // coordinates already being present in the SoCoordinate3
  // node. We'll get lots of duplicate coordinates from this.)
  coord3-&gt;point.setNum(coord3-&gt;point.getNum() + 3);
  coord3-&gt;point.setValues(coord3idx, 3, vx);

  int32_t indices[] = { coord3idx, coord3idx + 1, coord3idx + 2, -1 };
  coord3idx += 3;

  int oldsize = ifs-&gt;coordIndex.getNum();
  ifs-&gt;coordIndex.setNum(oldsize + 4);
  ifs-&gt;coordIndex.setValues(oldsize, 4, indices);

  // (Note that it would likely be desirable to grab normal vectors,
  // materials and / or texture coordinates in a real-world
  // application. How to do this is not shown by the above code,
  // but it is not much different from the extraction of vertex
  // coordinates.)
}


int
main(void)
{
  SoDB::init();

  SoSeparator * root = new SoSeparator;
  root-&gt;addChild(new SoSphere);
  SoTranslation * trans = new SoTranslation;
  trans-&gt;translation.setValue(10, 0, 0);
  root-&gt;addChild(trans);
  SoSphere * ss = new SoSphere;
  ss-&gt;radius = 3;
  root-&gt;addChild(ss);

  root-&gt;ref();

  coord3 = new SoCoordinate3;
  coord3-&gt;<strong>point.setNum</strong>(0);
  ifs = new SoIndexedFaceSet;
  ifs-&gt;<strong>coordIndex.setNum</strong>(0);

  SoCallbackAction ca;
  ca.addTriangleCallback(SoShape::getClassTypeId(), triangle_cb, NULL);
  ca.apply(root);

  root-&gt;unref();

  // [the generated SoCoordinate3 and SoIndexedFaceSet nodes would now
  // typically be used in a scenegraph in a viewer, or written to disk
  // or something]

  return 0;
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>\fBResponse\fP SoCallbackAction::SoCallbackActionCB</h3>
<p>Callback functions need to be of this type. <em>node</em> is at the current traversal point in the scene graph.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoCallbackAction::Response\fP</h3>
<p>Response values for callback function.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>CONTINUE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Continue traversal as usual.</p>
  </dd>
  <dt>
    <p><strong></strong><em>ABORT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Abort traversal immediately. No other callbacks are called after this has been returned.</p>
  </dd>
  <dt>
    <p><strong></strong><em>PRUNE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Don't do traversal of neither the current node (if returning from a pre-traversal callback) nor its children.</p>
  </dd>

</dl>
<p>If returned from a pre-callback, the post-callbacks will still be called. If returned from a post-callback, the behaviour will be the same as for returning CONTINUE.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoCallbackAction::SoCallbackAction (void)</h3>
<p>Default constructor. Will set the viewport to a standard viewport with size 640x512.</p>
<h3>SoCallbackAction::SoCallbackAction (const \fBSbViewportRegion\fP &vp)</h3>
<p>Constructor which lets you specify the viewport.</p><p>This constructor is an extension versus the Open Inventor API.</p>
<h3>SoCallbackAction::~SoCallbackAction (void)\fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoCallbackAction::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an action derived from a class inheriting <strong>SoAction</strong>. This is used for run-time type checking and 'downward' casting.</p><p>Usage example:</p>
<pre>
void bar(SoAction * action)
{
  if (action-&gt;getTypeId() == SoGLRenderAction::getClassTypeId()) {
    // safe downward cast, know the type
    SoGLRenderAction * glrender = (SoGLRenderAction *)action;
  }
  return; // ignore if not renderaction
}
</pre>
<p>For application programmers wanting to extend the library with new actions: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR.</p><p>For more information on writing Coin extensions, see the <strong>SoAction</strong> class documentation.</p><p>Returns the actual type id of an object derived from a class inheriting <strong>SoAction</strong>. Needs to be overridden in <em>all</em> subclasses.</p><p>Implements <strong>SoAction</strong>.</p>
<h3>void SoCallbackAction::addMethod (const \fBSoType\fPtype, SoActionMethodmethod)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoCallbackAction::enableElement (const \fBSoType\fPtype, const intstackindex)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>const \fBSoEnabledElementsList\fP & SoCallbackAction::getEnabledElements (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a list of the elements used by action instances of this class upon traversal operations.</p><p>Reimplemented from <strong>SoAction</strong>.</p>
<h3>void SoCallbackAction::setViewportRegion (const \fBSbViewportRegion\fP &vp)</h3>
<p>Sets the viewport region for this action. When set, the viewport element is initialized right before a traversal starts, making it the current viewport.</p><p>This method is an extension versus the Open Inventor API.</p>
<h3>void SoCallbackAction::addPreCallback (const \fBSoType\fPtype, \fBSoCallbackActionCB\fP *cb, void *userdata)</h3>
<p>Set a function <em>cb</em> to call before every node of <em>type</em> is traversed. <em>cb</em> will be called with <em>userdata</em>.</p>
<h3>void SoCallbackAction::addPostCallback (const \fBSoType\fPtype, \fBSoCallbackActionCB\fP *cb, void *userdata)</h3>
<p>Set a function <em>cb</em> to call after every node of <em>type</em> has been traversed. <em>cb</em> will be called with <em>userdata</em>.</p>
<h3>void SoCallbackAction::addPreTailCallback (\fBSoCallbackActionCB\fP *cb, void *userdata)</h3>
<p>Set a function <em>cb</em> to call before the tail of a path is traversed. <em>cb</em> will be called with <em>userdata</em>.</p>
<h3>void SoCallbackAction::addPostTailCallback (\fBSoCallbackActionCB\fP *cb, void *userdata)</h3>
<p>Set a function <em>cb</em> to call after the tail of a path has been traversed. <em>cb</em> will be called with <em>userdata</em>.</p>
<h3>void SoCallbackAction::addTriangleCallback (const \fBSoType\fPtype, \fBSoTriangleCB\fP *cb, void *userdata)</h3>
<p>Set a function <em>cb</em> to call when traversing a node of <em>type</em> which generates triangle primitives for rendering. <em>cb</em> will be called with <em>userdata</em>.</p>
<h3>void SoCallbackAction::addLineSegmentCallback (const \fBSoType\fPtype, \fBSoLineSegmentCB\fP *cb, void *userdata)</h3>
<p>Set a function <em>cb</em> to call when traversing a node of <em>type</em> which generates line primitives for rendering. <em>cb</em> will be called with <em>userdata</em>.</p>
<h3>void SoCallbackAction::addPointCallback (const \fBSoType\fPtype, \fBSoPointCB\fP *cb, void *userdata)</h3>
<p>Set a function <em>cb</em> to call when traversing a node of <em>type</em> which generates single point primitives for rendering. <em>cb</em> will be called with <em>userdata</em>.</p>
<h3>\fBSoDecimationTypeElement::Type\fP SoCallbackAction::getDecimationType (void) const</h3>
<p>Returns current decimation type setting.</p>
<h3>float SoCallbackAction::getDecimationPercentage (void) const</h3>
<p>Returns current decimation percentage setting.</p>
<h3>float SoCallbackAction::getComplexity (void) const</h3>
<p>Returns current complexity setting.</p>
<h3>\fBSoComplexity::Type\fP SoCallbackAction::getComplexityType (void) const</h3>
<p>Returns current complexity type setting.</p>
<h3>int32_t SoCallbackAction::getNumCoordinates (void) const</h3>
<p>Returns current number of coordinates in the state.</p>
<h3>const \fBSbVec3f\fP & SoCallbackAction::getCoordinate3 (const intindex) const</h3>
<p>Returns a coordinate triplet from the current state pool of coordinates.</p>
<h3>const \fBSbVec4f\fP & SoCallbackAction::getCoordinate4 (const intindex) const</h3>
<p>Returns a coordinate quartuplet from the current state pool of coordinates.</p>
<h3>\fBSoDrawStyle::Style\fP SoCallbackAction::getDrawStyle (void) const</h3>
<p>Returns current draw style setting.</p>
<h3>unsigned short SoCallbackAction::getLinePattern (void) const</h3>
<p>Returns current line pattern setting.</p>
<h3>float SoCallbackAction::getLineWidth (void) const</h3>
<p>Returns current line width setting.</p>
<h3>float SoCallbackAction::getPointSize (void) const</h3>
<p>Returns current point size setting.</p>
<h3>const \fBSbName\fP & SoCallbackAction::getFontName (void) const</h3>
<p>Returns current fontname setting.</p>
<h3>float SoCallbackAction::getFontSize (void) const</h3>
<p>Returns current fontsize setting.</p>
<h3>\fBSoLightModel::Model\fP SoCallbackAction::getLightModel (void) const</h3>
<p>Returns current lightmodel setting.</p>
<h3>const \fBSbVec3f\fP & SoCallbackAction::getLightAttenuation (void) const</h3>
<p>Returns current light attenuation setting.</p>
<h3>void SoCallbackAction::getMaterial (\fBSbColor\fP &ambient, \fBSbColor\fP &diffuse, \fBSbColor\fP &specular, \fBSbColor\fP &emission, float &shininess, float &transparency, const intindex = \fC0\fP) const</h3>
<p>Returns current material settings.</p>
<h3>\fBSoMaterialBinding::Binding\fP SoCallbackAction::getMaterialBinding (void) const</h3>
<p>Returns current materialbinding setting.</p>
<h3>uint32_t SoCallbackAction::getNumNormals (void) const</h3>
<p>Returns current number of normals in the state.</p>
<h3>const \fBSbVec3f\fP & SoCallbackAction::getNormal (const intindex) const</h3>
<p>Returns the normal vectors at <em>index</em> from the current state.</p>
<h3>\fBSoNormalBinding::Binding\fP SoCallbackAction::getNormalBinding (void) const</h3>
<p>Returns current normalbinding setting.</p>
<h3>int32_t SoCallbackAction::getNumProfileCoordinates (void) const</h3>
<p>Returns current number of profile coordinates in the state.</p>
<h3>const \fBSbVec2f\fP & SoCallbackAction::getProfileCoordinate2 (const intindex) const</h3>
<p>Returns current number of <strong>SbVec2f</strong> profile coordinates in the state.</p>
<h3>const \fBSbVec3f\fP & SoCallbackAction::getProfileCoordinate3 (const intindex) const</h3>
<p>Returns current number of <strong>SbVec3f</strong> profile coordinates in the state.</p>
<h3>const \fBSoNodeList\fP & SoCallbackAction::getProfile (void) const</h3>
<p>Returns current list of profile nodes.</p>
<h3>\fBSoShapeHints::VertexOrdering\fP SoCallbackAction::getVertexOrdering (void) const</h3>
<p>Returns current vertexordering shapehint setting.</p><p>Please note that this is the vertex ordering set by the <strong>SoShapeHints</strong> node. If you want to find the vertex ordering for VRML nodes you'll need to read this directly from the <em>ccw</em> field in those nodes.</p>
<h3>\fBSoShapeHints::ShapeType\fP SoCallbackAction::getShapeType (void) const</h3>
<p>Returns current shapetype hint setting.</p><p>Please note that this is the shape type set by the <strong>SoShapeHints</strong> node. If you want to find the shape type for VRML nodes you'll need to read this directly from the <em>solid</em> field in those nodes.</p>
<h3>\fBSoShapeHints::FaceType\fP SoCallbackAction::getFaceType (void) const</h3>
<p>Returns current facetype hint setting.</p><p>Please note that this is the face type set by the <strong>SoShapeHints</strong> node. If you want to find the face type for VRML nodes you'll need to read this directly from the <em>convex</em> field in those nodes.</p>
<h3>float SoCallbackAction::getCreaseAngle (void) const</h3>
<p>Returns current creaseangle setting. Please note that this is the crease angle value set by the <strong>SoShapeHints</strong> node. If you want to find the crease angle for VRML nodes you'll need to read this directly from the creaseAngle field in those nodes.</p>
<h3>int32_t SoCallbackAction::getNumTextureCoordinates (void) const</h3>
<p>Returns current number of texture coordinates in the traversal state.</p>
<h3>const \fBSbVec2f\fP & SoCallbackAction::getTextureCoordinate2 (const intindex) const</h3>
<p>Returns <strong>SbVec2f</strong> texture coordinate at <em>index</em> from the texture coordinate pool of the traversal state.</p>
<h3>const \fBSbVec3f\fP & SoCallbackAction::getTextureCoordinate3 (const intindex) const</h3>
<p>Returns <strong>SbVec3f</strong> texture coordinate at <em>index</em> from the texture coordinate pool of the traversal state.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>const \fBSbVec4f\fP & SoCallbackAction::getTextureCoordinate4 (const intindex) const</h3>
<p>Returns <strong>SbVec4f</strong> texture coordinate at <em>index</em> from the texture coordinate pool of the traversal state.</p>
<h3>\fBSoTextureCoordinateBinding::Binding\fP SoCallbackAction::getTextureCoordinateBinding (void) const</h3>
<p>Returns current texturecoordinate binding setting.</p>
<h3>const \fBSbColor\fP & SoCallbackAction::getTextureBlendColor (void) const</h3>
<p>Returns current texture blend color setting.</p>
<h3>const unsigned char * SoCallbackAction::getTextureImage (\fBSbVec2s\fP &size, int &numcomps) const</h3>
<p>Returns current texture image settings.</p>
<h3>const unsigned char * SoCallbackAction::getTextureImage (\fBSbVec3s\fP &size, int &numcomps) const</h3>
<p>Returns current 3D texture image settings.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>const \fBSbMatrix\fP & SoCallbackAction::getTextureMatrix (void) const</h3>
<p>Returns current texture transformation matrix setting.</p>
<h3>\fBSoTexture2::Model\fP SoCallbackAction::getTextureModel (void) const</h3>
<p>Returns current texturemapping model setting.</p>
<h3>\fBSoTexture2::Wrap\fP SoCallbackAction::getTextureWrapS (void) const</h3>
<p>Returns current texture wrapping setting for the S coordinate.</p>
<h3>\fBSoTexture2::Wrap\fP SoCallbackAction::getTextureWrapT (void) const</h3>
<p>Returns current texture wrapping setting for the T coordinate.</p>
<h3>\fBSoTexture2::Wrap\fP SoCallbackAction::getTextureWrapR (void) const</h3>
<p>Returns current texture wrapping setting for the R coordinate.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>const \fBSbMatrix\fP & SoCallbackAction::getModelMatrix (void) const</h3>
<p>Returns current model matrix.</p>
<h3>\fBSoUnits::Units\fP SoCallbackAction::getUnits (void) const</h3>
<p>Returns current units setting.</p>
<h3>float SoCallbackAction::getFocalDistance (void) const</h3>
<p>Returns current camera focal distance setting.</p>
<h3>const \fBSbMatrix\fP & SoCallbackAction::getProjectionMatrix (void) const</h3>
<p>Returns current projection matrix.</p>
<h3>const \fBSbMatrix\fP & SoCallbackAction::getViewingMatrix (void) const</h3>
<p>Returns current viewing matrix.</p>
<h3>const \fBSbViewVolume\fP & SoCallbackAction::getViewVolume (void) const</h3>
<p>Returns current view volume setting.</p>
<h3>const \fBSbViewportRegion\fP & SoCallbackAction::getViewportRegion (void) const</h3>
<p>Returns current viewport region setting.</p><p>This method is an extension versus the Open Inventor API.</p>
<h3>\fBSoPickStyle::Style\fP SoCallbackAction::getPickStyle (void) const</h3>
<p>Returns current pickstyle setting.</p>
<h3>int32_t SoCallbackAction::getSwitch (void) const</h3>
<p>Returns last <strong>SoSwitch::whichChild</strong> setting during the traversal.</p>
<h3>\fBSoCallbackAction::Response\fP SoCallbackAction::getCurrentResponse (void) const</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoCallbackAction::invokePreCallbacks (const \fBSoNode\fP *constnode)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Invoke all 'pre traversal' callbacks.</p>
<h3>void SoCallbackAction::invokePostCallbacks (const \fBSoNode\fP *constnode)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Invoke all 'post traversal' callbacks.</p>
<h3>void SoCallbackAction::invokeTriangleCallbacks (const \fBSoShape\fP *constshape, const \fBSoPrimitiveVertex\fP *constv1, const \fBSoPrimitiveVertex\fP *constv2, const \fBSoPrimitiveVertex\fP *constv3)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Invoke all 'triangle generation' callbacks.</p>
<h3>void SoCallbackAction::invokeLineSegmentCallbacks (const \fBSoShape\fP *constshape, const \fBSoPrimitiveVertex\fP *constv1, const \fBSoPrimitiveVertex\fP *constv2)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Invoke all 'line segment generation' callbacks.</p>
<h3>void SoCallbackAction::invokePointCallbacks (const \fBSoShape\fP *constshape, const \fBSoPrimitiveVertex\fP *constv)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Invoke all 'point' callbacks.</p>
<h3>SbBool SoCallbackAction::shouldGeneratePrimitives (const \fBSoShape\fP *shape) const</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Check from the shape nodes whether or not to generate primitives from the complex shapes. If there are no callbacks attached to the node types, making the primitives would only be a waste of CPU.</p>
<h3>\fBSoNode\fP * SoCallbackAction::getCurPathTail (void)\fC [virtual]\fP</h3>
<p>Returns the current tail of the traversal path for the callback action.</p><p>Reimplemented from <strong>SoAction</strong>.</p>
<h3>void SoCallbackAction::setCurrentNode (\fBSoNode\fP *constnode)</h3>
<p>Used from nodes during traversal to keep a current node pointer in the action.</p>
<h3>void SoCallbackAction::beginTraversal (\fBSoNode\fP *node)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This virtual method is called from <strong>SoAction::apply()</strong>, and is the entry point for the actual scenegraph traversal.</p><p>It can be overridden to initialize the action at traversal start, for specific initializations in the action subclasses inheriting <strong>SoAction</strong>.</p><p>Default method just calls <strong>traverse()</strong>, which any overridden implementation of the method must do too (or call <strong>SoAction::beginTraversal()</strong>) to trigger the scenegraph traversal.</p><p>Reimplemented from <strong>SoAction</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoCallback.h.3.html"><span aria-hidden="true">&larr;</span> SoCallback.h.3: Socallback.h -</a></li>
   <li class="next"><a href="SoCallbackAction.h.3.html">SoCallbackAction.h.3: Socallbackaction.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

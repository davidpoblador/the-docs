<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoPath: The sopath class is a container class for traversal path descriptions.  sopath objects contain a list of sonode pointers and a list of child indices. indices are necessary to disambiguate situations where a node uses the same node as a child multiple times.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sopath class is a container class for traversal path descriptions.  sopath objects contain a list of sonode pointers and a list of child indices. indices are necessary to disambiguate situations where a node uses the same node as a child multiple times.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoPath (3) manual">
  <meta name="twitter:description" content="The sopath class is a container class for traversal path descriptions.  sopath objects contain a list of sonode pointers and a list of child indices. indices are necessary to disambiguate situations where a node uses the same node as a child multiple times.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoPath-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoPath.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoPath (3) manual" />
  <meta property="og:description" content="The sopath class is a container class for traversal path descriptions.  sopath objects contain a list of sonode pointers and a list of child indices. indices are necessary to disambiguate situations where a node uses the same node as a child multiple times." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoPath-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoPath<small> (3)</small></h1>
        <p class="lead">The sopath class is a container class for traversal path descriptions.  sopath objects contain a list of sonode pointers and a list of child indices. indices are necessary to disambiguate situations where a node uses the same node as a child multiple times.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoPath.3.html">
      <span itemprop="name">SoPath: The sopath class is a container class for traversal path descriptions.  sopath objects contain a list of sonode pointers and a list of child indices. indices are necessary to disambiguate situations where a node uses the same node as a child multiple times.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoPath.3.html">
      <span itemprop="name">SoPath: The sopath class is a container class for traversal path descriptions.  sopath objects contain a list of sonode pointers and a list of child indices. indices are necessary to disambiguate situations where a node uses the same node as a child multiple times.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SoPath.h&gt;</p><p>Inherits <strong>SoBase</strong>.</p><p>Inherited by <strong>SoFullPath</strong>, and <strong>SoNodeKitPath</strong>.</p><h3>Public Member Functions</h3>
<p><strong>SoPath</strong> (const int approxlength=4)</p><p><strong>SoPath</strong> (<strong>SoNode</strong> *const head)</p><p><strong>SoPath</strong> (const <strong>SoPath</strong> &rhs)</p><p><strong>SoPath</strong> & <strong>operator=</strong> (const <strong>SoPath</strong> &rhs)</p><p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> void <strong>setHead</strong> (<strong>SoNode</strong> *const head)</p><p><strong>SoNode</strong> * <strong>getHead</strong> (void) const </p><p>void <strong>append</strong> (const int childindex)</p><p>void <strong>append</strong> (<strong>SoNode</strong> *const node)</p><p>void <strong>append</strong> (const <strong>SoPath</strong> *const frompath)</p><p>void <strong>push</strong> (const int childindex)</p><p>void <strong>pop</strong> (void)</p><p><strong>SoNode</strong> * <strong>getTail</strong> (void) const </p><p><strong>SoNode</strong> * <strong>getNode</strong> (const int index) const </p><p><strong>SoNode</strong> * <strong>getNodeFromTail</strong> (const int index) const </p><p>int <strong>getIndex</strong> (const int index) const </p><p>int <strong>getIndexFromTail</strong> (const int index) const </p><p>int <strong>getLength</strong> (void) const </p><p>void <strong>truncate</strong> (const int length)</p><p>int <strong>findFork</strong> (const <strong>SoPath</strong> *const path) const </p><p>int <strong>findNode</strong> (const <strong>SoNode</strong> *const node) const </p><p>SbBool <strong>containsNode</strong> (const <strong>SoNode</strong> *const node) const </p><p>SbBool <strong>containsPath</strong> (const <strong>SoPath</strong> *const path) const </p><p><strong>SoPath</strong> * <strong>copy</strong> (const int startfromnodeindex=0, int numnodes=0) const </p><p>void <strong>insertIndex</strong> (<strong>SoNode</strong> *const parent, const int newindex)</p><p>void <strong>removeIndex</strong> (<strong>SoNode</strong> *const parent, const int oldindex)</p><p>void <strong>replaceIndex</strong> (<strong>SoNode</strong> *const parent, const int index, <strong>SoNode</strong> *const newchild)</p><p>SbBool <strong>isRelevantNotification</strong> (<strong>SoNotList</strong> *const l) const </p><p>virtual void <strong>write</strong> (<strong>SoWriteAction</strong> *action)</p>
<h3>Static Public Member Functions</h3>
<p>static void <strong>initClass</strong> (void)</p><p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static <strong>SoPath</strong> * <strong>getByName</strong> (const <strong>SbName</strong> name)</p><p>static int <strong>getByName</strong> (const <strong>SbName</strong> name, <strong>SoPathList</strong> &l)</p>
<h3>Protected Member Functions</h3>
<p>virtual <strong>~SoPath</strong> ()</p><p>void <strong>auditPath</strong> (const SbBool flag)</p>
<h3>Friends</h3>
<p>SbBool <strong>operator==</strong> (const <strong>SoPath</strong> &lhs, const <strong>SoPath</strong> &rhs)</p><p>SbBool <strong>operator!=</strong> (const <strong>SoPath</strong> &lhs, const <strong>SoPath</strong> &rhs)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoPath</strong> class is a container class for traversal path descriptions.</p><p><strong>SoPath</strong> objects contain a list of <strong>SoNode</strong> pointers and a list of child indices. Indices are necessary to disambiguate situations where a node uses the same node as a child multiple times.</p><p>Paths can be export and imported to/from file, like other <strong>SoBase</strong> derived objects. Read the documentation on the <strong>write()</strong> method to see how the file format is.</p><p>It's important to know the difference between this class and <strong>SoFullPath</strong> when working with paths. <strong>SoPath::getTail()</strong> will return the first node in the path that doesn't inherit <strong>SoGroup</strong>, and <strong>getLength()</strong> returns the number of nodes down to this node.</p><p>If you need the actual path length, or the actual tail node, you need to cast the path to <strong>SoFullPath</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoPath::SoPath (const intapproxlength = \fC4\fP)</h3>
<p>The default constructor. <em>approxlength</em> is used to indicate in advance the length of the path to minimize the number of reallocations.</p>
<h3>SoPath::SoPath (\fBSoNode\fP *consthead)</h3>
<p>A constructor. The argument is set as the <em>head</em> (and only) node of the path.</p>
<h3>SoPath::SoPath (const \fBSoPath\fP &rhs)</h3>
<p>Copy constructor. Not part of the original Open Inventor API.</p>
<h3>SoPath::~SoPath (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>The destructor is protected as destruction of <strong>SoPath</strong> instances happens through <strong>unref()</strong> (as for all objects derived from classes inheriting <strong>SoBase</strong>).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoPath\fP & SoPath::operator= (const \fBSoPath\fP &rhs)</h3>
<p>Assignment operator, copies the <em>rhs</em> path into this. Not part of the original Open Inventor API.</p>
<h3>\fBSoType\fP SoPath::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Implements <strong>SoBase</strong>.</p>
<h3>void SoPath::setHead (\fBSoNode\fP *constnode)</h3>
<p>This method sets the head of the path to <em>node</em>. If the object already has a path set, it will be truncated.</p>
<h3>\fBSoNode\fP * SoPath::getHead (void) const</h3>
<p>This method returns the head of the path, or NULL if the path is empty.</p>
<h3>void SoPath::append (const intchildindex)</h3>
<p>This function appends the <em>childindex</em> child of the path's tail to the end of the path. It can only be used after the head is set.</p>
<h3>void SoPath::append (\fBSoNode\fP *constnode)</h3>
<p>This function adds <em>node</em> to the end if it is a child of the current tail. If path is empty, this is equivalent to calling <strong>setHead()</strong>.</p>
<h3>void SoPath::append (const \fBSoPath\fP *constfrompath)</h3>
<p>This method appends the path to the end of the path if the head of <em>frompath</em> is either the tail of the path or a child of the path's tail. If the head of <em>frompath</em> is used multiple times as a child of the path tail, the lowest child index is used.</p>
<h3>void SoPath::push (const intchildindex)\fC [inline]\fP</h3>
<p>This method pushes the child at <em>childindex</em> on the tail on the path.</p>
<h3>void SoPath::pop (void)\fC [inline]\fP</h3>
<p>This method pops the tail off the path.</p>
<h3>\fBSoNode\fP * SoPath::getTail (void) const</h3>
<p>This method returns the tail node of the path. Please note that this method only considers group nodes without hidden children (nodes inheriting <strong>SoGroup</strong>) when finding the tail.</p><p>If you want to find the real tail node (also below node kits and VRML nodes with hidden children), you have to use <strong>SoFullPath::getTail()</strong>. You don't have to create an <strong>SoFullPath</strong> instance to do this, just cast the <strong>SoPath</strong> instance to <strong>SoFullPath</strong> before gettting the tail node:</p>
<pre>
SoNode * tail = static_cast&lt;SoFullPath*&gt;(path)-&gt;getTail();
</pre>

<h3>\fBSoNode\fP * SoPath::getNode (const intindex) const</h3>
<p>This method returns the node at <em>index</em> in the path, counted from 0 at the head.</p>
<h3>\fBSoNode\fP * SoPath::getNodeFromTail (const intindex) const</h3>
<p>This method returns the node at <em>index</em> in the path, counting from the tail. The <em>index</em> argument should be zero or positive.</p>
<h3>int SoPath::getIndex (const intindex) const</h3>
<p>This method returns the child index of the node at <em>index</em> in the path.</p>
<h3>int SoPath::getIndexFromTail (const intindex) const</h3>
<p>This method returns the child index of the node at <em>index</em> in the path, counting from the tail. The <em>index</em> argument should be zero or positive.</p>
<h3>int SoPath::getLength (void) const</h3>
<p>This method returns the number of nodes in the path. Only the 'visible' nodes are counted, i.e. hidden nodes of e.g. nodekits are not included.</p><p>If you need the actual path length, you need to cast your path to <strong>SoFullPath</strong> and use <strong>SoFullPath::getLength()</strong>.</p>
<h3>void SoPath::truncate (const intlength)</h3>
<p>This method truncates the path to the given <em>length</em> (i.e. all nodes in the path list from index <em>length</em> and onwards will be removed from the path list).</p>
<h3>int SoPath::findFork (const \fBSoPath\fP *constpath) const</h3>
<p>This method returns the index of the last node that is the same for both paths, or -1 if the paths don't even start on the same node.</p>
<h3>int SoPath::findNode (const \fBSoNode\fP *constnode) const</h3>
<p>Returns the index of <em>node</em> if found in the <em>full</em> path (possibly also in the normally hidden parts), or -1<em> otherwise.</em></p><p>Note that this method is not part of the original Open Inventor API.</p>
<h3>SbBool SoPath::containsNode (const \fBSoNode\fP *constnode) const</h3>
<p>This method returns TRUE is <em>node</em> is contained somewhere in the <em>full</em> path (possibly also in the normally hidden parts), and FALSE<em> otherwise.</em></p>
<h3>SbBool SoPath::containsPath (const \fBSoPath\fP *constpath) const</h3>
<p>This method returns TRUE if path is contained in the path, and FALSE otherwise.</p>
<h3>\fBSoPath\fP * SoPath::copy (const intstartfromnodeindex = \fC0\fP, intnumnodes = \fC0\fP) const</h3>
<p>This method returns a copy of the path starting at <em>startfromnodeindex</em> with length <em>numnodes</em>. If <em>numnodes</em> is 0 (default) the path will be copied to the end.</p><p>The returned <strong>SoPath</strong> instance will have an initial reference count of 0. It is the caller's responsibility to <strong>ref()</strong> and <strong>unref()</strong> it according to use.</p>
<h3>\fBSoPath\fP * SoPath::getByName (const \fBSbName\fPname)\fC [static]\fP</h3>
<p>This static method is for retrieving an <strong>SoPath</strong> by it's <em>name</em>. The last registered <strong>SoPath</strong> with the given <em>name</em> is returned, or NULL<em> if no </em><strong>SoPath</strong><em> by </em><em>name</em><em> exists.</em></p>
<h3>int SoPath::getByName (const \fBSbName\fPname, \fBSoPathList\fP &l)\fC [static]\fP</h3>
<p>This static method is for finding all the paths with a given <em>name</em> and append them to the <em>l</em> list. The number of <strong>SoPath</strong> instances with <em>name</em> found is returned.</p>
<h3>void SoPath::insertIndex (\fBSoNode\fP *constparent, const intnewindex)</h3>
<p>This method is called when a node in the path chain has a child added, to update the index of it's child.</p><p><em>newindex</em> is the index of the child which was inserted. If <em>newindex</em> is lower than the index value of the child node stored in the path, the path is updated accordingly.</p>
<h3>void SoPath::removeIndex (\fBSoNode\fP *constparent, const intoldindex)</h3>
<p>This method is called when a node in the path chain has a child removed, to update the index of it's child.</p><p><em>oldindex</em> was the index of the removed child. If <em>oldindex</em> is lower than or equal to the index value of the child node stored in the path, the path is updated accordingly.</p>
<h3>void SoPath::replaceIndex (\fBSoNode\fP *constparent, const intindex, \fBSoNode\fP *constnewchild)</h3>
<p>This method is called when a node <em>newchild</em> replaces a node in the path. <em>index</em> is the position of the child which has been replaced.</p>
<h3>SbBool SoPath::isRelevantNotification (\fBSoNotList\fP *constl) const</h3>
<p>Return TRUE if the notification chain <em>l</em> will affect the path. <em>l</em> will affect the path either if the notification is in the path (the notification started on a field in a node in the path), or off the path (the notification started in a non-separator node that is left of the path's node).</p>
<h3>void SoPath::write (\fBSoWriteAction\fP *action)\fC [virtual]\fP</h3>
<p>This method is used to write the contents of an <strong>SoPath</strong>.</p><p>A path is written as:</p>
<pre>
Path {
  HEAD-NODE-OF-SUBGRAPH
  NUMBER-OF-INDICES
  INDEX0
  INDEX1
  ...
}

</pre>
<p>[The rest of the documentation for this method only explains the reason behind a mismatch in behavior between the original Open Inventor and Coin. Don't read it if you're not taking a particular interest. (Short version: we do <strong>SoPath</strong> export in a somewhat more inefficient way to avoid the potential for bugs).]</p><p>Note that unlike Open Inventor, we write the complete subgraph below the head node. Only writing the parts of the subgraph affecting the state for nodes within the path is error prone if a subgraph is written out as part of path <em>before</em> it is written out 'properly'. Consider writing a scene graph which looks like this (in memory):</p>
<pre>
DEF top_sep Separator {
  Cone { }
  DEF a_sphere Sphere { }
  Cube { }
}

DEF path_switch PathSwitch {
  path Path {
    ...path from "top_sep" to "a_sphere"...
  }
}
</pre>
<p>..if we now do:</p>
<pre>
SoSeparator * root = new SoSeparator;
root-&gt;addChild([ptr to path_switch]);
root-&gt;addChild([ptr to top_sep]);
SoWriteAction wa;
wa.apply(root);
</pre>
<p>..we would get the scene graph exported like this:</p>
<pre>
Separator {
  DEF path_switch PathSwitch {
    path Path {
      DEF top_sep Separator {
        DEF a_sphere Sphere {
        }
      }
      1
      0
    }
  }
  USE top_sep
}
</pre>
<p>..and as you can see, <em>both</em> the Cone and the Cube nodes has vanished, as they was not important for the part per se, and not written as part of it.</p><p>This is why we do full subgraph export for head nodes in paths.</p>
<h3>void SoPath::auditPath (const SbBoolflag)\fC [protected]\fP</h3>
<p>Set whether or not to audit the nodes in the path to detect changes.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Friends And Related Function Documentation</h2>
        <div class="sectioncontent">
<h3>SbBool operator== (const \fBSoPath\fP &lhs, const \fBSoPath\fP &rhs)\fC [friend]\fP</h3>
<p>Compares contents of path <em>lhs</em> and path <em>rhs</em>, and returns TRUE<em> if they are equal.</em></p>
<h3>SbBool operator!= (const \fBSoPath\fP &lhs, const \fBSoPath\fP &rhs)\fC [friend]\fP</h3>
<p>Returns TRUE if paths <em>lhs</em> and <em>rhs</em> does not contain the same nodes in the same order.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoPackedColor.3.html"><span aria-hidden="true">&larr;</span> SoPackedColor.3: The sopackedcolor class is a node for setting diffuse and transparency material values.  this node provides a convenient way of setting diffuse colors and transparency values with packed 32-bit rgba vectors.</a></li>
   <li class="next"><a href="SoPathList.3.html">SoPathList.3: The sopathlist class is a container for pointers to sopath objects.  as this class inherits sobaselist, referencing and dereferencing will default be done on the objects at append(), remove(), insert() etc. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pmdacache: Manage a cache of instance domain information for a pmda</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Manage a cache of instance domain information for a pmda">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pmdacache (3) manual">
  <meta name="twitter:description" content="Manage a cache of instance domain information for a pmda">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pmdacache.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pmdacache (3) manual" />
  <meta property="og:description" content="Manage a cache of instance domain information for a pmda" />
  <meta property="fb:app_id" content="1241677679199500" />

</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pmdacache<small> (3)</small></h1>
        <p class="lead">Manage a cache of instance domain information for a pmda</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pmdacache.3.html">
      <span itemprop="name">pmdacache: Manage a cache of instance domain information for a pmda</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/pcp/">
      <span itemprop="name">pcp</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pmdacache.3.html">
      <span itemprop="name">pmdacache: Manage a cache of instance domain information for a pmda</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">C SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;pcp/pmapi.h&gt;</p><p>#include &lt;pcp/pmda.h&gt;</p><p>int pmdaCacheStore(pmInDom <em>indom</em>, int <em>flags</em>, const&nbsp;char&nbsp;*<em>name</em>, void&nbsp;*<em>private</em>);</p><p>int pmdaCacheStoreKey(pmInDom <em>indom</em>, int <em>flags</em>, const&nbsp;char&nbsp;*<em>name</em>, int&nbsp;<em>keylen</em>, const void&nbsp;*<em>key</em>, void&nbsp;*<em>private</em>);</p><p>int pmdaCacheLookup(pmInDom <em>indom</em>, int <em>inst</em>, char **<em>name</em>, void&nbsp;**<em>private</em>);</p><p>int pmdaCacheLookupName(pmInDom <em>indom</em>, const char *<em>name</em>, int&nbsp;*<em>inst</em>, void&nbsp;**<em>private</em>);</p><p>int pmdaCacheLookupKey(pmInDom <em>indom</em>, const char *<em>name</em>, int&nbsp;<em>keylen</em>, const void&nbsp;*<em>key</em>, char **<em>oname</em>, int&nbsp;*<em>inst</em>, void&nbsp;**<em>private</em>);</p><p>int pmdaCacheOp(pmInDom <em>indom</em>, int <em>op</em>);</p><p>int pmdaCachePurge(pmInDom <em>indom</em>, time_t <em>recent</em>);</p><p>int pmdaCacheResize(pmInDom <em>indom</em>, int <em>maximum</em>);</p><p>cc ... -lpcp_pmda -lpcp</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>pmdaCache</strong> family of routines provide services to support the maintenance of complex instance domains for Performance Co-Pilot PMDAs. There is potentially one cache of information for each instance domain, and for each instance the cache maintains:</p><ul>
<li><p>external instance name (supplied by the PMDA)</p></li><li><p>internal instance identifier (assigned by <strong>pmdaCacheStore</strong> or calculated from a ``hint'' by <strong>pmdaCacheStoreKey</strong>)</p></li><li><p>state, where <strong>active</strong> instances are visible and part of the current instance domain, and <strong>inactive</strong> instances are hidden, but not forgotten; <strong>pmdaCacheStore</strong> or <strong>pmdaCacheStoreKey</strong> may be used to change the state of an instance</p></li><li><p>an optional opaque pointer to data that is associated with the instance, but maintained by the PMDA</p></li><li><p>an optional opaque key that is used as a ``hint'' to <strong>pmdaCacheStoreKey</strong> when guessing the initial internal instance identifier</p></li><li><p>the last time the cache was saved and the instance had been marked as <strong>active</strong> at some point since the previous cache load or save operation</p></li>
</ul><p>The semantics of a PCP instance domain require a number of rules to be followed, namely:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Each internal instance identifier must be unique and in the range 0 to 2^31&nbsp;-&nbsp;1. This rule is enforced by the <strong>pmdaCache</strong> family of routines.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>The external instance name must be unique.  When the instance name contains a space, it is further constrained such that the name to the left of the first space (the short name) must also be unique. Refer to the INSTANCE NAME MATCHING section below. The PMDA must honor this rule, the <strong>pmdaCache</strong> family of routines will detect attempts to violate this rule.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Where an external instance name corresponds to some object or entity, there is an expectation that the association between the name and the object is fixed, e.g. ``/dev/hda'' is always the name of the same disk on a particular system. This rule is perhaps the responsibility of the PMDA, but is often a characteristic of the environment in which the PMDA runs.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>It is preferable, although not mandatory, for the association between and external instance name and an internal instance identifier to be persistent. This rule is supported by the <strong>pmdaCache</strong> family of routines.</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>When opaque keys are used, the values of the keys must be unique across all instances within an instance domain. This rule is enforced by the <strong>pmdaCache</strong> family of routines.</p>
  </dd>

</dl>
<p>The visible interface to the cache is oriented towards the PMDA developer who is most concerned about the names of instances, while the details of how the rest of the PCP infrastructure expects the internal instance identifiers to be managed is not relevant.</p><p>Instances are updated in the cache for instance domain <em>indom</em> by calling <strong>pmdaCacheStore</strong> or <strong>pmdaCacheStoreKey</strong> with the external name of the instance passed via <em>name.</em> The opaque pointer <em>private</em> may be used to associate additional data with the entry in the cache; if no such data is required, <em>private</em> should be NULL. Any manipulation of the additional data (including allocation or freeing) is the responsibility of the PMDA caller, as the cache simply maintains the pointer to the data (passed via <em>private</em>).</p><p>The upper bound for identifiers allocated for any given <em>indom</em> cache can be optionally reduced from the default (2^31&nbsp;-&nbsp;1) to some lesser <em>maximum</em>, using <strong>pmdaCacheResize</strong>. This <em>maximum</em> will then be persisted and restored in the usual manner, and can thus be associated permanently with a cache once set. This has applications when using these interfaces as general purpose identifier caches, and is less applicable when using them for instance domain caching.</p><p>For cases where the PMDA developer wishes to influence the allocation of internal instance identifiers, e.g. for instance domains with more than one natural dimension, or where there is a desire to allocate the same instance identifier each time the PMDA is started, even on different hosts, <strong>pmdaCacheStoreKey</strong> may be used. In this case, an initial ``hint'' for the instance identifier is provided as an opaque key via the first <em>keylen</em> bytes in <em>key</em> (which could be any sort of data, including binary values) else if <em>keylen</em> is less than 1 or <em>key</em> is <strong>NULL</strong> then <em>name</em> is used as the ``hint''. The ``hint'' is hashed to produce an initial instance identifier in the range 0 to 2^31&nbsp;-&nbsp;1 (or lesser <em>maximum</em>, if set).  If this instance identifier is already allocated, then the value is rehashed.  This procedure is repeated until an unallocated instance identifier is found, or <strong>pmdaCacheStoreKey</strong> gives up and returns <strong>PM_ERR_GENERIC</strong>. For each instance domain, the ``hint'' must be unique across all instances, else <strong>pmdaCacheStoreKey</strong> returns <strong>PM_ERR_INST</strong>.</p><p>The <em>flags</em> argument controls how the instance should be processed in the cache as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p>PMDA_CACHE_ADD</p>
  </dt>
  <dd>
    <p>Insert the entry into the cache if it is not already there and mark it <strong>active</strong>. If the entry is already in the cache mark it <strong>active</strong>.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_HIDE</p>
  </dt>
  <dd>
    <p>Mark the entry in the cache as <strong>inactive</strong>, but remember the details of the association between the external instance name and the internal instance identifier. Entries that are <strong>inactive</strong> will be hidden from cache traversal via PMDA_CACHE_WALK_NEXT operations, but remain visible to <strong>pmdaCacheLookup</strong>, <strong>pmdaCacheLookupName</strong> and <strong>pmdaCacheLookupKey</strong> requests.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_CULL</p>
  </dt>
  <dd>
    <p>Remove the entry from the cache.</p>
  </dd>

</dl>
<p>On success <strong>pmdaCacheStore</strong> or <strong>pmdaCacheStoreKey</strong> will return the internal instance identifier of the associated cache entry. Valid instance identifiers are guaranteed to be unique and non-negative. Failure will be indicated by a negative value (suitable for decoding with <a href="../man3/pmerrstr.3.html"><strong>pmErrStr</strong>(3)</a>) and most likely PM_ERR_INST to indicate the requested instance is not in the cache, or -EINVAL to indicate a potential violation of the short name uniqueness property (see the INSTANCE NAME MATCHING section below).</p><p><strong>pmdaCacheLookup</strong> is used to search the entries in the cache based on the internal instance identifier <em>inst</em>.</p><p>On success the return value will be PMDA_CACHE_ACTIVE or PMDA_CACHE_INACTIVE (depending on the <strong>active</strong> or <strong>inactive</strong> state of the cache entry), <em>name</em> (if not NULL) and <em>private</em> (if not NULL) will be set to the external instance name and the associate additional data area as provided when the instance was last activated via <strong>pmdaCacheStore</strong> or <strong>pmdaCacheStoreKey</strong>.</p><p><strong>pmdaCacheLookup</strong> failure is indicated by a negative return value suitable for decoding with <a href="../man3/pmerrstr.3.html"><strong>pmErrStr</strong>(3)</a>.</p><p>The <strong>pmdaCacheLookup</strong> interface is required by the PMDA's fetch callback that is registered via <strong>pmdaSetFetchCallback</strong>(3). Here the internal instance identifier is passed to the fetch callback to identifier for which instance a value is required. Typical usage is shown in the code fragment below.</p>
<pre>
static int
foo_callback(pmdaMetric *mdesc, unsigned int inst, pmAtomValue *atom)
{
    mydata   *mdp;
    char     *name;
    int      sts;

    sts = pmdaCacheLookup(mdesc-&gt;m_desc.indom, inst, &name, (void **)&mdp);
    /*
     * expect sts == PMDA_CACHE_ACTIVE except for cataclysmic events
     * use mdp as required, name may be useful for diagnostics
     */
    ...
</pre>
<p><strong>pmdaCacheLookupName</strong> is used to search the entries in the cache based on the external instance name <em>name</em>.</p><p>On success the return value will be PMDA_CACHE_ACTIVE or PMDA_CACHE_INACTIVE (depending on the <strong>active</strong> or <strong>inactive</strong> state of the cache entry), <em>inst</em> (if not NULL) and <em>private</em> (if not NULL) will be set to the internal instance identifier and the associate additional data area as provided when the instance was last activated via <strong>pmdaCacheStore</strong> or <strong>pmdaCacheStoreKey</strong>.</p><p><strong>pmdaCacheLookupName</strong> failure is indicated by a negative return value suitable for decoding with <a href="../man3/pmerrstr.3.html"><strong>pmErrStr</strong>(3)</a>.</p><p>The <strong>pmdaCacheLookupName</strong> interface is useful for PMDAs wishing to update an instance domain based on the external instance names.</p><p><strong>pmdaCacheLookupKey</strong> is used to search the entries in the cache based on an opaque key (or ``hint'') previously used in a call to <strong>pmdaCacheStoreKey</strong>. The ``hint'' is provided via the first <em>keylen</em> bytes in <em>key</em>. For symmetry with <strong>pmdaCacheStoreKey</strong>, if <em>keylen</em> is less than 1 or <em>key</em> is <strong>NULL</strong> then <em>name</em> is used as the ``hint'' (although the results will be the same as calling <strong>pmdaCacheLookupName</strong> in this case).</p><p>On success the return value will be PMDA_CACHE_ACTIVE or PMDA_CACHE_INACTIVE (depending on the <strong>active</strong> or <strong>inactive</strong> state of the cache entry), <em>oname</em> (if not NULL), <em>inst</em> (if not NULL) and <em>private</em> (if not NULL) will be set to the external instance name, the internal instance identifier and the associate additional data area as provided when the instance was last activated via <strong>pmdaCacheStore</strong> or <strong>pmdaCacheStoreKey</strong>.</p><p><strong>pmdaCacheLookupKey</strong> failure is indicated by a negative return value suitable for decoding with <a href="../man3/pmerrstr.3.html"><strong>pmErrStr</strong>(3)</a>.</p><p>To avoid a persistent cache growing without bound, <strong>pmdaCachePurge</strong> can be used to cull all entries that have <em>not</em> been <strong>active</strong> in the last <em>recent</em> seconds. For performance reasons, the time accounting is imprecise and the entries are timestamped at the time of the next cache save operation <em>after</em> the entry has been added or marked <strong>active</strong> (refer to PMDA_CACHE_SAVE and PMDA_CACHE_SYNC below). On success <strong>pmdaCachePurge</strong> returns the number of culled entries, else in the case of an error the return value is negative (and suitable for decoding with <a href="../man3/pmerrstr.3.html"><strong>pmErrStr</strong>(3)</a>).</p><p><strong>pmdaCacheOp</strong> may be used to perform additional operations on the cache as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p>PMDA_CACHE_LOAD</p>
  </dt>
  <dd>
    <p>The cache can optionally be maintained as a persistent external file, so that the mapping of instance names to instance identifiers is persistent across executions of a PMDA. This operation loads the cache from the external file, and then all new cache entries are marked <strong>inactive</strong>, and the additional data pointer is set to NULL. Entries loaded from the external file are checked against the current cache contents and if the instance name and instance identifiers match then the state in the cache ( .B active or <strong>inactive</strong>) is not changed. Should a mismatch be found (same instance name and different instance identifier, or same instance identifier and different instance name, or some but not all of the instance identifier, the instance name and the ``hint'' match) then the entry from the external file is ignored and a warning is issued on <em>stderr</em>. Typically a PMDA would only perform this operation once per execution.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_SAVE</p>
  </dt>
  <dd>
    <p>If any instance has been added to, or deleted from, the instance domain since the last PMDA_CACHE_LOAD, PMDA_CACHE_SAVE or PMDA_CACHE_SYNC operation, the <em>entire</em> cache is written to the external file as a bulk operation. This operation is provided for PMDAs that are <em>not</em> interested in using <strong>pmdaCachePurge</strong> and simply want the external file to reflect the set of known instances without accurate details of when they were last marked <strong>active</strong>.</p><p>Returns the number of instances saved to the external file, else 0 if the external file was already up to date.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_STRINGS</p>
  </dt>
  <dd>
    <p>Annotates this cache as being a special-purpose cache used for string de-duplication in PMDAs exporting large numbers of string valued metrics. This can be used to reduce the memory footprint of the PMDA (duplicate strings hash to the same bucket, and are stored in memory once only). Key comparisons are not terminated at the first space but rather the entire string is used for matching. These are specialised caches not useful for general purpose instance domain handling.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_SYNC</p>
  </dt>
  <dd>
    <p>Within an instance domain, if any instance has been added to, or deleted from, or marked <strong>active</strong> since the last PMDA_CACHE_LOAD, PMDA_CACHE_SAVE or PMDA_CACHE_SYNC operation, the <em>entire</em> cache is written to the external file as a bulk operation. This operation is similar to PMDA_CACHE_SAVE, but will save the instance domain more frequently so the timestamps more accurately match the semantics expected by <strong>pmdaCachePurge</strong>.</p><p>Returns the number of instances saved to the external file, else 0 if the external file was already synchronized.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_CHECK</p>
  </dt>
  <dd>
    <p>Returns 1 if a cache exists for the specified instance domain, else 0.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_REUSE</p>
  </dt>
  <dd>
    <p>When a new instance is added to the cache, the default strategy is to assign instance identifiers in a monotonic increasing manner.  Once the maximum possible instance identifier value has been assigned, the strategy changes to one where starting from 0, the next available unused instance identifier will be used. Calling <strong>pmdaCacheOp</strong> with PMDA_CACHE_REUSE forces an irreversible change to a second (reuse) strategy where the next unallocated instance identifier will be used.  This may be useful in cases where there is a desire to restrict the allocated instance identifiers to smaller values.  The prevailing strategy will be saved and restored across PMDA_CACHE_SAVE and PMDA_CACHE_LOAD operations. If <strong>pmdaCacheStoreKey</strong> is ever used, the associated instance domain will be changed to PMDA_CACHE_REUSE mode.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_REORG</p>
  </dt>
  <dd>
    <p>Reorganize the cache to allow faster retrieval of <strong>active</strong> entries, and the cost of slower retrieval for <strong>inactive</strong> entries, and reclaim any culled entries.  The cache may be internally re-organized as entries are added, so this operation is not required for most PMDAs.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_WALK_REWIND</p>
  </dt>
  <dd>
    <p>Prepares for a traversal of the cache in ascending instance identifier sequence.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_WALK_NEXT</p>
  </dt>
  <dd>
    <p>Fetch the next <strong>active</strong> instance identifier from the cache.  Requires a prior call using PMDA_CACHE_WALK_REWIND and will return -1 when all instances have been processed.</p><p>Only one cache walk can be active at any given time, nesting calls to PMDA_CACHE_WALK and PMDA_CACHE_REWIND will interfere with each other.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_ACTIVE</p>
  </dt>
  <dd>
    <p>Changes <strong>every</strong> <strong>inactive</strong> entry in the cache to be marked <strong>active</strong>.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_INACTIVE</p>
  </dt>
  <dd>
    <p>Changes <strong>every</strong> <strong>active</strong> entry in the cache to be marked <strong>inactive</strong>.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_CULL</p>
  </dt>
  <dd>
    <p>Remove <strong>every</strong> entry from the cache.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_SIZE</p>
  </dt>
  <dd>
    <p>Return the number of entries in the cache (includes <strong>active</strong>, <strong>inactive</strong> and any culled entries that have not yet been reclaimed).</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_SIZE_ACTIVE</p>
  </dt>
  <dd>
    <p>Return the number of <strong>active</strong> entries in the cache.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_SIZE_INACTIVE</p>
  </dt>
  <dd>
    <p>Return the number of <strong>inactive</strong> entries in the cache.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_DUMP</p>
  </dt>
  <dd>
    <p>Dump the current state of the cache on <em>stderr</em>.</p>
  </dd>
  <dt>
    <p>PMDA_CACHE_DUMP_ALL</p>
  </dt>
  <dd>
    <p>Like PMDA_CACHE_DUMP, but also dump the internal hashing structures used to support lookup by instance name, lookup by instance identifier and the collision statistics for ``hint'' hashing from <strong>pmdaCacheStoreKey</strong>.</p>
  </dd>

</dl>
<p><strong>pmdaCacheOp</strong> returns a non-negative value on success, and failure is indicated by a negative return value (suitable for decoding with <a href="../man3/pmerrstr.3.html"><strong>pmErrStr</strong>(3)</a>).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER CONSIDERATIONS</h2>
        <div class="sectioncontent">
<p>When the <strong>pmdaCache</strong> routines are used for particular instance domain, <strong>pmdaInstance (3)</strong> and the instance domain enumeration behind <a href="../man3/pmdafetch.3.html"><strong>pmdaFetch</strong>(3)</a> will attempt to extract instance domain information from the cache, thereby avoiding reference to the <strong>pmdaIndom</strong> data structures that have historically been used to define instance domains and service instance requests. A PMDA can adopt a hybrid approach and choose to implement some instance domains via the traditional <strong>pmdaIndom</strong> method, and others via the <strong>pmdaCache</strong> approach, however attempts to manage the <em>same</em> instance domain by both methods will result in the <strong>pmdaCache</strong> method silently prevailing.</p><p>If <strong>all</strong> instances in a PMDA are to be serviced from a <strong>pmdaCache</strong> then a <strong>pmdaIndom</strong> is not required, and the <strong>pmdaInit (3)</strong> call becomes</p>
<pre>
    pmdaInit(dp, NULL, 0, metrictab, nmetrics);
</pre>
<p>However, the PMDA will need to explicitly initialize the <strong>indom</strong> field of the <strong>pmDesc</strong> in the <em>metrictab</em> entries, as this cannot be done by <a href="../man3/pmdainit.3.html"><strong>pmdaInit</strong>(3)</a> if <em>indomtab</em> is missing entries for the instance domains maintained in the cache.</p><p>Independent of how the instance domain is being maintained, to refresh an instance domain prior to a fetch or an instance domain operation, the standard methods of a ``wrapper'' to the <strong>pmdaInstance (3)</strong> and <strong>pmdaFetch (3)</strong> methods should be used.</p><p>Refer to the <strong>simple</strong> PMDA source code for an example use of the <strong>pmdaCache</strong> routines.</p><p>When using <strong>pmdaCacheStoreKey</strong>, if there is a desire to ensure the given ``hint'' generates the same initial instance identifier across all platforms, then the caller should ensure the endian and word-size issues are considered, e.g. if the natural data structure used for the <em>key</em> is an array of 32-bit integers, then <a href="../man3/htonl.3.html"><strong>htonl</strong>(3)</a> should be used on each element of the array before calling <strong>pmdaCacheStoreKey</strong> or <strong>pmdaCacheLookupKey</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTANCE NAME MATCHING</h2>
        <div class="sectioncontent">
<p>The following table summarizes the ``short name'' matching semantics for an instance domain (caches other than PMDA_CACHE_STRINGS style).</p><table class="table table-striped">
<tr>
<th>name in</th>
<th><strong>pmdaCacheLookup</strong></th>
<th>result</th>
<th></th>
<th></th></tr>

<tr>
<td>cache</td>
<td>name</td>
<td></td>
<td></td>
<td></td></tr>

<tr>
<td>foodle</td>
<td>foo</td>
<td>no match (PM_ERR_INST)</td>
<td></td>
<td></td></tr>

<tr>
<td>foo</td>
<td>foodle</td>
<td>no match (PM_ERR_INST)</td>
<td></td>
<td></td></tr>

<tr>
<td>foo</td>
<td>foo</td>
<td>match</td>
<td></td>
<td></td></tr>

<tr>
<td>foo bar</td>
<td>foo</td>
<td>match on short name (instance identifier)</td>
<td></td>
<td></td></tr>

<tr>
<td>foo bar</td>
<td>foo bar</td>
<td>match on full name (instance identifier)</td>
<td></td>
<td></td></tr>

<tr>
<td>foo</td>
<td>foo bar</td>
<td>bad match (-EDOM)</td>
<td></td>
<td></td></tr>

<tr>
<td>foo bar</td>
<td>foo blah</td>
<td>bad match (-EDOM)</td>
<td></td>
<td></td></tr>
</table>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>Cache persistence uses files with names constructed from the <em>indom</em> within the <strong>$PCP_VAR_DIR/config/pmda</strong> directory.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pmdacache&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/byteorder.3.html"><strong>BYTEORDER</strong>(3)</a>, <a href="../man3/pmapi.3.html"><strong>PMAPI</strong>(3)</a>, <a href="../man3/pmda.3.html"><strong>PMDA</strong>(3)</a>, <a href="../man3/pmdainit.3.html"><strong>pmdaInit</strong>(3)</a>, <a href="../man3/pmdainstance.3.html"><strong>pmdaInstance</strong>(3)</a>, <a href="../man3/pmdafetch.3.html"><strong>pmdaFetch</strong>(3)</a>, <strong>pmdaSetFetchCallback</strong>(3), <a href="../man3/pmerrstr.3.html"><strong>pmErrStr</strong>(3)</a> and <a href="../man3/pmgetindom.3.html"><strong>pmGetInDom</strong>(3)</a>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pmdaattribute.3.html"><span aria-hidden="true">&larr;</span> pmdaattribute.3: Informs a pmda about client connection attributes</a></li>
   <li class="next"><a href="pmdachildren.3.html">pmdachildren.3: Translate a pmid to a set of dynamic performance metric names <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>zmq_socket: Create 0mq socket</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Create 0mq socket">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="zmq_socket (3) manual">
  <meta name="twitter:description" content="Create 0mq socket">
  <meta name="twitter:image" content="https://www.carta.tech/images/libzmq-dev-zmq_socket-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libzmq-dev-zmq_socket.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="zmq_socket (3) manual" />
  <meta property="og:description" content="Create 0mq socket" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libzmq-dev-zmq_socket-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">zmq_socket<small> (3)</small></h1>
        <p class="lead">Create 0mq socket</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/zmq_socket.3.html">
      <span itemprop="name">zmq_socket: Create 0mq socket</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libzmq-dev/">
      <span itemprop="name">libzmq-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/zmq_socket.3.html">
      <span itemprop="name">zmq_socket: Create 0mq socket</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>void *zmq_socket (void </strong><strong></strong><em>*context</em><strong>, int </strong><strong></strong><em>type</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <em>zmq_socket()</em> function shall create a 0MQ socket within the specified <em>context</em> and return an opaque handle to the newly created socket. The <em>type</em> argument specifies the socket type, which determines the semantics of communication over the socket.</p><p>The newly created socket is initially unbound, and not associated with any endpoints. In order to establish a message flow a socket must first be connected to at least one endpoint with <a href="../man3/zmq_connect.3.html"><strong>zmq_connect</strong>(3)</a>, or at least one endpoint must be created for accepting incoming connections with <a href="../man3/zmq_bind.3.html"><strong>zmq_bind</strong>(3)</a>.</p><p><strong>Key differences to conventional sockets</strong>. Generally speaking, conventional sockets present a <em>synchronous</em> interface to either connection-oriented reliable byte streams (SOCK_STREAM), or connection-less unreliable datagrams (SOCK_DGRAM). In comparison, 0MQ sockets present an abstraction of an asynchronous <em>message queue</em>, with the exact queueing semantics depending on the socket type in use. Where conventional sockets transfer streams of bytes or discrete datagrams, 0MQ sockets transfer discrete <em>messages</em>.</p><p>0MQ sockets being <em>asynchronous</em> means that the timings of the physical connection setup and tear down, reconnect and effective delivery are transparent to the user and organized by 0MQ itself. Further, messages may be <em>queued</em> in the event that a peer is unavailable to receive them.</p><p>Conventional sockets allow only strict one-to-one (two peers), many-to-one (many clients, one server), or in some cases one-to-many (multicast) relationships. With the exception of <em>ZMQ_PAIR</em>, 0MQ sockets may be connected <strong>to multiple endpoints</strong> using <em>zmq_connect()</em>, while simultaneously accepting incoming connections <strong>from multiple endpoints</strong> bound to the socket using <em>zmq_bind()</em>, thus allowing many-to-many relationships.</p><p><strong>Thread safety</strong>. 0MQ <em>sockets</em> are <em>not</em> thread safe. Applications MUST NOT use a socket from multiple threads except after migrating a socket from one thread to another with a "full fence" memory barrier.</p><p><strong>Socket types</strong>. The following sections present the socket types defined by 0MQ, grouped by the general <em>messaging pattern</em> which is built from related socket types.</p><h3>Request-reply pattern</h3>
<p>The request-reply pattern is used for sending requests from a ZMQ_REQ <em>client</em> to one or more ZMQ_REP <em>services</em>, and receiving subsequent replies to each request sent.</p><p>The request-reply pattern is formally defined by \m[blue]<strong>http://rfc.zeromq.org/spec:28</strong>\m[].</p><p><strong>ZMQ_REQ</strong></p><p>A socket of type <em>ZMQ_REQ</em> is used by a <em>client</em> to send requests to and receive replies from a <em>service</em>. This socket type allows only an alternating sequence of <em>zmq_send(request)</em> and subsequent <em>zmq_recv(reply)</em> calls. Each request sent is round-robined among all <em>services</em>, and each reply received is matched with the last issued request.</p><p>If no services are available, then any send operation on the socket shall block until at least one <em>service</em> becomes available. The REQ socket shall not discard messages.</p><p><strong>Table&nbsp;1.&nbsp;Summary of ZMQ_REQ characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_REP</em>, <em>ZMQ_ROUTER</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send, Receive, Send, Receive, ... </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Round-robin </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Last peer </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Block </td></tr>
</table><p><strong>ZMQ_REP</strong></p><p>A socket of type <em>ZMQ_REP</em> is used by a <em>service</em> to receive requests from and send replies to a <em>client</em>. This socket type allows only an alternating sequence of <em>zmq_recv(request)</em> and subsequent <em>zmq_send(reply)</em> calls. Each request received is fair-queued from among all <em>clients</em>, and each reply sent is routed to the <em>client</em> that issued the last request. If the original requester does not exist any more the reply is silently discarded.</p><p><strong>Table&nbsp;2.&nbsp;Summary of ZMQ_REP characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_REQ</em>, <em>ZMQ_DEALER</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive, Send, Receive, Send, ... </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Last peer </td></tr>
</table><p><strong>ZMQ_DEALER</strong></p><p>A socket of type <em>ZMQ_DEALER</em> is an advanced pattern used for extending request/reply sockets. Each message sent is round-robined among all connected peers, and each message received is fair-queued from all connected peers.</p><p>When a <em>ZMQ_DEALER</em> socket enters the <em>mute</em> state due to having reached the high water mark for all peers, or if there are no peers at all, then any <a href="../man3/zmq_send.3.html"><strong>zmq_send</strong>(3)</a> operations on the socket shall block until the mute state ends or at least one peer becomes available for sending; messages are not discarded.</p><p>When a <em>ZMQ_DEALER</em> socket is connected to a <em>ZMQ_REP</em> socket each message sent must consist of an empty message part, the <em>delimiter</em>, followed by one or more <em>body parts</em>.</p><p><strong>Table&nbsp;3.&nbsp;Summary of ZMQ_DEALER characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_ROUTER</em>, <em>ZMQ_REP</em>, <em>ZMQ_DEALER</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Unrestricted </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Round-robin </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Block </td></tr>
</table><p><strong>ZMQ_ROUTER</strong></p><p>A socket of type <em>ZMQ_ROUTER</em> is an advanced socket type used for extending request/reply sockets. When receiving messages a <em>ZMQ_ROUTER</em> socket shall prepend a message part containing the <em>identity</em> of the originating peer to the message before passing it to the application. Messages received are fair-queued from among all connected peers. When sending messages a <em>ZMQ_ROUTER</em> socket shall remove the first part of the message and use it to determine the <em>identity</em> of the peer the message shall be routed to. If the peer does not exist anymore the message shall be silently discarded by default, unless <em>ZMQ_ROUTER_MANDATORY</em> socket option is set to <em>1</em>.</p><p>When a <em>ZMQ_ROUTER</em> socket enters the <em>mute</em> state due to having reached the high water mark for all peers, then any messages sent to the socket shall be dropped until the mute state ends. Likewise, any messages routed to a peer for which the individual high water mark has been reached shall also be dropped.</p><p>When a <em>ZMQ_REQ</em> socket is connected to a <em>ZMQ_ROUTER</em> socket, in addition to the <em>identity</em> of the originating peer each message received shall contain an empty <em>delimiter</em> message part. Hence, the entire structure of each received message as seen by the application becomes: one or more <em>identity</em> parts, <em>delimiter</em> part, one or more <em>body parts</em>. When sending replies to a <em>ZMQ_REQ</em> socket the application must include the <em>delimiter</em> part.</p><p><strong>Table&nbsp;4.&nbsp;Summary of ZMQ_ROUTER characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_DEALER</em>, <em>ZMQ_REQ</em>, <em>ZMQ_ROUTER</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Unrestricted </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  See text </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Drop </td></tr>
</table>
<h3>Publish-subscribe pattern</h3>
<p>The publish-subscribe pattern is used for one-to-many distribution of data from a single <em>publisher</em> to multiple <em>subscribers</em> in a fan out fashion.</p><p>The publish-subscribe pattern is formally defined by \m[blue]<strong>http://rfc.zeromq.org/spec:29</strong>\m[].</p><p><strong>ZMQ_PUB</strong></p><p>A socket of type <em>ZMQ_PUB</em> is used by a <em>publisher</em> to distribute data. Messages sent are distributed in a fan out fashion to all connected peers. The <a href="../man3/zmq_recv.3.html"><strong>zmq_recv</strong>(3)</a> function is not implemented for this socket type.</p><p>When a <em>ZMQ_PUB</em> socket enters the <em>mute</em> state due to having reached the high water mark for a <em>subscriber</em>, then any messages that would be sent to the <em>subscriber</em> in question shall instead be dropped until the mute state ends. The <em>zmq_send()</em> function shall never block for this socket type.</p><p><strong>Table&nbsp;5.&nbsp;Summary of ZMQ_PUB characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_SUB</em>, <em>ZMQ_XSUB</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Unidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send only </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Fan out </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Drop </td></tr>
</table><p><strong>ZMQ_SUB</strong></p><p>A socket of type <em>ZMQ_SUB</em> is used by a <em>subscriber</em> to subscribe to data distributed by a <em>publisher</em>. Initially a <em>ZMQ_SUB</em> socket is not subscribed to any messages, use the <em>ZMQ_SUBSCRIBE</em> option of <a href="../man3/zmq_setsockopt.3.html"><strong>zmq_setsockopt</strong>(3)</a> to specify which messages to subscribe to. The <em>zmq_send()</em> function is not implemented for this socket type.</p><p><strong>Table&nbsp;6.&nbsp;Summary of ZMQ_SUB characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_PUB</em>, <em>ZMQ_XPUB</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Unidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive only </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  N/A </td></tr>
</table><p><strong>ZMQ_XPUB</strong></p><p>Same as ZMQ_PUB except that you can receive subscriptions from the peers in form of incoming messages. Subscription message is a byte 1 (for subscriptions) or byte 0 (for unsubscriptions) followed by the subscription body. Messages without a sub/unsub prefix are also received, but have no effect on subscription status.</p><p><strong>Table&nbsp;7.&nbsp;Summary of ZMQ_XPUB characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_SUB</em>, <em>ZMQ_XSUB</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Unidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send messages, receive subscriptions </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Fan out </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Drop </td></tr>
</table><p><strong>ZMQ_XSUB</strong></p><p>Same as ZMQ_SUB except that you subscribe by sending subscription messages to the socket. Subscription message is a byte 1 (for subscriptions) or byte 0 (for unsubscriptions) followed by the subscription body. Messages without a sub/unsub prefix may also be sent, but have no effect on subscription status.</p><p><strong>Table&nbsp;8.&nbsp;Summary of ZMQ_XSUB characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_PUB</em>, <em>ZMQ_XPUB</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Unidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive messages, send subscriptions </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Drop </td></tr>
</table>
<h3>Pipeline pattern</h3>
<p>The pipeline pattern is used for distributing data to <em>nodes</em> arranged in a pipeline. Data always flows down the pipeline, and each stage of the pipeline is connected to at least one <em>node</em>. When a pipeline stage is connected to multiple <em>nodes</em> data is round-robined among all connected <em>nodes</em>.</p><p>The pipeline pattern is formally defined by \m[blue]<strong>http://rfc.zeromq.org/spec:30</strong>\m[].</p><p><strong>ZMQ_PUSH</strong></p><p>A socket of type <em>ZMQ_PUSH</em> is used by a pipeline <em>node</em> to send messages to downstream pipeline <em>nodes</em>. Messages are round-robined to all connected downstream <em>nodes</em>. The <em>zmq_recv()</em> function is not implemented for this socket type.</p><p>When a <em>ZMQ_PUSH</em> socket enters the <em>mute</em> state due to having reached the high water mark for all downstream <em>nodes</em>, or if there are no downstream <em>nodes</em> at all, then any <a href="../man3/zmq_send.3.html"><strong>zmq_send</strong>(3)</a> operations on the socket shall block until the mute state ends or at least one downstream <em>node</em> becomes available for sending; messages are not discarded.</p><p><strong>Table&nbsp;9.&nbsp;Summary of ZMQ_PUSH characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_PULL</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Unidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send only </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Round-robin </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Block </td></tr>
</table><p><strong>ZMQ_PULL</strong></p><p>A socket of type <em>ZMQ_PULL</em> is used by a pipeline <em>node</em> to receive messages from upstream pipeline <em>nodes</em>. Messages are fair-queued from among all connected upstream <em>nodes</em>. The <em>zmq_send()</em> function is not implemented for this socket type.</p><p><strong>Table&nbsp;10.&nbsp;Summary of ZMQ_PULL characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_PUSH</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Unidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive only </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Block </td></tr>
</table>
<h3>Exclusive pair pattern</h3>
<p>The exclusive pair pattern is used to connect a peer to precisely one other peer. This pattern is used for inter-thread communication across the inproc transport.</p><p>The exclusive pair pattern is formally defined by \m[blue]<strong>http://rfc.zeromq.org/spec:31</strong>\m[].</p><p><strong>ZMQ_PAIR</strong></p><p>A socket of type <em>ZMQ_PAIR</em> can only be connected to a single peer at any one time. No message routing or filtering is performed on messages sent over a <em>ZMQ_PAIR</em> socket.</p><p>When a <em>ZMQ_PAIR</em> socket enters the <em>mute</em> state due to having reached the high water mark for the connected peer, or if no peer is connected, then any <a href="../man3/zmq_send.3.html"><strong>zmq_send</strong>(3)</a> operations on the socket shall block until the peer becomes available for sending; messages are not discarded.</p><p><strong>Note</strong></p><p><em>ZMQ_PAIR</em> sockets are designed for inter-thread communication across the <a href="../man7/zmq_inproc.7.html"><strong>zmq_inproc</strong>(7)</a> transport and do not implement functionality such as auto-reconnection. <em>ZMQ_PAIR</em> sockets are considered experimental and may have other missing or broken aspects.</p><p><strong>Table&nbsp;11.&nbsp;Summary of ZMQ_PAIR characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>ZMQ_PAIR</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Unrestricted </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  Block </td></tr>
</table>
<h3>Native Pattern</h3>
<p>The native pattern is used for communicating with TCP peers and allows asynchronous requests and replies in either direction.</p><p><strong>ZMQ_STREAM</strong></p><p>A socket of type <em>ZMQ_STREAM</em> is used to send and receive TCP data from a non-0MQ peer, when using the tcp:// transport. A <em>ZMQ_STREAM</em> socket can act as client and/or server, sending and/or receiving TCP data asynchronously.</p><p>When receiving TCP data, a <em>ZMQ_STREAM</em> socket shall prepend a message part containing the <em>identity</em> of the originating peer to the message before passing it to the application. Messages received are fair-queued from among all connected peers.</p><p>When sending TCP data, a <em>ZMQ_STREAM</em> socket shall remove the first part of the message and use it to determine the <em>identity</em> of the peer the message shall be routed to, and unroutable messages shall cause an EHOSTUNREACH or EAGAIN error.</p><p>To open a connection to a server, use the zmq_connect call, and then fetch the socket identity using the ZMQ_IDENTITY zmq_getsockopt call.</p><p>To close a specific client connection, as a server, send the identity frame followed by a zero-length message (see EXAMPLE section).</p><p>The ZMQ_MSGMORE flag is ignored on data frames. You must send one identity frame followed by one data frame.</p><p>Also, please note that omitting the ZMQ_MSGMORE flag will prevent sending further data (from any client) on the same socket.</p><p><strong>Table&nbsp;12.&nbsp;Summary of ZMQ_STREAM characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  none. </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Unrestricted </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  See text </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Action in mute state </td>
<td>  EAGAIN </td></tr>
</table>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>The <em>zmq_socket()</em> function shall return an opaque handle to the newly created socket if successful. Otherwise, it shall return NULL and set <em>errno</em> to one of the values defined below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p><strong>EINVAL</strong></p><p>The requested socket <em>type</em> is invalid.</p><p><strong>EFAULT</strong></p><p>The provided <em>context</em> is invalid.</p><p><strong>EMFILE</strong></p><p>The limit on the total number of open 0MQ sockets has been reached.</p><p><strong>ETERM</strong></p><p>The context specified was terminated.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p><strong>Creating a simple HTTP server using ZMQ_STREAM</strong>.</p>
<pre>
void *ctx = zmq_ctx_new ();
assert (ctx);
/* Create ZMQ_STREAM socket */
void *socket = zmq_socket (ctx, ZMQ_STREAM);
assert (socket);
int rc = zmq_bind (socket, "tcp://*:8080");
assert (rc == 0);
/* Data structure to hold the ZMQ_STREAM ID */
uint8_t id [256];
size_t id_size = 256;
while (1) {
        /*  Get HTTP request; ID frame and then request */
        id_size = zmq_recv (socket, id, 256, 0);
        assert (id_size &gt; 0);
        /* Prepares the response */
        char http_response [] =
                "HTTP/1.0 200 OK&#92;r&#92;n"
                "Content-Type: text/plain&#92;r&#92;n"
                "&#92;r&#92;n"
                "Hello, World!";
        /* Sends the ID frame followed by the response */
        zmq_send (socket, id, id_size, ZMQ_SNDMORE);
        zmq_send (socket, http_response, strlen (http_response), ZMQ_SNDMORE);
        /* Closes the connection by sending the ID frame followed by a zero response */
        zmq_send (socket, id, id_size, ZMQ_SNDMORE);
        zmq_send (socket, 0, 0, ZMQ_SNDMORE);
        /* NOTE: If we don&apos;t use ZMQ_SNDMORE, then we won&apos;t be able to send more */
        /* message to any client */
}
zmq_close (socket);
zmq_ctx_destroy (ctx);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO zmq_socket&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/zmq_init.3.html"><strong>zmq_init</strong>(3)</a> <a href="../man3/zmq_setsockopt.3.html"><strong>zmq_setsockopt</strong>(3)</a> <a href="../man3/zmq_bind.3.html"><strong>zmq_bind</strong>(3)</a> <a href="../man3/zmq_connect.3.html"><strong>zmq_connect</strong>(3)</a> <a href="../man3/zmq_send.3.html"><strong>zmq_send</strong>(3)</a> <a href="../man3/zmq_recv.3.html"><strong>zmq_recv</strong>(3)</a> <a href="../man7/zmq_inproc.7.html"><strong>zmq_inproc</strong>(7)</a> <a href="../man7/zmq.7.html"><strong>zmq</strong>(7)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>This page was written by the 0MQ community. To make a change please read the 0MQ Contribution Policy at \m[blue]<strong>http://www.zeromq.org/docs:contributing</strong>\m[].</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libzmq3-dev-zmq_setsockopt.3.html"><span aria-hidden="true">&larr;</span> zmq_setsockopt.3: Set 0mq socket options</a></li>
   <li class="next"><a href="libzmq3-dev-zmq_socket.3.html">zmq_socket.3: Create 0mq socket <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

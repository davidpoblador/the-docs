<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TextBuffer: Operations on unstructured text</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Operations on unstructured text">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="TextBuffer (3I) manual">
  <meta name="twitter:description" content="Operations on unstructured text">
  <meta name="twitter:image" content="https://www.carta.tech/images/ivtools-dev-TextBuffer-3I.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3I/TextBuffer.3I.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="TextBuffer (3I) manual" />
  <meta property="og:description" content="Operations on unstructured text" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ivtools-dev-TextBuffer-3I.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">TextBuffer<small> (3I)</small></h1>
        <p class="lead">Operations on unstructured text</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3I/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3I/TextBuffer.3I.html">
      <span itemprop="name">TextBuffer: Operations on unstructured text</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ivtools-dev/">
      <span itemprop="name">ivtools-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3I/TextBuffer.3I.html">
      <span itemprop="name">TextBuffer: Operations on unstructured text</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;InterViews/textbuffer.h&gt;</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>TextBuffer defines common editing, searching, and text movement operations on a buffer of unstructured text.  Text positions are specified by an index into the buffer and logically refer to positions between characters.  For example, the position referred to by the index <em>0</em> is before the first character in the text.  Indices can be compared for equality or ordering, but they should not be used to directly access the buffer because TextBuffer might rearrange the text to improve the efficiency of some operations.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PUBLIC OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>TextBuffer(char* buffer, int length, int size)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>~TextBuffer()</strong></p>
  </dt>
  <dd>
    <p>Create or destroy an instance of TextBuffer.  All operations on the text contained in <em>buffer</em> should be performed through TextBuffer functions.  The text is assumed to be of length <em>length</em>, and the total available buffer size is <em>size</em>.</p>
  </dd>
  <dt>
    <p><strong>int Search(Regexp* regexp, int index, int range, int stop)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int ForwardSearch(Regexp* regexp, int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int BackwardSearch(Regexp* regexp, int index)</strong></p>
  </dt>
  <dd>
    <p>Search for a match with the regular expression <em>regexp</em>, beginning at position <em>index</em>.  Search searches the part of the buffer specified by <em>range</em> and <em>stop</em> and returns the index of the beginning of the matched text.  Positive values of <em>range</em> specify forward searches, and negative values specify backward searches.  In either case, the matched text will not extend beyond the position given by <em>stop</em>.  ForwardSearch searches for matches from <em>index</em> to the end of the text and returns the index of the end of the match.  BackwardSearch searches from <em>index</em> to the start of the text and returns the index of the beginning of the match.  All three functions return a negative number if there was no match.</p>
  </dd>
  <dt>
    <p><strong>int Match(Regexp* regexp, int index, int stop)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>boolean ForwardMatch(Regexp* regexp, int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>boolean BackwardMatch(Regexp* regexp, int index)</strong></p>
  </dt>
  <dd>
    <p>Attempt to match the regular expression <em>regexp</em> at the position <em>index</em>.  Match returns the length of the matching string, or a negative number if there was no match.  Matching will not succeed beyond the position given by <em>stop</em>.  ForwardMatch looks for a match that begins at <em>index</em>.  BackwardMatch looks for a match that ends at <em>index</em>.</p>
  </dd>
  <dt>
    <p><strong>int Insert(int index, const char* string, int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int Delete(int index, int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int Copy(int index, char* buffer, int count)</strong></p>
  </dt>
  <dd>
    <p>Edit the text in the buffer.  Insert inserts count characters from <em>string</em> at the position <em>index</em>.  It returns the actual number of characters inserted, which might be less than count if there is insufficient space in the buffer.  Delete deletes <em>count</em> characters from the buffer.  A positive <em>count</em> deletes characters after <em>index</em>, and a negative value deletes character before <em>index</em>.  Delete returns the actual number of characters deleted, which might be less than <em>count</em> if index is near the beginning or the end of the text.  Copy copies <em>count</em> characters into <em>buffer</em>.  A positive <em>count</em> copies characters after <em>index</em> and a negative <em>count</em> copies characters before <em>index</em>.  Count returns the actual number of characters copied. It is the caller's responsibility to ensure that <em>buffer</em> contains sufficient space for the copied text.</p>
  </dd>
  <dt>
    <p><strong>int Height()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int Width()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int Length()</strong></p>
  </dt>
  <dd>
    <p>Return information about the text.  Height returns the number of lines in the text, Width returns the number of characters in the longest line, and Length returns the total number of characters.</p>
  </dd>
  <dt>
    <p><strong>const char* Text()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>const char* Text(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>const char* Text(int index1, int index2)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>char Char (int index)</strong></p>
  </dt>
  <dd>
    <p>Access the contents of the text.  Char returns the character immediately following <em>index</em>.  The three Text calls return pointers to character strings representing the text.  They make various guarantees about the format of the returned string.  With no parameters, Text returns a pointer to a string that contains the entire text of the buffer.  With a single parameter the string contains at least the text from <em>index</em> to the end of the line. With two parameters, the returned string contains at least the text between <em>index1</em> and <em>index2</em>.  In any case, the returned string should be considered temporary and its contents subject to change.  To maximize efficiency, you should prefer the more restricted forms of Text.</p>
  </dd>
  <dt>
    <p><strong>int LineIndex(int line)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int LinesBetween(int index1, int index2)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int LineNumber(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int LineOffset (int index)</strong></p>
  </dt>
  <dd>
    <p>Map between text indices and line and offset positions.  LineIndex returns the index of the beginning of line <em>line</em>.  LineNumber returns the number of the line that contains <em>index</em>.  LineOffset returns the offset of <em>index</em> from the beginning of its containing line.  LinesBetween returns the difference between the numbers of the lines containings <em>index1</em> and <em>index2</em>; a return value of zero indicates that <em>index1</em> and <em>index2</em> are on the same line, and a positive value indicates that the line containing <em>index2</em> is after the line containing <em>index1</em>.  Lines are numbered starting from zero.</p>
  </dd>
  <dt>
    <p><strong>int PreviousCharacter(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int NextCharacter(int index)</strong></p>
  </dt>
  <dd>
    <p>Return the index immediately following or preceding <em>index</em>.  The returned value is never before the beginning or after the end of the text.</p>
  </dd>
  <dt>
    <p><strong>boolean IsBeginningOfText(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int BeginningOfText()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>boolean IsEndOfText(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int EndOfText()</strong></p>
  </dt>
  <dd>
    <p>Return the index of the beginning or end of the text, or query whether <em>index</em> is at the beginning or end of the text.</p>
  </dd>
  <dt>
    <p><strong>boolean IsBeginningOfLine(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int BeginningOfLine(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int BeginningOfNextLine(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>boolean IsEndOfLine(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int EndOfLine(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int EndOfPreviousLine(int index)</strong></p>
  </dt>
  <dd>
    <p>Return information about the line structure of the text around <em>index</em>.  BeginningOfLine returns the index of the beginning of the line containing <em>index</em>.  BeginningOfNextLine returns the index of the beginning of the next line that begins after <em>index</em>. EndOfLine returns the index of the end of the line containing <em>index</em>.  EndOfPreviousLine returns the index of the end of the last line that ends before <em>index</em>.  The beginning of a line is logically immediately after a newline character, and the end of a line is logically immediately before a newline character.  The beginning and end of the text are considered to be the beginning and end of the first and last lines, respectively.</p>
  </dd>
  <dt>
    <p><strong>boolean IsBeginningOfWord(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int BeginningOfWord(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int BeginningOfNextWord(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>boolean IsEndOfWord(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int EndOfWord(int index)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int EndOfPreviousWord(int index)</strong></p>
  </dt>
  <dd>
    <p>Return information about the word structure of the text around <em>index</em>.  BeginningOfWord returns the index of the beginning of the word containing <em>index</em>.  BeginningOfNextWord return the index of the beginning of the nest word that begins after <em>index</em>. EndOfWord returns the index of the end of the word that contains <em>index</em>.  EndOfPreviousWord returns the index of the end of the last word that ends before <em>index</em>.  A word is defined as a sequence of alpha-numeric characters.  The beginning and end of the text are considered to be the beginning and end of the first and last words, respectively.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO TextBuffer&hellip;</h2>
        <div class="sectioncontent">
<p>Regexp(3I)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Subject.3I.html"><span aria-hidden="true">&larr;</span> Subject.3I: Object with views</a></li>
   <li class="next"><a href="TextDisplay.3I.html">TextDisplay.3I: Unstructured text display <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

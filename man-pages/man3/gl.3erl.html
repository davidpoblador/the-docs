<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gl: Standard opengl api.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Standard opengl api.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gl (3erl) manual">
  <meta name="twitter:description" content="Standard opengl api.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-gl-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/gl.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gl (3erl) manual" />
  <meta property="og:description" content="Standard opengl api." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-gl-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gl<small> (3erl)</small></h1>
        <p class="lead">Standard opengl api.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gl.3erl.html">
      <span itemprop="name">gl: Standard opengl api.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gl.3erl.html">
      <span itemprop="name">gl: Standard opengl api.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Standard OpenGL api. See www.opengl.org</p><p>Booleans are represented by integers 0 and 1.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>clamp() = float()</em>:</p><p>0.0..1.0</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>enum() = non_neg_integer()</em>:</p><p>See wx/include/gl.hrl</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>matrix() = {float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>mem() = binary() | tuple()</em>:</p><p>Memory block</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>offset() = non_neg_integer()</em>:</p><p>Offset in memory block</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> clearIndex(C) -&gt; ok</p><p>Types:</p><p>C = float()</p><p>Specify the clear value for the color index buffers</p><p><em>gl:clearIndex</em> specifies the index used by <strong>gl:clear/1</strong> to clear the color index buffers. <em>C</em> is not clamped. Rather, <em>C</em> is converted to a fixed-point value with unspecified precision to the right of the binary point. The integer part of this value is then masked with 2 m-1, where m is the number of bits in a color index stored in the frame buffer.</p><p>See external documentation.</p><p><strong></strong> clearColor(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = clamp()</p><p>Green = clamp()</p><p>Blue = clamp()</p><p>Alpha = clamp()</p><p>Specify clear values for the color buffers</p><p><em>gl:clearColor</em> specifies the red, green, blue, and alpha values used by <strong>gl:clear/1</strong> to clear the color buffers. Values specified by <em>gl:clearColor</em> are clamped to the range [0 1].</p><p>See external documentation.</p><p><strong></strong> clear(Mask) -&gt; ok</p><p>Types:</p><p>Mask = integer()</p><p>Clear buffers to preset values</p><p><em>gl:clear</em> sets the bitplane area of the window to values previously selected by <em>gl:clearColor</em> , <em>gl:clearDepth</em>, and <em>gl:clearStencil</em>. Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using <strong>gl:drawBuffer/1</strong> .</p><p>The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of <em>gl:clear</em>. The scissor box bounds the cleared region. Alpha function, blend function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by <em>gl:clear</em>.</p><p><em>gl:clear</em> takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared.</p><p>The values are as follows:</p><p><em>?GL_COLOR_BUFFER_BIT</em>: Indicates the buffers currently enabled for color writing.</p><p><em>?GL_DEPTH_BUFFER_BIT</em>: Indicates the depth buffer.</p><p><em>?GL_STENCIL_BUFFER_BIT</em>: Indicates the stencil buffer.</p><p>The value to which each buffer is cleared depends on the setting of the clear value for that buffer.</p><p>See external documentation.</p><p><strong></strong> indexMask(Mask) -&gt; ok</p><p>Types:</p><p>Mask = integer()</p><p>Control the writing of individual bits in the color index buffers</p><p><em>gl:indexMask</em> controls the writing of individual bits in the color index buffers. The least significant n bits of <em>Mask</em> , where n is the number of bits in a color index buffer, specify a mask. Where a 1 (one) appears in the mask, it's possible to write to the corresponding bit in the color index buffer (or buffers). Where a 0 (zero) appears, the corresponding bit is write-protected.</p><p>This mask is used only in color index mode, and it affects only the buffers currently selected for writing (see <strong>gl:drawBuffer/1</strong> ). Initially, all bits are enabled for writing.</p><p>See external documentation.</p><p><strong></strong> colorMask(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = 0 | 1</p><p>Green = 0 | 1</p><p>Blue = 0 | 1</p><p>Alpha = 0 | 1</p><p>Enable and disable writing of frame buffer color components</p><p><em>gl:colorMask</em> and <em>gl:colorMaski</em> specify whether the individual color components in the frame buffer can or cannot be written. <em>gl:colorMaski</em> sets the mask for a specific draw buffer, whereas <em>gl:colorMask</em> sets the mask for all draw buffers. If <em>Red</em> is <em>?GL_FALSE</em>, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.</p><p>Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.</p><p>See external documentation.</p><p><strong></strong> alphaFunc(Func, Ref) -&gt; ok</p><p>Types:</p><p>Func = enum()</p><p>Ref = clamp()</p><p>Specify the alpha test function</p><p>The alpha test discards fragments depending on the outcome of a comparison between an incoming fragment's alpha value and a constant reference value. <em>gl:alphaFunc</em> specifies the reference value and the comparison function. The comparison is performed only if alpha testing is enabled. By default, it is not enabled. (See <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> of <em>?GL_ALPHA_TEST</em>.)</p><p><em>Func</em> and <em>Ref</em> specify the conditions under which the pixel is drawn. The incoming alpha value is compared to <em>Ref</em> using the function specified by <em>Func</em> . If the value passes the comparison, the incoming fragment is drawn if it also passes subsequent stencil and depth buffer tests. If the value fails the comparison, no change is made to the frame buffer at that pixel location. The comparison functions are as follows:</p><p><em>?GL_NEVER</em>: Never passes.</p><p><em>?GL_LESS</em>: Passes if the incoming alpha value is less than the reference value.</p><p><em>?GL_EQUAL</em>: Passes if the incoming alpha value is equal to the reference value.</p><p><em>?GL_LEQUAL</em>: Passes if the incoming alpha value is less than or equal to the reference value.</p><p><em>?GL_GREATER</em>: Passes if the incoming alpha value is greater than the reference value.</p><p><em>?GL_NOTEQUAL</em>: Passes if the incoming alpha value is not equal to the reference value.</p><p><em>?GL_GEQUAL</em>: Passes if the incoming alpha value is greater than or equal to the reference value.</p><p><em>?GL_ALWAYS</em>: Always passes (initial value).</p><p><em>gl:alphaFunc</em> operates on all pixel write operations, including those resulting from the scan conversion of points, lines, polygons, and bitmaps, and from pixel draw and copy operations. <em>gl:alphaFunc</em> does not affect screen clear operations.</p><p>See external documentation.</p><p><strong></strong> blendFunc(Sfactor, Dfactor) -&gt; ok</p><p>Types:</p><p>Sfactor = enum()</p><p>Dfactor = enum()</p><p>Specify pixel arithmetic</p><p>Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_BLEND</em> to enable and disable blending.</p><p><em>gl:blendFunc</em> defines the operation of blending for all draw buffers when it is enabled. <em>gl:blendFunci</em> defines the operation of blending for a single draw buffer specified by <em>Buf</em> when enabled for that draw buffer. <em>Sfactor</em> specifies which method is used to scale the source color components. <em>Dfactor</em> specifies which method is used to scale the destination color components. Both parameters must be one of the following symbolic constants: <em>?GL_ZERO</em>, <em>?GL_ONE</em>, <em>?GL_SRC_COLOR</em>, <em>?GL_ONE_MINUS_SRC_COLOR</em> , <em>?GL_DST_COLOR</em>, <em>?GL_ONE_MINUS_DST_COLOR</em>, <em>?GL_SRC_ALPHA</em>, <em>?GL_ONE_MINUS_SRC_ALPHA</em> , <em>?GL_DST_ALPHA</em>, <em>?GL_ONE_MINUS_DST_ALPHA</em>, <em>?GL_CONSTANT_COLOR</em>, <em>?GL_ONE_MINUS_CONSTANT_COLOR</em> , <em>?GL_CONSTANT_ALPHA</em>, <em>?GL_ONE_MINUS_CONSTANT_ALPHA</em>, <em>?GL_SRC_ALPHA_SATURATE</em> , <em>?GL_SRC1_COLOR</em>, <em>?GL_ONE_MINUS_SRC1_COLOR</em>, <em>?GL_SRC1_ALPHA</em>, and <em>?GL_ONE_MINUS_SRC1_ALPHA</em> . The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as (R s0 G s0 B s0 A s0), (R s1 G s1 B s1 A s1) and (R d G d B d A d), respectively. The color specified by <strong>gl:blendColor/4</strong> is referred to as (R c G c B c A c). They are understood to have integer values between 0 and (k R k G k B k A), where</p><p>k c=2(m c)-1</p><p>and (m R m G m B m A) is the number of red, green, blue, and alpha bitplanes.</p><p>Source and destination scale factors are referred to as (s R s G s B s A) and (d R d G d B d A). The scale factors described in the table, denoted (f R f G f B f A), represent either source or destination factors. All scale factors have range [0 1].<em>Parameter</em>(f R f G f B f A)</p><p><em>?GL_ZERO</em> (0 0 0 0)</p><p><em>?GL_ONE</em>(1 1 1 1)</p><p><em>?GL_SRC_COLOR</em> (R s0 k/R G s0 k/G B s0 k/B A s0 k/A)</p><p><em>?GL_ONE_MINUS_SRC_COLOR</em>(1 1 1 1)-(R s0 k/R G s0 k/G B s0 k/B A s0 k/A)</p><p><em>?GL_DST_COLOR</em> (R d k/R G d k/G B d k/B A d k/A)</p><p><em>?GL_ONE_MINUS_DST_COLOR</em>(1 1 1 1)-(R d k/R G d k/G B d k/B A d k/A)</p><p><em>?GL_SRC_ALPHA</em> (A s0 k/A A s0 k/A A s0 k/A A s0 k/A)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em>(1 1 1 1)-(A s0 k/A A s0 k/A A s0 k/A A s0 k/A)</p><p><em>?GL_DST_ALPHA</em> (A d k/A A d k/A A d k/A A d k/A)</p><p><em>?GL_ONE_MINUS_DST_ALPHA</em>(1 1 1 1)-(A d k/A A d k/A A d k/A A d k/A)</p><p><em>?GL_CONSTANT_COLOR</em> (R c G c B c A c)</p><p><em>?GL_ONE_MINUS_CONSTANT_COLOR</em>(1 1 1 1)-(R c G c B c A c)</p><p><em>?GL_CONSTANT_ALPHA</em>(A c A c A c A c)</p><p><em>?GL_ONE_MINUS_CONSTANT_ALPHA</em> (1 1 1 1)-(A c A c A c A c)</p><p><em>?GL_SRC_ALPHA_SATURATE</em>(i i i 1)</p><p><em>?GL_SRC1_COLOR</em> (R s1 k/R G s1 k/G B s1 k/B A s1 k/A)</p><p><em>?GL_ONE_MINUS_SRC1_COLOR</em>(1 1 1 1)-(R s1 k/R G s1 k/G B s1 k/B A s1 k/A)</p><p><em>?GL_SRC1_ALPHA</em> (A s1 k/A A s1 k/A A s1 k/A A s1 k/A)</p><p><em>?GL_ONE_MINUS_SRC1_ALPHA</em>(1 1 1 1)-(A s1 k/A A s1 k/A A s1 k/A A s1 k/A)</p><p>In the table,</p><p>i=min(A s k A-A d) k/A</p><p>To determine the blended RGBA values of a pixel, the system uses the following equations:</p><p>R d=min(k R R s s R+R d d R) G d=min(k G G s s G+G d d G) B d=min(k B B s s B+B d d B) A d=min(k A A s s A+A d d A)</p><p>Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when <em>Sfactor</em> is <em>?GL_SRC_ALPHA</em> , <em>Dfactor</em> is <em>?GL_ONE_MINUS_SRC_ALPHA</em>, and A s is equal to k A, the equations reduce to simple replacement:</p><p>R d=R s G d=G s B d=B s A d=A s</p><p>See external documentation.</p><p><strong></strong> logicOp(Opcode) -&gt; ok</p><p>Types:</p><p>Opcode = enum()</p><p>Specify a logical pixel operation for rendering</p><p><em>gl:logicOp</em> specifies a logical operation that, when enabled, is applied between the incoming RGBA color and the RGBA color at the corresponding location in the frame buffer. To enable or disable the logical operation, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> using the symbolic constant <em>?GL_COLOR_LOGIC_OP</em>. The initial value is disabled.<em>Opcode</em><em>Resulting Operation</em></p><p><em>?GL_CLEAR</em> 0</p><p><em>?GL_SET</em> 1</p><p><em>?GL_COPY</em> s</p><p><em>?GL_COPY_INVERTED</em> ~s</p><p><em>?GL_NOOP</em> d</p><p><em>?GL_INVERT</em> ~d</p><p><em>?GL_AND</em> s & d</p><p><em>?GL_NAND</em> ~(s & d)</p><p><em>?GL_OR</em> s | d</p><p><em>?GL_NOR</em> ~(s | d)</p><p><em>?GL_XOR</em> s ^ d</p><p><em>?GL_EQUIV</em> ~(s ^ d)</p><p><em>?GL_AND_REVERSE</em> s & ~d</p><p><em>?GL_AND_INVERTED</em> ~s & d</p><p><em>?GL_OR_REVERSE</em> s | ~d</p><p><em>?GL_OR_INVERTED</em> ~s | d</p><p><em>Opcode</em> is a symbolic constant chosen from the list above. In the explanation of the logical operations, <em>s</em> represents the incoming color and <em>d</em> represents the color in the frame buffer. Standard C-language operators are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination colors.</p><p>See external documentation.</p><p><strong></strong> cullFace(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Specify whether front- or back-facing facets can be culled</p><p><em>gl:cullFace</em> specifies whether front- or back-facing facets are culled (as specified by <em>mode</em>) when facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling, call the <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> commands with the argument <em>?GL_CULL_FACE</em>. Facets include triangles, quadrilaterals, polygons, and rectangles.</p><p><strong>gl:frontFace/1</strong> specifies which of the clockwise and counterclockwise facets are front-facing and back-facing. See <strong>gl:frontFace/1</strong> .</p><p>See external documentation.</p><p><strong></strong> frontFace(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Define front- and back-facing polygons</p><p>In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_CULL_FACE</em>.</p><p>The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. <em>gl:frontFace</em> specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing <em>?GL_CCW</em> to <em>Mode</em> selects counterclockwise polygons as front-facing; <em>?GL_CW</em> selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.</p><p>See external documentation.</p><p><strong></strong> pointSize(Size) -&gt; ok</p><p>Types:</p><p>Size = float()</p><p>Specify the diameter of rasterized points</p><p><em>gl:pointSize</em> specifies the rasterized diameter of points. If point size mode is disabled (see <strong>gl:enable/1</strong> with parameter <em>?GL_PROGRAM_POINT_SIZE</em>), this value will be used to rasterize points. Otherwise, the value written to the shading language built-in variable gl_PointSize will be used.</p><p>See external documentation.</p><p><strong></strong> lineWidth(Width) -&gt; ok</p><p>Types:</p><p>Width = float()</p><p>Specify the width of rasterized lines</p><p><em>gl:lineWidth</em> specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_LINE_SMOOTH</em>. Line antialiasing is initially disabled.</p><p>If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If |&Delta; x|&gt;=|&Delta; y|, <em>i</em> pixels are filled in each column that is rasterized, where <em>i</em> is the rounded value of <em>Width</em> . Otherwise, <em>i</em> pixels are filled in each row that is rasterized.</p><p>If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step.</p><p>Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the implementation. Likewise, there is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported widths within the range, call <strong>gl:getBooleanv/1</strong> with arguments <em>?GL_ALIASED_LINE_WIDTH_RANGE</em> , <em>?GL_SMOOTH_LINE_WIDTH_RANGE</em>, and <em>?GL_SMOOTH_LINE_WIDTH_GRANULARITY</em>.</p><p>See external documentation.</p><p><strong></strong> lineStipple(Factor, Pattern) -&gt; ok</p><p>Types:</p><p>Factor = integer()</p><p>Pattern = integer()</p><p>Specify the line stipple pattern</p><p>Line stippling masks out certain fragments produced by rasterization; those fragments will not be drawn. The masking is achieved by using three parameters: the 16-bit line stipple pattern <em>Pattern</em> , the repeat count <em>Factor</em> , and an integer stipple counter s.</p><p>Counter s is reset to 0 whenever <strong>gl:'begin'/1</strong> is called and before each line segment of a <strong>gl:'begin'/1</strong> (<em>?GL_LINES</em>)/ <strong>gl:'begin'/1</strong> sequence is generated. It is incremented after each fragment of a unit width aliased line segment is generated or after each i fragments of an i width line segment are generated. The i fragments associated with count s are masked out if</p><p><em>Pattern</em> bit (s/factor)% 16</p><p>is 0, otherwise these fragments are sent to the frame buffer. Bit zero of <em>Pattern</em> is the least significant bit.</p><p>Antialiased lines are treated as a sequence of 1×width rectangles for purposes of stippling. Whether rectangle s is rasterized or not depends on the fragment rule described for aliased lines, counting rectangles rather than groups of fragments.</p><p>To enable and disable line stippling, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_LINE_STIPPLE</em>. When enabled, the line stipple pattern is applied as described above. When disabled, it is as if the pattern were all 1's. Initially, line stippling is disabled.</p><p>See external documentation.</p><p><strong></strong> polygonMode(Face, Mode) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Mode = enum()</p><p>Select a polygon rasterization mode</p><p><em>gl:polygonMode</em> controls the interpretation of polygons for rasterization. <em>Face</em> describes which polygons <em>Mode</em> applies to: both front and back-facing polygons (<em>?GL_FRONT_AND_BACK</em> ). The polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied.</p><p>Three modes are defined and can be specified in <em>Mode</em> :</p><p><em>?GL_POINT</em>: Polygon vertices that are marked as the start of a boundary edge are drawn as points. Point attributes such as <em>?GL_POINT_SIZE</em> and <em>?GL_POINT_SMOOTH</em> control the rasterization of the points. Polygon rasterization attributes other than <em>?GL_POLYGON_MODE</em> have no effect.</p><p><em>?GL_LINE</em>: Boundary edges of the polygon are drawn as line segments. Line attributes such as <em>?GL_LINE_WIDTH</em> and <em>?GL_LINE_SMOOTH</em> control the rasterization of the lines. Polygon rasterization attributes other than <em>?GL_POLYGON_MODE</em> have no effect.</p><p><em>?GL_FILL</em>: The interior of the polygon is filled. Polygon attributes such as <em>?GL_POLYGON_SMOOTH</em> control the rasterization of the polygon.</p><p>See external documentation.</p><p><strong></strong> polygonOffset(Factor, Units) -&gt; ok</p><p>Types:</p><p>Factor = float()</p><p>Units = float()</p><p>Set the scale and units used to calculate depth values</p><p>When <em>?GL_POLYGON_OFFSET_FILL</em>, <em>?GL_POLYGON_OFFSET_LINE</em>, or <em>?GL_POLYGON_OFFSET_POINT</em> is enabled, each fragment's <em>depth</em> value will be offset after it is interpolated from the <em>depth</em> values of the appropriate vertices. The value of the offset is factor×DZ+r×units, where DZ is a measurement of the change in depth relative to the screen area of the polygon, and r is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer.</p><p><em>gl:polygonOffset</em> is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.</p><p>See external documentation.</p><p><strong></strong> polygonStipple(Mask) -&gt; ok</p><p>Types:</p><p>Mask = binary()</p><p>Set the polygon stippling pattern</p><p>Polygon stippling, like line stippling (see <strong>gl:lineStipple/2</strong> ), masks out certain fragments produced by rasterization, creating a pattern. Stippling is independent of polygon antialiasing.</p><p><em>Pattern</em> is a pointer to a 32×32 stipple pattern that is stored in memory just like the pixel data supplied to a <strong>gl:drawPixels/5</strong> call with height and <em>width</em> both equal to 32, a pixel format of <em>?GL_COLOR_INDEX</em>, and data type of <em>?GL_BITMAP</em> . That is, the stipple pattern is represented as a 32×32 array of 1-bit color indices packed in unsigned bytes. <strong>gl:pixelStoref/2</strong> parameters like <em>?GL_UNPACK_SWAP_BYTES</em> and <em>?GL_UNPACK_LSB_FIRST</em> affect the assembling of the bits into a stipple pattern. Pixel transfer operations (shift, offset, pixel map) are not applied to the stipple image, however.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a stipple pattern is specified, <em>Pattern</em> is treated as a byte offset into the buffer object's data store.</p><p>To enable and disable polygon stippling, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_POLYGON_STIPPLE</em>. Polygon stippling is initially disabled. If it's enabled, a rasterized polygon fragment with window coordinates x w and y w is sent to the next stage of the GL if and only if the ( x w% 32)th bit in the ( y w% 32)th row of the stipple pattern is 1 (one). When polygon stippling is disabled, it is as if the stipple pattern consists of all 1's.</p><p>See external documentation.</p><p><strong></strong> getPolygonStipple() -&gt; binary()</p><p>Return the polygon stipple pattern</p><p><em>gl:getPolygonStipple</em> returns to <em>Pattern</em> a 32×32 polygon stipple pattern. The pattern is packed into memory as if <strong>gl:readPixels/7</strong> with both <em>height</em> and <em>width</em> of 32, <em>type</em> of <em>?GL_BITMAP</em>, and <em>format</em> of <em>?GL_COLOR_INDEX</em> were called, and the stipple pattern were stored in an internal 32×32 color index buffer. Unlike <strong>gl:readPixels/7</strong> , however, pixel transfer operations (shift, offset, pixel map) are not applied to the returned stipple image.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a polygon stipple pattern is requested, <em>Pattern</em> is treated as a byte offset into the buffer object's data store.</p><p>See external documentation.</p><p><strong></strong> edgeFlag(Flag) -&gt; ok</p><p>Types:</p><p>Flag = 0 | 1</p><p>Flag edges as either boundary or nonboundary</p><p>Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a <strong>gl:'begin'/1</strong> / <strong>gl:'begin'/1</strong> pair is marked as the start of either a boundary or nonboundary edge. If the current edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary edge. Otherwise, the vertex is marked as the start of a nonboundary edge. <em>gl:edgeFlag</em> sets the edge flag bit to <em>?GL_TRUE</em> if <em>Flag</em> is <em>?GL_TRUE</em> and to <em>?GL_FALSE</em> otherwise.</p><p>The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of the value of the edge flag.</p><p>Boundary and nonboundary edge flags on vertices are significant only if <em>?GL_POLYGON_MODE</em> is set to <em>?GL_POINT</em> or <em>?GL_LINE</em>. See <strong>gl:polygonMode/2</strong> .</p><p>See external documentation.</p><p><strong></strong> edgeFlagv(Flag) -&gt; ok</p><p>Types:</p><p>Flag = {Flag::0 | 1}</p><p>Equivalent to <strong>edgeFlag(Flag)</strong>.</p><p><strong></strong> scissor(X, Y, Width, Height) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Define the scissor box</p><p><em>gl:scissor</em> defines a rectangle, called the scissor box, in window coordinates. The first two arguments, <em>X</em> and <em>Y</em> , specify the lower left corner of the box. <em>Width</em> and <em>Height</em> specify the width and height of the box.</p><p>To enable and disable the scissor test, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_SCISSOR_TEST</em>. The test is initially disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of any pixels in the window.</p><p>When the scissor test is disabled, it is as though the scissor box includes the entire window.</p><p>See external documentation.</p><p><strong></strong> clipPlane(Plane, Equation) -&gt; ok</p><p>Types:</p><p>Plane = enum()</p><p>Equation = {float(), float(), float(), float()}</p><p>Specify a plane against which all geometry is clipped</p><p>Geometry is always clipped against the boundaries of a six-plane frustum in <em>x</em>, <em>y</em> , and <em>z</em>. <em>gl:clipPlane</em> allows the specification of additional planes, not necessarily perpendicular to the <em>x</em>, <em>y</em>, or <em>z</em> axis, against which all geometry is clipped. To determine the maximum number of additional clipping planes, call <strong>gl:getBooleanv/1</strong> with argument <em>?GL_MAX_CLIP_PLANES</em>. All implementations support at least six such clipping planes. Because the resulting clipping region is the intersection of the defined half-spaces, it is always convex.</p><p><em>gl:clipPlane</em> specifies a half-space using a four-component plane equation. When <em>gl:clipPlane</em> is called, <em>Equation</em> is transformed by the inverse of the modelview matrix and stored in the resulting eye coordinates. Subsequent changes to the modelview matrix have no effect on the stored plane-equation components. If the dot product of the eye coordinates of a vertex with the stored plane equation components is positive or zero, the vertex is <em>in</em> with respect to that clipping plane. Otherwise, it is <em>out</em>.</p><p>To enable and disable clipping planes, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with the argument <em>?GL_CLIP_PLANE</em><em>i</em>, where <em>i</em> is the plane number.</p><p>All clipping planes are initially defined as (0, 0, 0, 0) in eye coordinates and are disabled.</p><p>See external documentation.</p><p><strong></strong> getClipPlane(Plane) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Plane = enum()</p><p>Return the coefficients of the specified clipping plane</p><p><em>gl:getClipPlane</em> returns in <em>Equation</em> the four coefficients of the plane equation for <em>Plane</em> .</p><p>See external documentation.</p><p><strong></strong> drawBuffer(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Specify which color buffers are to be drawn into</p><p>When colors are written to the frame buffer, they are written into the color buffers specified by <em>gl:drawBuffer</em>. The specifications are as follows:</p><p><em>?GL_NONE</em>: No color buffers are written.</p><p><em>?GL_FRONT_LEFT</em>: Only the front left color buffer is written.</p><p><em>?GL_FRONT_RIGHT</em>: Only the front right color buffer is written.</p><p><em>?GL_BACK_LEFT</em>: Only the back left color buffer is written.</p><p><em>?GL_BACK_RIGHT</em>: Only the back right color buffer is written.</p><p><em>?GL_FRONT</em>: Only the front left and front right color buffers are written. If there is no front right color buffer, only the front left color buffer is written.</p><p><em>?GL_BACK</em>: Only the back left and back right color buffers are written. If there is no back right color buffer, only the back left color buffer is written.</p><p><em>?GL_LEFT</em>: Only the front left and back left color buffers are written. If there is no back left color buffer, only the front left color buffer is written.</p><p><em>?GL_RIGHT</em>: Only the front right and back right color buffers are written. If there is no back right color buffer, only the front right color buffer is written.</p><p><em>?GL_FRONT_AND_BACK</em>: All the front and back color buffers (front left, front right, back left, back right) are written. If there are no back color buffers, only the front left and front right color buffers are written. If there are no right color buffers, only the front left and back left color buffers are written. If there are no right or back color buffers, only the front left color buffer is written.</p><p>If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer.</p><p>Monoscopic contexts include only <em>left</em> buffers, and stereoscopic contexts include both <em>left</em> and <em>right</em> buffers. Likewise, single-buffered contexts include only <em>front</em> buffers, and double-buffered contexts include both <em>front</em> and <em>back</em> buffers. The context is selected at GL initialization.</p><p>See external documentation.</p><p><strong></strong> readBuffer(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Select a color buffer source for pixels</p><p><em>gl:readBuffer</em> specifies a color buffer as the source for subsequent <strong>gl:readPixels/7</strong> , <strong>gl:copyTexImage1D/7</strong> , <strong>gl:copyTexImage2D/8</strong> , <strong>gl:copyTexSubImage1D/6</strong> , <strong>gl:copyTexSubImage2D/8</strong> , and <strong>gl:copyTexSubImage3D/9</strong> commands. <em>Mode</em> accepts one of twelve or more predefined values. In a fully configured system, <em>?GL_FRONT</em>, <em>?GL_LEFT</em>, and <em>?GL_FRONT_LEFT</em> all name the front left buffer, <em>?GL_FRONT_RIGHT</em> and <em>?GL_RIGHT</em> name the front right buffer, and <em>?GL_BACK_LEFT</em> and <em>?GL_BACK</em> name the back left buffer. Further more, the constants <em>?GL_COLOR_ATTACHMENT</em><em>i</em> may be used to indicate the <em>i</em>th color attachment where <em>i</em> ranges from zero to the value of <em>?GL_MAX_COLOR_ATTACHMENTS</em> minus one.</p><p>Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify a nonexistent buffer to <em>gl:readBuffer</em> .</p><p><em>Mode</em> is initially <em>?GL_FRONT</em> in single-buffered configurations and <em>?GL_BACK</em> in double-buffered configurations.</p><p>See external documentation.</p><p><strong></strong> enable(Cap) -&gt; ok</p><p>Types:</p><p>Cap = enum()</p><p>Enable or disable server-side GL capabilities</p><p><em>gl:enable</em> and <strong>gl:enable/1</strong> enable and disable various capabilities. Use <strong>gl:isEnabled/1</strong> or <strong>gl:getBooleanv/1</strong> to determine the current setting of any capability. The initial value for each capability with the exception of <em>?GL_DITHER</em> and <em>?GL_MULTISAMPLE</em> is <em>?GL_FALSE</em>. The initial value for <em>?GL_DITHER</em> and <em>?GL_MULTISAMPLE</em> is <em>?GL_TRUE</em>.</p><p>Both <em>gl:enable</em> and <strong>gl:enable/1</strong> take a single argument, <em>Cap</em> , which can assume one of the following values:</p><p>Some of the GL's capabilities are indexed. <em>gl:enablei</em> and <em>gl:disablei</em> enable and disable indexed capabilities.</p><p><em>?GL_BLEND</em>: If enabled, blend the computed fragment color values with the values in the color buffers. See <strong>gl:blendFunc/2</strong> .</p><p><em>?GL_CLIP_DISTANCE</em><em>i</em>: If enabled, clip geometry against user-defined half space <em>i</em>.</p><p><em>?GL_COLOR_LOGIC_OP</em>: If enabled, apply the currently selected logical operation to the computed fragment color and color buffer values. See <strong>gl:logicOp/1</strong> .</p><p><em>?GL_CULL_FACE</em>: If enabled, cull polygons based on their winding in window coordinates. See <strong>gl:cullFace/1</strong> .</p><p><em>?GL_DEPTH_CLAMP</em>: If enabled, the -w c&le; z c&le; w c plane equation is ignored by view volume clipping (effectively, there is no near or far plane clipping). See <strong>gl:depthRange/2</strong> .</p><p><em>?GL_DEPTH_TEST</em>: If enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See <strong>gl:depthFunc/1</strong> and <strong>gl:depthRange/2</strong> .</p><p><em>?GL_DITHER</em>: If enabled, dither color components or indices before they are written to the color buffer.</p><p><em>?GL_FRAMEBUFFER_SRGB</em>: If enabled and the value of <em>?GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING</em> for the framebuffer attachment corresponding to the destination buffer is <em>?GL_SRGB</em>, the R, G, and B destination color values (after conversion from fixed-point to floating-point) are considered to be encoded for the sRGB color space and hence are linearized prior to their use in blending.</p><p><em>?GL_LINE_SMOOTH</em>: If enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See <strong>gl:lineWidth/1</strong> .</p><p><em>?GL_MULTISAMPLE</em>: If enabled, use multiple fragment samples in computing the final color of a pixel. See <strong>gl:sampleCoverage/2</strong> .</p><p><em>?GL_POLYGON_OFFSET_FILL</em>: If enabled, and if the polygon is rendered in <em>?GL_FILL</em> mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See <strong>gl:polygonOffset/2</strong> .</p><p><em>?GL_POLYGON_OFFSET_LINE</em>: If enabled, and if the polygon is rendered in <em>?GL_LINE</em> mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See <strong>gl:polygonOffset/2</strong> .</p><p><em>?GL_POLYGON_OFFSET_POINT</em>: If enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in <em>?GL_POINT</em> mode. See <strong>gl:polygonOffset/2</strong> .</p><p><em>?GL_POLYGON_SMOOTH</em>: If enabled, draw polygons with proper filtering. Otherwise, draw aliased polygons. For correct antialiased polygons, an alpha buffer is needed and the polygons must be sorted front to back.</p><p><em>?GL_PRIMITIVE_RESTART</em>: Enables primitive restarting. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the primitive restart index. See <strong>gl:primitiveRestartIndex/1</strong> .</p><p><em>?GL_SAMPLE_ALPHA_TO_COVERAGE</em>: If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.</p><p><em>?GL_SAMPLE_ALPHA_TO_ONE</em>: If enabled, each sample alpha value is replaced by the maximum representable alpha value.</p><p><em>?GL_SAMPLE_COVERAGE</em>: If enabled, the fragment's coverage is ANDed with the temporary coverage value. If <em>?GL_SAMPLE_COVERAGE_INVERT</em> is set to <em>?GL_TRUE</em>, invert the coverage value. See <strong>gl:sampleCoverage/2</strong> .</p><p><em>?GL_SAMPLE_SHADING</em>: If enabled, the active fragment shader is run once for each covered sample, or at fraction of this rate as determined by the current value of <em>?GL_MIN_SAMPLE_SHADING_VALUE</em> . See <strong>gl:minSampleShading/1</strong> .</p><p><em>?GL_SAMPLE_MASK</em>: If enabled, the sample coverage mask generated for a fragment during rasterization will be ANDed with the value of <em>?GL_SAMPLE_MASK_VALUE</em> before shading occurs. See <strong>gl:sampleMaski/2</strong> .</p><p><em>?GL_SCISSOR_TEST</em>: If enabled, discard fragments that are outside the scissor rectangle. See <strong>gl:scissor/4</strong> .</p><p><em>?GL_STENCIL_TEST</em>: If enabled, do stencil testing and update the stencil buffer. See <strong>gl:stencilFunc/3</strong> and <strong>gl:stencilOp/3</strong> .</p><p><em>?GL_TEXTURE_CUBE_MAP_SEAMLESS</em>: If enabled, cubemap textures are sampled such that when linearly sampling from the border between two adjacent faces, texels from both faces are used to generate the final sample value. When disabled, texels from only a single face are used to construct the final sample value.</p><p><em>?GL_PROGRAM_POINT_SIZE</em>: If enabled and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped) shader builtin <em>?gl_PointSize</em> and clamped to the implementation-dependent point size range.</p><p>See external documentation.</p><p><strong></strong> disable(Cap) -&gt; ok</p><p>Types:</p><p>Cap = enum()</p><p>See <strong>enable/1</strong></p><p><strong></strong> isEnabled(Cap) -&gt; 0 | 1</p><p>Types:</p><p>Cap = enum()</p><p>Test whether a capability is enabled</p><p><em>gl:isEnabled</em> returns <em>?GL_TRUE</em> if <em>Cap</em> is an enabled capability and returns <em>?GL_FALSE</em> otherwise. Boolean states that are indexed may be tested with <em>gl:isEnabledi</em> . For <em>gl:isEnabledi</em>, <em>Index</em> specifies the index of the capability to test. <em>Index</em> must be between zero and the count of indexed capabilities for <em>Cap</em> . Initially all capabilities except <em>?GL_DITHER</em> are disabled; <em>?GL_DITHER</em> is initially enabled.</p><p>The following capabilities are accepted for <em>Cap</em> :<em>Constant</em><em>See</em></p><p><em>?GL_BLEND</em><strong>gl:blendFunc/2</strong> , <strong>gl:logicOp/1</strong></p><p><em>?GL_CLIP_DISTANCE</em><em>i</em><strong>gl:enable/1</strong></p><p><em>?GL_COLOR_LOGIC_OP</em><strong>gl:logicOp/1</strong></p><p><em>?GL_CULL_FACE</em><strong>gl:cullFace/1</strong></p><p><em>?GL_DEPTH_CLAMP</em><strong>gl:enable/1</strong></p><p><em>?GL_DEPTH_TEST</em><strong>gl:depthFunc/1</strong> , <strong>gl:depthRange/2</strong></p><p><em>?GL_DITHER</em><strong>gl:enable/1</strong></p><p><em>?GL_FRAMEBUFFER_SRGB</em><strong>gl:enable/1</strong></p><p><em>?GL_LINE_SMOOTH</em><strong>gl:lineWidth/1</strong></p><p><em>?GL_MULTISAMPLE</em><strong>gl:sampleCoverage/2</strong></p><p><em>?GL_POLYGON_SMOOTH</em><strong>gl:polygonMode/2</strong></p><p><em>?GL_POLYGON_OFFSET_FILL</em><strong>gl:polygonOffset/2</strong></p><p><em>?GL_POLYGON_OFFSET_LINE</em><strong>gl:polygonOffset/2</strong></p><p><em>?GL_POLYGON_OFFSET_POINT</em><strong>gl:polygonOffset/2</strong></p><p><em>?GL_PROGRAM_POINT_SIZE</em><strong>gl:enable/1</strong></p><p><em>?GL_PRIMITIVE_RESTART</em><strong>gl:enable/1</strong> , <strong>gl:primitiveRestartIndex/1</strong></p><p><em>?GL_SAMPLE_ALPHA_TO_COVERAGE</em><strong>gl:sampleCoverage/2</strong></p><p><em>?GL_SAMPLE_ALPHA_TO_ONE</em><strong>gl:sampleCoverage/2</strong></p><p><em>?GL_SAMPLE_COVERAGE</em><strong>gl:sampleCoverage/2</strong></p><p><em>?GL_SAMPLE_MASK</em><strong>gl:enable/1</strong></p><p><em>?GL_SCISSOR_TEST</em><strong>gl:scissor/4</strong></p><p><em>?GL_STENCIL_TEST</em><strong>gl:stencilFunc/3</strong> , <strong>gl:stencilOp/3</strong></p><p><em>?GL_TEXTURE_CUBEMAP_SEAMLESS</em><strong>gl:enable/1</strong></p><p>See external documentation.</p><p><strong></strong> enableClientState(Cap) -&gt; ok</p><p>Types:</p><p>Cap = enum()</p><p>Enable or disable client-side capability</p><p><em>gl:enableClientState</em> and <strong>gl:enableClientState/1</strong> enable or disable individual client-side capabilities. By default, all client-side capabilities are disabled. Both <em>gl:enableClientState</em> and <strong>gl:enableClientState/1</strong> take a single argument, <em>Cap</em> , which can assume one of the following values:</p><p><em>?GL_COLOR_ARRAY</em>: If enabled, the color array is enabled for writing and used during rendering when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> <strong>gl:multiDrawArrays/3</strong> , or see <em>glMultiDrawElements</em> is called. See <strong>gl:colorPointer/4</strong> .</p><p><em>?GL_EDGE_FLAG_ARRAY</em>: If enabled, the edge flag array is enabled for writing and used during rendering when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> <strong>gl:multiDrawArrays/3</strong> , or see <em>glMultiDrawElements</em> is called. See <strong>gl:edgeFlagPointer/2</strong> .</p><p><em>?GL_FOG_COORD_ARRAY</em>: If enabled, the fog coordinate array is enabled for writing and used during rendering when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> <strong>gl:multiDrawArrays/3</strong> , or see <em>glMultiDrawElements</em> is called. See <strong>gl:fogCoordPointer/3</strong> .</p><p><em>?GL_INDEX_ARRAY</em>: If enabled, the index array is enabled for writing and used during rendering when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> <strong>gl:multiDrawArrays/3</strong> , or see <em>glMultiDrawElements</em> is called. See <strong>gl:indexPointer/3</strong> .</p><p><em>?GL_NORMAL_ARRAY</em>: If enabled, the normal array is enabled for writing and used during rendering when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> <strong>gl:multiDrawArrays/3</strong> , or see <em>glMultiDrawElements</em> is called. See <strong>gl:normalPointer/3</strong> .</p><p><em>?GL_SECONDARY_COLOR_ARRAY</em>: If enabled, the secondary color array is enabled for writing and used during rendering when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> <strong>gl:multiDrawArrays/3</strong> , or see <em>glMultiDrawElements</em> is called. See <strong>gl:colorPointer/4</strong> .</p><p><em>?GL_TEXTURE_COORD_ARRAY</em>: If enabled, the texture coordinate array is enabled for writing and used during rendering when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> <strong>gl:multiDrawArrays/3</strong> , or see <em>glMultiDrawElements</em> is called. See <strong>gl:texCoordPointer/4</strong> .</p><p><em>?GL_VERTEX_ARRAY</em>: If enabled, the vertex array is enabled for writing and used during rendering when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> <strong>gl:multiDrawArrays/3</strong> , or see <em>glMultiDrawElements</em> is called. See <strong>gl:vertexPointer/4</strong> .</p><p>See external documentation.</p><p><strong></strong> disableClientState(Cap) -&gt; ok</p><p>Types:</p><p>Cap = enum()</p><p>See <strong>enableClientState/1</strong></p><p><strong></strong> getBooleanv(Pname) -&gt; [0 | 1]</p><p>Types:</p><p>Pname = enum()</p><p>Return the value or values of a selected parameter</p><p>These four commands return values for simple state variables in GL. <em>Pname</em> is a symbolic constant indicating the state variable to be returned, and <em>Params</em> is a pointer to an array of the indicated type in which to place the returned data.</p><p>Type conversion is performed if <em>Params</em> has a different type than the state variable value being requested. If <em>gl:getBooleanv</em> is called, a floating-point (or integer) value is converted to <em>?GL_FALSE</em> if and only if it is 0.0 (or 0). Otherwise, it is converted to <em>?GL_TRUE</em>. If <em>gl:getIntegerv</em> is called, boolean values are returned as <em>?GL_TRUE</em> or <em>?GL_FALSE</em>, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and -1.0 to the most negative representable integer value. If <em>gl:getFloatv</em> or <em>gl:getDoublev</em> is called, boolean values are returned as <em>?GL_TRUE</em> or <em>?GL_FALSE</em>, and integer values are converted to floating-point values.</p><p>The following symbolic constants are accepted by <em>Pname</em> :</p><p><em>?GL_ACTIVE_TEXTURE</em>: <em>Params</em> returns a single value indicating the active multitexture unit. The initial value is <em>?GL_TEXTURE0</em>. See <strong>gl:activeTexture/1</strong> .</p><p><em>?GL_ALIASED_LINE_WIDTH_RANGE</em>: <em>Params</em> returns a pair of values indicating the range of widths supported for aliased lines. See <strong>gl:lineWidth/1</strong> .</p><p><em>?GL_ARRAY_BUFFER_BINDING</em>: <em>Params</em> returns a single value, the name of the buffer object currently bound to the target <em>?GL_ARRAY_BUFFER</em>. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See <strong>gl:bindBuffer/2</strong> .</p><p><em>?GL_BLEND</em>: <em>Params</em> returns a single boolean value indicating whether blending is enabled. The initial value is <em>?GL_FALSE</em>. See <strong>gl:blendFunc/2</strong> .</p><p><em>?GL_BLEND_COLOR</em>: <em>Params</em> returns four values, the red, green, blue, and alpha values which are the components of the blend color. See <strong>gl:blendColor/4</strong> .</p><p><em>?GL_BLEND_DST_ALPHA</em>: <em>Params</em> returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is <em>?GL_ZERO</em>. See <strong>gl:blendFunc/2</strong> and <strong>gl:blendFuncSeparate/4</strong> .</p><p><em>?GL_BLEND_DST_RGB</em>: <em>Params</em> returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is <em>?GL_ZERO</em>. See <strong>gl:blendFunc/2</strong> and <strong>gl:blendFuncSeparate/4</strong> .</p><p><em>?GL_BLEND_EQUATION_RGB</em>: <em>Params</em> returns one value, a symbolic constant indicating whether the RGB blend equation is <em>?GL_FUNC_ADD</em>, <em>?GL_FUNC_SUBTRACT</em>, <em>?GL_FUNC_REVERSE_SUBTRACT</em> , <em>?GL_MIN</em> or <em>?GL_MAX</em>. See <strong>gl:blendEquationSeparate/2</strong> .</p><p><em>?GL_BLEND_EQUATION_ALPHA</em>: <em>Params</em> returns one value, a symbolic constant indicating whether the Alpha blend equation is <em>?GL_FUNC_ADD</em>, <em>?GL_FUNC_SUBTRACT</em> , <em>?GL_FUNC_REVERSE_SUBTRACT</em>, <em>?GL_MIN</em> or <em>?GL_MAX</em>. See <strong>gl:blendEquationSeparate/2</strong> .</p><p><em>?GL_BLEND_SRC_ALPHA</em>: <em>Params</em> returns one value, the symbolic constant identifying the alpha source blend function. The initial value is <em>?GL_ONE</em>. See <strong>gl:blendFunc/2</strong> and <strong>gl:blendFuncSeparate/4</strong> .</p><p><em>?GL_BLEND_SRC_RGB</em>: <em>Params</em> returns one value, the symbolic constant identifying the RGB source blend function. The initial value is <em>?GL_ONE</em>. See <strong>gl:blendFunc/2</strong> and <strong>gl:blendFuncSeparate/4</strong> .</p><p><em>?GL_COLOR_CLEAR_VALUE</em>: <em>Params</em> returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See <strong>gl:clearColor/4</strong> .</p><p><em>?GL_COLOR_LOGIC_OP</em>: <em>Params</em> returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is <em>?GL_FALSE</em>. See <strong>gl:logicOp/1</strong> .</p><p><em>?GL_COLOR_WRITEMASK</em>: <em>Params</em> returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is (<em>?GL_TRUE</em>, <em>?GL_TRUE</em>, <em>?GL_TRUE</em>, <em>?GL_TRUE</em>). See <strong>gl:colorMask/4</strong> .</p><p><em>?GL_COMPRESSED_TEXTURE_FORMATS</em>: <em>Params</em> returns a list of symbolic constants of length <em>?GL_NUM_COMPRESSED_TEXTURE_FORMATS</em> indicating which compressed texture formats are available. See <strong>gl:compressedTexImage2D/8</strong> .</p><p><em>?GL_CONTEXT_FLAGS</em>: <em>Params</em> returns one value, the flags with which the context was created (such as debugging functionality).</p><p><em>?GL_CULL_FACE</em>: <em>Params</em> returns a single boolean value indicating whether polygon culling is enabled. The initial value is <em>?GL_FALSE</em>. See <strong>gl:cullFace/1</strong> .</p><p><em>?GL_CURRENT_PROGRAM</em>: <em>Params</em> returns one value, the name of the program object that is currently active, or 0 if no program object is active. See <strong>gl:useProgram/1</strong> .</p><p><em>?GL_DEPTH_CLEAR_VALUE</em>: <em>Params</em> returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is 1. See <strong>gl:clearDepth/1</strong> .</p><p><em>?GL_DEPTH_FUNC</em>: <em>Params</em> returns one value, the symbolic constant that indicates the depth comparison function. The initial value is <em>?GL_LESS</em>. See <strong>gl:depthFunc/1</strong> .</p><p><em>?GL_DEPTH_RANGE</em>: <em>Params</em> returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 1). See <strong>gl:depthRange/2</strong> .</p><p><em>?GL_DEPTH_TEST</em>: <em>Params</em> returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is <em>?GL_FALSE</em>. See <strong>gl:depthFunc/1</strong> and <strong>gl:depthRange/2</strong> .</p><p><em>?GL_DEPTH_WRITEMASK</em>: <em>Params</em> returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is <em>?GL_TRUE</em>. See <strong>gl:depthMask/1</strong> .</p><p><em>?GL_DITHER</em>: <em>Params</em> returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is <em>?GL_TRUE</em>.</p><p><em>?GL_DOUBLEBUFFER</em>: <em>Params</em> returns a single boolean value indicating whether double buffering is supported.</p><p><em>?GL_DRAW_BUFFER</em>: <em>Params</em> returns one value, a symbolic constant indicating which buffers are being drawn to. See <strong>gl:drawBuffer/1</strong> . The initial value is <em>?GL_BACK</em> if there are back buffers, otherwise it is <em>?GL_FRONT</em>.</p><p><em>?GL_DRAW_BUFFER</em><em>i</em>: <em>Params</em> returns one value, a symbolic constant indicating which buffers are being drawn to by the corresponding output color. See <strong>gl:drawBuffers/1</strong> . The initial value of <em>?GL_DRAW_BUFFER0</em> is <em>?GL_BACK</em> if there are back buffers, otherwise it is <em>?GL_FRONT</em>. The initial values of draw buffers for all other output colors is <em>?GL_NONE</em>.</p><p><em>?GL_DRAW_FRAMEBUFFER_BINDING</em>: <em>Params</em> returns one value, the name of the framebuffer object currently bound to the <em>?GL_DRAW_FRAMEBUFFER</em> target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See <strong>gl:bindFramebuffer/2</strong> .</p><p><em>?GL_READ_FRAMEBUFFER_BINDING</em>: <em>Params</em> returns one value, the name of the framebuffer object currently bound to the <em>?GL_READ_FRAMEBUFFER</em> target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See <strong>gl:bindFramebuffer/2</strong> .</p><p><em>?GL_ELEMENT_ARRAY_BUFFER_BINDING</em>: <em>Params</em> returns a single value, the name of the buffer object currently bound to the target <em>?GL_ELEMENT_ARRAY_BUFFER</em>. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See <strong>gl:bindBuffer/2</strong> .</p><p><em>?GL_FRAGMENT_SHADER_DERIVATIVE_HINT</em>: <em>Params</em> returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for fragment shaders. The initial value is <em>?GL_DONT_CARE</em>. See <strong>gl:hint/2</strong> .</p><p><em>?GL_IMPLEMENTATION_COLOR_READ_FORMAT</em>: <em>Params</em> returns a single GLenum value indicating the implementation's preferred pixel data format. See <strong>gl:readPixels/7</strong> .</p><p><em>?GL_IMPLEMENTATION_COLOR_READ_TYPE</em>: <em>Params</em> returns a single GLenum value indicating the implementation's preferred pixel data type. See <strong>gl:readPixels/7</strong> .</p><p><em>?GL_LINE_SMOOTH</em>: <em>Params</em> returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is <em>?GL_FALSE</em>. See <strong>gl:lineWidth/1</strong> .</p><p><em>?GL_LINE_SMOOTH_HINT</em>: <em>Params</em> returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is <em>?GL_DONT_CARE</em>. See <strong>gl:hint/2</strong> .</p><p><em>?GL_LINE_WIDTH</em>: <em>Params</em> returns one value, the line width as specified with <strong>gl:lineWidth/1</strong> . The initial value is 1.</p><p><em>?GL_LAYER_PROVOKING_VERTEX</em>: <em>Params</em> returns one value, the implementation dependent specifc vertex of a primitive that is used to select the rendering layer. If the value returned is equivalent to <em>?GL_PROVOKING_VERTEX</em>, then the vertex selection follows the convention specified by <strong>gl:provokingVertex/1</strong> . If the value returned is equivalent to <em>?GL_FIRST_VERTEX_CONVENTION</em>, then the selection is always taken from the first vertex in the primitive. If the value returned is equivalent to <em>?GL_LAST_VERTEX_CONVENTION</em> , then the selection is always taken from the last vertex in the primitive. If the value returned is equivalent to <em>?GL_UNDEFINED_VERTEX</em>, then the selection is not guaranteed to be taken from any specific vertex in the primitive.</p><p><em>?GL_LINE_WIDTH_GRANULARITY</em>: <em>Params</em> returns one value, the width difference between adjacent supported widths for antialiased lines. See <strong>gl:lineWidth/1</strong> .</p><p><em>?GL_LINE_WIDTH_RANGE</em>: <em>Params</em> returns two values: the smallest and largest supported widths for antialiased lines. See <strong>gl:lineWidth/1</strong> .</p><p><em>?GL_LOGIC_OP_MODE</em>: <em>Params</em> returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is <em>?GL_COPY</em>. See <strong>gl:logicOp/1</strong> .</p><p><em>?GL_MAJOR_VERSION</em>: <em>Params</em> returns one value, the major version number of the OpenGL API supported by the current context.</p><p><em>?GL_MAX_3D_TEXTURE_SIZE</em>: <em>Params</em> returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value must be at least 64. Use <em>?GL_PROXY_TEXTURE_3D</em> to determine if a texture is too large. See <strong>gl:texImage3D/10</strong> .</p><p><em>?GL_MAX_ARRAY_TEXTURE_LAYERS</em>: <em>Params</em> returns one value. The value indicates the maximum number of layers allowed in an array texture, and must be at least 256. See <strong>gl:texImage2D/9</strong> .</p><p><em>?GL_MAX_CLIP_DISTANCES</em>: <em>Params</em> returns one value, the maximum number of application-defined clipping distances. The value must be at least 8.</p><p><em>?GL_MAX_COLOR_TEXTURE_SAMPLES</em>: <em>Params</em> returns one value, the maximum number of samples in a color multisample texture.</p><p><em>?GL_MAX_COMBINED_ATOMIC_COUNTERS</em>: <em>Params</em> returns a single value, the maximum number of atomic counters available to all active shaders.</p><p><em>?GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS</em>: <em>Params</em> returns one value, the number of words for fragment shader uniform variables in all uniform blocks (including default). The value must be at least 1. See <strong>gl:uniform1f/2</strong> .</p><p><em>?GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS</em>: <em>Params</em> returns one value, the number of words for geometry shader uniform variables in all uniform blocks (including default). The value must be at least 1. See <strong>gl:uniform1f/2</strong> .</p><p><em>?GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</em>: <em>Params</em> returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 48. See <strong>gl:activeTexture/1</strong> .</p><p><em>?GL_MAX_COMBINED_UNIFORM_BLOCKS</em>: <em>Params</em> returns one value, the maximum number of uniform blocks per program. The value must be at least 36. See <strong>gl:uniformBlockBinding/3</strong> .</p><p><em>?GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS</em>: <em>Params</em> returns one value, the number of words for vertex shader uniform variables in all uniform blocks (including default). The value must be at least 1. See <strong>gl:uniform1f/2</strong> .</p><p><em>?GL_MAX_CUBE_MAP_TEXTURE_SIZE</em>: <em>Params</em> returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 1024. Use <em>?GL_PROXY_TEXTURE_CUBE_MAP</em> to determine if a texture is too large. See <strong>gl:texImage2D/9</strong> .</p><p><em>?GL_MAX_DEPTH_TEXTURE_SAMPLES</em>: <em>Params</em> returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.</p><p><em>?GL_MAX_DRAW_BUFFERS</em>: <em>Params</em> returns one value, the maximum number of simultaneous outputs that may be written in a fragment shader. The value must be at least 8. See <strong>gl:drawBuffers/1</strong> .</p><p><em>?GL_MAX_DUALSOURCE_DRAW_BUFFERS</em>: <em>Params</em> returns one value, the maximum number of active draw buffers when using dual-source blending. The value must be at least 1. See <strong>gl:blendFunc/2</strong> and <strong>gl:blendFuncSeparate/4</strong> .</p><p><em>?GL_MAX_ELEMENTS_INDICES</em>: <em>Params</em> returns one value, the recommended maximum number of vertex array indices. See <strong>gl:drawRangeElements/6</strong> .</p><p><em>?GL_MAX_ELEMENTS_VERTICES</em>: <em>Params</em> returns one value, the recommended maximum number of vertex array vertices. See <strong>gl:drawRangeElements/6</strong> .</p><p><em>?GL_MAX_FRAGMENT_ATOMIC_COUNTERS</em>: <em>Params</em> returns a single value, the maximum number of atomic counters available to fragment shaders.</p><p><em>?GL_MAX_FRAGMENT_INPUT_COMPONENTS</em>: <em>Params</em> returns one value, the maximum number of components of the inputs read by the fragment shader, which must be at least 128.</p><p><em>?GL_MAX_FRAGMENT_UNIFORM_COMPONENTS</em>: <em>Params</em> returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value must be at least 1024. See <strong>gl:uniform1f/2</strong> .</p><p><em>?GL_MAX_FRAGMENT_UNIFORM_VECTORS</em>: <em>Params</em> returns one value, the maximum number of individual 4-vectors of floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value is equal to the value of <em>?GL_MAX_FRAGMENT_UNIFORM_COMPONENTS</em> divided by 4 and must be at least 256. See <strong>gl:uniform1f/2</strong> .</p><p><em>?GL_MAX_FRAGMENT_UNIFORM_BLOCKS</em>: <em>Params</em> returns one value, the maximum number of uniform blocks per fragment shader. The value must be at least 12. See <strong>gl:uniformBlockBinding/3</strong> .</p><p><em>?GL_MAX_GEOMETRY_ATOMIC_COUNTERS</em>: <em>Params</em> returns a single value, the maximum number of atomic counters available to geometry shaders.</p><p><em>?GL_MAX_GEOMETRY_INPUT_COMPONENTS</em>: <em>Params</em> returns one value, the maximum number of components of inputs read by a geometry shader, which must be at least 64.</p><p><em>?GL_MAX_GEOMETRY_OUTPUT_COMPONENTS</em>: <em>Params</em> returns one value, the maximum number of components of outputs written by a geometry shader, which must be at least 128.</p><p><em>?GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS</em>: <em>Params</em> returns one value, the maximum supported texture image units that can be used to access texture maps from the geometry shader. The value must be at least 16. See <strong>gl:activeTexture/1</strong> .</p><p><em>?GL_MAX_GEOMETRY_UNIFORM_BLOCKS</em>: <em>Params</em> returns one value, the maximum number of uniform blocks per geometry shader. The value must be at least 12. See <strong>gl:uniformBlockBinding/3</strong> .</p><p><em>?GL_MAX_GEOMETRY_UNIFORM_COMPONENTS</em>: <em>Params</em> returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a geometry shader. The value must be at least 1024. See <strong>gl:uniform1f/2</strong> .</p><p><em>?GL_MAX_INTEGER_SAMPLES</em>: <em>Params</em> returns one value, the maximum number of samples supported in integer format multisample buffers.</p><p><em>?GL_MIN_MAP_BUFFER_ALIGNMENT</em>: <em>Params</em> returns one value, the minimum alignment in basic machine units of pointers returned fromsee <em>glMapBuffer</em> and see <em>glMapBufferRange</em> . This value must be a power of two and must be at least 64.</p><p><em>?GL_MAX_PROGRAM_TEXEL_OFFSET</em>: <em>Params</em> returns one value, the maximum texel offset allowed in a texture lookup, which must be at least 7.</p><p><em>?GL_MIN_PROGRAM_TEXEL_OFFSET</em>: <em>Params</em> returns one value, the minimum texel offset allowed in a texture lookup, which must be at most -8.</p><p><em>?GL_MAX_RECTANGLE_TEXTURE_SIZE</em>: <em>Params</em> returns one value. The value gives a rough estimate of the largest rectangular texture that the GL can handle. The value must be at least 1024. Use <em>?GL_PROXY_RECTANGLE_TEXTURE</em> to determine if a texture is too large. See <strong>gl:texImage2D/9</strong> .</p><p><em>?GL_MAX_RENDERBUFFER_SIZE</em>: <em>Params</em> returns one value. The value indicates the maximum supported size for renderbuffers. See <strong>gl:framebufferRenderbuffer/4</strong> .</p><p><em>?GL_MAX_SAMPLE_MASK_WORDS</em>: <em>Params</em> returns one value, the maximum number of sample mask words.</p><p><em>?GL_MAX_SERVER_WAIT_TIMEOUT</em>: <em>Params</em> returns one value, the maximum <strong>gl:waitSync/3</strong> timeout interval.</p><p><em>?GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS</em>: <em>Params</em> returns a single value, the maximum number of atomic counters available to tessellation control shaders.</p><p><em>?GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS</em>: <em>Params</em> returns a single value, the maximum number of atomic counters available to tessellation evaluation shaders.</p><p><em>?GL_MAX_TEXTURE_BUFFER_SIZE</em>: <em>Params</em> returns one value. The value gives the maximum number of texels allowed in the texel array of a texture buffer object. Value must be at least 65536.</p><p><em>?GL_MAX_TEXTURE_IMAGE_UNITS</em>: <em>Params</em> returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 16. See <strong>gl:activeTexture/1</strong> .</p><p><em>?GL_MAX_TEXTURE_LOD_BIAS</em>: <em>Params</em> returns one value, the maximum, absolute value of the texture level-of-detail bias. The value must be at least 2.0.</p><p><em>?GL_MAX_TEXTURE_SIZE</em>: <em>Params</em> returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target such as <em>?GL_PROXY_TEXTURE_1D</em> or <em>?GL_PROXY_TEXTURE_2D</em> to determine if a texture is too large. See <strong>gl:texImage1D/8</strong> and <strong>gl:texImage2D/9</strong> .</p><p><em>?GL_MAX_UNIFORM_BUFFER_BINDINGS</em>: <em>Params</em> returns one value, the maximum number of uniform buffer binding points on the context, which must be at least 36.</p><p><em>?GL_MAX_UNIFORM_BLOCK_SIZE</em>: <em>Params</em> returns one value, the maximum size in basic machine units of a uniform block, which must be at least 16384.</p><p><em>?GL_MAX_VARYING_COMPONENTS</em>: <em>Params</em> returns one value, the number components for varying variables, which must be at least 60.</p><p><em>?GL_MAX_VARYING_VECTORS</em>: <em>Params</em> returns one value, the number 4-vectors for varying variables, which is equal to the value of <em>?GL_MAX_VARYING_COMPONENTS</em> and must be at least 15.</p><p><em>?GL_MAX_VARYING_FLOATS</em>: <em>Params</em> returns one value, the maximum number of interpolators available for processing varying variables used by vertex and fragment shaders. This value represents the number of individual floating-point values that can be interpolated; varying variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The value must be at least 32.</p><p><em>?GL_MAX_VERTEX_ATOMIC_COUNTERS</em>: <em>Params</em> returns a single value, the maximum number of atomic counters available to vertex shaders.</p><p><em>?GL_MAX_VERTEX_ATTRIBS</em>: <em>Params</em> returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 16. See <strong>gl:vertexAttrib1d/2</strong> .</p><p><em>?GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</em>: <em>Params</em> returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be at least 16. See <strong>gl:activeTexture/1</strong> .</p><p><em>?GL_MAX_VERTEX_UNIFORM_COMPONENTS</em>: <em>Params</em> returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex shader. The value must be at least 1024. See <strong>gl:uniform1f/2</strong> .</p><p><em>?GL_MAX_VERTEX_UNIFORM_VECTORS</em>: <em>Params</em> returns one value, the maximum number of 4-vectors that may be held in uniform variable storage for the vertex shader. The value of <em>?GL_MAX_VERTEX_UNIFORM_VECTORS</em> is equal to the value of <em>?GL_MAX_VERTEX_UNIFORM_COMPONENTS</em> and must be at least 256.</p><p><em>?GL_MAX_VERTEX_OUTPUT_COMPONENTS</em>: <em>Params</em> returns one value, the maximum number of components of output written by a vertex shader, which must be at least 64.</p><p><em>?GL_MAX_VERTEX_UNIFORM_BLOCKS</em>: <em>Params</em> returns one value, the maximum number of uniform blocks per vertex shader. The value must be at least 12. See <strong>gl:uniformBlockBinding/3</strong> .</p><p><em>?GL_MAX_VIEWPORT_DIMS</em>: <em>Params</em> returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See <strong>gl:viewport/4</strong> .</p><p><em>?GL_MAX_VIEWPORTS</em>: <em>Params</em> returns one value, the maximum number of simultaneous viewports that are supported. The value must be at least 16. See <strong>gl:viewportIndexedf/5</strong> .</p><p><em>?GL_MINOR_VERSION</em>: <em>Params</em> returns one value, the minor version number of the OpenGL API supported by the current context.</p><p><em>?GL_NUM_COMPRESSED_TEXTURE_FORMATS</em>: <em>Params</em> returns a single integer value indicating the number of available compressed texture formats. The minimum value is 4. See <strong>gl:compressedTexImage2D/8</strong> .</p><p><em>?GL_NUM_EXTENSIONS</em>: <em>Params</em> returns one value, the number of extensions supported by the GL implementation for the current context. See <strong>gl:getString/1</strong> .</p><p><em>?GL_NUM_PROGRAM_BINARY_FORMATS</em>: <em>Params</em> returns one value, the number of program binary formats supported by the implementation.</p><p><em>?GL_NUM_SHADER_BINARY_FORMATS</em>: <em>Params</em> returns one value, the number of binary shader formats supported by the implementation. If this value is greater than zero, then the implementation supports loading binary shaders. If it is zero, then the loading of binary shaders by the implementation is not supported.</p><p><em>?GL_PACK_ALIGNMENT</em>: <em>Params</em> returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_PACK_IMAGE_HEIGHT</em>: <em>Params</em> returns one value, the image height used for writing pixel data to memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_PACK_LSB_FIRST</em>: <em>Params</em> returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is <em>?GL_FALSE</em>. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_PACK_ROW_LENGTH</em>: <em>Params</em> returns one value, the row length used for writing pixel data to memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_PACK_SKIP_IMAGES</em>: <em>Params</em> returns one value, the number of pixel images skipped before the first pixel is written into memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_PACK_SKIP_PIXELS</em>: <em>Params</em> returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_PACK_SKIP_ROWS</em>: <em>Params</em> returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_PACK_SWAP_BYTES</em>: <em>Params</em> returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is <em>?GL_FALSE</em>. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_PIXEL_PACK_BUFFER_BINDING</em>: <em>Params</em> returns a single value, the name of the buffer object currently bound to the target <em>?GL_PIXEL_PACK_BUFFER</em>. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See <strong>gl:bindBuffer/2</strong> .</p><p><em>?GL_PIXEL_UNPACK_BUFFER_BINDING</em>: <em>Params</em> returns a single value, the name of the buffer object currently bound to the target <em>?GL_PIXEL_UNPACK_BUFFER</em>. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See <strong>gl:bindBuffer/2</strong> .</p><p><em>?GL_POINT_FADE_THRESHOLD_SIZE</em>: <em>Params</em> returns one value, the point size threshold for determining the point size. See <strong>gl:pointParameterf/2</strong> .</p><p><em>?GL_PRIMITIVE_RESTART_INDEX</em>: <em>Params</em> returns one value, the current primitive restart index. The initial value is 0. See <strong>gl:primitiveRestartIndex/1</strong> .</p><p><em>?GL_PROGRAM_BINARY_FORMATS</em>: <em>Params</em> an array of <em>?GL_NUM_PROGRAM_BINARY_FORMATS</em> values, indicating the proram binary formats supported by the implementation.</p><p><em>?GL_PROGRAM_PIPELINE_BINDING</em>: <em>Params</em> a single value, the name of the currently bound program pipeline object, or zero if no program pipeline object is bound. See <strong>gl:bindProgramPipeline/1</strong> .</p><p><em>?GL_PROVOKING_VERTEX</em>: <em>Params</em> returns one value, the currently selected provoking vertex convention. The initial value is <em>?GL_LAST_VERTEX_CONVENTION</em>. See <strong>gl:provokingVertex/1</strong> .</p><p><em>?GL_POINT_SIZE</em>: <em>Params</em> returns one value, the point size as specified by <strong>gl:pointSize/1</strong> . The initial value is 1.</p><p><em>?GL_POINT_SIZE_GRANULARITY</em>: <em>Params</em> returns one value, the size difference between adjacent supported sizes for antialiased points. See <strong>gl:pointSize/1</strong> .</p><p><em>?GL_POINT_SIZE_RANGE</em>: <em>Params</em> returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See <strong>gl:pointSize/1</strong> .</p><p><em>?GL_POLYGON_OFFSET_FACTOR</em>: <em>Params</em> returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See <strong>gl:polygonOffset/2</strong> .</p><p><em>?GL_POLYGON_OFFSET_UNITS</em>: <em>Params</em> returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See <strong>gl:polygonOffset/2</strong> .</p><p><em>?GL_POLYGON_OFFSET_FILL</em>: <em>Params</em> returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is <em>?GL_FALSE</em> . See <strong>gl:polygonOffset/2</strong> .</p><p><em>?GL_POLYGON_OFFSET_LINE</em>: <em>Params</em> returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is <em>?GL_FALSE</em> . See <strong>gl:polygonOffset/2</strong> .</p><p><em>?GL_POLYGON_OFFSET_POINT</em>: <em>Params</em> returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is <em>?GL_FALSE</em> . See <strong>gl:polygonOffset/2</strong> .</p><p><em>?GL_POLYGON_SMOOTH</em>: <em>Params</em> returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is <em>?GL_FALSE</em>. See <strong>gl:polygonMode/2</strong> .</p><p><em>?GL_POLYGON_SMOOTH_HINT</em>: <em>Params</em> returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is <em>?GL_DONT_CARE</em>. See <strong>gl:hint/2</strong> .</p><p><em>?GL_READ_BUFFER</em>: <em>Params</em> returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is <em>?GL_BACK</em> if there is a back buffer, otherwise it is <em>?GL_FRONT</em>. See <strong>gl:readPixels/7</strong> .</p><p><em>?GL_RENDERBUFFER_BINDING</em>: <em>Params</em> returns a single value, the name of the renderbuffer object currently bound to the target <em>?GL_RENDERBUFFER</em>. If no renderbuffer object is bound to this target, 0 is returned. The initial value is 0. See <strong>gl:bindRenderbuffer/2</strong> .</p><p><em>?GL_SAMPLE_BUFFERS</em>: <em>Params</em> returns a single integer value indicating the number of sample buffers associated with the framebuffer. See <strong>gl:sampleCoverage/2</strong> .</p><p><em>?GL_SAMPLE_COVERAGE_VALUE</em>: <em>Params</em> returns a single positive floating-point value indicating the current sample coverage value. See <strong>gl:sampleCoverage/2</strong> .</p><p><em>?GL_SAMPLE_COVERAGE_INVERT</em>: <em>Params</em> returns a single boolean value indicating if the temporary coverage value should be inverted. See <strong>gl:sampleCoverage/2</strong> .</p><p><em>?GL_SAMPLER_BINDING</em>: <em>Params</em> returns a single value, the name of the sampler object currently bound to the active texture unit. The initial value is 0. See <strong>gl:bindSampler/2</strong> .</p><p><em>?GL_SAMPLES</em>: <em>Params</em> returns a single integer value indicating the coverage mask size. See <strong>gl:sampleCoverage/2</strong> .</p><p><em>?GL_SCISSOR_BOX</em>: <em>Params</em> returns four values: the x and y window coordinates of the scissor box, followed by its width and height. Initially the x and y window coordinates are both 0 and the width and height are set to the size of the window. See <strong>gl:scissor/4</strong> .</p><p><em>?GL_SCISSOR_TEST</em>: <em>Params</em> returns a single boolean value indicating whether scissoring is enabled. The initial value is <em>?GL_FALSE</em>. See <strong>gl:scissor/4</strong> .</p><p><em>?GL_SHADER_COMPILER</em>: <em>Params</em> returns a single boolean value indicating whether an online shader compiler is present in the implementation. All desktop OpenGL implementations must support online shader compilations, and therefore the value of <em>?GL_SHADER_COMPILER</em> will always be <em>?GL_TRUE</em>.</p><p><em>?GL_SMOOTH_LINE_WIDTH_RANGE</em>: <em>Params</em> returns a pair of values indicating the range of widths supported for smooth (antialiased) lines. See <strong>gl:lineWidth/1</strong> .</p><p><em>?GL_SMOOTH_LINE_WIDTH_GRANULARITY</em>: <em>Params</em> returns a single value indicating the level of quantization applied to smooth line width parameters.</p><p><em>?GL_STENCIL_BACK_FAIL</em>: <em>Params</em> returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is <em>?GL_KEEP</em>. See <strong>gl:stencilOpSeparate/4</strong> .</p><p><em>?GL_STENCIL_BACK_FUNC</em>: <em>Params</em> returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is <em>?GL_ALWAYS</em>. See <strong>gl:stencilFuncSeparate/4</strong> .</p><p><em>?GL_STENCIL_BACK_PASS_DEPTH_FAIL</em>: <em>Params</em> returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is <em>?GL_KEEP</em>. See <strong>gl:stencilOpSeparate/4</strong> .</p><p><em>?GL_STENCIL_BACK_PASS_DEPTH_PASS</em>: <em>Params</em> returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is <em>?GL_KEEP</em>. See <strong>gl:stencilOpSeparate/4</strong> .</p><p><em>?GL_STENCIL_BACK_REF</em>: <em>Params</em> returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See <strong>gl:stencilFuncSeparate/4</strong> .</p><p><em>?GL_STENCIL_BACK_VALUE_MASK</em>: <em>Params</em> returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See <strong>gl:stencilFuncSeparate/4</strong> .</p><p><em>?GL_STENCIL_BACK_WRITEMASK</em>: <em>Params</em> returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See <strong>gl:stencilMaskSeparate/2</strong> .</p><p><em>?GL_STENCIL_CLEAR_VALUE</em>: <em>Params</em> returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See <strong>gl:clearStencil/1</strong> .</p><p><em>?GL_STENCIL_FAIL</em>: <em>Params</em> returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is <em>?GL_KEEP</em>. See <strong>gl:stencilOp/3</strong> . This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See <strong>gl:stencilOpSeparate/4</strong> .</p><p><em>?GL_STENCIL_FUNC</em>: <em>Params</em> returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is <em>?GL_ALWAYS</em>. See <strong>gl:stencilFunc/3</strong> . This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See <strong>gl:stencilFuncSeparate/4</strong> .</p><p><em>?GL_STENCIL_PASS_DEPTH_FAIL</em>: <em>Params</em> returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is <em>?GL_KEEP</em>. See <strong>gl:stencilOp/3</strong> . This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See <strong>gl:stencilOpSeparate/4</strong> .</p><p><em>?GL_STENCIL_PASS_DEPTH_PASS</em>: <em>Params</em> returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is <em>?GL_KEEP</em>. See <strong>gl:stencilOp/3</strong> . This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See <strong>gl:stencilOpSeparate/4</strong> .</p><p><em>?GL_STENCIL_REF</em>: <em>Params</em> returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See <strong>gl:stencilFunc/3</strong> . This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See <strong>gl:stencilFuncSeparate/4</strong> .</p><p><em>?GL_STENCIL_TEST</em>: <em>Params</em> returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is <em>?GL_FALSE</em>. See <strong>gl:stencilFunc/3</strong> and <strong>gl:stencilOp/3</strong> .</p><p><em>?GL_STENCIL_VALUE_MASK</em>: <em>Params</em> returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See <strong>gl:stencilFunc/3</strong> . This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See <strong>gl:stencilFuncSeparate/4</strong> .</p><p><em>?GL_STENCIL_WRITEMASK</em>: <em>Params</em> returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See <strong>gl:stencilMask/1</strong> . This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See <strong>gl:stencilMaskSeparate/2</strong> .</p><p><em>?GL_STEREO</em>: <em>Params</em> returns a single boolean value indicating whether stereo buffers (left and right) are supported.</p><p><em>?GL_SUBPIXEL_BITS</em>: <em>Params</em> returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.</p><p><em>?GL_TEXTURE_BINDING_1D</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_1D</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_1D_ARRAY</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_1D_ARRAY</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_2D</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_2D</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_2D_ARRAY</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_2D_ARRAY</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_2D_MULTISAMPLE</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_2D_MULTISAMPLE</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</em> . The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_3D</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_3D</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_BUFFER</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_BUFFER</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_CUBE_MAP</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_CUBE_MAP</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_BINDING_RECTANGLE</em>: <em>Params</em> returns a single value, the name of the texture currently bound to the target <em>?GL_TEXTURE_RECTANGLE</em>. The initial value is 0. See <strong>gl:bindTexture/2</strong> .</p><p><em>?GL_TEXTURE_COMPRESSION_HINT</em>: <em>Params</em> returns a single value indicating the mode of the texture compression hint. The initial value is <em>?GL_DONT_CARE</em>.</p><p><em>?GL_TEXTURE_BUFFER_BINDING</em>: <em>Params</em> returns a single value, the name of the texture buffer object currently bound. The initial value is 0. See <strong>gl:bindBuffer/2</strong> .</p><p><em>?GL_TIMESTAMP</em>: <em>Params</em> returns a single value, the 64-bit value of the current GL time. See <strong>gl:queryCounter/2</strong> .</p><p><em>?GL_TRANSFORM_FEEDBACK_BUFFER_BINDING</em>: When used with non-indexed variants of <em>gl:get</em> (such as <em>gl:getIntegerv</em>), <em>Params</em> returns a single value, the name of the buffer object currently bound to the target <em>?GL_TRANSFORM_FEEDBACK_BUFFER</em>. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of <em>gl:get</em> (such as <em>gl:getIntegeri_v</em>), <em>Params</em> returns a single value, the name of the buffer object bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets. See <strong>gl:bindBuffer/2</strong> , <strong>gl:bindBufferBase/3</strong> , and <strong>gl:bindBufferRange/5</strong> .</p><p><em>?GL_TRANSFORM_FEEDBACK_BUFFER_START</em>: When used with indexed variants of <em>gl:get</em> (such as <em>gl:getInteger64i_v</em>), <em>Params</em> returns a single value, the start offset of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See <strong>gl:bindBufferRange/5</strong> .</p><p><em>?GL_TRANSFORM_FEEDBACK_BUFFER_SIZE</em>: When used with indexed variants of <em>gl:get</em> (such as <em>gl:getInteger64i_v</em>), <em>Params</em> returns a single value, the size of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See <strong>gl:bindBufferRange/5</strong> .</p><p><em>?GL_UNIFORM_BUFFER_BINDING</em>: When used with non-indexed variants of <em>gl:get</em> (such as <em>gl:getIntegerv</em>), <em>Params</em> returns a single value, the name of the buffer object currently bound to the target <em>?GL_UNIFORM_BUFFER</em>. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of <em>gl:get</em> (such as <em>gl:getIntegeri_v</em>), <em>Params</em> returns a single value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial value is 0 for all targets. See <strong>gl:bindBuffer/2</strong> , <strong>gl:bindBufferBase/3</strong> , and <strong>gl:bindBufferRange/5</strong> .</p><p><em>?GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT</em>: <em>Params</em> returns a single value, the minimum required alignment for uniform buffer sizes and offset. The initial value is 1. See <strong>gl:uniformBlockBinding/3</strong> .</p><p><em>?GL_UNIFORM_BUFFER_SIZE</em>: When used with indexed variants of <em>gl:get</em> (such as <em>gl:getInteger64i_v</em>), <em>Params</em> returns a single value, the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See <strong>gl:bindBufferRange/5</strong> .</p><p><em>?GL_UNIFORM_BUFFER_START</em>: When used with indexed variants of <em>gl:get</em> (such as <em>gl:getInteger64i_v</em>), <em>Params</em> returns a single value, the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See <strong>gl:bindBufferRange/5</strong> .</p><p><em>?GL_UNPACK_ALIGNMENT</em>: <em>Params</em> returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_UNPACK_IMAGE_HEIGHT</em>: <em>Params</em> returns one value, the image height used for reading pixel data from memory. The initial is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_UNPACK_LSB_FIRST</em>: <em>Params</em> returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is <em>?GL_FALSE</em>. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_UNPACK_ROW_LENGTH</em>: <em>Params</em> returns one value, the row length used for reading pixel data from memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_UNPACK_SKIP_IMAGES</em>: <em>Params</em> returns one value, the number of pixel images skipped before the first pixel is read from memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_UNPACK_SKIP_PIXELS</em>: <em>Params</em> returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_UNPACK_SKIP_ROWS</em>: <em>Params</em> returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_UNPACK_SWAP_BYTES</em>: <em>Params</em> returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is <em>?GL_FALSE</em>. See <strong>gl:pixelStoref/2</strong> .</p><p><em>?GL_VERTEX_PROGRAM_POINT_SIZE</em>: <em>Params</em> returns a single boolean value indicating whether vertex program point size mode is enabled. If enabled, and a vertex shader is active, then the point size is taken from the shader built-in gl_PointSize. If disabled, and a vertex shader is active, then the point size is taken from the point state as specified by <strong>gl:pointSize/1</strong> . The initial value is <em>?GL_FALSE</em>.</p><p><em>?GL_VIEWPORT</em>: When used with non-indexed variants of <em>gl:get</em> (such as <em>gl:getIntegerv</em> ), <em>Params</em> returns four values: the x and y window coordinates of the viewport, followed by its width and height. Initially the x and y window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See <strong>gl:viewport/4</strong> . When used with indexed variants of <em>gl:get</em> (such as <em>gl:getIntegeri_v</em>), <em>Params</em> returns four values: the x and y window coordinates of the indexed viewport, followed by its width and height. Initially the x and y window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See <strong>gl:viewportIndexedf/5</strong> .</p><p><em>?GL_VIEWPORT_BOUNDS_RANGE</em>: <em>Params</em> returns two values, the minimum and maximum viewport bounds range. The minimum range should be at least [-32768, 32767].</p><p><em>?GL_VIEWPORT_INDEX_PROVOKING_VERTEX</em>: <em>Params</em> returns one value, the implementation dependent specifc vertex of a primitive that is used to select the viewport index. If the value returned is equivalent to <em>?GL_PROVOKING_VERTEX</em>, then the vertex selection follows the convention specified by <strong>gl:provokingVertex/1</strong> . If the value returned is equivalent to <em>?GL_FIRST_VERTEX_CONVENTION</em>, then the selection is always taken from the first vertex in the primitive. If the value returned is equivalent to <em>?GL_LAST_VERTEX_CONVENTION</em> , then the selection is always taken from the last vertex in the primitive. If the value returned is equivalent to <em>?GL_UNDEFINED_VERTEX</em>, then the selection is not guaranteed to be taken from any specific vertex in the primitive.</p><p><em>?GL_VIEWPORT_SUBPIXEL_BITS</em>: <em>Params</em> returns a single value, the number of bits of sub-pixel precision which the GL uses to interpret the floating point viewport bounds. The minimum value is 0.</p><p>Many of the boolean parameters can also be queried more easily using <strong>gl:isEnabled/1</strong> .</p><p>See external documentation.</p><p><strong></strong> getDoublev(Pname) -&gt; [float()]</p><p>Types:</p><p>Pname = enum()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> getFloatv(Pname) -&gt; [float()]</p><p>Types:</p><p>Pname = enum()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> getIntegerv(Pname) -&gt; [integer()]</p><p>Types:</p><p>Pname = enum()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> pushAttrib(Mask) -&gt; ok</p><p>Types:</p><p>Mask = integer()</p><p>Push and pop the server attribute stack</p><p><em>gl:pushAttrib</em> takes one argument, a mask that indicates which groups of state variables to save on the attribute stack. Symbolic constants are used to set bits in the mask. <em>Mask</em> is typically constructed by specifying the bitwise-or of several of these constants together. The special mask <em>?GL_ALL_ATTRIB_BITS</em> can be used to save all stackable states.</p><p>The symbolic mask constants and their associated GL state are as follows (the second column lists which attributes are saved):<em>?GL_ACCUM_BUFFER_BIT</em> Accumulation buffer clear value</p><p><em>?GL_COLOR_BUFFER_BIT</em><em>?GL_ALPHA_TEST</em> enable bit</p><p> Alpha test function and reference value</p><p><em>?GL_BLEND</em> enable bit</p><p> Blending source and destination functions</p><p> Constant blend color</p><p> Blending equation</p><p><em>?GL_DITHER</em> enable bit</p><p><em>?GL_DRAW_BUFFER</em> setting</p><p><em>?GL_COLOR_LOGIC_OP</em> enable bit</p><p><em>?GL_INDEX_LOGIC_OP</em> enable bit</p><p> Logic op function</p><p> Color mode and index mode clear values</p><p> Color mode and index mode writemasks</p><p><em>?GL_CURRENT_BIT</em> Current RGBA color</p><p> Current color index</p><p> Current normal vector</p><p> Current texture coordinates</p><p> Current raster position</p><p><em>?GL_CURRENT_RASTER_POSITION_VALID</em> flag</p><p> RGBA color associated with current raster position</p><p> Color index associated with current raster position</p><p> Texture coordinates associated with current raster position</p><p><em>?GL_EDGE_FLAG</em> flag</p><p><em>?GL_DEPTH_BUFFER_BIT</em><em>?GL_DEPTH_TEST</em> enable bit</p><p> Depth buffer test function</p><p> Depth buffer clear value</p><p><em>?GL_DEPTH_WRITEMASK</em> enable bit</p><p><em>?GL_ENABLE_BIT</em><em>?GL_ALPHA_TEST</em> flag</p><p><em>?GL_AUTO_NORMAL</em> flag</p><p><em>?GL_BLEND</em> flag</p><p> Enable bits for the user-definable clipping planes</p><p><em>?GL_COLOR_MATERIAL</em></p><p><em>?GL_CULL_FACE</em> flag</p><p><em>?GL_DEPTH_TEST</em> flag</p><p><em>?GL_DITHER</em> flag</p><p><em>?GL_FOG</em> flag</p><p><em>?GL_LIGHT</em><em>i</em> where <em>?0</em> &lt;= <em>i</em> &lt; <em>?GL_MAX_LIGHTS</em></p><p><em>?GL_LIGHTING</em> flag</p><p><em>?GL_LINE_SMOOTH</em> flag</p><p><em>?GL_LINE_STIPPLE</em> flag</p><p><em>?GL_COLOR_LOGIC_OP</em> flag</p><p><em>?GL_INDEX_LOGIC_OP</em> flag</p><p><em>?GL_MAP1_</em><em>x</em> where <em>x</em> is a map type</p><p><em>?GL_MAP2_</em><em>x</em> where <em>x</em> is a map type</p><p><em>?GL_MULTISAMPLE</em> flag</p><p><em>?GL_NORMALIZE</em> flag</p><p><em>?GL_POINT_SMOOTH</em> flag</p><p><em>?GL_POLYGON_OFFSET_LINE</em> flag</p><p><em>?GL_POLYGON_OFFSET_FILL</em> flag</p><p><em>?GL_POLYGON_OFFSET_POINT</em> flag</p><p><em>?GL_POLYGON_SMOOTH</em> flag</p><p><em>?GL_POLYGON_STIPPLE</em> flag</p><p><em>?GL_SAMPLE_ALPHA_TO_COVERAGE</em> flag</p><p><em>?GL_SAMPLE_ALPHA_TO_ONE</em> flag</p><p><em>?GL_SAMPLE_COVERAGE</em> flag</p><p><em>?GL_SCISSOR_TEST</em> flag</p><p><em>?GL_STENCIL_TEST</em> flag</p><p><em>?GL_TEXTURE_1D</em> flag</p><p><em>?GL_TEXTURE_2D</em> flag</p><p><em>?GL_TEXTURE_3D</em> flag</p><p> Flags <em>?GL_TEXTURE_GEN_</em><em>x</em> where <em>x</em> is S, T, R, or Q</p><p><em>?GL_EVAL_BIT</em><em>?GL_MAP1_</em><em>x</em> enable bits, where <em>x</em> is a map type</p><p><em>?GL_MAP2_</em><em>x</em> enable bits, where <em>x</em> is a map type</p><p> 1D grid endpoints and divisions</p><p> 2D grid endpoints and divisions</p><p><em>?GL_AUTO_NORMAL</em> enable bit</p><p><em>?GL_FOG_BIT</em><em>?GL_FOG</em> enable bit</p><p> Fog color</p><p> Fog density</p><p> Linear fog start</p><p> Linear fog end</p><p> Fog index</p><p><em>?GL_FOG_MODE</em> value</p><p><em>?GL_HINT_BIT</em><em>?GL_PERSPECTIVE_CORRECTION_HINT</em> setting</p><p><em>?GL_POINT_SMOOTH_HINT</em> setting</p><p><em>?GL_LINE_SMOOTH_HINT</em> setting</p><p><em>?GL_POLYGON_SMOOTH_HINT</em> setting</p><p><em>?GL_FOG_HINT</em> setting</p><p><em>?GL_GENERATE_MIPMAP_HINT</em> setting</p><p><em>?GL_TEXTURE_COMPRESSION_HINT</em> setting</p><p><em>?GL_LIGHTING_BIT</em><em>?GL_COLOR_MATERIAL</em> enable bit</p><p><em>?GL_COLOR_MATERIAL_FACE</em> value</p><p> Color material parameters that are tracking the current color</p><p> Ambient scene color</p><p><em>?GL_LIGHT_MODEL_LOCAL_VIEWER</em> value</p><p><em>?GL_LIGHT_MODEL_TWO_SIDE</em> setting</p><p><em>?GL_LIGHTING</em> enable bit</p><p> Enable bit for each light</p><p> Ambient, diffuse, and specular intensity for each light</p><p> Direction, position, exponent, and cutoff angle for each light</p><p> Constant, linear, and quadratic attenuation factors for each light</p><p> Ambient, diffuse, specular, and emissive color for each material</p><p> Ambient, diffuse, and specular color indices for each material</p><p> Specular exponent for each material</p><p><em>?GL_SHADE_MODEL</em> setting</p><p><em>?GL_LINE_BIT</em><em>?GL_LINE_SMOOTH</em> flag</p><p><em>?GL_LINE_STIPPLE</em> enable bit</p><p> Line stipple pattern and repeat counter</p><p> Line width</p><p><em>?GL_LIST_BIT</em><em>?GL_LIST_BASE</em> setting</p><p><em>?GL_MULTISAMPLE_BIT</em><em>?GL_MULTISAMPLE</em> flag</p><p><em>?GL_SAMPLE_ALPHA_TO_COVERAGE</em> flag</p><p><em>?GL_SAMPLE_ALPHA_TO_ONE</em> flag</p><p><em>?GL_SAMPLE_COVERAGE</em> flag</p><p><em>?GL_SAMPLE_COVERAGE_VALUE</em> value</p><p><em>?GL_SAMPLE_COVERAGE_INVERT</em> value</p><p><em>?GL_PIXEL_MODE_BIT</em><em>?GL_RED_BIAS</em> and <em>?GL_RED_SCALE</em> settings</p><p><em>?GL_GREEN_BIAS</em> and <em>?GL_GREEN_SCALE</em> values</p><p><em>?GL_BLUE_BIAS</em> and <em>?GL_BLUE_SCALE</em></p><p><em>?GL_ALPHA_BIAS</em> and <em>?GL_ALPHA_SCALE</em></p><p><em>?GL_DEPTH_BIAS</em> and <em>?GL_DEPTH_SCALE</em></p><p><em>?GL_INDEX_OFFSET</em> and <em>?GL_INDEX_SHIFT</em> values</p><p><em>?GL_MAP_COLOR</em> and <em>?GL_MAP_STENCIL</em> flags</p><p><em>?GL_ZOOM_X</em> and <em>?GL_ZOOM_Y</em> factors</p><p><em>?GL_READ_BUFFER</em> setting</p><p><em>?GL_POINT_BIT</em><em>?GL_POINT_SMOOTH</em> flag</p><p> Point size</p><p><em>?GL_POLYGON_BIT</em><em>?GL_CULL_FACE</em> enable bit</p><p><em>?GL_CULL_FACE_MODE</em> value</p><p><em>?GL_FRONT_FACE</em> indicator</p><p><em>?GL_POLYGON_MODE</em> setting</p><p><em>?GL_POLYGON_SMOOTH</em> flag</p><p><em>?GL_POLYGON_STIPPLE</em> enable bit</p><p><em>?GL_POLYGON_OFFSET_FILL</em> flag</p><p><em>?GL_POLYGON_OFFSET_LINE</em> flag</p><p><em>?GL_POLYGON_OFFSET_POINT</em> flag</p><p><em>?GL_POLYGON_OFFSET_FACTOR</em></p><p><em>?GL_POLYGON_OFFSET_UNITS</em></p><p><em>?GL_POLYGON_STIPPLE_BIT</em> Polygon stipple image</p><p><em>?GL_SCISSOR_BIT</em><em>?GL_SCISSOR_TEST</em> flag</p><p> Scissor box</p><p><em>?GL_STENCIL_BUFFER_BIT</em><em>?GL_STENCIL_TEST</em> enable bit</p><p> Stencil function and reference value</p><p> Stencil value mask</p><p> Stencil fail, pass, and depth buffer pass actions</p><p> Stencil buffer clear value</p><p> Stencil buffer writemask</p><p><em>?GL_TEXTURE_BIT</em> Enable bits for the four texture coordinates</p><p> Border color for each texture image</p><p> Minification function for each texture image</p><p> Magnification function for each texture image</p><p> Texture coordinates and wrap mode for each texture image</p><p> Color and mode for each texture environment</p><p> Enable bits <em>?GL_TEXTURE_GEN_</em><em>x</em>, <em>x</em> is S, T, R, and Q</p><p><em>?GL_TEXTURE_GEN_MODE</em> setting for S, T, R, and Q</p><p><strong>gl:texGend/3</strong> plane equations for S, T, R, and Q</p><p> Current texture bindings (for example, <em>?GL_TEXTURE_BINDING_2D</em>)</p><p><em>?GL_TRANSFORM_BIT</em> Coefficients of the six clipping planes</p><p> Enable bits for the user-definable clipping planes</p><p><em>?GL_MATRIX_MODE</em> value</p><p><em>?GL_NORMALIZE</em> flag</p><p><em>?GL_RESCALE_NORMAL</em> flag</p><p><em>?GL_VIEWPORT_BIT</em> Depth range (near and far)</p><p> Viewport origin and extent</p><p><strong>gl:pushAttrib/1</strong> restores the values of the state variables saved with the last <em>gl:pushAttrib</em> command. Those not saved are left unchanged.</p><p>It is an error to push attributes onto a full stack or to pop attributes off an empty stack. In either case, the error flag is set and no other change is made to GL state.</p><p>Initially, the attribute stack is empty.</p><p>See external documentation.</p><p><strong></strong> popAttrib() -&gt; ok</p><p>See <strong>pushAttrib/1</strong></p><p><strong></strong> pushClientAttrib(Mask) -&gt; ok</p><p>Types:</p><p>Mask = integer()</p><p>Push and pop the client attribute stack</p><p><em>gl:pushClientAttrib</em> takes one argument, a mask that indicates which groups of client-state variables to save on the client attribute stack. Symbolic constants are used to set bits in the mask. <em>Mask</em> is typically constructed by specifying the bitwise-or of several of these constants together. The special mask <em>?GL_CLIENT_ALL_ATTRIB_BITS</em> can be used to save all stackable client state.</p><p>The symbolic mask constants and their associated GL client state are as follows (the second column lists which attributes are saved):</p><p><em>?GL_CLIENT_PIXEL_STORE_BIT</em> Pixel storage modes <em>?GL_CLIENT_VERTEX_ARRAY_BIT</em> Vertex arrays (and enables)</p><p><strong>gl:pushClientAttrib/1</strong> restores the values of the client-state variables saved with the last <em>gl:pushClientAttrib</em>. Those not saved are left unchanged.</p><p>It is an error to push attributes onto a full client attribute stack or to pop attributes off an empty stack. In either case, the error flag is set, and no other change is made to GL state.</p><p>Initially, the client attribute stack is empty.</p><p>See external documentation.</p><p><strong></strong> popClientAttrib() -&gt; ok</p><p>See <strong>pushClientAttrib/1</strong></p><p><strong></strong> renderMode(Mode) -&gt; integer()</p><p>Types:</p><p>Mode = enum()</p><p>Set rasterization mode</p><p><em>gl:renderMode</em> sets the rasterization mode. It takes one argument, <em>Mode</em> , which can assume one of three predefined values:</p><p><em>?GL_RENDER</em>: Render mode. Primitives are rasterized, producing pixel fragments, which are written into the frame buffer. This is the normal mode and also the default mode.</p><p><em>?GL_SELECT</em>: Selection mode. No pixel fragments are produced, and no change to the frame buffer contents is made. Instead, a record of the names of primitives that would have been drawn if the render mode had been <em>?GL_RENDER</em> is returned in a select buffer, which must be created (see <strong>gl:selectBuffer/2</strong> ) before selection mode is entered.</p><p><em>?GL_FEEDBACK</em>: Feedback mode. No pixel fragments are produced, and no change to the frame buffer contents is made. Instead, the coordinates and attributes of vertices that would have been drawn if the render mode had been <em>?GL_RENDER</em> is returned in a feedback buffer, which must be created (see <strong>gl:feedbackBuffer/3</strong> ) before feedback mode is entered.</p><p>The return value of <em>gl:renderMode</em> is determined by the render mode at the time <em>gl:renderMode</em> is called, rather than by <em>Mode</em> . The values returned for the three render modes are as follows:</p><p><em>?GL_RENDER</em>: 0.</p><p><em>?GL_SELECT</em>: The number of hit records transferred to the select buffer.</p><p><em>?GL_FEEDBACK</em>: The number of values (not vertices) transferred to the feedback buffer.</p><p>See the <strong>gl:selectBuffer/2</strong> and <strong>gl:feedbackBuffer/3</strong> reference pages for more details concerning selection and feedback operation.</p><p>See external documentation.</p><p><strong></strong> getError() -&gt; enum()</p><p>Return error information</p><p><em>gl:getError</em> returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until <em>gl:getError</em> is called, the error code is returned, and the flag is reset to <em>?GL_NO_ERROR</em>. If a call to <em>gl:getError</em> returns <em>?GL_NO_ERROR</em>, there has been no detectable error since the last call to <em>gl:getError</em> , or since the GL was initialized.</p><p>To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to <em>?GL_NO_ERROR</em> when <em>gl:getError</em> is called. If more than one flag has recorded an error, <em>gl:getError</em> returns and clears an arbitrary error flag value. Thus, <em>gl:getError</em> should always be called in a loop, until it returns <em>?GL_NO_ERROR</em> , if all error flags are to be reset.</p><p>Initially, all error flags are set to <em>?GL_NO_ERROR</em>.</p><p>The following errors are currently defined:</p><p><em>?GL_NO_ERROR</em>: No error has been recorded. The value of this symbolic constant is guaranteed to be 0.</p><p><em>?GL_INVALID_ENUM</em>: An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.</p><p><em>?GL_INVALID_VALUE</em>: A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.</p><p><em>?GL_INVALID_OPERATION</em>: The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.</p><p><em>?GL_INVALID_FRAMEBUFFER_OPERATION</em>: The framebuffer object is not complete. The offending command is ignored and has no other side effect than to set the error flag.</p><p><em>?GL_OUT_OF_MEMORY</em>: There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.</p><p>When an error flag is set, results of a GL operation are undefined only if <em>?GL_OUT_OF_MEMORY</em> has occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating command returns a value, it returns 0. If <em>gl:getError</em> itself generates an error, it returns 0.</p><p>See external documentation.</p><p><strong></strong> getString(Name) -&gt; string()</p><p>Types:</p><p>Name = enum()</p><p>Return a string describing the current GL connection</p><p><em>gl:getString</em> returns a pointer to a static string describing some aspect of the current GL connection. <em>Name</em> can be one of the following:</p><p><em>?GL_VENDOR</em>: Returns the company responsible for this GL implementation. This name does not change from release to release.</p><p><em>?GL_RENDERER</em>: Returns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform. It does not change from release to release.</p><p><em>?GL_VERSION</em>: Returns a version or release number.</p><p><em>?GL_SHADING_LANGUAGE_VERSION</em>: Returns a version or release number for the shading language.</p><p><em>gl:getStringi</em> returns a pointer to a static string indexed by <em>Index</em> . <em>Name</em> can be one of the following:</p><p><em>?GL_EXTENSIONS</em>: For <em>gl:getStringi</em> only, returns the extension string supported by the implementation at <em>Index</em> .</p><p>Strings <em>?GL_VENDOR</em> and <em>?GL_RENDERER</em> together uniquely specify a platform. They do not change from release to release and should be used by platform-recognition algorithms.</p><p>The <em>?GL_VERSION</em> and <em>?GL_SHADING_LANGUAGE_VERSION</em> strings begin with a version number. The version number uses one of these forms:</p><p><em>major_number.minor_number</em><em>major_number.minor_number.release_number</em></p><p>Vendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information.</p><p>All strings are null-terminated.</p><p>See external documentation.</p><p><strong></strong> finish() -&gt; ok</p><p>Block until all GL execution is complete</p><p><em>gl:finish</em> does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.</p><p>See external documentation.</p><p><strong></strong> flush() -&gt; ok</p><p>Force execution of GL commands in finite time</p><p>Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. <em>gl:flush</em> empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time.</p><p>Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call <em>gl:flush</em> whenever they count on having all of their previously issued commands completed. For example, call <em>gl:flush</em> before waiting for user input that depends on the generated image.</p><p>See external documentation.</p><p><strong></strong> hint(Target, Mode) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Mode = enum()</p><p>Specify implementation-specific hints</p><p>Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified with two arguments. <em>Target</em> is a symbolic constant indicating the behavior to be controlled, and <em>Mode</em> is another symbolic constant indicating the desired behavior. The initial value for each <em>Target</em> is <em>?GL_DONT_CARE</em> . <em>Mode</em> can be one of the following:</p><p><em>?GL_FASTEST</em>: The most efficient option should be chosen.</p><p><em>?GL_NICEST</em>: The most correct, or highest quality, option should be chosen.</p><p><em>?GL_DONT_CARE</em>: No preference.</p><p>Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation. The hint aspects that can be specified with <em>Target</em> , along with suggested semantics, are as follows:</p><p><em>?GL_FRAGMENT_SHADER_DERIVATIVE_HINT</em>: Indicates the accuracy of the derivative calculation for the GL shading language fragment processing built-in functions: <em>?dFdx</em> , <em>?dFdy</em>, and <em>?fwidth</em>.</p><p><em>?GL_LINE_SMOOTH_HINT</em>: Indicates the sampling quality of antialiased lines. If a larger filter function is applied, hinting <em>?GL_NICEST</em> can result in more pixel fragments being generated during rasterization.</p><p><em>?GL_POLYGON_SMOOTH_HINT</em>: Indicates the sampling quality of antialiased polygons. Hinting <em>?GL_NICEST</em> can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.</p><p><em>?GL_TEXTURE_COMPRESSION_HINT</em>: Indicates the quality and performance of the compressing texture images. Hinting <em>?GL_FASTEST</em> indicates that texture images should be compressed as quickly as possible, while <em>?GL_NICEST</em> indicates that texture images should be compressed with as little image quality loss as possible. <em>?GL_NICEST</em> should be selected if the texture is to be retrieved by <strong>gl:getCompressedTexImage/3</strong> for reuse.</p><p>See external documentation.</p><p><strong></strong> clearDepth(Depth) -&gt; ok</p><p>Types:</p><p>Depth = clamp()</p><p>Specify the clear value for the depth buffer</p><p><em>gl:clearDepth</em> specifies the depth value used by <strong>gl:clear/1</strong> to clear the depth buffer. Values specified by <em>gl:clearDepth</em> are clamped to the range [0 1].</p><p>See external documentation.</p><p><strong></strong> depthFunc(Func) -&gt; ok</p><p>Types:</p><p>Func = enum()</p><p>Specify the value used for depth buffer comparisons</p><p><em>gl:depthFunc</em> specifies the function used to compare each incoming pixel depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> of <em>?GL_DEPTH_TEST</em> .)</p><p><em>Func</em> specifies the conditions under which the pixel will be drawn. The comparison functions are as follows:</p><p><em>?GL_NEVER</em>: Never passes.</p><p><em>?GL_LESS</em>: Passes if the incoming depth value is less than the stored depth value.</p><p><em>?GL_EQUAL</em>: Passes if the incoming depth value is equal to the stored depth value.</p><p><em>?GL_LEQUAL</em>: Passes if the incoming depth value is less than or equal to the stored depth value.</p><p><em>?GL_GREATER</em>: Passes if the incoming depth value is greater than the stored depth value.</p><p><em>?GL_NOTEQUAL</em>: Passes if the incoming depth value is not equal to the stored depth value.</p><p><em>?GL_GEQUAL</em>: Passes if the incoming depth value is greater than or equal to the stored depth value.</p><p><em>?GL_ALWAYS</em>: Always passes.</p><p>The initial value of <em>Func</em> is <em>?GL_LESS</em>. Initially, depth testing is disabled. If depth testing is disabled or if no depth buffer exists, it is as if the depth test always passes.</p><p>See external documentation.</p><p><strong></strong> depthMask(Flag) -&gt; ok</p><p>Types:</p><p>Flag = 0 | 1</p><p>Enable or disable writing into the depth buffer</p><p><em>gl:depthMask</em> specifies whether the depth buffer is enabled for writing. If <em>Flag</em> is <em>?GL_FALSE</em>, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.</p><p>See external documentation.</p><p><strong></strong> depthRange(Near_val, Far_val) -&gt; ok</p><p>Types:</p><p>Near_val = clamp()</p><p>Far_val = clamp()</p><p>Specify mapping of depth values from normalized device coordinates to window coordinates</p><p>After clipping and division by <em>w</em>, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. <em>gl:depthRange</em> specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by <em>gl:depthRange</em> are both clamped to this range before they are accepted.</p><p>The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.</p><p>See external documentation.</p><p><strong></strong> clearAccum(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = float()</p><p>Green = float()</p><p>Blue = float()</p><p>Alpha = float()</p><p>Specify clear values for the accumulation buffer</p><p><em>gl:clearAccum</em> specifies the red, green, blue, and alpha values used by <strong>gl:clear/1</strong> to clear the accumulation buffer.</p><p>Values specified by <em>gl:clearAccum</em> are clamped to the range [-1 1].</p><p>See external documentation.</p><p><strong></strong> accum(Op, Value) -&gt; ok</p><p>Types:</p><p>Op = enum()</p><p>Value = float()</p><p>Operate on the accumulation buffer</p><p>The accumulation buffer is an extended-range color buffer. Images are not rendered into it. Rather, images rendered into one of the color buffers are added to the contents of the accumulation buffer after rendering. Effects such as antialiasing (of points, lines, and polygons), motion blur, and depth of field can be created by accumulating images generated with different transformation matrices.</p><p>Each pixel in the accumulation buffer consists of red, green, blue, and alpha values. The number of bits per component in the accumulation buffer depends on the implementation. You can examine this number by calling <strong>gl:getBooleanv/1</strong> four times, with arguments <em>?GL_ACCUM_RED_BITS</em>, <em>?GL_ACCUM_GREEN_BITS</em>, <em>?GL_ACCUM_BLUE_BITS</em>, and <em>?GL_ACCUM_ALPHA_BITS</em> . Regardless of the number of bits per component, the range of values stored by each component is [-1 1]. The accumulation buffer pixels are mapped one-to-one with frame buffer pixels.</p><p><em>gl:accum</em> operates on the accumulation buffer. The first argument, <em>Op</em> , is a symbolic constant that selects an accumulation buffer operation. The second argument, <em>Value</em> , is a floating-point value to be used in that operation. Five operations are specified: <em>?GL_ACCUM</em> , <em>?GL_LOAD</em>, <em>?GL_ADD</em>, <em>?GL_MULT</em>, and <em>?GL_RETURN</em>.</p><p>All accumulation buffer operations are limited to the area of the current scissor box and applied identically to the red, green, blue, and alpha components of each pixel. If a <em>gl:accum</em> operation results in a value outside the range [-1 1], the contents of an accumulation buffer pixel component are undefined.</p><p>The operations are as follows:</p><p><em>?GL_ACCUM</em>: Obtains R, G, B, and A values from the buffer currently selected for reading (see <strong>gl:readBuffer/1</strong> ). Each component value is divided by 2 n-1, where n is the number of bits allocated to each color component in the currently selected buffer. The result is a floating-point value in the range [0 1], which is multiplied by <em>Value</em> and added to the corresponding pixel component in the accumulation buffer, thereby updating the accumulation buffer.</p><p><em>?GL_LOAD</em>: Similar to <em>?GL_ACCUM</em>, except that the current value in the accumulation buffer is not used in the calculation of the new value. That is, the R, G, B, and A values from the currently selected buffer are divided by 2 n-1, multiplied by <em>Value</em> , and then stored in the corresponding accumulation buffer cell, overwriting the current value.</p><p><em>?GL_ADD</em>: Adds <em>Value</em> to each R, G, B, and A in the accumulation buffer.</p><p><em>?GL_MULT</em>: Multiplies each R, G, B, and A in the accumulation buffer by <em>Value</em> and returns the scaled component to its corresponding accumulation buffer location.</p><p><em>?GL_RETURN</em>: Transfers accumulation buffer values to the color buffer or buffers currently selected for writing. Each R, G, B, and A component is multiplied by <em>Value</em> , then multiplied by 2 n-1, clamped to the range [0 2 n-1], and stored in the corresponding display buffer cell. The only fragment operations that are applied to this transfer are pixel ownership, scissor, dithering, and color writemasks.</p><p>To clear the accumulation buffer, call <strong>gl:clearAccum/4</strong> with R, G, B, and A values to set it to, then call <strong>gl:clear/1</strong> with the accumulation buffer enabled.</p><p>See external documentation.</p><p><strong></strong> matrixMode(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Specify which matrix is the current matrix</p><p><em>gl:matrixMode</em> sets the current matrix mode. <em>Mode</em> can assume one of four values:</p><p><em>?GL_MODELVIEW</em>: Applies subsequent matrix operations to the modelview matrix stack.</p><p><em>?GL_PROJECTION</em>: Applies subsequent matrix operations to the projection matrix stack.</p><p><em>?GL_TEXTURE</em>: Applies subsequent matrix operations to the texture matrix stack.</p><p><em>?GL_COLOR</em>: Applies subsequent matrix operations to the color matrix stack.</p><p>To find out which matrix stack is currently the target of all matrix operations, call <strong>gl:getBooleanv/1</strong> with argument <em>?GL_MATRIX_MODE</em>. The initial value is <em>?GL_MODELVIEW</em>.</p><p>See external documentation.</p><p><strong></strong> ortho(Left, Right, Bottom, Top, Near_val, Far_val) -&gt; ok</p><p>Types:</p><p>Left = float()</p><p>Right = float()</p><p>Bottom = float()</p><p>Top = float()</p><p>Near_val = float()</p><p>Far_val = float()</p><p>Multiply the current matrix with an orthographic matrix</p><p><em>gl:ortho</em> describes a transformation that produces a parallel projection. The current matrix (see <strong>gl:matrixMode/1</strong> ) is multiplied by this matrix and the result replaces the current matrix, as if <strong>gl:multMatrixd/1</strong> were called with the following matrix as its argument:</p><p>((2/(right-left)) 0 0(t x) 0(2/(top-bottom)) 0(t y) 0 0(-2/(farVal-nearVal))(t z) 0 0 0 1)</p><p>where t x=-((right+left)/(right-left)) t y=-((top+bottom)/(top-bottom)) t z=-((farVal+nearVal)/(farVal-nearVal))</p><p>Typically, the matrix mode is <em>?GL_PROJECTION</em>, and (left bottom-nearVal) and (right top-nearVal) specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, respectively, assuming that the eye is located at (0, 0, 0). -farVal specifies the location of the far clipping plane. Both <em>NearVal</em> and <em>FarVal</em> can be either positive or negative.</p><p>Use <strong>gl:pushMatrix/0</strong> and <strong>gl:pushMatrix/0</strong> to save and restore the current matrix stack.</p><p>See external documentation.</p><p><strong></strong> frustum(Left, Right, Bottom, Top, Near_val, Far_val) -&gt; ok</p><p>Types:</p><p>Left = float()</p><p>Right = float()</p><p>Bottom = float()</p><p>Top = float()</p><p>Near_val = float()</p><p>Far_val = float()</p><p>Multiply the current matrix by a perspective matrix</p><p><em>gl:frustum</em> describes a perspective matrix that produces a perspective projection. The current matrix (see <strong>gl:matrixMode/1</strong> ) is multiplied by this matrix and the result replaces the current matrix, as if <strong>gl:multMatrixd/1</strong> were called with the following matrix as its argument:</p><p>[((2 nearVal)/(right-left)) 0 A 0 0((2 nearVal)/(top-bottom)) B 0 0 0 C D 0 0 -1 0]</p><p>A=(right+left)/(right-left)</p><p>B=(top+bottom)/(top-bottom)</p><p>C=-((farVal+nearVal)/(farVal-nearVal))</p><p>D=-((2 farVal nearVal)/(farVal-nearVal))</p><p>Typically, the matrix mode is <em>?GL_PROJECTION</em>, and (left bottom-nearVal) and (right top-nearVal) specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, assuming that the eye is located at (0, 0, 0). -farVal specifies the location of the far clipping plane. Both <em>NearVal</em> and <em>FarVal</em> must be positive.</p><p>Use <strong>gl:pushMatrix/0</strong> and <strong>gl:pushMatrix/0</strong> to save and restore the current matrix stack.</p><p>See external documentation.</p><p><strong></strong> viewport(X, Y, Width, Height) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Set the viewport</p><p><em>gl:viewport</em> specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let (x nd y nd) be normalized device coordinates. Then the window coordinates (x w y w) are computed as follows:</p><p>x w=(x nd+1) (width/2)+x</p><p>y w=(y nd+1) (height/2)+y</p><p>Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call <strong>gl:getBooleanv/1</strong> with argument <em>?GL_MAX_VIEWPORT_DIMS</em>.</p><p>See external documentation.</p><p><strong></strong> pushMatrix() -&gt; ok</p><p>Push and pop the current matrix stack</p><p>There is a stack of matrices for each of the matrix modes. In <em>?GL_MODELVIEW</em> mode, the stack depth is at least 32. In the other modes, <em>?GL_COLOR</em>, <em>?GL_PROJECTION</em> , and <em>?GL_TEXTURE</em>, the depth is at least 2. The current matrix in any mode is the matrix on the top of the stack for that mode.</p><p><em>gl:pushMatrix</em> pushes the current matrix stack down by one, duplicating the current matrix. That is, after a <em>gl:pushMatrix</em> call, the matrix on top of the stack is identical to the one below it.</p><p><strong>gl:pushMatrix/0</strong> pops the current matrix stack, replacing the current matrix with the one below it on the stack.</p><p>Initially, each of the stacks contains one matrix, an identity matrix.</p><p>It is an error to push a full matrix stack or to pop a matrix stack that contains only a single matrix. In either case, the error flag is set and no other change is made to GL state.</p><p>See external documentation.</p><p><strong></strong> popMatrix() -&gt; ok</p><p>See <strong>pushMatrix/0</strong></p><p><strong></strong> loadIdentity() -&gt; ok</p><p>Replace the current matrix with the identity matrix</p><p><em>gl:loadIdentity</em> replaces the current matrix with the identity matrix. It is semantically equivalent to calling <strong>gl:loadMatrixd/1</strong> with the identity matrix</p><p>((1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1))</p><p>but in some cases it is more efficient.</p><p>See external documentation.</p><p><strong></strong> loadMatrixd(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>Replace the current matrix with the specified matrix</p><p><em>gl:loadMatrix</em> replaces the current matrix with the one whose elements are specified by <em>M</em> . The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see <strong>gl:matrixMode/1</strong> ).</p><p>The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview matrix. If v=(v[0] v[1] v[2] v[3]) is the set of object coordinates of a vertex, and <em>M</em> points to an array of 16 single- or double-precision floating-point values m={m[0] m[1] ... m[15]}, then the modelview transformation M(v) does the following:</p><p>M(v)=(m[0] m[4] m[8] m[12] m[1] m[5] m[9] m[13] m[2] m[6] m[10] m[14] m[3] m[7] m[11] m[15])×(v[0] v[1] v[2] v[3])</p><p>Projection and texture transformations are similarly defined.</p><p>See external documentation.</p><p><strong></strong> loadMatrixf(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>See <strong>loadMatrixd/1</strong></p><p><strong></strong> multMatrixd(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>Multiply the current matrix with the specified matrix</p><p><em>gl:multMatrix</em> multiplies the current matrix with the one specified using <em>M</em> , and replaces the current matrix with the product.</p><p>The current matrix is determined by the current matrix mode (see <strong>gl:matrixMode/1</strong> ). It is either the projection matrix, modelview matrix, or the texture matrix.</p><p>See external documentation.</p><p><strong></strong> multMatrixf(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>See <strong>multMatrixd/1</strong></p><p><strong></strong> rotated(Angle, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Angle = float()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>Multiply the current matrix by a rotation matrix</p><p><em>gl:rotate</em> produces a rotation of <em>Angle</em> degrees around the vector (x y z). The current matrix (see <strong>gl:matrixMode/1</strong> ) is multiplied by a rotation matrix with the product replacing the current matrix, as if <strong>gl:multMatrixd/1</strong> were called with the following matrix as its argument:</p><p>(x 2(1-c)+c x y(1-c)-z s x z(1-c)+y s 0 y x(1-c)+z s y 2(1-c)+c y z(1-c)-x s 0 x z(1-c)-y s y z(1-c)+x s z 2(1-c)+c 0 0 0 0 1)</p><p>Where c=cos(angle), s=sin(angle), and ||(x y z)||=1 (if not, the GL will normalize this vector).</p><p>If the matrix mode is either <em>?GL_MODELVIEW</em> or <em>?GL_PROJECTION</em>, all objects drawn after <em>gl:rotate</em> is called are rotated. Use <strong>gl:pushMatrix/0</strong> and <strong>gl:pushMatrix/0</strong> to save and restore the unrotated coordinate system.</p><p>See external documentation.</p><p><strong></strong> rotatef(Angle, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Angle = float()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>rotated/4</strong></p><p><strong></strong> scaled(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>Multiply the current matrix by a general scaling matrix</p><p><em>gl:scale</em> produces a nonuniform scaling along the <em>x</em>, <em>y</em>, and <em>z</em> axes. The three parameters indicate the desired scale factor along each of the three axes.</p><p>The current matrix (see <strong>gl:matrixMode/1</strong> ) is multiplied by this scale matrix, and the product replaces the current matrix as if <strong>gl:multMatrixd/1</strong> were called with the following matrix as its argument:</p><p>(x 0 0 0 0 y 0 0 0 0 z 0 0 0 0 1)</p><p>If the matrix mode is either <em>?GL_MODELVIEW</em> or <em>?GL_PROJECTION</em>, all objects drawn after <em>gl:scale</em> is called are scaled.</p><p>Use <strong>gl:pushMatrix/0</strong> and <strong>gl:pushMatrix/0</strong> to save and restore the unscaled coordinate system.</p><p>See external documentation.</p><p><strong></strong> scalef(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>scaled/3</strong></p><p><strong></strong> translated(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>Multiply the current matrix by a translation matrix</p><p><em>gl:translate</em> produces a translation by (x y z). The current matrix (see <strong>gl:matrixMode/1</strong> ) is multiplied by this translation matrix, with the product replacing the current matrix, as if <strong>gl:multMatrixd/1</strong> were called with the following matrix for its argument:</p><p>(1 0 0 x 0 1 0 y 0 0 1 z 0 0 0 1)</p><p>If the matrix mode is either <em>?GL_MODELVIEW</em> or <em>?GL_PROJECTION</em>, all objects drawn after a call to <em>gl:translate</em> are translated.</p><p>Use <strong>gl:pushMatrix/0</strong> and <strong>gl:pushMatrix/0</strong> to save and restore the untranslated coordinate system.</p><p>See external documentation.</p><p><strong></strong> translatef(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>translated/3</strong></p><p><strong></strong> isList(List) -&gt; 0 | 1</p><p>Types:</p><p>List = integer()</p><p>Determine if a name corresponds to a display list</p><p><em>gl:isList</em> returns <em>?GL_TRUE</em> if <em>List</em> is the name of a display list and returns <em>?GL_FALSE</em> if it is not, or if an error occurs.</p><p>A name returned by <strong>gl:genLists/1</strong> , but not yet associated with a display list by calling <strong>gl:newList/2</strong> , is not the name of a display list.</p><p>See external documentation.</p><p><strong></strong> deleteLists(List, Range) -&gt; ok</p><p>Types:</p><p>List = integer()</p><p>Range = integer()</p><p>Delete a contiguous group of display lists</p><p><em>gl:deleteLists</em> causes a contiguous group of display lists to be deleted. <em>List</em> is the name of the first display list to be deleted, and <em>Range</em> is the number of display lists to delete. All display lists d with list&lt;= d&lt;= list+range-1 are deleted.</p><p>All storage locations allocated to the specified display lists are freed, and the names are available for reuse at a later time. Names within the range that do not have an associated display list are ignored. If <em>Range</em> is 0, nothing happens.</p><p>See external documentation.</p><p><strong></strong> genLists(Range) -&gt; integer()</p><p>Types:</p><p>Range = integer()</p><p>Generate a contiguous set of empty display lists</p><p><em>gl:genLists</em> has one argument, <em>Range</em> . It returns an integer <em>n</em> such that <em>Range</em> contiguous empty display lists, named n, n+1, ..., n+range-1, are created. If <em>Range</em> is 0, if there is no group of <em>Range</em> contiguous names available, or if any error is generated, no display lists are generated, and 0 is returned.</p><p>See external documentation.</p><p><strong></strong> newList(List, Mode) -&gt; ok</p><p>Types:</p><p>List = integer()</p><p>Mode = enum()</p><p>Create or replace a display list</p><p>Display lists are groups of GL commands that have been stored for subsequent execution. Display lists are created with <em>gl:newList</em>. All subsequent commands are placed in the display list, in the order issued, until <strong>gl:endList/0</strong> is called.</p><p><em>gl:newList</em> has two arguments. The first argument, <em>List</em> , is a positive integer that becomes the unique name for the display list. Names can be created and reserved with <strong>gl:genLists/1</strong> and tested for uniqueness with <strong>gl:isList/1</strong> . The second argument, <em>Mode</em> , is a symbolic constant that can assume one of two values:</p><p><em>?GL_COMPILE</em>: Commands are merely compiled.</p><p><em>?GL_COMPILE_AND_EXECUTE</em>: Commands are executed as they are compiled into the display list.</p><p>Certain commands are not compiled into the display list but are executed immediately, regardless of the display-list mode. These commands are <strong>gl:areTexturesResident/1</strong> , <strong>gl:colorPointer/4</strong> , <strong>gl:deleteLists/2</strong> , <strong>gl:deleteTextures/1</strong> , <strong>gl:enableClientState/1</strong> , <strong>gl:edgeFlagPointer/2</strong> , <strong>gl:enableClientState/1</strong> , <strong>gl:feedbackBuffer/3</strong> , <strong>gl:finish/0</strong> , <strong>gl:flush/0</strong> , <strong>gl:genLists/1</strong> , <strong>gl:genTextures/1</strong> , <strong>gl:indexPointer/3</strong> , <strong>gl:interleavedArrays/3</strong> , <strong>gl:isEnabled/1</strong> , <strong>gl:isList/1</strong> , <strong>gl:isTexture/1</strong> , <strong>gl:normalPointer/3</strong> , <strong>gl:pushClientAttrib/1</strong> , <strong>gl:pixelStoref/2</strong> , <strong>gl:pushClientAttrib/1</strong> , <strong>gl:readPixels/7</strong> , <strong>gl:renderMode/1</strong> , <strong>gl:selectBuffer/2</strong> , <strong>gl:texCoordPointer/4</strong> , <strong>gl:vertexPointer/4</strong> , and all of the <strong>gl:getBooleanv/1</strong> commands.</p><p>Similarly, <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , and <strong>gl:texImage3D/10</strong> are executed immediately and not compiled into the display list when their first argument is <em>?GL_PROXY_TEXTURE_1D</em>, <em>?GL_PROXY_TEXTURE_1D</em>, or <em>?GL_PROXY_TEXTURE_3D</em> , respectively.</p><p>When the ARB_imaging extension is supported, <strong>gl:histogram/4</strong> executes immediately when its argument is <em>?GL_PROXY_HISTOGRAM</em>. Similarly, <strong>gl:colorTable/6</strong> executes immediately when its first argument is <em>?GL_PROXY_COLOR_TABLE</em>, <em>?GL_PROXY_POST_CONVOLUTION_COLOR_TABLE</em> , or <em>?GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE</em>.</p><p>For OpenGL versions 1.3 and greater, or when the ARB_multitexture extension is supported, <strong>gl:clientActiveTexture/1</strong> is not compiled into display lists, but executed immediately.</p><p>When <strong>gl:endList/0</strong> is encountered, the display-list definition is completed by associating the list with the unique name <em>List</em> (specified in the <em>gl:newList</em> command). If a display list with name <em>List</em> already exists, it is replaced only when <strong>gl:endList/0</strong> is called.</p><p>See external documentation.</p><p><strong></strong> endList() -&gt; ok</p><p>glBeginList</p><p>See external documentation.</p><p><strong></strong> callList(List) -&gt; ok</p><p>Types:</p><p>List = integer()</p><p>Execute a display list</p><p><em>gl:callList</em> causes the named display list to be executed. The commands saved in the display list are executed in order, just as if they were called without using a display list. If <em>List</em> has not been defined as a display list, <em>gl:callList</em> is ignored.</p><p><em>gl:callList</em> can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution. This limit is at least 64, and it depends on the implementation.</p><p>GL state is not saved and restored across a call to <em>gl:callList</em>. Thus, changes made to GL state during the execution of a display list remain after execution of the display list is completed. Use <strong>gl:pushAttrib/1</strong> , <strong>gl:pushAttrib/1</strong> , <strong>gl:pushMatrix/0</strong> , and <strong>gl:pushMatrix/0</strong> to preserve GL state across <em>gl:callList</em> calls.</p><p>See external documentation.</p><p><strong></strong> callLists(Lists) -&gt; ok</p><p>Types:</p><p>Lists = [integer()]</p><p>Execute a list of display lists</p><p><em>gl:callLists</em> causes each display list in the list of names passed as <em>Lists</em> to be executed. As a result, the commands saved in each display list are executed in order, just as if they were called without using a display list. Names of display lists that have not been defined are ignored.</p><p><em>gl:callLists</em> provides an efficient means for executing more than one display list. <em>Type</em> allows lists with various name formats to be accepted. The formats are as follows:</p><p><em>?GL_BYTE</em>: <em>Lists</em> is treated as an array of signed bytes, each in the range -128 through 127.</p><p><em>?GL_UNSIGNED_BYTE</em>: <em>Lists</em> is treated as an array of unsigned bytes, each in the range 0 through 255.</p><p><em>?GL_SHORT</em>: <em>Lists</em> is treated as an array of signed two-byte integers, each in the range -32768 through 32767.</p><p><em>?GL_UNSIGNED_SHORT</em>: <em>Lists</em> is treated as an array of unsigned two-byte integers, each in the range 0 through 65535.</p><p><em>?GL_INT</em>: <em>Lists</em> is treated as an array of signed four-byte integers.</p><p><em>?GL_UNSIGNED_INT</em>: <em>Lists</em> is treated as an array of unsigned four-byte integers.</p><p><em>?GL_FLOAT</em>: <em>Lists</em> is treated as an array of four-byte floating-point values.</p><p><em>?GL_2_BYTES</em>: <em>Lists</em> is treated as an array of unsigned bytes. Each pair of bytes specifies a single display-list name. The value of the pair is computed as 256 times the unsigned value of the first byte plus the unsigned value of the second byte.</p><p><em>?GL_3_BYTES</em>: <em>Lists</em> is treated as an array of unsigned bytes. Each triplet of bytes specifies a single display-list name. The value of the triplet is computed as 65536 times the unsigned value of the first byte, plus 256 times the unsigned value of the second byte, plus the unsigned value of the third byte.</p><p><em>?GL_4_BYTES</em>: <em>Lists</em> is treated as an array of unsigned bytes. Each quadruplet of bytes specifies a single display-list name. The value of the quadruplet is computed as 16777216 times the unsigned value of the first byte, plus 65536 times the unsigned value of the second byte, plus 256 times the unsigned value of the third byte, plus the unsigned value of the fourth byte.</p><p>The list of display-list names is not null-terminated. Rather, <em>N</em> specifies how many names are to be taken from <em>Lists</em> .</p><p>An additional level of indirection is made available with the <strong>gl:listBase/1</strong> command, which specifies an unsigned offset that is added to each display-list name specified in <em>Lists</em> before that display list is executed.</p><p><em>gl:callLists</em> can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution. This limit must be at least 64, and it depends on the implementation.</p><p>GL state is not saved and restored across a call to <em>gl:callLists</em>. Thus, changes made to GL state during the execution of the display lists remain after execution is completed. Use <strong>gl:pushAttrib/1</strong> , <strong>gl:pushAttrib/1</strong> , <strong>gl:pushMatrix/0</strong> , and <strong>gl:pushMatrix/0</strong> to preserve GL state across <em>gl:callLists</em> calls.</p><p>See external documentation.</p><p><strong></strong> listBase(Base) -&gt; ok</p><p>Types:</p><p>Base = integer()</p><p>set the display-list base for</p><p><strong>gl:callLists/1</strong></p><p><strong>gl:callLists/1</strong> specifies an array of offsets. Display-list names are generated by adding <em>Base</em> to each offset. Names that reference valid display lists are executed; the others are ignored.</p><p>See external documentation.</p><p><strong></strong> begin(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Delimit the vertices of a primitive or a group of like primitives</p><p><em>gl:'begin</em>' and <strong>gl:'begin'/1</strong> delimit the vertices that define a primitive or a group of like primitives. <em>gl:'begin</em>' accepts a single argument that specifies in which of ten ways the vertices are interpreted. Taking n as an integer count starting at one, and N as the total number of vertices specified, the interpretations are as follows:</p><p><em>?GL_POINTS</em>: Treats each vertex as a single point. Vertex n defines point n. N points are drawn.</p><p><em>?GL_LINES</em>: Treats each pair of vertices as an independent line segment. Vertices 2 n-1 and 2 n define line n. N/2 lines are drawn.</p><p><em>?GL_LINE_STRIP</em>: Draws a connected group of line segments from the first vertex to the last. Vertices n and n+1 define line n. N-1 lines are drawn.</p><p><em>?GL_LINE_LOOP</em>: Draws a connected group of line segments from the first vertex to the last, then back to the first. Vertices n and n+1 define line n. The last line, however, is defined by vertices N and 1. N lines are drawn.</p><p><em>?GL_TRIANGLES</em>: Treats each triplet of vertices as an independent triangle. Vertices 3 n-2, 3 n-1, and 3 n define triangle n. N/3 triangles are drawn.</p><p><em>?GL_TRIANGLE_STRIP</em>: Draws a connected group of triangles. One triangle is defined for each vertex presented after the first two vertices. For odd n, vertices n, n+1, and n+2 define triangle n. For even n, vertices n+1, n, and n+2 define triangle n. N-2 triangles are drawn.</p><p><em>?GL_TRIANGLE_FAN</em>: Draws a connected group of triangles. One triangle is defined for each vertex presented after the first two vertices. Vertices 1, n+1, and n+2 define triangle n. N-2 triangles are drawn.</p><p><em>?GL_QUADS</em>: Treats each group of four vertices as an independent quadrilateral. Vertices 4 n-3, 4 n-2, 4 n-1, and 4 n define quadrilateral n. N/4 quadrilaterals are drawn.</p><p><em>?GL_QUAD_STRIP</em>: Draws a connected group of quadrilaterals. One quadrilateral is defined for each pair of vertices presented after the first pair. Vertices 2 n-1, 2 n, 2 n+2, and 2 n+1 define quadrilateral n. N/2-1 quadrilaterals are drawn. Note that the order in which vertices are used to construct a quadrilateral from strip data is different from that used with independent data.</p><p><em>?GL_POLYGON</em>: Draws a single, convex polygon. Vertices 1 through N define this polygon.</p><p>Only a subset of GL commands can be used between <em>gl:'begin</em>' and <strong>gl:'begin'/1</strong> . The commands are <strong>gl:vertex2d/2</strong> , <strong>gl:color3b/3</strong> , <strong>gl:secondaryColor3b/3</strong> , <strong>gl:indexd/1</strong> , <strong>gl:normal3b/3</strong> , <strong>gl:fogCoordf/1</strong> , <strong>gl:texCoord1d/1</strong> , <strong>gl:multiTexCoord1d/2</strong> , <strong>gl:vertexAttrib1d/2</strong> , <strong>gl:evalCoord1d/1</strong> , <strong>gl:evalPoint1/1</strong> , <strong>gl:arrayElement/1</strong> , <strong>gl:materialf/3</strong> , and <strong>gl:edgeFlag/1</strong> . Also, it is acceptable to use <strong>gl:callList/1</strong> or <strong>gl:callLists/1</strong> to execute display lists that include only the preceding commands. If any other GL command is executed between <em>gl:'begin</em>' and <strong>gl:'begin'/1</strong> , the error flag is set and the command is ignored.</p><p>Regardless of the value chosen for <em>Mode</em> , there is no limit to the number of vertices that can be defined between <em>gl:'begin</em>' and <strong>gl:'begin'/1</strong> . Lines, triangles, quadrilaterals, and polygons that are incompletely specified are not drawn. Incomplete specification results when either too few vertices are provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The incomplete primitive is ignored; the rest are drawn.</p><p>The minimum specification of vertices for each primitive is as follows: 1 for a point, 2 for a line, 3 for a triangle, 4 for a quadrilateral, and 3 for a polygon. Modes that require a certain multiple of vertices are <em>?GL_LINES</em> (2), <em>?GL_TRIANGLES</em> (3), <em>?GL_QUADS</em> (4), and <em>?GL_QUAD_STRIP</em> (2).</p><p>See external documentation.</p><p><strong></strong> end() -&gt; ok</p><p>See <strong>'begin'/1</strong></p><p><strong></strong> vertex2d(X, Y) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Specify a vertex</p><p><em>gl:vertex</em> commands are used within <strong>gl:'begin'/1</strong> / <strong>gl:'begin'/1</strong> pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when <em>gl:vertex</em> is called.</p><p>When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w defaults to 1.</p><p>See external documentation.</p><p><strong></strong> vertex2f(X, Y) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex2i(X, Y) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex2s(X, Y) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex3d(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex3f(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex3i(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex3s(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex4d(X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex4f(X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex4i(X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>W = integer()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex4s(X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>W = integer()</p><p>See <strong>vertex2d/2</strong></p><p><strong></strong> vertex2dv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>vertex2d(X, Y)</strong>.</p><p><strong></strong> vertex2fv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>vertex2f(X, Y)</strong>.</p><p><strong></strong> vertex2iv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>vertex2i(X, Y)</strong>.</p><p><strong></strong> vertex2sv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>vertex2s(X, Y)</strong>.</p><p><strong></strong> vertex3dv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>vertex3d(X, Y, Z)</strong>.</p><p><strong></strong> vertex3fv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>vertex3f(X, Y, Z)</strong>.</p><p><strong></strong> vertex3iv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>vertex3i(X, Y, Z)</strong>.</p><p><strong></strong> vertex3sv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>vertex3s(X, Y, Z)</strong>.</p><p><strong></strong> vertex4dv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float(), W::float()}</p><p>Equivalent to <strong>vertex4d(X, Y, Z, W)</strong>.</p><p><strong></strong> vertex4fv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float(), W::float()}</p><p>Equivalent to <strong>vertex4f(X, Y, Z, W)</strong>.</p><p><strong></strong> vertex4iv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer(), W::integer()}</p><p>Equivalent to <strong>vertex4i(X, Y, Z, W)</strong>.</p><p><strong></strong> vertex4sv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer(), W::integer()}</p><p>Equivalent to <strong>vertex4s(X, Y, Z, W)</strong>.</p><p><strong></strong> normal3b(Nx, Ny, Nz) -&gt; ok</p><p>Types:</p><p>Nx = integer()</p><p>Ny = integer()</p><p>Nz = integer()</p><p>Set the current normal vector</p><p>The current normal is set to the given coordinates whenever <em>gl:normal</em> is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to -1.0.</p><p>Normals specified with <em>gl:normal</em> need not have unit length. If <em>?GL_NORMALIZE</em> is enabled, then normals of any length specified with <em>gl:normal</em> are normalized after transformation. If <em>?GL_RESCALE_NORMAL</em> is enabled, normals are scaled by a scaling factor derived from the modelview matrix. <em>?GL_RESCALE_NORMAL</em> requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with either <em>?GL_NORMALIZE</em> or <em>?GL_RESCALE_NORMAL</em>. Normalization is initially disabled.</p><p>See external documentation.</p><p><strong></strong> normal3d(Nx, Ny, Nz) -&gt; ok</p><p>Types:</p><p>Nx = float()</p><p>Ny = float()</p><p>Nz = float()</p><p>See <strong>normal3b/3</strong></p><p><strong></strong> normal3f(Nx, Ny, Nz) -&gt; ok</p><p>Types:</p><p>Nx = float()</p><p>Ny = float()</p><p>Nz = float()</p><p>See <strong>normal3b/3</strong></p><p><strong></strong> normal3i(Nx, Ny, Nz) -&gt; ok</p><p>Types:</p><p>Nx = integer()</p><p>Ny = integer()</p><p>Nz = integer()</p><p>See <strong>normal3b/3</strong></p><p><strong></strong> normal3s(Nx, Ny, Nz) -&gt; ok</p><p>Types:</p><p>Nx = integer()</p><p>Ny = integer()</p><p>Nz = integer()</p><p>See <strong>normal3b/3</strong></p><p><strong></strong> normal3bv(V) -&gt; ok</p><p>Types:</p><p>V = {Nx::integer(), Ny::integer(), Nz::integer()}</p><p>Equivalent to <strong>normal3b(Nx, Ny, Nz)</strong>.</p><p><strong></strong> normal3dv(V) -&gt; ok</p><p>Types:</p><p>V = {Nx::float(), Ny::float(), Nz::float()}</p><p>Equivalent to <strong>normal3d(Nx, Ny, Nz)</strong>.</p><p><strong></strong> normal3fv(V) -&gt; ok</p><p>Types:</p><p>V = {Nx::float(), Ny::float(), Nz::float()}</p><p>Equivalent to <strong>normal3f(Nx, Ny, Nz)</strong>.</p><p><strong></strong> normal3iv(V) -&gt; ok</p><p>Types:</p><p>V = {Nx::integer(), Ny::integer(), Nz::integer()}</p><p>Equivalent to <strong>normal3i(Nx, Ny, Nz)</strong>.</p><p><strong></strong> normal3sv(V) -&gt; ok</p><p>Types:</p><p>V = {Nx::integer(), Ny::integer(), Nz::integer()}</p><p>Equivalent to <strong>normal3s(Nx, Ny, Nz)</strong>.</p><p><strong></strong> indexd(C) -&gt; ok</p><p>Types:</p><p>C = float()</p><p>Set the current color index</p><p><em>gl:index</em> updates the current (single-valued) color index. It takes one argument, the new value for the current color index.</p><p>The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.</p><p>Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.</p><p>See external documentation.</p><p><strong></strong> indexf(C) -&gt; ok</p><p>Types:</p><p>C = float()</p><p>See <strong>indexd/1</strong></p><p><strong></strong> indexi(C) -&gt; ok</p><p>Types:</p><p>C = integer()</p><p>See <strong>indexd/1</strong></p><p><strong></strong> indexs(C) -&gt; ok</p><p>Types:</p><p>C = integer()</p><p>See <strong>indexd/1</strong></p><p><strong></strong> indexub(C) -&gt; ok</p><p>Types:</p><p>C = integer()</p><p>See <strong>indexd/1</strong></p><p><strong></strong> indexdv(C) -&gt; ok</p><p>Types:</p><p>C = {C::float()}</p><p>Equivalent to <strong>indexd(C)</strong>.</p><p><strong></strong> indexfv(C) -&gt; ok</p><p>Types:</p><p>C = {C::float()}</p><p>Equivalent to <strong>indexf(C)</strong>.</p><p><strong></strong> indexiv(C) -&gt; ok</p><p>Types:</p><p>C = {C::integer()}</p><p>Equivalent to <strong>indexi(C)</strong>.</p><p><strong></strong> indexsv(C) -&gt; ok</p><p>Types:</p><p>C = {C::integer()}</p><p>Equivalent to <strong>indexs(C)</strong>.</p><p><strong></strong> indexubv(C) -&gt; ok</p><p>Types:</p><p>C = {C::integer()}</p><p>Equivalent to <strong>indexub(C)</strong>.</p><p><strong></strong> color3b(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>Set the current color</p><p>The GL stores both a current single-valued color index and a current four-valued RGBA color. <em>gl:color</em> sets a new four-valued RGBA color. <em>gl:color</em> has two major variants: <em>gl:color3</em> and <em>gl:color4</em>. <em>gl:color3</em> variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. <em>gl:color4</em> variants specify all four color components explicitly.</p><p><em>gl:color3b</em>, <em>gl:color4b</em>, <em>gl:color3s</em>, <em>gl:color4s</em>, <em>gl:color3i</em>, and <em>gl:color4i</em> take three or four signed byte, short, or long integers as arguments. When <em>v</em> is appended to the name, the color commands can take a pointer to an array of such values.</p><p>Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.</p><p>Neither floating-point nor signed integer values are clamped to the range [0 1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.</p><p>See external documentation.</p><p><strong></strong> color3d(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = float()</p><p>Green = float()</p><p>Blue = float()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color3f(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = float()</p><p>Green = float()</p><p>Blue = float()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color3i(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color3s(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color3ub(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color3ui(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color3us(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color4b(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>Alpha = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color4d(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = float()</p><p>Green = float()</p><p>Blue = float()</p><p>Alpha = float()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color4f(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = float()</p><p>Green = float()</p><p>Blue = float()</p><p>Alpha = float()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color4i(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>Alpha = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color4s(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>Alpha = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color4ub(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>Alpha = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color4ui(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>Alpha = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color4us(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>Alpha = integer()</p><p>See <strong>color3b/3</strong></p><p><strong></strong> color3bv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>color3b(Red, Green, Blue)</strong>.</p><p><strong></strong> color3dv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::float(), Green::float(), Blue::float()}</p><p>Equivalent to <strong>color3d(Red, Green, Blue)</strong>.</p><p><strong></strong> color3fv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::float(), Green::float(), Blue::float()}</p><p>Equivalent to <strong>color3f(Red, Green, Blue)</strong>.</p><p><strong></strong> color3iv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>color3i(Red, Green, Blue)</strong>.</p><p><strong></strong> color3sv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>color3s(Red, Green, Blue)</strong>.</p><p><strong></strong> color3ubv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>color3ub(Red, Green, Blue)</strong>.</p><p><strong></strong> color3uiv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>color3ui(Red, Green, Blue)</strong>.</p><p><strong></strong> color3usv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>color3us(Red, Green, Blue)</strong>.</p><p><strong></strong> color4bv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer(), Alpha::integer()}</p><p>Equivalent to <strong>color4b(Red, Green, Blue, Alpha)</strong>.</p><p><strong></strong> color4dv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::float(), Green::float(), Blue::float(), Alpha::float()}</p><p>Equivalent to <strong>color4d(Red, Green, Blue, Alpha)</strong>.</p><p><strong></strong> color4fv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::float(), Green::float(), Blue::float(), Alpha::float()}</p><p>Equivalent to <strong>color4f(Red, Green, Blue, Alpha)</strong>.</p><p><strong></strong> color4iv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer(), Alpha::integer()}</p><p>Equivalent to <strong>color4i(Red, Green, Blue, Alpha)</strong>.</p><p><strong></strong> color4sv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer(), Alpha::integer()}</p><p>Equivalent to <strong>color4s(Red, Green, Blue, Alpha)</strong>.</p><p><strong></strong> color4ubv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer(), Alpha::integer()}</p><p>Equivalent to <strong>color4ub(Red, Green, Blue, Alpha)</strong>.</p><p><strong></strong> color4uiv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer(), Alpha::integer()}</p><p>Equivalent to <strong>color4ui(Red, Green, Blue, Alpha)</strong>.</p><p><strong></strong> color4usv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer(), Alpha::integer()}</p><p>Equivalent to <strong>color4us(Red, Green, Blue, Alpha)</strong>.</p><p><strong></strong> texCoord1d(S) -&gt; ok</p><p>Types:</p><p>S = float()</p><p>Set the current texture coordinates</p><p><em>gl:texCoord</em> specifies texture coordinates in one, two, three, or four dimensions. <em>gl:texCoord1</em> sets the current texture coordinates to (s 0 0 1); a call to <em>gl:texCoord2</em> sets them to (s t 0 1). Similarly, <em>gl:texCoord3</em> specifies the texture coordinates as (s t r 1), and <em>gl:texCoord4</em> defines all four components explicitly as (s t r q).</p><p>The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for <em>s</em>, <em>t</em>, <em>r</em> , and <em>q</em> are (0, 0, 0, 1).</p><p>See external documentation.</p><p><strong></strong> texCoord1f(S) -&gt; ok</p><p>Types:</p><p>S = float()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord1i(S) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord1s(S) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord2d(S, T) -&gt; ok</p><p>Types:</p><p>S = float()</p><p>T = float()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord2f(S, T) -&gt; ok</p><p>Types:</p><p>S = float()</p><p>T = float()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord2i(S, T) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>T = integer()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord2s(S, T) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>T = integer()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord3d(S, T, R) -&gt; ok</p><p>Types:</p><p>S = float()</p><p>T = float()</p><p>R = float()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord3f(S, T, R) -&gt; ok</p><p>Types:</p><p>S = float()</p><p>T = float()</p><p>R = float()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord3i(S, T, R) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>T = integer()</p><p>R = integer()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord3s(S, T, R) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>T = integer()</p><p>R = integer()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord4d(S, T, R, Q) -&gt; ok</p><p>Types:</p><p>S = float()</p><p>T = float()</p><p>R = float()</p><p>Q = float()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord4f(S, T, R, Q) -&gt; ok</p><p>Types:</p><p>S = float()</p><p>T = float()</p><p>R = float()</p><p>Q = float()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord4i(S, T, R, Q) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>T = integer()</p><p>R = integer()</p><p>Q = integer()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord4s(S, T, R, Q) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>T = integer()</p><p>R = integer()</p><p>Q = integer()</p><p>See <strong>texCoord1d/1</strong></p><p><strong></strong> texCoord1dv(V) -&gt; ok</p><p>Types:</p><p>V = {S::float()}</p><p>Equivalent to <strong>texCoord1d(S)</strong>.</p><p><strong></strong> texCoord1fv(V) -&gt; ok</p><p>Types:</p><p>V = {S::float()}</p><p>Equivalent to <strong>texCoord1f(S)</strong>.</p><p><strong></strong> texCoord1iv(V) -&gt; ok</p><p>Types:</p><p>V = {S::integer()}</p><p>Equivalent to <strong>texCoord1i(S)</strong>.</p><p><strong></strong> texCoord1sv(V) -&gt; ok</p><p>Types:</p><p>V = {S::integer()}</p><p>Equivalent to <strong>texCoord1s(S)</strong>.</p><p><strong></strong> texCoord2dv(V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float()}</p><p>Equivalent to <strong>texCoord2d(S, T)</strong>.</p><p><strong></strong> texCoord2fv(V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float()}</p><p>Equivalent to <strong>texCoord2f(S, T)</strong>.</p><p><strong></strong> texCoord2iv(V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer()}</p><p>Equivalent to <strong>texCoord2i(S, T)</strong>.</p><p><strong></strong> texCoord2sv(V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer()}</p><p>Equivalent to <strong>texCoord2s(S, T)</strong>.</p><p><strong></strong> texCoord3dv(V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float(), R::float()}</p><p>Equivalent to <strong>texCoord3d(S, T, R)</strong>.</p><p><strong></strong> texCoord3fv(V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float(), R::float()}</p><p>Equivalent to <strong>texCoord3f(S, T, R)</strong>.</p><p><strong></strong> texCoord3iv(V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer(), R::integer()}</p><p>Equivalent to <strong>texCoord3i(S, T, R)</strong>.</p><p><strong></strong> texCoord3sv(V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer(), R::integer()}</p><p>Equivalent to <strong>texCoord3s(S, T, R)</strong>.</p><p><strong></strong> texCoord4dv(V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float(), R::float(), Q::float()}</p><p>Equivalent to <strong>texCoord4d(S, T, R, Q)</strong>.</p><p><strong></strong> texCoord4fv(V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float(), R::float(), Q::float()}</p><p>Equivalent to <strong>texCoord4f(S, T, R, Q)</strong>.</p><p><strong></strong> texCoord4iv(V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer(), R::integer(), Q::integer()}</p><p>Equivalent to <strong>texCoord4i(S, T, R, Q)</strong>.</p><p><strong></strong> texCoord4sv(V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer(), R::integer(), Q::integer()}</p><p>Equivalent to <strong>texCoord4s(S, T, R, Q)</strong>.</p><p><strong></strong> rasterPos2d(X, Y) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Specify the raster position for pixel operations</p><p>The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See <strong>gl:bitmap/7</strong> , <strong>gl:drawPixels/5</strong> , and <strong>gl:copyPixels/5</strong> .</p><p>The current raster position consists of three window coordinates ( x, y, z), a clip coordinate value ( w), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a clip coordinate, because w is not projected to window coordinates. <em>gl:rasterPos4</em> specifies object coordinates x, y, z, and w explicitly. <em>gl:rasterPos3</em> specifies object coordinate x, y, and z explicitly, while w is implicitly set to 1. <em>gl:rasterPos2</em> uses the argument values for x and y while implicitly setting z and w to 0 and 1.</p><p>The object coordinates presented by <em>gl:rasterPos</em> are treated just like those of a <strong>gl:vertex2d/2</strong> command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the <em>?GL_CURRENT_RASTER_POSITION_VALID</em> flag is set. If the vertex <em>is</em> culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.</p><p>The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then <em>?GL_CURRENT_RASTER_COLOR</em> (in RGBA mode) or <em>?GL_CURRENT_RASTER_INDEX</em> (in color index mode) is set to the color produced by the lighting calculation (see <strong>gl:lightf/3</strong> , <strong>gl:lightModelf/2</strong> , and <strong>gl:shadeModel/1</strong> ). If lighting is disabled, current color (in RGBA mode, state variable <em>?GL_CURRENT_COLOR</em>) or color index (in color index mode, state variable <em>?GL_CURRENT_INDEX</em>) is used to update the current raster color. <em>?GL_CURRENT_RASTER_SECONDARY_COLOR</em> (in RGBA mode) is likewise updated.</p><p>Likewise, <em>?GL_CURRENT_RASTER_TEXTURE_COORDS</em> is updated as a function of <em>?GL_CURRENT_TEXTURE_COORDS</em> , based on the texture matrix and the texture generation functions (see <strong>gl:texGend/3</strong> ). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces <em>?GL_CURRENT_RASTER_DISTANCE</em>.</p><p>Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, <em>?GL_CURRENT_RASTER_INDEX</em> is always 1; in color index mode, the current raster RGBA color always maintains its initial value.</p><p>See external documentation.</p><p><strong></strong> rasterPos2f(X, Y) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos2i(X, Y) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos2s(X, Y) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos3d(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos3f(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos3i(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos3s(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos4d(X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos4f(X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos4i(X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>W = integer()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos4s(X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>W = integer()</p><p>See <strong>rasterPos2d/2</strong></p><p><strong></strong> rasterPos2dv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>rasterPos2d(X, Y)</strong>.</p><p><strong></strong> rasterPos2fv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>rasterPos2f(X, Y)</strong>.</p><p><strong></strong> rasterPos2iv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>rasterPos2i(X, Y)</strong>.</p><p><strong></strong> rasterPos2sv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>rasterPos2s(X, Y)</strong>.</p><p><strong></strong> rasterPos3dv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>rasterPos3d(X, Y, Z)</strong>.</p><p><strong></strong> rasterPos3fv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>rasterPos3f(X, Y, Z)</strong>.</p><p><strong></strong> rasterPos3iv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>rasterPos3i(X, Y, Z)</strong>.</p><p><strong></strong> rasterPos3sv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>rasterPos3s(X, Y, Z)</strong>.</p><p><strong></strong> rasterPos4dv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float(), W::float()}</p><p>Equivalent to <strong>rasterPos4d(X, Y, Z, W)</strong>.</p><p><strong></strong> rasterPos4fv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float(), W::float()}</p><p>Equivalent to <strong>rasterPos4f(X, Y, Z, W)</strong>.</p><p><strong></strong> rasterPos4iv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer(), W::integer()}</p><p>Equivalent to <strong>rasterPos4i(X, Y, Z, W)</strong>.</p><p><strong></strong> rasterPos4sv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer(), W::integer()}</p><p>Equivalent to <strong>rasterPos4s(X, Y, Z, W)</strong>.</p><p><strong></strong> rectd(X1, Y1, X2, Y2) -&gt; ok</p><p>Types:</p><p>X1 = float()</p><p>Y1 = float()</p><p>X2 = float()</p><p>Y2 = float()</p><p>Draw a rectangle</p><p><em>gl:rect</em> supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (x y) coordinates or as two pointers to arrays, each containing an (x y) pair. The resulting rectangle is defined in the z=0 plane.</p><p><em>gl:rect</em>( <em>X1</em> , <em>Y1</em> , <em>X2</em> , <em>Y2</em> ) is exactly equivalent to the following sequence: glBegin(<em>?GL_POLYGON</em>); glVertex2( <em>X1</em> , <em>Y1</em> ); glVertex2( <em>X2</em> , <em>Y1</em> ); glVertex2( <em>X2</em> , <em>Y2</em> ); glVertex2( <em>X1</em> , <em>Y2</em> ); glEnd(); Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.</p><p>See external documentation.</p><p><strong></strong> rectf(X1, Y1, X2, Y2) -&gt; ok</p><p>Types:</p><p>X1 = float()</p><p>Y1 = float()</p><p>X2 = float()</p><p>Y2 = float()</p><p>See <strong>rectd/4</strong></p><p><strong></strong> recti(X1, Y1, X2, Y2) -&gt; ok</p><p>Types:</p><p>X1 = integer()</p><p>Y1 = integer()</p><p>X2 = integer()</p><p>Y2 = integer()</p><p>See <strong>rectd/4</strong></p><p><strong></strong> rects(X1, Y1, X2, Y2) -&gt; ok</p><p>Types:</p><p>X1 = integer()</p><p>Y1 = integer()</p><p>X2 = integer()</p><p>Y2 = integer()</p><p>See <strong>rectd/4</strong></p><p><strong></strong> rectdv(V1, V2) -&gt; ok</p><p>Types:</p><p>V1 = {float(), float()}</p><p>V2 = {float(), float()}</p><p>See <strong>rectd/4</strong></p><p><strong></strong> rectfv(V1, V2) -&gt; ok</p><p>Types:</p><p>V1 = {float(), float()}</p><p>V2 = {float(), float()}</p><p>See <strong>rectd/4</strong></p><p><strong></strong> rectiv(V1, V2) -&gt; ok</p><p>Types:</p><p>V1 = {integer(), integer()}</p><p>V2 = {integer(), integer()}</p><p>See <strong>rectd/4</strong></p><p><strong></strong> rectsv(V1, V2) -&gt; ok</p><p>Types:</p><p>V1 = {integer(), integer()}</p><p>V2 = {integer(), integer()}</p><p>See <strong>rectd/4</strong></p><p><strong></strong> vertexPointer(Size, Type, Stride, Ptr) -&gt; ok</p><p>Types:</p><p>Size = integer()</p><p>Type = enum()</p><p>Stride = integer()</p><p>Ptr = offset() | mem()</p><p>Define an array of vertex data</p><p><em>gl:vertexPointer</em> specifies the location and data format of an array of vertex coordinates to use when rendering. <em>Size</em> specifies the number of coordinates per vertex, and must be 2, 3, or 4. <em>Type</em> specifies the data type of each coordinate, and <em>Stride</em> specifies the byte stride from one vertex to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see <strong>gl:interleavedArrays/3</strong> .)</p><p>If a non-zero named buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a vertex array is specified, <em>Pointer</em> is treated as a byte offset into the buffer object's data store. Also, the buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em> ) is saved as vertex array client-side state (<em>?GL_VERTEX_ARRAY_BUFFER_BINDING</em>).</p><p>When a vertex array is specified, <em>Size</em> , <em>Type</em> , <em>Stride</em> , and <em>Pointer</em> are saved as client-side state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable the vertex array, call <strong>gl:enableClientState/1</strong> and <strong>gl:enableClientState/1</strong> with the argument <em>?GL_VERTEX_ARRAY</em>. If enabled, the vertex array is used when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em> , or <strong>gl:drawRangeElements/6</strong> is called.</p><p>See external documentation.</p><p><strong></strong> normalPointer(Type, Stride, Ptr) -&gt; ok</p><p>Types:</p><p>Type = enum()</p><p>Stride = integer()</p><p>Ptr = offset() | mem()</p><p>Define an array of normals</p><p><em>gl:normalPointer</em> specifies the location and data format of an array of normals to use when rendering. <em>Type</em> specifies the data type of each normal coordinate, and <em>Stride</em> specifies the byte stride from one normal to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see <strong>gl:interleavedArrays/3</strong> .)</p><p>If a non-zero named buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a normal array is specified, <em>Pointer</em> is treated as a byte offset into the buffer object's data store. Also, the buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em> ) is saved as normal vertex array client-side state (<em>?GL_NORMAL_ARRAY_BUFFER_BINDING</em> ).</p><p>When a normal array is specified, <em>Type</em> , <em>Stride</em> , and <em>Pointer</em> are saved as client-side state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable the normal array, call <strong>gl:enableClientState/1</strong> and <strong>gl:enableClientState/1</strong> with the argument <em>?GL_NORMAL_ARRAY</em>. If enabled, the normal array is used when <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em>, <strong>gl:drawRangeElements/6</strong> , or <strong>gl:arrayElement/1</strong> is called.</p><p>See external documentation.</p><p><strong></strong> colorPointer(Size, Type, Stride, Ptr) -&gt; ok</p><p>Types:</p><p>Size = integer()</p><p>Type = enum()</p><p>Stride = integer()</p><p>Ptr = offset() | mem()</p><p>Define an array of colors</p><p><em>gl:colorPointer</em> specifies the location and data format of an array of color components to use when rendering. <em>Size</em> specifies the number of components per color, and must be 3 or 4. <em>Type</em> specifies the data type of each color component, and <em>Stride</em> specifies the byte stride from one color to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see <strong>gl:interleavedArrays/3</strong> .)</p><p>If a non-zero named buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a color array is specified, <em>Pointer</em> is treated as a byte offset into the buffer object's data store. Also, the buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em> ) is saved as color vertex array client-side state (<em>?GL_COLOR_ARRAY_BUFFER_BINDING</em>).</p><p>When a color array is specified, <em>Size</em> , <em>Type</em> , <em>Stride</em> , and <em>Pointer</em> are saved as client-side state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable the color array, call <strong>gl:enableClientState/1</strong> and <strong>gl:enableClientState/1</strong> with the argument <em>?GL_COLOR_ARRAY</em>. If enabled, the color array is used when <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em>, <strong>gl:drawRangeElements/6</strong> , or <strong>gl:arrayElement/1</strong> is called.</p><p>See external documentation.</p><p><strong></strong> indexPointer(Type, Stride, Ptr) -&gt; ok</p><p>Types:</p><p>Type = enum()</p><p>Stride = integer()</p><p>Ptr = offset() | mem()</p><p>Define an array of color indexes</p><p><em>gl:indexPointer</em> specifies the location and data format of an array of color indexes to use when rendering. <em>Type</em> specifies the data type of each color index and <em>Stride</em> specifies the byte stride from one color index to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.</p><p>If a non-zero named buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a color index array is specified, <em>Pointer</em> is treated as a byte offset into the buffer object's data store. Also, the buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em> ) is saved as color index vertex array client-side state (<em>?GL_INDEX_ARRAY_BUFFER_BINDING</em> ).</p><p>When a color index array is specified, <em>Type</em> , <em>Stride</em> , and <em>Pointer</em> are saved as client-side state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable the color index array, call <strong>gl:enableClientState/1</strong> and <strong>gl:enableClientState/1</strong> with the argument <em>?GL_INDEX_ARRAY</em>. If enabled, the color index array is used when <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em> , <strong>gl:drawRangeElements/6</strong> , or <strong>gl:arrayElement/1</strong> is called.</p><p>See external documentation.</p><p><strong></strong> texCoordPointer(Size, Type, Stride, Ptr) -&gt; ok</p><p>Types:</p><p>Size = integer()</p><p>Type = enum()</p><p>Stride = integer()</p><p>Ptr = offset() | mem()</p><p>Define an array of texture coordinates</p><p><em>gl:texCoordPointer</em> specifies the location and data format of an array of texture coordinates to use when rendering. <em>Size</em> specifies the number of coordinates per texture coordinate set, and must be 1, 2, 3, or 4. <em>Type</em> specifies the data type of each texture coordinate, and <em>Stride</em> specifies the byte stride from one texture coordinate set to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see <strong>gl:interleavedArrays/3</strong> .)</p><p>If a non-zero named buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture coordinate array is specified, <em>Pointer</em> is treated as a byte offset into the buffer object's data store. Also, the buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em> ) is saved as texture coordinate vertex array client-side state (<em>?GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING</em> ).</p><p>When a texture coordinate array is specified, <em>Size</em> , <em>Type</em> , <em>Stride</em> , and <em>Pointer</em> are saved as client-side state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable a texture coordinate array, call <strong>gl:enableClientState/1</strong> and <strong>gl:enableClientState/1</strong> with the argument <em>?GL_TEXTURE_COORD_ARRAY</em>. If enabled, the texture coordinate array is used when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em>, or <strong>gl:drawRangeElements/6</strong> is called.</p><p>See external documentation.</p><p><strong></strong> edgeFlagPointer(Stride, Ptr) -&gt; ok</p><p>Types:</p><p>Stride = integer()</p><p>Ptr = offset() | mem()</p><p>Define an array of edge flags</p><p><em>gl:edgeFlagPointer</em> specifies the location and data format of an array of boolean edge flags to use when rendering. <em>Stride</em> specifies the byte stride from one edge flag to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.</p><p>If a non-zero named buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while an edge flag array is specified, <em>Pointer</em> is treated as a byte offset into the buffer object's data store. Also, the buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em> ) is saved as edge flag vertex array client-side state (<em>?GL_EDGE_FLAG_ARRAY_BUFFER_BINDING</em> ).</p><p>When an edge flag array is specified, <em>Stride</em> and <em>Pointer</em> are saved as client-side state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable the edge flag array, call <strong>gl:enableClientState/1</strong> and <strong>gl:enableClientState/1</strong> with the argument <em>?GL_EDGE_FLAG_ARRAY</em>. If enabled, the edge flag array is used when <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em> , <strong>gl:drawRangeElements/6</strong> , or <strong>gl:arrayElement/1</strong> is called.</p><p>See external documentation.</p><p><strong></strong> arrayElement(I) -&gt; ok</p><p>Types:</p><p>I = integer()</p><p>Render a vertex using the specified vertex array element</p><p><em>gl:arrayElement</em> commands are used within <strong>gl:'begin'/1</strong> / <strong>gl:'begin'/1</strong> pairs to specify vertex and attribute data for point, line, and polygon primitives. If <em>?GL_VERTEX_ARRAY</em> is enabled when <em>gl:arrayElement</em> is called, a single vertex is drawn, using vertex and attribute data taken from location <em>I</em> of the enabled arrays. If <em>?GL_VERTEX_ARRAY</em> is not enabled, no drawing occurs but the attributes corresponding to the enabled arrays are modified.</p><p>Use <em>gl:arrayElement</em> to construct primitives by indexing vertex data, rather than by streaming through arrays of data in first-to-last order. Because each call specifies only a single vertex, it is possible to explicitly specify per-primitive attributes such as a single normal for each triangle.</p><p>Changes made to array data between the execution of <strong>gl:'begin'/1</strong> and the corresponding execution of <strong>gl:'begin'/1</strong> may affect calls to <em>gl:arrayElement</em> that are made within the same <strong>gl:'begin'/1</strong> / <strong>gl:'begin'/1</strong> period in nonsequential ways. That is, a call to <em>gl:arrayElement</em> that precedes a change to array data may access the changed data, and a call that follows a change to array data may access original data.</p><p>See external documentation.</p><p><strong></strong> drawArrays(Mode, First, Count) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>First = integer()</p><p>Count = integer()</p><p>Render primitives from array data</p><p><em>gl:drawArrays</em> specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to <em>gl:drawArrays</em> .</p><p>When <em>gl:drawArrays</em> is called, it uses <em>Count</em> sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element <em>First</em> . <em>Mode</em> specifies what kind of primitives are constructed and how the array elements construct those primitives.</p><p>Vertex attributes that are modified by <em>gl:drawArrays</em> have an unspecified value after <em>gl:drawArrays</em> returns. Attributes that aren't modified remain well defined.</p><p>See external documentation.</p><p><strong></strong> drawElements(Mode, Count, Type, Indices) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Count = integer()</p><p>Type = enum()</p><p>Indices = offset() | mem()</p><p>Render primitives from array data</p><p><em>gl:drawElements</em> specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to <em>gl:drawElements</em> .</p><p>When <em>gl:drawElements</em> is called, it uses <em>Count</em> sequential elements from an enabled array, starting at <em>Indices</em> to construct a sequence of geometric primitives. <em>Mode</em> specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used.</p><p>Vertex attributes that are modified by <em>gl:drawElements</em> have an unspecified value after <em>gl:drawElements</em> returns. Attributes that aren't modified maintain their previous values.</p><p>See external documentation.</p><p><strong></strong> interleavedArrays(Format, Stride, Pointer) -&gt; ok</p><p>Types:</p><p>Format = enum()</p><p>Stride = integer()</p><p>Pointer = offset() | mem()</p><p>Simultaneously specify and enable several interleaved arrays</p><p><em>gl:interleavedArrays</em> lets you specify and enable individual color, normal, texture and vertex arrays whose elements are part of a larger aggregate array element. For some implementations, this is more efficient than specifying the arrays separately.</p><p>If <em>Stride</em> is 0, the aggregate elements are stored consecutively. Otherwise, <em>Stride</em> bytes occur between the beginning of one aggregate array element and the beginning of the next aggregate array element.</p><p><em>Format</em> serves as a <em>key</em> describing the extraction of individual arrays from the aggregate array. If <em>Format</em> contains a T, then texture coordinates are extracted from the interleaved array. If C is present, color values are extracted. If N is present, normal coordinates are extracted. Vertex coordinates are always extracted.</p><p>The digits 2, 3, and 4 denote how many values are extracted. F indicates that values are extracted as floating-point values. Colors may also be extracted as 4 unsigned bytes if 4UB follows the C. If a color is extracted as 4 unsigned bytes, the vertex array element which follows is located at the first possible floating-point aligned address.</p><p>See external documentation.</p><p><strong></strong> shadeModel(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Select flat or smooth shading</p><p>GL primitives can have either flat or smooth shading. Smooth shading, the default, causes the computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning different colors to each resulting pixel fragment. Flat shading selects the computed color of just one vertex and assigns it to all the pixel fragments generated by rasterizing a single primitive. In either case, the computed color of a vertex is the result of lighting if lighting is enabled, or it is the current color at the time the vertex was specified if lighting is disabled.</p><p>Flat and smooth shading are indistinguishable for points. Starting when <strong>gl:'begin'/1</strong> is issued and counting vertices and primitives from 1, the GL gives each flat-shaded line segment i the computed color of vertex i+1, its second vertex. Counting similarly from 1, the GL gives each flat-shaded polygon the computed color of the vertex listed in the following table. This is the last vertex to specify the polygon in all cases except single polygons, where the first vertex specifies the flat-shaded color.<em>Primitive Type of Polygon</em> i<em>Vertex</em></p><p> Single polygon ( i== 1) 1</p><p> Triangle strip i+2</p><p> Triangle fan i+2</p><p> Independent triangle 3 i</p><p> Quad strip 2 i+2</p><p> Independent quad 4 i</p><p>Flat and smooth shading are specified by <em>gl:shadeModel</em> with <em>Mode</em> set to <em>?GL_FLAT</em> and <em>?GL_SMOOTH</em>, respectively.</p><p>See external documentation.</p><p><strong></strong> lightf(Light, Pname, Param) -&gt; ok</p><p>Types:</p><p>Light = enum()</p><p>Pname = enum()</p><p>Param = float()</p><p>Set light source parameters</p><p><em>gl:light</em> sets the values of individual light source parameters. <em>Light</em> names the light and is a symbolic name of the form <em>?GL_LIGHT</em> i, where i ranges from 0 to the value of <em>?GL_MAX_LIGHTS</em> - 1. <em>Pname</em> specifies one of ten light source parameters, again by symbolic name. <em>Params</em> is either a single value or a pointer to an array that contains the new values.</p><p>To enable and disable lighting calculation, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_LIGHTING</em>. Lighting is initially disabled. When it is enabled, light sources that are enabled contribute to the lighting calculation. Light source i is enabled and disabled using <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_LIGHT</em> i.</p><p>The ten light parameters are as follows:</p><p><em>?GL_AMBIENT</em>: <em>Params</em> contains four integer or floating-point values that specify the ambient RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient light intensity is (0, 0, 0, 1).</p><p><em>?GL_DIFFUSE</em>: <em>Params</em> contains four integer or floating-point values that specify the diffuse RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for <em>?GL_LIGHT0</em> is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).</p><p><em>?GL_SPECULAR</em>: <em>Params</em> contains four integer or floating-point values that specify the specular RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for <em>?GL_LIGHT0</em> is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).</p><p><em>?GL_POSITION</em>: <em>Params</em> contains four integer or floating-point values that specify the position of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.</p><p>The position is transformed by the modelview matrix when <em>gl:light</em> is called (just as if it were a point), and it is stored in eye coordinates. If the w component of the position is 0, the light is treated as a directional source. Diffuse and specular lighting calculations take the light's direction, but not its actual position, into account, and attenuation is disabled. Otherwise, diffuse and specular lighting calculations are based on the actual location of the light in eye coordinates, and attenuation is enabled. The initial position is (0, 0, 1, 0); thus, the initial light source is directional, parallel to, and in the direction of the -z axis.</p><p><em>?GL_SPOT_DIRECTION</em>: <em>Params</em> contains three integer or floating-point values that specify the direction of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.</p><p>The spot direction is transformed by the upper 3x3 of the modelview matrix when <em>gl:light</em> is called, and it is stored in eye coordinates. It is significant only when <em>?GL_SPOT_CUTOFF</em> is not 180, which it is initially. The initial direction is (0 0 -1).</p><p><em>?GL_SPOT_EXPONENT</em>: <em>Params</em> is a single integer or floating-point value that specifies the intensity distribution of the light. Integer and floating-point values are mapped directly. Only values in the range [0 128] are accepted.</p><p>Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle (see <em>?GL_SPOT_CUTOFF</em>, next paragraph). The initial spot exponent is 0, resulting in uniform light distribution.</p><p><em>?GL_SPOT_CUTOFF</em>: <em>Params</em> is a single integer or floating-point value that specifies the maximum spread angle of a light source. Integer and floating-point values are mapped directly. Only values in the range [0 90] and the special value 180 are accepted. If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The initial spot cutoff is 180, resulting in uniform light distribution.</p><p><em>?GL_CONSTANT_ATTENUATION</em></p><p><em>?GL_LINEAR_ATTENUATION</em></p><p><em>?GL_QUADRATIC_ATTENUATION</em>: <em>Params</em> is a single integer or floating-point value that specifies one of the three light attenuation factors. Integer and floating-point values are mapped directly. Only nonnegative values are accepted. If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of the constant factor, the linear factor times the distance between the light and the vertex being lighted, and the quadratic factor times the square of the same distance. The initial attenuation factors are (1, 0, 0), resulting in no attenuation.</p><p>See external documentation.</p><p><strong></strong> lighti(Light, Pname, Param) -&gt; ok</p><p>Types:</p><p>Light = enum()</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>lightf/3</strong></p><p><strong></strong> lightfv(Light, Pname, Params) -&gt; ok</p><p>Types:</p><p>Light = enum()</p><p>Pname = enum()</p><p>Params = {float()}</p><p>See <strong>lightf/3</strong></p><p><strong></strong> lightiv(Light, Pname, Params) -&gt; ok</p><p>Types:</p><p>Light = enum()</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>lightf/3</strong></p><p><strong></strong> getLightfv(Light, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Light = enum()</p><p>Pname = enum()</p><p>Return light source parameter values</p><p><em>gl:getLight</em> returns in <em>Params</em> the value or values of a light source parameter. <em>Light</em> names the light and is a symbolic name of the form <em>?GL_LIGHT</em> i where i ranges from 0 to the value of <em>?GL_MAX_LIGHTS</em> - 1. <em>?GL_MAX_LIGHTS</em> is an implementation dependent constant that is greater than or equal to eight. <em>Pname</em> specifies one of ten light source parameters, again by symbolic name.</p><p>The following parameters are defined:</p><p><em>?GL_AMBIENT</em>: <em>Params</em> returns four integer or floating-point values representing the ambient intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range [-1 1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).</p><p><em>?GL_DIFFUSE</em>: <em>Params</em> returns four integer or floating-point values representing the diffuse intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range [-1 1], the corresponding integer return value is undefined. The initial value for <em>?GL_LIGHT0</em> is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 0).</p><p><em>?GL_SPECULAR</em>: <em>Params</em> returns four integer or floating-point values representing the specular intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range [-1 1], the corresponding integer return value is undefined. The initial value for <em>?GL_LIGHT0</em> is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 0).</p><p><em>?GL_POSITION</em>: <em>Params</em> returns four integer or floating-point values representing the position of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using <strong>gl:lightf/3</strong> , unless the modelview matrix was identity at the time <strong>gl:lightf/3</strong> was called. The initial value is (0, 0, 1, 0).</p><p><em>?GL_SPOT_DIRECTION</em>: <em>Params</em> returns three integer or floating-point values representing the direction of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using <strong>gl:lightf/3</strong> , unless the modelview matrix was identity at the time <strong>gl:lightf/3</strong> was called. Although spot direction is normalized before being used in the lighting equation, the returned values are the transformed versions of the specified values prior to normalization. The initial value is (0 0 -1).</p><p><em>?GL_SPOT_EXPONENT</em>: <em>Params</em> returns a single integer or floating-point value representing the spot exponent of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.</p><p><em>?GL_SPOT_CUTOFF</em>: <em>Params</em> returns a single integer or floating-point value representing the spot cutoff angle of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 180.</p><p><em>?GL_CONSTANT_ATTENUATION</em>: <em>Params</em> returns a single integer or floating-point value representing the constant (not distance-related) attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 1.</p><p><em>?GL_LINEAR_ATTENUATION</em>: <em>Params</em> returns a single integer or floating-point value representing the linear attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.</p><p><em>?GL_QUADRATIC_ATTENUATION</em>: <em>Params</em> returns a single integer or floating-point value representing the quadratic attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.</p><p>See external documentation.</p><p><strong></strong> getLightiv(Light, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Light = enum()</p><p>Pname = enum()</p><p>See <strong>getLightfv/2</strong></p><p><strong></strong> lightModelf(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = float()</p><p>Set the lighting model parameters</p><p><em>gl:lightModel</em> sets the lighting model parameter. <em>Pname</em> names a parameter and <em>Params</em> gives the new value. There are three lighting model parameters:</p><p><em>?GL_LIGHT_MODEL_AMBIENT</em>: <em>Params</em> contains four integer or floating-point values that specify the ambient RGBA intensity of the entire scene. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient scene intensity is (0.2, 0.2, 0.2, 1.0).</p><p><em>?GL_LIGHT_MODEL_COLOR_CONTROL</em>: <em>Params</em> must be either <em>?GL_SEPARATE_SPECULAR_COLOR</em> or <em>?GL_SINGLE_COLOR</em>. <em>?GL_SINGLE_COLOR</em> specifies that a single color is generated from the lighting computation for a vertex. <em>?GL_SEPARATE_SPECULAR_COLOR</em> specifies that the specular color computation of lighting be stored separately from the remainder of the lighting computation. The specular color is summed into the generated fragment's color after the application of texture mapping (if enabled). The initial value is <em>?GL_SINGLE_COLOR</em>.</p><p><em>?GL_LIGHT_MODEL_LOCAL_VIEWER</em>: <em>Params</em> is a single integer or floating-point value that specifies how specular reflection angles are computed. If <em>Params</em> is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -<em>z</em> axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The initial value is 0.</p><p><em>?GL_LIGHT_MODEL_TWO_SIDE</em>: <em>Params</em> is a single integer or floating-point value that specifies whether one- or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If <em>Params</em> is 0 (or 0.0), one-sided lighting is specified, and only the <em>front</em> material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. In this case, vertices of back-facing polygons are lighted using the <em>back</em> material parameters and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the <em>front</em> material parameters, with no change to their normals. The initial value is 0.</p><p>In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular. The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source. The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material. All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they evaluate to a negative value.</p><p>The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.</p><p>In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to <strong>gl:materialf/3</strong> using <em>?GL_COLOR_INDEXES</em>. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.</p><p>See external documentation.</p><p><strong></strong> lightModeli(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>lightModelf/2</strong></p><p><strong></strong> lightModelfv(Pname, Params) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Params = {float()}</p><p>See <strong>lightModelf/2</strong></p><p><strong></strong> lightModeliv(Pname, Params) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>lightModelf/2</strong></p><p><strong></strong> materialf(Face, Pname, Param) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Pname = enum()</p><p>Param = float()</p><p>Specify material parameters for the lighting model</p><p><em>gl:material</em> assigns values to material parameters. There are two matched sets of material parameters. One, the <em>front-facing</em> set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, <em>back-facing</em>, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the <strong>gl:lightModelf/2</strong> reference page for details concerning one- and two-sided lighting calculations.</p><p><em>gl:material</em> takes three arguments. The first, <em>Face</em> , specifies whether the <em>?GL_FRONT</em> materials, the <em>?GL_BACK</em> materials, or both <em>?GL_FRONT_AND_BACK</em> materials will be modified. The second, <em>Pname</em> , specifies which of several parameters in one or both sets will be modified. The third, <em>Params</em> , specifies what value or values will be assigned to the specified parameter.</p><p>Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in the <strong>gl:lightModelf/2</strong> reference page. The parameters that can be specified using <em>gl:material</em>, and their interpretations by the lighting equation, are as follows:</p><p><em>?GL_AMBIENT</em>: <em>Params</em> contains four integer or floating-point values that specify the ambient RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient reflectance for both front- and back-facing materials is (0.2, 0.2, 0.2, 1.0).</p><p><em>?GL_DIFFUSE</em>: <em>Params</em> contains four integer or floating-point values that specify the diffuse RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial diffuse reflectance for both front- and back-facing materials is (0.8, 0.8, 0.8, 1.0).</p><p><em>?GL_SPECULAR</em>: <em>Params</em> contains four integer or floating-point values that specify the specular RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial specular reflectance for both front- and back-facing materials is (0, 0, 0, 1).</p><p><em>?GL_EMISSION</em>: <em>Params</em> contains four integer or floating-point values that specify the RGBA emitted light intensity of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial emission intensity for both front- and back-facing materials is (0, 0, 0, 1).</p><p><em>?GL_SHININESS</em>: <em>Params</em> is a single integer or floating-point value that specifies the RGBA specular exponent of the material. Integer and floating-point values are mapped directly. Only values in the range [0 128] are accepted. The initial specular exponent for both front- and back-facing materials is 0.</p><p><em>?GL_AMBIENT_AND_DIFFUSE</em>: Equivalent to calling <em>gl:material</em> twice with the same parameter values, once with <em>?GL_AMBIENT</em> and once with <em>?GL_DIFFUSE</em>.</p><p><em>?GL_COLOR_INDEXES</em>: <em>Params</em> contains three integer or floating-point values specifying the color indices for ambient, diffuse, and specular lighting. These three values, and <em>?GL_SHININESS</em>, are the only material values used by the color index mode lighting equation. Refer to the <strong>gl:lightModelf/2</strong> reference page for a discussion of color index lighting.</p><p>See external documentation.</p><p><strong></strong> materiali(Face, Pname, Param) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>materialf/3</strong></p><p><strong></strong> materialfv(Face, Pname, Params) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Pname = enum()</p><p>Params = {float()}</p><p>See <strong>materialf/3</strong></p><p><strong></strong> materialiv(Face, Pname, Params) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>materialf/3</strong></p><p><strong></strong> getMaterialfv(Face, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Face = enum()</p><p>Pname = enum()</p><p>Return material parameters</p><p><em>gl:getMaterial</em> returns in <em>Params</em> the value or values of parameter <em>Pname</em> of material <em>Face</em> . Six parameters are defined:</p><p><em>?GL_AMBIENT</em>: <em>Params</em> returns four integer or floating-point values representing the ambient reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range [-1 1], the corresponding integer return value is undefined. The initial value is (0.2, 0.2, 0.2, 1.0)</p><p><em>?GL_DIFFUSE</em>: <em>Params</em> returns four integer or floating-point values representing the diffuse reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range [-1 1], the corresponding integer return value is undefined. The initial value is (0.8, 0.8, 0.8, 1.0).</p><p><em>?GL_SPECULAR</em>: <em>Params</em> returns four integer or floating-point values representing the specular reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range [-1 1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).</p><p><em>?GL_EMISSION</em>: <em>Params</em> returns four integer or floating-point values representing the emitted light intensity of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range [-1 1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).</p><p><em>?GL_SHININESS</em>: <em>Params</em> returns one integer or floating-point value representing the specular exponent of the material. Integer values, when requested, are computed by rounding the internal floating-point value to the nearest integer value. The initial value is 0.</p><p><em>?GL_COLOR_INDEXES</em>: <em>Params</em> returns three integer or floating-point values representing the ambient, diffuse, and specular indices of the material. These indices are used only for color index lighting. (All the other parameters are used only for RGBA lighting.) Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.</p><p>See external documentation.</p><p><strong></strong> getMaterialiv(Face, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Face = enum()</p><p>Pname = enum()</p><p>See <strong>getMaterialfv/2</strong></p><p><strong></strong> colorMaterial(Face, Mode) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Mode = enum()</p><p>Cause a material color to track the current color</p><p><em>gl:colorMaterial</em> specifies which material parameters track the current color. When <em>?GL_COLOR_MATERIAL</em> is enabled, the material parameter or parameters specified by <em>Mode</em> , of the material or materials specified by <em>Face</em> , track the current color at all times.</p><p>To enable and disable <em>?GL_COLOR_MATERIAL</em>, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_COLOR_MATERIAL</em>. <em>?GL_COLOR_MATERIAL</em> is initially disabled.</p><p>See external documentation.</p><p><strong></strong> pixelZoom(Xfactor, Yfactor) -&gt; ok</p><p>Types:</p><p>Xfactor = float()</p><p>Yfactor = float()</p><p>Specify the pixel zoom factors</p><p><em>gl:pixelZoom</em> specifies values for the x and y zoom factors. During the execution of <strong>gl:drawPixels/5</strong> or <strong>gl:copyPixels/5</strong> , if ( xr, yr) is the current raster position, and a given element is in the mth row and nth column of the pixel rectangle, then pixels whose centers are in the rectangle with corners at</p><p>( xr+n. xfactor, yr+m. yfactor)</p><p>( xr+(n+1). xfactor, yr+(m+1). yfactor)</p><p>are candidates for replacement. Any pixel whose center lies on the bottom or left edge of this rectangular region is also modified.</p><p>Pixel zoom factors are not limited to positive values. Negative zoom factors reflect the resulting image about the current raster position.</p><p>See external documentation.</p><p><strong></strong> pixelStoref(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = float()</p><p>Set pixel storage modes</p><p><em>gl:pixelStore</em> sets pixel storage modes that affect the operation of subsequent <strong>gl:readPixels/7</strong> as well as the unpacking of texture patterns (see <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> ), <strong>gl:compressedTexImage1D/7</strong> , <strong>gl:compressedTexImage2D/8</strong> , <strong>gl:compressedTexImage3D/9</strong> , <strong>gl:compressedTexSubImage1D/7</strong> , <strong>gl:compressedTexSubImage2D/9</strong> or <strong>gl:compressedTexSubImage1D/7</strong> .</p><p><em>Pname</em> is a symbolic constant indicating the parameter to be set, and <em>Param</em> is the new value. Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows:</p><p><em>?GL_PACK_SWAP_BYTES</em>: If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes b 0, b 1, b 2, b 3, it is stored in memory as b 3, b 2, b 1, b 0 if <em>?GL_PACK_SWAP_BYTES</em> is true. <em>?GL_PACK_SWAP_BYTES</em> has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a <em>?GL_RGB</em> format pixel are always stored with red first, green second, and blue third, regardless of the value of <em>?GL_PACK_SWAP_BYTES</em>.</p><p><em>?GL_PACK_LSB_FIRST</em>: If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.</p><p><em>?GL_PACK_ROW_LENGTH</em>: If greater than 0, <em>?GL_PACK_ROW_LENGTH</em> defines the number of pixels in a row. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping</p><p>k={n l(a/s) |(s n l)/a| s&gt;= a s&lt; a)</p><p>components or indices, where n is the number of components or indices in a pixel, l is the number of pixels in a row (<em>?GL_PACK_ROW_LENGTH</em> if it is greater than 0, the width argument to the pixel routine otherwise), a is the value of <em>?GL_PACK_ALIGNMENT</em> , and s is the size, in bytes, of a single component (if a&lt; s, then it is as if a= s). In the case of 1-bit values, the location of the next row is obtained by skipping</p><p>k=8 a |(n l)/(8 a)|</p><p>components or indices.</p><p>The word <em>component</em> in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format <em>?GL_RGB</em>, for example, has three components per pixel: first red, then green, and finally blue.</p><p><em>?GL_PACK_IMAGE_HEIGHT</em>: If greater than 0, <em>?GL_PACK_IMAGE_HEIGHT</em> defines the number of pixels in an image three-dimensional texture volume, where <em>image</em> is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping</p><p>k={n l h(a/s) |(s n l h)/a| s&gt;= a s&lt; a)</p><p>components or indices, where n is the number of components or indices in a pixel, l is the number of pixels in a row (<em>?GL_PACK_ROW_LENGTH</em> if it is greater than 0, the width argument to <strong>gl:texImage3D/10</strong> otherwise), h is the number of rows in a pixel image (<em>?GL_PACK_IMAGE_HEIGHT</em> if it is greater than 0, the height argument to the <strong>gl:texImage3D/10</strong> routine otherwise), a is the value of <em>?GL_PACK_ALIGNMENT</em> , and s is the size, in bytes, of a single component (if a&lt; s, then it is as if a=s).</p><p>The word <em>component</em> in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format <em>?GL_RGB</em>, for example, has three components per pixel: first red, then green, and finally blue.</p><p><em>?GL_PACK_SKIP_PIXELS</em>, <em>?GL_PACK_SKIP_ROWS</em>, and <em>?GL_PACK_SKIP_IMAGES</em></p><p>These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to <strong>gl:readPixels/7</strong> . Setting <em>?GL_PACK_SKIP_PIXELS</em> to i is equivalent to incrementing the pointer by i n components or indices, where n is the number of components or indices in each pixel. Setting <em>?GL_PACK_SKIP_ROWS</em> to j is equivalent to incrementing the pointer by j m components or indices, where m is the number of components or indices per row, as just computed in the <em>?GL_PACK_ROW_LENGTH</em> section. Setting <em>?GL_PACK_SKIP_IMAGES</em> to k is equivalent to incrementing the pointer by k p, where p is the number of components or indices per image, as computed in the <em>?GL_PACK_IMAGE_HEIGHT</em> section.</p><p><em>?GL_PACK_ALIGNMENT</em>: Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).</p><p>The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> , and <strong>gl:texSubImage1D/7</strong></p><p>They are as follows:</p><p><em>?GL_UNPACK_SWAP_BYTES</em>: If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes b 0, b 1, b 2, b 3, it is taken from memory as b 3, b 2, b 1, b 0 if <em>?GL_UNPACK_SWAP_BYTES</em> is true. <em>?GL_UNPACK_SWAP_BYTES</em> has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a <em>?GL_RGB</em> format pixel are always stored with red first, green second, and blue third, regardless of the value of <em>?GL_UNPACK_SWAP_BYTES</em>.</p><p><em>?GL_UNPACK_LSB_FIRST</em>: If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.</p><p><em>?GL_UNPACK_ROW_LENGTH</em>: If greater than 0, <em>?GL_UNPACK_ROW_LENGTH</em> defines the number of pixels in a row. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping</p><p>k={n l(a/s) |(s n l)/a| s&gt;= a s&lt; a)</p><p>components or indices, where n is the number of components or indices in a pixel, l is the number of pixels in a row (<em>?GL_UNPACK_ROW_LENGTH</em> if it is greater than 0, the width argument to the pixel routine otherwise), a is the value of <em>?GL_UNPACK_ALIGNMENT</em> , and s is the size, in bytes, of a single component (if a&lt; s, then it is as if a= s). In the case of 1-bit values, the location of the next row is obtained by skipping</p><p>k=8 a |(n l)/(8 a)|</p><p>components or indices.</p><p>The word <em>component</em> in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format <em>?GL_RGB</em>, for example, has three components per pixel: first red, then green, and finally blue.</p><p><em>?GL_UNPACK_IMAGE_HEIGHT</em>: If greater than 0, <em>?GL_UNPACK_IMAGE_HEIGHT</em> defines the number of pixels in an image of a three-dimensional texture volume. Where <em>image</em> is defined by all pixel sharing the same third dimension index. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping</p><p>k={n l h(a/s) |(s n l h)/a| s&gt;= a s&lt; a)</p><p>components or indices, where n is the number of components or indices in a pixel, l is the number of pixels in a row (<em>?GL_UNPACK_ROW_LENGTH</em> if it is greater than 0, the width argument to <strong>gl:texImage3D/10</strong> otherwise), h is the number of rows in an image (<em>?GL_UNPACK_IMAGE_HEIGHT</em> if it is greater than 0, the height argument to <strong>gl:texImage3D/10</strong> otherwise), a is the value of <em>?GL_UNPACK_ALIGNMENT</em>, and s is the size, in bytes, of a single component (if a&lt; s, then it is as if a=s).</p><p>The word <em>component</em> in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format <em>?GL_RGB</em>, for example, has three components per pixel: first red, then green, and finally blue.</p><p><em>?GL_UNPACK_SKIP_PIXELS</em> and <em>?GL_UNPACK_SKIP_ROWS</em></p><p>These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated by incrementing the pointer passed to <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texSubImage1D/7</strong> or <strong>gl:texSubImage1D/7</strong> . Setting <em>?GL_UNPACK_SKIP_PIXELS</em> to i is equivalent to incrementing the pointer by i n components or indices, where n is the number of components or indices in each pixel. Setting <em>?GL_UNPACK_SKIP_ROWS</em> to j is equivalent to incrementing the pointer by j k components or indices, where k is the number of components or indices per row, as just computed in the <em>?GL_UNPACK_ROW_LENGTH</em> section.</p><p><em>?GL_UNPACK_ALIGNMENT</em>: Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).</p><p>The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with <em>gl:pixelStore</em>.<em>Pname</em><em>Type</em><em>Initial Value</em><em>Valid Range</em></p><p><em>?GL_PACK_SWAP_BYTES</em> boolean false true or false</p><p><em>?GL_PACK_LSB_FIRST</em> boolean false true or false</p><p><em>?GL_PACK_ROW_LENGTH</em> integer 0 [0)</p><p><em>?GL_PACK_IMAGE_HEIGHT</em> integer 0 [0)</p><p><em>?GL_PACK_SKIP_ROWS</em> integer 0 [0)</p><p><em>?GL_PACK_SKIP_PIXELS</em> integer 0 [0)</p><p><em>?GL_PACK_SKIP_IMAGES</em> integer 0 [0)</p><p><em>?GL_PACK_ALIGNMENT</em> integer 4 1, 2, 4, or 8</p><p><em>?GL_UNPACK_SWAP_BYTES</em> boolean false true or false</p><p><em>?GL_UNPACK_LSB_FIRST</em> boolean false true or false</p><p><em>?GL_UNPACK_ROW_LENGTH</em> integer 0 [0)</p><p><em>?GL_UNPACK_IMAGE_HEIGHT</em> integer 0 [0)</p><p><em>?GL_UNPACK_SKIP_ROWS</em> integer 0 [0)</p><p><em>?GL_UNPACK_SKIP_PIXELS</em> integer 0 [0)</p><p><em>?GL_UNPACK_SKIP_IMAGES</em> integer 0 [0)</p><p><em>?GL_UNPACK_ALIGNMENT</em> integer 4 1, 2, 4, or 8</p><p><em>gl:pixelStoref</em> can be used to set any pixel store parameter. If the parameter type is boolean, then if <em>Param</em> is 0, the parameter is false; otherwise it is set to true. If <em>Pname</em> is a integer type parameter, <em>Param</em> is rounded to the nearest integer.</p><p>Likewise, <em>gl:pixelStorei</em> can also be used to set any of the pixel store parameters. Boolean parameters are set to false if <em>Param</em> is 0 and true otherwise.</p><p>See external documentation.</p><p><strong></strong> pixelStorei(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>pixelStoref/2</strong></p><p><strong></strong> pixelTransferf(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = float()</p><p>Set pixel transfer modes</p><p><em>gl:pixelTransfer</em> sets pixel transfer modes that affect the operation of subsequent <strong>gl:copyPixels/5</strong> , <strong>gl:copyTexImage1D/7</strong> , <strong>gl:copyTexImage2D/8</strong> , <strong>gl:copyTexSubImage1D/6</strong> , <strong>gl:copyTexSubImage2D/8</strong> , <strong>gl:copyTexSubImage3D/9</strong> , <strong>gl:drawPixels/5</strong> , <strong>gl:readPixels/7</strong> , <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> , and <strong>gl:texSubImage1D/7</strong> commands. Additionally, if the ARB_imaging subset is supported, the routines <strong>gl:colorTable/6</strong> , <strong>gl:colorSubTable/6</strong> , <strong>gl:convolutionFilter1D/6</strong> , <strong>gl:convolutionFilter2D/7</strong> , <strong>gl:histogram/4</strong> , <strong>gl:minmax/3</strong> , and <strong>gl:separableFilter2D/8</strong> are also affected. The algorithms that are specified by pixel transfer modes operate on pixels after they are read from the frame buffer ( <strong>gl:copyPixels/5</strong> <strong>gl:copyTexImage1D/7</strong> , <strong>gl:copyTexImage2D/8</strong> , <strong>gl:copyTexSubImage1D/6</strong> , <strong>gl:copyTexSubImage2D/8</strong> , <strong>gl:copyTexSubImage3D/9</strong> , and <strong>gl:readPixels/7</strong> ), or unpacked from client memory ( <strong>gl:drawPixels/5</strong> , <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> , and <strong>gl:texSubImage1D/7</strong> ). Pixel transfer operations happen in the same order, and in the same manner, regardless of the command that resulted in the pixel operation. Pixel storage modes (see <strong>gl:pixelStoref/2</strong> ) control the unpacking of pixels being read from client memory and the packing of pixels being written back into client memory.</p><p>Pixel transfer operations handle four fundamental pixel types: <em>color</em>, <em>color index</em> , <em>depth</em>, and <em>stencil</em>. <em>Color</em> pixels consist of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0 represents zero intensity and 1 represents full intensity. <em>Color indices</em> comprise a single fixed-point value, with unspecified precision to the right of the binary point. <em>Depth</em> pixels comprise a single floating-point value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer value, and 1.0 represents the maximum depth buffer value. Finally, <em>stencil</em> pixels comprise a single fixed-point value, with unspecified precision to the right of the binary point.</p><p>The pixel transfer operations performed on the four basic pixel types are as follows:</p><p><em>Color</em>: Each of the four color components is multiplied by a scale factor, then added to a bias factor. That is, the red component is multiplied by <em>?GL_RED_SCALE</em>, then added to <em>?GL_RED_BIAS</em>; the green component is multiplied by <em>?GL_GREEN_SCALE</em> , then added to <em>?GL_GREEN_BIAS</em>; the blue component is multiplied by <em>?GL_BLUE_SCALE</em> , then added to <em>?GL_BLUE_BIAS</em>; and the alpha component is multiplied by <em>?GL_ALPHA_SCALE</em> , then added to <em>?GL_ALPHA_BIAS</em>. After all four color components are scaled and biased, each is clamped to the range [0 1]. All color, scale, and bias values are specified with <em>gl:pixelTransfer</em>.</p><p>If <em>?GL_MAP_COLOR</em> is true, each color component is scaled by the size of the corresponding color-to-color map, then replaced by the contents of that map indexed by the scaled component. That is, the red component is scaled by <em>?GL_PIXEL_MAP_R_TO_R_SIZE</em>, then replaced by the contents of <em>?GL_PIXEL_MAP_R_TO_R</em> indexed by itself. The green component is scaled by <em>?GL_PIXEL_MAP_G_TO_G_SIZE</em>, then replaced by the contents of <em>?GL_PIXEL_MAP_G_TO_G</em> indexed by itself. The blue component is scaled by <em>?GL_PIXEL_MAP_B_TO_B_SIZE</em>, then replaced by the contents of <em>?GL_PIXEL_MAP_B_TO_B</em> indexed by itself. And the alpha component is scaled by <em>?GL_PIXEL_MAP_A_TO_A_SIZE</em>, then replaced by the contents of <em>?GL_PIXEL_MAP_A_TO_A</em> indexed by itself. All components taken from the maps are then clamped to the range [0 1]. <em>?GL_MAP_COLOR</em> is specified with <em>gl:pixelTransfer</em>. The contents of the various maps are specified with <strong>gl:pixelMapfv/3</strong> .</p><p>If the ARB_imaging extension is supported, each of the four color components may be scaled and biased after transformation by the color matrix. That is, the red component is multiplied by <em>?GL_POST_COLOR_MATRIX_RED_SCALE</em>, then added to <em>?GL_POST_COLOR_MATRIX_RED_BIAS</em> ; the green component is multiplied by <em>?GL_POST_COLOR_MATRIX_GREEN_SCALE</em>, then added to <em>?GL_POST_COLOR_MATRIX_GREEN_BIAS</em>; the blue component is multiplied by <em>?GL_POST_COLOR_MATRIX_BLUE_SCALE</em> , then added to <em>?GL_POST_COLOR_MATRIX_BLUE_BIAS</em>; and the alpha component is multiplied by <em>?GL_POST_COLOR_MATRIX_ALPHA_SCALE</em>, then added to <em>?GL_POST_COLOR_MATRIX_ALPHA_BIAS</em> . After all four color components are scaled and biased, each is clamped to the range [0 1].</p><p>Similarly, if the ARB_imaging extension is supported, each of the four color components may be scaled and biased after processing by the enabled convolution filter. That is, the red component is multiplied by <em>?GL_POST_CONVOLUTION_RED_SCALE</em>, then added to <em>?GL_POST_CONVOLUTION_RED_BIAS</em> ; the green component is multiplied by <em>?GL_POST_CONVOLUTION_GREEN_SCALE</em>, then added to <em>?GL_POST_CONVOLUTION_GREEN_BIAS</em>; the blue component is multiplied by <em>?GL_POST_CONVOLUTION_BLUE_SCALE</em> , then added to <em>?GL_POST_CONVOLUTION_BLUE_BIAS</em>; and the alpha component is multiplied by <em>?GL_POST_CONVOLUTION_ALPHA_SCALE</em>, then added to <em>?GL_POST_CONVOLUTION_ALPHA_BIAS</em> . After all four color components are scaled and biased, each is clamped to the range [0 1].</p><p><em>Color index</em>: Each color index is shifted left by <em>?GL_INDEX_SHIFT</em> bits; any bits beyond the number of fraction bits carried by the fixed-point index are filled with zeros. If <em>?GL_INDEX_SHIFT</em> is negative, the shift is to the right, again zero filled. Then <em>?GL_INDEX_OFFSET</em> is added to the index. <em>?GL_INDEX_SHIFT</em> and <em>?GL_INDEX_OFFSET</em> are specified with <em>gl:pixelTransfer</em>.</p><p>From this point, operation diverges depending on the required format of the resulting pixels. If the resulting pixels are to be written to a color index buffer, or if they are being read back to client memory in <em>?GL_COLOR_INDEX</em> format, the pixels continue to be treated as indices. If <em>?GL_MAP_COLOR</em> is true, each index is masked by 2 n-1 , where n is <em>?GL_PIXEL_MAP_I_TO_I_SIZE</em>, then replaced by the contents of <em>?GL_PIXEL_MAP_I_TO_I</em> indexed by the masked value. <em>?GL_MAP_COLOR</em> is specified with <em>gl:pixelTransfer</em> . The contents of the index map is specified with <strong>gl:pixelMapfv/3</strong> .</p><p>If the resulting pixels are to be written to an RGBA color buffer, or if they are read back to client memory in a format other than <em>?GL_COLOR_INDEX</em>, the pixels are converted from indices to colors by referencing the four maps <em>?GL_PIXEL_MAP_I_TO_R</em>, <em>?GL_PIXEL_MAP_I_TO_G</em> , <em>?GL_PIXEL_MAP_I_TO_B</em>, and <em>?GL_PIXEL_MAP_I_TO_A</em>. Before being dereferenced, the index is masked by 2 n-1, where n is <em>?GL_PIXEL_MAP_I_TO_R_SIZE</em> for the red map, <em>?GL_PIXEL_MAP_I_TO_G_SIZE</em> for the green map, <em>?GL_PIXEL_MAP_I_TO_B_SIZE</em> for the blue map, and <em>?GL_PIXEL_MAP_I_TO_A_SIZE</em> for the alpha map. All components taken from the maps are then clamped to the range [0 1]. The contents of the four maps is specified with <strong>gl:pixelMapfv/3</strong> .</p><p><em>Depth</em>: Each depth value is multiplied by <em>?GL_DEPTH_SCALE</em>, added to <em>?GL_DEPTH_BIAS</em> , then clamped to the range [0 1].</p><p><em>Stencil</em>: Each index is shifted <em>?GL_INDEX_SHIFT</em> bits just as a color index is, then added to <em>?GL_INDEX_OFFSET</em>. If <em>?GL_MAP_STENCIL</em> is true, each index is masked by 2 n-1, where n is <em>?GL_PIXEL_MAP_S_TO_S_SIZE</em>, then replaced by the contents of <em>?GL_PIXEL_MAP_S_TO_S</em> indexed by the masked value.</p><p>The following table gives the type, initial value, and range of valid values for each of the pixel transfer parameters that are set with <em>gl:pixelTransfer</em>.<em>Pname</em><em>Type</em><em>Initial Value</em><em>Valid Range</em></p><p><em>?GL_MAP_COLOR</em> boolean false true/false</p><p><em>?GL_MAP_STENCIL</em> boolean false true/false</p><p><em>?GL_INDEX_SHIFT</em> integer 0 (-)</p><p><em>?GL_INDEX_OFFSET</em> integer 0 (-)</p><p><em>?GL_RED_SCALE</em> float 1 (-)</p><p><em>?GL_GREEN_SCALE</em> float 1 (-)</p><p><em>?GL_BLUE_SCALE</em> float 1 (-)</p><p><em>?GL_ALPHA_SCALE</em> float 1 (-)</p><p><em>?GL_DEPTH_SCALE</em> float 1 (-)</p><p><em>?GL_RED_BIAS</em> float 0 (-)</p><p><em>?GL_GREEN_BIAS</em> float 0 (-)</p><p><em>?GL_BLUE_BIAS</em> float 0 (-)</p><p><em>?GL_ALPHA_BIAS</em> float 0 (-)</p><p><em>?GL_DEPTH_BIAS</em> float 0 (-)</p><p><em>?GL_POST_COLOR_MATRIX_RED_SCALE</em> float 1 (-)</p><p><em>?GL_POST_COLOR_MATRIX_GREEN_SCALE</em> float 1 (-)</p><p><em>?GL_POST_COLOR_MATRIX_BLUE_SCALE</em> float 1 (-)</p><p><em>?GL_POST_COLOR_MATRIX_ALPHA_SCALE</em> float 1 (-)</p><p><em>?GL_POST_COLOR_MATRIX_RED_BIAS</em> float 0 (-)</p><p><em>?GL_POST_COLOR_MATRIX_GREEN_BIAS</em> float 0 (-)</p><p><em>?GL_POST_COLOR_MATRIX_BLUE_BIAS</em> float 0 (-)</p><p><em>?GL_POST_COLOR_MATRIX_ALPHA_BIAS</em> float 0 (-)</p><p><em>?GL_POST_CONVOLUTION_RED_SCALE</em> float 1 (-)</p><p><em>?GL_POST_CONVOLUTION_GREEN_SCALE</em> float 1 (-)</p><p><em>?GL_POST_CONVOLUTION_BLUE_SCALE</em> float 1 (-)</p><p><em>?GL_POST_CONVOLUTION_ALPHA_SCALE</em> float 1 (-)</p><p><em>?GL_POST_CONVOLUTION_RED_BIAS</em> float 0 (-)</p><p><em>?GL_POST_CONVOLUTION_GREEN_BIAS</em> float 0 (-)</p><p><em>?GL_POST_CONVOLUTION_BLUE_BIAS</em> float 0 (-)</p><p><em>?GL_POST_CONVOLUTION_ALPHA_BIAS</em> float 0 (-)</p><p><em>gl:pixelTransferf</em> can be used to set any pixel transfer parameter. If the parameter type is boolean, 0 implies false and any other value implies true. If <em>Pname</em> is an integer parameter, <em>Param</em> is rounded to the nearest integer.</p><p>Likewise, <em>gl:pixelTransferi</em> can be used to set any of the pixel transfer parameters. Boolean parameters are set to false if <em>Param</em> is 0 and to true otherwise. <em>Param</em> is converted to floating point before being assigned to real-valued parameters.</p><p>See external documentation.</p><p><strong></strong> pixelTransferi(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>pixelTransferf/2</strong></p><p><strong></strong> pixelMapfv(Map, Mapsize, Values) -&gt; ok</p><p>Types:</p><p>Map = enum()</p><p>Mapsize = integer()</p><p>Values = binary()</p><p>Set up pixel transfer maps</p><p><em>gl:pixelMap</em> sets up translation tables, or <em>maps</em>, used by <strong>gl:copyPixels/5</strong> , <strong>gl:copyTexImage1D/7</strong> , <strong>gl:copyTexImage2D/8</strong> , <strong>gl:copyTexSubImage1D/6</strong> , <strong>gl:copyTexSubImage2D/8</strong> , <strong>gl:copyTexSubImage3D/9</strong> , <strong>gl:drawPixels/5</strong> , <strong>gl:readPixels/7</strong> , <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> , and <strong>gl:texSubImage1D/7</strong> . Additionally, if the ARB_imaging subset is supported, the routines <strong>gl:colorTable/6</strong> , <strong>gl:colorSubTable/6</strong> , <strong>gl:convolutionFilter1D/6</strong> , <strong>gl:convolutionFilter2D/7</strong> , <strong>gl:histogram/4</strong> , <strong>gl:minmax/3</strong> , and <strong>gl:separableFilter2D/8</strong> . Use of these maps is described completely in the <strong>gl:pixelTransferf/2</strong> reference page, and partly in the reference pages for the pixel and texture image commands. Only the specification of the maps is described in this reference page.</p><p><em>Map</em> is a symbolic map name, indicating one of ten maps to set. <em>Mapsize</em> specifies the number of entries in the map, and <em>Values</em> is a pointer to an array of <em>Mapsize</em> map values.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a pixel transfer map is specified, <em>Values</em> is treated as a byte offset into the buffer object's data store.</p><p>The ten maps are as follows:</p><p><em>?GL_PIXEL_MAP_I_TO_I</em>: Maps color indices to color indices.</p><p><em>?GL_PIXEL_MAP_S_TO_S</em>: Maps stencil indices to stencil indices.</p><p><em>?GL_PIXEL_MAP_I_TO_R</em>: Maps color indices to red components.</p><p><em>?GL_PIXEL_MAP_I_TO_G</em>: Maps color indices to green components.</p><p><em>?GL_PIXEL_MAP_I_TO_B</em>: Maps color indices to blue components.</p><p><em>?GL_PIXEL_MAP_I_TO_A</em>: Maps color indices to alpha components.</p><p><em>?GL_PIXEL_MAP_R_TO_R</em>: Maps red components to red components.</p><p><em>?GL_PIXEL_MAP_G_TO_G</em>: Maps green components to green components.</p><p><em>?GL_PIXEL_MAP_B_TO_B</em>: Maps blue components to blue components.</p><p><em>?GL_PIXEL_MAP_A_TO_A</em>: Maps alpha components to alpha components.</p><p>The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned int integers. Maps that store color component values (all but <em>?GL_PIXEL_MAP_I_TO_I</em> and <em>?GL_PIXEL_MAP_S_TO_S</em>) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by <em>gl:pixelMapfv</em> are converted directly to the internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values specified by <em>gl:pixelMapusv</em> and <em>gl:pixelMapuiv</em> are converted linearly such that the largest representable integer maps to 1.0, and 0 maps to 0.0.</p><p>Maps that store indices, <em>?GL_PIXEL_MAP_I_TO_I</em> and <em>?GL_PIXEL_MAP_S_TO_S</em>, retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by <em>gl:pixelMapfv</em> are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by <em>gl:pixelMapusv</em> and <em>gl:pixelMapuiv</em> specify integer values, with all 0's to the right of the binary point.</p><p>The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indices must have <em>Mapsize</em> = 2 n for some n or the results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling <strong>gl:getBooleanv/1</strong> with argument <em>?GL_MAX_PIXEL_MAP_TABLE</em> . The single maximum applies to all maps; it is at least 32.<em>Map</em><em>Lookup Index</em><em>Lookup Value</em><em>Initial Size</em><em>Initial Value</em></p><p><em>?GL_PIXEL_MAP_I_TO_I</em> color index color index 1 0</p><p><em>?GL_PIXEL_MAP_S_TO_S</em> stencil index stencil index 1 0</p><p><em>?GL_PIXEL_MAP_I_TO_R</em> color index R 1 0</p><p><em>?GL_PIXEL_MAP_I_TO_G</em> color index G 1 0</p><p><em>?GL_PIXEL_MAP_I_TO_B</em> color index B 1 0</p><p><em>?GL_PIXEL_MAP_I_TO_A</em> color index A 1 0</p><p><em>?GL_PIXEL_MAP_R_TO_R</em> R R 1 0</p><p><em>?GL_PIXEL_MAP_G_TO_G</em> G G 1 0</p><p><em>?GL_PIXEL_MAP_B_TO_B</em> B B 1 0</p><p><em>?GL_PIXEL_MAP_A_TO_A</em> A A 1 0</p><p>See external documentation.</p><p><strong></strong> pixelMapuiv(Map, Mapsize, Values) -&gt; ok</p><p>Types:</p><p>Map = enum()</p><p>Mapsize = integer()</p><p>Values = binary()</p><p>See <strong>pixelMapfv/3</strong></p><p><strong></strong> pixelMapusv(Map, Mapsize, Values) -&gt; ok</p><p>Types:</p><p>Map = enum()</p><p>Mapsize = integer()</p><p>Values = binary()</p><p>See <strong>pixelMapfv/3</strong></p><p><strong></strong> getPixelMapfv(Map, Values) -&gt; ok</p><p>Types:</p><p>Map = enum()</p><p>Values = mem()</p><p>Return the specified pixel map</p><p>See the <strong>gl:pixelMapfv/3</strong> reference page for a description of the acceptable values for the <em>Map</em> parameter. <em>gl:getPixelMap</em> returns in <em>Data</em> the contents of the pixel map specified in <em>Map</em> . Pixel maps are used during the execution of <strong>gl:readPixels/7</strong> , <strong>gl:drawPixels/5</strong> , <strong>gl:copyPixels/5</strong> , <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:copyTexImage1D/7</strong> , <strong>gl:copyTexImage2D/8</strong> , <strong>gl:copyTexSubImage1D/6</strong> , <strong>gl:copyTexSubImage2D/8</strong> , and <strong>gl:copyTexSubImage3D/9</strong> . to map color indices, stencil indices, color components, and depth components to other values.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a pixel map is requested, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return unsigned integer values are undefined if the map value was not in the range [0,1].</p><p>To determine the required size of <em>Map</em> , call <strong>gl:getBooleanv/1</strong> with the appropriate symbolic constant.</p><p>See external documentation.</p><p><strong></strong> getPixelMapuiv(Map, Values) -&gt; ok</p><p>Types:</p><p>Map = enum()</p><p>Values = mem()</p><p>See <strong>getPixelMapfv/2</strong></p><p><strong></strong> getPixelMapusv(Map, Values) -&gt; ok</p><p>Types:</p><p>Map = enum()</p><p>Values = mem()</p><p>See <strong>getPixelMapfv/2</strong></p><p><strong></strong> bitmap(Width, Height, Xorig, Yorig, Xmove, Ymove, Bitmap) -&gt; ok</p><p>Types:</p><p>Width = integer()</p><p>Height = integer()</p><p>Xorig = float()</p><p>Yorig = float()</p><p>Xmove = float()</p><p>Ymove = float()</p><p>Bitmap = offset() | mem()</p><p>Draw a bitmap</p><p>A bitmap is a binary image. When drawn, the bitmap is positioned relative to the current raster position, and frame buffer pixels corresponding to 1's in the bitmap are written using the current raster color or index. Frame buffer pixels corresponding to 0's in the bitmap are not modified.</p><p><em>gl:bitmap</em> takes seven arguments. The first pair specifies the width and height of the bitmap image. The second pair specifies the location of the bitmap origin relative to the lower left corner of the bitmap image. The third pair of arguments specifies <em>x</em> and <em>y</em> offsets to be added to the current raster position after the bitmap has been drawn. The final argument is a pointer to the bitmap image itself.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a bitmap image is specified, <em>Bitmap</em> is treated as a byte offset into the buffer object's data store.</p><p>The bitmap image is interpreted like image data for the <strong>gl:drawPixels/5</strong> command, with <em>Width</em> and <em>Height</em> corresponding to the width and height arguments of that command, and with <em>type</em> set to <em>?GL_BITMAP</em> and <em>format</em> set to <em>?GL_COLOR_INDEX</em> . Modes specified using <strong>gl:pixelStoref/2</strong> affect the interpretation of bitmap image data; modes specified using <strong>gl:pixelTransferf/2</strong> do not.</p><p>If the current raster position is invalid, <em>gl:bitmap</em> is ignored. Otherwise, the lower left corner of the bitmap image is positioned at the window coordinates</p><p>x w=|x r-x o|</p><p>y w=|y r-y o|</p><p>where (x r y r) is the raster position and (x o y o) is the bitmap origin. Fragments are then generated for each pixel corresponding to a 1 (one) in the bitmap image. These fragments are generated using the current raster <em>z</em> coordinate, color or color index, and current raster texture coordinates. They are then treated just as if they had been generated by a point, line, or polygon, including texture mapping, fogging, and all per-fragment operations such as alpha and depth testing.</p><p>After the bitmap has been drawn, the <em>x</em> and <em>y</em> coordinates of the current raster position are offset by <em>Xmove</em> and <em>Ymove</em> . No change is made to the <em>z</em> coordinate of the current raster position, or to the current raster color, texture coordinates, or index.</p><p>See external documentation.</p><p><strong></strong> readPixels(X, Y, Width, Height, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = mem()</p><p>Read a block of pixels from the frame buffer</p><p><em>gl:readPixels</em> returns pixel data from the frame buffer, starting with the pixel whose lower left corner is at location ( <em>X</em> , <em>Y</em> ), into client memory starting at location <em>Data</em> . Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with <strong>gl:pixelStoref/2</strong> . This reference page describes the effects on <em>gl:readPixels</em> of most, but not all of the parameters specified by these three commands.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a block of pixels is requested, <em>Data</em> is treated as a byte offset into the buffer object's data store rather than a pointer to client memory.</p><p><em>gl:readPixels</em> returns values from each pixel with lower left corner at (x+i y+j) for 0&lt;= i&lt; width and 0&lt;= j&lt; height. This pixel is said to be the ith pixel in the jth row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.</p><p><em>Format</em> specifies the format for the returned pixel values; accepted values are:</p><p><em>?GL_STENCIL_INDEX</em>: Stencil values are read from the stencil buffer. Each index is converted to fixed point, shifted left or right depending on the value and sign of <em>?GL_INDEX_SHIFT</em> , and added to <em>?GL_INDEX_OFFSET</em>. If <em>?GL_MAP_STENCIL</em> is <em>?GL_TRUE</em>, indices are replaced by their mappings in the table <em>?GL_PIXEL_MAP_S_TO_S</em>.</p><p><em>?GL_DEPTH_COMPONENT</em>: Depth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth value maps to 0 and the maximum value maps to 1. Each component is then multiplied by <em>?GL_DEPTH_SCALE</em>, added to <em>?GL_DEPTH_BIAS</em> , and finally clamped to the range [0 1].</p><p><em>?GL_DEPTH_STENCIL</em>: Values are taken from both the depth and stencil buffers. The <em>Type</em> parameter must be <em>?GL_UNSIGNED_INT_24_8</em> or <em>?GL_FLOAT_32_UNSIGNED_INT_24_8_REV</em> .</p><p><em>?GL_RED</em></p><p><em>?GL_GREEN</em></p><p><em>?GL_BLUE</em></p><p><em>?GL_RGB</em></p><p><em>?GL_BGR</em></p><p><em>?GL_RGBA</em></p><p><em>?GL_BGRA</em>: Finally, the indices or components are converted to the proper format, as specified by <em>Type</em> . If <em>Format</em> is <em>?GL_STENCIL_INDEX</em> and <em>Type</em> is not <em>?GL_FLOAT</em>, each index is masked with the mask value given in the following table. If <em>Type</em> is <em>?GL_FLOAT</em>, then each integer index is converted to single-precision floating-point format.</p><p>If <em>Format</em> is <em>?GL_RED</em>, <em>?GL_GREEN</em>, <em>?GL_BLUE</em>, <em>?GL_RGB</em>, <em>?GL_BGR</em> , <em>?GL_RGBA</em>, or <em>?GL_BGRA</em> and <em>Type</em> is not <em>?GL_FLOAT</em>, each component is multiplied by the multiplier shown in the following table. If type is <em>?GL_FLOAT</em>, then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL).<em>Type</em><em>Index Mask</em><em>Component Conversion</em></p><p><em>?GL_UNSIGNED_BYTE</em> 2 8-1(2 8-1) c</p><p><em>?GL_BYTE</em> 2 7-1((2 8-1) c-1)/2</p><p><em>?GL_UNSIGNED_SHORT</em> 2 16-1(2 16-1) c</p><p><em>?GL_SHORT</em> 2 15-1((2 16-1) c-1)/2</p><p><em>?GL_UNSIGNED_INT</em> 2 32-1(2 32-1) c</p><p><em>?GL_INT</em> 2 31-1((2 32-1) c-1)/2</p><p><em>?GL_HALF_FLOAT</em> none c</p><p><em>?GL_FLOAT</em> none c</p><p><em>?GL_UNSIGNED_BYTE_3_3_2</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_BYTE_2_3_3_REV</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_SHORT_5_6_5</em> 2 N-1 (2 N-1) c</p><p><em>?GL_UNSIGNED_SHORT_5_6_5_REV</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_SHORT_4_4_4_4</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_SHORT_4_4_4_4_REV</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_SHORT_5_5_5_1</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_SHORT_1_5_5_5_REV</em> 2 N-1 (2 N-1) c</p><p><em>?GL_UNSIGNED_INT_8_8_8_8</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_INT_8_8_8_8_REV</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_INT_10_10_10_2</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_INT_2_10_10_10_REV</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_INT_24_8</em> 2 N-1(2 N-1) c</p><p><em>?GL_UNSIGNED_INT_10F_11F_11F_REV</em> -- Special</p><p><em>?GL_UNSIGNED_INT_5_9_9_9_REV</em> -- Special</p><p><em>?GL_FLOAT_32_UNSIGNED_INT_24_8_REV</em> none c (Depth Only)</p><p>Return values are placed in memory as follows. If <em>Format</em> is <em>?GL_STENCIL_INDEX</em> , <em>?GL_DEPTH_COMPONENT</em>, <em>?GL_RED</em>, <em>?GL_GREEN</em>, or <em>?GL_BLUE</em>, a single value is returned and the data for the ith pixel in the jth row is placed in location (j) width+i. <em>?GL_RGB</em> and <em>?GL_BGR</em> return three values, <em>?GL_RGBA</em> and <em>?GL_BGRA</em> return four values for each pixel, with all values corresponding to a single pixel occupying contiguous space in <em>Data</em> . Storage parameters set by <strong>gl:pixelStoref/2</strong> , such as <em>?GL_PACK_LSB_FIRST</em> and <em>?GL_PACK_SWAP_BYTES</em>, affect the way that data is written into memory. See <strong>gl:pixelStoref/2</strong> for a description.</p><p>See external documentation.</p><p><strong></strong> drawPixels(Width, Height, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>Width = integer()</p><p>Height = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = offset() | mem()</p><p>Write a block of pixels to the frame buffer</p><p><em>gl:drawPixels</em> reads pixel data from memory and writes it into the frame buffer relative to the current raster position, provided that the raster position is valid. Use <strong>gl:rasterPos2d/2</strong> or <strong>gl:windowPos2d/2</strong> to set the current raster position; use <strong>gl:getBooleanv/1</strong> with argument <em>?GL_CURRENT_RASTER_POSITION_VALID</em> to determine if the specified raster position is valid, and <strong>gl:getBooleanv/1</strong> with argument <em>?GL_CURRENT_RASTER_POSITION</em> to query the raster position.</p><p>Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the frame buffer. These parameters are set with four commands: <strong>gl:pixelStoref/2</strong> , <strong>gl:pixelTransferf/2</strong> , <strong>gl:pixelMapfv/3</strong> , and <strong>gl:pixelZoom/2</strong> . This reference page describes the effects on <em>gl:drawPixels</em> of many, but not all, of the parameters specified by these four commands.</p><p>Data is read from <em>Data</em> as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on <em>Type</em> . When <em>Type</em> is one of <em>?GL_UNSIGNED_BYTE</em>, <em>?GL_BYTE</em>, <em>?GL_UNSIGNED_SHORT</em> , <em>?GL_SHORT</em>, <em>?GL_UNSIGNED_INT</em>, <em>?GL_INT</em>, or <em>?GL_FLOAT</em> each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on <em>Format</em> . When <em>Type</em> is one of <em>?GL_UNSIGNED_BYTE_3_3_2</em> , <em>?GL_UNSIGNED_SHORT_5_6_5</em>, <em>?GL_UNSIGNED_SHORT_4_4_4_4</em>, <em>?GL_UNSIGNED_SHORT_5_5_5_1</em> , <em>?GL_UNSIGNED_INT_8_8_8_8</em>, or <em>?GL_UNSIGNED_INT_10_10_10_2</em>, each unsigned value is interpreted as containing all the components for a single pixel, with the color components arranged according to <em>Format</em> . When <em>Type</em> is one of <em>?GL_UNSIGNED_BYTE_2_3_3_REV</em> , <em>?GL_UNSIGNED_SHORT_5_6_5_REV</em>, <em>?GL_UNSIGNED_SHORT_4_4_4_4_REV</em>, <em>?GL_UNSIGNED_SHORT_1_5_5_5_REV</em> , <em>?GL_UNSIGNED_INT_8_8_8_8_REV</em>, or <em>?GL_UNSIGNED_INT_2_10_10_10_REV</em>, each unsigned value is interpreted as containing all color components, specified by <em>Format</em> , for a single pixel in a reversed order. Indices are always treated individually. Color components are treated as groups of one, two, three, or four values, again based on <em>Format</em> . Both individual indices and groups of components are referred to as pixels. If <em>Type</em> is <em>?GL_BITMAP</em>, the data must be unsigned bytes, and <em>Format</em> must be either <em>?GL_COLOR_INDEX</em> or <em>?GL_STENCIL_INDEX</em>. Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by <em>?GL_UNPACK_LSB_FIRST</em> (see <strong>gl:pixelStoref/2</strong> ).</p><p>width×height pixels are read from memory, starting at location <em>Data</em> . By default, these pixels are taken from adjacent memory locations, except that after all <em>Width</em> pixels are read, the read pointer is advanced to the next four-byte boundary. The four-byte row alignment is specified by <strong>gl:pixelStoref/2</strong> with argument <em>?GL_UNPACK_ALIGNMENT</em> , and it can be set to one, two, four, or eight bytes. Other pixel store parameters specify different read pointer advancements, both before the first pixel is read and after all <em>Width</em> pixels are read. See the <strong>gl:pixelStoref/2</strong> reference page for details on these options.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a block of pixels is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>The width×height pixels that are read from memory are each operated on in the same way, based on the values of several parameters specified by <strong>gl:pixelTransferf/2</strong> and <strong>gl:pixelMapfv/3</strong> . The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by <em>Format</em> . <em>Format</em> can assume one of 13 symbolic values:</p><p><em>?GL_COLOR_INDEX</em>: Each pixel is a single value, a color index. It is converted to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type. Floating-point values convert to true fixed-point values. Signed and unsigned integer data is converted with all fraction bits set to 0. Bitmap data convert to either 0 or 1.</p><p>Each fixed-point index is then shifted left by <em>?GL_INDEX_SHIFT</em> bits and added to <em>?GL_INDEX_OFFSET</em> . If <em>?GL_INDEX_SHIFT</em> is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result.</p><p>If the GL is in RGBA mode, the resulting index is converted to an RGBA pixel with the help of the <em>?GL_PIXEL_MAP_I_TO_R</em>, <em>?GL_PIXEL_MAP_I_TO_G</em>, <em>?GL_PIXEL_MAP_I_TO_B</em> , and <em>?GL_PIXEL_MAP_I_TO_A</em> tables. If the GL is in color index mode, and if <em>?GL_MAP_COLOR</em> is true, the index is replaced with the value that it references in lookup table <em>?GL_PIXEL_MAP_I_TO_I</em> . Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2 b-1, where b is the number of bits in a color index buffer.</p><p>The GL then converts the resulting indices or RGBA colors to fragments by attaching the current raster position <em>z</em> coordinate and texture coordinates to each pixel, then assigning x and y window coordinates to the nth fragment such that x n=x r+n% width</p><p>y n=y r+|n/width|</p><p>where (x r y r) is the current raster position. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.</p><p><em>?GL_STENCIL_INDEX</em>: Each pixel is a single value, a stencil index. It is converted to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type. Floating-point values convert to true fixed-point values. Signed and unsigned integer data is converted with all fraction bits set to 0. Bitmap data convert to either 0 or 1.</p><p>Each fixed-point index is then shifted left by <em>?GL_INDEX_SHIFT</em> bits, and added to <em>?GL_INDEX_OFFSET</em>. If <em>?GL_INDEX_SHIFT</em> is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result. If <em>?GL_MAP_STENCIL</em> is true, the index is replaced with the value that it references in lookup table <em>?GL_PIXEL_MAP_S_TO_S</em>. Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2 b-1, where b is the number of bits in the stencil buffer. The resulting stencil indices are then written to the stencil buffer such that the nth index is written to location</p><p>x n=x r+n% width</p><p>y n=y r+|n/width|</p><p>where (x r y r) is the current raster position. Only the pixel ownership test, the scissor test, and the stencil writemask affect these write operations.</p><p><em>?GL_DEPTH_COMPONENT</em>: Each pixel is a single-depth component. Floating-point data is converted directly to an internal floating-point format with unspecified precision. Signed integer data is mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0. Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and 0 maps to 0.0. The resulting floating-point depth value is then multiplied by <em>?GL_DEPTH_SCALE</em> and added to <em>?GL_DEPTH_BIAS</em>. The result is clamped to the range [0 1].</p><p>The GL then converts the resulting depth components to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, then assigning x and y window coordinates to the nth fragment such that</p><p>x n=x r+n% width</p><p>y n=y r+|n/width|</p><p>where (x r y r) is the current raster position. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.</p><p><em>?GL_RGBA</em></p><p><em>?GL_BGRA</em>: Each pixel is a four-component group: For <em>?GL_RGBA</em>, the red component is first, followed by green, followed by blue, followed by alpha; for <em>?GL_BGRA</em> the order is blue, green, red and then alpha. Floating-point values are converted directly to an internal floating-point format with unspecified precision. Signed integer values are mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Unsigned integer data is mapped similarly: The largest integer value maps to 1.0, and 0 maps to 0.0. The resulting floating-point color values are then multiplied by <em>?GL_c_SCALE</em> and added to <em>?GL_c_BIAS</em>, where <em>c</em> is RED, GREEN, BLUE, and ALPHA for the respective color components. The results are clamped to the range [0 1].</p><p>If <em>?GL_MAP_COLOR</em> is true, each color component is scaled by the size of lookup table <em>?GL_PIXEL_MAP_c_TO_c</em>, then replaced by the value that it references in that table. <em>c</em> is R, G, B, or A respectively.</p><p>The GL then converts the resulting RGBA colors to fragments by attaching the current raster position <em>z</em> coordinate and texture coordinates to each pixel, then assigning x and y window coordinates to the nth fragment such that</p><p>x n=x r+n% width</p><p>y n=y r+|n/width|</p><p>where (x r y r) is the current raster position. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.</p><p><em>?GL_RED</em>: Each pixel is a single red component. This component is converted to the internal floating-point format in the same way the red component of an RGBA pixel is. It is then converted to an RGBA pixel with green and blue set to 0, and alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.</p><p><em>?GL_GREEN</em>: Each pixel is a single green component. This component is converted to the internal floating-point format in the same way the green component of an RGBA pixel is. It is then converted to an RGBA pixel with red and blue set to 0, and alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.</p><p><em>?GL_BLUE</em>: Each pixel is a single blue component. This component is converted to the internal floating-point format in the same way the blue component of an RGBA pixel is. It is then converted to an RGBA pixel with red and green set to 0, and alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.</p><p><em>?GL_ALPHA</em>: Each pixel is a single alpha component. This component is converted to the internal floating-point format in the same way the alpha component of an RGBA pixel is. It is then converted to an RGBA pixel with red, green, and blue set to 0. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.</p><p><em>?GL_RGB</em></p><p><em>?GL_BGR</em>: Each pixel is a three-component group: red first, followed by green, followed by blue; for <em>?GL_BGR</em>, the first component is blue, followed by green and then red. Each component is converted to the internal floating-point format in the same way the red, green, and blue components of an RGBA pixel are. The color triple is converted to an RGBA pixel with alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.</p><p><em>?GL_LUMINANCE</em>: Each pixel is a single luminance component. This component is converted to the internal floating-point format in the same way the red component of an RGBA pixel is. It is then converted to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.</p><p><em>?GL_LUMINANCE_ALPHA</em>: Each pixel is a two-component group: luminance first, followed by alpha. The two components are converted to the internal floating-point format in the same way the red component of an RGBA pixel is. They are then converted to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to the converted alpha value. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.</p><p>The following table summarizes the meaning of the valid constants for the <em>type</em> parameter:<em>Type</em><em>Corresponding Type</em></p><p><em>?GL_UNSIGNED_BYTE</em> unsigned 8-bit integer</p><p><em>?GL_BYTE</em> signed 8-bit integer</p><p><em>?GL_BITMAP</em> single bits in unsigned 8-bit integers</p><p><em>?GL_UNSIGNED_SHORT</em> unsigned 16-bit integer</p><p><em>?GL_SHORT</em> signed 16-bit integer</p><p><em>?GL_UNSIGNED_INT</em> unsigned 32-bit integer</p><p><em>?GL_INT</em> 32-bit integer</p><p><em>?GL_FLOAT</em> single-precision floating-point</p><p><em>?GL_UNSIGNED_BYTE_3_3_2</em> unsigned 8-bit integer</p><p><em>?GL_UNSIGNED_BYTE_2_3_3_REV</em> unsigned 8-bit integer with reversed component ordering</p><p><em>?GL_UNSIGNED_SHORT_5_6_5</em> unsigned 16-bit integer</p><p><em>?GL_UNSIGNED_SHORT_5_6_5_REV</em> unsigned 16-bit integer with reversed component ordering</p><p><em>?GL_UNSIGNED_SHORT_4_4_4_4</em> unsigned 16-bit integer</p><p><em>?GL_UNSIGNED_SHORT_4_4_4_4_REV</em> unsigned 16-bit integer with reversed component ordering</p><p><em>?GL_UNSIGNED_SHORT_5_5_5_1</em> unsigned 16-bit integer</p><p><em>?GL_UNSIGNED_SHORT_1_5_5_5_REV</em> unsigned 16-bit integer with reversed component ordering</p><p><em>?GL_UNSIGNED_INT_8_8_8_8</em> unsigned 32-bit integer</p><p><em>?GL_UNSIGNED_INT_8_8_8_8_REV</em> unsigned 32-bit integer with reversed component ordering</p><p><em>?GL_UNSIGNED_INT_10_10_10_2</em> unsigned 32-bit integer</p><p><em>?GL_UNSIGNED_INT_2_10_10_10_REV</em> unsigned 32-bit integer with reversed component ordering</p><p>The rasterization described so far assumes pixel zoom factors of 1. If <strong>gl:pixelZoom/2</strong> is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows. If (x r y r) is the current raster position, and a given pixel is in the nth column and mth row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at</p><p>(x r+(zoom x) n y r+(zoom y) m)</p><p>(x r+(zoom x)(n+1) y r+(zoom y)(m+1))</p><p>where zoom x is the value of <em>?GL_ZOOM_X</em> and zoom y is the value of <em>?GL_ZOOM_Y</em> .</p><p>See external documentation.</p><p><strong></strong> copyPixels(X, Y, Width, Height, Type) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Type = enum()</p><p>Copy pixels in the frame buffer</p><p><em>gl:copyPixels</em> copies a screen-aligned rectangle of pixels from the specified frame buffer location to a region relative to the current raster position. Its operation is well defined only if the entire pixel source region is within the exposed portion of the window. Results of copies from outside the window, or from regions of the window that are not exposed, are hardware dependent and undefined.</p><p><em>X</em> and <em>Y</em> specify the window coordinates of the lower left corner of the rectangular region to be copied. <em>Width</em> and <em>Height</em> specify the dimensions of the rectangular region to be copied. Both <em>Width</em> and <em>Height</em> must not be negative.</p><p>Several parameters control the processing of the pixel data while it is being copied. These parameters are set with three commands: <strong>gl:pixelTransferf/2</strong> , <strong>gl:pixelMapfv/3</strong> , and <strong>gl:pixelZoom/2</strong> . This reference page describes the effects on <em>gl:copyPixels</em> of most, but not all, of the parameters specified by these three commands.</p><p><em>gl:copyPixels</em> copies values from each pixel with the lower left-hand corner at (x+i y+j) for 0&lt;= i&lt; width and 0&lt;= j&lt; height. This pixel is said to be the ith pixel in the jth row. Pixels are copied in row order from the lowest to the highest row, left to right in each row.</p><p><em>Type</em> specifies whether color, depth, or stencil data is to be copied. The details of the transfer for each data type are as follows:</p><p><em>?GL_COLOR</em>: Indices or RGBA colors are read from the buffer currently specified as the read source buffer (see <strong>gl:readBuffer/1</strong> ). If the GL is in color index mode, each index that is read from this buffer is converted to a fixed-point format with an unspecified number of bits to the right of the binary point. Each index is then shifted left by <em>?GL_INDEX_SHIFT</em> bits, and added to <em>?GL_INDEX_OFFSET</em>. If <em>?GL_INDEX_SHIFT</em> is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result. If <em>?GL_MAP_COLOR</em> is true, the index is replaced with the value that it references in lookup table <em>?GL_PIXEL_MAP_I_TO_I</em>. Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2 b-1, where b is the number of bits in a color index buffer.</p><p>If the GL is in RGBA mode, the red, green, blue, and alpha components of each pixel that is read are converted to an internal floating-point format with unspecified precision. The conversion maps the largest representable component value to 1.0, and component value 0 to 0.0. The resulting floating-point color values are then multiplied by <em>?GL_c_SCALE</em> and added to <em>?GL_c_BIAS</em>, where <em>c</em> is RED, GREEN, BLUE, and ALPHA for the respective color components. The results are clamped to the range [0,1]. If <em>?GL_MAP_COLOR</em> is true, each color component is scaled by the size of lookup table <em>?GL_PIXEL_MAP_c_TO_c</em> , then replaced by the value that it references in that table. <em>c</em> is R, G, B, or A.</p><p>If the ARB_imaging extension is supported, the color values may be additionally processed by color-table lookups, color-matrix transformations, and convolution filters.</p><p>The GL then converts the resulting indices or RGBA colors to fragments by attaching the current raster position <em>z</em> coordinate and texture coordinates to each pixel, then assigning window coordinates (x r+i y r+j), where (x r y r) is the current raster position, and the pixel was the ith pixel in the jth row. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.</p><p><em>?GL_DEPTH</em>: Depth values are read from the depth buffer and converted directly to an internal floating-point format with unspecified precision. The resulting floating-point depth value is then multiplied by <em>?GL_DEPTH_SCALE</em> and added to <em>?GL_DEPTH_BIAS</em> . The result is clamped to the range [0,1].</p><p>The GL then converts the resulting depth components to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, then assigning window coordinates (x r+i y r+j), where (x r y r) is the current raster position, and the pixel was the ith pixel in the jth row. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.</p><p><em>?GL_STENCIL</em>: Stencil indices are read from the stencil buffer and converted to an internal fixed-point format with an unspecified number of bits to the right of the binary point. Each fixed-point index is then shifted left by <em>?GL_INDEX_SHIFT</em> bits, and added to <em>?GL_INDEX_OFFSET</em>. If <em>?GL_INDEX_SHIFT</em> is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result. If <em>?GL_MAP_STENCIL</em> is true, the index is replaced with the value that it references in lookup table <em>?GL_PIXEL_MAP_S_TO_S</em>. Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2 b-1, where b is the number of bits in the stencil buffer. The resulting stencil indices are then written to the stencil buffer such that the index read from the ith location of the jth row is written to location (x r+i y r+j), where (x r y r) is the current raster position. Only the pixel ownership test, the scissor test, and the stencil writemask affect these write operations.</p><p>The rasterization described thus far assumes pixel zoom factors of 1.0. If <strong>gl:pixelZoom/2</strong> is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows. If (x r y r) is the current raster position, and a given pixel is in the ith location in the jth row of the source pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at</p><p>(x r+(zoom x) i y r+(zoom y) j)</p><p>and</p><p>(x r+(zoom x)(i+1) y r+(zoom y)(j+1))</p><p>where zoom x is the value of <em>?GL_ZOOM_X</em> and zoom y is the value of <em>?GL_ZOOM_Y</em> .</p><p>See external documentation.</p><p><strong></strong> stencilFunc(Func, Ref, Mask) -&gt; ok</p><p>Types:</p><p>Func = enum()</p><p>Ref = integer()</p><p>Mask = integer()</p><p>Set front and back function and reference value for stencil testing</p><p>Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.</p><p>The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_STENCIL_TEST</em> . To specify actions based on the outcome of the stencil test, call <strong>gl:stencilOp/3</strong> or <strong>gl:stencilOpSeparate/4</strong> .</p><p>There can be two separate sets of <em>Func</em> , <em>Ref</em> , and <em>Mask</em> parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. <strong>gl:stencilFunc/3</strong> sets both front and back stencil state to the same values. Use <strong>gl:stencilFuncSeparate/4</strong> to set front and back stencil state to different values.</p><p><em>Func</em> is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. <em>Ref</em> is an integer reference value that is used in the stencil comparison. It is clamped to the range [0 2 n-1], where n is the number of bitplanes in the stencil buffer. <em>Mask</em> is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.</p><p>If <em>stencil</em> represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by <em>Func</em> . Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see <strong>gl:stencilOp/3</strong> ). All tests treat <em>stencil</em> values as unsigned integers in the range [0 2 n-1], where n is the number of bitplanes in the stencil buffer.</p><p>The following values are accepted by <em>Func</em> :</p><p><em>?GL_NEVER</em>: Always fails.</p><p><em>?GL_LESS</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) &lt; ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_LEQUAL</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) &lt;= ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_GREATER</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) &gt; ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_GEQUAL</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) &gt;= ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_EQUAL</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) = ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_NOTEQUAL</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) != ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_ALWAYS</em>: Always passes.</p><p>See external documentation.</p><p><strong></strong> stencilMask(Mask) -&gt; ok</p><p>Types:</p><p>Mask = integer()</p><p>Control the front and back writing of individual bits in the stencil planes</p><p><em>gl:stencilMask</em> controls the writing of individual bits in the stencil planes. The least significant n bits of <em>Mask</em> , where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.</p><p>There can be two separate <em>Mask</em> writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. <strong>gl:stencilMask/1</strong> sets both front and back stencil writemasks to the same values. Use <strong>gl:stencilMaskSeparate/2</strong> to set front and back stencil writemasks to different values.</p><p>See external documentation.</p><p><strong></strong> stencilOp(Fail, Zfail, Zpass) -&gt; ok</p><p>Types:</p><p>Fail = enum()</p><p>Zfail = enum()</p><p>Zpass = enum()</p><p>Set front and back stencil test actions</p><p>Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.</p><p>The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_STENCIL_TEST</em> ; to control it, call <strong>gl:stencilFunc/3</strong> or <strong>gl:stencilFuncSeparate/4</strong> .</p><p>There can be two separate sets of <em>Sfail</em> , <em>Dpfail</em> , and <em>Dppass</em> parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. <strong>gl:stencilOp/3</strong> sets both front and back stencil state to the same values. Use <strong>gl:stencilOpSeparate/4</strong> to set front and back stencil state to different values.</p><p><em>gl:stencilOp</em> takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and <em>Sfail</em> specifies what happens to the stencil buffer contents. The following eight actions are possible.</p><p><em>?GL_KEEP</em>: Keeps the current value.</p><p><em>?GL_ZERO</em>: Sets the stencil buffer value to 0.</p><p><em>?GL_REPLACE</em>: Sets the stencil buffer value to <em>ref</em>, as specified by <strong>gl:stencilFunc/3</strong> .</p><p><em>?GL_INCR</em>: Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.</p><p><em>?GL_INCR_WRAP</em>: Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.</p><p><em>?GL_DECR</em>: Decrements the current stencil buffer value. Clamps to 0.</p><p><em>?GL_DECR_WRAP</em>: Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.</p><p><em>?GL_INVERT</em>: Bitwise inverts the current stencil buffer value.</p><p>Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n-1, where n is the value returned by querying <em>?GL_STENCIL_BITS</em> .</p><p>The other two arguments to <em>gl:stencilOp</em> specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed ( <em>Dppass</em> ) or fail ( <em>Dpfail</em> ) (see <strong>gl:depthFunc/1</strong> ). The actions are specified using the same eight symbolic constants as <em>Sfail</em> . Note that <em>Dpfail</em> is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, <em>Sfail</em> and <em>Dppass</em> specify stencil action when the stencil test fails and passes, respectively.</p><p>See external documentation.</p><p><strong></strong> clearStencil(S) -&gt; ok</p><p>Types:</p><p>S = integer()</p><p>Specify the clear value for the stencil buffer</p><p><em>gl:clearStencil</em> specifies the index used by <strong>gl:clear/1</strong> to clear the stencil buffer. <em>S</em> is masked with 2 m-1, where m is the number of bits in the stencil buffer.</p><p>See external documentation.</p><p><strong></strong> texGend(Coord, Pname, Param) -&gt; ok</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>Param = float()</p><p>Control the generation of texture coordinates</p><p><em>gl:texGen</em> selects a texture-coordinate generation function or supplies coefficients for one of the functions. <em>Coord</em> names one of the (<em>s</em>, <em>t</em>, <em>r</em>, <em>q</em> ) texture coordinates; it must be one of the symbols <em>?GL_S</em>, <em>?GL_T</em>, <em>?GL_R</em> , or <em>?GL_Q</em>. <em>Pname</em> must be one of three symbolic constants: <em>?GL_TEXTURE_GEN_MODE</em> , <em>?GL_OBJECT_PLANE</em>, or <em>?GL_EYE_PLANE</em>. If <em>Pname</em> is <em>?GL_TEXTURE_GEN_MODE</em> , then <em>Params</em> chooses a mode, one of <em>?GL_OBJECT_LINEAR</em>, <em>?GL_EYE_LINEAR</em> , <em>?GL_SPHERE_MAP</em>, <em>?GL_NORMAL_MAP</em>, or <em>?GL_REFLECTION_MAP</em>. If <em>Pname</em> is either <em>?GL_OBJECT_PLANE</em> or <em>?GL_EYE_PLANE</em>, <em>Params</em> contains coefficients for the corresponding texture generation function.</p><p>If the texture generation function is <em>?GL_OBJECT_LINEAR</em>, the function</p><p>g=p 1×x o+p 2×y o+p 3×z o+p 4×w o</p><p>is used, where g is the value computed for the coordinate named in <em>Coord</em> , p 1, p 2, p 3, and p 4 are the four values supplied in <em>Params</em> , and x o, y o, z o, and w o are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by p 1, p 2, p 3, and p 4). The altitude of a terrain vertex is computed by the <em>?GL_OBJECT_LINEAR</em> coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills.</p><p>If the texture generation function is <em>?GL_EYE_LINEAR</em>, the function</p><p>g=(p 1)"×x e+(p 2)"×y e+(p 3)"×z e+(p 4)"×w e</p><p>is used, where</p><p>((p 1)" (p 2)" (p 3)" (p 4)")=(p 1 p 2 p 3 p 4) M -1</p><p>and x e, y e, z e, and w e are the eye coordinates of the vertex, p 1, p 2, p 3, and p 4 are the values supplied in <em>Params</em> , and M is the modelview matrix when <em>gl:texGen</em> is invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined.</p><p>Note that the values in <em>Params</em> define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.</p><p>If the texture generation function is <em>?GL_SPHERE_MAP</em> and <em>Coord</em> is either <em>?GL_S</em> or <em>?GL_T</em>, s and t texture coordinates are generated as follows. Let <em>u</em> be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let <em>n</em> sup prime be the current normal, after transformation to eye coordinates. Let</p><p>f=(f x f y f z) T be the reflection vector such that</p><p>f=u-2 n" (n") T u</p><p>Finally, let m=2 ((f x) 2+(f y) 2+(f z+1) 2). Then the values assigned to the s and t texture coordinates are</p><p>s=f x/m+1/2</p><p>t=f y/m+1/2</p><p>To enable or disable a texture-coordinate generation function, call <strong>gl:enable/1</strong> or <strong>gl:enable/1</strong> with one of the symbolic texture-coordinate names (<em>?GL_TEXTURE_GEN_S</em> , <em>?GL_TEXTURE_GEN_T</em>, <em>?GL_TEXTURE_GEN_R</em>, or <em>?GL_TEXTURE_GEN_Q</em>) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to <em>?GL_EYE_LINEAR</em> and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0).</p><p>When the ARB_multitexture extension is supported, <em>gl:texGen</em> sets the texture generation parameters for the currently active texture unit, selected with <strong>gl:activeTexture/1</strong> .</p><p>See external documentation.</p><p><strong></strong> texGenf(Coord, Pname, Param) -&gt; ok</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>Param = float()</p><p>See <strong>texGend/3</strong></p><p><strong></strong> texGeni(Coord, Pname, Param) -&gt; ok</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>texGend/3</strong></p><p><strong></strong> texGendv(Coord, Pname, Params) -&gt; ok</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>Params = {float()}</p><p>See <strong>texGend/3</strong></p><p><strong></strong> texGenfv(Coord, Pname, Params) -&gt; ok</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>Params = {float()}</p><p>See <strong>texGend/3</strong></p><p><strong></strong> texGeniv(Coord, Pname, Params) -&gt; ok</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>texGend/3</strong></p><p><strong></strong> getTexGendv(Coord, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>Return texture coordinate generation parameters</p><p><em>gl:getTexGen</em> returns in <em>Params</em> selected parameters of a texture coordinate generation function that was specified using <strong>gl:texGend/3</strong> . <em>Coord</em> names one of the (<em>s</em>, <em>t</em>, <em>r</em>, <em>q</em>) texture coordinates, using the symbolic constant <em>?GL_S</em>, <em>?GL_T</em>, <em>?GL_R</em>, or <em>?GL_Q</em>.</p><p><em>Pname</em> specifies one of three symbolic names:</p><p><em>?GL_TEXTURE_GEN_MODE</em>: <em>Params</em> returns the single-valued texture generation function, a symbolic constant. The initial value is <em>?GL_EYE_LINEAR</em>.</p><p><em>?GL_OBJECT_PLANE</em>: <em>Params</em> returns the four plane equation coefficients that specify object linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation.</p><p><em>?GL_EYE_PLANE</em>: <em>Params</em> returns the four plane equation coefficients that specify eye linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation. The returned values are those maintained in eye coordinates. They are not equal to the values specified using <strong>gl:texGend/3</strong> , unless the modelview matrix was identity when <strong>gl:texGend/3</strong> was called.</p><p>See external documentation.</p><p><strong></strong> getTexGenfv(Coord, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>See <strong>getTexGendv/2</strong></p><p><strong></strong> getTexGeniv(Coord, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Coord = enum()</p><p>Pname = enum()</p><p>See <strong>getTexGendv/2</strong></p><p><strong></strong> texEnvf(Target, Pname, Param) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Param = float()</p><p>glTexEnvf</p><p>See external documentation.</p><p><strong></strong> texEnvi(Target, Pname, Param) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Param = integer()</p><p>glTexEnvi</p><p>See external documentation.</p><p><strong></strong> texEnvfv(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {float()}</p><p>Set texture environment parameters</p><p>A texture environment specifies how texture values are interpreted when a fragment is textured. When <em>Target</em> is <em>?GL_TEXTURE_FILTER_CONTROL</em>, <em>Pname</em> must be <em>?GL_TEXTURE_LOD_BIAS</em> . When <em>Target</em> is <em>?GL_TEXTURE_ENV</em>, <em>Pname</em> can be <em>?GL_TEXTURE_ENV_MODE</em> , <em>?GL_TEXTURE_ENV_COLOR</em>, <em>?GL_COMBINE_RGB</em>, <em>?GL_COMBINE_ALPHA</em>, <em>?GL_RGB_SCALE</em> , <em>?GL_ALPHA_SCALE</em>, <em>?GL_SRC0_RGB</em>, <em>?GL_SRC1_RGB</em>, <em>?GL_SRC2_RGB</em>, <em>?GL_SRC0_ALPHA</em> , <em>?GL_SRC1_ALPHA</em>, or <em>?GL_SRC2_ALPHA</em>.</p><p>If <em>Pname</em> is <em>?GL_TEXTURE_ENV_MODE</em>, then <em>Params</em> is (or points to) the symbolic name of a texture function. Six texture functions may be specified: <em>?GL_ADD</em> , <em>?GL_MODULATE</em>, <em>?GL_DECAL</em>, <em>?GL_BLEND</em>, <em>?GL_REPLACE</em>, or <em>?GL_COMBINE</em> .</p><p>The following table shows the correspondence of filtered texture values R t, G t, B t, A t, L t, I t to texture source components. C s and A s are used by the texture functions described below. Texture Base Internal Format C s A s</p><p><em>?GL_ALPHA</em> (0, 0, 0) A t</p><p><em>?GL_LUMINANCE</em> ( L t, L t, L t ) 1</p><p><em>?GL_LUMINANCE_ALPHA</em> ( L t, L t, L t ) A t</p><p><em>?GL_INTENSITY</em> ( I t, I t, I t ) I t</p><p><em>?GL_RGB</em> ( R t, G t, B t ) 1</p><p><em>?GL_RGBA</em> ( R t, G t, B t ) A t</p><p>A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see <strong>gl:texParameterf/3</strong> ) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the first five texture functions that can be chosen. C is a triple of color values (RGB) and A is the associated alpha value. RGBA values extracted from a texture image are in the range [0,1]. The subscript p refers to the color computed from the previous texture stage (or the incoming fragment if processing texture stage 0), the subscript s to the texture source color, the subscript c to the texture environment color, and the subscript v indicates a value produced by the texture function. Texture Base Internal Format <em>?Value</em><em>?GL_REPLACE</em> Function <em>?GL_MODULATE</em> Function <em>?GL_DECAL</em> Function <em>?GL_BLEND</em> Function <em>?GL_ADD</em> Function</p><p><em>?GL_ALPHA</em> C v= C p C p undefined C p C p</p><p> A v= A s A p A s A v=A p A s A p A s</p><p><em>?GL_LUMINANCE</em> C v= C s C p C s undefined C p (1-C s)+C c C s C p+C s</p><p> (or 1) A v= A p A p A p A p</p><p><em>?GL_LUMINANCE_ALPHA</em> C v= C s C p C s undefined C p (1-C s)+C c C s C p+C s</p><p> (or 2) A v= A s A p A s A p A s A p A s</p><p><em>?GL_INTENSITY</em> C v= C s C p C s undefined C p (1-C s)+C c C s C p+C s</p><p> A v= A s A p A s A p (1-A s)+A c A s A p+A s</p><p><em>?GL_RGB</em> C v= C s C p C s C s C p (1-C s)+C c C s C p+C s</p><p> (or 3) A v= A p A p A p A p A p</p><p><em>?GL_RGBA</em> C v= C s C p C s C p (1-A s)+C s A s C p (1-C s)+C c C s C p+C s</p><p> (or 4) A v= A s A p A s A p A p A s A p A s</p><p>If <em>Pname</em> is <em>?GL_TEXTURE_ENV_MODE</em>, and <em>Params</em> is <em>?GL_COMBINE</em>, the form of the texture function depends on the values of <em>?GL_COMBINE_RGB</em> and <em>?GL_COMBINE_ALPHA</em> .</p><p>The following describes how the texture sources, as specified by <em>?GL_SRC0_RGB</em>, <em>?GL_SRC1_RGB</em> , <em>?GL_SRC2_RGB</em>, <em>?GL_SRC0_ALPHA</em>, <em>?GL_SRC1_ALPHA</em>, and <em>?GL_SRC2_ALPHA</em> , are combined to produce a final texture color. In the following tables, <em>?GL_SRC0_c</em> is represented by Arg0, <em>?GL_SRC1_c</em> is represented by Arg1, and <em>?GL_SRC2_c</em> is represented by Arg2.</p><p><em>?GL_COMBINE_RGB</em> accepts any of <em>?GL_REPLACE</em>, <em>?GL_MODULATE</em>, <em>?GL_ADD</em> , <em>?GL_ADD_SIGNED</em>, <em>?GL_INTERPOLATE</em>, <em>?GL_SUBTRACT</em>, <em>?GL_DOT3_RGB</em>, or <em>?GL_DOT3_RGBA</em>.<em>?GL_COMBINE_RGB</em><em>Texture Function</em></p><p><em>?GL_REPLACE</em> Arg0</p><p><em>?GL_MODULATE</em> Arg0×Arg1</p><p><em>?GL_ADD</em> Arg0+Arg1</p><p><em>?GL_ADD_SIGNED</em> Arg0+Arg1-0.5</p><p><em>?GL_INTERPOLATE</em> Arg0×Arg2+Arg1×(1- Arg2)</p><p><em>?GL_SUBTRACT</em> Arg0-Arg1</p><p><em>?GL_DOT3_RGB</em> or <em>?GL_DOT3_RGBA</em> 4×((((Arg0 r)-0.5)×((Arg1 r)-0.5))+(((Arg0 g)-0.5)×((Arg1 g)-0.5))+(((Arg0 b)-0.5)×((Arg1 b)-0.5)))</p><p>The scalar results for <em>?GL_DOT3_RGB</em> and <em>?GL_DOT3_RGBA</em> are placed into each of the 3 (RGB) or 4 (RGBA) components on output.</p><p>Likewise, <em>?GL_COMBINE_ALPHA</em> accepts any of <em>?GL_REPLACE</em>, <em>?GL_MODULATE</em>, <em>?GL_ADD</em>, <em>?GL_ADD_SIGNED</em>, <em>?GL_INTERPOLATE</em>, or <em>?GL_SUBTRACT</em>. The following table describes how alpha values are combined:<em>?GL_COMBINE_ALPHA</em><em>Texture Function</em></p><p><em>?GL_REPLACE</em> Arg0</p><p><em>?GL_MODULATE</em> Arg0×Arg1</p><p><em>?GL_ADD</em> Arg0+Arg1</p><p><em>?GL_ADD_SIGNED</em> Arg0+Arg1-0.5</p><p><em>?GL_INTERPOLATE</em> Arg0×Arg2+Arg1×(1- Arg2)</p><p><em>?GL_SUBTRACT</em> Arg0-Arg1</p><p>In the following tables, the value C s represents the color sampled from the currently bound texture, C c represents the constant texture-environment color, C f represents the primary color of the incoming fragment, and C p represents the color computed from the previous texture stage or C f if processing texture stage 0. Likewise, A s, A c, A f, and A p represent the respective alpha values.</p><p>The following table describes the values assigned to Arg0, Arg1, and Arg2 based upon the RGB sources and operands:<em>?GL_SRCn_RGB</em><em>?GL_OPERANDn_RGB</em><em>Argument Value</em></p><p><em>?GL_TEXTURE</em><em>?GL_SRC_COLOR</em>(C s)</p><p><em>?GL_ONE_MINUS_SRC_COLOR</em> 1-(C s)</p><p><em>?GL_SRC_ALPHA</em>(A s)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A s)</p><p><em>?GL_TEXTUREn</em><em>?GL_SRC_COLOR</em>(C s)</p><p><em>?GL_ONE_MINUS_SRC_COLOR</em> 1-(C s)</p><p><em>?GL_SRC_ALPHA</em> (A s)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A s)</p><p><em>?GL_CONSTANT</em><em>?GL_SRC_COLOR</em>(C c)</p><p><em>?GL_ONE_MINUS_SRC_COLOR</em> 1-(C c)</p><p><em>?GL_SRC_ALPHA</em>(A c)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A c)</p><p><em>?GL_PRIMARY_COLOR</em><em>?GL_SRC_COLOR</em>(C f)</p><p><em>?GL_ONE_MINUS_SRC_COLOR</em> 1-(C f)</p><p><em>?GL_SRC_ALPHA</em>(A f)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A f)</p><p><em>?GL_PREVIOUS</em><em>?GL_SRC_COLOR</em> (C p)</p><p><em>?GL_ONE_MINUS_SRC_COLOR</em> 1-(C p)</p><p><em>?GL_SRC_ALPHA</em>(A p)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A p)</p><p>For <em>?GL_TEXTUREn</em> sources, C s and A s represent the color and alpha, respectively, produced from texture stage n.</p><p>The follow table describes the values assigned to Arg0, Arg1, and Arg2 based upon the alpha sources and operands:<em>?GL_SRCn_ALPHA</em><em>?GL_OPERANDn_ALPHA</em><em>Argument Value</em></p><p><em>?GL_TEXTURE</em><em>?GL_SRC_ALPHA</em>(A s)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A s)</p><p><em>?GL_TEXTUREn</em><em>?GL_SRC_ALPHA</em>(A s)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A s)</p><p><em>?GL_CONSTANT</em><em>?GL_SRC_ALPHA</em>(A c)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A c)</p><p><em>?GL_PRIMARY_COLOR</em><em>?GL_SRC_ALPHA</em>(A f)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A f)</p><p><em>?GL_PREVIOUS</em><em>?GL_SRC_ALPHA</em>(A p)</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em> 1-(A p)</p><p>The RGB and alpha results of the texture function are multipled by the values of <em>?GL_RGB_SCALE</em> and <em>?GL_ALPHA_SCALE</em>, respectively, and clamped to the range [0 1].</p><p>If <em>Pname</em> is <em>?GL_TEXTURE_ENV_COLOR</em>, <em>Params</em> is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1] when they are specified. C c takes these four values.</p><p>If <em>Pname</em> is <em>?GL_TEXTURE_LOD_BIAS</em>, the value specified is added to the texture level-of-detail parameter, that selects which mipmap, or mipmaps depending upon the selected <em>?GL_TEXTURE_MIN_FILTER</em>, will be sampled.</p><p><em>?GL_TEXTURE_ENV_MODE</em> defaults to <em>?GL_MODULATE</em> and <em>?GL_TEXTURE_ENV_COLOR</em> defaults to (0, 0, 0, 0).</p><p>If <em>Target</em> is <em>?GL_POINT_SPRITE</em> and <em>Pname</em> is <em>?GL_COORD_REPLACE</em>, the boolean value specified is used to either enable or disable point sprite texture coordinate replacement. The default value is <em>?GL_FALSE</em>.</p><p>See external documentation.</p><p><strong></strong> texEnviv(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>texEnvfv/3</strong></p><p><strong></strong> getTexEnvfv(Target, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Return texture environment parameters</p><p><em>gl:getTexEnv</em> returns in <em>Params</em> selected values of a texture environment that was specified with <strong>gl:texEnvfv/3</strong> . <em>Target</em> specifies a texture environment.</p><p>When <em>Target</em> is <em>?GL_TEXTURE_FILTER_CONTROL</em>, <em>Pname</em> must be <em>?GL_TEXTURE_LOD_BIAS</em> . When <em>Target</em> is <em>?GL_POINT_SPRITE</em>, <em>Pname</em> must be <em>?GL_COORD_REPLACE</em> . When <em>Target</em> is <em>?GL_TEXTURE_ENV</em>, <em>Pname</em> can be <em>?GL_TEXTURE_ENV_MODE</em> , <em>?GL_TEXTURE_ENV_COLOR</em>, <em>?GL_COMBINE_RGB</em>, <em>?GL_COMBINE_ALPHA</em>, <em>?GL_RGB_SCALE</em> , <em>?GL_ALPHA_SCALE</em>, <em>?GL_SRC0_RGB</em>, <em>?GL_SRC1_RGB</em>, <em>?GL_SRC2_RGB</em>, <em>?GL_SRC0_ALPHA</em>, <em>?GL_SRC1_ALPHA</em>, or <em>?GL_SRC2_ALPHA</em>.</p><p><em>Pname</em> names a specific texture environment parameter, as follows:</p><p><em>?GL_TEXTURE_ENV_MODE</em>: <em>Params</em> returns the single-valued texture environment mode, a symbolic constant. The initial value is <em>?GL_MODULATE</em>.</p><p><em>?GL_TEXTURE_ENV_COLOR</em>: <em>Params</em> returns four integer or floating-point values that are the texture environment color. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer, and -1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).</p><p><em>?GL_TEXTURE_LOD_BIAS</em>: <em>Params</em> returns a single floating-point value that is the texture level-of-detail bias. The initial value is 0.</p><p><em>?GL_COMBINE_RGB</em>: <em>Params</em> returns a single symbolic constant value representing the current RGB combine mode. The initial value is <em>?GL_MODULATE</em>.</p><p><em>?GL_COMBINE_ALPHA</em>: <em>Params</em> returns a single symbolic constant value representing the current alpha combine mode. The initial value is <em>?GL_MODULATE</em>.</p><p><em>?GL_SRC0_RGB</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner zero's RGB source. The initial value is <em>?GL_TEXTURE</em>.</p><p><em>?GL_SRC1_RGB</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner one's RGB source. The initial value is <em>?GL_PREVIOUS</em>.</p><p><em>?GL_SRC2_RGB</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner two's RGB source. The initial value is <em>?GL_CONSTANT</em>.</p><p><em>?GL_SRC0_ALPHA</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner zero's alpha source. The initial value is <em>?GL_TEXTURE</em>.</p><p><em>?GL_SRC1_ALPHA</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner one's alpha source. The initial value is <em>?GL_PREVIOUS</em>.</p><p><em>?GL_SRC2_ALPHA</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner two's alpha source. The initial value is <em>?GL_CONSTANT</em>.</p><p><em>?GL_OPERAND0_RGB</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner zero's RGB operand. The initial value is <em>?GL_SRC_COLOR</em>.</p><p><em>?GL_OPERAND1_RGB</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner one's RGB operand. The initial value is <em>?GL_SRC_COLOR</em>.</p><p><em>?GL_OPERAND2_RGB</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner two's RGB operand. The initial value is <em>?GL_SRC_ALPHA</em>.</p><p><em>?GL_OPERAND0_ALPHA</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner zero's alpha operand. The initial value is <em>?GL_SRC_ALPHA</em>.</p><p><em>?GL_OPERAND1_ALPHA</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner one's alpha operand. The initial value is <em>?GL_SRC_ALPHA</em>.</p><p><em>?GL_OPERAND2_ALPHA</em>: <em>Params</em> returns a single symbolic constant value representing the texture combiner two's alpha operand. The initial value is <em>?GL_SRC_ALPHA</em>.</p><p><em>?GL_RGB_SCALE</em>: <em>Params</em> returns a single floating-point value representing the current RGB texture combiner scaling factor. The initial value is 1.0.</p><p><em>?GL_ALPHA_SCALE</em>: <em>Params</em> returns a single floating-point value representing the current alpha texture combiner scaling factor. The initial value is 1.0.</p><p><em>?GL_COORD_REPLACE</em>: <em>Params</em> returns a single boolean value representing the current point sprite texture coordinate replacement enable state. The initial value is <em>?GL_FALSE</em> .</p><p>See external documentation.</p><p><strong></strong> getTexEnviv(Target, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>See <strong>getTexEnvfv/2</strong></p><p><strong></strong> texParameterf(Target, Pname, Param) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Param = float()</p><p>Set texture parameters</p><p><em>gl:texParameter</em> assigns the value or values in <em>Params</em> to the texture parameter specified as <em>Pname</em> . <em>Target</em> defines the target texture, either <em>?GL_TEXTURE_1D</em> , <em>?GL_TEXTURE_2D</em>, <em>?GL_TEXTURE_1D_ARRAY</em>, <em>?GL_TEXTURE_2D_ARRAY</em>, <em>?GL_TEXTURE_RECTANGLE</em> , or <em>?GL_TEXTURE_3D</em>. The following symbols are accepted in <em>Pname</em> :</p><p><em>?GL_TEXTURE_BASE_LEVEL</em>: Specifies the index of the lowest defined mipmap level. This is an integer value. The initial value is 0.</p><p><em>?GL_TEXTURE_BORDER_COLOR</em>: The data in <em>Params</em> specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of <em>?GL_TEXTURE_BORDER_COLOR</em> are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of <em>?GL_TEXTURE_BORDER_COLOR</em> is interpreted as a depth value. The initial value is ( 0.0, 0.0, 0.0, 0.0 ).</p><p>If the values for <em>?GL_TEXTURE_BORDER_COLOR</em> are specified with <em>gl:texParameterIiv</em> or <em>gl:texParameterIuiv</em>, the values are stored unmodified with an internal data type of integer. If specified with <em>gl:texParameteriv</em>, they are converted to floating point with the following equation: f=2 c+1 2 b-/1. If specified with <em>gl:texParameterfv</em> , they are stored unmodified as floating-point values.</p><p><em>?GL_TEXTURE_COMPARE_FUNC</em>: Specifies the comparison operator used when <em>?GL_TEXTURE_COMPARE_MODE</em> is set to <em>?GL_COMPARE_REF_TO_TEXTURE</em>. Permissible values are:<em>Texture Comparison Function</em><em>Computed result</em></p><p><em>?GL_LEQUAL</em> result={1.0 0.0 r&lt;=(D t) r&gt;(D t))</p><p><em>?GL_GEQUAL</em> result={1.0 0.0 r&gt;=(D t) r&lt;(D t))</p><p><em>?GL_LESS</em> result={1.0 0.0 r&lt;(D t) r&gt;=(D t))</p><p><em>?GL_GREATER</em> result={1.0 0.0 r&gt;(D t) r&lt;=(D t))</p><p><em>?GL_EQUAL</em> result={1.0 0.0 r=(D t) r&ne; (D t))</p><p><em>?GL_NOTEQUAL</em> result={1.0 0.0 r&ne;(D t) r=(D t))</p><p><em>?GL_ALWAYS</em> result=1.0</p><p><em>?GL_NEVER</em> result=0.0</p><p>where r is the current interpolated texture coordinate, and D t is the depth texture value sampled from the currently bound depth texture. result is assigned to the the red channel.</p><p><em>?GL_TEXTURE_COMPARE_MODE</em>: Specifies the texture comparison mode for currently bound depth textures. That is, a texture whose internal format is <em>?GL_DEPTH_COMPONENT_*</em> ; see <strong>gl:texImage2D/9</strong> ) Permissible values are:</p><p><em>?GL_COMPARE_REF_TO_TEXTURE</em>: Specifies that the interpolated and clamped r texture coordinate should be compared to the value in the currently bound depth texture. See the discussion of <em>?GL_TEXTURE_COMPARE_FUNC</em> for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.</p><p><em>?GL_NONE</em>: Specifies that the red channel should be assigned the appropriate value from the currently bound depth texture.</p><p><em>?GL_TEXTURE_LOD_BIAS</em>: <em>Params</em> specifies a fixed bias value that is to be added to the level-of-detail parameter for the texture before texture sampling. The specified value is added to the shader-supplied bias value (if any) and subsequently clamped into the implementation-defined range [( - bias max)(bias max)], where bias max is the value of the implementation defined constant <em>?GL_MAX_TEXTURE_LOD_BIAS</em>. The initial value is 0.0.</p><p><em>?GL_TEXTURE_MIN_FILTER</em>: The texture minifying function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be minified. There are six defined minifying functions. Two of them use either the nearest texture elements or a weighted average of multiple texture elements to compute the texture value. The other four use mipmaps.</p><p>A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2 n×2 m, there are max(n m)+1 mipmaps. The first mipmap is the original texture, with dimensions 2 n×2 m. Each subsequent mipmap has dimensions 2(k-1)×2(l-1), where 2 k×2 l are the dimensions of the previous mipmap, until either k=0 or l=0. At that point, subsequent mipmaps have dimension 1×2(l-1) or 2(k-1)×1 until the final mipmap, which has dimension 1×1. To define the mipmaps, call <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:copyTexImage1D/7</strong> , or <strong>gl:copyTexImage2D/8</strong> with the <em>level</em> argument indicating the order of the mipmaps. Level 0 is the original texture; level max(n m) is the final 1×1 mipmap.</p><p><em>Params</em> supplies a function for minifying the texture as one of the following:</p><p><em>?GL_NEAREST</em>: Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.</p><p><em>?GL_LINEAR</em>: Returns the weighted average of the four texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of <em>?GL_TEXTURE_WRAP_S</em> and <em>?GL_TEXTURE_WRAP_T</em> , and on the exact mapping.</p><p><em>?GL_NEAREST_MIPMAP_NEAREST</em>: Chooses the mipmap that most closely matches the size of the pixel being textured and uses the <em>?GL_NEAREST</em> criterion (the texture element closest to the specified texture coordinates) to produce a texture value.</p><p><em>?GL_LINEAR_MIPMAP_NEAREST</em>: Chooses the mipmap that most closely matches the size of the pixel being textured and uses the <em>?GL_LINEAR</em> criterion (a weighted average of the four texture elements that are closest to the specified texture coordinates) to produce a texture value.</p><p><em>?GL_NEAREST_MIPMAP_LINEAR</em>: Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the <em>?GL_NEAREST</em> criterion (the texture element closest to the specified texture coordinates ) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.</p><p><em>?GL_LINEAR_MIPMAP_LINEAR</em>: Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the <em>?GL_LINEAR</em> criterion (a weighted average of the texture elements that are closest to the specified texture coordinates) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.</p><p>As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the <em>?GL_NEAREST</em> and <em>?GL_LINEAR</em> minification functions can be faster than the other four, they sample only one or multiple texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of <em>?GL_TEXTURE_MIN_FILTER</em> is <em>?GL_NEAREST_MIPMAP_LINEAR</em> .</p><p><em>?GL_TEXTURE_MAG_FILTER</em>: The texture magnification function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be magified. It sets the texture magnification function to either <em>?GL_NEAREST</em> or <em>?GL_LINEAR</em> (see below). <em>?GL_NEAREST</em> is generally faster than <em>?GL_LINEAR</em> , but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of <em>?GL_TEXTURE_MAG_FILTER</em> is <em>?GL_LINEAR</em> .</p><p><em>?GL_NEAREST</em>: Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.</p><p><em>?GL_LINEAR</em>: Returns the weighted average of the texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of <em>?GL_TEXTURE_WRAP_S</em> and <em>?GL_TEXTURE_WRAP_T</em> , and on the exact mapping.</p><p><em>?GL_TEXTURE_MIN_LOD</em>: Sets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.</p><p><em>?GL_TEXTURE_MAX_LOD</em>: Sets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.</p><p><em>?GL_TEXTURE_MAX_LEVEL</em>: Sets the index of the highest defined mipmap level. This is an integer value. The initial value is 1000.</p><p><em>?GL_TEXTURE_SWIZZLE_R</em>: Sets the swizzle that will be applied to the r component of a texel before it is returned to the shader. Valid values for <em>Param</em> are <em>?GL_RED</em> , <em>?GL_GREEN</em>, <em>?GL_BLUE</em>, <em>?GL_ALPHA</em>, <em>?GL_ZERO</em> and <em>?GL_ONE</em>. If <em>?GL_TEXTURE_SWIZZLE_R</em> is <em>?GL_RED</em>, the value for r will be taken from the first channel of the fetched texel. If <em>?GL_TEXTURE_SWIZZLE_R</em> is <em>?GL_GREEN</em> , the value for r will be taken from the second channel of the fetched texel. If <em>?GL_TEXTURE_SWIZZLE_R</em> is <em>?GL_BLUE</em>, the value for r will be taken from the third channel of the fetched texel. If <em>?GL_TEXTURE_SWIZZLE_R</em> is <em>?GL_ALPHA</em>, the value for r will be taken from the fourth channel of the fetched texel. If <em>?GL_TEXTURE_SWIZZLE_R</em> is <em>?GL_ZERO</em> , the value for r will be subtituted with 0.0. If <em>?GL_TEXTURE_SWIZZLE_R</em> is <em>?GL_ONE</em> , the value for r will be subtituted with 1.0. The initial value is <em>?GL_RED</em>.</p><p><em>?GL_TEXTURE_SWIZZLE_G</em>: Sets the swizzle that will be applied to the g component of a texel before it is returned to the shader. Valid values for <em>Param</em> and their effects are similar to those of <em>?GL_TEXTURE_SWIZZLE_R</em>. The initial value is <em>?GL_GREEN</em> .</p><p><em>?GL_TEXTURE_SWIZZLE_B</em>: Sets the swizzle that will be applied to the b component of a texel before it is returned to the shader. Valid values for <em>Param</em> and their effects are similar to those of <em>?GL_TEXTURE_SWIZZLE_R</em>. The initial value is <em>?GL_BLUE</em> .</p><p><em>?GL_TEXTURE_SWIZZLE_A</em>: Sets the swizzle that will be applied to the a component of a texel before it is returned to the shader. Valid values for <em>Param</em> and their effects are similar to those of <em>?GL_TEXTURE_SWIZZLE_R</em>. The initial value is <em>?GL_ALPHA</em> .</p><p><em>?GL_TEXTURE_SWIZZLE_RGBA</em>: Sets the swizzles that will be applied to the r, g, b, and a components of a texel before they are returned to the shader. Valid values for <em>Params</em> and their effects are similar to those of <em>?GL_TEXTURE_SWIZZLE_R</em>, except that all channels are specified simultaneously. Setting the value of <em>?GL_TEXTURE_SWIZZLE_RGBA</em> is equivalent (assuming no errors are generated) to setting the parameters of each of <em>?GL_TEXTURE_SWIZZLE_R</em> , <em>?GL_TEXTURE_SWIZZLE_G</em>, <em>?GL_TEXTURE_SWIZZLE_B</em>, and <em>?GL_TEXTURE_SWIZZLE_A</em> successively.</p><p><em>?GL_TEXTURE_WRAP_S</em>: Sets the wrap parameter for texture coordinate s to either <em>?GL_CLAMP_TO_EDGE</em> , <em>?GL_CLAMP_TO_BORDER</em>, <em>?GL_MIRRORED_REPEAT</em>, or <em>?GL_REPEAT</em>. <em>?GL_CLAMP_TO_EDGE</em> causes s coordinates to be clamped to the range [(1 2/N) 1-(1 2/N)], where N is the size of the texture in the direction of clamping. <em>?GL_CLAMP_TO_BORDER</em> evaluates s coordinates in a similar manner to <em>?GL_CLAMP_TO_EDGE</em>. However, in cases where clamping would have occurred in <em>?GL_CLAMP_TO_EDGE</em> mode, the fetched texel data is substituted with the values specified by <em>?GL_TEXTURE_BORDER_COLOR</em>. <em>?GL_REPEAT</em> causes the integer part of the s coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. <em>?GL_MIRRORED_REPEAT</em> causes the s coordinate to be set to the fractional part of the texture coordinate if the integer part of s is even; if the integer part of s is odd, then the s texture coordinate is set to 1- frac(s), where frac(s) represents the fractional part of s. Initially, <em>?GL_TEXTURE_WRAP_S</em> is set to <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_WRAP_T</em>: Sets the wrap parameter for texture coordinate t to either <em>?GL_CLAMP_TO_EDGE</em> , <em>?GL_CLAMP_TO_BORDER</em>, <em>?GL_MIRRORED_REPEAT</em>, or <em>?GL_REPEAT</em>. See the discussion under <em>?GL_TEXTURE_WRAP_S</em>. Initially, <em>?GL_TEXTURE_WRAP_T</em> is set to <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_WRAP_R</em>: Sets the wrap parameter for texture coordinate r to either <em>?GL_CLAMP_TO_EDGE</em> , <em>?GL_CLAMP_TO_BORDER</em>, <em>?GL_MIRRORED_REPEAT</em>, or <em>?GL_REPEAT</em>. See the discussion under <em>?GL_TEXTURE_WRAP_S</em>. Initially, <em>?GL_TEXTURE_WRAP_R</em> is set to <em>?GL_REPEAT</em>.</p><p>See external documentation.</p><p><strong></strong> texParameteri(Target, Pname, Param) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>texParameterf/3</strong></p><p><strong></strong> texParameterfv(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {float()}</p><p>See <strong>texParameterf/3</strong></p><p><strong></strong> texParameteriv(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>texParameterf/3</strong></p><p><strong></strong> getTexParameterfv(Target, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Return texture parameter values</p><p><em>gl:getTexParameter</em> returns in <em>Params</em> the value or values of the texture parameter specified as <em>Pname</em> . <em>Target</em> defines the target texture. <em>?GL_TEXTURE_1D</em>, <em>?GL_TEXTURE_2D</em>, <em>?GL_TEXTURE_3D</em>, <em>?GL_TEXTURE_1D_ARRAY</em>, <em>?GL_TEXTURE_2D_ARRAY</em> , <em>?GL_TEXTURE_RECTANGLE</em>, <em>?GL_TEXTURE_CUBE_MAP</em>, <em>?GL_TEXTURE_CUBE_MAP_ARRAY</em> specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional array, rectangle, cube-mapped or cube-mapped array texturing, respectively. <em>Pname</em> accepts the same symbols as <strong>gl:texParameterf/3</strong> , with the same interpretations:</p><p><em>?GL_TEXTURE_MAG_FILTER</em>: Returns the single-valued texture magnification filter, a symbolic constant. The initial value is <em>?GL_LINEAR</em>.</p><p><em>?GL_TEXTURE_MIN_FILTER</em>: Returns the single-valued texture minification filter, a symbolic constant. The initial value is <em>?GL_NEAREST_MIPMAP_LINEAR</em>.</p><p><em>?GL_TEXTURE_MIN_LOD</em>: Returns the single-valued texture minimum level-of-detail value. The initial value is -1000.</p><p><em>?GL_TEXTURE_MAX_LOD</em>: Returns the single-valued texture maximum level-of-detail value. The initial value is 1000.</p><p><em>?GL_TEXTURE_BASE_LEVEL</em>: Returns the single-valued base texture mipmap level. The initial value is 0.</p><p><em>?GL_TEXTURE_MAX_LEVEL</em>: Returns the single-valued maximum texture mipmap array level. The initial value is 1000.</p><p><em>?GL_TEXTURE_SWIZZLE_R</em>: Returns the red component swizzle. The initial value is <em>?GL_RED</em> .</p><p><em>?GL_TEXTURE_SWIZZLE_G</em>: Returns the green component swizzle. The initial value is <em>?GL_GREEN</em> .</p><p><em>?GL_TEXTURE_SWIZZLE_B</em>: Returns the blue component swizzle. The initial value is <em>?GL_BLUE</em> .</p><p><em>?GL_TEXTURE_SWIZZLE_A</em>: Returns the alpha component swizzle. The initial value is <em>?GL_ALPHA</em> .</p><p><em>?GL_TEXTURE_SWIZZLE_RGBA</em>: Returns the component swizzle for all channels in a single query.</p><p><em>?GL_TEXTURE_WRAP_S</em>: Returns the single-valued wrapping function for texture coordinate s, a symbolic constant. The initial value is <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_WRAP_T</em>: Returns the single-valued wrapping function for texture coordinate t, a symbolic constant. The initial value is <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_WRAP_R</em>: Returns the single-valued wrapping function for texture coordinate r, a symbolic constant. The initial value is <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_BORDER_COLOR</em>: Returns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range [0 1]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and -1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).</p><p><em>?GL_TEXTURE_COMPARE_MODE</em>: Returns a single-valued texture comparison mode, a symbolic constant. The initial value is <em>?GL_NONE</em>. See <strong>gl:texParameterf/3</strong> .</p><p><em>?GL_TEXTURE_COMPARE_FUNC</em>: Returns a single-valued texture comparison function, a symbolic constant. The initial value is <em>?GL_LEQUAL</em>. See <strong>gl:texParameterf/3</strong> .</p><p>In addition to the parameters that may be set with <strong>gl:texParameterf/3</strong> , <em>gl:getTexParameter</em> accepts the following read-only parameters:</p><p><em>?GL_TEXTURE_IMMUTABLE_FORMAT</em>: Returns non-zero if the texture has an immutable format. Textures become immutable if their storage is specified with <strong>gl:texStorage1D/4</strong> , <strong>gl:texStorage2D/5</strong> or <strong>gl:texStorage3D/6</strong> . The initial value is <em>?GL_FALSE</em> .</p><p>See external documentation.</p><p><strong></strong> getTexParameteriv(Target, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>See <strong>getTexParameterfv/2</strong></p><p><strong></strong> getTexLevelParameterfv(Target, Level, Pname) -&gt; {float()}</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Pname = enum()</p><p>Return texture parameter values for a specific level of detail</p><p><em>gl:getTexLevelParameter</em> returns in <em>Params</em> texture parameter values for a specific level-of-detail value, specified as <em>Level</em> . <em>Target</em> defines the target texture, either <em>?GL_TEXTURE_1D</em>, <em>?GL_TEXTURE_2D</em>, <em>?GL_TEXTURE_3D</em>, <em>?GL_PROXY_TEXTURE_1D</em> , <em>?GL_PROXY_TEXTURE_2D</em>, <em>?GL_PROXY_TEXTURE_3D</em>, <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_X</em> , <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_X</em>, <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Y</em>, <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</em> , <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Z</em>, <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</em>, or <em>?GL_PROXY_TEXTURE_CUBE_MAP</em> .</p><p><em>?GL_MAX_TEXTURE_SIZE</em>, and <em>?GL_MAX_3D_TEXTURE_SIZE</em> are not really descriptive enough. It has to report the largest square texture image that can be accommodated with mipmaps and borders, but a long skinny texture, or a texture without mipmaps and borders, may easily fit in texture memory. The proxy targets allow the user to more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot be accommodated, the texture state variables, which may be queried with <em>gl:getTexLevelParameter</em> , are set to 0. If the texture can be accommodated, the texture state values will be set as they would be set for a non-proxy target.</p><p><em>Pname</em> specifies the texture parameter whose value or values will be returned.</p><p>The accepted parameter names are as follows:</p><p><em>?GL_TEXTURE_WIDTH</em>: <em>Params</em> returns a single value, the width of the texture image. This value includes the border of the texture image. The initial value is 0.</p><p><em>?GL_TEXTURE_HEIGHT</em>: <em>Params</em> returns a single value, the height of the texture image. This value includes the border of the texture image. The initial value is 0.</p><p><em>?GL_TEXTURE_DEPTH</em>: <em>Params</em> returns a single value, the depth of the texture image. This value includes the border of the texture image. The initial value is 0.</p><p><em>?GL_TEXTURE_INTERNAL_FORMAT</em>: <em>Params</em> returns a single value, the internal format of the texture image.</p><p><em>?GL_TEXTURE_RED_TYPE</em>,</p><p><em>?GL_TEXTURE_GREEN_TYPE</em>,</p><p><em>?GL_TEXTURE_BLUE_TYPE</em>,</p><p><em>?GL_TEXTURE_ALPHA_TYPE</em>,</p><p><em>?GL_TEXTURE_DEPTH_TYPE</em>: The data type used to store the component. The types <em>?GL_NONE</em> , <em>?GL_SIGNED_NORMALIZED</em>, <em>?GL_UNSIGNED_NORMALIZED</em>, <em>?GL_FLOAT</em>, <em>?GL_INT</em> , and <em>?GL_UNSIGNED_INT</em> may be returned to indicate signed normalized fixed-point, unsigned normalized fixed-point, floating-point, integer unnormalized, and unsigned integer unnormalized components, respectively.</p><p><em>?GL_TEXTURE_RED_SIZE</em>,</p><p><em>?GL_TEXTURE_GREEN_SIZE</em>,</p><p><em>?GL_TEXTURE_BLUE_SIZE</em>,</p><p><em>?GL_TEXTURE_ALPHA_SIZE</em>,</p><p><em>?GL_TEXTURE_DEPTH_SIZE</em>: The internal storage resolution of an individual component. The resolution chosen by the GL will be a close match for the resolution requested by the user with the component argument of <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:copyTexImage1D/7</strong> , and <strong>gl:copyTexImage2D/8</strong> . The initial value is 0.</p><p><em>?GL_TEXTURE_COMPRESSED</em>: <em>Params</em> returns a single boolean value indicating if the texture image is stored in a compressed internal format. The initiali value is <em>?GL_FALSE</em> .</p><p><em>?GL_TEXTURE_COMPRESSED_IMAGE_SIZE</em>: <em>Params</em> returns a single integer value, the number of unsigned bytes of the compressed texture image that would be returned from <strong>gl:getCompressedTexImage/3</strong> .</p><p>See external documentation.</p><p><strong></strong> getTexLevelParameteriv(Target, Level, Pname) -&gt; {integer()}</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Pname = enum()</p><p>See <strong>getTexLevelParameterfv/3</strong></p><p><strong></strong> texImage1D(Target, Level, InternalFormat, Width, Border, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Border = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = offset() | mem()</p><p>Specify a one-dimensional texture image</p><p>Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable one-dimensional texturing, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_TEXTURE_1D</em>.</p><p>Texture images are defined with <em>gl:texImage1D</em>. The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see <strong>gl:texParameterf/3</strong> ), and the internal resolution and format used to store the image. The last three arguments describe how the image is represented in memory.</p><p>If <em>Target</em> is <em>?GL_PROXY_TEXTURE_1D</em>, no data is read from <em>Data</em> , but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see <strong>gl:getError/0</strong> ). To query for an entire mipmap array, use an image array level greater than or equal to 1.</p><p>If <em>Target</em> is <em>?GL_TEXTURE_1D</em>, data is read from <em>Data</em> as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on <em>Type</em> . These values are grouped into sets of one, two, three, or four values, depending on <em>Format</em> , to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by <em>?GL_UNPACK_LSB_FIRST</em> (see <strong>gl:pixelStoref/2</strong> ).</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>The first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right through the remaining texels in the texture array. The final element corresponds to the right end of the texture array.</p><p><em>Format</em> determines the composition of each element in <em>Data</em> . It can assume one of these symbolic values:</p><p><em>?GL_RED</em>: Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RG</em>: Each element is a single red/green double The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RGB</em></p><p><em>?GL_BGR</em>: Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RGBA</em></p><p><em>?GL_BGRA</em>: Each element contains all four components. Each component is multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_DEPTH_COMPONENT</em>: Each element is a single depth value. The GL converts it to floating point, multiplies by the signed scale factor <em>?GL_DEPTH_SCALE</em>, adds the signed bias <em>?GL_DEPTH_BIAS</em>, and clamps to the range [0,1].</p><p>If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with <em>InternalFormat</em> . The GL will choose an internal representation that closely approximates that requested by <em>InternalFormat</em> , but it may not match exactly. (The representations specified by <em>?GL_RED</em>, <em>?GL_RG</em> , <em>?GL_RGB</em> and <em>?GL_RGBA</em> must match exactly.)</p><p><em>InternalFormat</em> may be one of the base internal formats shown in Table 1, below</p><p><em>InternalFormat</em> may also be one of the sized internal formats shown in Table 2, below</p><p>Finally, <em>InternalFormat</em> may also be one of the generic or compressed compressed texture formats shown in Table 3 below</p><p>If the <em>InternalFormat</em> parameter is one of the generic compressed formats, <em>?GL_COMPRESSED_RED</em> , <em>?GL_COMPRESSED_RG</em>, <em>?GL_COMPRESSED_RGB</em>, or <em>?GL_COMPRESSED_RGBA</em>, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.</p><p>If the <em>InternalFormat</em> parameter is <em>?GL_SRGB</em>, <em>?GL_SRGB8</em>, <em>?GL_SRGB_ALPHA</em> or <em>?GL_SRGB8_ALPHA8</em>, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component c s to a linear component c l is:</p><p>c l={ c s/12.92if c s&le; 0.04045( c s+0.055/1.055) 2.4if c s&gt; 0.04045</p><p>Assume c s is the sRGB component in the range [0,1].</p><p>Use the <em>?GL_PROXY_TEXTURE_1D</em> target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call <strong>gl:getTexLevelParameterfv/3</strong> . If the texture cannot be accommodated, texture state is set to 0.</p><p>A one-component texture image uses only the red component of the RGBA color from <em>Data</em> . A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.</p><p>Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See <strong>gl:texParameterf/3</strong> for details on texture comparison.</p><p>See external documentation.</p><p><strong></strong> texImage2D(Target, Level, InternalFormat, Width, Height, Border, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Border = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = offset() | mem()</p><p>Specify a two-dimensional texture image</p><p>Texturing allows elements of an image array to be read by shaders.</p><p>To define texture images, call <em>gl:texImage2D</em>. The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see <strong>gl:texParameterf/3</strong> ), and number of color components provided. The last three arguments describe how the image is represented in memory.</p><p>If <em>Target</em> is <em>?GL_PROXY_TEXTURE_2D</em>, <em>?GL_PROXY_TEXTURE_1D_ARRAY</em>, <em>?GL_PROXY_TEXTURE_CUBE_MAP</em> , or <em>?GL_PROXY_TEXTURE_RECTANGLE</em>, no data is read from <em>Data</em> , but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see <strong>gl:getError/0</strong> ). To query for an entire mipmap array, use an image array level greater than or equal to 1.</p><p>If <em>Target</em> is <em>?GL_TEXTURE_2D</em>, <em>?GL_TEXTURE_RECTANGLE</em> or one of the <em>?GL_TEXTURE_CUBE_MAP</em> targets, data is read from <em>Data</em> as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on <em>Type</em> . These values are grouped into sets of one, two, three, or four values, depending on <em>Format</em> , to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by <em>?GL_UNPACK_LSB_FIRST</em> (see <strong>gl:pixelStoref/2</strong> ).</p><p>If <em>Target</em> is <em>?GL_TEXTURE_1D_ARRAY</em>, data is interpreted as an array of one-dimensional images.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.</p><p><em>Format</em> determines the composition of each element in <em>Data</em> . It can assume one of these symbolic values:</p><p><em>?GL_RED</em>: Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RG</em>: Each element is a red/green double. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RGB</em></p><p><em>?GL_BGR</em>: Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RGBA</em></p><p><em>?GL_BGRA</em>: Each element contains all four components. Each component is multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_DEPTH_COMPONENT</em>: Each element is a single depth value. The GL converts it to floating point, multiplies by the signed scale factor <em>?GL_DEPTH_SCALE</em>, adds the signed bias <em>?GL_DEPTH_BIAS</em>, and clamps to the range [0,1].</p><p><em>?GL_DEPTH_STENCIL</em>: Each element is a pair of depth and stencil values. The depth component of the pair is interpreted as in <em>?GL_DEPTH_COMPONENT</em>. The stencil component is interpreted based on specified the depth + stencil internal format.</p><p>If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with <em>InternalFormat</em> . The GL will choose an internal representation that closely approximates that requested by <em>InternalFormat</em> , but it may not match exactly. (The representations specified by <em>?GL_RED</em>, <em>?GL_RG</em> , <em>?GL_RGB</em>, and <em>?GL_RGBA</em> must match exactly.)</p><p><em>InternalFormat</em> may be one of the base internal formats shown in Table 1, below</p><p><em>InternalFormat</em> may also be one of the sized internal formats shown in Table 2, below</p><p>Finally, <em>InternalFormat</em> may also be one of the generic or compressed compressed texture formats shown in Table 3 below</p><p>If the <em>InternalFormat</em> parameter is one of the generic compressed formats, <em>?GL_COMPRESSED_RED</em> , <em>?GL_COMPRESSED_RG</em>, <em>?GL_COMPRESSED_RGB</em>, or <em>?GL_COMPRESSED_RGBA</em>, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.</p><p>If the <em>InternalFormat</em> parameter is <em>?GL_SRGB</em>, <em>?GL_SRGB8</em>, <em>?GL_SRGB_ALPHA</em> , or <em>?GL_SRGB8_ALPHA8</em>, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component c s to a linear component c l is:</p><p>c l={ c s/12.92if c s&le; 0.04045( c s+0.055/1.055) 2.4if c s&gt; 0.04045</p><p>Assume c s is the sRGB component in the range [0,1].</p><p>Use the <em>?GL_PROXY_TEXTURE_2D</em>, <em>?GL_PROXY_TEXTURE_1D_ARRAY</em>, <em>?GL_PROXY_TEXTURE_RECTANGLE</em> , or <em>?GL_PROXY_TEXTURE_CUBE_MAP</em> target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call <strong>gl:getTexLevelParameterfv/3</strong> . If the texture cannot be accommodated, texture state is set to 0.</p><p>A one-component texture image uses only the red component of the RGBA color extracted from <em>Data</em> . A two-component image uses the R and G values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.</p><p>Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See <strong>gl:texParameterf/3</strong> for details on texture comparison.</p><p>See external documentation.</p><p><strong></strong> getTexImage(Target, Level, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = mem()</p><p>Return a texture image</p><p><em>gl:getTexImage</em> returns a texture image into <em>Img</em> . <em>Target</em> specifies whether the desired texture image is one specified by <strong>gl:texImage1D/8</strong> (<em>?GL_TEXTURE_1D</em> ), <strong>gl:texImage2D/9</strong> (<em>?GL_TEXTURE_1D_ARRAY</em>, <em>?GL_TEXTURE_RECTANGLE</em>, <em>?GL_TEXTURE_2D</em> or any of <em>?GL_TEXTURE_CUBE_MAP_*</em>), or <strong>gl:texImage3D/10</strong> (<em>?GL_TEXTURE_2D_ARRAY</em> , <em>?GL_TEXTURE_3D</em>). <em>Level</em> specifies the level-of-detail number of the desired image. <em>Format</em> and <em>Type</em> specify the format and type of the desired image array. See the reference page for <strong>gl:texImage1D/8</strong> for a description of the acceptable values for the <em>Format</em> and <em>Type</em> parameters, respectively.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is requested, <em>Img</em> is treated as a byte offset into the buffer object's data store.</p><p>To understand the operation of <em>gl:getTexImage</em>, consider the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of <em>gl:getTexImage</em> are then identical to those of <strong>gl:readPixels/7</strong> , with the exception that no pixel transfer operations are performed, when called with the same <em>Format</em> and <em>Type</em> , with <em>x</em> and <em>y</em> set to 0, <em>width</em> set to the width of the texture image and <em>height</em> set to 1 for 1D images, or to the height of the texture image for 2D images.</p><p>If the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to 1.</p><p>To determine the required size of <em>Img</em> , use <strong>gl:getTexLevelParameterfv/3</strong> to determine the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on <em>Format</em> and <em>Type</em> . Be sure to take the pixel storage parameters into account, especially <em>?GL_PACK_ALIGNMENT</em> .</p><p>See external documentation.</p><p><strong></strong> genTextures(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>Generate texture names</p><p><em>gl:genTextures</em> returns <em>N</em> texture names in <em>Textures</em> . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to <em>gl:genTextures</em>.</p><p>The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see <strong>gl:bindTexture/2</strong> ).</p><p>Texture names returned by a call to <em>gl:genTextures</em> are not returned by subsequent calls, unless they are first deleted with <strong>gl:deleteTextures/1</strong> .</p><p>See external documentation.</p><p><strong></strong> deleteTextures(Textures) -&gt; ok</p><p>Types:</p><p>Textures = [integer()]</p><p>Delete named textures</p><p><em>gl:deleteTextures</em> deletes <em>N</em> textures named by the elements of the array <em>Textures</em> . After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by <strong>gl:genTextures/1</strong> ). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture).</p><p><em>gl:deleteTextures</em> silently ignores 0's and names that do not correspond to existing textures.</p><p>See external documentation.</p><p><strong></strong> bindTexture(Target, Texture) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Texture = integer()</p><p>Bind a named texture to a texturing target</p><p><em>gl:bindTexture</em> lets you create or use a named texture. Calling <em>gl:bindTexture</em> with <em>Target</em> set to <em>?GL_TEXTURE_1D</em>, <em>?GL_TEXTURE_2D</em>, <em>?GL_TEXTURE_3D</em> , or <em>?GL_TEXTURE_1D_ARRAY</em>, <em>?GL_TEXTURE_2D_ARRAY</em>, <em>?GL_TEXTURE_RECTANGLE</em> , <em>?GL_TEXTURE_CUBE_MAP</em>, <em>?GL_TEXTURE_2D_MULTISAMPLE</em> or <em>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</em> and <em>Texture</em> set to the name of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for that target is automatically broken.</p><p>Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.</p><p>You must use <strong>gl:genTextures/1</strong> to generate a set of new texture names.</p><p>When a texture is first bound, it assumes the specified target: A texture first bound to <em>?GL_TEXTURE_1D</em> becomes one-dimensional texture, a texture first bound to <em>?GL_TEXTURE_2D</em> becomes two-dimensional texture, a texture first bound to <em>?GL_TEXTURE_3D</em> becomes three-dimensional texture, a texture first bound to <em>?GL_TEXTURE_1D_ARRAY</em> becomes one-dimensional array texture, a texture first bound to <em>?GL_TEXTURE_2D_ARRAY</em> becomes two-dimensional arary texture, a texture first bound to <em>?GL_TEXTURE_RECTANGLE</em> becomes rectangle texture, a, texture first bound to <em>?GL_TEXTURE_CUBE_MAP</em> becomes a cube-mapped texture, a texture first bound to <em>?GL_TEXTURE_2D_MULTISAMPLE</em> becomes a two-dimensional multisampled texture, and a texture first bound to <em>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</em> becomes a two-dimensional multisampled array texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the default <em>?GL_TEXTURE_1D</em> at GL initialization, and similarly for the other texture types.</p><p>While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.</p><p>A texture binding created with <em>gl:bindTexture</em> remains active until a different texture is bound to the same target, or until the bound texture is deleted with <strong>gl:deleteTextures/1</strong> .</p><p>Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use <em>gl:bindTexture</em> to bind an existing named texture to one of the texture targets than it is to reload the texture image using <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> or another similar function.</p><p>See external documentation.</p><p><strong></strong> prioritizeTextures(Textures, Priorities) -&gt; ok</p><p>Types:</p><p>Textures = [integer()]</p><p>Priorities = [clamp()]</p><p>Set texture residence priority</p><p><em>gl:prioritizeTextures</em> assigns the <em>N</em> texture priorities given in <em>Priorities</em> to the <em>N</em> textures named in <em>Textures</em> .</p><p>The GL establishes a <em>working set</em> of textures that are resident in texture memory. These textures may be bound to a texture target much more efficiently than textures that are not resident. By specifying a priority for each texture, <em>gl:prioritizeTextures</em> allows applications to guide the GL implementation in determining which textures should be resident.</p><p>The priorities given in <em>Priorities</em> are clamped to the range [0 1] before they are assigned. 0 indicates the lowest priority; textures with priority 0 are least likely to be resident. 1 indicates the highest priority; textures with priority 1 are most likely to be resident. However, textures are not guaranteed to be resident until they are used.</p><p><em>gl:prioritizeTextures</em> silently ignores attempts to prioritize texture 0 or any texture name that does not correspond to an existing texture.</p><p><em>gl:prioritizeTextures</em> does not require that any of the textures named by <em>Textures</em> be bound to a texture target. <strong>gl:texParameterf/3</strong> may also be used to set a texture's priority, but only if the texture is currently bound. This is the only way to set the priority of a default texture.</p><p>See external documentation.</p><p><strong></strong> areTexturesResident(Textures) -&gt; {0 | 1, Residences::[0 | 1]}</p><p>Types:</p><p>Textures = [integer()]</p><p>Determine if textures are loaded in texture memory</p><p>GL establishes a <em>working set</em> of textures that are resident in texture memory. These textures can be bound to a texture target much more efficiently than textures that are not resident.</p><p><em>gl:areTexturesResident</em> queries the texture residence status of the <em>N</em> textures named by the elements of <em>Textures</em> . If all the named textures are resident, <em>gl:areTexturesResident</em> returns <em>?GL_TRUE</em>, and the contents of <em>Residences</em> are undisturbed. If not all the named textures are resident, <em>gl:areTexturesResident</em> returns <em>?GL_FALSE</em>, and detailed status is returned in the <em>N</em> elements of <em>Residences</em> . If an element of <em>Residences</em> is <em>?GL_TRUE</em>, then the texture named by the corresponding element of <em>Textures</em> is resident.</p><p>The residence status of a single bound texture may also be queried by calling <strong>gl:getTexParameterfv/2</strong> with the <em>target</em> argument set to the target to which the texture is bound, and the <em>pname</em> argument set to <em>?GL_TEXTURE_RESIDENT</em>. This is the only way that the residence status of a default texture can be queried.</p><p>See external documentation.</p><p><strong></strong> isTexture(Texture) -&gt; 0 | 1</p><p>Types:</p><p>Texture = integer()</p><p>Determine if a name corresponds to a texture</p><p><em>gl:isTexture</em> returns <em>?GL_TRUE</em> if <em>Texture</em> is currently the name of a texture. If <em>Texture</em> is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs, <em>gl:isTexture</em> returns <em>?GL_FALSE</em>.</p><p>A name returned by <strong>gl:genTextures/1</strong> , but not yet associated with a texture by calling <strong>gl:bindTexture/2</strong> , is not the name of a texture.</p><p>See external documentation.</p><p><strong></strong> texSubImage1D(Target, Level, Xoffset, Width, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>Width = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = offset() | mem()</p><p>glTexSubImage</p><p>See external documentation.</p><p><strong></strong> texSubImage2D(Target, Level, Xoffset, Yoffset, Width, Height, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>Yoffset = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = offset() | mem()</p><p>glTexSubImage</p><p>See external documentation.</p><p><strong></strong> copyTexImage1D(Target, Level, Internalformat, X, Y, Width, Border) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Internalformat = enum()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Border = integer()</p><p>Copy pixels into a 1D texture image</p><p><em>gl:copyTexImage1D</em> defines a one-dimensional texture image with pixels from the current <em>?GL_READ_BUFFER</em>.</p><p>The screen-aligned pixel row with left corner at (x y) and with a length of width+2(border) defines the texture array at the mipmap level specified by <em>Level</em> . <em>Internalformat</em> specifies the internal format of the texture array.</p><p>The pixels in the row are processed exactly as if <strong>gl:readPixels/7</strong> had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range [0 1] and then converted to the texture's internal format for storage in the texel array.</p><p>Pixel ordering is such that lower x screen coordinates correspond to lower texture coordinates.</p><p>If any of the pixels within the specified row of the current <em>?GL_READ_BUFFER</em> are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined.</p><p><em>gl:copyTexImage1D</em> defines a one-dimensional texture image with pixels from the current <em>?GL_READ_BUFFER</em>.</p><p>When <em>Internalformat</em> is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the <em>gl:pixelMap</em> function can be used to accomplish the conversion.</p><p>See external documentation.</p><p><strong></strong> copyTexImage2D(Target, Level, Internalformat, X, Y, Width, Height, Border) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Internalformat = enum()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Border = integer()</p><p>Copy pixels into a 2D texture image</p><p><em>gl:copyTexImage2D</em> defines a two-dimensional texture image, or cube-map texture image with pixels from the current <em>?GL_READ_BUFFER</em>.</p><p>The screen-aligned pixel rectangle with lower left corner at ( <em>X</em> , <em>Y</em> ) and with a width of width+2(border) and a height of height+2(border) defines the texture array at the mipmap level specified by <em>Level</em> . <em>Internalformat</em> specifies the internal format of the texture array.</p><p>The pixels in the rectangle are processed exactly as if <strong>gl:readPixels/7</strong> had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range [0 1] and then converted to the texture's internal format for storage in the texel array.</p><p>Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates.</p><p>If any of the pixels within the specified rectangle of the current <em>?GL_READ_BUFFER</em> are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined.</p><p>When <em>Internalformat</em> is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the <em>gl:pixelMap</em> function can be used to accomplish the conversion.</p><p>See external documentation.</p><p><strong></strong> copyTexSubImage1D(Target, Level, Xoffset, X, Y, Width) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Copy a one-dimensional texture subimage</p><p><em>gl:copyTexSubImage1D</em> replaces a portion of a one-dimensional texture image with pixels from the current <em>?GL_READ_BUFFER</em> (rather than from main memory, as is the case for <strong>gl:texSubImage1D/7</strong> ).</p><p>The screen-aligned pixel row with left corner at ( <em>X</em> , <em>Y</em> ), and with length <em>Width</em> replaces the portion of the texture array with x indices <em>Xoffset</em> through xoffset +width-1, inclusive. The destination in the texture array may not include any texels outside the texture array as it was originally specified.</p><p>The pixels in the row are processed exactly as if <strong>gl:readPixels/7</strong> had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range [0 1] and then converted to the texture's internal format for storage in the texel array.</p><p>It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels within the specified row of the current <em>?GL_READ_BUFFER</em> are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.</p><p>No change is made to the <em>internalformat</em>, <em>width</em>, or <em>border</em> parameters of the specified texture array or to texel values outside the specified subregion.</p><p>See external documentation.</p><p><strong></strong> copyTexSubImage2D(Target, Level, Xoffset, Yoffset, X, Y, Width, Height) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>Yoffset = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Copy a two-dimensional texture subimage</p><p><em>gl:copyTexSubImage2D</em> replaces a rectangular portion of a two-dimensional texture image or cube-map texture image with pixels from the current <em>?GL_READ_BUFFER</em> (rather than from main memory, as is the case for <strong>gl:texSubImage1D/7</strong> ).</p><p>The screen-aligned pixel rectangle with lower left corner at (x y) and with width <em>Width</em> and height <em>Height</em> replaces the portion of the texture array with x indices <em>Xoffset</em> through xoffset+width-1, inclusive, and y indices <em>Yoffset</em> through yoffset+height -1, inclusive, at the mipmap level specified by <em>Level</em> .</p><p>The pixels in the rectangle are processed exactly as if <strong>gl:readPixels/7</strong> had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range [0 1] and then converted to the texture's internal format for storage in the texel array.</p><p>The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.</p><p>If any of the pixels within the specified rectangle of the current <em>?GL_READ_BUFFER</em> are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.</p><p>No change is made to the <em>internalformat</em>, <em>width</em>, <em>height</em>, or <em>border</em> parameters of the specified texture array or to texel values outside the specified subregion.</p><p>See external documentation.</p><p><strong></strong> map1d(Target, U1, U2, Stride, Order, Points) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>U1 = float()</p><p>U2 = float()</p><p>Stride = integer()</p><p>Order = integer()</p><p>Points = binary()</p><p>glMap</p><p>See external documentation.</p><p><strong></strong> map1f(Target, U1, U2, Stride, Order, Points) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>U1 = float()</p><p>U2 = float()</p><p>Stride = integer()</p><p>Order = integer()</p><p>Points = binary()</p><p>glMap</p><p>See external documentation.</p><p><strong></strong> map2d(Target, U1, U2, Ustride, Uorder, V1, V2, Vstride, Vorder, Points) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>U1 = float()</p><p>U2 = float()</p><p>Ustride = integer()</p><p>Uorder = integer()</p><p>V1 = float()</p><p>V2 = float()</p><p>Vstride = integer()</p><p>Vorder = integer()</p><p>Points = binary()</p><p>glMap</p><p>See external documentation.</p><p><strong></strong> map2f(Target, U1, U2, Ustride, Uorder, V1, V2, Vstride, Vorder, Points) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>U1 = float()</p><p>U2 = float()</p><p>Ustride = integer()</p><p>Uorder = integer()</p><p>V1 = float()</p><p>V2 = float()</p><p>Vstride = integer()</p><p>Vorder = integer()</p><p>Points = binary()</p><p>glMap</p><p>See external documentation.</p><p><strong></strong> getMapdv(Target, Query, V) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Query = enum()</p><p>V = mem()</p><p>Return evaluator parameters</p><p><strong>gl:map1d/6</strong> and <strong>gl:map1d/6</strong> define evaluators. <em>gl:getMap</em> returns evaluator parameters. <em>Target</em> chooses a map, <em>Query</em> selects a specific parameter, and <em>V</em> points to storage where the values will be returned.</p><p>The acceptable values for the <em>Target</em> parameter are described in the <strong>gl:map1d/6</strong> and <strong>gl:map1d/6</strong> reference pages.</p><p><em>Query</em> can assume the following values:</p><p><em>?GL_COEFF</em>: <em>V</em> returns the control points for the evaluator function. One-dimensional evaluators return order control points, and two-dimensional evaluators return uorder×vorder control points. Each control point consists of one, two, three, or four integer, single-precision floating-point, or double-precision floating-point values, depending on the type of the evaluator. The GL returns two-dimensional control points in row-major order, incrementing the uorder index quickly and the vorder index after each row. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.</p><p><em>?GL_ORDER</em>: <em>V</em> returns the order of the evaluator function. One-dimensional evaluators return a single value, order. The initial value is 1. Two-dimensional evaluators return two values, uorder and vorder. The initial value is 1,1.</p><p><em>?GL_DOMAIN</em>: <em>V</em> returns the linear u and v mapping parameters. One-dimensional evaluators return two values, u1 and u2, as specified by <strong>gl:map1d/6</strong> . Two-dimensional evaluators return four values ( u1, u2, v1, and v2) as specified by <strong>gl:map1d/6</strong> . Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.</p><p>See external documentation.</p><p><strong></strong> getMapfv(Target, Query, V) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Query = enum()</p><p>V = mem()</p><p>See <strong>getMapdv/3</strong></p><p><strong></strong> getMapiv(Target, Query, V) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Query = enum()</p><p>V = mem()</p><p>See <strong>getMapdv/3</strong></p><p><strong></strong> evalCoord1d(U) -&gt; ok</p><p>Types:</p><p>U = float()</p><p>Evaluate enabled one- and two-dimensional maps</p><p><em>gl:evalCoord1</em> evaluates enabled one-dimensional maps at argument <em>U</em> . <em>gl:evalCoord2</em> does the same for two-dimensional maps using two domain values, <em>U</em> and <em>V</em> . To define a map, call <strong>gl:map1d/6</strong> and <strong>gl:map1d/6</strong> ; to enable and disable it, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> .</p><p>When one of the <em>gl:evalCoord</em> commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if <em>?GL_MAP1_INDEX</em> or <em>?GL_MAP2_INDEX</em> is enabled, a <strong>gl:indexd/1</strong> command is simulated. If <em>?GL_MAP1_COLOR_4</em> or <em>?GL_MAP2_COLOR_4</em> is enabled, a <strong>gl:color3b/3</strong> command is simulated. If <em>?GL_MAP1_NORMAL</em> or <em>?GL_MAP2_NORMAL</em> is enabled, a normal vector is produced, and if any of <em>?GL_MAP1_TEXTURE_COORD_1</em>, <em>?GL_MAP1_TEXTURE_COORD_2</em> , <em>?GL_MAP1_TEXTURE_COORD_3</em>, <em>?GL_MAP1_TEXTURE_COORD_4</em>, <em>?GL_MAP2_TEXTURE_COORD_1</em> , <em>?GL_MAP2_TEXTURE_COORD_2</em>, <em>?GL_MAP2_TEXTURE_COORD_3</em>, or <em>?GL_MAP2_TEXTURE_COORD_4</em> is enabled, then an appropriate <strong>gl:texCoord1d/1</strong> command is simulated.</p><p>For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if <strong>gl:vertex2d/2</strong> commands are interspersed with <em>gl:evalCoord</em> commands, the color, normal, and texture coordinates associated with the <strong>gl:vertex2d/2</strong> commands are not affected by the values generated by the <em>gl:evalCoord</em> commands, but only by the most recent <strong>gl:color3b/3</strong> , <strong>gl:indexd/1</strong> , <strong>gl:normal3b/3</strong> , and <strong>gl:texCoord1d/1</strong> commands.</p><p>No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, <em>?GL_MAP2_TEXTURE_COORD_1</em> and <em>?GL_MAP2_TEXTURE_COORD_2</em> ), then only the evaluation of the map that produces the larger number of coordinates (in this case, <em>?GL_MAP2_TEXTURE_COORD_2</em>) is carried out. <em>?GL_MAP1_VERTEX_4</em> overrides <em>?GL_MAP1_VERTEX_3</em>, and <em>?GL_MAP2_VERTEX_4</em> overrides <em>?GL_MAP2_VERTEX_3</em> , in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the <em>gl:evalCoord</em> command is ignored.</p><p>If you have enabled automatic normal generation, by calling <strong>gl:enable/1</strong> with argument <em>?GL_AUTO_NORMAL</em>, <em>gl:evalCoord2</em> generates surface normals analytically, regardless of the contents or enabling of the <em>?GL_MAP2_NORMAL</em> map. Let</p><p>m=((&PartialD; p)/(&PartialD; u))×((&PartialD; p)/(&PartialD; v))</p><p>Then the generated normal n is n=m/(||m||)</p><p>If automatic normal generation is disabled, the corresponding normal map <em>?GL_MAP2_NORMAL</em> , if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for <em>gl:evalCoord2</em> commands.</p><p>See external documentation.</p><p><strong></strong> evalCoord1f(U) -&gt; ok</p><p>Types:</p><p>U = float()</p><p>See <strong>evalCoord1d/1</strong></p><p><strong></strong> evalCoord1dv(U) -&gt; ok</p><p>Types:</p><p>U = {U::float()}</p><p>Equivalent to <strong>evalCoord1d(U)</strong>.</p><p><strong></strong> evalCoord1fv(U) -&gt; ok</p><p>Types:</p><p>U = {U::float()}</p><p>Equivalent to <strong>evalCoord1f(U)</strong>.</p><p><strong></strong> evalCoord2d(U, V) -&gt; ok</p><p>Types:</p><p>U = float()</p><p>V = float()</p><p>See <strong>evalCoord1d/1</strong></p><p><strong></strong> evalCoord2f(U, V) -&gt; ok</p><p>Types:</p><p>U = float()</p><p>V = float()</p><p>See <strong>evalCoord1d/1</strong></p><p><strong></strong> evalCoord2dv(U) -&gt; ok</p><p>Types:</p><p>U = {U::float(), V::float()}</p><p>Equivalent to <strong>evalCoord2d(U, V)</strong>.</p><p><strong></strong> evalCoord2fv(U) -&gt; ok</p><p>Types:</p><p>U = {U::float(), V::float()}</p><p>Equivalent to <strong>evalCoord2f(U, V)</strong>.</p><p><strong></strong> mapGrid1d(Un, U1, U2) -&gt; ok</p><p>Types:</p><p>Un = integer()</p><p>U1 = float()</p><p>U2 = float()</p><p>Define a one- or two-dimensional mesh</p><p><em>gl:mapGrid</em> and <strong>gl:evalMesh1/3</strong> are used together to efficiently generate and evaluate a series of evenly-spaced map domain values. <strong>gl:evalMesh1/3</strong> steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by <strong>gl:map1d/6</strong> and <strong>gl:map1d/6</strong> .</p><p><em>gl:mapGrid1</em> and <em>gl:mapGrid2</em> specify the linear grid mappings between the i (or i and j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See <strong>gl:map1d/6</strong> and <strong>gl:map1d/6</strong> for details of how u and v coordinates are evaluated.</p><p><em>gl:mapGrid1</em> specifies a single linear mapping such that integer grid coordinate 0 maps exactly to <em>U1</em> , and integer grid coordinate <em>Un</em> maps exactly to <em>U2</em> . All other integer grid coordinates i are mapped so that</p><p>u=i(u2-u1)/un+u1</p><p><em>gl:mapGrid2</em> specifies two such linear mappings. One maps integer grid coordinate i=0 exactly to <em>U1</em> , and integer grid coordinate i=un exactly to <em>U2</em> . The other maps integer grid coordinate j=0 exactly to <em>V1</em> , and integer grid coordinate j=vn exactly to <em>V2</em> . Other integer grid coordinates i and j are mapped such that</p><p>u=i(u2-u1)/un+u1</p><p>v=j(v2-v1)/vn+v1</p><p>The mappings specified by <em>gl:mapGrid</em> are used identically by <strong>gl:evalMesh1/3</strong> and <strong>gl:evalPoint1/1</strong> .</p><p>See external documentation.</p><p><strong></strong> mapGrid1f(Un, U1, U2) -&gt; ok</p><p>Types:</p><p>Un = integer()</p><p>U1 = float()</p><p>U2 = float()</p><p>See <strong>mapGrid1d/3</strong></p><p><strong></strong> mapGrid2d(Un, U1, U2, Vn, V1, V2) -&gt; ok</p><p>Types:</p><p>Un = integer()</p><p>U1 = float()</p><p>U2 = float()</p><p>Vn = integer()</p><p>V1 = float()</p><p>V2 = float()</p><p>See <strong>mapGrid1d/3</strong></p><p><strong></strong> mapGrid2f(Un, U1, U2, Vn, V1, V2) -&gt; ok</p><p>Types:</p><p>Un = integer()</p><p>U1 = float()</p><p>U2 = float()</p><p>Vn = integer()</p><p>V1 = float()</p><p>V2 = float()</p><p>See <strong>mapGrid1d/3</strong></p><p><strong></strong> evalPoint1(I) -&gt; ok</p><p>Types:</p><p>I = integer()</p><p>Generate and evaluate a single point in a mesh</p><p><strong>gl:mapGrid1d/3</strong> and <strong>gl:evalMesh1/3</strong> are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. <em>gl:evalPoint</em> can be used to evaluate a single grid point in the same gridspace that is traversed by <strong>gl:evalMesh1/3</strong> . Calling <em>gl:evalPoint1</em> is equivalent to calling glEvalCoord1( i.&Delta; u+u 1 ); where &Delta; u=(u 2-u 1)/n</p><p>and n, u 1, and u 2 are the arguments to the most recent <strong>gl:mapGrid1d/3</strong> command. The one absolute numeric requirement is that if i=n, then the value computed from i.&Delta; u+u 1 is exactly u 2.</p><p>In the two-dimensional case, <em>gl:evalPoint2</em>, let</p><p>&Delta; u=(u 2-u 1)/n</p><p>&Delta; v=(v 2-v 1)/m</p><p>where n, u 1, u 2, m, v 1, and v 2 are the arguments to the most recent <strong>gl:mapGrid1d/3</strong> command. Then the <em>gl:evalPoint2</em> command is equivalent to calling glEvalCoord2( i. &Delta; u+u 1, j.&Delta; v+v 1 ); The only absolute numeric requirements are that if i=n, then the value computed from i.&Delta; u+u 1 is exactly u 2, and if j=m, then the value computed from j.&Delta; v+v 1 is exactly v 2.</p><p>See external documentation.</p><p><strong></strong> evalPoint2(I, J) -&gt; ok</p><p>Types:</p><p>I = integer()</p><p>J = integer()</p><p>See <strong>evalPoint1/1</strong></p><p><strong></strong> evalMesh1(Mode, I1, I2) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>I1 = integer()</p><p>I2 = integer()</p><p>Compute a one- or two-dimensional grid of points or lines</p><p><strong>gl:mapGrid1d/3</strong> and <em>gl:evalMesh</em> are used in tandem to efficiently generate and evaluate a series of evenly-spaced map domain values. <em>gl:evalMesh</em> steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by <strong>gl:map1d/6</strong> and <strong>gl:map1d/6</strong> . <em>Mode</em> determines whether the resulting vertices are connected as points, lines, or filled polygons.</p><p>In the one-dimensional case, <em>gl:evalMesh1</em>, the mesh is generated as if the following code fragment were executed:</p><p>glBegin( <em>Type</em> ); for ( i = <em>I1</em> ; i &lt;= <em>I2</em> ; i += 1 ) glEvalCoord1( i.&Delta; u+u 1 ); glEnd(); where</p><p>&Delta; u=(u 2-u 1)/n</p><p>and n, u 1, and u 2 are the arguments to the most recent <strong>gl:mapGrid1d/3</strong> command. <em>type</em> is <em>?GL_POINTS</em> if <em>Mode</em> is <em>?GL_POINT</em>, or <em>?GL_LINES</em> if <em>Mode</em> is <em>?GL_LINE</em>.</p><p>The one absolute numeric requirement is that if i=n, then the value computed from i.&Delta; u+u 1 is exactly u 2.</p><p>In the two-dimensional case, <em>gl:evalMesh2</em>, let .cp &Delta; u=(u 2-u 1)/n</p><p>&Delta; v=(v 2-v 1)/m</p><p>where n, u 1, u 2, m, v 1, and v 2 are the arguments to the most recent <strong>gl:mapGrid1d/3</strong> command. Then, if <em>Mode</em> is <em>?GL_FILL</em>, the <em>gl:evalMesh2</em> command is equivalent to:</p><p>for ( j = <em>J1</em> ; j &lt; <em>J2</em> ; j += 1 ) { glBegin( GL_QUAD_STRIP ); for ( i = <em>I1</em> ; i &lt;= <em>I2</em> ; i += 1 ) { glEvalCoord2( i.&Delta; u+u 1, j.&Delta; v+v 1 ); glEvalCoord2( i.&Delta; u+u 1,(j+1).&Delta; v+v 1 ); } glEnd(); }</p><p>If <em>Mode</em> is <em>?GL_LINE</em>, then a call to <em>gl:evalMesh2</em> is equivalent to:</p><p>for ( j = <em>J1</em> ; j &lt;= <em>J2</em> ; j += 1 ) { glBegin( GL_LINE_STRIP ); for ( i = <em>I1</em> ; i &lt;= <em>I2</em> ; i += 1 ) glEvalCoord2( i.&Delta; u+u 1, j.&Delta; v+v 1 ); glEnd(); } for ( i = <em>I1</em> ; i &lt;= <em>I2</em> ; i += 1 ) { glBegin( GL_LINE_STRIP ); for ( j = <em>J1</em> ; j &lt;= <em>J1</em> ; j += 1 ) glEvalCoord2( i.&Delta; u+u 1, j. &Delta; v+v 1 ); glEnd(); }</p><p>And finally, if <em>Mode</em> is <em>?GL_POINT</em>, then a call to <em>gl:evalMesh2</em> is equivalent to:</p><p>glBegin( GL_POINTS ); for ( j = <em>J1</em> ; j &lt;= <em>J2</em> ; j += 1 ) for ( i = <em>I1</em> ; i &lt;= <em>I2</em> ; i += 1 ) glEvalCoord2( i.&Delta; u+u 1, j.&Delta; v+v 1 ); glEnd();</p><p>In all three cases, the only absolute numeric requirements are that if i=n, then the value computed from i.&Delta; u+u 1 is exactly u 2, and if j=m, then the value computed from j.&Delta; v+v 1 is exactly v 2.</p><p>See external documentation.</p><p><strong></strong> evalMesh2(Mode, I1, I2, J1, J2) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>I1 = integer()</p><p>I2 = integer()</p><p>J1 = integer()</p><p>J2 = integer()</p><p>See <strong>evalMesh1/3</strong></p><p><strong></strong> fogf(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = float()</p><p>Specify fog parameters</p><p>Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer clear operations. To enable and disable fog, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_FOG</em>.</p><p><em>gl:fog</em> assigns the value or values in <em>Params</em> to the fog parameter specified by <em>Pname</em> . The following values are accepted for <em>Pname</em> :</p><p><em>?GL_FOG_MODE</em>: <em>Params</em> is a single integer or floating-point value that specifies the equation to be used to compute the fog blend factor, f. Three symbolic constants are accepted: <em>?GL_LINEAR</em>, <em>?GL_EXP</em>, and <em>?GL_EXP2</em>. The equations corresponding to these symbolic constants are defined below. The initial fog mode is <em>?GL_EXP</em>.</p><p><em>?GL_FOG_DENSITY</em>: <em>Params</em> is a single integer or floating-point value that specifies density, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The initial fog density is 1.</p><p><em>?GL_FOG_START</em>: <em>Params</em> is a single integer or floating-point value that specifies start, the near distance used in the linear fog equation. The initial near distance is 0.</p><p><em>?GL_FOG_END</em>: <em>Params</em> is a single integer or floating-point value that specifies end, the far distance used in the linear fog equation. The initial far distance is 1.</p><p><em>?GL_FOG_INDEX</em>: <em>Params</em> is a single integer or floating-point value that specifies i f, the fog color index. The initial fog index is 0.</p><p><em>?GL_FOG_COLOR</em>: <em>Params</em> contains four integer or floating-point values that specify C f, the fog color. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. After conversion, all color components are clamped to the range [0 1]. The initial fog color is (0, 0, 0, 0).</p><p><em>?GL_FOG_COORD_SRC</em>: <em>Params</em> contains either of the following symbolic constants: <em>?GL_FOG_COORD</em> or <em>?GL_FRAGMENT_DEPTH</em>. <em>?GL_FOG_COORD</em> specifies that the current fog coordinate should be used as distance value in the fog color computation. <em>?GL_FRAGMENT_DEPTH</em> specifies that the current fragment depth should be used as distance value in the fog computation.</p><p>Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor f. Factor f is computed in one of three ways, depending on the fog mode. Let c be either the distance in eye coordinate from the origin (in the case that the <em>?GL_FOG_COORD_SRC</em> is <em>?GL_FRAGMENT_DEPTH</em>) or the current fog coordinate (in the case that <em>?GL_FOG_COORD_SRC</em> is <em>?GL_FOG_COORD</em>). The equation for <em>?GL_LINEAR</em> fog is f=(end-c)/(end-start)</p><p>The equation for <em>?GL_EXP</em> fog is f=e(-(density. c))</p><p>The equation for <em>?GL_EXP2</em> fog is f=e(-(density. c)) 2</p><p>Regardless of the fog mode, f is clamped to the range [0 1] after it is computed. Then, if the GL is in RGBA color mode, the fragment's red, green, and blue colors, represented by C r, are replaced by</p><p>(C r)"=f×C r+(1-f)×C f</p><p>Fog does not affect a fragment's alpha component.</p><p>In color index mode, the fragment's color index i r is replaced by</p><p>(i r)"=i r+(1-f)×i f</p><p>See external documentation.</p><p><strong></strong> fogi(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>fogf/2</strong></p><p><strong></strong> fogfv(Pname, Params) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Params = {float()}</p><p>See <strong>fogf/2</strong></p><p><strong></strong> fogiv(Pname, Params) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>fogf/2</strong></p><p><strong></strong> feedbackBuffer(Size, Type, Buffer) -&gt; ok</p><p>Types:</p><p>Size = integer()</p><p>Type = enum()</p><p>Buffer = mem()</p><p>Controls feedback mode</p><p>The <em>gl:feedbackBuffer</em> function controls feedback. Feedback, like selection, is a GL mode. The mode is selected by calling <strong>gl:renderMode/1</strong> with <em>?GL_FEEDBACK</em>. When the GL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using the GL.</p><p><em>gl:feedbackBuffer</em> has three arguments: <em>Buffer</em> is a pointer to an array of floating-point values into which feedback information is placed. <em>Size</em> indicates the size of the array. <em>Type</em> is a symbolic constant describing the information that is fed back for each vertex. <em>gl:feedbackBuffer</em> must be issued before feedback mode is enabled (by calling <strong>gl:renderMode/1</strong> with argument <em>?GL_FEEDBACK</em>). Setting <em>?GL_FEEDBACK</em> without establishing the feedback buffer, or calling <em>gl:feedbackBuffer</em> while the GL is in feedback mode, is an error.</p><p>When <strong>gl:renderMode/1</strong> is called while in feedback mode, it returns the number of entries placed in the feedback array and resets the feedback array pointer to the base of the feedback buffer. The returned value never exceeds <em>Size</em> . If the feedback data required more room than was available in <em>Buffer</em> , <strong>gl:renderMode/1</strong> returns a negative value. To take the GL out of feedback mode, call <strong>gl:renderMode/1</strong> with a parameter value other than <em>?GL_FEEDBACK</em>.</p><p>While in feedback mode, each primitive, bitmap, or pixel rectangle that would be rasterized generates a block of values that are copied into the feedback array. If doing so would cause the number of entries to exceed the maximum, the block is partially written so as to fill the array (if there is any room left at all), and an overflow flag is set. Each block begins with a code indicating the primitive type, followed by values that describe the primitive's vertices and associated data. Entries are also written for bitmaps and pixel rectangles. Feedback occurs after polygon culling and <strong>gl:polygonMode/2</strong> interpretation of polygons has taken place, so polygons that are culled are not returned in the feedback buffer. It can also occur after polygons with more than three edges are broken up into triangles, if the GL implementation renders polygons by performing this decomposition.</p><p>The <strong>gl:passThrough/1</strong> command can be used to insert a marker into the feedback buffer. See <strong>gl:passThrough/1</strong> .</p><p>Following is the grammar for the blocks of values written into the feedback buffer. Each primitive is indicated with a unique identifying value followed by some number of vertices. Polygon entries include an integer value indicating how many vertices follow. A vertex is fed back as some number of floating-point values, as determined by <em>Type</em> . Colors are fed back as four values in RGBA mode and one value in color index mode.</p><p>feedbackList ← feedbackItem feedbackList | feedbackItem</p><p>feedbackItem ← point | lineSegment | polygon | bitmap | pixelRectangle | passThru</p><p>point ←<em>?GL_POINT_TOKEN</em> vertex</p><p>lineSegment ←<em>?GL_LINE_TOKEN</em> vertex vertex | <em>?GL_LINE_RESET_TOKEN</em> vertex vertex</p><p>polygon ←<em>?GL_POLYGON_TOKEN</em> n polySpec</p><p>polySpec ← polySpec vertex | vertex vertex vertex</p><p>bitmap ←<em>?GL_BITMAP_TOKEN</em> vertex</p><p>pixelRectangle ←<em>?GL_DRAW_PIXEL_TOKEN</em> vertex | <em>?GL_COPY_PIXEL_TOKEN</em> vertex</p><p>passThru ←<em>?GL_PASS_THROUGH_TOKEN</em> value</p><p>vertex ← 2d | 3d | 3dColor | 3dColorTexture | 4dColorTexture</p><p>2d ← value value</p><p>3d ← value value value</p><p>3dColor ← value value value color</p><p>3dColorTexture ← value value value color tex</p><p>4dColorTexture ← value value value value color tex</p><p>color ← rgba | index</p><p>rgba ← value value value value</p><p>index ← value</p><p>tex ← value value value value</p><p><em>value</em> is a floating-point number, and <em>n</em> is a floating-point integer giving the number of vertices in the polygon. <em>?GL_POINT_TOKEN</em>, <em>?GL_LINE_TOKEN</em>, <em>?GL_LINE_RESET_TOKEN</em> , <em>?GL_POLYGON_TOKEN</em>, <em>?GL_BITMAP_TOKEN</em>, <em>?GL_DRAW_PIXEL_TOKEN</em>, <em>?GL_COPY_PIXEL_TOKEN</em> and <em>?GL_PASS_THROUGH_TOKEN</em> are symbolic floating-point constants. <em>?GL_LINE_RESET_TOKEN</em> is returned whenever the line stipple pattern is reset. The data returned as a vertex depends on the feedback <em>Type</em> .</p><p>The following table gives the correspondence between <em>Type</em> and the number of values per vertex. <em>k</em> is 1 in color index mode and 4 in RGBA mode.<em>Type</em><em>Coordinates</em><em>Color</em><em>Texture</em><em>Total Number of Values</em></p><p><em>?GL_2D</em><em>x</em>, <em>y</em> 2</p><p><em>?GL_3D</em><em>x</em>, <em>y</em>, <em>z</em> 3</p><p><em>?GL_3D_COLOR</em><em>x</em>, <em>y</em>, <em>z</em> k 3+k</p><p><em>?GL_3D_COLOR_TEXTURE</em><em>x</em>, <em>y</em>, <em>z</em> k 4 7+k</p><p><em>?GL_4D_COLOR_TEXTURE</em><em>x</em>, <em>y</em>, <em>z</em>, <em>w</em> k 4 8+k</p><p>Feedback vertex coordinates are in window coordinates, except <em>w</em>, which is in clip coordinates. Feedback colors are lighted, if lighting is enabled. Feedback texture coordinates are generated, if texture coordinate generation is enabled. They are always transformed by the texture matrix.</p><p>See external documentation.</p><p><strong></strong> passThrough(Token) -&gt; ok</p><p>Types:</p><p>Token = float()</p><p>Place a marker in the feedback buffer</p><p>Feedback is a GL render mode. The mode is selected by calling <strong>gl:renderMode/1</strong> with <em>?GL_FEEDBACK</em>. When the GL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using the GL. See the <strong>gl:feedbackBuffer/3</strong> reference page for a description of the feedback buffer and the values in it.</p><p><em>gl:passThrough</em> inserts a user-defined marker in the feedback buffer when it is executed in feedback mode. <em>Token</em> is returned as if it were a primitive; it is indicated with its own unique identifying value: <em>?GL_PASS_THROUGH_TOKEN</em>. The order of <em>gl:passThrough</em> commands with respect to the specification of graphics primitives is maintained.</p><p>See external documentation.</p><p><strong></strong> selectBuffer(Size, Buffer) -&gt; ok</p><p>Types:</p><p>Size = integer()</p><p>Buffer = mem()</p><p>Establish a buffer for selection mode values</p><p><em>gl:selectBuffer</em> has two arguments: <em>Buffer</em> is a pointer to an array of unsigned integers, and <em>Size</em> indicates the size of the array. <em>Buffer</em> returns values from the name stack (see <strong>gl:initNames/0</strong> , <strong>gl:loadName/1</strong> , <strong>gl:pushName/1</strong> ) when the rendering mode is <em>?GL_SELECT</em> (see <strong>gl:renderMode/1</strong> ). <em>gl:selectBuffer</em> must be issued before selection mode is enabled, and it must not be issued while the rendering mode is <em>?GL_SELECT</em>.</p><p>A programmer can use selection to determine which primitives are drawn into some region of a window. The region is defined by the current modelview and perspective matrices.</p><p>In selection mode, no pixel fragments are produced from rasterization. Instead, if a primitive or a raster position intersects the clipping volume defined by the viewing frustum and the user-defined clipping planes, this primitive causes a selection hit. (With polygons, no hit occurs if the polygon is culled.) When a change is made to the name stack, or when <strong>gl:renderMode/1</strong> is called, a hit record is copied to <em>Buffer</em> if any hits have occurred since the last such event (name stack change or <strong>gl:renderMode/1</strong> call). The hit record consists of the number of names in the name stack at the time of the event, followed by the minimum and maximum depth values of all vertices that hit since the previous event, followed by the name stack contents, bottom name first.</p><p>Depth values (which are in the range [0,1]) are multiplied by 2 32-1, before being placed in the hit record.</p><p>An internal index into <em>Buffer</em> is reset to 0 whenever selection mode is entered. Each time a hit record is copied into <em>Buffer</em> , the index is incremented to point to the cell just past the end of the block of names(emthat is, to the next available cell If the hit record is larger than the number of remaining locations in <em>Buffer</em> , as much data as can fit is copied, and the overflow flag is set. If the name stack is empty when a hit record is copied, that record consists of 0 followed by the minimum and maximum depth values.</p><p>To exit selection mode, call <strong>gl:renderMode/1</strong> with an argument other than <em>?GL_SELECT</em> . Whenever <strong>gl:renderMode/1</strong> is called while the render mode is <em>?GL_SELECT</em>, it returns the number of hit records copied to <em>Buffer</em> , resets the overflow flag and the selection buffer pointer, and initializes the name stack to be empty. If the overflow bit was set when <strong>gl:renderMode/1</strong> was called, a negative hit record count is returned.</p><p>See external documentation.</p><p><strong></strong> initNames() -&gt; ok</p><p>Initialize the name stack</p><p>The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers. <em>gl:initNames</em> causes the name stack to be initialized to its default empty state.</p><p>The name stack is always empty while the render mode is not <em>?GL_SELECT</em>. Calls to <em>gl:initNames</em> while the render mode is not <em>?GL_SELECT</em> are ignored.</p><p>See external documentation.</p><p><strong></strong> loadName(Name) -&gt; ok</p><p>Types:</p><p>Name = integer()</p><p>Load a name onto the name stack</p><p>The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty.</p><p><em>gl:loadName</em> causes <em>Name</em> to replace the value on the top of the name stack.</p><p>The name stack is always empty while the render mode is not <em>?GL_SELECT</em>. Calls to <em>gl:loadName</em> while the render mode is not <em>?GL_SELECT</em> are ignored.</p><p>See external documentation.</p><p><strong></strong> pushName(Name) -&gt; ok</p><p>Types:</p><p>Name = integer()</p><p>Push and pop the name stack</p><p>The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty.</p><p><em>gl:pushName</em> causes <em>Name</em> to be pushed onto the name stack. <strong>gl:pushName/1</strong> pops one name off the top of the stack.</p><p>The maximum name stack depth is implementation-dependent; call <em>?GL_MAX_NAME_STACK_DEPTH</em> to find out the value for a particular implementation. It is an error to push a name onto a full stack or to pop a name off an empty stack. It is also an error to manipulate the name stack between the execution of <strong>gl:'begin'/1</strong> and the corresponding execution of <strong>gl:'begin'/1</strong> . In any of these cases, the error flag is set and no other change is made to GL state.</p><p>The name stack is always empty while the render mode is not <em>?GL_SELECT</em>. Calls to <em>gl:pushName</em> or <strong>gl:pushName/1</strong> while the render mode is not <em>?GL_SELECT</em> are ignored.</p><p>See external documentation.</p><p><strong></strong> popName() -&gt; ok</p><p>See <strong>pushName/1</strong></p><p><strong></strong> blendColor(Red, Green, Blue, Alpha) -&gt; ok</p><p>Types:</p><p>Red = clamp()</p><p>Green = clamp()</p><p>Blue = clamp()</p><p>Alpha = clamp()</p><p>Set the blend color</p><p>The <em>?GL_BLEND_COLOR</em> may be used to calculate the source and destination blending factors. The color components are clamped to the range [0 1] before being stored. See <strong>gl:blendFunc/2</strong> for a complete description of the blending operations. Initially the <em>?GL_BLEND_COLOR</em> is set to (0, 0, 0, 0).</p><p>See external documentation.</p><p><strong></strong> blendEquation(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Specify the equation used for both the RGB blend equation and the Alpha blend equation</p><p>The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function sets both the RGB blend equation and the alpha blend equation to a single equation. <em>gl:blendEquationi</em> specifies the blend equation for a single draw buffer whereas <em>gl:blendEquation</em> sets the blend equation for all draw buffers.</p><p>These equations use the source and destination blend factors specified by either <strong>gl:blendFunc/2</strong> or <strong>gl:blendFuncSeparate/4</strong> . See <strong>gl:blendFunc/2</strong> or <strong>gl:blendFuncSeparate/4</strong> for a description of the various blend factors.</p><p>In the equations that follow, source and destination color components are referred to as (R s G s B s A s) and (R d G d B d A d), respectively. The result color is referred to as (R r G r B r A r). The source and destination blend factors are denoted (s R s G s B s A) and (d R d G d B d A), respectively. For these equations all color components are understood to have values in the range [0 1].<em>Mode</em><em>RGB Components</em><em>Alpha Component</em></p><p><em>?GL_FUNC_ADD</em> Rr=R s s R+R d d R Gr=G s s G+G d d G Br=B s s B+B d d B Ar=A s s A+A d d A</p><p><em>?GL_FUNC_SUBTRACT</em> Rr=R s s R-R d d R Gr=G s s G-G d d G Br=B s s B-B d d B Ar=A s s A-A d d A</p><p><em>?GL_FUNC_REVERSE_SUBTRACT</em> Rr=R d d R-R s s R Gr=G d d G-G s s G Br=B d d B-B s s B Ar=A d d A-A s s A</p><p><em>?GL_MIN</em> Rr=min(R s R d) Gr=min(G s G d) Br=min(B s B d) Ar=min (A s A d)</p><p><em>?GL_MAX</em> Rr=max(R s R d) Gr=max(G s G d) Br=max(B s B d) Ar=max(A s A d)</p><p>The results of these equations are clamped to the range [0 1].</p><p>The <em>?GL_MIN</em> and <em>?GL_MAX</em> equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The <em>?GL_FUNC_ADD</em> equation is useful for antialiasing and transparency, among other things.</p><p>Initially, both the RGB blend equation and the alpha blend equation are set to <em>?GL_FUNC_ADD</em> .</p><p>See external documentation.</p><p><strong></strong> drawRangeElements(Mode, Start, End, Count, Type, Indices) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Start = integer()</p><p>End = integer()</p><p>Count = integer()</p><p>Type = enum()</p><p>Indices = offset() | mem()</p><p>Render primitives from array data</p><p><em>gl:drawRangeElements</em> is a restricted form of <strong>gl:drawElements/4</strong> . <em>Mode</em> , <em>Start</em> , <em>End</em> , and <em>Count</em> match the corresponding arguments to <strong>gl:drawElements/4</strong> , with the additional constraint that all values in the arrays <em>Count</em> must lie between <em>Start</em> and <em>End</em> , inclusive.</p><p>Implementations denote recommended maximum amounts of vertex and index data, which may be queried by calling <strong>gl:getBooleanv/1</strong> with argument <em>?GL_MAX_ELEMENTS_VERTICES</em> and <em>?GL_MAX_ELEMENTS_INDICES</em> . If end-start+1 is greater than the value of <em>?GL_MAX_ELEMENTS_VERTICES</em>, or if <em>Count</em> is greater than the value of <em>?GL_MAX_ELEMENTS_INDICES</em>, then the call may operate at reduced performance. There is no requirement that all vertices in the range [start end] be referenced. However, the implementation may partially process unused vertices, reducing performance from what could be achieved with an optimal index set.</p><p>When <em>gl:drawRangeElements</em> is called, it uses <em>Count</em> sequential elements from an enabled array, starting at <em>Start</em> to construct a sequence of geometric primitives. <em>Mode</em> specifies what kind of primitives are constructed, and how the array elements construct these primitives. If more than one array is enabled, each is used.</p><p>Vertex attributes that are modified by <em>gl:drawRangeElements</em> have an unspecified value after <em>gl:drawRangeElements</em> returns. Attributes that aren't modified maintain their previous values.</p><p>See external documentation.</p><p><strong></strong> texImage3D(Target, Level, InternalFormat, Width, Height, Depth, Border, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Depth = integer()</p><p>Border = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = offset() | mem()</p><p>Specify a three-dimensional texture image</p><p>Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable three-dimensional texturing, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_TEXTURE_3D</em>.</p><p>To define texture images, call <em>gl:texImage3D</em>. The arguments describe the parameters of the texture image, such as height, width, depth, width of the border, level-of-detail number (see <strong>gl:texParameterf/3</strong> ), and number of color components provided. The last three arguments describe how the image is represented in memory.</p><p>If <em>Target</em> is <em>?GL_PROXY_TEXTURE_3D</em>, no data is read from <em>Data</em> , but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see <strong>gl:getError/0</strong> ). To query for an entire mipmap array, use an image array level greater than or equal to 1.</p><p>If <em>Target</em> is <em>?GL_TEXTURE_3D</em>, data is read from <em>Data</em> as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on <em>Type</em> . These values are grouped into sets of one, two, three, or four values, depending on <em>Format</em> , to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by <em>?GL_UNPACK_LSB_FIRST</em> (see <strong>gl:pixelStoref/2</strong> ).</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.</p><p><em>Format</em> determines the composition of each element in <em>Data</em> . It can assume one of these symbolic values:</p><p><em>?GL_RED</em>: Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RG</em>: Each element is a red and green pair. The GL converts each to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RGB</em></p><p><em>?GL_BGR</em>: Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is then multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p><em>?GL_RGBA</em></p><p><em>?GL_BGRA</em>: Each element contains all four components. Each component is multiplied by the signed scale factor <em>?GL_c_SCALE</em>, added to the signed bias <em>?GL_c_BIAS</em>, and clamped to the range [0,1].</p><p>If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with <em>InternalFormat</em> . The GL will choose an internal representation that closely approximates that requested by <em>InternalFormat</em> , but it may not match exactly. (The representations specified by <em>?GL_RED</em>, <em>?GL_RG</em> , <em>?GL_RGB</em>, and <em>?GL_RGBA</em> must match exactly.)</p><p><em>InternalFormat</em> may be one of the base internal formats shown in Table 1, below</p><p><em>InternalFormat</em> may also be one of the sized internal formats shown in Table 2, below</p><p>Finally, <em>InternalFormat</em> may also be one of the generic or compressed compressed texture formats shown in Table 3 below</p><p>If the <em>InternalFormat</em> parameter is one of the generic compressed formats, <em>?GL_COMPRESSED_RED</em> , <em>?GL_COMPRESSED_RG</em>, <em>?GL_COMPRESSED_RGB</em>, or <em>?GL_COMPRESSED_RGBA</em>, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.</p><p>If the <em>InternalFormat</em> parameter is <em>?GL_SRGB</em>, <em>?GL_SRGB8</em>, <em>?GL_SRGB_ALPHA</em> , or <em>?GL_SRGB8_ALPHA8</em>, the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component c s to a linear component c l is:</p><p>c l={ c s/12.92if c s&le; 0.04045( c s+0.055/1.055) 2.4if c s&gt; 0.04045</p><p>Assume c s is the sRGB component in the range [0,1].</p><p>Use the <em>?GL_PROXY_TEXTURE_3D</em> target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call <strong>gl:getTexLevelParameterfv/3</strong> . If the texture cannot be accommodated, texture state is set to 0.</p><p>A one-component texture image uses only the red component of the RGBA color extracted from <em>Data</em> . A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.</p><p>See external documentation.</p><p><strong></strong> texSubImage3D(Target, Level, Xoffset, Yoffset, Zoffset, Width, Height, Depth, Format, Type, Pixels) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>Yoffset = integer()</p><p>Zoffset = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Depth = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Pixels = offset() | mem()</p><p>glTexSubImage</p><p>See external documentation.</p><p><strong></strong> copyTexSubImage3D(Target, Level, Xoffset, Yoffset, Zoffset, X, Y, Width, Height) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>Yoffset = integer()</p><p>Zoffset = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Copy a three-dimensional texture subimage</p><p><em>gl:copyTexSubImage3D</em> replaces a rectangular portion of a three-dimensional texture image with pixels from the current <em>?GL_READ_BUFFER</em> (rather than from main memory, as is the case for <strong>gl:texSubImage1D/7</strong> ).</p><p>The screen-aligned pixel rectangle with lower left corner at ( <em>X</em> , <em>Y</em> ) and with width <em>Width</em> and height <em>Height</em> replaces the portion of the texture array with x indices <em>Xoffset</em> through xoffset+width-1, inclusive, and y indices <em>Yoffset</em> through yoffset+height-1, inclusive, at z index <em>Zoffset</em> and at the mipmap level specified by <em>Level</em> .</p><p>The pixels in the rectangle are processed exactly as if <strong>gl:readPixels/7</strong> had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range [0 1] and then converted to the texture's internal format for storage in the texel array.</p><p>The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.</p><p>If any of the pixels within the specified rectangle of the current <em>?GL_READ_BUFFER</em> are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.</p><p>No change is made to the <em>internalformat</em>, <em>width</em>, <em>height</em>, <em>depth</em>, or <em>border</em> parameters of the specified texture array or to texel values outside the specified subregion.</p><p>See external documentation.</p><p><strong></strong> colorTable(Target, Internalformat, Width, Format, Type, Table) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Table = offset() | mem()</p><p>Define a color lookup table</p><p><em>gl:colorTable</em> may be used in two ways: to test the actual size and color resolution of a lookup table given a particular set of parameters, or to load the contents of a color lookup table. Use the targets <em>?GL_PROXY_*</em> for the first case and the other targets for the second case.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a color table is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>If <em>Target</em> is <em>?GL_COLOR_TABLE</em>, <em>?GL_POST_CONVOLUTION_COLOR_TABLE</em>, or <em>?GL_POST_COLOR_MATRIX_COLOR_TABLE</em> , <em>gl:colorTable</em> builds a color lookup table from an array of pixels. The pixel array specified by <em>Width</em> , <em>Format</em> , <em>Type</em> , and <em>Data</em> is extracted from memory and processed just as if <strong>gl:drawPixels/5</strong> were called, but processing stops after the final expansion to RGBA is completed.</p><p>The four scale parameters and the four bias parameters that are defined for the table are then used to scale and bias the R, G, B, and A components of each pixel. (Use <em>gl:colorTableParameter</em> to set these scale and bias parameters.)</p><p>Next, the R, G, B, and A values are clamped to the range [0 1]. Each pixel is then converted to the internal format specified by <em>Internalformat</em> . This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity). The mapping is as follows:<em>Internal Format</em><em>Red</em><em>Green</em><em>Blue</em><em>Alpha</em><em>Luminance</em><em>Intensity</em></p><p><em>?GL_ALPHA</em> A</p><p><em>?GL_LUMINANCE</em> R</p><p><em>?GL_LUMINANCE_ALPHA</em> A R</p><p><em>?GL_INTENSITY</em> R</p><p><em>?GL_RGB</em> R G B</p><p><em>?GL_RGBA</em> R G B A</p><p>Finally, the red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in the color table. They form a one-dimensional table with indices in the range [0 width-1].</p><p>If <em>Target</em> is <em>?GL_PROXY_*</em>, <em>gl:colorTable</em> recomputes and stores the values of the proxy color table's state variables <em>?GL_COLOR_TABLE_FORMAT</em>, <em>?GL_COLOR_TABLE_WIDTH</em> , <em>?GL_COLOR_TABLE_RED_SIZE</em>, <em>?GL_COLOR_TABLE_GREEN_SIZE</em>, <em>?GL_COLOR_TABLE_BLUE_SIZE</em> , <em>?GL_COLOR_TABLE_ALPHA_SIZE</em>, <em>?GL_COLOR_TABLE_LUMINANCE_SIZE</em>, and <em>?GL_COLOR_TABLE_INTENSITY_SIZE</em> . There is no effect on the image or state of any actual color table. If the specified color table is too large to be supported, then all the proxy state variables listed above are set to zero. Otherwise, the color table could be supported by <em>gl:colorTable</em> using the corresponding non-proxy target, and the proxy state variables are set as if that target were being defined.</p><p>The proxy state variables can be retrieved by calling <strong>gl:getColorTableParameterfv/2</strong> with a target of <em>?GL_PROXY_*</em>. This allows the application to decide if a particular <em>gl:colorTable</em> command would succeed, and to determine what the resulting color table attributes would be.</p><p>If a color table is enabled, and its width is non-zero, then its contents are used to replace a subset of the components of each RGBA pixel group, based on the internal format of the table.</p><p>Each pixel group has color components (R, G, B, A) that are in the range [0.0 1.0]. The color components are rescaled to the size of the color lookup table to form an index. Then a subset of the components based on the internal format of the table are replaced by the table entry selected by that index. If the color components and contents of the table are represented as follows:<em>Representation</em><em>Meaning</em></p><p> r Table index computed from R</p><p>g Table index computed from G</p><p>b Table index computed from B</p><p>a Table index computed from A</p><p>L[i] Luminance value at table index i</p><p>I[i] Intensity value at table index i</p><p> R[i] Red value at table index i</p><p>G[i] Green value at table index i</p><p>B[i] Blue value at table index i</p><p> A[i] Alpha value at table index i</p><p>then the result of color table lookup is as follows:<em>Resulting Texture Components</em></p><p><em>Table Internal Format</em><em>R</em><em>G</em><em>B</em><em>A</em></p><p><em>?GL_ALPHA</em>RGBA[a]</p><p><em>?GL_LUMINANCE</em>L[r]L[g]L[b]At</p><p><em>?GL_LUMINANCE_ALPHA</em> L[r]L[g]L[b]A[a]</p><p><em>?GL_INTENSITY</em> I[r]I[g]I[b]I[a]</p><p><em>?GL_RGB</em>R[r] G[g]B[b]A</p><p><em>?GL_RGBA</em>R[r] G[g]B[b]A[a]</p><p>When <em>?GL_COLOR_TABLE</em> is enabled, the colors resulting from the pixel map operation (if it is enabled) are mapped by the color lookup table before being passed to the convolution operation. The colors resulting from the convolution operation are modified by the post convolution color lookup table when <em>?GL_POST_CONVOLUTION_COLOR_TABLE</em> is enabled. These modified colors are then sent to the color matrix operation. Finally, if <em>?GL_POST_COLOR_MATRIX_COLOR_TABLE</em> is enabled, the colors resulting from the color matrix operation are mapped by the post color matrix color lookup table before being used by the histogram operation.</p><p>See external documentation.</p><p><strong></strong> colorTableParameterfv(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {float(), float(), float(), float()}</p><p>Set color lookup table parameters</p><p><em>gl:colorTableParameter</em> is used to specify the scale factors and bias terms applied to color components when they are loaded into a color table. <em>Target</em> indicates which color table the scale and bias terms apply to; it must be set to <em>?GL_COLOR_TABLE</em>, <em>?GL_POST_CONVOLUTION_COLOR_TABLE</em> , or <em>?GL_POST_COLOR_MATRIX_COLOR_TABLE</em>.</p><p><em>Pname</em> must be <em>?GL_COLOR_TABLE_SCALE</em> to set the scale factors. In this case, <em>Params</em> points to an array of four values, which are the scale factors for red, green, blue, and alpha, in that order.</p><p><em>Pname</em> must be <em>?GL_COLOR_TABLE_BIAS</em> to set the bias terms. In this case, <em>Params</em> points to an array of four values, which are the bias terms for red, green, blue, and alpha, in that order.</p><p>The color tables themselves are specified by calling <strong>gl:colorTable/6</strong> .</p><p>See external documentation.</p><p><strong></strong> colorTableParameteriv(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {integer(), integer(), integer(), integer()}</p><p>See <strong>colorTableParameterfv/3</strong></p><p><strong></strong> copyColorTable(Target, Internalformat, X, Y, Width) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Copy pixels into a color table</p><p><em>gl:copyColorTable</em> loads a color table with pixels from the current <em>?GL_READ_BUFFER</em> (rather than from main memory, as is the case for <strong>gl:colorTable/6</strong> ).</p><p>The screen-aligned pixel rectangle with lower-left corner at ( <em>X</em> , <em>Y</em> ) having width <em>Width</em> and height 1 is loaded into the color table. If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined.</p><p>The pixels in the rectangle are processed just as if <strong>gl:readPixels/7</strong> were called, with <em>Internalformat</em> set to RGBA, but processing stops after the final conversion to RGBA.</p><p>The four scale parameters and the four bias parameters that are defined for the table are then used to scale and bias the R, G, B, and A components of each pixel. The scale and bias parameters are set by calling <strong>gl:colorTableParameterfv/3</strong> .</p><p>Next, the R, G, B, and A values are clamped to the range [0 1]. Each pixel is then converted to the internal format specified by <em>Internalformat</em> . This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity). The mapping is as follows:<em>Internal Format</em><em>Red</em><em>Green</em><em>Blue</em><em>Alpha</em><em>Luminance</em><em>Intensity</em></p><p><em>?GL_ALPHA</em> A</p><p><em>?GL_LUMINANCE</em> R</p><p><em>?GL_LUMINANCE_ALPHA</em> A R</p><p><em>?GL_INTENSITY</em> R</p><p><em>?GL_RGB</em> R G B</p><p><em>?GL_RGBA</em> R G B A</p><p>Finally, the red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in the color table. They form a one-dimensional table with indices in the range [0 width-1].</p><p>See external documentation.</p><p><strong></strong> getColorTable(Target, Format, Type, Table) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Format = enum()</p><p>Type = enum()</p><p>Table = mem()</p><p>Retrieve contents of a color lookup table</p><p><em>gl:getColorTable</em> returns in <em>Table</em> the contents of the color table specified by <em>Target</em> . No pixel transfer operations are performed, but pixel storage modes that are applicable to <strong>gl:readPixels/7</strong> are performed.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a histogram table is requested, <em>Table</em> is treated as a byte offset into the buffer object's data store.</p><p>Color components that are requested in the specified <em>Format</em> , but which are not included in the internal format of the color lookup table, are returned as zero. The assignments of internal color components to the components requested by <em>Format</em> are<em>Internal Component</em><em>Resulting Component</em></p><p> Red Red</p><p> Green Green</p><p> Blue Blue</p><p> Alpha Alpha</p><p> Luminance Red</p><p> Intensity Red</p><p>See external documentation.</p><p><strong></strong> getColorTableParameterfv(Target, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Get color lookup table parameters</p><p>Returns parameters specific to color table <em>Target</em> .</p><p>When <em>Pname</em> is set to <em>?GL_COLOR_TABLE_SCALE</em> or <em>?GL_COLOR_TABLE_BIAS</em>, <em>gl:getColorTableParameter</em> returns the color table scale or bias parameters for the table specified by <em>Target</em> . For these queries, <em>Target</em> must be set to <em>?GL_COLOR_TABLE</em> , <em>?GL_POST_CONVOLUTION_COLOR_TABLE</em>, or <em>?GL_POST_COLOR_MATRIX_COLOR_TABLE</em> and <em>Params</em> points to an array of four elements, which receive the scale or bias factors for red, green, blue, and alpha, in that order.</p><p><em>gl:getColorTableParameter</em> can also be used to retrieve the format and size parameters for a color table. For these queries, set <em>Target</em> to either the color table target or the proxy color table target. The format and size parameters are set by <strong>gl:colorTable/6</strong> .</p><p>The following table lists the format and size parameters that may be queried. For each symbolic constant listed below for <em>Pname</em> , <em>Params</em> must point to an array of the given length and receive the values indicated.<em>Parameter</em><em>N</em><em>Meaning</em></p><p><em>?GL_COLOR_TABLE_FORMAT</em> 1 Internal format (e.g., <em>?GL_RGBA</em>)</p><p><em>?GL_COLOR_TABLE_WIDTH</em> 1 Number of elements in table</p><p><em>?GL_COLOR_TABLE_RED_SIZE</em> 1 Size of red component, in bits</p><p><em>?GL_COLOR_TABLE_GREEN_SIZE</em> 1 Size of green component</p><p><em>?GL_COLOR_TABLE_BLUE_SIZE</em> 1 Size of blue component</p><p><em>?GL_COLOR_TABLE_ALPHA_SIZE</em> 1 Size of alpha component</p><p><em>?GL_COLOR_TABLE_LUMINANCE_SIZE</em> 1 Size of luminance component</p><p><em>?GL_COLOR_TABLE_INTENSITY_SIZE</em> 1 Size of intensity component</p><p>See external documentation.</p><p><strong></strong> getColorTableParameteriv(Target, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>See <strong>getColorTableParameterfv/2</strong></p><p><strong></strong> colorSubTable(Target, Start, Count, Format, Type, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Start = integer()</p><p>Count = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Data = offset() | mem()</p><p>Respecify a portion of a color table</p><p><em>gl:colorSubTable</em> is used to respecify a contiguous portion of a color table previously defined using <strong>gl:colorTable/6</strong> . The pixels referenced by <em>Data</em> replace the portion of the existing table from indices <em>Start</em> to start+count-1, inclusive. This region may not include any entries outside the range of the color table as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a portion of a color table is respecified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>See external documentation.</p><p><strong></strong> copyColorSubTable(Target, Start, X, Y, Width) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Start = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Respecify a portion of a color table</p><p><em>gl:copyColorSubTable</em> is used to respecify a contiguous portion of a color table previously defined using <strong>gl:colorTable/6</strong> . The pixels copied from the framebuffer replace the portion of the existing table from indices <em>Start</em> to start+x-1, inclusive. This region may not include any entries outside the range of the color table, as was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.</p><p>See external documentation.</p><p><strong></strong> convolutionFilter1D(Target, Internalformat, Width, Format, Type, Image) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Image = offset() | mem()</p><p>Define a one-dimensional convolution filter</p><p><em>gl:convolutionFilter1D</em> builds a one-dimensional convolution filter kernel from an array of pixels.</p><p>The pixel array specified by <em>Width</em> , <em>Format</em> , <em>Type</em> , and <em>Data</em> is extracted from memory and processed just as if <strong>gl:drawPixels/5</strong> were called, but processing stops after the final expansion to RGBA is completed.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a convolution filter is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>The R, G, B, and A components of each pixel are next scaled by the four 1D <em>?GL_CONVOLUTION_FILTER_SCALE</em> parameters and biased by the four 1D <em>?GL_CONVOLUTION_FILTER_BIAS</em> parameters. (The scale and bias parameters are set by <strong>gl:convolutionParameterf/3</strong> using the <em>?GL_CONVOLUTION_1D</em> target and the names <em>?GL_CONVOLUTION_FILTER_SCALE</em> and <em>?GL_CONVOLUTION_FILTER_BIAS</em> . The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process.</p><p>Each pixel is then converted to the internal format specified by <em>Internalformat</em> . This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity). The mapping is as follows:<em>Internal Format</em><em>Red</em><em>Green</em><em>Blue</em><em>Alpha</em><em>Luminance</em><em>Intensity</em></p><p><em>?GL_ALPHA</em> A</p><p><em>?GL_LUMINANCE</em> R</p><p><em>?GL_LUMINANCE_ALPHA</em> A R</p><p><em>?GL_INTENSITY</em> R</p><p><em>?GL_RGB</em> R G B</p><p><em>?GL_RGBA</em> R G B A</p><p>The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form a one-dimensional filter kernel image indexed with coordinate <em>i</em> such that <em>i</em> starts at 0 and increases from left to right. Kernel location <em>i</em> is derived from the <em>i</em>th pixel, counting from 0.</p><p>Note that after a convolution is performed, the resulting color components are also scaled by their corresponding <em>?GL_POST_CONVOLUTION_c_SCALE</em> parameters and biased by their corresponding <em>?GL_POST_CONVOLUTION_c_BIAS</em> parameters (where <em>c</em> takes on the values <em>RED</em>, <em>GREEN</em>, <em>BLUE</em>, and <em>ALPHA</em>). These parameters are set by <strong>gl:pixelTransferf/2</strong> .</p><p>See external documentation.</p><p><strong></strong> convolutionFilter2D(Target, Internalformat, Width, Height, Format, Type, Image) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Height = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Image = offset() | mem()</p><p>Define a two-dimensional convolution filter</p><p><em>gl:convolutionFilter2D</em> builds a two-dimensional convolution filter kernel from an array of pixels.</p><p>The pixel array specified by <em>Width</em> , <em>Height</em> , <em>Format</em> , <em>Type</em> , and <em>Data</em> is extracted from memory and processed just as if <strong>gl:drawPixels/5</strong> were called, but processing stops after the final expansion to RGBA is completed.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a convolution filter is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>The R, G, B, and A components of each pixel are next scaled by the four 2D <em>?GL_CONVOLUTION_FILTER_SCALE</em> parameters and biased by the four 2D <em>?GL_CONVOLUTION_FILTER_BIAS</em> parameters. (The scale and bias parameters are set by <strong>gl:convolutionParameterf/3</strong> using the <em>?GL_CONVOLUTION_2D</em> target and the names <em>?GL_CONVOLUTION_FILTER_SCALE</em> and <em>?GL_CONVOLUTION_FILTER_BIAS</em> . The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process.</p><p>Each pixel is then converted to the internal format specified by <em>Internalformat</em> . This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity). The mapping is as follows:<em>Internal Format</em><em>Red</em><em>Green</em><em>Blue</em><em>Alpha</em><em>Luminance</em><em>Intensity</em></p><p><em>?GL_ALPHA</em> A</p><p><em>?GL_LUMINANCE</em> R</p><p><em>?GL_LUMINANCE_ALPHA</em> A R</p><p><em>?GL_INTENSITY</em> R</p><p><em>?GL_RGB</em> R G B</p><p><em>?GL_RGBA</em> R G B A</p><p>The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form a two-dimensional filter kernel image indexed with coordinates <em>i</em> and <em>j</em> such that <em>i</em> starts at zero and increases from left to right, and <em>j</em> starts at zero and increases from bottom to top. Kernel location <em>i,j</em> is derived from the <em>N</em>th pixel, where <em>N</em> is <em>i</em>+<em>j</em>* <em>Width</em> .</p><p>Note that after a convolution is performed, the resulting color components are also scaled by their corresponding <em>?GL_POST_CONVOLUTION_c_SCALE</em> parameters and biased by their corresponding <em>?GL_POST_CONVOLUTION_c_BIAS</em> parameters (where <em>c</em> takes on the values <em>RED</em>, <em>GREEN</em>, <em>BLUE</em>, and <em>ALPHA</em>). These parameters are set by <strong>gl:pixelTransferf/2</strong> .</p><p>See external documentation.</p><p><strong></strong> convolutionParameterf(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {float()}</p><p>Set convolution parameters</p><p><em>gl:convolutionParameter</em> sets the value of a convolution parameter.</p><p><em>Target</em> selects the convolution filter to be affected: <em>?GL_CONVOLUTION_1D</em>, <em>?GL_CONVOLUTION_2D</em> , or <em>?GL_SEPARABLE_2D</em> for the 1D, 2D, or separable 2D filter, respectively.</p><p><em>Pname</em> selects the parameter to be changed. <em>?GL_CONVOLUTION_FILTER_SCALE</em> and <em>?GL_CONVOLUTION_FILTER_BIAS</em> affect the definition of the convolution filter kernel; see <strong>gl:convolutionFilter1D/6</strong> , <strong>gl:convolutionFilter2D/7</strong> , and <strong>gl:separableFilter2D/8</strong> for details. In these cases, <em>Params</em> v is an array of four values to be applied to red, green, blue, and alpha values, respectively. The initial value for <em>?GL_CONVOLUTION_FILTER_SCALE</em> is (1, 1, 1, 1), and the initial value for <em>?GL_CONVOLUTION_FILTER_BIAS</em> is (0, 0, 0, 0).</p><p>A <em>Pname</em> value of <em>?GL_CONVOLUTION_BORDER_MODE</em> controls the convolution border mode. The accepted modes are:</p><p><em>?GL_REDUCE</em>: The image resulting from convolution is smaller than the source image. If the filter width is Wf and height is Hf, and the source image width is Ws and height is Hs, then the convolved image width will be Ws-Wf+1 and height will be Hs-Hf +1. (If this reduction would generate an image with zero or negative width and/or height, the output is simply null, with no error generated.) The coordinates of the image resulting from convolution are zero through Ws-Wf in width and zero through Hs-Hf in height.</p><p><em>?GL_CONSTANT_BORDER</em>: The image resulting from convolution is the same size as the source image, and processed as if the source image were surrounded by pixels with their color specified by the <em>?GL_CONVOLUTION_BORDER_COLOR</em>.</p><p><em>?GL_REPLICATE_BORDER</em>: The image resulting from convolution is the same size as the source image, and processed as if the outermost pixel on the border of the source image were replicated.</p><p>See external documentation.</p><p><strong></strong> convolutionParameterfv(Target::enum(), Pname::enum(), Params) -&gt; ok</p><p>Types:</p><p>Params = {Params::{float()}}</p><p>Equivalent to <strong>convolutionParameterf(Target, Pname, Params)</strong>.</p><p><strong></strong> convolutionParameteri(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>convolutionParameterf/3</strong></p><p><strong></strong> convolutionParameteriv(Target::enum(), Pname::enum(), Params) -&gt; ok</p><p>Types:</p><p>Params = {Params::{integer()}}</p><p>Equivalent to <strong>convolutionParameteri(Target, Pname, Params)</strong>.</p><p><strong></strong> copyConvolutionFilter1D(Target, Internalformat, X, Y, Width) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Copy pixels into a one-dimensional convolution filter</p><p><em>gl:copyConvolutionFilter1D</em> defines a one-dimensional convolution filter kernel with pixels from the current <em>?GL_READ_BUFFER</em> (rather than from main memory, as is the case for <strong>gl:convolutionFilter1D/6</strong> ).</p><p>The screen-aligned pixel rectangle with lower-left corner at ( <em>X</em> , <em>Y</em> ), width <em>Width</em> and height 1 is used to define the convolution filter. If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined.</p><p>The pixels in the rectangle are processed exactly as if <strong>gl:readPixels/7</strong> had been called with <em>format</em> set to RGBA, but the process stops just before final conversion. The R, G, B, and A components of each pixel are next scaled by the four 1D <em>?GL_CONVOLUTION_FILTER_SCALE</em> parameters and biased by the four 1D <em>?GL_CONVOLUTION_FILTER_BIAS</em> parameters. (The scale and bias parameters are set by <strong>gl:convolutionParameterf/3</strong> using the <em>?GL_CONVOLUTION_1D</em> target and the names <em>?GL_CONVOLUTION_FILTER_SCALE</em> and <em>?GL_CONVOLUTION_FILTER_BIAS</em> . The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process.</p><p>Each pixel is then converted to the internal format specified by <em>Internalformat</em> . This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity). The mapping is as follows:<em>Internal Format</em><em>Red</em><em>Green</em><em>Blue</em><em>Alpha</em><em>Luminance</em><em>Intensity</em></p><p><em>?GL_ALPHA</em> A</p><p><em>?GL_LUMINANCE</em> R</p><p><em>?GL_LUMINANCE_ALPHA</em> A R</p><p><em>?GL_INTENSITY</em> R</p><p><em>?GL_RGB</em> R G B</p><p><em>?GL_RGBA</em> R G B A</p><p>The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format.</p><p>Pixel ordering is such that lower x screen coordinates correspond to lower <em>i</em> filter image coordinates.</p><p>Note that after a convolution is performed, the resulting color components are also scaled by their corresponding <em>?GL_POST_CONVOLUTION_c_SCALE</em> parameters and biased by their corresponding <em>?GL_POST_CONVOLUTION_c_BIAS</em> parameters (where <em>c</em> takes on the values <em>RED</em>, <em>GREEN</em>, <em>BLUE</em>, and <em>ALPHA</em>). These parameters are set by <strong>gl:pixelTransferf/2</strong> .</p><p>See external documentation.</p><p><strong></strong> copyConvolutionFilter2D(Target, Internalformat, X, Y, Width, Height) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>X = integer()</p><p>Y = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Copy pixels into a two-dimensional convolution filter</p><p><em>gl:copyConvolutionFilter2D</em> defines a two-dimensional convolution filter kernel with pixels from the current <em>?GL_READ_BUFFER</em> (rather than from main memory, as is the case for <strong>gl:convolutionFilter2D/7</strong> ).</p><p>The screen-aligned pixel rectangle with lower-left corner at ( <em>X</em> , <em>Y</em> ), width <em>Width</em> and height <em>Height</em> is used to define the convolution filter. If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined.</p><p>The pixels in the rectangle are processed exactly as if <strong>gl:readPixels/7</strong> had been called with <em>format</em> set to RGBA, but the process stops just before final conversion. The R, G, B, and A components of each pixel are next scaled by the four 2D <em>?GL_CONVOLUTION_FILTER_SCALE</em> parameters and biased by the four 2D <em>?GL_CONVOLUTION_FILTER_BIAS</em> parameters. (The scale and bias parameters are set by <strong>gl:convolutionParameterf/3</strong> using the <em>?GL_CONVOLUTION_2D</em> target and the names <em>?GL_CONVOLUTION_FILTER_SCALE</em> and <em>?GL_CONVOLUTION_FILTER_BIAS</em> . The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process.</p><p>Each pixel is then converted to the internal format specified by <em>Internalformat</em> . This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity). The mapping is as follows:<em>Internal Format</em><em>Red</em><em>Green</em><em>Blue</em><em>Alpha</em><em>Luminance</em><em>Intensity</em></p><p><em>?GL_ALPHA</em> A</p><p><em>?GL_LUMINANCE</em> R</p><p><em>?GL_LUMINANCE_ALPHA</em> A R</p><p><em>?GL_INTENSITY</em> R</p><p><em>?GL_RGB</em> R G B</p><p><em>?GL_RGBA</em> R G B A</p><p>The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format.</p><p>Pixel ordering is such that lower x screen coordinates correspond to lower <em>i</em> filter image coordinates, and lower y screen coordinates correspond to lower <em>j</em> filter image coordinates.</p><p>Note that after a convolution is performed, the resulting color components are also scaled by their corresponding <em>?GL_POST_CONVOLUTION_c_SCALE</em> parameters and biased by their corresponding <em>?GL_POST_CONVOLUTION_c_BIAS</em> parameters (where <em>c</em> takes on the values <em>RED</em>, <em>GREEN</em>, <em>BLUE</em>, and <em>ALPHA</em>). These parameters are set by <strong>gl:pixelTransferf/2</strong> .</p><p>See external documentation.</p><p><strong></strong> getConvolutionFilter(Target, Format, Type, Image) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Format = enum()</p><p>Type = enum()</p><p>Image = mem()</p><p>Get current 1D or 2D convolution filter kernel</p><p><em>gl:getConvolutionFilter</em> returns the current 1D or 2D convolution filter kernel as an image. The one- or two-dimensional image is placed in <em>Image</em> according to the specifications in <em>Format</em> and <em>Type</em> . No pixel transfer operations are performed on this image, but the relevant pixel storage modes are applied.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a convolution filter is requested, <em>Image</em> is treated as a byte offset into the buffer object's data store.</p><p>Color components that are present in <em>Format</em> but not included in the internal format of the filter are returned as zero. The assignments of internal color components to the components of <em>Format</em> are as follows.<em>Internal Component</em><em>Resulting Component</em></p><p> Red Red</p><p> Green Green</p><p> Blue Blue</p><p> Alpha Alpha</p><p> Luminance Red</p><p> Intensity Red</p><p>See external documentation.</p><p><strong></strong> getConvolutionParameterfv(Target, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Get convolution parameters</p><p><em>gl:getConvolutionParameter</em> retrieves convolution parameters. <em>Target</em> determines which convolution filter is queried. <em>Pname</em> determines which parameter is returned:</p><p><em>?GL_CONVOLUTION_BORDER_MODE</em>: The convolution border mode. See <strong>gl:convolutionParameterf/3</strong> for a list of border modes.</p><p><em>?GL_CONVOLUTION_BORDER_COLOR</em>: The current convolution border color. <em>Params</em> must be a pointer to an array of four elements, which will receive the red, green, blue, and alpha border colors.</p><p><em>?GL_CONVOLUTION_FILTER_SCALE</em>: The current filter scale factors. <em>Params</em> must be a pointer to an array of four elements, which will receive the red, green, blue, and alpha filter scale factors in that order.</p><p><em>?GL_CONVOLUTION_FILTER_BIAS</em>: The current filter bias factors. <em>Params</em> must be a pointer to an array of four elements, which will receive the red, green, blue, and alpha filter bias terms in that order.</p><p><em>?GL_CONVOLUTION_FORMAT</em>: The current internal format. See <strong>gl:convolutionFilter1D/6</strong> , <strong>gl:convolutionFilter2D/7</strong> , and <strong>gl:separableFilter2D/8</strong> for lists of allowable formats.</p><p><em>?GL_CONVOLUTION_WIDTH</em>: The current filter image width.</p><p><em>?GL_CONVOLUTION_HEIGHT</em>: The current filter image height.</p><p><em>?GL_MAX_CONVOLUTION_WIDTH</em>: The maximum acceptable filter image width.</p><p><em>?GL_MAX_CONVOLUTION_HEIGHT</em>: The maximum acceptable filter image height.</p><p>See external documentation.</p><p><strong></strong> getConvolutionParameteriv(Target, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>See <strong>getConvolutionParameterfv/2</strong></p><p><strong></strong> separableFilter2D(Target, Internalformat, Width, Height, Format, Type, Row, Column) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Height = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Row = offset() | mem()</p><p>Column = offset() | mem()</p><p>Define a separable two-dimensional convolution filter</p><p><em>gl:separableFilter2D</em> builds a two-dimensional separable convolution filter kernel from two arrays of pixels.</p><p>The pixel arrays specified by ( <em>Width</em> , <em>Format</em> , <em>Type</em> , <em>Row</em> ) and ( <em>Height</em> , <em>Format</em> , <em>Type</em> , <em>Column</em> ) are processed just as if they had been passed to <strong>gl:drawPixels/5</strong> , but processing stops after the final expansion to RGBA is completed.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a convolution filter is specified, <em>Row</em> and <em>Column</em> are treated as byte offsets into the buffer object's data store.</p><p>Next, the R, G, B, and A components of all pixels in both arrays are scaled by the four separable 2D <em>?GL_CONVOLUTION_FILTER_SCALE</em> parameters and biased by the four separable 2D <em>?GL_CONVOLUTION_FILTER_BIAS</em> parameters. (The scale and bias parameters are set by <strong>gl:convolutionParameterf/3</strong> using the <em>?GL_SEPARABLE_2D</em> target and the names <em>?GL_CONVOLUTION_FILTER_SCALE</em> and <em>?GL_CONVOLUTION_FILTER_BIAS</em>. The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process.</p><p>Each pixel is then converted to the internal format specified by <em>Internalformat</em> . This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity). The mapping is as follows:<em>Internal Format</em><em>Red</em><em>Green</em><em>Blue</em><em>Alpha</em><em>Luminance</em><em>Intensity</em></p><p><em>?GL_LUMINANCE</em> R</p><p><em>?GL_LUMINANCE_ALPHA</em> A R</p><p><em>?GL_INTENSITY</em> R</p><p><em>?GL_RGB</em> R G B</p><p><em>?GL_RGBA</em> R G B A</p><p>The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form two one-dimensional filter kernel images. The row image is indexed by coordinate <em>i</em> starting at zero and increasing from left to right. Each location in the row image is derived from element <em>i</em> of <em>Row</em> . The column image is indexed by coordinate <em>j</em> starting at zero and increasing from bottom to top. Each location in the column image is derived from element <em>j</em> of <em>Column</em> .</p><p>Note that after a convolution is performed, the resulting color components are also scaled by their corresponding <em>?GL_POST_CONVOLUTION_c_SCALE</em> parameters and biased by their corresponding <em>?GL_POST_CONVOLUTION_c_BIAS</em> parameters (where <em>c</em> takes on the values <em>RED</em>, <em>GREEN</em>, <em>BLUE</em>, and <em>ALPHA</em>). These parameters are set by <strong>gl:pixelTransferf/2</strong> .</p><p>See external documentation.</p><p><strong></strong> getHistogram(Target, Reset, Format, Type, Values) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Reset = 0 | 1</p><p>Format = enum()</p><p>Type = enum()</p><p>Values = mem()</p><p>Get histogram table</p><p><em>gl:getHistogram</em> returns the current histogram table as a one-dimensional image with the same width as the histogram. No pixel transfer operations are performed on this image, but pixel storage modes that are applicable to 1D images are honored.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a histogram table is requested, <em>Values</em> is treated as a byte offset into the buffer object's data store.</p><p>Color components that are requested in the specified <em>Format</em> , but which are not included in the internal format of the histogram, are returned as zero. The assignments of internal color components to the components requested by <em>Format</em> are:<em>Internal Component</em><em>Resulting Component</em></p><p> Red Red</p><p> Green Green</p><p> Blue Blue</p><p> Alpha Alpha</p><p> Luminance Red</p><p>See external documentation.</p><p><strong></strong> getHistogramParameterfv(Target, Pname) -&gt; {float()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Get histogram parameters</p><p><em>gl:getHistogramParameter</em> is used to query parameter values for the current histogram or for a proxy. The histogram state information may be queried by calling <em>gl:getHistogramParameter</em> with a <em>Target</em> of <em>?GL_HISTOGRAM</em> (to obtain information for the current histogram table) or <em>?GL_PROXY_HISTOGRAM</em> (to obtain information from the most recent proxy request) and one of the following values for the <em>Pname</em> argument:<em>Parameter</em><em>Description</em></p><p><em>?GL_HISTOGRAM_WIDTH</em> Histogram table width</p><p><em>?GL_HISTOGRAM_FORMAT</em> Internal format</p><p><em>?GL_HISTOGRAM_RED_SIZE</em> Red component counter size, in bits</p><p><em>?GL_HISTOGRAM_GREEN_SIZE</em> Green component counter size, in bits</p><p><em>?GL_HISTOGRAM_BLUE_SIZE</em> Blue component counter size, in bits</p><p><em>?GL_HISTOGRAM_ALPHA_SIZE</em> Alpha component counter size, in bits</p><p><em>?GL_HISTOGRAM_LUMINANCE_SIZE</em> Luminance component counter size, in bits</p><p><em>?GL_HISTOGRAM_SINK</em> Value of the <em>sink</em> parameter</p><p>See external documentation.</p><p><strong></strong> getHistogramParameteriv(Target, Pname) -&gt; {integer()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>See <strong>getHistogramParameterfv/2</strong></p><p><strong></strong> getMinmax(Target, Reset, Format, Types, Values) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Reset = 0 | 1</p><p>Format = enum()</p><p>Types = enum()</p><p>Values = mem()</p><p>Get minimum and maximum pixel values</p><p><em>gl:getMinmax</em> returns the accumulated minimum and maximum pixel values (computed on a per-component basis) in a one-dimensional image of width 2. The first set of return values are the minima, and the second set of return values are the maxima. The format of the return values is determined by <em>Format</em> , and their type is determined by <em>Types</em> .</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while minimum and maximum pixel values are requested, <em>Values</em> is treated as a byte offset into the buffer object's data store.</p><p>No pixel transfer operations are performed on the return values, but pixel storage modes that are applicable to one-dimensional images are performed. Color components that are requested in the specified <em>Format</em> , but that are not included in the internal format of the minmax table, are returned as zero. The assignment of internal color components to the components requested by <em>Format</em> are as follows:<em>Internal Component</em><em>Resulting Component</em></p><p> Red Red</p><p> Green Green</p><p> Blue Blue</p><p> Alpha Alpha</p><p> Luminance Red</p><p>If <em>Reset</em> is <em>?GL_TRUE</em>, the minmax table entries corresponding to the return values are reset to their initial values. Minimum and maximum values that are not returned are not modified, even if <em>Reset</em> is <em>?GL_TRUE</em>.</p><p>See external documentation.</p><p><strong></strong> getMinmaxParameterfv(Target, Pname) -&gt; {float()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Get minmax parameters</p><p><em>gl:getMinmaxParameter</em> retrieves parameters for the current minmax table by setting <em>Pname</em> to one of the following values:<em>Parameter</em><em>Description</em></p><p><em>?GL_MINMAX_FORMAT</em> Internal format of minmax table</p><p><em>?GL_MINMAX_SINK</em> Value of the <em>sink</em> parameter</p><p>See external documentation.</p><p><strong></strong> getMinmaxParameteriv(Target, Pname) -&gt; {integer()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>See <strong>getMinmaxParameterfv/2</strong></p><p><strong></strong> histogram(Target, Width, Internalformat, Sink) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Width = integer()</p><p>Internalformat = enum()</p><p>Sink = 0 | 1</p><p>Define histogram table</p><p>When <em>?GL_HISTOGRAM</em> is enabled, RGBA color components are converted to histogram table indices by clamping to the range [0,1], multiplying by the width of the histogram table, and rounding to the nearest integer. The table entries selected by the RGBA indices are then incremented. (If the internal format of the histogram table includes luminance, then the index derived from the R color component determines the luminance table entry to be incremented.) If a histogram table entry is incremented beyond its maximum value, then its value becomes undefined. (This is not an error.)</p><p>Histogramming is performed only for RGBA pixels (though these may be specified originally as color indices and converted to RGBA by index table lookup). Histogramming is enabled with <strong>gl:enable/1</strong> and disabled with <strong>gl:enable/1</strong> .</p><p>When <em>Target</em> is <em>?GL_HISTOGRAM</em>, <em>gl:histogram</em> redefines the current histogram table to have <em>Width</em> entries of the format specified by <em>Internalformat</em> . The entries are indexed 0 through width-1, and all entries are initialized to zero. The values in the previous histogram table, if any, are lost. If <em>Sink</em> is <em>?GL_TRUE</em> , then pixels are discarded after histogramming; no further processing of the pixels takes place, and no drawing, texture loading, or pixel readback will result.</p><p>When <em>Target</em> is <em>?GL_PROXY_HISTOGRAM</em>, <em>gl:histogram</em> computes all state information as if the histogram table were to be redefined, but does not actually define the new table. If the requested histogram table is too large to be supported, then the state information will be set to zero. This provides a way to determine if a histogram table with the given parameters can be supported.</p><p>See external documentation.</p><p><strong></strong> minmax(Target, Internalformat, Sink) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>Sink = 0 | 1</p><p>Define minmax table</p><p>When <em>?GL_MINMAX</em> is enabled, the RGBA components of incoming pixels are compared to the minimum and maximum values for each component, which are stored in the two-element minmax table. (The first element stores the minima, and the second element stores the maxima.) If a pixel component is greater than the corresponding component in the maximum element, then the maximum element is updated with the pixel component value. If a pixel component is less than the corresponding component in the minimum element, then the minimum element is updated with the pixel component value. (In both cases, if the internal format of the minmax table includes luminance, then the R color component of incoming pixels is used for comparison.) The contents of the minmax table may be retrieved at a later time by calling <strong>gl:getMinmax/5</strong> . The minmax operation is enabled or disabled by calling <strong>gl:enable/1</strong> or <strong>gl:enable/1</strong> , respectively, with an argument of <em>?GL_MINMAX</em> .</p><p><em>gl:minmax</em> redefines the current minmax table to have entries of the format specified by <em>Internalformat</em> . The maximum element is initialized with the smallest possible component values, and the minimum element is initialized with the largest possible component values. The values in the previous minmax table, if any, are lost. If <em>Sink</em> is <em>?GL_TRUE</em> , then pixels are discarded after minmax; no further processing of the pixels takes place, and no drawing, texture loading, or pixel readback will result.</p><p>See external documentation.</p><p><strong></strong> resetHistogram(Target) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Reset histogram table entries to zero</p><p><em>gl:resetHistogram</em> resets all the elements of the current histogram table to zero.</p><p>See external documentation.</p><p><strong></strong> resetMinmax(Target) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Reset minmax table entries to initial values</p><p><em>gl:resetMinmax</em> resets the elements of the current minmax table to their initial values: the <em>maximum</em> element receives the minimum possible component values, and the <em>minimum</em> element receives the maximum possible component values.</p><p>See external documentation.</p><p><strong></strong> activeTexture(Texture) -&gt; ok</p><p>Types:</p><p>Texture = enum()</p><p>Select active texture unit</p><p><em>gl:activeTexture</em> selects which texture unit subsequent texture state calls will affect. The number of texture units an implementation supports is implementation dependent, but must be at least 80.</p><p>See external documentation.</p><p><strong></strong> sampleCoverage(Value, Invert) -&gt; ok</p><p>Types:</p><p>Value = clamp()</p><p>Invert = 0 | 1</p><p>Specify multisample coverage parameters</p><p>Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations to generate antialiasing effects. Multisampling transparently antialiases points, lines, polygons, and images if it is enabled.</p><p><em>Value</em> is used in constructing a temporary mask used in determining which samples will be used in resolving the final fragment color. This mask is bitwise-anded with the coverage mask generated from the multisampling computation. If the <em>Invert</em> flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed.</p><p>If an implementation does not have any multisample buffers available, or multisampling is disabled, rasterization occurs with only a single sample computing a pixel's final RGB color.</p><p>Provided an implementation supports multisample buffers, and multisampling is enabled, then a pixel's final color is generated by combining several samples per pixel. Each sample contains color, depth, and stencil information, allowing those operations to be performed on each sample.</p><p>See external documentation.</p><p><strong></strong> compressedTexImage3D(Target, Level, Internalformat, Width, Height, Depth, Border, ImageSize, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Height = integer()</p><p>Depth = integer()</p><p>Border = integer()</p><p>ImageSize = integer()</p><p>Data = offset() | mem()</p><p>Specify a three-dimensional texture image in a compressed format</p><p>Texturing allows elements of an image array to be read by shaders.</p><p><em>gl:compressedTexImage3D</em> loads a previously defined, and retrieved, compressed three-dimensional texture image if <em>Target</em> is <em>?GL_TEXTURE_3D</em> (see <strong>gl:texImage3D/10</strong> ).</p><p>If <em>Target</em> is <em>?GL_TEXTURE_2D_ARRAY</em>, <em>Data</em> is treated as an array of compressed 2D textures.</p><p>If <em>Target</em> is <em>?GL_PROXY_TEXTURE_3D</em> or <em>?GL_PROXY_TEXTURE_2D_ARRAY</em>, no data is read from <em>Data</em> , but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see <strong>gl:getError/0</strong> ). To query for an entire mipmap array, use an image array level greater than or equal to 1.</p><p><em>Internalformat</em> must be a known compressed image format (such as <em>?GL_RGTC</em>) or an extension-specified compressed-texture format. When a texture is loaded with <strong>gl:texImage2D/9</strong> using a generic compressed texture format (e.g., <em>?GL_COMPRESSED_RGB</em>), the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using <em>gl:compressedTexImage3D</em>, query the compressed texture image's size and format using <strong>gl:getTexLevelParameterfv/3</strong> .</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for <strong>gl:texImage1D/8</strong> . In the following description, denote by b s, b w, b h, and b d, the values of pixel storage modes <em>?GL_UNPACK_COMPRESSED_BLOCK_SIZE</em>, <em>?GL_UNPACK_COMPRESSED_BLOCK_WIDTH</em>, <em>?GL_UNPACK_COMPRESSED_BLOCK_HEIGHT</em> , and <em>?GL_UNPACK_COMPRESSED_BLOCK_DEPTH</em>, respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels.</p><p>By default the pixel storage modes <em>?GL_UNPACK_ROW_LENGTH</em>, <em>?GL_UNPACK_SKIP_ROWS</em> , <em>?GL_UNPACK_SKIP_PIXELS</em>, <em>?GL_UNPACK_IMAGE_HEIGHT</em> and <em>?GL_UNPACK_SKIP_IMAGES</em> are ignored for compressed images. To enable <em>?GL_UNPACK_SKIP_PIXELS</em> and <em>?GL_UNPACK_ROW_LENGTH</em> , b s and b w must both be non-zero. To also enable <em>?GL_UNPACK_SKIP_ROWS</em> and <em>?GL_UNPACK_IMAGE_HEIGHT</em> , b h must be non-zero. To also enable <em>?GL_UNPACK_SKIP_IMAGES</em>, b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.</p><p>When selecting a sub-rectangle from a compressed image: the value of <em>?GL_UNPACK_SKIP_PIXELS</em> must be a multiple of b w;the value of <em>?GL_UNPACK_SKIP_ROWS</em> must be a multiple of b w;the value of <em>?GL_UNPACK_SKIP_IMAGES</em> must be a multiple of b w.</p><p><em>ImageSize</em> must be equal to:</p><p>b s×|width b/w|×|height b/h|×|depth b/d|</p><p>See external documentation.</p><p><strong></strong> compressedTexImage2D(Target, Level, Internalformat, Width, Height, Border, ImageSize, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Height = integer()</p><p>Border = integer()</p><p>ImageSize = integer()</p><p>Data = offset() | mem()</p><p>Specify a two-dimensional texture image in a compressed format</p><p>Texturing allows elements of an image array to be read by shaders.</p><p><em>gl:compressedTexImage2D</em> loads a previously defined, and retrieved, compressed two-dimensional texture image if <em>Target</em> is <em>?GL_TEXTURE_2D</em>, or one of the cube map faces such as <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_X</em>. (see <strong>gl:texImage2D/9</strong> ).</p><p>If <em>Target</em> is <em>?GL_TEXTURE_1D_ARRAY</em>, <em>Data</em> is treated as an array of compressed 1D textures.</p><p>If <em>Target</em> is <em>?GL_PROXY_TEXTURE_2D</em>, <em>?GL_PROXY_TEXTURE_1D_ARRAY</em> or <em>?GL_PROXY_CUBE_MAP</em> , no data is read from <em>Data</em> , but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see <strong>gl:getError/0</strong> ). To query for an entire mipmap array, use an image array level greater than or equal to 1.</p><p><em>Internalformat</em> must be a known compressed image format (such as <em>?GL_RGTC</em>) or an extension-specified compressed-texture format. When a texture is loaded with <strong>gl:texImage2D/9</strong> using a generic compressed texture format (e.g., <em>?GL_COMPRESSED_RGB</em>), the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using <em>gl:compressedTexImage2D</em>, query the compressed texture image's size and format using <strong>gl:getTexLevelParameterfv/3</strong> .</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for <strong>gl:texImage2D/9</strong> . In the following description, denote by b s, b w, b h, and b d, the values of pixel storage modes <em>?GL_UNPACK_COMPRESSED_BLOCK_SIZE</em>, <em>?GL_UNPACK_COMPRESSED_BLOCK_WIDTH</em>, <em>?GL_UNPACK_COMPRESSED_BLOCK_HEIGHT</em> , and <em>?GL_UNPACK_COMPRESSED_BLOCK_DEPTH</em>, respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels.</p><p>By default the pixel storage modes <em>?GL_UNPACK_ROW_LENGTH</em>, <em>?GL_UNPACK_SKIP_ROWS</em> , <em>?GL_UNPACK_SKIP_PIXELS</em>, <em>?GL_UNPACK_IMAGE_HEIGHT</em> and <em>?GL_UNPACK_SKIP_IMAGES</em> are ignored for compressed images. To enable <em>?GL_UNPACK_SKIP_PIXELS</em> and <em>?GL_UNPACK_ROW_LENGTH</em> , b s and b w must both be non-zero. To also enable <em>?GL_UNPACK_SKIP_ROWS</em> and <em>?GL_UNPACK_IMAGE_HEIGHT</em> , b h must be non-zero. To also enable <em>?GL_UNPACK_SKIP_IMAGES</em>, b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.</p><p>When selecting a sub-rectangle from a compressed image: the value of <em>?GL_UNPACK_SKIP_PIXELS</em> must be a multiple of b w;the value of <em>?GL_UNPACK_SKIP_ROWS</em> must be a multiple of b w.</p><p><em>ImageSize</em> must be equal to:</p><p>b s×|width b/w|×|height b/h|</p><p>See external documentation.</p><p><strong></strong> compressedTexImage1D(Target, Level, Internalformat, Width, Border, ImageSize, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Border = integer()</p><p>ImageSize = integer()</p><p>Data = offset() | mem()</p><p>Specify a one-dimensional texture image in a compressed format</p><p>Texturing allows elements of an image array to be read by shaders.</p><p><em>gl:compressedTexImage1D</em> loads a previously defined, and retrieved, compressed one-dimensional texture image if <em>Target</em> is <em>?GL_TEXTURE_1D</em> (see <strong>gl:texImage1D/8</strong> ).</p><p>If <em>Target</em> is <em>?GL_PROXY_TEXTURE_1D</em>, no data is read from <em>Data</em> , but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see <strong>gl:getError/0</strong> ). To query for an entire mipmap array, use an image array level greater than or equal to 1.</p><p><em>Internalformat</em> must be an extension-specified compressed-texture format. When a texture is loaded with <strong>gl:texImage1D/8</strong> using a generic compressed texture format (e.g., <em>?GL_COMPRESSED_RGB</em>) the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using <em>gl:compressedTexImage1D</em> , query the compressed texture image's size and format using <strong>gl:getTexLevelParameterfv/3</strong> .</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for <strong>gl:texImage1D/8</strong> . In the following description, denote by b s, b w, b h, and b d, the values of pixel storage modes <em>?GL_UNPACK_COMPRESSED_BLOCK_SIZE</em>, <em>?GL_UNPACK_COMPRESSED_BLOCK_WIDTH</em>, <em>?GL_UNPACK_COMPRESSED_BLOCK_HEIGHT</em> , and <em>?GL_UNPACK_COMPRESSED_BLOCK_DEPTH</em>, respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels.</p><p>By default the pixel storage modes <em>?GL_UNPACK_ROW_LENGTH</em>, <em>?GL_UNPACK_SKIP_ROWS</em> , <em>?GL_UNPACK_SKIP_PIXELS</em>, <em>?GL_UNPACK_IMAGE_HEIGHT</em> and <em>?GL_UNPACK_SKIP_IMAGES</em> are ignored for compressed images. To enable <em>?GL_UNPACK_SKIP_PIXELS</em> and <em>?GL_UNPACK_ROW_LENGTH</em> , b s and b w must both be non-zero. To also enable <em>?GL_UNPACK_SKIP_ROWS</em> and <em>?GL_UNPACK_IMAGE_HEIGHT</em> , b h must be non-zero. To also enable <em>?GL_UNPACK_SKIP_IMAGES</em>, b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.</p><p>When selecting a sub-rectangle from a compressed image: the value of <em>?GL_UNPACK_SKIP_PIXELS</em> must be a multiple of b w;</p><p><em>ImageSize</em> must be equal to:</p><p>b s×|width b/w|</p><p>See external documentation.</p><p><strong></strong> compressedTexSubImage3D(Target, Level, Xoffset, Yoffset, Zoffset, Width, Height, Depth, Format, ImageSize, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>Yoffset = integer()</p><p>Zoffset = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Depth = integer()</p><p>Format = enum()</p><p>ImageSize = integer()</p><p>Data = offset() | mem()</p><p>Specify a three-dimensional texture subimage in a compressed format</p><p>Texturing allows elements of an image array to be read by shaders.</p><p><em>gl:compressedTexSubImage3D</em> redefines a contiguous subregion of an existing three-dimensional texture image. The texels referenced by <em>Data</em> replace the portion of the existing texture array with x indices <em>Xoffset</em> and xoffset+width-1, and the y indices <em>Yoffset</em> and yoffset+height-1, and the z indices <em>Zoffset</em> and zoffset+depth-1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.</p><p><em>Internalformat</em> must be a known compressed image format (such as <em>?GL_RGTC</em>) or an extension-specified compressed-texture format. The <em>Format</em> of the compressed texture image is selected by the GL implementation that compressed it (see <strong>gl:texImage3D/10</strong> ) and should be queried at the time the texture was compressed with <strong>gl:getTexLevelParameterfv/3</strong> .</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>See external documentation.</p><p><strong></strong> compressedTexSubImage2D(Target, Level, Xoffset, Yoffset, Width, Height, Format, ImageSize, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>Yoffset = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Format = enum()</p><p>ImageSize = integer()</p><p>Data = offset() | mem()</p><p>Specify a two-dimensional texture subimage in a compressed format</p><p>Texturing allows elements of an image array to be read by shaders.</p><p><em>gl:compressedTexSubImage2D</em> redefines a contiguous subregion of an existing two-dimensional texture image. The texels referenced by <em>Data</em> replace the portion of the existing texture array with x indices <em>Xoffset</em> and xoffset+width-1, and the y indices <em>Yoffset</em> and yoffset+height-1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.</p><p><em>Internalformat</em> must be a known compressed image format (such as <em>?GL_RGTC</em>) or an extension-specified compressed-texture format. The <em>Format</em> of the compressed texture image is selected by the GL implementation that compressed it (see <strong>gl:texImage2D/9</strong> ) and should be queried at the time the texture was compressed with <strong>gl:getTexLevelParameterfv/3</strong> .</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>See external documentation.</p><p><strong></strong> compressedTexSubImage1D(Target, Level, Xoffset, Width, Format, ImageSize, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Level = integer()</p><p>Xoffset = integer()</p><p>Width = integer()</p><p>Format = enum()</p><p>ImageSize = integer()</p><p>Data = offset() | mem()</p><p>Specify a one-dimensional texture subimage in a compressed format</p><p>Texturing allows elements of an image array to be read by shaders.</p><p><em>gl:compressedTexSubImage1D</em> redefines a contiguous subregion of an existing one-dimensional texture image. The texels referenced by <em>Data</em> replace the portion of the existing texture array with x indices <em>Xoffset</em> and xoffset+width-1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.</p><p><em>Internalformat</em> must be a known compressed image format (such as <em>?GL_RGTC</em>) or an extension-specified compressed-texture format. The <em>Format</em> of the compressed texture image is selected by the GL implementation that compressed it (see <strong>gl:texImage1D/8</strong> ), and should be queried at the time the texture was compressed with <strong>gl:getTexLevelParameterfv/3</strong> .</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is specified, <em>Data</em> is treated as a byte offset into the buffer object's data store.</p><p>See external documentation.</p><p><strong></strong> getCompressedTexImage(Target, Lod, Img) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Lod = integer()</p><p>Img = mem()</p><p>Return a compressed texture image</p><p><em>gl:getCompressedTexImage</em> returns the compressed texture image associated with <em>Target</em> and <em>Lod</em> into <em>Img</em> . <em>Img</em> should be an array of <em>?GL_TEXTURE_COMPRESSED_IMAGE_SIZE</em> bytes. <em>Target</em> specifies whether the desired texture image was one specified by <strong>gl:texImage1D/8</strong> (<em>?GL_TEXTURE_1D</em>), <strong>gl:texImage2D/9</strong> (<em>?GL_TEXTURE_2D</em> or any of <em>?GL_TEXTURE_CUBE_MAP_*</em> ), or <strong>gl:texImage3D/10</strong> (<em>?GL_TEXTURE_3D</em>). <em>Lod</em> specifies the level-of-detail number of the desired image.</p><p>If a non-zero named buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a texture image is requested, <em>Img</em> is treated as a byte offset into the buffer object's data store.</p><p>To minimize errors, first verify that the texture is compressed by calling <strong>gl:getTexLevelParameterfv/3</strong> with argument <em>?GL_TEXTURE_COMPRESSED</em>. If the texture is compressed, then determine the amount of memory required to store the compressed texture by calling <strong>gl:getTexLevelParameterfv/3</strong> with argument <em>?GL_TEXTURE_COMPRESSED_IMAGE_SIZE</em>. Finally, retrieve the internal format of the texture by calling <strong>gl:getTexLevelParameterfv/3</strong> with argument <em>?GL_TEXTURE_INTERNAL_FORMAT</em> . To store the texture for later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective texture or subtexture loading routine used for loading <em>Target</em> textures.</p><p>See external documentation.</p><p><strong></strong> clientActiveTexture(Texture) -&gt; ok</p><p>Types:</p><p>Texture = enum()</p><p>Select active texture unit</p><p><em>gl:clientActiveTexture</em> selects the vertex array client state parameters to be modified by <strong>gl:texCoordPointer/4</strong> , and enabled or disabled with <strong>gl:enableClientState/1</strong> or <strong>gl:enableClientState/1</strong> , respectively, when called with a parameter of <em>?GL_TEXTURE_COORD_ARRAY</em> .</p><p>See external documentation.</p><p><strong></strong> multiTexCoord1d(Target, S) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = float()</p><p>Set the current texture coordinates</p><p><em>gl:multiTexCoord</em> specifies texture coordinates in one, two, three, or four dimensions. <em>gl:multiTexCoord1</em> sets the current texture coordinates to (s 0 0 1); a call to <em>gl:multiTexCoord2</em> sets them to (s t 0 1). Similarly, <em>gl:multiTexCoord3</em> specifies the texture coordinates as (s t r 1), and <em>gl:multiTexCoord4</em> defines all four components explicitly as (s t r q).</p><p>The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for (s t r q) are (0 0 0 1).</p><p>See external documentation.</p><p><strong></strong> multiTexCoord1dv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::float()}</p><p>Equivalent to <strong>multiTexCoord1d(Target, S)</strong>.</p><p><strong></strong> multiTexCoord1f(Target, S) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = float()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord1fv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::float()}</p><p>Equivalent to <strong>multiTexCoord1f(Target, S)</strong>.</p><p><strong></strong> multiTexCoord1i(Target, S) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = integer()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord1iv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::integer()}</p><p>Equivalent to <strong>multiTexCoord1i(Target, S)</strong>.</p><p><strong></strong> multiTexCoord1s(Target, S) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = integer()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord1sv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::integer()}</p><p>Equivalent to <strong>multiTexCoord1s(Target, S)</strong>.</p><p><strong></strong> multiTexCoord2d(Target, S, T) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = float()</p><p>T = float()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord2dv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float()}</p><p>Equivalent to <strong>multiTexCoord2d(Target, S, T)</strong>.</p><p><strong></strong> multiTexCoord2f(Target, S, T) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = float()</p><p>T = float()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord2fv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float()}</p><p>Equivalent to <strong>multiTexCoord2f(Target, S, T)</strong>.</p><p><strong></strong> multiTexCoord2i(Target, S, T) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = integer()</p><p>T = integer()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord2iv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer()}</p><p>Equivalent to <strong>multiTexCoord2i(Target, S, T)</strong>.</p><p><strong></strong> multiTexCoord2s(Target, S, T) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = integer()</p><p>T = integer()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord2sv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer()}</p><p>Equivalent to <strong>multiTexCoord2s(Target, S, T)</strong>.</p><p><strong></strong> multiTexCoord3d(Target, S, T, R) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = float()</p><p>T = float()</p><p>R = float()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord3dv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float(), R::float()}</p><p>Equivalent to <strong>multiTexCoord3d(Target, S, T, R)</strong>.</p><p><strong></strong> multiTexCoord3f(Target, S, T, R) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = float()</p><p>T = float()</p><p>R = float()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord3fv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float(), R::float()}</p><p>Equivalent to <strong>multiTexCoord3f(Target, S, T, R)</strong>.</p><p><strong></strong> multiTexCoord3i(Target, S, T, R) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = integer()</p><p>T = integer()</p><p>R = integer()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord3iv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer(), R::integer()}</p><p>Equivalent to <strong>multiTexCoord3i(Target, S, T, R)</strong>.</p><p><strong></strong> multiTexCoord3s(Target, S, T, R) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = integer()</p><p>T = integer()</p><p>R = integer()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord3sv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer(), R::integer()}</p><p>Equivalent to <strong>multiTexCoord3s(Target, S, T, R)</strong>.</p><p><strong></strong> multiTexCoord4d(Target, S, T, R, Q) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = float()</p><p>T = float()</p><p>R = float()</p><p>Q = float()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord4dv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float(), R::float(), Q::float()}</p><p>Equivalent to <strong>multiTexCoord4d(Target, S, T, R, Q)</strong>.</p><p><strong></strong> multiTexCoord4f(Target, S, T, R, Q) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = float()</p><p>T = float()</p><p>R = float()</p><p>Q = float()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord4fv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::float(), T::float(), R::float(), Q::float()}</p><p>Equivalent to <strong>multiTexCoord4f(Target, S, T, R, Q)</strong>.</p><p><strong></strong> multiTexCoord4i(Target, S, T, R, Q) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = integer()</p><p>T = integer()</p><p>R = integer()</p><p>Q = integer()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord4iv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer(), R::integer(), Q::integer()}</p><p>Equivalent to <strong>multiTexCoord4i(Target, S, T, R, Q)</strong>.</p><p><strong></strong> multiTexCoord4s(Target, S, T, R, Q) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>S = integer()</p><p>T = integer()</p><p>R = integer()</p><p>Q = integer()</p><p>See <strong>multiTexCoord1d/2</strong></p><p><strong></strong> multiTexCoord4sv(Target::enum(), V) -&gt; ok</p><p>Types:</p><p>V = {S::integer(), T::integer(), R::integer(), Q::integer()}</p><p>Equivalent to <strong>multiTexCoord4s(Target, S, T, R, Q)</strong>.</p><p><strong></strong> loadTransposeMatrixf(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>Replace the current matrix with the specified row-major ordered matrix</p><p><em>gl:loadTransposeMatrix</em> replaces the current matrix with the one whose elements are specified by <em>M</em> . The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see <strong>gl:matrixMode/1</strong> ).</p><p>The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview matrix. If v=(v[0] v[1] v[2] v[3]) is the set of object coordinates of a vertex, and <em>M</em> points to an array of 16 single- or double-precision floating-point values m={m[0] m[1] ... m[15]}, then the modelview transformation M(v) does the following:</p><p>M(v)=(m[0] m[1] m[2] m[3] m[4] m[5] m[6] m[7] m[8] m[9] m[10] m[11] m[12] m[13] m[14] m[15])×(v[0] v[1] v[2] v[3])</p><p>Projection and texture transformations are similarly defined.</p><p>Calling <em>gl:loadTransposeMatrix</em> with matrix M is identical in operation to <strong>gl:loadMatrixd/1</strong> with M T, where T represents the transpose.</p><p>See external documentation.</p><p><strong></strong> loadTransposeMatrixd(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>See <strong>loadTransposeMatrixf/1</strong></p><p><strong></strong> multTransposeMatrixf(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>Multiply the current matrix with the specified row-major ordered matrix</p><p><em>gl:multTransposeMatrix</em> multiplies the current matrix with the one specified using <em>M</em> , and replaces the current matrix with the product.</p><p>The current matrix is determined by the current matrix mode (see <strong>gl:matrixMode/1</strong> ). It is either the projection matrix, modelview matrix, or the texture matrix.</p><p>See external documentation.</p><p><strong></strong> multTransposeMatrixd(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>See <strong>multTransposeMatrixf/1</strong></p><p><strong></strong> blendFuncSeparate(SfactorRGB, DfactorRGB, SfactorAlpha, DfactorAlpha) -&gt; ok</p><p>Types:</p><p>SfactorRGB = enum()</p><p>DfactorRGB = enum()</p><p>SfactorAlpha = enum()</p><p>DfactorAlpha = enum()</p><p>Specify pixel arithmetic for RGB and alpha components separately</p><p>Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_BLEND</em> to enable and disable blending.</p><p><em>gl:blendFuncSeparate</em> defines the operation of blending for all draw buffers when it is enabled. <em>gl:blendFuncSeparatei</em> defines the operation of blending for a single draw buffer specified by <em>Buf</em> when enabled for that draw buffer. <em>SrcRGB</em> specifies which method is used to scale the source RGB-color components. <em>DstRGB</em> specifies which method is used to scale the destination RGB-color components. Likewise, <em>SrcAlpha</em> specifies which method is used to scale the source alpha color component, and <em>DstAlpha</em> specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.</p><p>In the table and in subsequent equations, first source, second source and destination color components are referred to as (R s0 G s0 B s0 A s0), (R s1 G s1 B s1 A s1), and (R d G d B d A d), respectively. The color specified by <strong>gl:blendColor/4</strong> is referred to as (R c G c B c A c). They are understood to have integer values between 0 and (k R k G k B k A), where</p><p>k c=2(m c)-1</p><p>and (m R m G m B m A) is the number of red, green, blue, and alpha bitplanes.</p><p>Source and destination scale factors are referred to as (s R s G s B s A) and (d R d G d B d A). All scale factors have range [0 1].<em>Parameter</em><em>RGB Factor</em><em>Alpha Factor</em></p><p><em>?GL_ZERO</em>(0 0 0) 0</p><p><em>?GL_ONE</em> (1 1 1) 1</p><p><em>?GL_SRC_COLOR</em>(R s0 k/R G s0 k/G B s0 k/B) A s0 k/A</p><p><em>?GL_ONE_MINUS_SRC_COLOR</em>(1 1 1 1)-(R s0 k/R G s0 k/G B s0 k/B) 1-A s0 k/A</p><p><em>?GL_DST_COLOR</em>(R d k/R G d k/G B d k/B) A d k/A</p><p><em>?GL_ONE_MINUS_DST_COLOR</em> (1 1 1)-(R d k/R G d k/G B d k/B) 1-A d k/A</p><p><em>?GL_SRC_ALPHA</em>(A s0 k/A A s0 k/A A s0 k/A) A s0 k/A</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em>(1 1 1)-(A s0 k/A A s0 k/A A s0 k/A ) 1-A s0 k/A</p><p><em>?GL_DST_ALPHA</em>(A d k/A A d k/A A d k/A) A d k/A</p><p><em>?GL_ONE_MINUS_DST_ALPHA</em> (1 1 1)-(A d k/A A d k/A A d k/A) 1-A d k/A</p><p><em>?GL_CONSTANT_COLOR</em>(R c G c B c) A c</p><p><em>?GL_ONE_MINUS_CONSTANT_COLOR</em>(1 1 1)-(R c G c B c) 1-A c</p><p><em>?GL_CONSTANT_ALPHA</em>(A c A c A c) A c</p><p><em>?GL_ONE_MINUS_CONSTANT_ALPHA</em> (1 1 1)-(A c A c A c) 1-A c</p><p><em>?GL_SRC_ALPHA_SATURATE</em>(i i i) 1</p><p><em>?GL_SRC1_COLOR</em>(R s1 k/R G s1 k/G B s1 k/B) A s1 k/A</p><p><em>?GL_ONE_MINUS_SRC_COLOR</em> (1 1 1 1)-(R s1 k/R G s1 k/G B s1 k/B) 1-A s1 k/A</p><p><em>?GL_SRC1_ALPHA</em>(A s1 k/A A s1 k/A A s1 k/A) A s1 k/A</p><p><em>?GL_ONE_MINUS_SRC_ALPHA</em>(1 1 1)-(A s1 k/A A s1 k/A A s1 k/A ) 1-A s1 k/A</p><p>In the table,</p><p>i=min(A s 1-(A d))</p><p>To determine the blended RGBA values of a pixel, the system uses the following equations:</p><p>R d=min(k R R s s R+R d d R) G d=min(k G G s s G+G d d G) B d=min(k B B s s B+B d d B) A d=min(k A A s s A+A d d A)</p><p>Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when <em>SrcRGB</em> is <em>?GL_SRC_ALPHA</em> , <em>DstRGB</em> is <em>?GL_ONE_MINUS_SRC_ALPHA</em>, and A s is equal to k A, the equations reduce to simple replacement:</p><p>R d=R s G d=G s B d=B s A d=A s</p><p>See external documentation.</p><p><strong></strong> multiDrawArrays(Mode, First, Count) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>First = [integer()]</p><p>Count = [integer()]</p><p>Render multiple sets of primitives from array data</p><p><em>gl:multiDrawArrays</em> specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to <em>gl:multiDrawArrays</em>.</p><p><em>gl:multiDrawArrays</em> behaves identically to <strong>gl:drawArrays/3</strong> except that <em>Primcount</em> separate ranges of elements are specified instead.</p><p>When <em>gl:multiDrawArrays</em> is called, it uses <em>Count</em> sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element <em>First</em> . <em>Mode</em> specifies what kind of primitives are constructed, and how the array elements construct those primitives.</p><p>Vertex attributes that are modified by <em>gl:multiDrawArrays</em> have an unspecified value after <em>gl:multiDrawArrays</em> returns. Attributes that aren't modified remain well defined.</p><p>See external documentation.</p><p><strong></strong> pointParameterf(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = float()</p><p>Specify point parameters</p><p>The following values are accepted for <em>Pname</em> :</p><p><em>?GL_POINT_FADE_THRESHOLD_SIZE</em>: <em>Params</em> is a single floating-point value that specifies the threshold value to which point sizes are clamped if they exceed the specified value. The default value is 1.0.</p><p><em>?GL_POINT_SPRITE_COORD_ORIGIN</em>: <em>Params</em> is a single enum specifying the point sprite texture coordinate origin, either <em>?GL_LOWER_LEFT</em> or <em>?GL_UPPER_LEFT</em>. The default value is <em>?GL_UPPER_LEFT</em>.</p><p>See external documentation.</p><p><strong></strong> pointParameterfv(Pname, Params) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Params = {float()}</p><p>See <strong>pointParameterf/2</strong></p><p><strong></strong> pointParameteri(Pname, Param) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Param = integer()</p><p>See <strong>pointParameterf/2</strong></p><p><strong></strong> pointParameteriv(Pname, Params) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>pointParameterf/2</strong></p><p><strong></strong> fogCoordf(Coord) -&gt; ok</p><p>Types:</p><p>Coord = float()</p><p>Set the current fog coordinates</p><p><em>gl:fogCoord</em> specifies the fog coordinate that is associated with each vertex and the current raster position. The value specified is interpolated and used in computing the fog color (see <strong>gl:fogf/2</strong> ).</p><p>See external documentation.</p><p><strong></strong> fogCoordfv(Coord) -&gt; ok</p><p>Types:</p><p>Coord = {Coord::float()}</p><p>Equivalent to <strong>fogCoordf(Coord)</strong>.</p><p><strong></strong> fogCoordd(Coord) -&gt; ok</p><p>Types:</p><p>Coord = float()</p><p>See <strong>fogCoordf/1</strong></p><p><strong></strong> fogCoorddv(Coord) -&gt; ok</p><p>Types:</p><p>Coord = {Coord::float()}</p><p>Equivalent to <strong>fogCoordd(Coord)</strong>.</p><p><strong></strong> fogCoordPointer(Type, Stride, Pointer) -&gt; ok</p><p>Types:</p><p>Type = enum()</p><p>Stride = integer()</p><p>Pointer = offset() | mem()</p><p>Define an array of fog coordinates</p><p><em>gl:fogCoordPointer</em> specifies the location and data format of an array of fog coordinates to use when rendering. <em>Type</em> specifies the data type of each fog coordinate, and <em>Stride</em> specifies the byte stride from one fog coordinate to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.</p><p>If a non-zero named buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a fog coordinate array is specified, <em>Pointer</em> is treated as a byte offset into the buffer object's data store. Also, the buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em> ) is saved as fog coordinate vertex array client-side state (<em>?GL_FOG_COORD_ARRAY_BUFFER_BINDING</em> ).</p><p>When a fog coordinate array is specified, <em>Type</em> , <em>Stride</em> , and <em>Pointer</em> are saved as client-side state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable the fog coordinate array, call <strong>gl:enableClientState/1</strong> and <strong>gl:enableClientState/1</strong> with the argument <em>?GL_FOG_COORD_ARRAY</em>. If enabled, the fog coordinate array is used when <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em> , <strong>gl:drawRangeElements/6</strong> , or <strong>gl:arrayElement/1</strong> is called.</p><p>See external documentation.</p><p><strong></strong> secondaryColor3b(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>Set the current secondary color</p><p>The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where alpha is always set to 0.0) that is associated with every vertex.</p><p>The secondary color is interpolated and applied to each fragment during rasterization when <em>?GL_COLOR_SUM</em> is enabled. When lighting is enabled, and <em>?GL_SEPARATE_SPECULAR_COLOR</em> is specified, the value of the secondary color is assigned the value computed from the specular term of the lighting computation. Both the primary and secondary current colors are applied to each fragment, regardless of the state of <em>?GL_COLOR_SUM</em>, under such conditions. When <em>?GL_SEPARATE_SPECULAR_COLOR</em> is specified, the value returned from querying the current secondary color is undefined.</p><p><em>gl:secondaryColor3b</em>, <em>gl:secondaryColor3s</em>, and <em>gl:secondaryColor3i</em> take three signed byte, short, or long integers as arguments. When <em>v</em> is appended to the name, the color commands can take a pointer to an array of such values.</p><p>Color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0). Floating-point values are mapped directly.</p><p>Neither floating-point nor signed integer values are clamped to the range [0 1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.</p><p>See external documentation.</p><p><strong></strong> secondaryColor3bv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>secondaryColor3b(Red, Green, Blue)</strong>.</p><p><strong></strong> secondaryColor3d(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = float()</p><p>Green = float()</p><p>Blue = float()</p><p>See <strong>secondaryColor3b/3</strong></p><p><strong></strong> secondaryColor3dv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::float(), Green::float(), Blue::float()}</p><p>Equivalent to <strong>secondaryColor3d(Red, Green, Blue)</strong>.</p><p><strong></strong> secondaryColor3f(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = float()</p><p>Green = float()</p><p>Blue = float()</p><p>See <strong>secondaryColor3b/3</strong></p><p><strong></strong> secondaryColor3fv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::float(), Green::float(), Blue::float()}</p><p>Equivalent to <strong>secondaryColor3f(Red, Green, Blue)</strong>.</p><p><strong></strong> secondaryColor3i(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>secondaryColor3b/3</strong></p><p><strong></strong> secondaryColor3iv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>secondaryColor3i(Red, Green, Blue)</strong>.</p><p><strong></strong> secondaryColor3s(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>secondaryColor3b/3</strong></p><p><strong></strong> secondaryColor3sv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>secondaryColor3s(Red, Green, Blue)</strong>.</p><p><strong></strong> secondaryColor3ub(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>secondaryColor3b/3</strong></p><p><strong></strong> secondaryColor3ubv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>secondaryColor3ub(Red, Green, Blue)</strong>.</p><p><strong></strong> secondaryColor3ui(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>secondaryColor3b/3</strong></p><p><strong></strong> secondaryColor3uiv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>secondaryColor3ui(Red, Green, Blue)</strong>.</p><p><strong></strong> secondaryColor3us(Red, Green, Blue) -&gt; ok</p><p>Types:</p><p>Red = integer()</p><p>Green = integer()</p><p>Blue = integer()</p><p>See <strong>secondaryColor3b/3</strong></p><p><strong></strong> secondaryColor3usv(V) -&gt; ok</p><p>Types:</p><p>V = {Red::integer(), Green::integer(), Blue::integer()}</p><p>Equivalent to <strong>secondaryColor3us(Red, Green, Blue)</strong>.</p><p><strong></strong> secondaryColorPointer(Size, Type, Stride, Pointer) -&gt; ok</p><p>Types:</p><p>Size = integer()</p><p>Type = enum()</p><p>Stride = integer()</p><p>Pointer = offset() | mem()</p><p>Define an array of secondary colors</p><p><em>gl:secondaryColorPointer</em> specifies the location and data format of an array of color components to use when rendering. <em>Size</em> specifies the number of components per color, and must be 3. <em>Type</em> specifies the data type of each color component, and <em>Stride</em> specifies the byte stride from one color to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.</p><p>If a non-zero named buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ) while a secondary color array is specified, <em>Pointer</em> is treated as a byte offset into the buffer object's data store. Also, the buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em> ) is saved as secondary color vertex array client-side state (<em>?GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING</em> ).</p><p>When a secondary color array is specified, <em>Size</em> , <em>Type</em> , <em>Stride</em> , and <em>Pointer</em> are saved as client-side state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable the secondary color array, call <strong>gl:enableClientState/1</strong> and <strong>gl:enableClientState/1</strong> with the argument <em>?GL_SECONDARY_COLOR_ARRAY</em>. If enabled, the secondary color array is used when <strong>gl:arrayElement/1</strong> , <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em>, or <strong>gl:drawRangeElements/6</strong> is called.</p><p>See external documentation.</p><p><strong></strong> windowPos2d(X, Y) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Specify the raster position in window coordinates for pixel operations</p><p>The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See <strong>gl:bitmap/7</strong> , <strong>gl:drawPixels/5</strong> , and <strong>gl:copyPixels/5</strong> .</p><p><em>gl:windowPos2</em> specifies the x and y coordinates, while z is implicitly set to 0. <em>gl:windowPos3</em> specifies all three coordinates. The w coordinate of the current raster position is always set to 1.0.</p><p><em>gl:windowPos</em> directly updates the x and y coordinates of the current raster position with the values specified. That is, the values are neither transformed by the current modelview and projection matrices, nor by the viewport-to-window transform. The z coordinate of the current raster position is updated in the following manner:</p><p>z={n f(n+z×(f-n)) if z&lt;= 0 if z&gt;= 1(otherwise))</p><p>where n is <em>?GL_DEPTH_RANGE</em>'s near value, and f is <em>?GL_DEPTH_RANGE</em>'s far value. See <strong>gl:depthRange/2</strong> .</p><p>The specified coordinates are not clip-tested, causing the raster position to always be valid.</p><p>The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then <em>?GL_CURRENT_RASTER_COLOR</em> (in RGBA mode) or <em>?GL_CURRENT_RASTER_INDEX</em> (in color index mode) is set to the color produced by the lighting calculation (see <strong>gl:lightf/3</strong> , <strong>gl:lightModelf/2</strong> , and <strong>gl:shadeModel/1</strong> ). If lighting is disabled, current color (in RGBA mode, state variable <em>?GL_CURRENT_COLOR</em>) or color index (in color index mode, state variable <em>?GL_CURRENT_INDEX</em>) is used to update the current raster color. <em>?GL_CURRENT_RASTER_SECONDARY_COLOR</em> (in RGBA mode) is likewise updated.</p><p>Likewise, <em>?GL_CURRENT_RASTER_TEXTURE_COORDS</em> is updated as a function of <em>?GL_CURRENT_TEXTURE_COORDS</em> , based on the texture matrix and the texture generation functions (see <strong>gl:texGend/3</strong> ). The <em>?GL_CURRENT_RASTER_DISTANCE</em> is set to the <em>?GL_CURRENT_FOG_COORD</em>.</p><p>See external documentation.</p><p><strong></strong> windowPos2dv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>windowPos2d(X, Y)</strong>.</p><p><strong></strong> windowPos2f(X, Y) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>See <strong>windowPos2d/2</strong></p><p><strong></strong> windowPos2fv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>windowPos2f(X, Y)</strong>.</p><p><strong></strong> windowPos2i(X, Y) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>windowPos2d/2</strong></p><p><strong></strong> windowPos2iv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>windowPos2i(X, Y)</strong>.</p><p><strong></strong> windowPos2s(X, Y) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>windowPos2d/2</strong></p><p><strong></strong> windowPos2sv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>windowPos2s(X, Y)</strong>.</p><p><strong></strong> windowPos3d(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>windowPos2d/2</strong></p><p><strong></strong> windowPos3dv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>windowPos3d(X, Y, Z)</strong>.</p><p><strong></strong> windowPos3f(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>windowPos2d/2</strong></p><p><strong></strong> windowPos3fv(V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>windowPos3f(X, Y, Z)</strong>.</p><p><strong></strong> windowPos3i(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>windowPos2d/2</strong></p><p><strong></strong> windowPos3iv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>windowPos3i(X, Y, Z)</strong>.</p><p><strong></strong> windowPos3s(X, Y, Z) -&gt; ok</p><p>Types:</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>windowPos2d/2</strong></p><p><strong></strong> windowPos3sv(V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>windowPos3s(X, Y, Z)</strong>.</p><p><strong></strong> genQueries(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>Generate query object names</p><p><em>gl:genQueries</em> returns <em>N</em> query object names in <em>Ids</em> . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to <em>gl:genQueries</em>.</p><p>Query object names returned by a call to <em>gl:genQueries</em> are not returned by subsequent calls, unless they are first deleted with <strong>gl:deleteQueries/1</strong> .</p><p>No query objects are associated with the returned query object names until they are first used by calling <strong>gl:beginQuery/2</strong> .</p><p>See external documentation.</p><p><strong></strong> deleteQueries(Ids) -&gt; ok</p><p>Types:</p><p>Ids = [integer()]</p><p>Delete named query objects</p><p><em>gl:deleteQueries</em> deletes <em>N</em> query objects named by the elements of the array <em>Ids</em> . After a query object is deleted, it has no contents, and its name is free for reuse (for example by <strong>gl:genQueries/1</strong> ).</p><p><em>gl:deleteQueries</em> silently ignores 0's and names that do not correspond to existing query objects.</p><p>See external documentation.</p><p><strong></strong> isQuery(Id) -&gt; 0 | 1</p><p>Types:</p><p>Id = integer()</p><p>Determine if a name corresponds to a query object</p><p><em>gl:isQuery</em> returns <em>?GL_TRUE</em> if <em>Id</em> is currently the name of a query object. If <em>Id</em> is zero, or is a non-zero value that is not currently the name of a query object, or if an error occurs, <em>gl:isQuery</em> returns <em>?GL_FALSE</em>.</p><p>A name returned by <strong>gl:genQueries/1</strong> , but not yet associated with a query object by calling <strong>gl:beginQuery/2</strong> , is not the name of a query object.</p><p>See external documentation.</p><p><strong></strong> beginQuery(Target, Id) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Id = integer()</p><p>Delimit the boundaries of a query object</p><p><em>gl:beginQuery</em> and <strong>gl:beginQuery/2</strong> delimit the boundaries of a query object. <em>Query</em> must be a name previously returned from a call to <strong>gl:genQueries/1</strong> . If a query object with name <em>Id</em> does not yet exist it is created with the type determined by <em>Target</em> . <em>Target</em> must be one of <em>?GL_SAMPLES_PASSED</em>, <em>?GL_ANY_SAMPLES_PASSED</em>, <em>?GL_PRIMITIVES_GENERATED</em> , <em>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</em>, or <em>?GL_TIME_ELAPSED</em>. The behavior of the query object depends on its type and is as follows.</p><p>If <em>Target</em> is <em>?GL_SAMPLES_PASSED</em>, <em>Id</em> must be an unused name, or the name of an existing occlusion query object. When <em>gl:beginQuery</em> is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes the depth test. If the value of <em>?GL_SAMPLE_BUFFERS</em> is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of <em>?GL_SAMPLE_BUFFERS</em> is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of <em>?GL_SAMPLES</em> if any sample in the fragment is covered. When <em>gl:endQuery</em> is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>.</p><p>If <em>Target</em> is <em>?GL_ANY_SAMPLES_PASSED</em>, <em>Id</em> must be an unused name, or the name of an existing boolean occlusion query object. When <em>gl:beginQuery</em> is executed, the query object's samples-passed flag is reset to <em>?GL_FALSE</em>. Subsequent rendering causes the flag to be set to <em>?GL_TRUE</em> if any sample passes the depth test. When <em>gl:endQuery</em> is executed, the samples-passed flag is assigned to the query object's result value. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>.</p><p>If <em>Target</em> is <em>?GL_PRIMITIVES_GENERATED</em>, <em>Id</em> must be an unused name, or the name of an existing primitive query object previously bound to the <em>?GL_PRIMITIVES_GENERATED</em> query binding. When <em>gl:beginQuery</em> is executed, the query object's primitives-generated counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader, or from the vertex shader if no geometry shader is present. When <em>gl:endQuery</em> is executed, the primitives-generated counter is assigned to the query object's result value. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>.</p><p>If <em>Target</em> is <em>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</em>, <em>Id</em> must be an unused name, or the name of an existing primitive query object previously bound to the <em>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</em> query binding. When <em>gl:beginQuery</em> is executed, the query object's primitives-written counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s). If transform feedback mode is not activated between the call to <em>gl:beginQuery</em> and <em>gl:endQuery</em>, the counter will not be incremented. When <em>gl:endQuery</em> is executed, the primitives-written counter is assigned to the query object's result value. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>.</p><p>If <em>Target</em> is <em>?GL_TIME_ELAPSED</em>, <em>Id</em> must be an unused name, or the name of an existing timer query object previously bound to the <em>?GL_TIME_ELAPSED</em> query binding. When <em>gl:beginQuery</em> is executed, the query object's time counter is reset to 0. When <em>gl:endQuery</em> is executed, the elapsed server time that has passed since the call to <em>gl:beginQuery</em> is written into the query object's time counter. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em> .</p><p>Querying the <em>?GL_QUERY_RESULT</em> implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. <em>?GL_QUERY_RESULT_AVAILABLE</em> can be queried to determine if the result is immediately available or if the rendering is not yet complete.</p><p>See external documentation.</p><p><strong></strong> endQuery(Target) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>See <strong>beginQuery/2</strong></p><p><strong></strong> getQueryiv(Target, Pname) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>glGetQuery</p><p>See external documentation.</p><p><strong></strong> getQueryObjectiv(Id, Pname) -&gt; integer()</p><p>Types:</p><p>Id = integer()</p><p>Pname = enum()</p><p>Return parameters of a query object</p><p><em>gl:getQueryObject</em> returns in <em>Params</em> a selected parameter of the query object specified by <em>Id</em> .</p><p><em>Pname</em> names a specific query object parameter. <em>Pname</em> can be as follows:</p><p><em>?GL_QUERY_RESULT</em>: <em>Params</em> returns the value of the query object's passed samples counter. The initial value is 0.</p><p><em>?GL_QUERY_RESULT_AVAILABLE</em>: <em>Params</em> returns whether the passed samples counter is immediately available. If a delay would occur waiting for the query result, <em>?GL_FALSE</em> is returned. Otherwise, <em>?GL_TRUE</em> is returned, which also indicates that the results of all previous queries are available as well.</p><p>See external documentation.</p><p><strong></strong> getQueryObjectuiv(Id, Pname) -&gt; integer()</p><p>Types:</p><p>Id = integer()</p><p>Pname = enum()</p><p>See <strong>getQueryObjectiv/2</strong></p><p><strong></strong> bindBuffer(Target, Buffer) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Buffer = integer()</p><p>Bind a named buffer object</p><p><em>gl:bindBuffer</em> binds a buffer object to the specified buffer binding point. Calling <em>gl:bindBuffer</em> with <em>Target</em> set to one of the accepted symbolic constants and <em>Buffer</em> set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name <em>Buffer</em> exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken.</p><p>Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, <em>Buffer</em> set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.</p><p><strong>gl:genBuffers/1</strong> must be used to generate a set of unused buffer object names.</p><p>The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with <em>?GL_READ_WRITE</em> access and <em>?GL_STATIC_DRAW</em> usage.</p><p>While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an <em>?GL_INVALID_OPERATION</em> error.</p><p>When a non-zero buffer object is bound to the <em>?GL_ARRAY_BUFFER</em> target, the vertex array pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.</p><p>When a non-zero buffer object is bound to the <em>?GL_DRAW_INDIRECT_BUFFER</em> target, parameters for draws issued through <strong>gl:drawArraysIndirect/2</strong> and <strong>gl:drawElementsIndirect/3</strong> are sourced from that buffer object.</p><p>While a non-zero buffer object is bound to the <em>?GL_ELEMENT_ARRAY_BUFFER</em> target, the indices parameter of <strong>gl:drawElements/4</strong> , <strong>gl:drawElementsInstanced/5</strong> , <strong>gl:drawElementsBaseVertex/5</strong> , <strong>gl:drawRangeElements/6</strong> , <strong>gl:drawRangeElementsBaseVertex/7</strong> , see <em>glMultiDrawElements</em> , or see <em>glMultiDrawElementsBaseVertex</em> is interpreted as an offset within the buffer object measured in basic machine units.</p><p>While a non-zero buffer object is bound to the <em>?GL_PIXEL_PACK_BUFFER</em> target, the following commands are affected: <strong>gl:getCompressedTexImage/3</strong> , <strong>gl:getTexImage/5</strong> , and <strong>gl:readPixels/7</strong> . The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.</p><p>While a non-zero buffer object is bound to the <em>?GL_PIXEL_UNPACK_BUFFER</em> target, the following commands are affected: <strong>gl:compressedTexImage1D/7</strong> , <strong>gl:compressedTexImage2D/8</strong> , <strong>gl:compressedTexImage3D/9</strong> , <strong>gl:compressedTexSubImage1D/7</strong> , <strong>gl:compressedTexSubImage2D/9</strong> , <strong>gl:compressedTexSubImage3D/11</strong> , <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:texSubImage1D/7</strong> , <strong>gl:texSubImage1D/7</strong> , and <strong>gl:texSubImage1D/7</strong> . The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.</p><p>The buffer targets <em>?GL_COPY_READ_BUFFER</em> and <em>?GL_COPY_WRITE_BUFFER</em> are provided to allow <strong>gl:copyBufferSubData/5</strong> to be used without disturbing the state of other bindings. However, <strong>gl:copyBufferSubData/5</strong> may be used with any pair of buffer binding points.</p><p>The <em>?GL_TRANSFORM_FEEDBACK_BUFFER</em> buffer binding point may be passed to <em>gl:bindBuffer</em> , but will not directly affect transform feedback state. Instead, the indexed <em>?GL_TRANSFORM_FEEDBACK_BUFFER</em> bindings must be used through a call to <strong>gl:bindBufferBase/3</strong> or <strong>gl:bindBufferRange/5</strong> . This will affect the generic <em>?GL_TRANSFORM_FEEDABCK_BUFFER</em> binding.</p><p>Likewise, the <em>?GL_UNIFORM_BUFFER</em> and <em>?GL_ATOMIC_COUNTER_BUFFER</em> buffer binding points may be used, but do not directly affect uniform buffer or atomic counter buffer state, respectively. <strong>gl:bindBufferBase/3</strong> or <strong>gl:bindBufferRange/5</strong> must be used to bind a buffer to an indexed uniform buffer or atomic counter buffer binding point.</p><p>A buffer object binding created with <em>gl:bindBuffer</em> remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with <strong>gl:deleteBuffers/1</strong> .</p><p>Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.</p><p>See external documentation.</p><p><strong></strong> deleteBuffers(Buffers) -&gt; ok</p><p>Types:</p><p>Buffers = [integer()]</p><p>Delete named buffer objects</p><p><em>gl:deleteBuffers</em> deletes <em>N</em> buffer objects named by the elements of the array <em>Buffers</em> . After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by <strong>gl:genBuffers/1</strong> ). If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any buffer object).</p><p><em>gl:deleteBuffers</em> silently ignores 0's and names that do not correspond to existing buffer objects.</p><p>See external documentation.</p><p><strong></strong> genBuffers(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>Generate buffer object names</p><p><em>gl:genBuffers</em> returns <em>N</em> buffer object names in <em>Buffers</em> . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to <em>gl:genBuffers</em> .</p><p>Buffer object names returned by a call to <em>gl:genBuffers</em> are not returned by subsequent calls, unless they are first deleted with <strong>gl:deleteBuffers/1</strong> .</p><p>No buffer objects are associated with the returned buffer object names until they are first bound by calling <strong>gl:bindBuffer/2</strong> .</p><p>See external documentation.</p><p><strong></strong> isBuffer(Buffer) -&gt; 0 | 1</p><p>Types:</p><p>Buffer = integer()</p><p>Determine if a name corresponds to a buffer object</p><p><em>gl:isBuffer</em> returns <em>?GL_TRUE</em> if <em>Buffer</em> is currently the name of a buffer object. If <em>Buffer</em> is zero, or is a non-zero value that is not currently the name of a buffer object, or if an error occurs, <em>gl:isBuffer</em> returns <em>?GL_FALSE</em> .</p><p>A name returned by <strong>gl:genBuffers/1</strong> , but not yet associated with a buffer object by calling <strong>gl:bindBuffer/2</strong> , is not the name of a buffer object.</p><p>See external documentation.</p><p><strong></strong> bufferData(Target, Size, Data, Usage) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Size = integer()</p><p>Data = offset() | mem()</p><p>Usage = enum()</p><p>Creates and initializes a buffer object's data store</p><p><em>gl:bufferData</em> creates a new data store for the buffer object currently bound to <em>Target</em> . Any pre-existing data store is deleted. The new data store is created with the specified <em>Size</em> in bytes and <em>Usage</em> . If <em>Data</em> is not <em>?NULL</em>, the data store is initialized with data from this pointer. In its initial state, the new data store is not mapped, it has a <em>?NULL</em> mapped pointer, and its mapped access is <em>?GL_READ_WRITE</em> .</p><p><em>Usage</em> is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. <em>Usage</em> can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these:</p><p>STREAM: The data store contents will be modified once and used at most a few times.</p><p>STATIC: The data store contents will be modified once and used many times.</p><p>DYNAMIC: The data store contents will be modified repeatedly and used many times.</p><p>The nature of access may be one of these:</p><p>DRAW: The data store contents are modified by the application, and used as the source for GL drawing and image specification commands.</p><p>READ: The data store contents are modified by reading data from the GL, and used to return that data when queried by the application.</p><p>COPY: The data store contents are modified by reading data from the GL, and used as the source for GL drawing and image specification commands.</p><p>See external documentation.</p><p><strong></strong> bufferSubData(Target, Offset, Size, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Offset = integer()</p><p>Size = integer()</p><p>Data = offset() | mem()</p><p>Updates a subset of a buffer object's data store</p><p><em>gl:bufferSubData</em> redefines some or all of the data store for the buffer object currently bound to <em>Target</em> . Data starting at byte offset <em>Offset</em> and extending for <em>Size</em> bytes is copied to the data store from the memory pointed to by <em>Data</em> . An error is thrown if <em>Offset</em> and <em>Size</em> together define a range beyond the bounds of the buffer object's data store.</p><p>See external documentation.</p><p><strong></strong> getBufferSubData(Target, Offset, Size, Data) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Offset = integer()</p><p>Size = integer()</p><p>Data = mem()</p><p>Returns a subset of a buffer object's data store</p><p><em>gl:getBufferSubData</em> returns some or all of the data from the buffer object currently bound to <em>Target</em> . Data starting at byte offset <em>Offset</em> and extending for <em>Size</em> bytes is copied from the data store to the memory pointed to by <em>Data</em> . An error is thrown if the buffer object is currently mapped, or if <em>Offset</em> and <em>Size</em> together define a range beyond the bounds of the buffer object's data store.</p><p>See external documentation.</p><p><strong></strong> getBufferParameteriv(Target, Pname) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Return parameters of a buffer object</p><p><em>gl:getBufferParameteriv</em> returns in <em>Data</em> a selected parameter of the buffer object specified by <em>Target</em> .</p><p><em>Value</em> names a specific buffer object parameter, as follows:</p><p><em>?GL_BUFFER_ACCESS</em>: <em>Params</em> returns the access policy set while mapping the buffer object. The initial value is <em>?GL_READ_WRITE</em>.</p><p><em>?GL_BUFFER_MAPPED</em>: <em>Params</em> returns a flag indicating whether the buffer object is currently mapped. The initial value is <em>?GL_FALSE</em>.</p><p><em>?GL_BUFFER_SIZE</em>: <em>Params</em> returns the size of the buffer object, measured in bytes. The initial value is 0.</p><p><em>?GL_BUFFER_USAGE</em>: <em>Params</em> returns the buffer object's usage pattern. The initial value is <em>?GL_STATIC_DRAW</em>.</p><p>See external documentation.</p><p><strong></strong> blendEquationSeparate(ModeRGB, ModeAlpha) -&gt; ok</p><p>Types:</p><p>ModeRGB = enum()</p><p>ModeAlpha = enum()</p><p>Set the RGB blend equation and the alpha blend equation separately</p><p>The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). These functions specifie one blend equation for the RGB-color components and one blend equation for the alpha component. <em>gl:blendEquationSeparatei</em> specifies the blend equations for a single draw buffer whereas <em>gl:blendEquationSeparate</em> sets the blend equations for all draw buffers.</p><p>The blend equations use the source and destination blend factors specified by either <strong>gl:blendFunc/2</strong> or <strong>gl:blendFuncSeparate/4</strong> . See <strong>gl:blendFunc/2</strong> or <strong>gl:blendFuncSeparate/4</strong> for a description of the various blend factors.</p><p>In the equations that follow, source and destination color components are referred to as (R s G s B s A s) and (R d G d B d A d), respectively. The result color is referred to as (R r G r B r A r). The source and destination blend factors are denoted (s R s G s B s A) and (d R d G d B d A), respectively. For these equations all color components are understood to have values in the range [0 1].<em>Mode</em><em>RGB Components</em><em>Alpha Component</em></p><p><em>?GL_FUNC_ADD</em> Rr=R s s R+R d d R Gr=G s s G+G d d G Br=B s s B+B d d B Ar=A s s A+A d d A</p><p><em>?GL_FUNC_SUBTRACT</em> Rr=R s s R-R d d R Gr=G s s G-G d d G Br=B s s B-B d d B Ar=A s s A-A d d A</p><p><em>?GL_FUNC_REVERSE_SUBTRACT</em> Rr=R d d R-R s s R Gr=G d d G-G s s G Br=B d d B-B s s B Ar=A d d A-A s s A</p><p><em>?GL_MIN</em> Rr=min(R s R d) Gr=min(G s G d) Br=min(B s B d) Ar=min (A s A d)</p><p><em>?GL_MAX</em> Rr=max(R s R d) Gr=max(G s G d) Br=max(B s B d) Ar=max(A s A d)</p><p>The results of these equations are clamped to the range [0 1].</p><p>The <em>?GL_MIN</em> and <em>?GL_MAX</em> equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The <em>?GL_FUNC_ADD</em> equation is useful for antialiasing and transparency, among other things.</p><p>Initially, both the RGB blend equation and the alpha blend equation are set to <em>?GL_FUNC_ADD</em> .</p><p>See external documentation.</p><p><strong></strong> drawBuffers(Bufs) -&gt; ok</p><p>Types:</p><p>Bufs = [enum()]</p><p>Specifies a list of color buffers to be drawn into</p><p><em>gl:drawBuffers</em> defines an array of buffers into which outputs from the fragment shader data will be written. If a fragment shader writes a value to one or more user defined output variables, then the value of each variable will be written into the buffer specified at a location within <em>Bufs</em> corresponding to the location assigned to that user defined output. The draw buffer used for user defined outputs assigned to locations greater than or equal to <em>N</em> is implicitly set to <em>?GL_NONE</em> and any data written to such an output is discarded.</p><p>The symbolic constants contained in <em>Bufs</em> may be any of the following:</p><p><em>?GL_NONE</em>: The fragment shader output value is not written into any color buffer.</p><p><em>?GL_FRONT_LEFT</em>: The fragment shader output value is written into the front left color buffer.</p><p><em>?GL_FRONT_RIGHT</em>: The fragment shader output value is written into the front right color buffer.</p><p><em>?GL_BACK_LEFT</em>: The fragment shader output value is written into the back left color buffer.</p><p><em>?GL_BACK_RIGHT</em>: The fragment shader output value is written into the back right color buffer.</p><p><em>?GL_COLOR_ATTACHMENT</em><em>n</em>: The fragment shader output value is written into the <em>n</em>th color attachment of the current framebuffer. <em>n</em> may range from 0 to the value of <em>?GL_MAX_COLOR_ATTACHMENTS</em>.</p><p>Except for <em>?GL_NONE</em>, the preceding symbolic constants may not appear more than once in <em>Bufs</em> . The maximum number of draw buffers supported is implementation dependent and can be queried by calling <strong>gl:getBooleanv/1</strong> with the argument <em>?GL_MAX_DRAW_BUFFERS</em> .</p><p>See external documentation.</p><p><strong></strong> stencilOpSeparate(Face, Sfail, Dpfail, Dppass) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Sfail = enum()</p><p>Dpfail = enum()</p><p>Dppass = enum()</p><p>Set front and/or back stencil test actions</p><p>Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.</p><p>The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_STENCIL_TEST</em> ; to control it, call <strong>gl:stencilFunc/3</strong> or <strong>gl:stencilFuncSeparate/4</strong> .</p><p>There can be two separate sets of <em>Sfail</em> , <em>Dpfail</em> , and <em>Dppass</em> parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. <strong>gl:stencilOp/3</strong> sets both front and back stencil state to the same values, as if <strong>gl:stencilOpSeparate/4</strong> were called with <em>Face</em> set to <em>?GL_FRONT_AND_BACK</em>.</p><p><em>gl:stencilOpSeparate</em> takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and <em>Sfail</em> specifies what happens to the stencil buffer contents. The following eight actions are possible.</p><p><em>?GL_KEEP</em>: Keeps the current value.</p><p><em>?GL_ZERO</em>: Sets the stencil buffer value to 0.</p><p><em>?GL_REPLACE</em>: Sets the stencil buffer value to <em>ref</em>, as specified by <strong>gl:stencilFunc/3</strong> .</p><p><em>?GL_INCR</em>: Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.</p><p><em>?GL_INCR_WRAP</em>: Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.</p><p><em>?GL_DECR</em>: Decrements the current stencil buffer value. Clamps to 0.</p><p><em>?GL_DECR_WRAP</em>: Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.</p><p><em>?GL_INVERT</em>: Bitwise inverts the current stencil buffer value.</p><p>Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n-1, where n is the value returned by querying <em>?GL_STENCIL_BITS</em> .</p><p>The other two arguments to <em>gl:stencilOpSeparate</em> specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed ( <em>Dppass</em> ) or fail ( <em>Dpfail</em> ) (see <strong>gl:depthFunc/1</strong> ). The actions are specified using the same eight symbolic constants as <em>Sfail</em> . Note that <em>Dpfail</em> is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, <em>Sfail</em> and <em>Dppass</em> specify stencil action when the stencil test fails and passes, respectively.</p><p>See external documentation.</p><p><strong></strong> stencilFuncSeparate(Face, Func, Ref, Mask) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Func = enum()</p><p>Ref = integer()</p><p>Mask = integer()</p><p>Set front and/or back function and reference value for stencil testing</p><p>Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.</p><p>The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call <strong>gl:enable/1</strong> and <strong>gl:enable/1</strong> with argument <em>?GL_STENCIL_TEST</em> . To specify actions based on the outcome of the stencil test, call <strong>gl:stencilOp/3</strong> or <strong>gl:stencilOpSeparate/4</strong> .</p><p>There can be two separate sets of <em>Func</em> , <em>Ref</em> , and <em>Mask</em> parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. <strong>gl:stencilFunc/3</strong> sets both front and back stencil state to the same values, as if <strong>gl:stencilFuncSeparate/4</strong> were called with <em>Face</em> set to <em>?GL_FRONT_AND_BACK</em>.</p><p><em>Func</em> is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. <em>Ref</em> is an integer reference value that is used in the stencil comparison. It is clamped to the range [0 2 n-1], where n is the number of bitplanes in the stencil buffer. <em>Mask</em> is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.</p><p>If <em>stencil</em> represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by <em>Func</em> . Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see <strong>gl:stencilOp/3</strong> ). All tests treat <em>stencil</em> values as unsigned integers in the range [0 2 n-1], where n is the number of bitplanes in the stencil buffer.</p><p>The following values are accepted by <em>Func</em> :</p><p><em>?GL_NEVER</em>: Always fails.</p><p><em>?GL_LESS</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) &lt; ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_LEQUAL</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) &lt;= ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_GREATER</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) &gt; ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_GEQUAL</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) &gt;= ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_EQUAL</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) = ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_NOTEQUAL</em>: Passes if ( <em>Ref</em> & <em>Mask</em> ) != ( <em>stencil</em> & <em>Mask</em> ).</p><p><em>?GL_ALWAYS</em>: Always passes.</p><p>See external documentation.</p><p><strong></strong> stencilMaskSeparate(Face, Mask) -&gt; ok</p><p>Types:</p><p>Face = enum()</p><p>Mask = integer()</p><p>Control the front and/or back writing of individual bits in the stencil planes</p><p><em>gl:stencilMaskSeparate</em> controls the writing of individual bits in the stencil planes. The least significant n bits of <em>Mask</em> , where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.</p><p>There can be two separate <em>Mask</em> writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. <strong>gl:stencilMask/1</strong> sets both front and back stencil writemasks to the same values, as if <strong>gl:stencilMaskSeparate/2</strong> were called with <em>Face</em> set to <em>?GL_FRONT_AND_BACK</em>.</p><p>See external documentation.</p><p><strong></strong> attachShader(Program, Shader) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Shader = integer()</p><p>Attaches a shader object to a program object</p><p>In order to create a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. <em>gl:attachShader</em> attaches the shader object specified by <em>Shader</em> to the program object specified by <em>Program</em> . This indicates that <em>Shader</em> will be included in link operations that will be performed on <em>Program</em> .</p><p>All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. It is permissible to attach multiple shader objects of the same type because each may contain a portion of the complete shader. It is also permissible to attach a shader object to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until <strong>gl:detachShader/2</strong> is called to detach it from all program objects to which it is attached.</p><p>See external documentation.</p><p><strong></strong> bindAttribLocation(Program, Index, Name) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Index = integer()</p><p>Name = string()</p><p>Associates a generic vertex attribute index with a named attribute variable</p><p><em>gl:bindAttribLocation</em> is used to associate a user-defined attribute variable in the program object specified by <em>Program</em> with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in <em>Name</em> . The generic vertex attribute index to be bound to this variable is specified by <em>Index</em> . When <em>Program</em> is made part of current state, values provided via the generic vertex attribute <em>Index</em> will modify the value of the user-defined attribute variable specified by <em>Name</em> .</p><p>If <em>Name</em> refers to a matrix attribute variable, <em>Index</em> refers to the first column of the matrix. Other matrix columns are then automatically bound to locations <em>Index+1</em> for a matrix of type <em>mat2</em>; <em>Index+1</em> and <em>Index+2</em> for a matrix of type <em>mat3</em>; and <em>Index+1</em> , <em>Index+2</em> , and <em>Index+3</em> for a matrix of type <em>mat4</em> .</p><p>This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from 0 to <em>?GL_MAX_VERTEX_ATTRIBS</em> -1. The values sent to each generic attribute index are part of current state. If a different program object is made current by calling <strong>gl:useProgram/1</strong> , the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to <em>Index</em> .</p><p>Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling <em>gl:bindAttribLocation</em>. Attribute bindings do not go into effect until <strong>gl:linkProgram/1</strong> is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs.</p><p>Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.</p><p>See external documentation.</p><p><strong></strong> compileShader(Shader) -&gt; ok</p><p>Types:</p><p>Shader = integer()</p><p>Compiles a shader object</p><p><em>gl:compileShader</em> compiles the source code strings that have been stored in the shader object specified by <em>Shader</em> .</p><p>The compilation status will be stored as part of the shader object's state. This value will be set to <em>?GL_TRUE</em> if the shader was compiled without errors and is ready for use, and <em>?GL_FALSE</em> otherwise. It can be queried by calling <strong>gl:getShaderiv/2</strong> with arguments <em>Shader</em> and <em>?GL_COMPILE_STATUS</em>.</p><p>Compilation of a shader can fail for a number of reasons as specified by the OpenGL Shading Language Specification. Whether or not the compilation was successful, information about the compilation can be obtained from the shader object's information log by calling <strong>gl:getShaderInfoLog/2</strong> .</p><p>See external documentation.</p><p><strong></strong> createProgram() -&gt; integer()</p><p>Creates a program object</p><p><em>gl:createProgram</em> creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When no longer needed as part of a program object, shader objects can be detached.</p><p>One or more executables are created in a program object by successfully attaching shader objects to it with <strong>gl:attachShader/2</strong> , successfully compiling the shader objects with <strong>gl:compileShader/1</strong> , and successfully linking the program object with <strong>gl:linkProgram/1</strong> . These executables are made part of current state when <strong>gl:useProgram/1</strong> is called. Program objects can be deleted by calling <strong>gl:deleteProgram/1</strong> . The memory associated with the program object will be deleted when it is no longer part of current rendering state for any context.</p><p>See external documentation.</p><p><strong></strong> createShader(Type) -&gt; integer()</p><p>Types:</p><p>Type = enum()</p><p>Creates a shader object</p><p><em>gl:createShader</em> creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object is used to maintain the source code strings that define a shader. <em>ShaderType</em> indicates the type of shader to be created. Five types of shader are supported. A shader of type <em>?GL_VERTEX_SHADER</em> is a shader that is intended to run on the programmable vertex processor. A shader of type <em>?GL_TESS_CONTROL_SHADER</em> is a shader that is intended to run on the programmable tessellation processor in the control stage. A shader of type <em>?GL_TESS_EVALUATION_SHADER</em> is a shader that is intended to run on the programmable tessellation processor in the evaluation stage. A shader of type <em>?GL_GEOMETRY_SHADER</em> is a shader that is intended to run on the programmable geometry processor. A shader of type <em>?GL_FRAGMENT_SHADER</em> is a shader that is intended to run on the programmable fragment processor.</p><p>When created, a shader object's <em>?GL_SHADER_TYPE</em> parameter is set to either <em>?GL_VERTEX_SHADER</em> , <em>?GL_TESS_CONTROL_SHADER</em>, <em>?GL_TESS_EVALUATION_SHADER</em>, <em>?GL_GEOMETRY_SHADER</em> or <em>?GL_FRAGMENT_SHADER</em>, depending on the value of <em>ShaderType</em> .</p><p>See external documentation.</p><p><strong></strong> deleteProgram(Program) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Deletes a program object</p><p><em>gl:deleteProgram</em> frees the memory and invalidates the name associated with the program object specified by <em>Program.</em> This command effectively undoes the effects of a call to <strong>gl:createProgram/0</strong> .</p><p>If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to <strong>gl:deleteShader/1</strong> . A value of 0 for <em>Program</em> will be silently ignored.</p><p>To determine whether a program object has been flagged for deletion, call <strong>gl:getProgramiv/2</strong> with arguments <em>Program</em> and <em>?GL_DELETE_STATUS</em>.</p><p>See external documentation.</p><p><strong></strong> deleteShader(Shader) -&gt; ok</p><p>Types:</p><p>Shader = integer()</p><p>Deletes a shader object</p><p><em>gl:deleteShader</em> frees the memory and invalidates the name associated with the shader object specified by <em>Shader</em> . This command effectively undoes the effects of a call to <strong>gl:createShader/1</strong> .</p><p>If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted). A value of 0 for <em>Shader</em> will be silently ignored.</p><p>To determine whether an object has been flagged for deletion, call <strong>gl:getShaderiv/2</strong> with arguments <em>Shader</em> and <em>?GL_DELETE_STATUS</em>.</p><p>See external documentation.</p><p><strong></strong> detachShader(Program, Shader) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Shader = integer()</p><p>Detaches a shader object from a program object to which it is attached</p><p><em>gl:detachShader</em> detaches the shader object specified by <em>Shader</em> from the program object specified by <em>Program</em> . This command can be used to undo the effect of the command <strong>gl:attachShader/2</strong> .</p><p>If <em>Shader</em> has already been flagged for deletion by a call to <strong>gl:deleteShader/1</strong> and it is not attached to any other program object, it will be deleted after it has been detached.</p><p>See external documentation.</p><p><strong></strong> disableVertexAttribArray(Index) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>Enable or disable a generic vertex attribute array</p><p><em>gl:enableVertexAttribArray</em> enables the generic vertex attribute array specified by <em>Index</em> . <em>gl:disableVertexAttribArray</em> disables the generic vertex attribute array specified by <em>Index</em> . By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as <strong>gl:drawArrays/3</strong> , <strong>gl:drawElements/4</strong> , <strong>gl:drawRangeElements/6</strong> , see <em>glMultiDrawElements</em> , or <strong>gl:multiDrawArrays/3</strong> .</p><p>See external documentation.</p><p><strong></strong> enableVertexAttribArray(Index) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>See <strong>disableVertexAttribArray/1</strong></p><p><strong></strong> getActiveAttrib(Program, Index, BufSize) -&gt; {Size::integer(), Type::enum(), Name::string()}</p><p>Types:</p><p>Program = integer()</p><p>Index = integer()</p><p>BufSize = integer()</p><p>Returns information about an active attribute variable for the specified program object</p><p><em>gl:getActiveAttrib</em> returns information about an active attribute variable in the program object specified by <em>Program</em> . The number of active attributes can be obtained by calling <strong>gl:getProgramiv/2</strong> with the value <em>?GL_ACTIVE_ATTRIBUTES</em>. A value of 0 for <em>Index</em> selects the first active attribute variable. Permissible values for <em>Index</em> range from 0 to the number of active attribute variables minus 1.</p><p>A vertex shader may use either built-in attribute variables, user-defined attribute variables, or both. Built-in attribute variables have a prefix of "gl_" and reference conventional OpenGL vertex attribtes (e.g., <em>Gl_Vertex</em> , <em>Gl_Normal</em> , etc., see the OpenGL Shading Language specification for a complete list.) User-defined attribute variables have arbitrary names and obtain their values through numbered generic vertex attributes. An attribute variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, <em>Program</em> should have previously been the target of a call to <strong>gl:linkProgram/1</strong> , but it is not necessary for it to have been linked successfully.</p><p>The size of the character buffer required to store the longest attribute variable name in <em>Program</em> can be obtained by calling <strong>gl:getProgramiv/2</strong> with the value <em>?GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</em> . This value should be used to allocate a buffer of sufficient size to store the returned attribute name. The size of this character buffer is passed in <em>BufSize</em> , and a pointer to this character buffer is passed in <em>Name</em> .</p><p><em>gl:getActiveAttrib</em> returns the name of the attribute variable indicated by <em>Index</em> , storing it in the character buffer specified by <em>Name</em> . The string returned will be null terminated. The actual number of characters written into this buffer is returned in <em>Length</em> , and this count does not include the null termination character. If the length of the returned string is not required, a value of <em>?NULL</em> can be passed in the <em>Length</em> argument.</p><p>The <em>Type</em> argument specifies a pointer to a variable into which the attribute variable's data type will be written. The symbolic constants <em>?GL_FLOAT</em>, <em>?GL_FLOAT_VEC2</em>, <em>?GL_FLOAT_VEC3</em>, <em>?GL_FLOAT_VEC4</em>, <em>?GL_FLOAT_MAT2</em>, <em>?GL_FLOAT_MAT3</em>, <em>?GL_FLOAT_MAT4</em>, <em>?GL_FLOAT_MAT2x3</em>, <em>?GL_FLOAT_MAT2x4</em>, <em>?GL_FLOAT_MAT3x2</em> , <em>?GL_FLOAT_MAT3x4</em>, <em>?GL_FLOAT_MAT4x2</em>, <em>?GL_FLOAT_MAT4x3</em>, <em>?GL_INT</em> , <em>?GL_INT_VEC2</em>, <em>?GL_INT_VEC3</em>, <em>?GL_INT_VEC4</em>, <em>?GL_UNSIGNED_INT_VEC</em> , <em>?GL_UNSIGNED_INT_VEC2</em>, <em>?GL_UNSIGNED_INT_VEC3</em>, <em>?GL_UNSIGNED_INT_VEC4</em>, <em>?DOUBLE</em>, <em>?DOUBLE_VEC2</em>, <em>?DOUBLE_VEC3</em>, <em>?DOUBLE_VEC4</em>, <em>?DOUBLE_MAT2</em> , <em>?DOUBLE_MAT3</em>, <em>?DOUBLE_MAT4</em>, <em>?DOUBLE_MAT2x3</em>, <em>?DOUBLE_MAT2x4</em>, <em>?DOUBLE_MAT3x2</em>, <em>?DOUBLE_MAT3x4</em>, <em>?DOUBLE_MAT4x2</em>, or <em>?DOUBLE_MAT4x3</em> may be returned. The <em>Size</em> argument will return the size of the attribute, in units of the type returned in <em>Type</em> .</p><p>The list of active attribute variables may include both built-in attribute variables (which begin with the prefix "gl_") as well as user-defined attribute variable names.</p><p>This function will return as much information as it can about the specified active attribute variable. If no information is available, <em>Length</em> will be 0, and <em>Name</em> will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values <em>Length</em> , <em>Size</em> , <em>Type</em> , and <em>Name</em> will be unmodified.</p><p>See external documentation.</p><p><strong></strong> getActiveUniform(Program, Index, BufSize) -&gt; {Size::integer(), Type::enum(), Name::string()}</p><p>Types:</p><p>Program = integer()</p><p>Index = integer()</p><p>BufSize = integer()</p><p>Returns information about an active uniform variable for the specified program object</p><p><em>gl:getActiveUniform</em> returns information about an active uniform variable in the program object specified by <em>Program</em> . The number of active uniform variables can be obtained by calling <strong>gl:getProgramiv/2</strong> with the value <em>?GL_ACTIVE_UNIFORMS</em>. A value of 0 for <em>Index</em> selects the first active uniform variable. Permissible values for <em>Index</em> range from 0 to the number of active uniform variables minus 1.</p><p>Shaders may use either built-in uniform variables, user-defined uniform variables, or both. Built-in uniform variables have a prefix of "gl_" and reference existing OpenGL state or values derived from such state (e.g., <em>Gl_DepthRangeParameters</em> , see the OpenGL Shading Language specification for a complete list.) User-defined uniform variables have arbitrary names and obtain their values from the application through calls to <strong>gl:uniform1f/2</strong> . A uniform variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, <em>Program</em> should have previously been the target of a call to <strong>gl:linkProgram/1</strong> , but it is not necessary for it to have been linked successfully.</p><p>The size of the character buffer required to store the longest uniform variable name in <em>Program</em> can be obtained by calling <strong>gl:getProgramiv/2</strong> with the value <em>?GL_ACTIVE_UNIFORM_MAX_LENGTH</em> . This value should be used to allocate a buffer of sufficient size to store the returned uniform variable name. The size of this character buffer is passed in <em>BufSize</em> , and a pointer to this character buffer is passed in <em>Name.</em></p><p><em>gl:getActiveUniform</em> returns the name of the uniform variable indicated by <em>Index</em> , storing it in the character buffer specified by <em>Name</em> . The string returned will be null terminated. The actual number of characters written into this buffer is returned in <em>Length</em> , and this count does not include the null termination character. If the length of the returned string is not required, a value of <em>?NULL</em> can be passed in the <em>Length</em> argument.</p><p>The <em>Type</em> argument will return a pointer to the uniform variable's data type. The symbolic constants returned for uniform types are shown in the table below.<em>Returned Symbolic Contant</em><em>Shader Uniform Type</em></p><p><em>?GL_FLOAT</em><em>?float</em></p><p><em>?GL_FLOAT_VEC2</em><em>?vec2</em></p><p><em>?GL_FLOAT_VEC3</em><em>?vec3</em></p><p><em>?GL_FLOAT_VEC4</em><em>?vec4</em></p><p><em>?GL_DOUBLE</em><em>?double</em></p><p><em>?GL_DOUBLE_VEC2</em><em>?dvec2</em></p><p><em>?GL_DOUBLE_VEC3</em><em>?dvec3</em></p><p><em>?GL_DOUBLE_VEC4</em><em>?dvec4</em></p><p><em>?GL_INT</em><em>?int</em></p><p><em>?GL_INT_VEC2</em><em>?ivec2</em></p><p><em>?GL_INT_VEC3</em><em>?ivec3</em></p><p><em>?GL_INT_VEC4</em><em>?ivec4</em></p><p><em>?GL_UNSIGNED_INT</em><em>?unsigned int</em></p><p><em>?GL_UNSIGNED_INT_VEC2</em><em>?uvec2</em></p><p><em>?GL_UNSIGNED_INT_VEC3</em><em>?uvec3</em></p><p><em>?GL_UNSIGNED_INT_VEC4</em><em>?uvec4</em></p><p><em>?GL_BOOL</em><em>?bool</em></p><p><em>?GL_BOOL_VEC2</em><em>?bvec2</em></p><p><em>?GL_BOOL_VEC3</em><em>?bvec3</em></p><p><em>?GL_BOOL_VEC4</em><em>?bvec4</em></p><p><em>?GL_FLOAT_MAT2</em><em>?mat2</em></p><p><em>?GL_FLOAT_MAT3</em><em>?mat3</em></p><p><em>?GL_FLOAT_MAT4</em><em>?mat4</em></p><p><em>?GL_FLOAT_MAT2x3</em><em>?mat2x3</em></p><p><em>?GL_FLOAT_MAT2x4</em><em>?mat2x4</em></p><p><em>?GL_FLOAT_MAT3x2</em><em>?mat3x2</em></p><p><em>?GL_FLOAT_MAT3x4</em><em>?mat3x4</em></p><p><em>?GL_FLOAT_MAT4x2</em><em>?mat4x2</em></p><p><em>?GL_FLOAT_MAT4x3</em><em>?mat4x3</em></p><p><em>?GL_DOUBLE_MAT2</em><em>?dmat2</em></p><p><em>?GL_DOUBLE_MAT3</em><em>?dmat3</em></p><p><em>?GL_DOUBLE_MAT4</em><em>?dmat4</em></p><p><em>?GL_DOUBLE_MAT2x3</em><em>?dmat2x3</em></p><p><em>?GL_DOUBLE_MAT2x4</em><em>?dmat2x4</em></p><p><em>?GL_DOUBLE_MAT3x2</em><em>?dmat3x2</em></p><p><em>?GL_DOUBLE_MAT3x4</em><em>?dmat3x4</em></p><p><em>?GL_DOUBLE_MAT4x2</em><em>?dmat4x2</em></p><p><em>?GL_DOUBLE_MAT4x3</em><em>?dmat4x3</em></p><p><em>?GL_SAMPLER_1D</em><em>?sampler1D</em></p><p><em>?GL_SAMPLER_2D</em><em>?sampler2D</em></p><p><em>?GL_SAMPLER_3D</em><em>?sampler3D</em></p><p><em>?GL_SAMPLER_CUBE</em><em>?samplerCube</em></p><p><em>?GL_SAMPLER_1D_SHADOW</em><em>?sampler1DShadow</em></p><p><em>?GL_SAMPLER_2D_SHADOW</em><em>?sampler2DShadow</em></p><p><em>?GL_SAMPLER_1D_ARRAY</em><em>?sampler1DArray</em></p><p><em>?GL_SAMPLER_2D_ARRAY</em><em>?sampler2DArray</em></p><p><em>?GL_SAMPLER_1D_ARRAY_SHADOW</em><em>?sampler1DArrayShadow</em></p><p><em>?GL_SAMPLER_2D_ARRAY_SHADOW</em><em>?sampler2DArrayShadow</em></p><p><em>?GL_SAMPLER_2D_MULTISAMPLE</em><em>?sampler2DMS</em></p><p><em>?GL_SAMPLER_2D_MULTISAMPLE_ARRAY</em><em>?sampler2DMSArray</em></p><p><em>?GL_SAMPLER_CUBE_SHADOW</em><em>?samplerCubeShadow</em></p><p><em>?GL_SAMPLER_BUFFER</em><em>?samplerBuffer</em></p><p><em>?GL_SAMPLER_2D_RECT</em><em>?sampler2DRect</em></p><p><em>?GL_SAMPLER_2D_RECT_SHADOW</em><em>?sampler2DRectShadow</em></p><p><em>?GL_INT_SAMPLER_1D</em><em>?isampler1D</em></p><p><em>?GL_INT_SAMPLER_2D</em><em>?isampler2D</em></p><p><em>?GL_INT_SAMPLER_3D</em><em>?isampler3D</em></p><p><em>?GL_INT_SAMPLER_CUBE</em><em>?isamplerCube</em></p><p><em>?GL_INT_SAMPLER_1D_ARRAY</em><em>?isampler1DArray</em></p><p><em>?GL_INT_SAMPLER_2D_ARRAY</em><em>?isampler2DArray</em></p><p><em>?GL_INT_SAMPLER_2D_MULTISAMPLE</em><em>?isampler2DMS</em></p><p><em>?GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY</em><em>?isampler2DMSArray</em></p><p><em>?GL_INT_SAMPLER_BUFFER</em><em>?isamplerBuffer</em></p><p><em>?GL_INT_SAMPLER_2D_RECT</em><em>?isampler2DRect</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_1D</em><em>?usampler1D</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_2D</em><em>?usampler2D</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_3D</em><em>?usampler3D</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_CUBE</em><em>?usamplerCube</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_1D_ARRAY</em><em>?usampler2DArray</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_2D_ARRAY</em><em>?usampler2DArray</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE</em><em>?usampler2DMS</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY</em><em>?usampler2DMSArray</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_BUFFER</em><em>?usamplerBuffer</em></p><p><em>?GL_UNSIGNED_INT_SAMPLER_2D_RECT</em><em>?usampler2DRect</em></p><p><em>?GL_IMAGE_1D</em><em>?image1D</em></p><p><em>?GL_IMAGE_2D</em><em>?image2D</em></p><p><em>?GL_IMAGE_3D</em><em>?image3D</em></p><p><em>?GL_IMAGE_2D_RECT</em><em>?image2DRect</em></p><p><em>?GL_IMAGE_CUBE</em><em>?imageCube</em></p><p><em>?GL_IMAGE_BUFFER</em><em>?imageBuffer</em></p><p><em>?GL_IMAGE_1D_ARRAY</em><em>?image1DArray</em></p><p><em>?GL_IMAGE_2D_ARRAY</em><em>?image2DArray</em></p><p><em>?GL_IMAGE_2D_MULTISAMPLE</em><em>?image2DMS</em></p><p><em>?GL_IMAGE_2D_MULTISAMPLE_ARRAY</em><em>?image2DMSArray</em></p><p><em>?GL_INT_IMAGE_1D</em><em>?iimage1D</em></p><p><em>?GL_INT_IMAGE_2D</em><em>?iimage2D</em></p><p><em>?GL_INT_IMAGE_3D</em><em>?iimage3D</em></p><p><em>?GL_INT_IMAGE_2D_RECT</em><em>?iimage2DRect</em></p><p><em>?GL_INT_IMAGE_CUBE</em><em>?iimageCube</em></p><p><em>?GL_INT_IMAGE_BUFFER</em><em>?iimageBuffer</em></p><p><em>?GL_INT_IMAGE_1D_ARRAY</em><em>?iimage1DArray</em></p><p><em>?GL_INT_IMAGE_2D_ARRAY</em><em>?iimage2DArray</em></p><p><em>?GL_INT_IMAGE_2D_MULTISAMPLE</em><em>?iimage2DMS</em></p><p><em>?GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY</em><em>?iimage2DMSArray</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_1D</em><em>?uimage1D</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_2D</em><em>?uimage2D</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_3D</em><em>?uimage3D</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_2D_RECT</em><em>?uimage2DRect</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_CUBE</em><em>?uimageCube</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_BUFFER</em><em>?uimageBuffer</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_1D_ARRAY</em><em>?uimage1DArray</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_2D_ARRAY</em><em>?uimage2DArray</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE</em><em>?uimage2DMS</em></p><p><em>?GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY</em><em>?uimage2DMSArray</em></p><p><em>?GL_UNSIGNED_INT_ATOMIC_COUNTER</em><em>?atomic_uint</em></p><p>If one or more elements of an array are active, the name of the array is returned in <em>Name</em> , the type is returned in <em>Type</em> , and the <em>Size</em> parameter returns the highest array element index used, plus one, as determined by the compiler and/or linker. Only one active uniform variable will be reported for a uniform array.</p><p>Uniform variables that are declared as structures or arrays of structures will not be returned directly by this function. Instead, each of these uniform variables will be reduced to its fundamental components containing the "." and "[]" operators such that each of the names is valid as an argument to <strong>gl:getUniformLocation/2</strong> . Each of these reduced uniform variables is counted as one active uniform variable and is assigned an index. A valid name cannot be a structure, an array of structures, or a subcomponent of a vector or matrix.</p><p>The size of the uniform variable will be returned in <em>Size</em> . Uniform variables other than arrays will have a size of 1. Structures and arrays of structures will be reduced as described earlier, such that each of the names returned will be a data type in the earlier list. If this reduction results in an array, the size returned will be as described for uniform arrays; otherwise, the size returned will be 1.</p><p>The list of active uniform variables may include both built-in uniform variables (which begin with the prefix "gl_") as well as user-defined uniform variable names.</p><p>This function will return as much information as it can about the specified active uniform variable. If no information is available, <em>Length</em> will be 0, and <em>Name</em> will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values <em>Length</em> , <em>Size</em> , <em>Type</em> , and <em>Name</em> will be unmodified.</p><p>See external documentation.</p><p><strong></strong> getAttachedShaders(Program, MaxCount) -&gt; [integer()]</p><p>Types:</p><p>Program = integer()</p><p>MaxCount = integer()</p><p>Returns the handles of the shader objects attached to a program object</p><p><em>gl:getAttachedShaders</em> returns the names of the shader objects attached to <em>Program</em> . The names of shader objects that are attached to <em>Program</em> will be returned in <em>Shaders.</em> The actual number of shader names written into <em>Shaders</em> is returned in <em>Count.</em> If no shader objects are attached to <em>Program</em> , <em>Count</em> is set to 0. The maximum number of shader names that may be returned in <em>Shaders</em> is specified by <em>MaxCount</em> .</p><p>If the number of names actually returned is not required (for instance, if it has just been obtained by calling <strong>gl:getProgramiv/2</strong> ), a value of <em>?NULL</em> may be passed for count. If no shader objects are attached to <em>Program</em> , a value of 0 will be returned in <em>Count</em> . The actual number of attached shaders can be obtained by calling <strong>gl:getProgramiv/2</strong> with the value <em>?GL_ATTACHED_SHADERS</em>.</p><p>See external documentation.</p><p><strong></strong> getAttribLocation(Program, Name) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>Name = string()</p><p>Returns the location of an attribute variable</p><p><em>gl:getAttribLocation</em> queries the previously linked program object specified by <em>Program</em> for the attribute variable specified by <em>Name</em> and returns the index of the generic vertex attribute that is bound to that attribute variable. If <em>Name</em> is a matrix attribute variable, the index of the first column of the matrix is returned. If the named attribute variable is not an active attribute in the specified program object or if <em>Name</em> starts with the reserved prefix "gl_", a value of -1 is returned.</p><p>The association between an attribute variable name and a generic attribute index can be specified at any time by calling <strong>gl:bindAttribLocation/3</strong> . Attribute bindings do not go into effect until <strong>gl:linkProgram/1</strong> is called. After a program object has been linked successfully, the index values for attribute variables remain fixed until the next link command occurs. The attribute values can only be queried after a link if the link was successful. <em>gl:getAttribLocation</em> returns the binding that actually went into effect the last time <strong>gl:linkProgram/1</strong> was called for the specified program object. Attribute bindings that have been specified since the last link operation are not returned by <em>gl:getAttribLocation</em>.</p><p>See external documentation.</p><p><strong></strong> getProgramiv(Program, Pname) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>Pname = enum()</p><p>Returns a parameter from a program object</p><p><em>gl:getProgram</em> returns in <em>Params</em> the value of a parameter for a specific program object. The following parameters are defined:</p><p><em>?GL_DELETE_STATUS</em>: <em>Params</em> returns <em>?GL_TRUE</em> if <em>Program</em> is currently flagged for deletion, and <em>?GL_FALSE</em> otherwise.</p><p><em>?GL_LINK_STATUS</em>: <em>Params</em> returns <em>?GL_TRUE</em> if the last link operation on <em>Program</em> was successful, and <em>?GL_FALSE</em> otherwise.</p><p><em>?GL_VALIDATE_STATUS</em>: <em>Params</em> returns <em>?GL_TRUE</em> or if the last validation operation on <em>Program</em> was successful, and <em>?GL_FALSE</em> otherwise.</p><p><em>?GL_INFO_LOG_LENGTH</em>: <em>Params</em> returns the number of characters in the information log for <em>Program</em> including the null termination character (i.e., the size of the character buffer required to store the information log). If <em>Program</em> has no information log, a value of 0 is returned.</p><p><em>?GL_ATTACHED_SHADERS</em>: <em>Params</em> returns the number of shader objects attached to <em>Program</em> .</p><p><em>?GL_ACTIVE_ATOMIC_COUNTER_BUFFERS</em>: <em>Params</em> returns the number of active attribute atomic counter buffers used by <em>Program</em> .</p><p><em>?GL_ACTIVE_ATTRIBUTES</em>: <em>Params</em> returns the number of active attribute variables for <em>Program</em> .</p><p><em>?GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</em>: <em>Params</em> returns the length of the longest active attribute name for <em>Program</em> , including the null termination character (i.e., the size of the character buffer required to store the longest attribute name). If no active attributes exist, 0 is returned.</p><p><em>?GL_ACTIVE_UNIFORMS</em>: <em>Params</em> returns the number of active uniform variables for <em>Program</em> .</p><p><em>?GL_ACTIVE_UNIFORM_MAX_LENGTH</em>: <em>Params</em> returns the length of the longest active uniform variable name for <em>Program</em> , including the null termination character (i.e., the size of the character buffer required to store the longest uniform variable name). If no active uniform variables exist, 0 is returned.</p><p><em>?GL_PROGRAM_BINARY_LENGTH</em>: <em>Params</em> returns the length of the program binary, in bytes that will be returned by a call to <strong>gl:getProgramBinary/2</strong> . When a progam's <em>?GL_LINK_STATUS</em> is <em>?GL_FALSE</em>, its program binary length is zero.</p><p><em>?GL_TRANSFORM_FEEDBACK_BUFFER_MODE</em>: <em>Params</em> returns a symbolic constant indicating the buffer mode used when transform feedback is active. This may be <em>?GL_SEPARATE_ATTRIBS</em> or <em>?GL_INTERLEAVED_ATTRIBS</em>.</p><p><em>?GL_TRANSFORM_FEEDBACK_VARYINGS</em>: <em>Params</em> returns the number of varying variables to capture in transform feedback mode for the program.</p><p><em>?GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH</em>: <em>Params</em> returns the length of the longest variable name to be used for transform feedback, including the null-terminator.</p><p><em>?GL_GEOMETRY_VERTICES_OUT</em>: <em>Params</em> returns the maximum number of vertices that the geometry shader in <em>Program</em> will output.</p><p><em>?GL_GEOMETRY_INPUT_TYPE</em>: <em>Params</em> returns a symbolic constant indicating the primitive type accepted as input to the geometry shader contained in <em>Program</em> .</p><p><em>?GL_GEOMETRY_OUTPUT_TYPE</em>: <em>Params</em> returns a symbolic constant indicating the primitive type that will be output by the geometry shader contained in <em>Program</em> .</p><p>See external documentation.</p><p><strong></strong> getProgramInfoLog(Program, BufSize) -&gt; string()</p><p>Types:</p><p>Program = integer()</p><p>BufSize = integer()</p><p>Returns the information log for a program object</p><p><em>gl:getProgramInfoLog</em> returns the information log for the specified program object. The information log for a program object is modified when the program object is linked or validated. The string that is returned will be null terminated.</p><p><em>gl:getProgramInfoLog</em> returns in <em>InfoLog</em> as much of the information log as it can, up to a maximum of <em>MaxLength</em> characters. The number of characters actually returned, excluding the null termination character, is specified by <em>Length</em> . If the length of the returned string is not required, a value of <em>?NULL</em> can be passed in the <em>Length</em> argument. The size of the buffer required to store the returned information log can be obtained by calling <strong>gl:getProgramiv/2</strong> with the value <em>?GL_INFO_LOG_LENGTH</em> .</p><p>The information log for a program object is either an empty string, or a string containing information about the last link operation, or a string containing information about the last validation operation. It may contain diagnostic messages, warning messages, and other information. When a program object is created, its information log will be a string of length 0.</p><p>See external documentation.</p><p><strong></strong> getShaderiv(Shader, Pname) -&gt; integer()</p><p>Types:</p><p>Shader = integer()</p><p>Pname = enum()</p><p>Returns a parameter from a shader object</p><p><em>gl:getShader</em> returns in <em>Params</em> the value of a parameter for a specific shader object. The following parameters are defined:</p><p><em>?GL_SHADER_TYPE</em>: <em>Params</em> returns <em>?GL_VERTEX_SHADER</em> if <em>Shader</em> is a vertex shader object, <em>?GL_GEOMETRY_SHADER</em> if <em>Shader</em> is a geometry shader object, and <em>?GL_FRAGMENT_SHADER</em> if <em>Shader</em> is a fragment shader object.</p><p><em>?GL_DELETE_STATUS</em>: <em>Params</em> returns <em>?GL_TRUE</em> if <em>Shader</em> is currently flagged for deletion, and <em>?GL_FALSE</em> otherwise.</p><p><em>?GL_COMPILE_STATUS</em>: <em>Params</em> returns <em>?GL_TRUE</em> if the last compile operation on <em>Shader</em> was successful, and <em>?GL_FALSE</em> otherwise.</p><p><em>?GL_INFO_LOG_LENGTH</em>: <em>Params</em> returns the number of characters in the information log for <em>Shader</em> including the null termination character (i.e., the size of the character buffer required to store the information log). If <em>Shader</em> has no information log, a value of 0 is returned.</p><p><em>?GL_SHADER_SOURCE_LENGTH</em>: <em>Params</em> returns the length of the concatenation of the source strings that make up the shader source for the <em>Shader</em> , including the null termination character. (i.e., the size of the character buffer required to store the shader source). If no source code exists, 0 is returned.</p><p>See external documentation.</p><p><strong></strong> getShaderInfoLog(Shader, BufSize) -&gt; string()</p><p>Types:</p><p>Shader = integer()</p><p>BufSize = integer()</p><p>Returns the information log for a shader object</p><p><em>gl:getShaderInfoLog</em> returns the information log for the specified shader object. The information log for a shader object is modified when the shader is compiled. The string that is returned will be null terminated.</p><p><em>gl:getShaderInfoLog</em> returns in <em>InfoLog</em> as much of the information log as it can, up to a maximum of <em>MaxLength</em> characters. The number of characters actually returned, excluding the null termination character, is specified by <em>Length</em> . If the length of the returned string is not required, a value of <em>?NULL</em> can be passed in the <em>Length</em> argument. The size of the buffer required to store the returned information log can be obtained by calling <strong>gl:getShaderiv/2</strong> with the value <em>?GL_INFO_LOG_LENGTH</em> .</p><p>The information log for a shader object is a string that may contain diagnostic messages, warning messages, and other information about the last compile operation. When a shader object is created, its information log will be a string of length 0.</p><p>See external documentation.</p><p><strong></strong> getShaderSource(Shader, BufSize) -&gt; string()</p><p>Types:</p><p>Shader = integer()</p><p>BufSize = integer()</p><p>Returns the source code string from a shader object</p><p><em>gl:getShaderSource</em> returns the concatenation of the source code strings from the shader object specified by <em>Shader</em> . The source code strings for a shader object are the result of a previous call to <strong>gl:shaderSource/2</strong> . The string returned by the function will be null terminated.</p><p><em>gl:getShaderSource</em> returns in <em>Source</em> as much of the source code string as it can, up to a maximum of <em>BufSize</em> characters. The number of characters actually returned, excluding the null termination character, is specified by <em>Length</em> . If the length of the returned string is not required, a value of <em>?NULL</em> can be passed in the <em>Length</em> argument. The size of the buffer required to store the returned source code string can be obtained by calling <strong>gl:getShaderiv/2</strong> with the value <em>?GL_SHADER_SOURCE_LENGTH</em> .</p><p>See external documentation.</p><p><strong></strong> getUniformLocation(Program, Name) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>Name = string()</p><p>Returns the location of a uniform variable</p><p><em>gl:getUniformLocation</em> returns an integer that represents the location of a specific uniform variable within a program object. <em>Name</em> must be a null terminated string that contains no white space. <em>Name</em> must be an active uniform variable name in <em>Program</em> that is not a structure, an array of structures, or a subcomponent of a vector or a matrix. This function returns -1 if <em>Name</em> does not correspond to an active uniform variable in <em>Program</em> , if <em>Name</em> starts with the reserved prefix "gl_", or if <em>Name</em> is associated with an atomic counter or a named uniform block.</p><p>Uniform variables that are structures or arrays of structures may be queried by calling <em>gl:getUniformLocation</em> for each field within the structure. The array element operator "[]" and the structure field operator "." may be used in <em>Name</em> in order to select elements within an array or fields within a structure. The result of using these operators is not allowed to be another structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last part of <em>Name</em> indicates a uniform variable array, the location of the first element of an array can be retrieved by using the name of the array, or by using the name appended by "[0]".</p><p>The actual locations assigned to uniform variables are not known until the program object is linked successfully. After linking has occurred, the command <em>gl:getUniformLocation</em> can be used to obtain the location of a uniform variable. This location value can then be passed to <strong>gl:uniform1f/2</strong> to set the value of the uniform variable or to <strong>gl:getUniformfv/2</strong> in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. Uniform variable locations and values can only be queried after a link if the link was successful.</p><p>See external documentation.</p><p><strong></strong> getUniformfv(Program, Location) -&gt; matrix()</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Returns the value of a uniform variable</p><p><em>gl:getUniform</em> returns in <em>Params</em> the value(s) of the specified uniform variable. The type of the uniform variable specified by <em>Location</em> determines the number of values returned. If the uniform variable is defined in the shader as a boolean, int, or float, a single value will be returned. If it is defined as a vec2, ivec2, or bvec2, two values will be returned. If it is defined as a vec3, ivec3, or bvec3, three values will be returned, and so on. To query values stored in uniform variables declared as arrays, call <em>gl:getUniform</em> for each element of the array. To query values stored in uniform variables declared as structures, call <em>gl:getUniform</em> for each field in the structure. The values for uniform variables declared as a matrix will be returned in column major order.</p><p>The locations assigned to uniform variables are not known until the program object is linked. After linking has occurred, the command <strong>gl:getUniformLocation/2</strong> can be used to obtain the location of a uniform variable. This location value can then be passed to <em>gl:getUniform</em> in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. The uniform variable values can only be queried after a link if the link was successful.</p><p>See external documentation.</p><p><strong></strong> getUniformiv(Program, Location) -&gt; {integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>See <strong>getUniformfv/2</strong></p><p><strong></strong> getVertexAttribdv(Index, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Index = integer()</p><p>Pname = enum()</p><p>Return a generic vertex attribute parameter</p><p><em>gl:getVertexAttrib</em> returns in <em>Params</em> the value of a generic vertex attribute parameter. The generic vertex attribute to be queried is specified by <em>Index</em> , and the parameter to be queried is specified by <em>Pname</em> .</p><p>The accepted parameter names are as follows:</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</em>: <em>Params</em> returns a single value, the name of the buffer object currently bound to the binding point corresponding to generic vertex attribute array <em>Index</em> . If no buffer object is bound, 0 is returned. The initial value is 0.</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_ENABLED</em>: <em>Params</em> returns a single value that is non-zero (true) if the vertex attribute array for <em>Index</em> is enabled and 0 (false) if it is disabled. The initial value is <em>?GL_FALSE</em>.</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_SIZE</em>: <em>Params</em> returns a single value, the size of the vertex attribute array for <em>Index</em> . The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3, or 4. The initial value is 4.</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_STRIDE</em>: <em>Params</em> returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for <em>Index</em> . A value of 0 indicates that the array elements are stored sequentially in memory. The initial value is 0.</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_TYPE</em>: <em>Params</em> returns a single value, a symbolic constant indicating the array type for the vertex attribute array for <em>Index</em> . Possible values are <em>?GL_BYTE</em>, <em>?GL_UNSIGNED_BYTE</em>, <em>?GL_SHORT</em>, <em>?GL_UNSIGNED_SHORT</em> , <em>?GL_INT</em>, <em>?GL_UNSIGNED_INT</em>, <em>?GL_FLOAT</em>, and <em>?GL_DOUBLE</em>. The initial value is <em>?GL_FLOAT</em>.</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</em>: <em>Params</em> returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by <em>Index</em> are normalized when they are converted to floating point, and 0 (false) otherwise. The initial value is <em>?GL_FALSE</em>.</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_INTEGER</em>: <em>Params</em> returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by <em>Index</em> have integer data types, and 0 (false) otherwise. The initial value is 0 (<em>?GL_FALSE</em>).</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_DIVISOR</em>: <em>Params</em> returns a single value that is the frequency divisor used for instanced rendering. See <strong>gl:vertexAttribDivisor/2</strong> . The initial value is 0.</p><p><em>?GL_CURRENT_VERTEX_ATTRIB</em>: <em>Params</em> returns four values that represent the current value for the generic vertex attribute specified by index. Generic vertex attribute 0 is unique in that it has no current state, so an error will be generated if <em>Index</em> is 0. The initial value for all other generic vertex attributes is (0,0,0,1).</p><p><em>gl:getVertexAttribdv</em> and <em>gl:getVertexAttribfv</em> return the current attribute values as four single-precision floating-point values; <em>gl:getVertexAttribiv</em> reads them as floating-point values and converts them to four integer values; <em>gl:getVertexAttribIiv</em> and <em>gl:getVertexAttribIuiv</em> read and return them as signed or unsigned integer values, respectively; <em>gl:getVertexAttribLdv</em> reads and returns them as four double-precision floating-point values.</p><p>All of the parameters except <em>?GL_CURRENT_VERTEX_ATTRIB</em> represent state stored in the currently bound vertex array object.</p><p>See external documentation.</p><p><strong></strong> getVertexAttribfv(Index, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Index = integer()</p><p>Pname = enum()</p><p>See <strong>getVertexAttribdv/2</strong></p><p><strong></strong> getVertexAttribiv(Index, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Index = integer()</p><p>Pname = enum()</p><p>See <strong>getVertexAttribdv/2</strong></p><p><strong></strong> isProgram(Program) -&gt; 0 | 1</p><p>Types:</p><p>Program = integer()</p><p>Determines if a name corresponds to a program object</p><p><em>gl:isProgram</em> returns <em>?GL_TRUE</em> if <em>Program</em> is the name of a program object previously created with <strong>gl:createProgram/0</strong> and not yet deleted with <strong>gl:deleteProgram/1</strong> . If <em>Program</em> is zero or a non-zero value that is not the name of a program object, or if an error occurs, <em>gl:isProgram</em> returns <em>?GL_FALSE</em>.</p><p>See external documentation.</p><p><strong></strong> isShader(Shader) -&gt; 0 | 1</p><p>Types:</p><p>Shader = integer()</p><p>Determines if a name corresponds to a shader object</p><p><em>gl:isShader</em> returns <em>?GL_TRUE</em> if <em>Shader</em> is the name of a shader object previously created with <strong>gl:createShader/1</strong> and not yet deleted with <strong>gl:deleteShader/1</strong> . If <em>Shader</em> is zero or a non-zero value that is not the name of a shader object, or if an error occurs, <em>gl:isShader</em> returns <em>?GL_FALSE</em>.</p><p>See external documentation.</p><p><strong></strong> linkProgram(Program) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Links a program object</p><p><em>gl:linkProgram</em> links the program object specified by <em>Program</em> . If any shader objects of type <em>?GL_VERTEX_SHADER</em> are attached to <em>Program</em> , they will be used to create an executable that will run on the programmable vertex processor. If any shader objects of type <em>?GL_GEOMETRY_SHADER</em> are attached to <em>Program</em> , they will be used to create an executable that will run on the programmable geometry processor. If any shader objects of type <em>?GL_FRAGMENT_SHADER</em> are attached to <em>Program</em> , they will be used to create an executable that will run on the programmable fragment processor.</p><p>The status of the link operation will be stored as part of the program object's state. This value will be set to <em>?GL_TRUE</em> if the program object was linked without errors and is ready for use, and <em>?GL_FALSE</em> otherwise. It can be queried by calling <strong>gl:getProgramiv/2</strong> with arguments <em>Program</em> and <em>?GL_LINK_STATUS</em>.</p><p>As a result of a successful link operation, all active user-defined uniform variables belonging to <em>Program</em> will be initialized to 0, and each of the program object's active uniform variables will be assigned a location that can be queried by calling <strong>gl:getUniformLocation/2</strong> . Also, any active user-defined attribute variables that have not been bound to a generic vertex attribute index will be bound to one at this time.</p><p>Linking of a program object can fail for a number of reasons as specified in the <em>OpenGL Shading Language Specification</em> . The following lists some of the conditions that will cause a link error.</p><p>The number of active attribute variables supported by the implementation has been exceeded.</p><p>The storage limit for uniform variables has been exceeded.</p><p>The number of active uniform variables supported by the implementation has been exceeded.</p><p>The <em>main</em> function is missing for the vertex, geometry or fragment shader.</p><p>A varying variable actually used in the fragment shader is not declared in the same way (or is not declared at all) in the vertex shader, or geometry shader shader if present.</p><p>A reference to a function or variable name is unresolved.</p><p>A shared global is declared with two different types or two different initial values.</p><p>One or more of the attached shader objects has not been successfully compiled.</p><p>Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed maximum of <em>?GL_MAX_VERTEX_ATTRIBS</em>.</p><p>Not enough contiguous vertex attribute slots could be found to bind attribute matrices.</p><p>The program object contains objects to form a fragment shader but does not contain objects to form a vertex shader.</p><p>The program object contains objects to form a geometry shader but does not contain objects to form a vertex shader.</p><p>The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is not specified in any compiled geometry shader object.</p><p>The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is specified differently in multiple geometry shader objects.</p><p>The number of active outputs in the fragment shader is greater than the value of <em>?GL_MAX_DRAW_BUFFERS</em> .</p><p>The program has an active output assigned to a location greater than or equal to the value of <em>?GL_MAX_DUAL_SOURCE_DRAW_BUFFERS</em> and has an active output assigned an index greater than or equal to one.</p><p>More than one varying out variable is bound to the same number and index.</p><p>The explicit binding assigments do not leave enough space for the linker to automatically assign a location for a varying out array, which requires multiple contiguous locations.</p><p>The <em>Count</em> specified by <strong>gl:transformFeedbackVaryings/3</strong> is non-zero, but the program object has no vertex or geometry shader.</p><p>Any variable name specified to <strong>gl:transformFeedbackVaryings/3</strong> in the <em>Varyings</em> array is not declared as an output in the vertex shader (or the geometry shader, if active).</p><p>Any two entries in the <em>Varyings</em> array given <strong>gl:transformFeedbackVaryings/3</strong> specify the same varying variable.</p><p>The total number of components to capture in any transform feedback varying variable is greater than the constant <em>?GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS</em> and the buffer mode is <em>?SEPARATE_ATTRIBS</em>.</p><p>When a program object has been successfully linked, the program object can be made part of current state by calling <strong>gl:useProgram/1</strong> . Whether or not the link operation was successful, the program object's information log will be overwritten. The information log can be retrieved by calling <strong>gl:getProgramInfoLog/2</strong> .</p><p><em>gl:linkProgram</em> will also install the generated executables as part of the current rendering state if the link operation was successful and the specified program object is already currently in use as a result of a previous call to <strong>gl:useProgram/1</strong> . If the program object currently in use is relinked unsuccessfully, its link status will be set to <em>?GL_FALSE</em> , but the executables and associated state will remain part of the current state until a subsequent call to <em>gl:useProgram</em> removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.</p><p>If <em>Program</em> contains shader objects of type <em>?GL_VERTEX_SHADER</em>, and optionally of type <em>?GL_GEOMETRY_SHADER</em>, but does not contain shader objects of type <em>?GL_FRAGMENT_SHADER</em> , the vertex shader executable will be installed on the programmable vertex processor, the geometry shader executable, if present, will be installed on the programmable geometry processor, but no executable will be installed on the fragment processor. The results of rasterizing primitives with such a program will be undefined.</p><p>The program object's information log is updated and the program is generated at the time of the link operation. After the link operation, applications are free to modify attached shader objects, compile attached shader objects, detach shader objects, delete shader objects, and attach additional shader objects. None of these operations affects the information log or the program that is part of the program object.</p><p>See external documentation.</p><p><strong></strong> shaderSource(Shader, String) -&gt; ok</p><p>Types:</p><p>Shader = integer()</p><p>String = [string()]</p><p>Replaces the source code in a shader object</p><p><em>gl:shaderSource</em> sets the source code in <em>Shader</em> to the source code in the array of strings specified by <em>String</em> . Any source code previously stored in the shader object is completely replaced. The number of strings in the array is specified by <em>Count</em> . If <em>Length</em> is <em>?NULL</em>, each string is assumed to be null terminated. If <em>Length</em> is a value other than <em>?NULL</em>, it points to an array containing a string length for each of the corresponding elements of <em>String</em> . Each element in the <em>Length</em> array may contain the length of the corresponding string (the null character is not counted as part of the string length) or a value less than 0 to indicate that the string is null terminated. The source code strings are not scanned or parsed at this time; they are simply copied into the specified shader object.</p><p>See external documentation.</p><p><strong></strong> useProgram(Program) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Installs a program object as part of current rendering state</p><p><em>gl:useProgram</em> installs the program object specified by <em>Program</em> as part of current rendering state. One or more executables are created in a program object by successfully attaching shader objects to it with <strong>gl:attachShader/2</strong> , successfully compiling the shader objects with <strong>gl:compileShader/1</strong> , and successfully linking the program object with <strong>gl:linkProgram/1</strong> .</p><p>A program object will contain an executable that will run on the vertex processor if it contains one or more shader objects of type <em>?GL_VERTEX_SHADER</em> that have been successfully compiled and linked. A program object will contain an executable that will run on the geometry processor if it contains one or more shader objects of type <em>?GL_GEOMETRY_SHADER</em> that have been successfully compiled and linked. Similarly, a program object will contain an executable that will run on the fragment processor if it contains one or more shader objects of type <em>?GL_FRAGMENT_SHADER</em> that have been successfully compiled and linked.</p><p>While a program object is in use, applications are free to modify attached shader objects, compile attached shader objects, attach additional shader objects, and detach or delete shader objects. None of these operations will affect the executables that are part of the current state. However, relinking the program object that is currently in use will install the program object as part of the current rendering state if the link operation was successful (see <strong>gl:linkProgram/1</strong> ). If the program object currently in use is relinked unsuccessfully, its link status will be set to <em>?GL_FALSE</em>, but the executables and associated state will remain part of the current state until a subsequent call to <em>gl:useProgram</em> removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.</p><p>If <em>Program</em> is zero, then the current rendering state refers to an <em>invalid</em> program object and the results of shader execution are undefined. However, this is not an error.</p><p>If <em>Program</em> does not contain shader objects of type <em>?GL_FRAGMENT_SHADER</em>, an executable will be installed on the vertex, and possibly geometry processors, but the results of fragment shader execution will be undefined.</p><p>See external documentation.</p><p><strong></strong> uniform1f(Location, V0) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = float()</p><p>Specify the value of a uniform variable for the current program object</p><p><em>gl:uniform</em> modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by <em>Location</em> , which should be a value returned by <strong>gl:getUniformLocation/2</strong> . <em>gl:uniform</em> operates on the program object that was made part of current state by calling <strong>gl:useProgram/1</strong> .</p><p>The commands <em>gl:uniform{1|2|3|4}{f|i|ui}</em> are used to change the value of the uniform variable specified by <em>Location</em> using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., <em>1</em> for float, int, unsigned int, bool; <em>2</em> for vec2, ivec2, uvec2, bvec2, etc.). The suffix <em>f</em> indicates that floating-point values are being passed; the suffix <em>i</em> indicates that integer values are being passed; the suffix <em>ui</em> indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The <em>i</em> variants of this function should be used to provide values for uniform variables defined as int, ivec2 , ivec3, ivec4, or arrays of these. The <em>ui</em> variants of this function should be used to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The <em>f</em> variants should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the <em>i</em>, <em>ui</em> or <em>f</em> variants may be used to provide values for uniform variables of type bool, bvec2 , bvec3, bvec4, or arrays of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.</p><p>All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to <em>gl:uniform</em> until the next successful link operation occurs on the program object, when they are once again initialized to 0.</p><p>The commands <em>gl:uniform{1|2|3|4}{f|i|ui}v</em> can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading <em>n</em> elements starting at an arbitrary position <em>m</em> in a uniform variable array, elements <em>m</em> + <em>n</em> - 1 in the array will be replaced with the new values. If <em>M</em> + <em>N</em> - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in <em>Value</em> , and it should match the number of components in the data type of the specified uniform variable (e.g., <em>1</em> for float, int, bool; <em>2</em> for vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for <em>gl:uniform{1|2|3|4}{f|i|ui}</em>.</p><p>For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., <em>gl:uniform3f</em> or <em>gl:uniform3fv</em> can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by <em>Count</em></p><p>The commands <em>gl:uniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv</em> are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number <em>2</em> indicates a 2 × 2 matrix (i.e., 4 values), the number <em>3</em> indicates a 3 × 3 matrix (i.e., 9 values), and the number <em>4</em> indicates a 4 × 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows. For example, <em>2x4</em> indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If <em>Transpose</em> is <em>?GL_FALSE</em>, each matrix is assumed to be supplied in column major order. If <em>Transpose</em> is <em>?GL_TRUE</em>, each matrix is assumed to be supplied in row major order. The <em>Count</em> argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.</p><p>See external documentation.</p><p><strong></strong> uniform2f(Location, V0, V1) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform3f(Location, V0, V1, V2) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>V2 = float()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform4f(Location, V0, V1, V2, V3) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>V2 = float()</p><p>V3 = float()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform1i(Location, V0) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = integer()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform2i(Location, V0, V1) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform3i(Location, V0, V1, V2) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>V2 = integer()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform4i(Location, V0, V1, V2, V3) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>V2 = integer()</p><p>V3 = integer()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform1fv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [float()]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform2fv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform3fv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform4fv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform1iv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [integer()]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform2iv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{integer(), integer()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform3iv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{integer(), integer(), integer()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform4iv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{integer(), integer(), integer(), integer()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix2fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix3fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix4fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> validateProgram(Program) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Validates a program object</p><p><em>gl:validateProgram</em> checks to see whether the executables contained in <em>Program</em> can execute given the current OpenGL state. The information generated by the validation process will be stored in <em>Program</em> 's information log. The validation information may consist of an empty string, or it may be a string containing information about how the current program object interacts with the rest of current OpenGL state. This provides a way for OpenGL implementers to convey more information about why the current program is inefficient, suboptimal, failing to execute, and so on.</p><p>The status of the validation operation will be stored as part of the program object's state. This value will be set to <em>?GL_TRUE</em> if the validation succeeded, and <em>?GL_FALSE</em> otherwise. It can be queried by calling <strong>gl:getProgramiv/2</strong> with arguments <em>Program</em> and <em>?GL_VALIDATE_STATUS</em>. If validation is successful, <em>Program</em> is guaranteed to execute given the current state. Otherwise, <em>Program</em> is guaranteed to not execute.</p><p>This function is typically useful only during application development. The informational string stored in the information log is completely implementation dependent; therefore, an application should not expect different OpenGL implementations to produce identical information strings.</p><p>See external documentation.</p><p><strong></strong> vertexAttrib1d(Index, X) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Specifies the value of a generic vertex attribute</p><p>The <em>gl:vertexAttrib</em> family of entry points allows an application to pass generic vertex attributes in numbered locations.</p><p>Generic attributes are defined as four-component values that are organized into an array. The first entry of this array is numbered 0, and the size of the array is specified by the implementation-dependent constant <em>?GL_MAX_VERTEX_ATTRIBS</em>. Individual elements of this array can be modified with a <em>gl:vertexAttrib</em> call that specifies the index of the element to be modified and a value for that element.</p><p>These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified by <em>Index</em> . A <em>1</em> in the name of the command indicates that only one value is passed, and it will be used to modify the first component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component will be set to 1. Similarly, a <em>2</em> in the name of the command indicates that values are provided for the first two components, the third component will be set to 0, and the fourth component will be set to 1. A <em>3</em> in the name of the command indicates that values are provided for the first three components and the fourth component will be set to 1, whereas a <em>4</em> in the name indicates that values are provided for all four components.</p><p>The letters <em>s</em>, <em>f</em>, <em>i</em>, <em>d</em>, <em>ub</em>, <em>us</em>, and <em>ui</em> indicate whether the arguments are of type short, float, int, double, unsigned byte, unsigned short, or unsigned int. When <em>v</em> is appended to the name, the commands can take a pointer to an array of such values.</p><p>Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:</p><p>The commands containing <em>N</em> indicate that the arguments will be passed as fixed-point values that are scaled to a normalized range according to the component conversion rules defined by the OpenGL specification. Signed values are understood to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values in the range [0,1].</p><p>The commands containing <em>I</em> indicate that the arguments are extended to full signed or unsigned integers.</p><p>The commands containing <em>P</em> indicate that the arguments are stored as packed components within a larger natural type.</p><p>The commands containing <em>L</em> indicate that the arguments are full 64-bit quantities and should be passed directly to shader inputs declared as 64-bit double precision types.</p><p>OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may be loaded using the <em>gl:vertexAttrib</em> entry points. Matrices must be loaded into successive generic attribute slots in column major order, with one column of the matrix in each generic attribute slot.</p><p>A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling <strong>gl:bindAttribLocation/3</strong> . This allows an application to use more descriptive variable names in a vertex shader. A subsequent change to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable in the vertex shader.</p><p>The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different program object is used.</p><p>An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable. These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing, the vertex shader will repeatedly use the current value for the generic vertex attribute.</p><p>See external documentation.</p><p><strong></strong> vertexAttrib1dv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float()}</p><p>Equivalent to <strong>vertexAttrib1d(Index, X)</strong>.</p><p><strong></strong> vertexAttrib1f(Index, X) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib1fv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float()}</p><p>Equivalent to <strong>vertexAttrib1f(Index, X)</strong>.</p><p><strong></strong> vertexAttrib1s(Index, X) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib1sv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer()}</p><p>Equivalent to <strong>vertexAttrib1s(Index, X)</strong>.</p><p><strong></strong> vertexAttrib2d(Index, X, Y) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib2dv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>vertexAttrib2d(Index, X, Y)</strong>.</p><p><strong></strong> vertexAttrib2f(Index, X, Y) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib2fv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>vertexAttrib2f(Index, X, Y)</strong>.</p><p><strong></strong> vertexAttrib2s(Index, X, Y) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib2sv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>vertexAttrib2s(Index, X, Y)</strong>.</p><p><strong></strong> vertexAttrib3d(Index, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib3dv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>vertexAttrib3d(Index, X, Y, Z)</strong>.</p><p><strong></strong> vertexAttrib3f(Index, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib3fv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>vertexAttrib3f(Index, X, Y, Z)</strong>.</p><p><strong></strong> vertexAttrib3s(Index, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib3sv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>vertexAttrib3s(Index, X, Y, Z)</strong>.</p><p><strong></strong> vertexAttrib4Nbv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4Niv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4Nsv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4Nub(Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>W = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4Nubv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer(), W::integer()}</p><p>Equivalent to <strong>vertexAttrib4Nub(Index, X, Y, Z, W)</strong>.</p><p><strong></strong> vertexAttrib4Nuiv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4Nusv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4bv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4d(Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4dv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float(), W::float()}</p><p>Equivalent to <strong>vertexAttrib4d(Index, X, Y, Z, W)</strong>.</p><p><strong></strong> vertexAttrib4f(Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4fv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float(), W::float()}</p><p>Equivalent to <strong>vertexAttrib4f(Index, X, Y, Z, W)</strong>.</p><p><strong></strong> vertexAttrib4iv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4s(Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>W = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4sv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer(), W::integer()}</p><p>Equivalent to <strong>vertexAttrib4s(Index, X, Y, Z, W)</strong>.</p><p><strong></strong> vertexAttrib4ubv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4uiv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttrib4usv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribPointer(Index, Size, Type, Normalized, Stride, Pointer) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>Size = integer()</p><p>Type = enum()</p><p>Normalized = 0 | 1</p><p>Stride = integer()</p><p>Pointer = offset() | mem()</p><p>Define an array of generic vertex attribute data</p><p><em>gl:vertexAttribPointer</em>, <em>gl:vertexAttribIPointer</em> and <em>gl:vertexAttribLPointer</em> specify the location and data format of the array of generic vertex attributes at index <em>Index</em> to use when rendering. <em>Size</em> specifies the number of components per attribute and must be 1, 2, 3, 4, or <em>?GL_BGRA</em>. <em>Type</em> specifies the data type of each component, and <em>Stride</em> specifies the byte stride from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.</p><p>For <em>gl:vertexAttribPointer</em>, if <em>Normalized</em> is set to <em>?GL_TRUE</em>, it indicates that values stored in an integer format are to be mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and converted to floating point. Otherwise, values will be converted to floats directly without normalization.</p><p>For <em>gl:vertexAttribIPointer</em>, only the integer types <em>?GL_BYTE</em>, <em>?GL_UNSIGNED_BYTE</em> , <em>?GL_SHORT</em>, <em>?GL_UNSIGNED_SHORT</em>, <em>?GL_INT</em>, <em>?GL_UNSIGNED_INT</em> are accepted. Values are always left as integer values.</p><p><em>gl:vertexAttribLPointer</em> specifies state for a generic vertex attribute array associated with a shader attribute variable declared with 64-bit double precision components. <em>Type</em> must be <em>?GL_DOUBLE</em>. <em>Index</em> , <em>Size</em> , and <em>Stride</em> behave as described for <em>gl:vertexAttribPointer</em> and <em>gl:vertexAttribIPointer</em>.</p><p>If <em>Pointer</em> is not NULL, a non-zero named buffer object must be bound to the <em>?GL_ARRAY_BUFFER</em> target (see <strong>gl:bindBuffer/2</strong> ), otherwise an error is generated. <em>Pointer</em> is treated as a byte offset into the buffer object's data store. The buffer object binding (<em>?GL_ARRAY_BUFFER_BINDING</em>) is saved as generic vertex attribute array state (<em>?GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</em> ) for index <em>Index</em> .</p><p>When a generic vertex attribute array is specified, <em>Size</em> , <em>Type</em> , <em>Normalized</em> , <em>Stride</em> , and <em>Pointer</em> are saved as vertex array state, in addition to the current vertex array buffer object binding.</p><p>To enable and disable a generic vertex attribute array, call <strong>gl:disableVertexAttribArray/1</strong> and <strong>gl:disableVertexAttribArray/1</strong> with <em>Index</em> . If enabled, the generic vertex attribute array is used when <strong>gl:drawArrays/3</strong> , <strong>gl:multiDrawArrays/3</strong> , <strong>gl:drawElements/4</strong> , see <em>glMultiDrawElements</em>, or <strong>gl:drawRangeElements/6</strong> is called.</p><p>See external documentation.</p><p><strong></strong> uniformMatrix2x3fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix3x2fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix2x4fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix4x2fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix3x4fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix4x3fv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> colorMaski(Index, R, G, B, A) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>R = 0 | 1</p><p>G = 0 | 1</p><p>B = 0 | 1</p><p>A = 0 | 1</p><p>glColorMaski</p><p>See external documentation.</p><p><strong></strong> getBooleani_v(Target, Index) -&gt; [0 | 1]</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> getIntegeri_v(Target, Index) -&gt; [integer()]</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> enablei(Target, Index) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>See <strong>enable/1</strong></p><p><strong></strong> disablei(Target, Index) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>glEnablei</p><p>See external documentation.</p><p><strong></strong> isEnabledi(Target, Index) -&gt; 0 | 1</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>glIsEnabledi</p><p>See external documentation.</p><p><strong></strong> beginTransformFeedback(PrimitiveMode) -&gt; ok</p><p>Types:</p><p>PrimitiveMode = enum()</p><p>Start transform feedback operation</p><p>Transform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry shader). Transform feedback is said to be active after a call to <em>gl:beginTransformFeedback</em> until a subsequent call to <strong>gl:beginTransformFeedback/1</strong> . Transform feedback commands must be paired.</p><p>If no geometry shader is present, while transform feedback is active the <em>Mode</em> parameter to <strong>gl:drawArrays/3</strong> must match those specified in the following table:<em>Transform Feedback</em><em>PrimitiveMode</em><em>Allowed Render Primitive</em><em>Modes</em></p><p><em>?GL_POINTS</em><em>?GL_POINTS</em></p><p><em>?GL_LINES</em><em>?GL_LINES</em>, <em>?GL_LINE_LOOP</em>, <em>?GL_LINE_STRIP</em> , <em>?GL_LINES_ADJACENCY</em>, <em>?GL_LINE_STRIP_ADJACENCY</em></p><p><em>?GL_TRIANGLES</em><em>?GL_TRIANGLES</em>, <em>?GL_TRIANGLE_STRIP</em>, <em>?GL_TRIANGLE_FAN</em>, <em>?GL_TRIANGLES_ADJACENCY</em> , <em>?GL_TRIANGLE_STRIP_ADJACENCY</em></p><p>If a geometry shader is present, the output primitive type from the geometry shader must match those provided in the following table:<em>Transform Feedback</em><em>PrimitiveMode</em><em>Allowed Geometry Shader Output Primitive Type</em></p><p><em>?GL_POINTS</em><em>?points</em></p><p><em>?GL_LINES</em><em>?line_strip</em></p><p><em>?GL_TRIANGLES</em><em>?triangle_strip</em></p><p>See external documentation.</p><p><strong></strong> endTransformFeedback() -&gt; ok</p><p>See <strong>beginTransformFeedback/1</strong></p><p><strong></strong> bindBufferRange(Target, Index, Buffer, Offset, Size) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Buffer = integer()</p><p>Offset = integer()</p><p>Size = integer()</p><p>Bind a range within a buffer object to an indexed buffer target</p><p><em>gl:bindBufferRange</em> binds a range the buffer object <em>Buffer</em> represented by <em>Offset</em> and <em>Size</em> to the binding point at index <em>Index</em> of the array of targets specified by <em>Target</em> . Each <em>Target</em> represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as <strong>gl:bindBuffer/2</strong> or see <em>glMapBuffer</em>. In addition to binding a range of <em>Buffer</em> to the indexed buffer binding target, <em>gl:bindBufferBase</em> also binds the range to the generic buffer binding point specified by <em>Target</em> .</p><p><em>Offset</em> specifies the offset in basic machine units into the buffer object <em>Buffer</em> and <em>Size</em> specifies the amount of data that can be read from the buffer object while used as an indexed target.</p><p>See external documentation.</p><p><strong></strong> bindBufferBase(Target, Index, Buffer) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Buffer = integer()</p><p>Bind a buffer object to an indexed buffer target</p><p><em>gl:bindBufferBase</em> binds the buffer object <em>Buffer</em> to the binding point at index <em>Index</em> of the array of targets specified by <em>Target</em> . Each <em>Target</em> represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as <strong>gl:bindBuffer/2</strong> or see <em>glMapBuffer</em>. In addition to binding <em>Buffer</em> to the indexed buffer binding target, <em>gl:bindBufferBase</em> also binds <em>Buffer</em> to the generic buffer binding point specified by <em>Target</em> .</p><p>See external documentation.</p><p><strong></strong> transformFeedbackVaryings(Program, Varyings, BufferMode) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Varyings = [string()]</p><p>BufferMode = enum()</p><p>Specify values to record in transform feedback buffers</p><p>The names of the vertex or geometry shader outputs to be recorded in transform feedback mode are specified using <em>gl:transformFeedbackVaryings</em>. When a geometry shader is active, transform feedback records the values of selected geometry shader output variables from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are recorded.</p><p>The state set by <em>gl:tranformFeedbackVaryings</em> is stored and takes effect next time <strong>gl:linkProgram/1</strong> is called on <em>Program</em> . When <strong>gl:linkProgram/1</strong> is called, <em>Program</em> is linked so that the values of the specified varying variables for the vertices of each primitive generated by the GL are written to a single buffer object if <em>BufferMode</em> is <em>?GL_INTERLEAVED_ATTRIBS</em> or multiple buffer objects if <em>BufferMode</em> is <em>?GL_SEPARATE_ATTRIBS</em> .</p><p>In addition to the errors generated by <em>gl:transformFeedbackVaryings</em>, the program <em>Program</em> will fail to link if:</p><p>The count specified by <em>gl:transformFeedbackVaryings</em> is non-zero, but the program object has no vertex or geometry shader.</p><p>Any variable name specified in the <em>Varyings</em> array is not declared as an output in the vertex shader (or the geometry shader, if active).</p><p>Any two entries in the <em>Varyings</em> array specify the same varying variable.</p><p>The total number of components to capture in any varying variable in <em>Varyings</em> is greater than the constant <em>?GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS</em> and the buffer mode is <em>?GL_SEPARATE_ATTRIBS</em>.</p><p>The total number of components to capture is greater than the constant <em>?GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS</em> and the buffer mode is <em>?GL_INTERLEAVED_ATTRIBS</em>.</p><p>See external documentation.</p><p><strong></strong> getTransformFeedbackVarying(Program, Index, BufSize) -&gt; {Size::integer(), Type::enum(), Name::string()}</p><p>Types:</p><p>Program = integer()</p><p>Index = integer()</p><p>BufSize = integer()</p><p>Retrieve information about varying variables selected for transform feedback</p><p>Information about the set of varying variables in a linked program that will be captured during transform feedback may be retrieved by calling <em>gl:getTransformFeedbackVarying</em>. <em>gl:getTransformFeedbackVarying</em> provides information about the varying variable selected by <em>Index</em> . An <em>Index</em> of 0 selects the first varying variable specified in the <em>Varyings</em> array passed to <strong>gl:transformFeedbackVaryings/3</strong> , and an <em>Index</em> of <em>?GL_TRANSFORM_FEEDBACK_VARYINGS-1</em> selects the last such variable.</p><p>The name of the selected varying is returned as a null-terminated string in <em>Name</em> . The actual number of characters written into <em>Name</em> , excluding the null terminator, is returned in <em>Length</em> . If <em>Length</em> is NULL, no length is returned. The maximum number of characters that may be written into <em>Name</em> , including the null terminator, is specified by <em>BufSize</em> .</p><p>The length of the longest varying name in program is given by <em>?GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH</em> , which can be queried with <strong>gl:getProgramiv/2</strong> .</p><p>For the selected varying variable, its type is returned into <em>Type</em> . The size of the varying is returned into <em>Size</em> . The value in <em>Size</em> is in units of the type returned in <em>Type</em> . The type returned can be any of the scalar, vector, or matrix attribute types returned by <strong>gl:getActiveAttrib/3</strong> . If an error occurred, the return parameters <em>Length</em> , <em>Size</em> , <em>Type</em> and <em>Name</em> will be unmodified. This command will return as much information about the varying variables as possible. If no information is available, <em>Length</em> will be set to zero and <em>Name</em> will be an empty string. This situation could arise if <em>gl:getTransformFeedbackVarying</em> is called after a failed link.</p><p>See external documentation.</p><p><strong></strong> clampColor(Target, Clamp) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Clamp = enum()</p><p>specify whether data read via</p><p><strong>gl:readPixels/7</strong> should be clamped</p><p><em>gl:clampColor</em> controls color clamping that is performed during <strong>gl:readPixels/7</strong> . <em>Target</em> must be <em>?GL_CLAMP_READ_COLOR</em>. If <em>Clamp</em> is <em>?GL_TRUE</em>, read color clamping is enabled; if <em>Clamp</em> is <em>?GL_FALSE</em>, read color clamping is disabled. If <em>Clamp</em> is <em>?GL_FIXED_ONLY</em>, read color clamping is enabled only if the selected read buffer has fixed point components and disabled otherwise.</p><p>See external documentation.</p><p><strong></strong> beginConditionalRender(Id, Mode) -&gt; ok</p><p>Types:</p><p>Id = integer()</p><p>Mode = enum()</p><p>Start conditional rendering</p><p>Conditional rendering is started using <em>gl:beginConditionalRender</em> and ended using <em>gl:endConditionalRender</em> . During conditional rendering, all vertex array commands, as well as <strong>gl:clear/1</strong> and <strong>gl:clearBufferiv/3</strong> have no effect if the (<em>?GL_SAMPLES_PASSED</em>) result of the query object <em>Id</em> is zero, or if the (<em>?GL_ANY_SAMPLES_PASSED</em>) result is <em>?GL_FALSE</em> . The results of commands setting the current vertex state, such as <strong>gl:vertexAttrib1d/2</strong> are undefined. If the (<em>?GL_SAMPLES_PASSED</em>) result is non-zero or if the (<em>?GL_ANY_SAMPLES_PASSED</em> ) result is <em>?GL_TRUE</em>, such commands are not discarded. The <em>Id</em> parameter to <em>gl:beginConditionalRender</em> must be the name of a query object previously returned from a call to <strong>gl:genQueries/1</strong> . <em>Mode</em> specifies how the results of the query object are to be interpreted. If <em>Mode</em> is <em>?GL_QUERY_WAIT</em>, the GL waits for the results of the query to be available and then uses the results to determine if subsequent rendering commands are discarded. If <em>Mode</em> is <em>?GL_QUERY_NO_WAIT</em>, the GL may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.</p><p>If <em>Mode</em> is <em>?GL_QUERY_BY_REGION_WAIT</em>, the GL will also wait for occlusion query results and discard rendering commands if the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed, but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample count in the specified occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering command results may not be discarded for any samples that contributed to the occlusion query sample count. If <em>Mode</em> is <em>?GL_QUERY_BY_REGION_NO_WAIT</em>, the GL operates as in <em>?GL_QUERY_BY_REGION_WAIT</em> , but may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.</p><p>See external documentation.</p><p><strong></strong> endConditionalRender() -&gt; ok</p><p>See <strong>beginConditionalRender/2</strong></p><p><strong></strong> vertexAttribIPointer(Index, Size, Type, Stride, Pointer) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>Size = integer()</p><p>Type = enum()</p><p>Stride = integer()</p><p>Pointer = offset() | mem()</p><p>glVertexAttribIPointer</p><p>See external documentation.</p><p><strong></strong> getVertexAttribIiv(Index, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Index = integer()</p><p>Pname = enum()</p><p>See <strong>getVertexAttribdv/2</strong></p><p><strong></strong> getVertexAttribIuiv(Index, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Index = integer()</p><p>Pname = enum()</p><p>glGetVertexAttribI</p><p>See external documentation.</p><p><strong></strong> vertexAttribI1i(Index, X) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI2i(Index, X, Y) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI3i(Index, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI4i(Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>W = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI1ui(Index, X) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI2ui(Index, X, Y) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI3ui(Index, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI4ui(Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = integer()</p><p>Y = integer()</p><p>Z = integer()</p><p>W = integer()</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI1iv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer()}</p><p>Equivalent to <strong>vertexAttribI1i(Index, X)</strong>.</p><p><strong></strong> vertexAttribI2iv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>vertexAttribI2i(Index, X, Y)</strong>.</p><p><strong></strong> vertexAttribI3iv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>vertexAttribI3i(Index, X, Y, Z)</strong>.</p><p><strong></strong> vertexAttribI4iv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer(), W::integer()}</p><p>Equivalent to <strong>vertexAttribI4i(Index, X, Y, Z, W)</strong>.</p><p><strong></strong> vertexAttribI1uiv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer()}</p><p>Equivalent to <strong>vertexAttribI1ui(Index, X)</strong>.</p><p><strong></strong> vertexAttribI2uiv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer()}</p><p>Equivalent to <strong>vertexAttribI2ui(Index, X, Y)</strong>.</p><p><strong></strong> vertexAttribI3uiv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer()}</p><p>Equivalent to <strong>vertexAttribI3ui(Index, X, Y, Z)</strong>.</p><p><strong></strong> vertexAttribI4uiv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::integer(), Y::integer(), Z::integer(), W::integer()}</p><p>Equivalent to <strong>vertexAttribI4ui(Index, X, Y, Z, W)</strong>.</p><p><strong></strong> vertexAttribI4bv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI4sv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI4ubv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> vertexAttribI4usv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>See <strong>vertexAttrib1d/2</strong></p><p><strong></strong> getUniformuiv(Program, Location) -&gt; {integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>See <strong>getUniformfv/2</strong></p><p><strong></strong> bindFragDataLocation(Program, Color, Name) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Color = integer()</p><p>Name = string()</p><p>Bind a user-defined varying out variable to a fragment shader color number</p><p><em>gl:bindFragDataLocation</em> explicitly specifies the binding of the user-defined varying out variable <em>Name</em> to fragment shader color number <em>ColorNumber</em> for program <em>Program</em> . If <em>Name</em> was bound previously, its assigned binding is replaced with <em>ColorNumber</em> . <em>Name</em> must be a null-terminated string. <em>ColorNumber</em> must be less than <em>?GL_MAX_DRAW_BUFFERS</em> .</p><p>The bindings specified by <em>gl:bindFragDataLocation</em> have no effect until <em>Program</em> is next linked. Bindings may be specified at any time after <em>Program</em> has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in <em>Name</em> , including a name that is never used as a varying out variable in any fragment shader object. Names beginning with <em>?gl_</em> are reserved by the GL.</p><p>In addition to the errors generated by <em>gl:bindFragDataLocation</em>, the program <em>Program</em> will fail to link if:</p><p>The number of active outputs is greater than the value <em>?GL_MAX_DRAW_BUFFERS</em>.</p><p>More than one varying out variable is bound to the same color number.</p><p>See external documentation.</p><p><strong></strong> getFragDataLocation(Program, Name) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>Name = string()</p><p>Query the bindings of color numbers to user-defined varying out variables</p><p><em>gl:getFragDataLocation</em> retrieves the assigned color number binding for the user-defined varying out variable <em>Name</em> for program <em>Program</em> . <em>Program</em> must have previously been linked. <em>Name</em> must be a null-terminated string. If <em>Name</em> is not the name of an active user-defined varying out fragment shader variable within <em>Program</em> , -1 will be returned.</p><p>See external documentation.</p><p><strong></strong> uniform1ui(Location, V0) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = integer()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform2ui(Location, V0, V1) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform3ui(Location, V0, V1, V2) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>V2 = integer()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform4ui(Location, V0, V1, V2, V3) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>V2 = integer()</p><p>V3 = integer()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform1uiv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [integer()]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform2uiv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{integer(), integer()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform3uiv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{integer(), integer(), integer()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform4uiv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{integer(), integer(), integer(), integer()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> texParameterIiv(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>See <strong>texParameterf/3</strong></p><p><strong></strong> texParameterIuiv(Target, Pname, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Params = {integer()}</p><p>glTexParameterI</p><p>See external documentation.</p><p><strong></strong> getTexParameterIiv(Target, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>See <strong>getTexParameterfv/2</strong></p><p><strong></strong> getTexParameterIuiv(Target, Pname) -&gt; {integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>glGetTexParameterI</p><p>See external documentation.</p><p><strong></strong> clearBufferiv(Buffer, Drawbuffer, Value) -&gt; ok</p><p>Types:</p><p>Buffer = enum()</p><p>Drawbuffer = integer()</p><p>Value = {integer()}</p><p>Clear individual buffers of the currently bound draw framebuffer</p><p><em>gl:clearBuffer*</em> clears the specified buffer to the specified value(s). If <em>Buffer</em> is <em>?GL_COLOR</em>, a particular draw buffer <em>?GL_DRAWBUFFER</em> <em>I</em> is specified by passing <em>I</em> as <em>DrawBuffer</em> . In this case, <em>Value</em> points to a four-element vector specifying the R, G, B and A color to clear that draw buffer to. If <em>Buffer</em> is one of <em>?GL_FRONT</em>, <em>?GL_BACK</em>, <em>?GL_LEFT</em>, <em>?GL_RIGHT</em>, or <em>?GL_FRONT_AND_BACK</em> , identifying multiple buffers, each selected buffer is cleared to the same value. Clamping and conversion for fixed-point color buffers are performed in the same fashion as <strong>gl:clearColor/4</strong> .</p><p>If <em>Buffer</em> is <em>?GL_DEPTH</em>, <em>DrawBuffer</em> must be zero, and <em>Value</em> points to a single value to clear the depth buffer to. Only <em>gl:clearBufferfv</em> should be used to clear depth buffers. Clamping and conversion for fixed-point depth buffers are performed in the same fashion as <strong>gl:clearDepth/1</strong> .</p><p>If <em>Buffer</em> is <em>?GL_STENCIL</em>, <em>DrawBuffer</em> must be zero, and <em>Value</em> points to a single value to clear the stencil buffer to. Only <em>gl:clearBufferiv</em> should be used to clear stencil buffers. Masing and type conversion are performed in the same fashion as <strong>gl:clearStencil/1</strong> .</p><p><em>gl:clearBufferfi</em> may be used to clear the depth and stencil buffers. <em>Buffer</em> must be <em>?GL_DEPTH_STENCIL</em> and <em>DrawBuffer</em> must be zero. <em>Depth</em> and <em>Stencil</em> are the depth and stencil values, respectively.</p><p>The result of <em>gl:clearBuffer</em> is undefined if no conversion between the type of <em>Value</em> and the buffer being cleared is defined. However, this is not an error.</p><p>See external documentation.</p><p><strong></strong> clearBufferuiv(Buffer, Drawbuffer, Value) -&gt; ok</p><p>Types:</p><p>Buffer = enum()</p><p>Drawbuffer = integer()</p><p>Value = {integer()}</p><p>See <strong>clearBufferiv/3</strong></p><p><strong></strong> clearBufferfv(Buffer, Drawbuffer, Value) -&gt; ok</p><p>Types:</p><p>Buffer = enum()</p><p>Drawbuffer = integer()</p><p>Value = {float()}</p><p>See <strong>clearBufferiv/3</strong></p><p><strong></strong> clearBufferfi(Buffer, Drawbuffer, Depth, Stencil) -&gt; ok</p><p>Types:</p><p>Buffer = enum()</p><p>Drawbuffer = integer()</p><p>Depth = float()</p><p>Stencil = integer()</p><p>glClearBufferfi</p><p>See external documentation.</p><p><strong></strong> getStringi(Name, Index) -&gt; string()</p><p>Types:</p><p>Name = enum()</p><p>Index = integer()</p><p>See <strong>getString/1</strong></p><p><strong></strong> drawArraysInstanced(Mode, First, Count, Primcount) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>First = integer()</p><p>Count = integer()</p><p>Primcount = integer()</p><p>glDrawArraysInstance</p><p>See external documentation.</p><p><strong></strong> drawElementsInstanced(Mode, Count, Type, Indices, Primcount) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Count = integer()</p><p>Type = enum()</p><p>Indices = offset() | mem()</p><p>Primcount = integer()</p><p>glDrawElementsInstance</p><p>See external documentation.</p><p><strong></strong> texBuffer(Target, Internalformat, Buffer) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>Buffer = integer()</p><p>Attach the storage for a buffer object to the active buffer texture</p><p><em>gl:texBuffer</em> attaches the storage for the buffer object named <em>Buffer</em> to the active buffer texture, and specifies the internal format for the texel array found in the attached buffer object. If <em>Buffer</em> is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If <em>Buffer</em> is non-zero, it must be the name of an existing buffer object. <em>Target</em> must be <em>?GL_TEXTURE_BUFFER</em> . <em>Internalformat</em> specifies the storage format, and must be one of the following sized internal formats:<em>Component</em></p><p><em>Sized Internal Format</em><em>Base Type</em><em>Components</em><em>Norm</em>0123</p><p><em>?GL_R8</em>ubyte1YESR00 1</p><p><em>?GL_R16</em>ushort1YESR 001</p><p><em>?GL_R16F</em>half1NO R001</p><p><em>?GL_R32F</em>float 1NOR001</p><p><em>?GL_R8I</em> byte1NOR001</p><p><em>?GL_R16I</em> short1NOR001</p><p><em>?GL_R32I</em>int1NOR001</p><p><em>?GL_R8UI</em>ubyte1NOR0 01</p><p><em>?GL_R16UI</em>ushort1NO R001</p><p><em>?GL_R32UI</em>uint1 NOR001</p><p><em>?GL_RG8</em>ubyte 2YESRG01</p><p><em>?GL_RG16</em> ushort2YESRG01</p><p><em>?GL_RG16F</em>half2NORG0 1</p><p><em>?GL_RG32F</em>float2NORG 01</p><p><em>?GL_RG8I</em>byte2NO RG01</p><p><em>?GL_RG16I</em>short 2NORG01</p><p><em>?GL_RG32I</em> int2NORG01</p><p><em>?GL_RG8UI</em> ubyte2NORG01</p><p><em>?GL_RG16UI</em>ushort2NORG0 1</p><p><em>?GL_RG32UI</em>uint2NORG 01</p><p><em>?GL_RGB32F</em>float3NO RGB1</p><p><em>?GL_RGB32I</em>int 3NORGB1</p><p><em>?GL_RGB32UI</em> uint3NORGB1</p><p><em>?GL_RGBA8</em>uint4YESRGB A</p><p><em>?GL_RGBA16</em>short4YESR GBA</p><p><em>?GL_RGBA16F</em>half4NO RGBA</p><p><em>?GL_RGBA32F</em>float 4NORGBA</p><p><em>?GL_RGBA8I</em> byte4NORGBA</p><p><em>?GL_RGBA16I</em>short4NORGB A</p><p><em>?GL_RGBA32I</em>int4NORG BA</p><p><em>?GL_RGBA8UI</em>ubyte4NO RGBA</p><p><em>?GL_RGBA16UI</em>ushort 4NORGBA</p><p><em>?GL_RGBA32UI</em> uint4NORGBA</p><p>When a buffer object is attached to a buffer texture, the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by buffer_size components×sizeof( base_type/)</p><p>where <em>buffer_size</em> is the size of the buffer object, in basic machine units and components and base type are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the implementation-dependent limit <em>?GL_MAX_TEXTURE_BUFFER_SIZE</em>. When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.</p><p>See external documentation.</p><p><strong></strong> primitiveRestartIndex(Index) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>Specify the primitive restart index</p><p><em>gl:primitiveRestartIndex</em> specifies a vertex array element that is treated specially when primitive restarting is enabled. This is known as the primitive restart index.</p><p>When one of the <em>Draw*</em> commands transfers a set of generic attribute array elements to the GL, if the index within the vertex arrays corresponding to that set is equal to the primitive restart index, then the GL does not process those elements as a vertex. Instead, it is as if the drawing command ended with the immediately preceding transfer, and another drawing command is immediately started with the same parameters, but only transferring the immediately following element through the end of the originally specified elements.</p><p>When either <strong>gl:drawElementsBaseVertex/5</strong> , <strong>gl:drawElementsInstancedBaseVertex/6</strong> or see <em>glMultiDrawElementsBaseVertex</em> is used, the primitive restart comparison occurs before the basevertex offset is added to the array index.</p><p>See external documentation.</p><p><strong></strong> getInteger64i_v(Target, Index) -&gt; [integer()]</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> getBufferParameteri64v(Target, Pname) -&gt; [integer()]</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>glGetBufferParameteri64v</p><p>See external documentation.</p><p><strong></strong> framebufferTexture(Target, Attachment, Texture, Level) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Attachment = enum()</p><p>Texture = integer()</p><p>Level = integer()</p><p>Attach a level of a texture object as a logical buffer to the currently bound framebuffer object</p><p><em>gl:framebufferTexture</em>, <em>gl:framebufferTexture1D</em>, <em>gl:framebufferTexture2D</em>, and <em>gl:framebufferTexture</em> attach a selected mipmap level or image of a texture object as one of the logical buffers of the framebuffer object currently bound to <em>Target</em> . <em>Target</em> must be <em>?GL_DRAW_FRAMEBUFFER</em>, <em>?GL_READ_FRAMEBUFFER</em>, or <em>?GL_FRAMEBUFFER</em> . <em>?GL_FRAMEBUFFER</em> is equivalent to <em>?GL_DRAW_FRAMEBUFFER</em>.</p><p><em>Attachment</em> specifies the logical attachment of the framebuffer and must be <em>?GL_COLOR_ATTACHMENT</em> <em>i</em>, <em>?GL_DEPTH_ATTACHMENT</em>, <em>?GL_STENCIL_ATTACHMENT</em> or <em>?GL_DEPTH_STENCIL_ATTACHMMENT</em> . <em>i</em> in <em>?GL_COLOR_ATTACHMENT</em><em>i</em> may range from zero to the value of <em>?GL_MAX_COLOR_ATTACHMENTS</em> - 1. Attaching a level of a texture to <em>?GL_DEPTH_STENCIL_ATTACHMENT</em> is equivalent to attaching that level to both the <em>?GL_DEPTH_ATTACHMENT</em><em>and</em> the <em>?GL_STENCIL_ATTACHMENT</em> attachment points simultaneously.</p><p><em>Textarget</em> specifies what type of texture is named by <em>Texture</em> , and for cube map textures, specifies the face that is to be attached. If <em>Texture</em> is not zero, it must be the name of an existing texture with type <em>Textarget</em> , unless it is a cube map texture, in which case <em>Textarget</em> must be <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_X</em> <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_X</em>, <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Y</em>, <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</em> , <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Z</em>, or <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</em>.</p><p>If <em>Texture</em> is non-zero, the specified <em>Level</em> of the texture object named <em>Texture</em> is attached to the framebfufer attachment point named by <em>Attachment</em> . For <em>gl:framebufferTexture1D</em> , <em>gl:framebufferTexture2D</em>, and <em>gl:framebufferTexture3D</em>, <em>Texture</em> must be zero or the name of an existing texture with a target of <em>Textarget</em> , or <em>Texture</em> must be the name of an existing cube-map texture and <em>Textarget</em> must be one of <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_X</em> , <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Y</em>, <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Z</em>, <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_X</em> , <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</em>, or <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</em>.</p><p>If <em>Textarget</em> is <em>?GL_TEXTURE_RECTANGLE</em>, <em>?GL_TEXTURE_2D_MULTISAMPLE</em>, or <em>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</em>, then <em>Level</em> must be zero. If <em>Textarget</em> is <em>?GL_TEXTURE_3D</em>, then level must be greater than or equal to zero and less than or equal to log2 of the value of <em>?GL_MAX_3D_TEXTURE_SIZE</em>. If <em>Textarget</em> is one of <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_X</em>, <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Y</em>, <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Z</em> , <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_X</em>, <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</em>, or <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</em> , then <em>Level</em> must be greater than or equal to zero and less than or equal to log2 of the value of <em>?GL_MAX_CUBE_MAP_TEXTURE_SIZE</em>. For all other values of <em>Textarget</em> , <em>Level</em> must be greater than or equal to zero and no larger than log2 of the value of <em>?GL_MAX_TEXTURE_SIZE</em>.</p><p><em>Layer</em> specifies the layer of a 2-dimensional image within a 3-dimensional texture.</p><p>For <em>gl:framebufferTexture1D</em>, if <em>Texture</em> is not zero, then <em>Textarget</em> must be <em>?GL_TEXTURE_1D</em>. For <em>gl:framebufferTexture2D</em>, if <em>Texture</em> is not zero, <em>Textarget</em> must be one of <em>?GL_TEXTURE_2D</em>, <em>?GL_TEXTURE_RECTANGLE</em> , <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_X</em>, <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Y</em>, <em>?GL_TEXTURE_CUBE_MAP_POSITIVE_Z</em> , <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_X</em>, <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</em>, <em>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</em> , or <em>?GL_TEXTURE_2D_MULTISAMPLE</em>. For <em>gl:framebufferTexture3D</em>, if <em>Texture</em> is not zero, then <em>Textarget</em> must be <em>?GL_TEXTURE_3D</em>.</p><p>See external documentation.</p><p><strong></strong> vertexAttribDivisor(Index, Divisor) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>Divisor = integer()</p><p>Modify the rate at which generic vertex attributes advance during instanced rendering</p><p><em>gl:vertexAttribDivisor</em> modifies the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw call. If <em>Divisor</em> is zero, the attribute at slot <em>Index</em> advances once per vertex. If <em>Divisor</em> is non-zero, the attribute advances once per <em>Divisor</em> instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if its <em>?GL_VERTEX_ATTRIB_ARRAY_DIVISOR</em> value is non-zero.</p><p><em>Index</em> must be less than the value of <em>?GL_MAX_VERTEX_ATTRIBUTES</em>.</p><p>See external documentation.</p><p><strong></strong> minSampleShading(Value) -&gt; ok</p><p>Types:</p><p>Value = clamp()</p><p>Specifies minimum rate at which sample shaing takes place</p><p><em>gl:minSampleShading</em> specifies the rate at which samples are shaded within a covered pixel. Sample-rate shading is enabled by calling <strong>gl:enable/1</strong> with the parameter <em>?GL_SAMPLE_SHADING</em> . If <em>?GL_MULTISAMPLE</em> or <em>?GL_SAMPLE_SHADING</em> is disabled, sample shading has no effect. Otherwise, an implementation must provide at least as many unique color values for each covered fragment as specified by <em>Value</em> times <em>Samples</em> where <em>Samples</em> is the value of <em>?GL_SAMPLES</em> for the current framebuffer. At least 1 sample for each covered fragment is generated.</p><p>A <em>Value</em> of 1.0 indicates that each sample in the framebuffer should be indpendently shaded. A <em>Value</em> of 0.0 effectively allows the GL to ignore sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade only a subset of the total samples within each covered fragment. Which samples are shaded and the algorithm used to select that subset of the fragment's samples is implementation dependent.</p><p>See external documentation.</p><p><strong></strong> blendEquationi(Buf, Mode) -&gt; ok</p><p>Types:</p><p>Buf = integer()</p><p>Mode = enum()</p><p>See <strong>blendEquation/1</strong></p><p><strong></strong> blendEquationSeparatei(Buf, ModeRGB, ModeAlpha) -&gt; ok</p><p>Types:</p><p>Buf = integer()</p><p>ModeRGB = enum()</p><p>ModeAlpha = enum()</p><p>See <strong>blendEquationSeparate/2</strong></p><p><strong></strong> blendFunci(Buf, Src, Dst) -&gt; ok</p><p>Types:</p><p>Buf = integer()</p><p>Src = enum()</p><p>Dst = enum()</p><p>glBlendFunci</p><p>See external documentation.</p><p><strong></strong> blendFuncSeparatei(Buf, SrcRGB, DstRGB, SrcAlpha, DstAlpha) -&gt; ok</p><p>Types:</p><p>Buf = integer()</p><p>SrcRGB = enum()</p><p>DstRGB = enum()</p><p>SrcAlpha = enum()</p><p>DstAlpha = enum()</p><p>See <strong>blendFuncSeparate/4</strong></p><p><strong></strong> loadTransposeMatrixfARB(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>glLoadTransposeMatrixARB</p><p>See external documentation.</p><p><strong></strong> loadTransposeMatrixdARB(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>glLoadTransposeMatrixARB</p><p>See external documentation.</p><p><strong></strong> multTransposeMatrixfARB(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>glMultTransposeMatrixARB</p><p>See external documentation.</p><p><strong></strong> multTransposeMatrixdARB(M) -&gt; ok</p><p>Types:</p><p>M = matrix()</p><p>glMultTransposeMatrixARB</p><p>See external documentation.</p><p><strong></strong> weightbvARB(Weights) -&gt; ok</p><p>Types:</p><p>Weights = [integer()]</p><p>glWeightARB</p><p>See external documentation.</p><p><strong></strong> weightsvARB(Weights) -&gt; ok</p><p>Types:</p><p>Weights = [integer()]</p><p>glWeightARB</p><p>See external documentation.</p><p><strong></strong> weightivARB(Weights) -&gt; ok</p><p>Types:</p><p>Weights = [integer()]</p><p>glWeightARB</p><p>See external documentation.</p><p><strong></strong> weightfvARB(Weights) -&gt; ok</p><p>Types:</p><p>Weights = [float()]</p><p>glWeightARB</p><p>See external documentation.</p><p><strong></strong> weightdvARB(Weights) -&gt; ok</p><p>Types:</p><p>Weights = [float()]</p><p>glWeightARB</p><p>See external documentation.</p><p><strong></strong> weightubvARB(Weights) -&gt; ok</p><p>Types:</p><p>Weights = [integer()]</p><p>glWeightARB</p><p>See external documentation.</p><p><strong></strong> weightusvARB(Weights) -&gt; ok</p><p>Types:</p><p>Weights = [integer()]</p><p>glWeightARB</p><p>See external documentation.</p><p><strong></strong> weightuivARB(Weights) -&gt; ok</p><p>Types:</p><p>Weights = [integer()]</p><p>glWeightARB</p><p>See external documentation.</p><p><strong></strong> vertexBlendARB(Count) -&gt; ok</p><p>Types:</p><p>Count = integer()</p><p>glVertexBlenARB</p><p>See external documentation.</p><p><strong></strong> currentPaletteMatrixARB(Index) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>glCurrentPaletteMatrixARB</p><p>See external documentation.</p><p><strong></strong> matrixIndexubvARB(Indices) -&gt; ok</p><p>Types:</p><p>Indices = [integer()]</p><p>glMatrixIndexARB</p><p>See external documentation.</p><p><strong></strong> matrixIndexusvARB(Indices) -&gt; ok</p><p>Types:</p><p>Indices = [integer()]</p><p>glMatrixIndexARB</p><p>See external documentation.</p><p><strong></strong> matrixIndexuivARB(Indices) -&gt; ok</p><p>Types:</p><p>Indices = [integer()]</p><p>glMatrixIndexARB</p><p>See external documentation.</p><p><strong></strong> programStringARB(Target, Format, String) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Format = enum()</p><p>String = string()</p><p>glProgramStringARB</p><p>See external documentation.</p><p><strong></strong> bindProgramARB(Target, Program) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Program = integer()</p><p>glBindProgramARB</p><p>See external documentation.</p><p><strong></strong> deleteProgramsARB(Programs) -&gt; ok</p><p>Types:</p><p>Programs = [integer()]</p><p>glDeleteProgramsARB</p><p>See external documentation.</p><p><strong></strong> genProgramsARB(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>glGenProgramsARB</p><p>See external documentation.</p><p><strong></strong> programEnvParameter4dARB(Target, Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>glProgramEnvParameterARB</p><p>See external documentation.</p><p><strong></strong> programEnvParameter4dvARB(Target, Index, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Params = {float(), float(), float(), float()}</p><p>glProgramEnvParameterARB</p><p>See external documentation.</p><p><strong></strong> programEnvParameter4fARB(Target, Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>glProgramEnvParameterARB</p><p>See external documentation.</p><p><strong></strong> programEnvParameter4fvARB(Target, Index, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Params = {float(), float(), float(), float()}</p><p>glProgramEnvParameterARB</p><p>See external documentation.</p><p><strong></strong> programLocalParameter4dARB(Target, Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>glProgramLocalParameterARB</p><p>See external documentation.</p><p><strong></strong> programLocalParameter4dvARB(Target, Index, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Params = {float(), float(), float(), float()}</p><p>glProgramLocalParameterARB</p><p>See external documentation.</p><p><strong></strong> programLocalParameter4fARB(Target, Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>glProgramLocalParameterARB</p><p>See external documentation.</p><p><strong></strong> programLocalParameter4fvARB(Target, Index, Params) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Params = {float(), float(), float(), float()}</p><p>glProgramLocalParameterARB</p><p>See external documentation.</p><p><strong></strong> getProgramEnvParameterdvARB(Target, Index) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>glGetProgramEnvParameterARB</p><p>See external documentation.</p><p><strong></strong> getProgramEnvParameterfvARB(Target, Index) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>glGetProgramEnvParameterARB</p><p>See external documentation.</p><p><strong></strong> getProgramLocalParameterdvARB(Target, Index) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>glGetProgramLocalParameterARB</p><p>See external documentation.</p><p><strong></strong> getProgramLocalParameterfvARB(Target, Index) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>glGetProgramLocalParameterARB</p><p>See external documentation.</p><p><strong></strong> getProgramStringARB(Target, Pname, String) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>String = mem()</p><p>glGetProgramStringARB</p><p>See external documentation.</p><p><strong></strong> getBufferParameterivARB(Target, Pname) -&gt; [integer()]</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>glGetBufferParameterARB</p><p>See external documentation.</p><p><strong></strong> deleteObjectARB(Obj) -&gt; ok</p><p>Types:</p><p>Obj = integer()</p><p>glDeleteObjectARB</p><p>See external documentation.</p><p><strong></strong> getHandleARB(Pname) -&gt; integer()</p><p>Types:</p><p>Pname = enum()</p><p>glGetHandleARB</p><p>See external documentation.</p><p><strong></strong> detachObjectARB(ContainerObj, AttachedObj) -&gt; ok</p><p>Types:</p><p>ContainerObj = integer()</p><p>AttachedObj = integer()</p><p>glDetachObjectARB</p><p>See external documentation.</p><p><strong></strong> createShaderObjectARB(ShaderType) -&gt; integer()</p><p>Types:</p><p>ShaderType = enum()</p><p>glCreateShaderObjectARB</p><p>See external documentation.</p><p><strong></strong> shaderSourceARB(ShaderObj, String) -&gt; ok</p><p>Types:</p><p>ShaderObj = integer()</p><p>String = [string()]</p><p>glShaderSourceARB</p><p>See external documentation.</p><p><strong></strong> compileShaderARB(ShaderObj) -&gt; ok</p><p>Types:</p><p>ShaderObj = integer()</p><p>glCompileShaderARB</p><p>See external documentation.</p><p><strong></strong> createProgramObjectARB() -&gt; integer()</p><p>glCreateProgramObjectARB</p><p>See external documentation.</p><p><strong></strong> attachObjectARB(ContainerObj, Obj) -&gt; ok</p><p>Types:</p><p>ContainerObj = integer()</p><p>Obj = integer()</p><p>glAttachObjectARB</p><p>See external documentation.</p><p><strong></strong> linkProgramARB(ProgramObj) -&gt; ok</p><p>Types:</p><p>ProgramObj = integer()</p><p>glLinkProgramARB</p><p>See external documentation.</p><p><strong></strong> useProgramObjectARB(ProgramObj) -&gt; ok</p><p>Types:</p><p>ProgramObj = integer()</p><p>glUseProgramObjectARB</p><p>See external documentation.</p><p><strong></strong> validateProgramARB(ProgramObj) -&gt; ok</p><p>Types:</p><p>ProgramObj = integer()</p><p>glValidateProgramARB</p><p>See external documentation.</p><p><strong></strong> getObjectParameterfvARB(Obj, Pname) -&gt; float()</p><p>Types:</p><p>Obj = integer()</p><p>Pname = enum()</p><p>glGetObjectParameterARB</p><p>See external documentation.</p><p><strong></strong> getObjectParameterivARB(Obj, Pname) -&gt; integer()</p><p>Types:</p><p>Obj = integer()</p><p>Pname = enum()</p><p>glGetObjectParameterARB</p><p>See external documentation.</p><p><strong></strong> getInfoLogARB(Obj, MaxLength) -&gt; string()</p><p>Types:</p><p>Obj = integer()</p><p>MaxLength = integer()</p><p>glGetInfoLogARB</p><p>See external documentation.</p><p><strong></strong> getAttachedObjectsARB(ContainerObj, MaxCount) -&gt; [integer()]</p><p>Types:</p><p>ContainerObj = integer()</p><p>MaxCount = integer()</p><p>glGetAttachedObjectsARB</p><p>See external documentation.</p><p><strong></strong> getUniformLocationARB(ProgramObj, Name) -&gt; integer()</p><p>Types:</p><p>ProgramObj = integer()</p><p>Name = string()</p><p>glGetUniformLocationARB</p><p>See external documentation.</p><p><strong></strong> getActiveUniformARB(ProgramObj, Index, MaxLength) -&gt; {Size::integer(), Type::enum(), Name::string()}</p><p>Types:</p><p>ProgramObj = integer()</p><p>Index = integer()</p><p>MaxLength = integer()</p><p>glGetActiveUniformARB</p><p>See external documentation.</p><p><strong></strong> getUniformfvARB(ProgramObj, Location) -&gt; matrix()</p><p>Types:</p><p>ProgramObj = integer()</p><p>Location = integer()</p><p>glGetUniformARB</p><p>See external documentation.</p><p><strong></strong> getUniformivARB(ProgramObj, Location) -&gt; {integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer()}</p><p>Types:</p><p>ProgramObj = integer()</p><p>Location = integer()</p><p>glGetUniformARB</p><p>See external documentation.</p><p><strong></strong> getShaderSourceARB(Obj, MaxLength) -&gt; string()</p><p>Types:</p><p>Obj = integer()</p><p>MaxLength = integer()</p><p>glGetShaderSourceARB</p><p>See external documentation.</p><p><strong></strong> bindAttribLocationARB(ProgramObj, Index, Name) -&gt; ok</p><p>Types:</p><p>ProgramObj = integer()</p><p>Index = integer()</p><p>Name = string()</p><p>glBindAttribLocationARB</p><p>See external documentation.</p><p><strong></strong> getActiveAttribARB(ProgramObj, Index, MaxLength) -&gt; {Size::integer(), Type::enum(), Name::string()}</p><p>Types:</p><p>ProgramObj = integer()</p><p>Index = integer()</p><p>MaxLength = integer()</p><p>glGetActiveAttribARB</p><p>See external documentation.</p><p><strong></strong> getAttribLocationARB(ProgramObj, Name) -&gt; integer()</p><p>Types:</p><p>ProgramObj = integer()</p><p>Name = string()</p><p>glGetAttribLocationARB</p><p>See external documentation.</p><p><strong></strong> isRenderbuffer(Renderbuffer) -&gt; 0 | 1</p><p>Types:</p><p>Renderbuffer = integer()</p><p>Determine if a name corresponds to a renderbuffer object</p><p><em>gl:isRenderbuffer</em> returns <em>?GL_TRUE</em> if <em>Renderbuffer</em> is currently the name of a renderbuffer object. If <em>Renderbuffer</em> is zero, or if <em>Renderbuffer</em> is not the name of a renderbuffer object, or if an error occurs, <em>gl:isRenderbuffer</em> returns <em>?GL_FALSE</em>. If <em>Renderbuffer</em> is a name returned by <strong>gl:genRenderbuffers/1</strong> , by that has not yet been bound through a call to <strong>gl:bindRenderbuffer/2</strong> or <strong>gl:framebufferRenderbuffer/4</strong> , then the name is not a renderbuffer object and <em>gl:isRenderbuffer</em> returns <em>?GL_FALSE</em> .</p><p>See external documentation.</p><p><strong></strong> bindRenderbuffer(Target, Renderbuffer) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Renderbuffer = integer()</p><p>Bind a renderbuffer to a renderbuffer target</p><p><em>gl:bindRenderbuffer</em> binds the renderbuffer object with name <em>Renderbuffer</em> to the renderbuffer target specified by <em>Target</em> . <em>Target</em> must be <em>?GL_RENDERBUFFER</em> . <em>Renderbuffer</em> is the name of a renderbuffer object previously returned from a call to <strong>gl:genRenderbuffers/1</strong> , or zero to break the existing binding of a renderbuffer object to <em>Target</em> .</p><p>See external documentation.</p><p><strong></strong> deleteRenderbuffers(Renderbuffers) -&gt; ok</p><p>Types:</p><p>Renderbuffers = [integer()]</p><p>Delete renderbuffer objects</p><p><em>gl:deleteRenderbuffers</em> deletes the <em>N</em> renderbuffer objects whose names are stored in the array addressed by <em>Renderbuffers</em> . The name zero is reserved by the GL and is silently ignored, should it occur in <em>Renderbuffers</em> , as are other unused names. Once a renderbuffer object is deleted, its name is again unused and it has no contents. If a renderbuffer that is currently bound to the target <em>?GL_RENDERBUFFER</em> is deleted, it is as though <strong>gl:bindRenderbuffer/2</strong> had been executed with a <em>Target</em> of <em>?GL_RENDERBUFFER</em> and a <em>Name</em> of zero.</p><p>If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if <strong>gl:framebufferRenderbuffer/4</strong> had been called, with a <em>Renderbuffer</em> of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words, this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer image is specifically <em>not</em> detached from any non-bound framebuffers.</p><p>See external documentation.</p><p><strong></strong> genRenderbuffers(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>Generate renderbuffer object names</p><p><em>gl:genRenderbuffers</em> returns <em>N</em> renderbuffer object names in <em>Renderbuffers</em> . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to <em>gl:genRenderbuffers</em> .</p><p>Renderbuffer object names returned by a call to <em>gl:genRenderbuffers</em> are not returned by subsequent calls, unless they are first deleted with <strong>gl:deleteRenderbuffers/1</strong> .</p><p>The names returned in <em>Renderbuffers</em> are marked as used, for the purposes of <em>gl:genRenderbuffers</em> only, but they acquire state and type only when they are first bound.</p><p>See external documentation.</p><p><strong></strong> renderbufferStorage(Target, Internalformat, Width, Height) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Height = integer()</p><p>Establish data storage, format and dimensions of a renderbuffer object's image</p><p><em>gl:renderbufferStorage</em> is equivalent to calling <strong>gl:renderbufferStorageMultisample/5</strong> with the <em>Samples</em> set to zero.</p><p>The target of the operation, specified by <em>Target</em> must be <em>?GL_RENDERBUFFER</em>. <em>Internalformat</em> specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. <em>Width</em> and <em>Height</em> are the dimensions, in pixels, of the renderbuffer. Both <em>Width</em> and <em>Height</em> must be less than or equal to the value of <em>?GL_MAX_RENDERBUFFER_SIZE</em> .</p><p>Upon success, <em>gl:renderbufferStorage</em> deletes any existing data store for the renderbuffer image and the contents of the data store after calling <em>gl:renderbufferStorage</em> are undefined.</p><p>See external documentation.</p><p><strong></strong> getRenderbufferParameteriv(Target, Pname) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>Pname = enum()</p><p>Retrieve information about a bound renderbuffer object</p><p><em>gl:getRenderbufferParameteriv</em> retrieves information about a bound renderbuffer object. <em>Target</em> specifies the target of the query operation and must be <em>?GL_RENDERBUFFER</em> . <em>Pname</em> specifies the parameter whose value to query and must be one of <em>?GL_RENDERBUFFER_WIDTH</em> , <em>?GL_RENDERBUFFER_HEIGHT</em>, <em>?GL_RENDERBUFFER_INTERNAL_FORMAT</em>, <em>?GL_RENDERBUFFER_RED_SIZE</em> , <em>?GL_RENDERBUFFER_GREEN_SIZE</em>, <em>?GL_RENDERBUFFER_BLUE_SIZE</em>, <em>?GL_RENDERBUFFER_ALPHA_SIZE</em> , <em>?GL_RENDERBUFFER_DEPTH_SIZE</em>, <em>?GL_RENDERBUFFER_DEPTH_SIZE</em>, <em>?GL_RENDERBUFFER_STENCIL_SIZE</em> , or <em>?GL_RENDERBUFFER_SAMPLES</em>.</p><p>Upon a successful return from <em>gl:getRenderbufferParameteriv</em>, if <em>Pname</em> is <em>?GL_RENDERBUFFER_WIDTH</em> , <em>?GL_RENDERBUFFER_HEIGHT</em>, <em>?GL_RENDERBUFFER_INTERNAL_FORMAT</em>, or <em>?GL_RENDERBUFFER_SAMPLES</em> , then <em>Params</em> will contain the width in pixels, the height in pixels, the internal format, or the number of samples, respectively, of the image of the renderbuffer currently bound to <em>Target</em> .</p><p>If <em>Pname</em> is <em>?GL_RENDERBUFFER_RED_SIZE</em>, <em>?GL_RENDERBUFFER_GREEN_SIZE</em>, <em>?GL_RENDERBUFFER_BLUE_SIZE</em>, <em>?GL_RENDERBUFFER_ALPHA_SIZE</em>, <em>?GL_RENDERBUFFER_DEPTH_SIZE</em> , or <em>?GL_RENDERBUFFER_STENCIL_SIZE</em>, then <em>Params</em> will contain the actual resolutions (not the resolutions specified when the image array was defined) for the red, green, blue, alpha depth, or stencil components, respectively, of the image of the renderbuffer currently bound to <em>Target</em> .</p><p>See external documentation.</p><p><strong></strong> isFramebuffer(Framebuffer) -&gt; 0 | 1</p><p>Types:</p><p>Framebuffer = integer()</p><p>Determine if a name corresponds to a framebuffer object</p><p><em>gl:isFramebuffer</em> returns <em>?GL_TRUE</em> if <em>Framebuffer</em> is currently the name of a framebuffer object. If <em>Framebuffer</em> is zero, or if <em>?framebuffer</em> is not the name of a framebuffer object, or if an error occurs, <em>gl:isFramebuffer</em> returns <em>?GL_FALSE</em>. If <em>Framebuffer</em> is a name returned by <strong>gl:genFramebuffers/1</strong> , by that has not yet been bound through a call to <strong>gl:bindFramebuffer/2</strong> , then the name is not a framebuffer object and <em>gl:isFramebuffer</em> returns <em>?GL_FALSE</em>.</p><p>See external documentation.</p><p><strong></strong> bindFramebuffer(Target, Framebuffer) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Framebuffer = integer()</p><p>Bind a framebuffer to a framebuffer target</p><p><em>gl:bindFramebuffer</em> binds the framebuffer object with name <em>Framebuffer</em> to the framebuffer target specified by <em>Target</em> . <em>Target</em> must be either <em>?GL_DRAW_FRAMEBUFFER</em> , <em>?GL_READ_FRAMEBUFFER</em> or <em>?GL_FRAMEBUFFER</em>. If a framebuffer object is bound to <em>?GL_DRAW_FRAMEBUFFER</em> or <em>?GL_READ_FRAMEBUFFER</em>, it becomes the target for rendering or readback operations, respectively, until it is deleted or another framebuffer is bound to the corresponding bind point. Calling <em>gl:bindFramebuffer</em> with <em>Target</em> set to <em>?GL_FRAMEBUFFER</em> binds <em>Framebuffer</em> to both the read and draw framebuffer targets. <em>Framebuffer</em> is the name of a framebuffer object previously returned from a call to <strong>gl:genFramebuffers/1</strong> , or zero to break the existing binding of a framebuffer object to <em>Target</em> .</p><p>See external documentation.</p><p><strong></strong> deleteFramebuffers(Framebuffers) -&gt; ok</p><p>Types:</p><p>Framebuffers = [integer()]</p><p>Delete framebuffer objects</p><p><em>gl:deleteFramebuffers</em> deletes the <em>N</em> framebuffer objects whose names are stored in the array addressed by <em>Framebuffers</em> . The name zero is reserved by the GL and is silently ignored, should it occur in <em>Framebuffers</em> , as are other unused names. Once a framebuffer object is deleted, its name is again unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets <em>?GL_DRAW_FRAMEBUFFER</em> or <em>?GL_READ_FRAMEBUFFER</em> is deleted, it is as though <strong>gl:bindFramebuffer/2</strong> had been executed with the corresponding <em>Target</em> and <em>Framebuffer</em> zero.</p><p>See external documentation.</p><p><strong></strong> genFramebuffers(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>Generate framebuffer object names</p><p><em>gl:genFramebuffers</em> returns <em>N</em> framebuffer object names in <em>Ids</em> . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to <em>gl:genFramebuffers</em> .</p><p>Framebuffer object names returned by a call to <em>gl:genFramebuffers</em> are not returned by subsequent calls, unless they are first deleted with <strong>gl:deleteFramebuffers/1</strong> .</p><p>The names returned in <em>Ids</em> are marked as used, for the purposes of <em>gl:genFramebuffers</em> only, but they acquire state and type only when they are first bound.</p><p>See external documentation.</p><p><strong></strong> checkFramebufferStatus(Target) -&gt; enum()</p><p>Types:</p><p>Target = enum()</p><p>Check the completeness status of a framebuffer</p><p><em>gl:checkFramebufferStatus</em> queries the completeness status of the framebuffer object currently bound to <em>Target</em> . <em>Target</em> must be <em>?GL_DRAW_FRAMEBUFFER</em>, <em>?GL_READ_FRAMEBUFFER</em> or <em>?GL_FRAMEBUFFER</em>. <em>?GL_FRAMEBUFFER</em> is equivalent to <em>?GL_DRAW_FRAMEBUFFER</em> .</p><p>The return value is <em>?GL_FRAMEBUFFER_COMPLETE</em> if the framebuffer bound to <em>Target</em> is complete. Otherwise, the return value is determined as follows:</p><p><em>?GL_FRAMEBUFFER_UNDEFINED</em> is returned if <em>Target</em> is the default framebuffer, but the default framebuffer does not exist.</p><p><em>?GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT</em> is returned if any of the framebuffer attachment points are framebuffer incomplete.</p><p><em>?GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT</em> is returned if the framebuffer does not have at least one image attached to it.</p><p><em>?GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER</em> is returned if the value of <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</em> is <em>?GL_NONE</em> for any color attachment point(s) named by <em>?GL_DRAWBUFFERi</em>.</p><p><em>?GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER</em> is returned if <em>?GL_READ_BUFFER</em> is not <em>?GL_NONE</em> and the value of <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</em> is <em>?GL_NONE</em> for the color attachment point named by <em>?GL_READ_BUFFER</em>.</p><p><em>?GL_FRAMEBUFFER_UNSUPPORTED</em> is returned if the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.</p><p><em>?GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE</em> is returned if the value of <em>?GL_RENDERBUFFER_SAMPLES</em> is not the same for all attached renderbuffers; if the value of <em>?GL_TEXTURE_SAMPLES</em> is the not same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of <em>?GL_RENDERBUFFER_SAMPLES</em> does not match the value of <em>?GL_TEXTURE_SAMPLES</em> .</p><p><em>?GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE</em> is also returned if the value of <em>?GL_TEXTURE_FIXED_SAMPLE_LOCATIONS</em> is not the same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of <em>?GL_TEXTURE_FIXED_SAMPLE_LOCATIONS</em> is not <em>?GL_TRUE</em> for all attached textures.</p><p><em>?GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS</em> is returned if any framebuffer attachment is layered, and any populated attachment is not layered, or if all populated color attachments are not from textures of the same target.</p><p>Additionally, if an error occurs, zero is returned.</p><p>See external documentation.</p><p><strong></strong> framebufferTexture1D(Target, Attachment, Textarget, Texture, Level) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Attachment = enum()</p><p>Textarget = enum()</p><p>Texture = integer()</p><p>Level = integer()</p><p>See <strong>framebufferTexture/4</strong></p><p><strong></strong> framebufferTexture2D(Target, Attachment, Textarget, Texture, Level) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Attachment = enum()</p><p>Textarget = enum()</p><p>Texture = integer()</p><p>Level = integer()</p><p>See <strong>framebufferTexture/4</strong></p><p><strong></strong> framebufferTexture3D(Target, Attachment, Textarget, Texture, Level, Zoffset) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Attachment = enum()</p><p>Textarget = enum()</p><p>Texture = integer()</p><p>Level = integer()</p><p>Zoffset = integer()</p><p>See <strong>framebufferTexture/4</strong></p><p><strong></strong> framebufferRenderbuffer(Target, Attachment, Renderbuffertarget, Renderbuffer) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Attachment = enum()</p><p>Renderbuffertarget = enum()</p><p>Renderbuffer = integer()</p><p>Attach a renderbuffer as a logical buffer to the currently bound framebuffer object</p><p><em>gl:framebufferRenderbuffer</em> attaches a renderbuffer as one of the logical buffers of the currently bound framebuffer object. <em>Renderbuffer</em> is the name of the renderbuffer object to attach and must be either zero, or the name of an existing renderbuffer object of type <em>Renderbuffertarget</em> . If <em>Renderbuffer</em> is not zero and if <em>gl:framebufferRenderbuffer</em> is successful, then the renderbuffer name <em>Renderbuffer</em> will be used as the logical buffer identified by <em>Attachment</em> of the framebuffer currently bound to <em>Target</em> .</p><p>The value of <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</em> for the specified attachment point is set to <em>?GL_RENDERBUFFER</em> and the value of <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</em> is set to <em>Renderbuffer</em> . All other state values of the attachment point specified by <em>Attachment</em> are set to their default values. No change is made to the state of the renderbuuffer object and any previous attachment to the <em>Attachment</em> logical buffer of the framebuffer <em>Target</em> is broken.</p><p>Calling <em>gl:framebufferRenderbuffer</em> with the renderbuffer name zero will detach the image, if any, identified by <em>Attachment</em> , in the framebuffer currently bound to <em>Target</em> . All state values of the attachment point specified by attachment in the object bound to target are set to their default values.</p><p>Setting <em>Attachment</em> to the value <em>?GL_DEPTH_STENCIL_ATTACHMENT</em> is a special case causing both the depth and stencil attachments of the framebuffer object to be set to <em>Renderbuffer</em> , which should have the base internal format <em>?GL_DEPTH_STENCIL</em> .</p><p>See external documentation.</p><p><strong></strong> getFramebufferAttachmentParameteriv(Target, Attachment, Pname) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>Attachment = enum()</p><p>Pname = enum()</p><p>Retrieve information about attachments of a bound framebuffer object</p><p><em>gl:getFramebufferAttachmentParameter</em> returns information about attachments of a bound framebuffer object. <em>Target</em> specifies the framebuffer binding point and must be <em>?GL_DRAW_FRAMEBUFFER</em>, <em>?GL_READ_FRAMEBUFFER</em> or <em>?GL_FRAMEBUFFER</em>. <em>?GL_FRAMEBUFFER</em> is equivalent to <em>?GL_DRAW_FRAMEBUFFER</em>.</p><p>If the default framebuffer is bound to <em>Target</em> then <em>Attachment</em> must be one of <em>?GL_FRONT_LEFT</em>, <em>?GL_FRONT_RIGHT</em>, <em>?GL_BACK_LEFT</em>, or <em>?GL_BACK_RIGHT</em> , identifying a color buffer, <em>?GL_DEPTH</em>, identifying the depth buffer, or <em>?GL_STENCIL</em> , identifying the stencil buffer.</p><p>If a framebuffer object is bound, then <em>Attachment</em> must be one of <em>?GL_COLOR_ATTACHMENT</em> <em>i</em>, <em>?GL_DEPTH_ATTACHMENT</em>, <em>?GL_STENCIL_ATTACHMENT</em>, or <em>?GL_DEPTH_STENCIL_ATTACHMENT</em> . <em>i</em> in <em>?GL_COLOR_ATTACHMENT</em><em>i</em> must be in the range zero to the value of <em>?GL_MAX_COLOR_ATTACHMENTS</em> - 1.</p><p>If <em>Attachment</em> is <em>?GL_DEPTH_STENCIL_ATTACHMENT</em> and different objects are bound to the depth and stencil attachment points of <em>Target</em> the query will fail. If the same object is bound to both attachment points, information about that object will be returned.</p><p>Upon successful return from <em>gl:getFramebufferAttachmentParameteriv</em>, if <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</em>, then <em>Params</em> will contain one of <em>?GL_NONE</em> , <em>?GL_FRAMEBUFFER_DEFAULT</em>, <em>?GL_TEXTURE</em>, or <em>?GL_RENDERBUFFER</em>, identifying the type of object which contains the attached image. Other values accepted for <em>Pname</em> depend on the type of object, as described below.</p><p>If the value of <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</em> is <em>?GL_NONE</em>, no framebuffer is bound to <em>Target</em> . In this case querying <em>Pname</em> <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</em> will return zero, and all other queries will generate an error.</p><p>If the value of <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</em> is not <em>?GL_NONE</em>, these queries apply to all other framebuffer types:</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE</em>, <em>?GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE</em> , <em>?GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE</em>, <em>?GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE</em> , <em>?GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE</em>, or <em>?GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE</em> , then <em>Params</em> will contain the number of bits in the corresponding red, green, blue, alpha, depth, or stencil component of the specified attachment. Zero is returned if the requested component is not present in <em>Attachment</em> .</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE</em>, <em>Params</em> will contain the format of components of the specified attachment, one of <em>?GL_FLOAT</em>, <em>GL_INT</em> , <em>GL_UNSIGNED_INT</em> , <em>GL_SIGNED_NORMALIZED</em> , or <em>GL_UNSIGNED_NORMALIZED</em> for floating-point, signed integer, unsigned integer, signed normalized fixed-point, or unsigned normalized fixed-point components respectively. Only color buffers may have integer components.</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING</em>, <em>Param</em> will contain the encoding of components of the specified attachment, one of <em>?GL_LINEAR</em> or <em>?GL_SRGB</em> for linear or sRGB-encoded components, respectively. Only color buffer components may be sRGB-encoded; such components are treated as described in sections 4.1.7 and 4.1.8. For the default framebuffer, color encoding is determined by the implementation. For framebuffer objects, components are sRGB-encoded if the internal format of a color attachment is one of the color-renderable SRGB formats.</p><p>If the value of <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</em> is <em>?GL_RENDERBUFFER</em>, then:</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</em>, <em>Params</em> will contain the name of the renderbuffer object which contains the attached image.</p><p>If the value of <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</em> is <em>?GL_TEXTURE</em>, then:</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</em>, then <em>Params</em> will contain the name of the texture object which contains the attached image.</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</em>, then <em>Params</em> will contain the mipmap level of the texture object which contains the attached image.</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</em> and the texture object named <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</em> is a cube map texture, then <em>Params</em> will contain the cube map face of the cubemap texture object which contains the attached image. Otherwise <em>Params</em> will contain the value zero.</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER</em> and the texture object named <em>?GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</em> is a layer of a three-dimensional texture or a one-or two-dimensional array texture, then <em>Params</em> will contain the number of the texture layer which contains the attached image. Otherwise <em>Params</em> will contain the value zero.</p><p>If <em>Pname</em> is <em>?GL_FRAMEBUFFER_ATTACHMENT_LAYERED</em>, then <em>Params</em> will contain <em>?GL_TRUE</em> if an entire level of a three-dimesional texture, cube map texture, or one-or two-dimensional array texture is attached. Otherwise, <em>Params</em> will contain <em>?GL_FALSE</em>.</p><p>Any combinations of framebuffer type and <em>Pname</em> not described above will generate an error.</p><p>See external documentation.</p><p><strong></strong> generateMipmap(Target) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Generate mipmaps for a specified texture target</p><p><em>gl:generateMipmap</em> generates mipmaps for the texture attached to <em>Target</em> of the active texture unit. For cube map textures, a <em>?GL_INVALID_OPERATION</em> error is generated if the texture attached to <em>Target</em> is not cube complete.</p><p>Mipmap generation replaces texel array levels level base+1 through q with arrays derived from the level base array, regardless of their previous contents. All other mimap arrays, including the level base array, are left unchanged by this computation.</p><p>The internal formats of the derived mipmap arrays all match those of the level base array. The contents of the derived arrays are computed by repeated, filtered reduction of the level base array. For one- and two-dimensional texture arrays, each layer is filtered independently.</p><p>See external documentation.</p><p><strong></strong> blitFramebuffer(SrcX0, SrcY0, SrcX1, SrcY1, DstX0, DstY0, DstX1, DstY1, Mask, Filter) -&gt; ok</p><p>Types:</p><p>SrcX0 = integer()</p><p>SrcY0 = integer()</p><p>SrcX1 = integer()</p><p>SrcY1 = integer()</p><p>DstX0 = integer()</p><p>DstY0 = integer()</p><p>DstX1 = integer()</p><p>DstY1 = integer()</p><p>Mask = integer()</p><p>Filter = enum()</p><p>Copy a block of pixels from the read framebuffer to the draw framebuffer</p><p><em>gl:blitFramebuffer</em> transfers a rectangle of pixel values from one region of the read framebuffer to another region in the draw framebuffer. <em>Mask</em> is the bitwise OR of a number of values indicating which buffers are to be copied. The values are <em>?GL_COLOR_BUFFER_BIT</em> , <em>?GL_DEPTH_BUFFER_BIT</em>, and <em>?GL_STENCIL_BUFFER_BIT</em>. The pixels corresponding to these buffers are copied from the source rectangle bounded by the locations ( <em>SrcX0</em> ; <em>SrcY0</em> ) and ( <em>SrcX1</em> ; <em>SrcY1</em> ) to the destination rectangle bounded by the locations ( <em>DstX0</em> ; <em>DstY0</em> ) and ( <em>DstX1</em> ; <em>DstY1</em> ). The lower bounds of the rectangle are inclusive, while the upper bounds are exclusive.</p><p>The actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred, which may include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending on mask. The actual region written to the draw framebuffer is limited to the intersection of the destination buffers being written, which may include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether or not the source or destination regions are altered due to these limits, the scaling and offset applied to pixels being transferred is performed as though no such limits were present.</p><p>If the sizes of the source and destination rectangles are not equal, <em>Filter</em> specifies the interpolation method that will be applied to resize the source image , and must be <em>?GL_NEAREST</em> or <em>?GL_LINEAR</em>. <em>?GL_LINEAR</em> is only a valid interpolation method for the color buffer. If <em>Filter</em> is not <em>?GL_NEAREST</em> and <em>Mask</em> includes <em>?GL_DEPTH_BUFFER_BIT</em> or <em>?GL_STENCIL_BUFFER_BIT</em>, no data is transferred and a <em>?GL_INVALID_OPERATION</em> error is generated.</p><p>If <em>Filter</em> is <em>?GL_LINEAR</em> and the source rectangle would require sampling outside the bounds of the source framebuffer, values are read as if the <em>?GL_CLAMP_TO_EDGE</em> texture wrapping mode were applied.</p><p>When the color buffer is transferred, values are taken from the read buffer of the read framebuffer and written to each of the draw buffers of the draw framebuffer.</p><p>If the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result of the operation is undefined.</p><p>See external documentation.</p><p><strong></strong> renderbufferStorageMultisample(Target, Samples, Internalformat, Width, Height) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Samples = integer()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Height = integer()</p><p>Establish data storage, format, dimensions and sample count of a renderbuffer object's image</p><p><em>gl:renderbufferStorageMultisample</em> establishes the data storage, format, dimensions and number of samples of a renderbuffer object's image.</p><p>The target of the operation, specified by <em>Target</em> must be <em>?GL_RENDERBUFFER</em>. <em>Internalformat</em> specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. <em>Width</em> and <em>Height</em> are the dimensions, in pixels, of the renderbuffer. Both <em>Width</em> and <em>Height</em> must be less than or equal to the value of <em>?GL_MAX_RENDERBUFFER_SIZE</em> . <em>Samples</em> specifies the number of samples to be used for the renderbuffer object's image, and must be less than or equal to the value of <em>?GL_MAX_SAMPLES</em>. If <em>Internalformat</em> is a signed or unsigned integer format then <em>Samples</em> must be less than or equal to the value of <em>?GL_MAX_INTEGER_SAMPLES</em>.</p><p>Upon success, <em>gl:renderbufferStorageMultisample</em> deletes any existing data store for the renderbuffer image and the contents of the data store after calling <em>gl:renderbufferStorageMultisample</em> are undefined.</p><p>See external documentation.</p><p><strong></strong> framebufferTextureLayer(Target, Attachment, Texture, Level, Layer) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Attachment = enum()</p><p>Texture = integer()</p><p>Level = integer()</p><p>Layer = integer()</p><p>See <strong>framebufferTexture/4</strong></p><p><strong></strong> framebufferTextureFaceARB(Target, Attachment, Texture, Level, Face) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Attachment = enum()</p><p>Texture = integer()</p><p>Level = integer()</p><p>Face = enum()</p><p>See <strong>framebufferTexture/4</strong></p><p><strong></strong> flushMappedBufferRange(Target, Offset, Length) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Offset = integer()</p><p>Length = integer()</p><p>Indicate modifications to a range of a mapped buffer</p><p><em>gl:flushMappedBufferRange</em> indicates that modifications have been made to a range of a mapped buffer. The buffer must previously have been mapped with the <em>?GL_MAP_FLUSH_EXPLICIT</em> flag. <em>Offset</em> and <em>Length</em> indicate the modified subrange of the mapping, in basic units. The specified subrange to flush is relative to the start of the currently mapped range of the buffer. <em>gl:flushMappedBufferRange</em> may be called multiple times to indicate distinct subranges of the mapping which require flushing.</p><p>See external documentation.</p><p><strong></strong> bindVertexArray(Array) -&gt; ok</p><p>Types:</p><p>Array = integer()</p><p>Bind a vertex array object</p><p><em>gl:bindVertexArray</em> binds the vertex array object with name <em>Array</em> . <em>Array</em> is the name of a vertex array object previously returned from a call to <strong>gl:genVertexArrays/1</strong> , or zero to break the existing vertex array object binding.</p><p>If no vertex array object with name <em>Array</em> exists, one is created when <em>Array</em> is first bound. If the bind is successful no change is made to the state of the vertex array object, and any previous vertex array object binding is broken.</p><p>See external documentation.</p><p><strong></strong> deleteVertexArrays(Arrays) -&gt; ok</p><p>Types:</p><p>Arrays = [integer()]</p><p>Delete vertex array objects</p><p><em>gl:deleteVertexArrays</em> deletes <em>N</em> vertex array objects whose names are stored in the array addressed by <em>Arrays</em> . Once a vertex array object is deleted it has no contents and its name is again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero and the default vertex array becomes current. Unused names in <em>Arrays</em> are silently ignored, as is the value zero.</p><p>See external documentation.</p><p><strong></strong> genVertexArrays(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>Generate vertex array object names</p><p><em>gl:genVertexArrays</em> returns <em>N</em> vertex array object names in <em>Arrays</em> . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to <em>gl:genVertexArrays</em> .</p><p>Vertex array object names returned by a call to <em>gl:genVertexArrays</em> are not returned by subsequent calls, unless they are first deleted with <strong>gl:deleteVertexArrays/1</strong> .</p><p>The names returned in <em>Arrays</em> are marked as used, for the purposes of <em>gl:genVertexArrays</em> only, but they acquire state and type only when they are first bound.</p><p>See external documentation.</p><p><strong></strong> isVertexArray(Array) -&gt; 0 | 1</p><p>Types:</p><p>Array = integer()</p><p>Determine if a name corresponds to a vertex array object</p><p><em>gl:isVertexArray</em> returns <em>?GL_TRUE</em> if <em>Array</em> is currently the name of a renderbuffer object. If <em>Renderbuffer</em> is zero, or if <em>Array</em> is not the name of a renderbuffer object, or if an error occurs, <em>gl:isVertexArray</em> returns <em>?GL_FALSE</em> . If <em>Array</em> is a name returned by <strong>gl:genVertexArrays/1</strong> , by that has not yet been bound through a call to <strong>gl:bindVertexArray/1</strong> , then the name is not a vertex array object and <em>gl:isVertexArray</em> returns <em>?GL_FALSE</em>.</p><p>See external documentation.</p><p><strong></strong> getUniformIndices(Program, UniformNames) -&gt; [integer()]</p><p>Types:</p><p>Program = integer()</p><p>UniformNames = [string()]</p><p>Retrieve the index of a named uniform block</p><p><em>gl:getUniformIndices</em> retrieves the indices of a number of uniforms within <em>Program</em> .</p><p><em>Program</em> must be the name of a program object for which the command <strong>gl:linkProgram/1</strong> must have been called in the past, although it is not required that <strong>gl:linkProgram/1</strong> must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.</p><p><em>UniformCount</em> indicates both the number of elements in the array of names <em>UniformNames</em> and the number of indices that may be written to <em>UniformIndices</em> .</p><p><em>UniformNames</em> contains a list of <em>UniformCount</em> name strings identifying the uniform names to be queried for indices. For each name string in <em>UniformNames</em> , the index assigned to the active uniform of that name will be written to the corresponding element of <em>UniformIndices</em> . If a string in <em>UniformNames</em> is not the name of an active uniform, the special value <em>?GL_INVALID_INDEX</em> will be written to the corresponding element of <em>UniformIndices</em> .</p><p>If an error occurs, nothing is written to <em>UniformIndices</em> .</p><p>See external documentation.</p><p><strong></strong> getActiveUniformsiv(Program, UniformIndices, Pname) -&gt; [integer()]</p><p>Types:</p><p>Program = integer()</p><p>UniformIndices = [integer()]</p><p>Pname = enum()</p><p>glGetActiveUniforms</p><p>See external documentation.</p><p><strong></strong> getActiveUniformName(Program, UniformIndex, BufSize) -&gt; string()</p><p>Types:</p><p>Program = integer()</p><p>UniformIndex = integer()</p><p>BufSize = integer()</p><p>Query the name of an active uniform</p><p><em>gl:getActiveUniformName</em> returns the name of the active uniform at <em>UniformIndex</em> within <em>Program</em> . If <em>UniformName</em> is not NULL, up to <em>BufSize</em> characters (including a nul-terminator) will be written into the array whose address is specified by <em>UniformName</em> . If <em>Length</em> is not NULL, the number of characters that were (or would have been) written into <em>UniformName</em> (not including the nul-terminator) will be placed in the variable whose address is specified in <em>Length</em> . If <em>Length</em> is NULL, no length is returned. The length of the longest uniform name in <em>Program</em> is given by the value of <em>?GL_ACTIVE_UNIFORM_MAX_LENGTH</em>, which can be queried with <strong>gl:getProgramiv/2</strong> .</p><p>If <em>gl:getActiveUniformName</em> is not successful, nothing is written to <em>Length</em> or <em>UniformName</em> .</p><p><em>Program</em> must be the name of a program for which the command <strong>gl:linkProgram/1</strong> has been issued in the past. It is not necessary for <em>Program</em> to have been linked successfully. The link could have failed because the number of active uniforms exceeded the limit.</p><p><em>UniformIndex</em> must be an active uniform index of the program <em>Program</em> , in the range zero to <em>?GL_ACTIVE_UNIFORMS</em> - 1. The value of <em>?GL_ACTIVE_UNIFORMS</em> can be queried with <strong>gl:getProgramiv/2</strong> .</p><p>See external documentation.</p><p><strong></strong> getUniformBlockIndex(Program, UniformBlockName) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>UniformBlockName = string()</p><p>Retrieve the index of a named uniform block</p><p><em>gl:getUniformBlockIndex</em> retrieves the index of a uniform block within <em>Program</em> .</p><p><em>Program</em> must be the name of a program object for which the command <strong>gl:linkProgram/1</strong> must have been called in the past, although it is not required that <strong>gl:linkProgram/1</strong> must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.</p><p><em>UniformBlockName</em> must contain a nul-terminated string specifying the name of the uniform block.</p><p><em>gl:getUniformBlockIndex</em> returns the uniform block index for the uniform block named <em>UniformBlockName</em> of <em>Program</em> . If <em>UniformBlockName</em> does not identify an active uniform block of <em>Program</em> , <em>gl:getUniformBlockIndex</em> returns the special identifier, <em>?GL_INVALID_INDEX</em>. Indices of the active uniform blocks of a program are assigned in consecutive order, beginning with zero.</p><p>See external documentation.</p><p><strong></strong> getActiveUniformBlockiv(Program, UniformBlockIndex, Pname, Params) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>UniformBlockIndex = integer()</p><p>Pname = enum()</p><p>Params = mem()</p><p>Query information about an active uniform block</p><p><em>gl:getActiveUniformBlockiv</em> retrieves information about an active uniform block within <em>Program</em> .</p><p><em>Program</em> must be the name of a program object for which the command <strong>gl:linkProgram/1</strong> must have been called in the past, although it is not required that <strong>gl:linkProgram/1</strong> must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.</p><p><em>UniformBlockIndex</em> is an active uniform block index of <em>Program</em> , and must be less than the value of <em>?GL_ACTIVE_UNIFORM_BLOCKS</em>.</p><p>Upon success, the uniform block parameter(s) specified by <em>Pname</em> are returned in <em>Params</em> . If an error occurs, nothing will be written to <em>Params</em> .</p><p>If <em>Pname</em> is <em>?GL_UNIFORM_BLOCK_BINDING</em>, then the index of the uniform buffer binding point last selected by the uniform block specified by <em>UniformBlockIndex</em> for <em>Program</em> is returned. If no uniform block has been previously specified, zero is returned.</p><p>If <em>Pname</em> is <em>?GL_UNIFORM_BLOCK_DATA_SIZE</em>, then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active uniforms in the uniform block identified by <em>UniformBlockIndex</em> is returned. It is neither guaranteed nor expected that a given implementation will arrange uniform values as tightly packed in a buffer object. The exception to this is the <em>std140 uniform block layout</em> , which guarantees specific packing behavior and does not require the application to query for offsets and strides. In this case the minimum size may still be queried, even though it is determined in advance based only on the uniform block declaration.</p><p>If <em>Pname</em> is <em>?GL_UNIFORM_BLOCK_NAME_LENGTH</em>, then the total length (including the nul terminator) of the name of the uniform block identified by <em>UniformBlockIndex</em> is returned.</p><p>If <em>Pname</em> is <em>?GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS</em>, then the number of active uniforms in the uniform block identified by <em>UniformBlockIndex</em> is returned.</p><p>If <em>Pname</em> is <em>?GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES</em>, then a list of the active uniform indices for the uniform block identified by <em>UniformBlockIndex</em> is returned. The number of elements that will be written to <em>Params</em> is the value of <em>?GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS</em> for <em>UniformBlockIndex</em> .</p><p>If <em>Pname</em> is <em>?GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER</em>, <em>?GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER</em> , or <em>?GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER</em>, then a boolean value indicating whether the uniform block identified by <em>UniformBlockIndex</em> is referenced by the vertex, geometry, or fragment programming stages of program, respectively, is returned.</p><p>See external documentation.</p><p><strong></strong> getActiveUniformBlockName(Program, UniformBlockIndex, BufSize) -&gt; string()</p><p>Types:</p><p>Program = integer()</p><p>UniformBlockIndex = integer()</p><p>BufSize = integer()</p><p>Retrieve the name of an active uniform block</p><p><em>gl:getActiveUniformBlockName</em> retrieves the name of the active uniform block at <em>UniformBlockIndex</em> within <em>Program</em> .</p><p><em>Program</em> must be the name of a program object for which the command <strong>gl:linkProgram/1</strong> must have been called in the past, although it is not required that <strong>gl:linkProgram/1</strong> must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.</p><p><em>UniformBlockIndex</em> is an active uniform block index of <em>Program</em> , and must be less than the value of <em>?GL_ACTIVE_UNIFORM_BLOCKS</em>.</p><p>Upon success, the name of the uniform block identified by <em>UnifomBlockIndex</em> is returned into <em>UniformBlockName</em> . The name is nul-terminated. The actual number of characters written into <em>UniformBlockName</em> , excluding the nul terminator, is returned in <em>Length</em> . If <em>Length</em> is NULL, no length is returned.</p><p><em>BufSize</em> contains the maximum number of characters (including the nul terminator) that will be written into <em>UniformBlockName</em> .</p><p>If an error occurs, nothing will be written to <em>UniformBlockName</em> or <em>Length</em> .</p><p>See external documentation.</p><p><strong></strong> uniformBlockBinding(Program, UniformBlockIndex, UniformBlockBinding) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>UniformBlockIndex = integer()</p><p>UniformBlockBinding = integer()</p><p>Assign a binding point to an active uniform block</p><p>Binding points for active uniform blocks are assigned using <em>gl:uniformBlockBinding</em>. Each of a program's active uniform blocks has a corresponding uniform buffer binding point. <em>Program</em> is the name of a program object for which the command <strong>gl:linkProgram/1</strong> has been issued in the past.</p><p>If successful, <em>gl:uniformBlockBinding</em> specifies that <em>Program</em> will use the data store of the buffer object bound to the binding point <em>UniformBlockBinding</em> to extract the values of the uniforms in the uniform block identified by <em>UniformBlockIndex</em> .</p><p>When a program object is linked or re-linked, the uniform buffer object binding point assigned to each of its active uniform blocks is reset to zero.</p><p>See external documentation.</p><p><strong></strong> copyBufferSubData(ReadTarget, WriteTarget, ReadOffset, WriteOffset, Size) -&gt; ok</p><p>Types:</p><p>ReadTarget = enum()</p><p>WriteTarget = enum()</p><p>ReadOffset = integer()</p><p>WriteOffset = integer()</p><p>Size = integer()</p><p>Copy part of the data store of a buffer object to the data store of another buffer object</p><p><em>gl:copyBufferSubData</em> copies part of the data store attached to <em>Readtarget</em> to the data store attached to <em>Writetarget</em> . The number of basic machine units indicated by <em>Size</em> is copied from the source, at offset <em>Readoffset</em> to the destination at <em>Writeoffset</em> , also in basic machine units.</p><p><em>Readtarget</em> and <em>Writetarget</em> must be <em>?GL_ARRAY_BUFFER</em>, <em>?GL_COPY_READ_BUFFER</em> , <em>?GL_COPY_WRITE_BUFFER</em>, <em>?GL_ELEMENT_ARRAY_BUFFER</em>, <em>?GL_PIXEL_PACK_BUFFER</em> , <em>?GL_PIXEL_UNPACK_BUFFER</em>, <em>?GL_TEXTURE_BUFFER</em>, <em>?GL_TRANSFORM_FEEDBACK_BUFFER</em> or <em>?GL_UNIFORM_BUFFER</em>. Any of these targets may be used, although the targets <em>?GL_COPY_READ_BUFFER</em> and <em>?GL_COPY_WRITE_BUFFER</em> are provided specifically to allow copies between buffers without disturbing other GL state.</p><p><em>Readoffset</em> , <em>Writeoffset</em> and <em>Size</em> must all be greater than or equal to zero. Furthermore, <em>Readoffset</em> + <em>Size</em> must not exceeed the size of the buffer object bound to <em>Readtarget</em> , and <em>Readoffset</em> + <em>Size</em> must not exceeed the size of the buffer bound to <em>Writetarget</em> . If the same buffer object is bound to both <em>Readtarget</em> and <em>Writetarget</em> , then the ranges specified by <em>Readoffset</em> , <em>Writeoffset</em> and <em>Size</em> must not overlap.</p><p>See external documentation.</p><p><strong></strong> drawElementsBaseVertex(Mode, Count, Type, Indices, Basevertex) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Count = integer()</p><p>Type = enum()</p><p>Indices = offset() | mem()</p><p>Basevertex = integer()</p><p>Render primitives from array data with a per-element offset</p><p><em>gl:drawElementsBaseVertex</em> behaves identically to <strong>gl:drawElements/4</strong> except that the <em>i</em>th element transferred by the corresponding draw call will be taken from element <em>Indices</em> [i] + <em>Basevertex</em> of each enabled array. If the resulting value is larger than the maximum value representable by <em>Type</em> , it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.</p><p>See external documentation.</p><p><strong></strong> drawRangeElementsBaseVertex(Mode, Start, End, Count, Type, Indices, Basevertex) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Start = integer()</p><p>End = integer()</p><p>Count = integer()</p><p>Type = enum()</p><p>Indices = offset() | mem()</p><p>Basevertex = integer()</p><p>Render primitives from array data with a per-element offset</p><p><em>gl:drawRangeElementsBaseVertex</em> is a restricted form of <strong>gl:drawElementsBaseVertex/5</strong> . <em>Mode</em> , <em>Start</em> , <em>End</em> , <em>Count</em> and <em>Basevertex</em> match the corresponding arguments to <strong>gl:drawElementsBaseVertex/5</strong> , with the additional constraint that all values in the array <em>Indices</em> must lie between <em>Start</em> and <em>End</em> , inclusive, prior to adding <em>Basevertex</em> . Index values lying outside the range [ <em>Start</em> , <em>End</em> ] are treated in the same way as <strong>gl:drawElementsBaseVertex/5</strong> . The <em>i</em> th element transferred by the corresponding draw call will be taken from element <em>Indices</em> [i] + <em>Basevertex</em> of each enabled array. If the resulting value is larger than the maximum value representable by <em>Type</em> , it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.</p><p>See external documentation.</p><p><strong></strong> drawElementsInstancedBaseVertex(Mode, Count, Type, Indices, Primcount, Basevertex) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Count = integer()</p><p>Type = enum()</p><p>Indices = offset() | mem()</p><p>Primcount = integer()</p><p>Basevertex = integer()</p><p>Render multiple instances of a set of primitives from array data with a per-element offset</p><p><em>gl:drawElementsInstancedBaseVertex</em> behaves identically to <strong>gl:drawElementsInstanced/5</strong> except that the <em>i</em>th element transferred by the corresponding draw call will be taken from element <em>Indices</em> [i] + <em>Basevertex</em> of each enabled array. If the resulting value is larger than the maximum value representable by <em>Type</em> , it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.</p><p>See external documentation.</p><p><strong></strong> provokingVertex(Mode) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Specifiy the vertex to be used as the source of data for flat shaded varyings</p><p><em>Flatshading</em> a vertex shader varying output means to assign all vetices of the primitive the same value for that output. The vertex from which these values is derived is known as the <em>provoking vertex</em> and <em>gl:provokingVertex</em> specifies which vertex is to be used as the source of data for flat shaded varyings.</p><p><em>ProvokeMode</em> must be either <em>?GL_FIRST_VERTEX_CONVENTION</em> or <em>?GL_LAST_VERTEX_CONVENTION</em> , and controls the selection of the vertex whose values are assigned to flatshaded varying outputs. The interpretation of these values for the supported primitive types is:<em>Primitive Type of Polygon</em><em>i</em><em>First Vertex Convention</em><em>Last Vertex Convention</em></p><p> point <em>i</em><em>i</em></p><p> independent line 2<em>i</em> - 1 2<em>i</em></p><p> line loop <em>i</em></p><p><em>i</em> + 1, if <em>i</em> &lt; <em>n</em> 1, if <em>i</em> = <em>n</em></p><p> line strip <em>i</em><em>i</em> + 1</p><p> independent triangle 3<em>i</em> - 2 3<em>i</em></p><p> triangle strip <em>i</em><em>i</em> + 2</p><p> triangle fan <em>i</em> + 1 <em>i</em> + 2</p><p> line adjacency 4<em>i</em> - 2 4<em>i</em> - 1</p><p> line strip adjacency <em>i</em> + 1 <em>i</em> + 2</p><p> triangle adjacency 6<em>i</em> - 5 6<em>i</em> - 1</p><p> triangle strip adjacency 2<em>i</em> - 1 2<em>i</em> + 3</p><p>If a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using the flat qualifier when declaring the output.</p><p>See external documentation.</p><p><strong></strong> fenceSync(Condition, Flags) -&gt; integer()</p><p>Types:</p><p>Condition = enum()</p><p>Flags = integer()</p><p>Create a new sync object and insert it into the GL command stream</p><p><em>gl:fenceSync</em> creates a new fence sync object, inserts a fence command into the GL command stream and associates it with that sync object, and returns a non-zero name corresponding to the sync object.</p><p>When the specified <em>Condition</em> of the sync object is satisfied by the fence command, the sync object is signaled by the GL, causing any <strong>gl:waitSync/3</strong> , <strong>gl:clientWaitSync/3</strong> commands blocking in <em>Sync</em> to <em>unblock</em>. No other state is affected by <em>gl:fenceSync</em> or by the execution of the associated fence command.</p><p><em>Condition</em> must be <em>?GL_SYNC_GPU_COMMANDS_COMPLETE</em>. This condition is satisfied by completion of the fence command corresponding to the sync object and all preceding commands in the same command stream. The sync object will not be signaled until all effects from these commands on GL client and server state and the framebuffer are fully realized. Note that completion of the fence command occurs once the state of the corresponding sync object has been changed, but commands waiting on that sync object may not be unblocked until after the fence command completes.</p><p>See external documentation.</p><p><strong></strong> isSync(Sync) -&gt; 0 | 1</p><p>Types:</p><p>Sync = integer()</p><p>Determine if a name corresponds to a sync object</p><p><em>gl:isSync</em> returns <em>?GL_TRUE</em> if <em>Sync</em> is currently the name of a sync object. If <em>Sync</em> is not the name of a sync object, or if an error occurs, <em>gl:isSync</em> returns <em>?GL_FALSE</em>. Note that zero is not the name of a sync object.</p><p>See external documentation.</p><p><strong></strong> deleteSync(Sync) -&gt; ok</p><p>Types:</p><p>Sync = integer()</p><p>Delete a sync object</p><p><em>gl:deleteSync</em> deletes the sync object specified by <em>Sync</em> . If the fence command corresponding to the specified sync object has completed, or if no <strong>gl:waitSync/3</strong> or <strong>gl:clientWaitSync/3</strong> commands are blocking on <em>Sync</em> , the object is deleted immediately. Otherwise, <em>Sync</em> is flagged for deletion and will be deleted when it is no longer associated with any fence command and is no longer blocking any <strong>gl:waitSync/3</strong> or <strong>gl:clientWaitSync/3</strong> command. In either case, after <em>gl:deleteSync</em> returns, the name <em>Sync</em> is invalid and can no longer be used to refer to the sync object.</p><p><em>gl:deleteSync</em> will silently ignore a <em>Sync</em> value of zero.</p><p>See external documentation.</p><p><strong></strong> clientWaitSync(Sync, Flags, Timeout) -&gt; enum()</p><p>Types:</p><p>Sync = integer()</p><p>Flags = integer()</p><p>Timeout = integer()</p><p>Block and wait for a sync object to become signaled</p><p><em>gl:clientWaitSync</em> causes the client to block and wait for the sync object specified by <em>Sync</em> to become signaled. If <em>Sync</em> is signaled when <em>gl:clientWaitSync</em> is called, <em>gl:clientWaitSync</em> returns immediately, otherwise it will block and wait for up to <em>Timeout</em> nanoseconds for <em>Sync</em> to become signaled.</p><p>The return value is one of four status values:</p><p><em>?GL_ALREADY_SIGNALED</em> indicates that <em>Sync</em> was signaled at the time that <em>gl:clientWaitSync</em> was called.</p><p><em>?GL_TIMEOUT_EXPIRED</em> indicates that at least <em>Timeout</em> nanoseconds passed and <em>Sync</em> did not become signaled.</p><p><em>?GL_CONDITION_SATISFIED</em> indicates that <em>Sync</em> was signaled before the timeout expired.</p><p><em>?GL_WAIT_FAILED</em> indicates that an error occurred. Additionally, an OpenGL error will be generated.</p><p>See external documentation.</p><p><strong></strong> waitSync(Sync, Flags, Timeout) -&gt; ok</p><p>Types:</p><p>Sync = integer()</p><p>Flags = integer()</p><p>Timeout = integer()</p><p>Instruct the GL server to block until the specified sync object becomes signaled</p><p><em>gl:waitSync</em> causes the GL server to block and wait until <em>Sync</em> becomes signaled. <em>Sync</em> is the name of an existing sync object upon which to wait. <em>Flags</em> and <em>Timeout</em> are currently not used and must be set to zero and the special value <em>?GL_TIMEOUT_IGNORED</em> , respectively</p><p><em>Flags</em> and <em>Timeout</em> are placeholders for anticipated future extensions of sync object capabilities. They must have these reserved values in order that existing code calling <em>gl:waitSync</em> operate properly in the presence of such extensions.. <em>gl:waitSync</em> will always wait no longer than an implementation-dependent timeout. The duration of this timeout in nanoseconds may be queried by calling <strong>gl:getBooleanv/1</strong> with the parameter <em>?GL_MAX_SERVER_WAIT_TIMEOUT</em> . There is currently no way to determine whether <em>gl:waitSync</em> unblocked because the timeout expired or because the sync object being waited on was signaled.</p><p>If an error occurs, <em>gl:waitSync</em> does not cause the GL server to block.</p><p>See external documentation.</p><p><strong></strong> getInteger64v(Pname) -&gt; [integer()]</p><p>Types:</p><p>Pname = enum()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> getSynciv(Sync, Pname, BufSize) -&gt; [integer()]</p><p>Types:</p><p>Sync = integer()</p><p>Pname = enum()</p><p>BufSize = integer()</p><p>Query the properties of a sync object</p><p><em>gl:getSynciv</em> retrieves properties of a sync object. <em>Sync</em> specifies the name of the sync object whose properties to retrieve.</p><p>On success, <em>gl:getSynciv</em> replaces up to <em>BufSize</em> integers in <em>Values</em> with the corresponding property values of the object being queried. The actual number of integers replaced is returned in the variable whose address is specified in <em>Length</em> . If <em>Length</em> is NULL, no length is returned.</p><p>If <em>Pname</em> is <em>?GL_OBJECT_TYPE</em>, a single value representing the specific type of the sync object is placed in <em>Values</em> . The only type supported is <em>?GL_SYNC_FENCE</em> .</p><p>If <em>Pname</em> is <em>?GL_SYNC_STATUS</em>, a single value representing the status of the sync object (<em>?GL_SIGNALED</em> or <em>?GL_UNSIGNALED</em>) is placed in <em>Values</em> .</p><p>If <em>Pname</em> is <em>?GL_SYNC_CONDITION</em>, a single value representing the condition of the sync object is placed in <em>Values</em> . The only condition supported is <em>?GL_SYNC_GPU_COMMANDS_COMPLETE</em> .</p><p>If <em>Pname</em> is <em>?GL_SYNC_FLAGS</em>, a single value representing the flags with which the sync object was created is placed in <em>Values</em> . No flags are currently supported</p><p><em>Flags</em> is expected to be used in future extensions to the sync objects..</p><p>If an error occurs, nothing will be written to <em>Values</em> or <em>Length</em> .</p><p>See external documentation.</p><p><strong></strong> texImage2DMultisample(Target, Samples, Internalformat, Width, Height, Fixedsamplelocations) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Samples = integer()</p><p>Internalformat = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Fixedsamplelocations = 0 | 1</p><p>Establish the data storage, format, dimensions, and number of samples of a multisample texture's image</p><p><em>gl:texImage2DMultisample</em> establishes the data storage, format, dimensions and number of samples of a multisample texture's image.</p><p><em>Target</em> must be <em>?GL_TEXTURE_2D_MULTISAMPLE</em> or <em>?GL_PROXY_TEXTURE_2D_MULTISAMPLE</em> . <em>Width</em> and <em>Height</em> are the dimensions in texels of the texture, and must be in the range zero to <em>?GL_MAX_TEXTURE_SIZE</em> - 1. <em>Samples</em> specifies the number of samples in the image and must be in the range zero to <em>?GL_MAX_SAMPLES</em> - 1.</p><p><em>Internalformat</em> must be a color-renderable, depth-renderable, or stencil-renderable format.</p><p>If <em>Fixedsamplelocations</em> is <em>?GL_TRUE</em>, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</p><p>When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.</p><p>See external documentation.</p><p><strong></strong> texImage3DMultisample(Target, Samples, Internalformat, Width, Height, Depth, Fixedsamplelocations) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Samples = integer()</p><p>Internalformat = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Depth = integer()</p><p>Fixedsamplelocations = 0 | 1</p><p>Establish the data storage, format, dimensions, and number of samples of a multisample texture's image</p><p><em>gl:texImage3DMultisample</em> establishes the data storage, format, dimensions and number of samples of a multisample texture's image.</p><p><em>Target</em> must be <em>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</em> or <em>?GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY</em> . <em>Width</em> and <em>Height</em> are the dimensions in texels of the texture, and must be in the range zero to <em>?GL_MAX_TEXTURE_SIZE</em> - 1. <em>Depth</em> is the number of array slices in the array texture's image. <em>Samples</em> specifies the number of samples in the image and must be in the range zero to <em>?GL_MAX_SAMPLES</em> - 1.</p><p><em>Internalformat</em> must be a color-renderable, depth-renderable, or stencil-renderable format.</p><p>If <em>Fixedsamplelocations</em> is <em>?GL_TRUE</em>, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</p><p>When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.</p><p>See external documentation.</p><p><strong></strong> getMultisamplefv(Pname, Index) -&gt; {float(), float()}</p><p>Types:</p><p>Pname = enum()</p><p>Index = integer()</p><p>Retrieve the location of a sample</p><p><em>gl:getMultisamplefv</em> queries the location of a given sample. <em>Pname</em> specifies the sample parameter to retrieve and must be <em>?GL_SAMPLE_POSITION</em>. <em>Index</em> corresponds to the sample for which the location should be returned. The sample location is returned as two floating-point values in <em>Val[0]</em> and <em>Val[1]</em> , each between 0 and 1, corresponding to the <em>X</em> and <em>Y</em> locations respectively in the GL pixel space of that sample. (0.5, 0.5) this corresponds to the pixel center. <em>Index</em> must be between zero and the value of <em>?GL_SAMPLES</em> - 1.</p><p>If the multisample mode does not have fixed sample locations, the returned values may only reflect the locations of samples within some pixels.</p><p>See external documentation.</p><p><strong></strong> sampleMaski(Index, Mask) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>Mask = integer()</p><p>Set the value of a sub-word of the sample mask</p><p><em>gl:sampleMaski</em> sets one 32-bit sub-word of the multi-word sample mask, <em>?GL_SAMPLE_MASK_VALUE</em> .</p><p><em>MaskIndex</em> specifies which 32-bit sub-word of the sample mask to update, and <em>Mask</em> specifies the new value to use for that sub-word. <em>MaskIndex</em> must be less than the value of <em>?GL_MAX_SAMPLE_MASK_WORDS</em>. Bit <em>B</em> of mask word <em>M</em> corresponds to sample 32 x <em>M</em> + <em>B</em>.</p><p>See external documentation.</p><p><strong></strong> namedStringARB(Type, Name, String) -&gt; ok</p><p>Types:</p><p>Type = enum()</p><p>Name = string()</p><p>String = string()</p><p>glNamedStringARB</p><p>See external documentation.</p><p><strong></strong> deleteNamedStringARB(Name) -&gt; ok</p><p>Types:</p><p>Name = string()</p><p>glDeleteNamedStringARB</p><p>See external documentation.</p><p><strong></strong> compileShaderIncludeARB(Shader, Path) -&gt; ok</p><p>Types:</p><p>Shader = integer()</p><p>Path = [string()]</p><p>glCompileShaderIncludeARB</p><p>See external documentation.</p><p><strong></strong> isNamedStringARB(Name) -&gt; 0 | 1</p><p>Types:</p><p>Name = string()</p><p>glIsNamedStringARB</p><p>See external documentation.</p><p><strong></strong> getNamedStringARB(Name, BufSize) -&gt; string()</p><p>Types:</p><p>Name = string()</p><p>BufSize = integer()</p><p>glGetNamedStringARB</p><p>See external documentation.</p><p><strong></strong> getNamedStringivARB(Name, Pname) -&gt; integer()</p><p>Types:</p><p>Name = string()</p><p>Pname = enum()</p><p>glGetNamedStringARB</p><p>See external documentation.</p><p><strong></strong> bindFragDataLocationIndexed(Program, ColorNumber, Index, Name) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>ColorNumber = integer()</p><p>Index = integer()</p><p>Name = string()</p><p>glBindFragDataLocationIndexe</p><p>See external documentation.</p><p><strong></strong> getFragDataIndex(Program, Name) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>Name = string()</p><p>Query the bindings of color indices to user-defined varying out variables</p><p><em>gl:getFragDataIndex</em> returns the index of the fragment color to which the variable <em>Name</em> was bound when the program object <em>Program</em> was last linked. If <em>Name</em> is not a varying out variable of <em>Program</em> , or if an error occurs, -1 will be returned.</p><p>See external documentation.</p><p><strong></strong> genSamplers(Count) -&gt; [integer()]</p><p>Types:</p><p>Count = integer()</p><p>Generate sampler object names</p><p><em>gl:genSamplers</em> returns <em>N</em> sampler object names in <em>Samplers</em> . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to <em>gl:genSamplers</em> .</p><p>Sampler object names returned by a call to <em>gl:genSamplers</em> are not returned by subsequent calls, unless they are first deleted with <strong>gl:deleteSamplers/1</strong> .</p><p>The names returned in <em>Samplers</em> are marked as used, for the purposes of <em>gl:genSamplers</em> only, but they acquire state and type only when they are first bound.</p><p>See external documentation.</p><p><strong></strong> deleteSamplers(Samplers) -&gt; ok</p><p>Types:</p><p>Samplers = [integer()]</p><p>Delete named sampler objects</p><p><em>gl:deleteSamplers</em> deletes <em>N</em> sampler objects named by the elements of the array <em>Ids</em> . After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as though <strong>gl:bindSampler/2</strong> is called with unit set to the unit the sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.</p><p>See external documentation.</p><p><strong></strong> isSampler(Sampler) -&gt; 0 | 1</p><p>Types:</p><p>Sampler = integer()</p><p>Determine if a name corresponds to a sampler object</p><p><em>gl:isSampler</em> returns <em>?GL_TRUE</em> if <em>Id</em> is currently the name of a sampler object. If <em>Id</em> is zero, or is a non-zero value that is not currently the name of a sampler object, or if an error occurs, <em>gl:isSampler</em> returns <em>?GL_FALSE</em>.</p><p>A name returned by <strong>gl:genSamplers/1</strong> , is the name of a sampler object.</p><p>See external documentation.</p><p><strong></strong> bindSampler(Unit, Sampler) -&gt; ok</p><p>Types:</p><p>Unit = integer()</p><p>Sampler = integer()</p><p>Bind a named sampler to a texturing target</p><p><em>gl:bindSampler</em> binds <em>Sampler</em> to the texture unit at index <em>Unit</em> . <em>Sampler</em> must be zero or the name of a sampler object previously returned from a call to <strong>gl:genSamplers/1</strong> . <em>Unit</em> must be less than the value of <em>?GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</em>.</p><p>When a sampler object is bound to a texture unit, its state supersedes that of the texture object bound to that texture unit. If the sampler name zero is bound to a texture unit, the currently bound texture's sampler state becomes active. A single sampler object may be bound to multiple texture units simultaneously.</p><p>See external documentation.</p><p><strong></strong> samplerParameteri(Sampler, Pname, Param) -&gt; ok</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>Param = integer()</p><p>Set sampler parameters</p><p><em>gl:samplerParameter</em> assigns the value or values in <em>Params</em> to the sampler parameter specified as <em>Pname</em> . <em>Sampler</em> specifies the sampler object to be modified, and must be the name of a sampler object previously returned from a call to <strong>gl:genSamplers/1</strong> . The following symbols are accepted in <em>Pname</em> :</p><p><em>?GL_TEXTURE_MIN_FILTER</em>: The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps.</p><p>A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2 n×2 m, there are max(n m)+1 mipmaps. The first mipmap is the original texture, with dimensions 2 n×2 m. Each subsequent mipmap has dimensions 2(k-1)×2(l-1), where 2 k×2 l are the dimensions of the previous mipmap, until either k=0 or l=0. At that point, subsequent mipmaps have dimension 1×2(l-1) or 2(k-1)×1 until the final mipmap, which has dimension 1×1. To define the mipmaps, call <strong>gl:texImage1D/8</strong> , <strong>gl:texImage2D/9</strong> , <strong>gl:texImage3D/10</strong> , <strong>gl:copyTexImage1D/7</strong> , or <strong>gl:copyTexImage2D/8</strong> with the <em>level</em> argument indicating the order of the mipmaps. Level 0 is the original texture; level max(n m) is the final 1×1 mipmap.</p><p><em>Params</em> supplies a function for minifying the texture as one of the following:</p><p><em>?GL_NEAREST</em>: Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.</p><p><em>?GL_LINEAR</em>: Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of <em>?GL_TEXTURE_WRAP_S</em> and <em>?GL_TEXTURE_WRAP_T</em>, and on the exact mapping.</p><p><em>?GL_NEAREST_MIPMAP_NEAREST</em>: Chooses the mipmap that most closely matches the size of the pixel being textured and uses the <em>?GL_NEAREST</em> criterion (the texture element nearest to the center of the pixel) to produce a texture value.</p><p><em>?GL_LINEAR_MIPMAP_NEAREST</em>: Chooses the mipmap that most closely matches the size of the pixel being textured and uses the <em>?GL_LINEAR</em> criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value.</p><p><em>?GL_NEAREST_MIPMAP_LINEAR</em>: Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the <em>?GL_NEAREST</em> criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.</p><p><em>?GL_LINEAR_MIPMAP_LINEAR</em>: Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the <em>?GL_LINEAR</em> criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.</p><p>As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the <em>?GL_NEAREST</em> and <em>?GL_LINEAR</em> minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of <em>?GL_TEXTURE_MIN_FILTER</em> is <em>?GL_NEAREST_MIPMAP_LINEAR</em> .</p><p><em>?GL_TEXTURE_MAG_FILTER</em>: The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either <em>?GL_NEAREST</em> or <em>?GL_LINEAR</em> (see below). <em>?GL_NEAREST</em> is generally faster than <em>?GL_LINEAR</em>, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of <em>?GL_TEXTURE_MAG_FILTER</em> is <em>?GL_LINEAR</em>.</p><p><em>?GL_NEAREST</em>: Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.</p><p><em>?GL_LINEAR</em>: Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of <em>?GL_TEXTURE_WRAP_S</em> and <em>?GL_TEXTURE_WRAP_T</em>, and on the exact mapping.</p><p><em>?GL_TEXTURE_MIN_LOD</em>: Sets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.</p><p><em>?GL_TEXTURE_MAX_LOD</em>: Sets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.</p><p><em>?GL_TEXTURE_WRAP_S</em>: Sets the wrap parameter for texture coordinate s to either <em>?GL_CLAMP_TO_EDGE</em> , <em>?GL_MIRRORED_REPEAT</em>, or <em>?GL_REPEAT</em>. <em>?GL_CLAMP_TO_BORDER</em> causes the s coordinate to be clamped to the range [(-1 2/N) 1+(1 2/N)], where N is the size of the texture in the direction of clamping.<em>?GL_CLAMP_TO_EDGE</em> causes s coordinates to be clamped to the range [(1 2/N) 1-(1 2/N)], where N is the size of the texture in the direction of clamping. <em>?GL_REPEAT</em> causes the integer part of the s coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. <em>?GL_MIRRORED_REPEAT</em> causes the s coordinate to be set to the fractional part of the texture coordinate if the integer part of s is even; if the integer part of s is odd, then the s texture coordinate is set to 1-frac(s), where frac(s) represents the fractional part of s. Initially, <em>?GL_TEXTURE_WRAP_S</em> is set to <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_WRAP_T</em>: Sets the wrap parameter for texture coordinate t to either <em>?GL_CLAMP_TO_EDGE</em> , <em>?GL_MIRRORED_REPEAT</em>, or <em>?GL_REPEAT</em>. See the discussion under <em>?GL_TEXTURE_WRAP_S</em> . Initially, <em>?GL_TEXTURE_WRAP_T</em> is set to <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_WRAP_R</em>: Sets the wrap parameter for texture coordinate r to either <em>?GL_CLAMP_TO_EDGE</em> , <em>?GL_MIRRORED_REPEAT</em>, or <em>?GL_REPEAT</em>. See the discussion under <em>?GL_TEXTURE_WRAP_S</em> . Initially, <em>?GL_TEXTURE_WRAP_R</em> is set to <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_BORDER_COLOR</em>: The data in <em>Params</em> specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of <em>?GL_TEXTURE_BORDER_COLOR</em> are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of <em>?GL_TEXTURE_BORDER_COLOR</em> is interpreted as a depth value. The initial value is (0.0, 0.0, 0.0, 0.0).</p><p><em>?GL_TEXTURE_COMPARE_MODE</em>: Specifies the texture comparison mode for currently bound textures. That is, a texture whose internal format is <em>?GL_DEPTH_COMPONENT_*</em>; see <strong>gl:texImage2D/9</strong> ) Permissible values are:</p><p><em>?GL_COMPARE_REF_TO_TEXTURE</em>: Specifies that the interpolated and clamped r texture coordinate should be compared to the value in the currently bound texture. See the discussion of <em>?GL_TEXTURE_COMPARE_FUNC</em> for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.</p><p><em>?GL_NONE</em>: Specifies that the red channel should be assigned the appropriate value from the currently bound texture.</p><p><em>?GL_TEXTURE_COMPARE_FUNC</em>: Specifies the comparison operator used when <em>?GL_TEXTURE_COMPARE_MODE</em> is set to <em>?GL_COMPARE_REF_TO_TEXTURE</em>. Permissible values are:<em>Texture Comparison Function</em><em>Computed result</em></p><p><em>?GL_LEQUAL</em> result={1.0 0.0 r&lt;=(D t) r&gt;(D t))</p><p><em>?GL_GEQUAL</em> result={1.0 0.0 r&gt;=(D t) r&lt;(D t))</p><p><em>?GL_LESS</em> result={1.0 0.0 r&lt;(D t) r&gt;=(D t))</p><p><em>?GL_GREATER</em> result={1.0 0.0 r&gt;(D t) r&lt;=(D t))</p><p><em>?GL_EQUAL</em> result={1.0 0.0 r=(D t) r&ne; (D t))</p><p><em>?GL_NOTEQUAL</em> result={1.0 0.0 r&ne;(D t) r=(D t))</p><p><em>?GL_ALWAYS</em> result=1.0</p><p><em>?GL_NEVER</em> result=0.0</p><p>where r is the current interpolated texture coordinate, and D t is the texture value sampled from the currently bound texture. result is assigned to R t.</p><p>See external documentation.</p><p><strong></strong> samplerParameteriv(Sampler, Pname, Param) -&gt; ok</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>Param = [integer()]</p><p>See <strong>samplerParameteri/3</strong></p><p><strong></strong> samplerParameterf(Sampler, Pname, Param) -&gt; ok</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>Param = float()</p><p>See <strong>samplerParameteri/3</strong></p><p><strong></strong> samplerParameterfv(Sampler, Pname, Param) -&gt; ok</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>Param = [float()]</p><p>See <strong>samplerParameteri/3</strong></p><p><strong></strong> samplerParameterIiv(Sampler, Pname, Param) -&gt; ok</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>Param = [integer()]</p><p>See <strong>samplerParameteri/3</strong></p><p><strong></strong> samplerParameterIuiv(Sampler, Pname, Param) -&gt; ok</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>Param = [integer()]</p><p>glSamplerParameterI</p><p>See external documentation.</p><p><strong></strong> getSamplerParameteriv(Sampler, Pname) -&gt; [integer()]</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>Return sampler parameter values</p><p><em>gl:getSamplerParameter</em> returns in <em>Params</em> the value or values of the sampler parameter specified as <em>Pname</em> . <em>Sampler</em> defines the target sampler, and must be the name of an existing sampler object, returned from a previous call to <strong>gl:genSamplers/1</strong> . <em>Pname</em> accepts the same symbols as <strong>gl:samplerParameteri/3</strong> , with the same interpretations:</p><p><em>?GL_TEXTURE_MAG_FILTER</em>: Returns the single-valued texture magnification filter, a symbolic constant. The initial value is <em>?GL_LINEAR</em>.</p><p><em>?GL_TEXTURE_MIN_FILTER</em>: Returns the single-valued texture minification filter, a symbolic constant. The initial value is <em>?GL_NEAREST_MIPMAP_LINEAR</em>.</p><p><em>?GL_TEXTURE_MIN_LOD</em>: Returns the single-valued texture minimum level-of-detail value. The initial value is -1000.</p><p><em>?GL_TEXTURE_MAX_LOD</em>: Returns the single-valued texture maximum level-of-detail value. The initial value is 1000.</p><p><em>?GL_TEXTURE_WRAP_S</em>: Returns the single-valued wrapping function for texture coordinate s, a symbolic constant. The initial value is <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_WRAP_T</em>: Returns the single-valued wrapping function for texture coordinate t, a symbolic constant. The initial value is <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_WRAP_R</em>: Returns the single-valued wrapping function for texture coordinate r, a symbolic constant. The initial value is <em>?GL_REPEAT</em>.</p><p><em>?GL_TEXTURE_BORDER_COLOR</em>: Returns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range [0 1]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and -1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).</p><p><em>?GL_TEXTURE_COMPARE_MODE</em>: Returns a single-valued texture comparison mode, a symbolic constant. The initial value is <em>?GL_NONE</em>. See <strong>gl:samplerParameteri/3</strong> .</p><p><em>?GL_TEXTURE_COMPARE_FUNC</em>: Returns a single-valued texture comparison function, a symbolic constant. The initial value is <em>?GL_LEQUAL</em>. See <strong>gl:samplerParameteri/3</strong> .</p><p>See external documentation.</p><p><strong></strong> getSamplerParameterIiv(Sampler, Pname) -&gt; [integer()]</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>See <strong>getSamplerParameteriv/2</strong></p><p><strong></strong> getSamplerParameterfv(Sampler, Pname) -&gt; [float()]</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>See <strong>getSamplerParameteriv/2</strong></p><p><strong></strong> getSamplerParameterIuiv(Sampler, Pname) -&gt; [integer()]</p><p>Types:</p><p>Sampler = integer()</p><p>Pname = enum()</p><p>glGetSamplerParameterI</p><p>See external documentation.</p><p><strong></strong> queryCounter(Id, Target) -&gt; ok</p><p>Types:</p><p>Id = integer()</p><p>Target = enum()</p><p>Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.</p><p><em>gl:queryCounter</em> causes the GL to record the current time into the query object named <em>Id</em> . <em>Target</em> must be <em>?GL_TIMESTAMP</em>. The time is recorded after all previous commands on the GL client and server state and the framebuffer have been fully realized. When the time is recorded, the query result for that object is marked available. <em>gl:queryCounter</em> timer queries can be used within a <strong>gl:beginQuery/2</strong> / <strong>gl:beginQuery/2</strong> block where the target is <em>?GL_TIME_ELAPSED</em> and it does not affect the result of that query object.</p><p>See external documentation.</p><p><strong></strong> getQueryObjecti64v(Id, Pname) -&gt; integer()</p><p>Types:</p><p>Id = integer()</p><p>Pname = enum()</p><p>glGetQueryObjecti64v</p><p>See external documentation.</p><p><strong></strong> getQueryObjectui64v(Id, Pname) -&gt; integer()</p><p>Types:</p><p>Id = integer()</p><p>Pname = enum()</p><p>glGetQueryObjectui64v</p><p>See external documentation.</p><p><strong></strong> drawArraysIndirect(Mode, Indirect) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Indirect = offset() | mem()</p><p>Render primitives from array data, taking parameters from memory</p><p><em>gl:drawArraysIndirect</em> specifies multiple geometric primitives with very few subroutine calls. <em>gl:drawArraysIndirect</em> behaves similarly to <strong>gl:drawArraysInstancedBaseInstance/5</strong> , execept that the parameters to <strong>gl:drawArraysInstancedBaseInstance/5</strong> are stored in memory at the address given by <em>Indirect</em> .</p><p>The parameters addressed by <em>Indirect</em> are packed into a structure that takes the form (in C): typedef struct { uint count; uint primCount; uint first; uint baseInstance; } DrawArraysIndirectCommand; const DrawArraysIndirectCommand *cmd = (const DrawArraysIndirectCommand *)indirect; glDrawArraysInstancedBaseInstance(mode, cmd-&gt;first, cmd-&gt;count, cmd-&gt;primCount, cmd-&gt;baseInstance);</p><p>If a buffer is bound to the <em>?GL_DRAW_INDIRECT_BUFFER</em> binding at the time of a call to <em>gl:drawArraysIndirect</em>, <em>Indirect</em> is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.</p><p>In contrast to <strong>gl:drawArraysInstancedBaseInstance/5</strong> , the first member of the parameter structure is unsigned, and out-of-range indices do not generate an error.</p><p>Vertex attributes that are modified by <em>gl:drawArraysIndirect</em> have an unspecified value after <em>gl:drawArraysIndirect</em> returns. Attributes that aren't modified remain well defined.</p><p>See external documentation.</p><p><strong></strong> drawElementsIndirect(Mode, Type, Indirect) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Type = enum()</p><p>Indirect = offset() | mem()</p><p>Render indexed primitives from array data, taking parameters from memory</p><p><em>gl:drawElementsIndirect</em> specifies multiple indexed geometric primitives with very few subroutine calls. <em>gl:drawElementsIndirect</em> behaves similarly to <strong>gl:drawElementsInstancedBaseVertexBaseInstance/7</strong> , execpt that the parameters to <strong>gl:drawElementsInstancedBaseVertexBaseInstance/7</strong> are stored in memory at the address given by <em>Indirect</em> .</p><p>The parameters addressed by <em>Indirect</em> are packed into a structure that takes the form (in C): typedef struct { uint count; uint primCount; uint firstIndex; uint baseVertex; uint baseInstance; } DrawElementsIndirectCommand;</p><p><em>gl:drawElementsIndirect</em> is equivalent to: void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect) { const DrawElementsIndirectCommand *cmd = (const DrawElementsIndirectCommand *)indirect; glDrawElementsInstancedBaseVertexBaseInstance(mode, cmd-&gt;count, type, cmd-&gt;firstIndex + size-of-type, cmd-&gt;primCount, cmd-&gt;baseVertex, cmd-&gt;baseInstance); }</p><p>If a buffer is bound to the <em>?GL_DRAW_INDIRECT_BUFFER</em> binding at the time of a call to <em>gl:drawElementsIndirect</em>, <em>Indirect</em> is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.</p><p>Note that indices stored in client memory are not supported. If no buffer is bound to the <em>?GL_ELEMENT_ARRAY_BUFFER</em> binding, an error will be generated.</p><p>The results of the operation are undefined if the reservedMustBeZero member of the parameter structure is non-zero. However, no error is generated in this case.</p><p>Vertex attributes that are modified by <em>gl:drawElementsIndirect</em> have an unspecified value after <em>gl:drawElementsIndirect</em> returns. Attributes that aren't modified remain well defined.</p><p>See external documentation.</p><p><strong></strong> uniform1d(Location, X) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>X = float()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform2d(Location, X, Y) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>X = float()</p><p>Y = float()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform3d(Location, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform4d(Location, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform1dv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [float()]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform2dv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform3dv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniform4dv(Location, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Value = [{float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix2dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix3dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix4dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix2x3dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix2x4dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix3x2dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix3x4dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix4x2dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> uniformMatrix4x3dv(Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>uniform1f/2</strong></p><p><strong></strong> getUniformdv(Program, Location) -&gt; matrix()</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>See <strong>getUniformfv/2</strong></p><p><strong></strong> getSubroutineUniformLocation(Program, Shadertype, Name) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>Shadertype = enum()</p><p>Name = string()</p><p>Retrieve the location of a subroutine uniform of a given shader stage within a program</p><p><em>gl:getSubroutineUniformLocation</em> returns the location of the subroutine uniform variable <em>Name</em> in the shader stage of type <em>Shadertype</em> attached to <em>Program</em> , with behavior otherwise identical to <strong>gl:getUniformLocation/2</strong> .</p><p>If <em>Name</em> is not the name of a subroutine uniform in the shader stage, -1 is returned, but no error is generated. If <em>Name</em> is the name of a subroutine uniform in the shader stage, a value between zero and the value of <em>?GL_ACTIVE_SUBROUTINE_LOCATIONS</em> minus one will be returned. Subroutine locations are assigned using consecutive integers in the range from zero to the value of <em>?GL_ACTIVE_SUBROUTINE_LOCATIONS</em> minus one for the shader stage. For active subroutine uniforms declared as arrays, the declared array elements are assigned consecutive locations.</p><p>See external documentation.</p><p><strong></strong> getSubroutineIndex(Program, Shadertype, Name) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>Shadertype = enum()</p><p>Name = string()</p><p>Retrieve the index of a subroutine uniform of a given shader stage within a program</p><p><em>gl:getSubroutineIndex</em> returns the index of a subroutine uniform within a shader stage attached to a program object. <em>Program</em> contains the name of the program to which the shader is attached. <em>Shadertype</em> specifies the stage from which to query shader subroutine index. <em>Name</em> contains the null-terminated name of the subroutine uniform whose name to query.</p><p>If <em>Name</em> is not the name of a subroutine uniform in the shader stage, <em>?GL_INVALID_INDEX</em> is returned, but no error is generated. If <em>Name</em> is the name of a subroutine uniform in the shader stage, a value between zero and the value of <em>?GL_ACTIVE_SUBROUTINES</em> minus one will be returned. Subroutine indices are assigned using consecutive integers in the range from zero to the value of <em>?GL_ACTIVE_SUBROUTINES</em> minus one for the shader stage.</p><p>See external documentation.</p><p><strong></strong> getActiveSubroutineUniformName(Program, Shadertype, Index, Bufsize) -&gt; string()</p><p>Types:</p><p>Program = integer()</p><p>Shadertype = enum()</p><p>Index = integer()</p><p>Bufsize = integer()</p><p>Query the name of an active shader subroutine uniform</p><p><em>gl:getActiveSubroutineUniformName</em> retrieves the name of an active shader subroutine uniform. <em>Program</em> contains the name of the program containing the uniform. <em>Shadertype</em> specifies the stage for which which the uniform location, given by <em>Index</em> , is valid. <em>Index</em> must be between zero and the value of <em>?GL_ACTIVE_SUBROUTINE_UNIFORMS</em> minus one for the shader stage.</p><p>The uniform name is returned as a null-terminated string in <em>Name</em> . The actual number of characters written into <em>Name</em> , excluding the null terminator is returned in <em>Length</em> . If <em>Length</em> is <em>?NULL</em>, no length is returned. The maximum number of characters that may be written into <em>Name</em> , including the null terminator, is specified by <em>Bufsize</em> . The length of the longest subroutine uniform name in <em>Program</em> and <em>Shadertype</em> is given by the value of <em>?GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH</em>, which can be queried with <strong>gl:getProgramStageiv/3</strong> .</p><p>See external documentation.</p><p><strong></strong> getActiveSubroutineName(Program, Shadertype, Index, Bufsize) -&gt; string()</p><p>Types:</p><p>Program = integer()</p><p>Shadertype = enum()</p><p>Index = integer()</p><p>Bufsize = integer()</p><p>Query the name of an active shader subroutine</p><p><em>gl:getActiveSubroutineName</em> queries the name of an active shader subroutine uniform from the program object given in <em>Program</em> . <em>Index</em> specifies the index of the shader subroutine uniform within the shader stage given by <em>Stage</em> , and must between zero and the value of <em>?GL_ACTIVE_SUBROUTINES</em> minus one for the shader stage.</p><p>The name of the selected subroutine is returned as a null-terminated string in <em>Name</em> . The actual number of characters written into <em>Name</em> , not including the null-terminator, is is returned in <em>Length</em> . If <em>Length</em> is <em>?NULL</em>, no length is returned. The maximum number of characters that may be written into <em>Name</em> , including the null-terminator, is given in <em>Bufsize</em> .</p><p>See external documentation.</p><p><strong></strong> uniformSubroutinesuiv(Shadertype, Indices) -&gt; ok</p><p>Types:</p><p>Shadertype = enum()</p><p>Indices = [integer()]</p><p>Load active subroutine uniforms</p><p><em>gl:uniformSubroutines</em> loads all active subroutine uniforms for shader stage <em>Shadertype</em> of the current program with subroutine indices from <em>Indices</em> , storing <em>Indices[i]</em> into the uniform at location <em>I</em> . <em>Count</em> must be equal to the value of <em>?GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS</em> for the program currently in use at shader stage <em>Shadertype</em> . Furthermore, all values in <em>Indices</em> must be less than the value of <em>?GL_ACTIVE_SUBROUTINES</em> for the shader stage.</p><p>See external documentation.</p><p><strong></strong> getUniformSubroutineuiv(Shadertype, Location) -&gt; {integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer()}</p><p>Types:</p><p>Shadertype = enum()</p><p>Location = integer()</p><p>Retrieve the value of a subroutine uniform of a given shader stage of the current program</p><p><em>gl:getUniformSubroutine</em> retrieves the value of the subroutine uniform at location <em>Location</em> for shader stage <em>Shadertype</em> of the current program. <em>Location</em> must be less than the value of <em>?GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS</em> for the shader currently in use at shader stage <em>Shadertype</em> . The value of the subroutine uniform is returned in <em>Values</em> .</p><p>See external documentation.</p><p><strong></strong> getProgramStageiv(Program, Shadertype, Pname) -&gt; integer()</p><p>Types:</p><p>Program = integer()</p><p>Shadertype = enum()</p><p>Pname = enum()</p><p>Retrieve properties of a program object corresponding to a specified shader stage</p><p><em>gl:getProgramStage</em> queries a parameter of a shader stage attached to a program object. <em>Program</em> contains the name of the program to which the shader is attached. <em>Shadertype</em> specifies the stage from which to query the parameter. <em>Pname</em> specifies which parameter should be queried. The value or values of the parameter to be queried is returned in the variable whose address is given in <em>Values</em> .</p><p>If <em>Pname</em> is <em>?GL_ACTIVE_SUBROUTINE_UNIFORMS</em>, the number of active subroutine variables in the stage is returned in <em>Values</em> .</p><p>If <em>Pname</em> is <em>?GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS</em>, the number of active subroutine variable locations in the stage is returned in <em>Values</em> .</p><p>If <em>Pname</em> is <em>?GL_ACTIVE_SUBROUTINES</em>, the number of active subroutines in the stage is returned in <em>Values</em> .</p><p>If <em>Pname</em> is <em>?GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH</em>, the length of the longest subroutine uniform for the stage is returned in <em>Values</em> .</p><p>If <em>Pname</em> is <em>?GL_ACTIVE_SUBROUTINE_MAX_LENGTH</em>, the length of the longest subroutine name for the stage is returned in <em>Values</em> . The returned name length includes space for the null-terminator.</p><p>If there is no shader present of type <em>Shadertype</em> , the returned value will be consistent with a shader containing no subroutines or subroutine uniforms.</p><p>See external documentation.</p><p><strong></strong> patchParameteri(Pname, Value) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Value = integer()</p><p>Specifies the parameters for patch primitives</p><p><em>gl:patchParameter</em> specifies the parameters that will be used for patch primitives. <em>Pname</em> specifies the parameter to modify and must be either <em>?GL_PATCH_VERTICES</em>, <em>?GL_PATCH_DEFAULT_OUTER_LEVEL</em> or <em>?GL_PATCH_DEFAULT_INNER_LEVEL</em>. For <em>gl:patchParameteri</em>, <em>Value</em> specifies the new value for the parameter specified by <em>Pname</em> . For <em>gl:patchParameterfv</em>, <em>Values</em> specifies the address of an array containing the new values for the parameter specified by <em>Pname</em> .</p><p>When <em>Pname</em> is <em>?GL_PATCH_VERTICES</em>, <em>Value</em> specifies the number of vertices that will be used to make up a single patch primitive. Patch primitives are consumed by the tessellation control shader (if present) and subsequently used for tessellation. When primitives are specified using <strong>gl:drawArrays/3</strong> or a similar function, each patch will be made from <em>Parameter</em> control points, each represented by a vertex taken from the enabeld vertex arrays. <em>Parameter</em> must be greater than zero, and less than or equal to the value of <em>?GL_MAX_PATCH_VERTICES</em>.</p><p>When <em>Pname</em> is <em>?GL_PATCH_DEFAULT_OUTER_LEVEL</em> or <em>?GL_PATCH_DEFAULT_INNER_LEVEL</em> , <em>Values</em> contains the address of an array contiaining the default outer or inner tessellation levels, respectively, to be used when no tessellation control shader is present.</p><p>See external documentation.</p><p><strong></strong> patchParameterfv(Pname, Values) -&gt; ok</p><p>Types:</p><p>Pname = enum()</p><p>Values = [float()]</p><p>See <strong>patchParameteri/2</strong></p><p><strong></strong> bindTransformFeedback(Target, Id) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Id = integer()</p><p>Bind a transform feedback object</p><p><em>gl:bindTransformFeedback</em> binds the transform feedback object with name <em>Id</em> to the current GL state. <em>Id</em> must be a name previously returned from a call to <strong>gl:genTransformFeedbacks/1</strong> . If <em>Id</em> has not previously been bound, a new transform feedback object with name <em>Id</em> and initialized with with the default transform state vector is created.</p><p>In the initial state, a default transform feedback object is bound and treated as a transform feedback object with a name of zero. If the name zero is subsequently bound, the default transform feedback object is again bound to the GL state.</p><p>While a transform feedback buffer object is bound, GL operations on the target to which it is bound affect the bound transform feedback object, and queries of the target to which a transform feedback object is bound return state from the bound object. When buffer objects are bound for transform feedback, they are attached to the currently bound transform feedback object. Buffer objects are used for trans- form feedback only if they are attached to the currently bound transform feedback object.</p><p>See external documentation.</p><p><strong></strong> deleteTransformFeedbacks(Ids) -&gt; ok</p><p>Types:</p><p>Ids = [integer()]</p><p>Delete transform feedback objects</p><p><em>gl:deleteTransformFeedbacks</em> deletes the <em>N</em> transform feedback objects whose names are stored in the array <em>Ids</em> . Unused names in <em>Ids</em> are ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but the underlying object is not deleted until it is no longer active.</p><p>See external documentation.</p><p><strong></strong> genTransformFeedbacks(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>Reserve transform feedback object names</p><p><em>gl:genTransformFeedbacks</em> returns <em>N</em> previously unused transform feedback object names in <em>Ids</em> . These names are marked as used, for the purposes of <em>gl:genTransformFeedbacks</em> only, but they acquire transform feedback state only when they are first bound.</p><p>See external documentation.</p><p><strong></strong> isTransformFeedback(Id) -&gt; 0 | 1</p><p>Types:</p><p>Id = integer()</p><p>Determine if a name corresponds to a transform feedback object</p><p><em>gl:isTransformFeedback</em> returns <em>?GL_TRUE</em> if <em>Id</em> is currently the name of a transform feedback object. If <em>Id</em> is zero, or if <em>?id</em> is not the name of a transform feedback object, or if an error occurs, <em>gl:isTransformFeedback</em> returns <em>?GL_FALSE</em>. If <em>Id</em> is a name returned by <strong>gl:genTransformFeedbacks/1</strong> , but that has not yet been bound through a call to <strong>gl:bindTransformFeedback/2</strong> , then the name is not a transform feedback object and <em>gl:isTransformFeedback</em> returns <em>?GL_FALSE</em> .</p><p>See external documentation.</p><p><strong></strong> pauseTransformFeedback() -&gt; ok</p><p>Pause transform feedback operations</p><p><em>gl:pauseTransformFeedback</em> pauses transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.</p><p>See external documentation.</p><p><strong></strong> resumeTransformFeedback() -&gt; ok</p><p>Resume transform feedback operations</p><p><em>gl:resumeTransformFeedback</em> resumes transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.</p><p>See external documentation.</p><p><strong></strong> drawTransformFeedback(Mode, Id) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Id = integer()</p><p>Render primitives using a count derived from a transform feedback object</p><p><em>gl:drawTransformFeedback</em> draws primitives of a type specified by <em>Mode</em> using a count retrieved from the transform feedback specified by <em>Id</em> . Calling <em>gl:drawTransformFeedback</em> is equivalent to calling <strong>gl:drawArrays/3</strong> with <em>Mode</em> as specified, <em>First</em> set to zero, and <em>Count</em> set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by <em>Id</em> .</p><p>See external documentation.</p><p><strong></strong> drawTransformFeedbackStream(Mode, Id, Stream) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Id = integer()</p><p>Stream = integer()</p><p>Render primitives using a count derived from a specifed stream of a transform feedback object</p><p><em>gl:drawTransformFeedbackStream</em> draws primitives of a type specified by <em>Mode</em> using a count retrieved from the transform feedback stream specified by <em>Stream</em> of the transform feedback object specified by <em>Id</em> . Calling <em>gl:drawTransformFeedbackStream</em> is equivalent to calling <strong>gl:drawArrays/3</strong> with <em>Mode</em> as specified, <em>First</em> set to zero, and <em>Count</em> set to the number of vertices captured on vertex stream <em>Stream</em> the last time transform feedback was active on the transform feedback object named by <em>Id</em> .</p><p>Calling <strong>gl:drawTransformFeedback/2</strong> is equivalent to calling <em>gl:drawTransformFeedbackStream</em> with <em>Stream</em> set to zero.</p><p>See external documentation.</p><p><strong></strong> beginQueryIndexed(Target, Index, Id) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Id = integer()</p><p>glBeginQueryIndexe</p><p>See external documentation.</p><p><strong></strong> endQueryIndexed(Target, Index) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Delimit the boundaries of a query object on an indexed target</p><p><em>gl:beginQueryIndexed</em> and <strong>gl:endQueryIndexed/2</strong> delimit the boundaries of a query object. <em>Query</em> must be a name previously returned from a call to <strong>gl:genQueries/1</strong> . If a query object with name <em>Id</em> does not yet exist it is created with the type determined by <em>Target</em> . <em>Target</em> must be one of <em>?GL_SAMPLES_PASSED</em>, <em>?GL_ANY_SAMPLES_PASSED</em> , <em>?GL_PRIMITIVES_GENERATED</em>, <em>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</em>, or <em>?GL_TIME_ELAPSED</em> . The behavior of the query object depends on its type and is as follows.</p><p><em>Index</em> specifies the index of the query target and must be between a <em>Target</em> -specific maximum.</p><p>If <em>Target</em> is <em>?GL_SAMPLES_PASSED</em>, <em>Id</em> must be an unused name, or the name of an existing occlusion query object. When <em>gl:beginQueryIndexed</em> is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes the depth test. If the value of <em>?GL_SAMPLE_BUFFERS</em> is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of <em>?GL_SAMPLE_BUFFERS</em> is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of <em>?GL_SAMPLES</em> if any sample in the fragment is covered. When <em>gl:endQueryIndexed</em> is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>. When <em>Target</em> is <em>?GL_SAMPLES_PASSED</em>, <em>Index</em> must be zero.</p><p>If <em>Target</em> is <em>?GL_ANY_SAMPLES_PASSED</em>, <em>Id</em> must be an unused name, or the name of an existing boolean occlusion query object. When <em>gl:beginQueryIndexed</em> is executed, the query object's samples-passed flag is reset to <em>?GL_FALSE</em>. Subsequent rendering causes the flag to be set to <em>?GL_TRUE</em> if any sample passes the depth test. When <em>gl:endQueryIndexed</em> is executed, the samples-passed flag is assigned to the query object's result value. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>. When <em>Target</em> is <em>?GL_ANY_SAMPLES_PASSED</em> , <em>Index</em> must be zero.</p><p>If <em>Target</em> is <em>?GL_PRIMITIVES_GENERATED</em>, <em>Id</em> must be an unused name, or the name of an existing primitive query object previously bound to the <em>?GL_PRIMITIVES_GENERATED</em> query binding. When <em>gl:beginQueryIndexed</em> is executed, the query object's primitives-generated counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader to the stream given by <em>Index</em> , or from the vertex shader if <em>Index</em> is zero and no geometry shader is present. When <em>gl:endQueryIndexed</em> is executed, the primitives-generated counter for stream <em>Index</em> is assigned to the query object's result value. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>. When <em>Target</em> is <em>?GL_PRIMITIVES_GENERATED</em> , <em>Index</em> must be less than the value of <em>?GL_MAX_VERTEX_STREAMS</em>.</p><p>If <em>Target</em> is <em>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</em>, <em>Id</em> must be an unused name, or the name of an existing primitive query object previously bound to the <em>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</em> query binding. When <em>gl:beginQueryIndexed</em> is executed, the query object's primitives-written counter for the stream specified by <em>Index</em> is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s) for stream <em>Index</em> . If transform feedback mode is not activated between the call to <em>gl:beginQueryIndexed</em> and <em>gl:endQueryIndexed</em>, the counter will not be incremented. When <em>gl:endQueryIndexed</em> is executed, the primitives-written counter for stream <em>Index</em> is assigned to the query object's result value. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>. When <em>Target</em> is <em>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</em> , <em>Index</em> must be less than the value of <em>?GL_MAX_VERTEX_STREAMS</em>.</p><p>If <em>Target</em> is <em>?GL_TIME_ELAPSED</em>, <em>Id</em> must be an unused name, or the name of an existing timer query object previously bound to the <em>?GL_TIME_ELAPSED</em> query binding. When <em>gl:beginQueryIndexed</em> is executed, the query object's time counter is reset to 0. When <em>gl:endQueryIndexed</em> is executed, the elapsed server time that has passed since the call to <em>gl:beginQueryIndexed</em> is written into the query object's time counter. This value can be queried by calling <strong>gl:getQueryObjectiv/2</strong> with <em>Pname</em> <em>?GL_QUERY_RESULT</em>. When <em>Target</em> is <em>?GL_TIME_ELAPSED</em>, <em>Index</em> must be zero.</p><p>Querying the <em>?GL_QUERY_RESULT</em> implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. <em>?GL_QUERY_RESULT_AVAILABLE</em> can be queried to determine if the result is immediately available or if the rendering is not yet complete.</p><p>See external documentation.</p><p><strong></strong> getQueryIndexediv(Target, Index, Pname) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>Pname = enum()</p><p>Return parameters of an indexed query object target</p><p><em>gl:getQueryIndexediv</em> returns in <em>Params</em> a selected parameter of the indexed query object target specified by <em>Target</em> and <em>Index</em> . <em>Index</em> specifies the index of the query object target and must be between zero and a target-specific maxiumum.</p><p><em>Pname</em> names a specific query object target parameter. When <em>Pname</em> is <em>?GL_CURRENT_QUERY</em> , the name of the currently active query for the specified <em>Index</em> of <em>Target</em> , or zero if no query is active, will be placed in <em>Params</em> . If <em>Pname</em> is <em>?GL_QUERY_COUNTER_BITS</em> , the implementation-dependent number of bits used to hold the result of queries for <em>Target</em> is returned in <em>Params</em> .</p><p>See external documentation.</p><p><strong></strong> releaseShaderCompiler() -&gt; ok</p><p>Release resources consumed by the implementation's shader compiler</p><p><em>gl:releaseShaderCompiler</em> provides a hint to the implementation that it may free internal resources associated with its shader compiler. <strong>gl:compileShader/1</strong> may subsequently be called and the implementation may at that time reallocate resources previously freed by the call to <em>gl:releaseShaderCompiler</em>.</p><p>See external documentation.</p><p><strong></strong> shaderBinary(Shaders, Binaryformat, Binary) -&gt; ok</p><p>Types:</p><p>Shaders = [integer()]</p><p>Binaryformat = enum()</p><p>Binary = binary()</p><p>Load pre-compiled shader binaries</p><p><em>gl:shaderBinary</em> loads pre-compiled shader binary code into the <em>Count</em> shader objects whose handles are given in <em>Shaders</em> . <em>Binary</em> points to <em>Length</em> bytes of binary shader code stored in client memory. <em>BinaryFormat</em> specifies the format of the pre-compiled code.</p><p>The binary image contained in <em>Binary</em> will be decoded according to the extension specification defining the specified <em>BinaryFormat</em> token. OpenGL does not define any specific binary formats, but it does provide a mechanism to obtain token vaues for such formats provided by such extensions.</p><p>Depending on the types of the shader objects in <em>Shaders</em> , <em>gl:shaderBinary</em> will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized pair of vertex and fragment shaders stored in the same binary.</p><p>See external documentation.</p><p><strong></strong> getShaderPrecisionFormat(Shadertype, Precisiontype) -&gt; {Range::{integer(), integer()}, Precision::integer()}</p><p>Types:</p><p>Shadertype = enum()</p><p>Precisiontype = enum()</p><p>Retrieve the range and precision for numeric formats supported by the shader compiler</p><p><em>gl:getShaderPrecisionFormat</em> retrieves the numeric range and precision for the implementation's representation of quantities in different numeric formats in specified shader type. <em>ShaderType</em> specifies the type of shader for which the numeric precision and range is to be retrieved and must be one of <em>?GL_VERTEX_SHADER</em> or <em>?GL_FRAGMENT_SHADER</em>. <em>PrecisionType</em> specifies the numeric format to query and must be one of <em>?GL_LOW_FLOAT</em>, <em>?GL_MEDIUM_FLOAT</em> <em>?GL_HIGH_FLOAT</em>, <em>?GL_LOW_INT</em>, <em>?GL_MEDIUM_INT</em>, or <em>?GL_HIGH_INT</em>.</p><p><em>Range</em> points to an array of two integers into which the format's numeric range will be returned. If min and max are the smallest values representable in the format, then the values returned are defined to be: <em>Range</em> [0] = floor(log2(|min|)) and <em>Range</em> [1] = floor(log2(|max|)).</p><p><em>Precision</em> specifies the address of an integer into which will be written the log2 value of the number of bits of precision of the format. If the smallest representable value greater than 1 is 1 + <em>eps</em>, then the integer addressed by <em>Precision</em> will contain floor(-log2(eps)).</p><p>See external documentation.</p><p><strong></strong> depthRangef(N, F) -&gt; ok</p><p>Types:</p><p>N = clamp()</p><p>F = clamp()</p><p>See <strong>depthRange/2</strong></p><p><strong></strong> clearDepthf(D) -&gt; ok</p><p>Types:</p><p>D = clamp()</p><p>glClearDepthf</p><p>See external documentation.</p><p><strong></strong> getProgramBinary(Program, BufSize) -&gt; {BinaryFormat::enum(), Binary::binary()}</p><p>Types:</p><p>Program = integer()</p><p>BufSize = integer()</p><p>Return a binary representation of a program object's compiled and linked executable source</p><p><em>gl:getProgramBinary</em> returns a binary representation of the compiled and linked executable for <em>Program</em> into the array of bytes whose address is specified in <em>Binary</em> . The maximum number of bytes that may be written into <em>Binary</em> is specified by <em>BufSize</em> . If the program binary is greater in size than <em>BufSize</em> bytes, then an error is generated, otherwise the actual number of bytes written into <em>Binary</em> is returned in the variable whose address is given by <em>Length</em> . If <em>Length</em> is <em>?NULL</em>, then no length is returned.</p><p>The format of the program binary written into <em>Binary</em> is returned in the variable whose address is given by <em>BinaryFormat</em> , and may be implementation dependent. The binary produced by the GL may subsequently be returned to the GL by calling <strong>gl:programBinary/3</strong> , with <em>BinaryFormat</em> and <em>Length</em> set to the values returned by <em>gl:getProgramBinary</em> , and passing the returned binary data in the <em>Binary</em> parameter.</p><p>See external documentation.</p><p><strong></strong> programBinary(Program, BinaryFormat, Binary) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>BinaryFormat = enum()</p><p>Binary = binary()</p><p>Load a program object with a program binary</p><p><em>gl:programBinary</em> loads a program object with a program binary previously returned from <strong>gl:getProgramBinary/2</strong> . <em>BinaryFormat</em> and <em>Binary</em> must be those returned by a previous call to <strong>gl:getProgramBinary/2</strong> , and <em>Length</em> must be the length returned by <strong>gl:getProgramBinary/2</strong> , or by <strong>gl:getProgramiv/2</strong> when called with <em>Pname</em> set to <em>?GL_PROGRAM_BINARY_LENGTH</em>. If these conditions are not met, loading the program binary will fail and <em>Program</em> 's <em>?GL_LINK_STATUS</em> will be set to <em>?GL_FALSE</em>.</p><p>A program object's program binary is replaced by calls to <strong>gl:linkProgram/1</strong> or <em>gl:programBinary</em> . When linking success or failure is concerned, <em>gl:programBinary</em> can be considered to perform an implicit linking operation. <strong>gl:linkProgram/1</strong> and <em>gl:programBinary</em> both set the program object's <em>?GL_LINK_STATUS</em> to <em>?GL_TRUE</em> or <em>?GL_FALSE</em> .</p><p>A successful call to <em>gl:programBinary</em> will reset all uniform variables to their initial values. The initial value is either the value of the variable's initializer as specified in the original shader source, or zero if no initializer was present. Additionally, all vertex shader input and fragment shader output assignments that were in effect when the program was linked before saving are restored with <em>gl:programBinary</em> is called.</p><p>See external documentation.</p><p><strong></strong> programParameteri(Program, Pname, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Pname = enum()</p><p>Value = integer()</p><p>Specify a parameter for a program object</p><p><em>gl:programParameter</em> specifies a new value for the parameter nameed by <em>Pname</em> for the program object <em>Program</em> .</p><p>If <em>Pname</em> is <em>?GL_PROGRAM_BINARY_RETRIEVABLE_HINT</em>, <em>Value</em> should be <em>?GL_FALSE</em> or <em>?GL_TRUE</em> to indicate to the implementation the intention of the application to retrieve the program's binary representation with <strong>gl:getProgramBinary/2</strong> . The implementation may use this information to store information that may be useful for a future query of the program's binary. It is recommended to set <em>?GL_PROGRAM_BINARY_RETRIEVABLE_HINT</em> for the program to <em>?GL_TRUE</em> before calling <strong>gl:linkProgram/1</strong> , and using the program at run-time if the binary is to be retrieved later.</p><p>If <em>Pname</em> is <em>?GL_PROGRAM_SEPARABLE</em>, <em>Value</em> must be <em>?GL_TRUE</em> or <em>?GL_FALSE</em> and indicates whether <em>Program</em> can be bound to individual pipeline stages via <strong>gl:useProgramStages/3</strong> . A program's <em>?GL_PROGRAM_SEPARABLE</em> parameter must be set to <em>?GL_TRUE</em><em>before</em> <strong>gl:linkProgram/1</strong> is called in order for it to be usable with a program pipeline object. The initial state of <em>?GL_PROGRAM_SEPARABLE</em> is <em>?GL_FALSE</em>.</p><p>See external documentation.</p><p><strong></strong> useProgramStages(Pipeline, Stages, Program) -&gt; ok</p><p>Types:</p><p>Pipeline = integer()</p><p>Stages = integer()</p><p>Program = integer()</p><p>Bind stages of a program object to a program pipeline</p><p><em>gl:useProgramStages</em> binds executables from a program object associated with a specified set of shader stages to the program pipeline object given by <em>Pipeline</em> . <em>Pipeline</em> specifies the program pipeline object to which to bind the executables. <em>Stages</em> contains a logical combination of bits indicating the shader stages to use within <em>Program</em> with the program pipeline object <em>Pipeline</em> . <em>Stages</em> must be a logical combination of <em>?GL_VERTEX_SHADER_BIT</em>, <em>?GL_TESS_CONTROL_SHADER_BIT</em>, <em>?GL_TESS_EVALUATION_SHADER_BIT</em> , <em>?GL_GEOMETRY_SHADER_BIT</em>, and <em>?GL_FRAGMENT_SHADER_BIT</em>. Additionally, the special value <em>?GL_ALL_SHADER_BITS</em> may be specified to indicate that all executables contained in <em>Program</em> should be installed in <em>Pipeline</em> .</p><p>If <em>Program</em> refers to a program object with a valid shader attached for an indicated shader stage, <em>gl:useProgramStages</em> installs the executable code for that stage in the indicated program pipeline object <em>Pipeline</em> . If <em>Program</em> is zero, or refers to a program object with no valid shader executable for a given stage, it is as if the pipeline object has no programmable stage configured for the indicated shader stages. If <em>Stages</em> contains bits other than those listed above, and is not equal to <em>?GL_ALL_SHADER_BITS</em> , an error is generated.</p><p>See external documentation.</p><p><strong></strong> activeShaderProgram(Pipeline, Program) -&gt; ok</p><p>Types:</p><p>Pipeline = integer()</p><p>Program = integer()</p><p>Set the active program object for a program pipeline object</p><p><em>gl:activeShaderProgram</em> sets the linked program named by <em>Program</em> to be the active program for the program pipeline object <em>Pipeline</em> . The active program in the active program pipeline object is the target of calls to <strong>gl:uniform1f/2</strong> when no program has been made current through a call to <strong>gl:useProgram/1</strong> .</p><p>See external documentation.</p><p><strong></strong> createShaderProgramv(Type, Strings) -&gt; integer()</p><p>Types:</p><p>Type = enum()</p><p>Strings = [string()]</p><p>glCreateShaderProgramv</p><p>See external documentation.</p><p><strong></strong> bindProgramPipeline(Pipeline) -&gt; ok</p><p>Types:</p><p>Pipeline = integer()</p><p>Bind a program pipeline to the current context</p><p><em>gl:bindProgramPipeline</em> binds a program pipeline object to the current context. <em>Pipeline</em> must be a name previously returned from a call to <strong>gl:genProgramPipelines/1</strong> . If no program pipeline exists with name <em>Pipeline</em> then a new pipeline object is created with that name and initialized to the default state vector.</p><p>When a program pipeline object is bound using <em>gl:bindProgramPipeline</em>, any previous binding is broken and is replaced with a binding to the specified pipeline object. If <em>Pipeline</em> is zero, the previous binding is broken and is not replaced, leaving no pipeline object bound. If no current program object has been established by <strong>gl:useProgram/1</strong> , the program objects used for each stage and for uniform updates are taken from the bound program pipeline object, if any. If there is a current program object established by <strong>gl:useProgram/1</strong> , the bound program pipeline object has no effect on rendering or uniform updates. When a bound program pipeline object is used for rendering, individual shader executables are taken from its program objects.</p><p>See external documentation.</p><p><strong></strong> deleteProgramPipelines(Pipelines) -&gt; ok</p><p>Types:</p><p>Pipelines = [integer()]</p><p>Delete program pipeline objects</p><p><em>gl:deleteProgramPipelines</em> deletes the <em>N</em> program pipeline objects whose names are stored in the array <em>Pipelines</em> . Unused names in <em>Pipelines</em> are ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to zero and no program pipeline object becomes current.</p><p>See external documentation.</p><p><strong></strong> genProgramPipelines(N) -&gt; [integer()]</p><p>Types:</p><p>N = integer()</p><p>Reserve program pipeline object names</p><p><em>gl:genProgramPipelines</em> returns <em>N</em> previously unused program pipeline object names in <em>Pipelines</em> . These names are marked as used, for the purposes of <em>gl:genProgramPipelines</em> only, but they acquire program pipeline state only when they are first bound.</p><p>See external documentation.</p><p><strong></strong> isProgramPipeline(Pipeline) -&gt; 0 | 1</p><p>Types:</p><p>Pipeline = integer()</p><p>Determine if a name corresponds to a program pipeline object</p><p><em>gl:isProgramPipeline</em> returns <em>?GL_TRUE</em> if <em>Pipeline</em> is currently the name of a program pipeline object. If <em>Pipeline</em> is zero, or if <em>?pipeline</em> is not the name of a program pipeline object, or if an error occurs, <em>gl:isProgramPipeline</em> returns <em>?GL_FALSE</em>. If <em>Pipeline</em> is a name returned by <strong>gl:genProgramPipelines/1</strong> , but that has not yet been bound through a call to <strong>gl:bindProgramPipeline/1</strong> , then the name is not a program pipeline object and <em>gl:isProgramPipeline</em> returns <em>?GL_FALSE</em> .</p><p>See external documentation.</p><p><strong></strong> getProgramPipelineiv(Pipeline, Pname) -&gt; integer()</p><p>Types:</p><p>Pipeline = integer()</p><p>Pname = enum()</p><p>Retrieve properties of a program pipeline object</p><p><em>gl:getProgramPipelineiv</em> retrieves the value of a property of the program pipeline object <em>Pipeline</em> . <em>Pname</em> specifies the name of the parameter whose value to retrieve. The value of the parameter is written to the variable whose address is given by <em>Params</em> .</p><p>If <em>Pname</em> is <em>?GL_ACTIVE_PROGRAM</em>, the name of the active program object of the program pipeline object is returned in <em>Params</em> .</p><p>If <em>Pname</em> is <em>?GL_VERTEX_SHADER</em>, the name of the current program object for the vertex shader type of the program pipeline object is returned in <em>Params</em> .</p><p>If <em>Pname</em> is <em>?GL_TESS_CONTROL_SHADER</em>, the name of the current program object for the tessellation control shader type of the program pipeline object is returned in <em>Params</em> .</p><p>If <em>Pname</em> is <em>?GL_TESS_EVALUATION_SHADER</em>, the name of the current program object for the tessellation evaluation shader type of the program pipeline object is returned in <em>Params</em> .</p><p>If <em>Pname</em> is <em>?GL_GEOMETRY_SHADER</em>, the name of the current program object for the geometry shader type of the program pipeline object is returned in <em>Params</em> .</p><p>If <em>Pname</em> is <em>?GL_FRAGMENT_SHADER</em>, the name of the current program object for the fragment shader type of the program pipeline object is returned in <em>Params</em> .</p><p>If <em>Pname</em> is <em>?GL_INFO_LOG_LENGTH</em>, the length of the info log, including the null terminator, is returned in <em>Params</em> . If there is no info log, zero is returned.</p><p>See external documentation.</p><p><strong></strong> programUniform1i(Program, Location, V0) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = integer()</p><p>Specify the value of a uniform variable for a specified program object</p><p><em>gl:programUniform</em> modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by <em>Location</em> , which should be a value returned by <strong>gl:getUniformLocation/2</strong> . <em>gl:programUniform</em> operates on the program object specified by <em>Program</em> .</p><p>The commands <em>gl:programUniform{1|2|3|4}{f|i|ui}</em> are used to change the value of the uniform variable specified by <em>Location</em> using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., <em>1</em> for float, int, unsigned int, bool; <em>2</em> for vec2, ivec2, uvec2, bvec2, etc.). The suffix <em>f</em> indicates that floating-point values are being passed; the suffix <em>i</em> indicates that integer values are being passed; the suffix <em>ui</em> indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The <em>i</em> variants of this function should be used to provide values for uniform variables defined as int, ivec2 , ivec3, ivec4, or arrays of these. The <em>ui</em> variants of this function should be used to provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of these. The <em>f</em> variants should be used to provide values for uniform variables of type float, vec2, vec3, vec4, or arrays of these. Either the <em>i</em>, <em>ui</em> or <em>f</em> variants may be used to provide values for uniform variables of type bool, bvec2 , bvec3, bvec4, or arrays of these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be set to true otherwise.</p><p>All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to <em>gl:programUniform</em> until the next successful link operation occurs on the program object, when they are once again initialized to 0.</p><p>The commands <em>gl:programUniform{1|2|3|4}{f|i|ui}v</em> can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading <em>n</em> elements starting at an arbitrary position <em>m</em> in a uniform variable array, elements <em>m</em> + <em>n</em> - 1 in the array will be replaced with the new values. If <em>M</em> + <em>N</em> - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in <em>Value</em> , and it should match the number of components in the data type of the specified uniform variable (e.g., <em>1</em> for float, int, bool; <em>2</em> for vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for <em>gl:programUniform{1|2|3|4}{f|i|ui}</em>.</p><p>For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., <em>gl:programUniform3f</em> or <em>gl:programUniform3fv</em> can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by <em>Count</em></p><p>The commands <em>gl:programUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv</em> are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number <em>2</em> indicates a 2 × 2 matrix (i.e., 4 values), the number <em>3</em> indicates a 3 × 3 matrix (i.e., 9 values), and the number <em>4</em> indicates a 4 × 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows. For example, <em>2x4</em> indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If <em>Transpose</em> is <em>?GL_FALSE</em>, each matrix is assumed to be supplied in column major order. If <em>Transpose</em> is <em>?GL_TRUE</em>, each matrix is assumed to be supplied in row major order. The <em>Count</em> argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.</p><p>See external documentation.</p><p><strong></strong> programUniform1iv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [integer()]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform1f(Program, Location, V0) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = float()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform1fv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [float()]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform1d(Program, Location, V0) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = float()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform1dv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [float()]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform1ui(Program, Location, V0) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = integer()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform1uiv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [integer()]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform2i(Program, Location, V0, V1) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform2iv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{integer(), integer()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform2f(Program, Location, V0, V1) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform2fv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform2d(Program, Location, V0, V1) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform2dv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform2ui(Program, Location, V0, V1) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform2uiv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{integer(), integer()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform3i(Program, Location, V0, V1, V2) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>V2 = integer()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform3iv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{integer(), integer(), integer()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform3f(Program, Location, V0, V1, V2) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>V2 = float()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform3fv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform3d(Program, Location, V0, V1, V2) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>V2 = float()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform3dv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform3ui(Program, Location, V0, V1, V2) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>V2 = integer()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform3uiv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{integer(), integer(), integer()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform4i(Program, Location, V0, V1, V2, V3) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>V2 = integer()</p><p>V3 = integer()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform4iv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{integer(), integer(), integer(), integer()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform4f(Program, Location, V0, V1, V2, V3) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>V2 = float()</p><p>V3 = float()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform4fv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform4d(Program, Location, V0, V1, V2, V3) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = float()</p><p>V1 = float()</p><p>V2 = float()</p><p>V3 = float()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform4dv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform4ui(Program, Location, V0, V1, V2, V3) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>V0 = integer()</p><p>V1 = integer()</p><p>V2 = integer()</p><p>V3 = integer()</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniform4uiv(Program, Location, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Value = [{integer(), integer(), integer(), integer()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix2fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix3fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix4fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix2dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix3dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix4dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix2x3fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix3x2fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix2x4fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix4x2fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix3x4fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix4x3fv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix2x3dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix3x2dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix2x4dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix4x2dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix3x4dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> programUniformMatrix4x3dv(Program, Location, Transpose, Value) -&gt; ok</p><p>Types:</p><p>Program = integer()</p><p>Location = integer()</p><p>Transpose = 0 | 1</p><p>Value = [{float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}]</p><p>See <strong>programUniform1i/3</strong></p><p><strong></strong> validateProgramPipeline(Pipeline) -&gt; ok</p><p>Types:</p><p>Pipeline = integer()</p><p>Validate a program pipeline object against current GL state</p><p><em>gl:validateProgramPipeline</em> instructs the implementation to validate the shader executables contained in <em>Pipeline</em> against the current GL state. The implementation may use this as an opportunity to perform any internal shader modifications that may be required to ensure correct operation of the installed shaders given the current GL state.</p><p>After a program pipeline has been validated, its validation status is set to <em>?GL_TRUE</em> . The validation status of a program pipeline object may be queried by calling <strong>gl:getProgramPipelineiv/2</strong> with parameter <em>?GL_VALIDATE_STATUS</em>.</p><p>If <em>Pipeline</em> is a name previously returned from a call to <strong>gl:genProgramPipelines/1</strong> but that has not yet been bound by a call to <strong>gl:bindProgramPipeline/1</strong> , a new program pipeline object is created with name <em>Pipeline</em> and the default state vector.</p><p>See external documentation.</p><p><strong></strong> getProgramPipelineInfoLog(Pipeline, BufSize) -&gt; string()</p><p>Types:</p><p>Pipeline = integer()</p><p>BufSize = integer()</p><p>Retrieve the info log string from a program pipeline object</p><p><em>gl:getProgramPipelineInfoLog</em> retrieves the info log for the program pipeline object <em>Pipeline</em> . The info log, including its null terminator, is written into the array of characters whose address is given by <em>InfoLog</em> . The maximum number of characters that may be written into <em>InfoLog</em> is given by <em>BufSize</em> , and the actual number of characters written into <em>InfoLog</em> is returned in the integer whose address is given by <em>Length</em> . If <em>Length</em> is <em>?NULL</em>, no length is returned.</p><p>The actual length of the info log for the program pipeline may be determined by calling <strong>gl:getProgramPipelineiv/2</strong> with <em>Pname</em> set to <em>?GL_INFO_LOG_LENGTH</em>.</p><p>See external documentation.</p><p><strong></strong> vertexAttribL1d(Index, X) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>glVertexAttribL</p><p>See external documentation.</p><p><strong></strong> vertexAttribL2d(Index, X, Y) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>glVertexAttribL</p><p>See external documentation.</p><p><strong></strong> vertexAttribL3d(Index, X, Y, Z) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>glVertexAttribL</p><p>See external documentation.</p><p><strong></strong> vertexAttribL4d(Index, X, Y, Z, W) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>Z = float()</p><p>W = float()</p><p>glVertexAttribL</p><p>See external documentation.</p><p><strong></strong> vertexAttribL1dv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float()}</p><p>Equivalent to <strong>vertexAttribL1d(Index, X)</strong>.</p><p><strong></strong> vertexAttribL2dv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float()}</p><p>Equivalent to <strong>vertexAttribL2d(Index, X, Y)</strong>.</p><p><strong></strong> vertexAttribL3dv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float()}</p><p>Equivalent to <strong>vertexAttribL3d(Index, X, Y, Z)</strong>.</p><p><strong></strong> vertexAttribL4dv(Index::integer(), V) -&gt; ok</p><p>Types:</p><p>V = {X::float(), Y::float(), Z::float(), W::float()}</p><p>Equivalent to <strong>vertexAttribL4d(Index, X, Y, Z, W)</strong>.</p><p><strong></strong> vertexAttribLPointer(Index, Size, Type, Stride, Pointer) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>Size = integer()</p><p>Type = enum()</p><p>Stride = integer()</p><p>Pointer = offset() | mem()</p><p>glVertexAttribLPointer</p><p>See external documentation.</p><p><strong></strong> getVertexAttribLdv(Index, Pname) -&gt; {float(), float(), float(), float()}</p><p>Types:</p><p>Index = integer()</p><p>Pname = enum()</p><p>glGetVertexAttribL</p><p>See external documentation.</p><p><strong></strong> viewportArrayv(First, V) -&gt; ok</p><p>Types:</p><p>First = integer()</p><p>V = [{float(), float(), float(), float()}]</p><p>glViewportArrayv</p><p>See external documentation.</p><p><strong></strong> viewportIndexedf(Index, X, Y, W, H) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>X = float()</p><p>Y = float()</p><p>W = float()</p><p>H = float()</p><p>Set a specified viewport</p><p><em>gl:viewportIndexedf</em> and <em>gl:viewportIndexedfv</em> specify the parameters for a single viewport. <em>Index</em> specifies the index of the viewport to modify. <em>Index</em> must be less than the value of <em>?GL_MAX_VIEWPORTS</em>. For <em>gl:viewportIndexedf</em>, <em>X</em> , <em>Y</em> , <em>W</em> , and <em>H</em> specify the left, bottom, width and height of the viewport in pixels, respectively. For <em>gl:viewportIndexedfv</em>, <em>V</em> contains the address of an array of floating point values specifying the left ( x), bottom ( y), width ( w), and height ( h) of each viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h give the width and height of the viewport, respectively. The viewport specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let (x nd y nd) be normalized device coordinates. Then the window coordinates (x w y w) are computed as follows:</p><p>x w=(x nd+1) (width/2)+x</p><p>y w=(y nd+1) (height/2)+y</p><p>The location of the viewport's bottom left corner, given by ( x, y) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range [ min, max] can be determined by calling <strong>gl:getBooleanv/1</strong> with argument <em>?GL_VIEWPORT_BOUNDS_RANGE</em> . Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call <strong>gl:getBooleanv/1</strong> with argument <em>?GL_MAX_VIEWPORT_DIMS</em>.</p><p>The precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant <em>?GL_VIEWPORT_SUBPIXEL_BITS</em> .</p><p>Calling <em>gl:viewportIndexedfv</em> is equivalent to calling see <em>glViewportArray</em> with <em>First</em> set to <em>Index</em> , <em>Count</em> set to 1 and <em>V</em> passsed directly. <em>gl:viewportIndexedf</em> is equivalent to: void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) { const float v[4] = { x, y, w, h }; glViewportArrayv(index, 1, v); }</p><p>See external documentation.</p><p><strong></strong> viewportIndexedfv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {float(), float(), float(), float()}</p><p>See <strong>viewportIndexedf/5</strong></p><p><strong></strong> scissorArrayv(First, V) -&gt; ok</p><p>Types:</p><p>First = integer()</p><p>V = [{integer(), integer(), integer(), integer()}]</p><p>glScissorArrayv</p><p>See external documentation.</p><p><strong></strong> scissorIndexed(Index, Left, Bottom, Width, Height) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>Left = integer()</p><p>Bottom = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>glScissorIndexe</p><p>See external documentation.</p><p><strong></strong> scissorIndexedv(Index, V) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>V = {integer(), integer(), integer(), integer()}</p><p>glScissorIndexe</p><p>See external documentation.</p><p><strong></strong> depthRangeArrayv(First, V) -&gt; ok</p><p>Types:</p><p>First = integer()</p><p>V = [{clamp(), clamp()}]</p><p>glDepthRangeArrayv</p><p>See external documentation.</p><p><strong></strong> depthRangeIndexed(Index, N, F) -&gt; ok</p><p>Types:</p><p>Index = integer()</p><p>N = clamp()</p><p>F = clamp()</p><p>glDepthRangeIndexe</p><p>See external documentation.</p><p><strong></strong> getFloati_v(Target, Index) -&gt; [float()]</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> getDoublei_v(Target, Index) -&gt; [float()]</p><p>Types:</p><p>Target = enum()</p><p>Index = integer()</p><p>See <strong>getBooleanv/1</strong></p><p><strong></strong> debugMessageControlARB(Source, Type, Severity, Ids, Enabled) -&gt; ok</p><p>Types:</p><p>Source = enum()</p><p>Type = enum()</p><p>Severity = enum()</p><p>Ids = [integer()]</p><p>Enabled = 0 | 1</p><p>glDebugMessageControlARB</p><p>See external documentation.</p><p><strong></strong> debugMessageInsertARB(Source, Type, Id, Severity, Buf) -&gt; ok</p><p>Types:</p><p>Source = enum()</p><p>Type = enum()</p><p>Id = integer()</p><p>Severity = enum()</p><p>Buf = string()</p><p>glDebugMessageInsertARB</p><p>See external documentation.</p><p><strong></strong> getDebugMessageLogARB(Count, Bufsize) -&gt; {integer(), Sources::[enum()], Types::[enum()], Ids::[integer()], Severities::[enum()], MessageLog::[string()]}</p><p>Types:</p><p>Count = integer()</p><p>Bufsize = integer()</p><p>glGetDebugMessageLogARB</p><p>See external documentation.</p><p><strong></strong> getGraphicsResetStatusARB() -&gt; enum()</p><p>glGetGraphicsResetStatusARB</p><p>See external documentation.</p><p><strong></strong> drawArraysInstancedBaseInstance(Mode, First, Count, Primcount, Baseinstance) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>First = integer()</p><p>Count = integer()</p><p>Primcount = integer()</p><p>Baseinstance = integer()</p><p>Draw multiple instances of a range of elements with offset applied to instanced attributes</p><p><em>gl:drawArraysInstancedBaseInstance</em> behaves identically to <strong>gl:drawArrays/3</strong> except that <em>Primcount</em> instances of the range of elements are executed and the value of the internal counter <em>InstanceID</em> advances for each iteration. <em>InstanceID</em> is an internal 32-bit integer counter that may be read by a vertex shader as <em>?gl_InstanceID</em> .</p><p><em>gl:drawArraysInstancedBaseInstance</em> has the same effect as: if ( mode or count is invalid ) generate appropriate error else { for (int i = 0; i &lt; primcount ; i++) { instanceID = i; glDrawArrays(mode, first, count); } instanceID = 0; }</p><p>Specific vertex attributes may be classified as <em>instanced</em> through the use of <strong>gl:vertexAttribDivisor/2</strong> . Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as: |gl_ InstanceID/divisor|&plus; baseInstance. Note that <em>Baseinstance</em> does not affect the shader-visible value of <em>?gl_InstanceID</em>.</p><p>See external documentation.</p><p><strong></strong> drawElementsInstancedBaseInstance(Mode, Count, Type, Indices, Primcount, Baseinstance) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Count = integer()</p><p>Type = enum()</p><p>Indices = offset() | mem()</p><p>Primcount = integer()</p><p>Baseinstance = integer()</p><p>Draw multiple instances of a set of elements with offset applied to instanced attributes</p><p><em>gl:drawElementsInstancedBaseInstance</em> behaves identically to <strong>gl:drawElements/4</strong> except that <em>Primcount</em> instances of the set of elements are executed and the value of the internal counter <em>InstanceID</em> advances for each iteration. <em>InstanceID</em> is an internal 32-bit integer counter that may be read by a vertex shader as <em>?gl_InstanceID</em> .</p><p><em>gl:drawElementsInstancedBaseInstance</em> has the same effect as: if (mode, count, or type is invalid ) generate appropriate error else { for (int i = 0; i &lt; primcount ; i++) { instanceID = i; glDrawElements(mode, count, type, indices); } instanceID = 0; }</p><p>Specific vertex attributes may be classified as <em>instanced</em> through the use of <strong>gl:vertexAttribDivisor/2</strong> . Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as |gl_ InstanceID/divisor|&plus; baseInstance. Note that <em>Baseinstance</em> does not affect the shader-visible value of <em>?gl_InstanceID</em>.</p><p>See external documentation.</p><p><strong></strong> drawElementsInstancedBaseVertexBaseInstance(Mode, Count, Type, Indices, Primcount, Basevertex, Baseinstance) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Count = integer()</p><p>Type = enum()</p><p>Indices = offset() | mem()</p><p>Primcount = integer()</p><p>Basevertex = integer()</p><p>Baseinstance = integer()</p><p>Render multiple instances of a set of primitives from array data with a per-element offset</p><p><em>gl:drawElementsInstancedBaseVertexBaseInstance</em> behaves identically to <strong>gl:drawElementsInstanced/5</strong> except that the <em>i</em>th element transferred by the corresponding draw call will be taken from element <em>Indices</em> [i] + <em>Basevertex</em> of each enabled array. If the resulting value is larger than the maximum value representable by <em>Type</em> , it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative. The <em>Basevertex</em> has no effect on the shader-visible value of <em>?gl_VertexID</em>.</p><p>Specific vertex attributes may be classified as <em>instanced</em> through the use of <strong>gl:vertexAttribDivisor/2</strong> . Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as |gl_ InstanceID/divisor|&plus; baseInstance. Note that <em>Baseinstance</em> does not affect the shader-visible value of <em>?gl_InstanceID</em>.</p><p>See external documentation.</p><p><strong></strong> drawTransformFeedbackInstanced(Mode, Id, Primcount) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Id = integer()</p><p>Primcount = integer()</p><p>glDrawTransformFeedbackInstance</p><p>See external documentation.</p><p><strong></strong> drawTransformFeedbackStreamInstanced(Mode, Id, Stream, Primcount) -&gt; ok</p><p>Types:</p><p>Mode = enum()</p><p>Id = integer()</p><p>Stream = integer()</p><p>Primcount = integer()</p><p>glDrawTransformFeedbackStreamInstance</p><p>See external documentation.</p><p><strong></strong> getInternalformativ(Target, Internalformat, Pname, BufSize) -&gt; [integer()]</p><p>Types:</p><p>Target = enum()</p><p>Internalformat = enum()</p><p>Pname = enum()</p><p>BufSize = integer()</p><p>glGetInternalformat</p><p>See external documentation.</p><p><strong></strong> bindImageTexture(Unit, Texture, Level, Layered, Layer, Access, Format) -&gt; ok</p><p>Types:</p><p>Unit = integer()</p><p>Texture = integer()</p><p>Level = integer()</p><p>Layered = 0 | 1</p><p>Layer = integer()</p><p>Access = enum()</p><p>Format = enum()</p><p>Bind a level of a texture to an image unit</p><p><em>gl:bindImageTexture</em> binds a single level of a texture to an image unit for the purpose of reading and writing it from shaders. <em>Unit</em> specifies the zero-based index of the image unit to which to bind the texture level. <em>Texture</em> specifies the name of an existing texture object to bind to the image unit. If <em>Texture</em> is zero, then any existing binding to the image unit is broken. <em>Level</em> specifies the level of the texture to bind to the image unit.</p><p>If <em>Texture</em> is the name of a one-, two-, or three-dimensional array texture, a cube map or cube map array texture, or a two-dimensional multisample array texture, then it is possible to bind either the entire array, or only a single layer of the array to the image unit. In such cases, if <em>Layered</em> is <em>?GL_TRUE</em>, the entire array is attached to the image unit and <em>Layer</em> is ignored. However, if <em>Layered</em> is <em>?GL_FALSE</em> then <em>Layer</em> specifies the layer of the array to attach to the image unit.</p><p><em>Access</em> specifies the access types to be performed by shaders and may be set to <em>?GL_READ_ONLY</em> , <em>?GL_WRITE_ONLY</em>, or <em>?GL_READ_WRITE</em> to indicate read-only, write-only or read-write access, respectively. Violation of the access type specified in <em>Access</em> (for example, if a shader writes to an image bound with <em>Access</em> set to <em>?GL_READ_ONLY</em> ) will lead to undefined results, possibly including program termination.</p><p><em>Format</em> specifies the format that is to be used when performing formatted stores into the image from shaders. <em>Format</em> must be compatible with the texture's internal format and must be one of the formats listed in the following table.<em>Image Unit Format</em><em>Format Qualifier</em></p><p><em>?GL_RGBA32F</em>rgba32f</p><p><em>?GL_RGBA16F</em> rgba16f</p><p><em>?GL_RG32F</em>rg32f</p><p><em>?GL_RG16F</em> rg16f</p><p><em>?GL_R11F_G11F_B10F</em>r11f_g11f_b10f</p><p><em>?GL_R32F</em>r32f</p><p><em>?GL_R16F</em>r16f</p><p><em>?GL_RGBA32UI</em>rgba32ui</p><p><em>?GL_RGBA16UI</em> rgba16ui</p><p><em>?GL_RGB10_A2UI</em>rgb10_a2ui</p><p><em>?GL_RGBA8UI</em> rgba8ui</p><p><em>?GL_RG32UI</em>rg32ui</p><p><em>?GL_RG16UI</em> rg16ui</p><p><em>?GL_RG8UI</em>rg8ui</p><p><em>?GL_R32UI</em> r32ui</p><p><em>?GL_R16UI</em>r16ui</p><p><em>?GL_R8UI</em> r8ui</p><p><em>?GL_RGBA32I</em>rgba32i</p><p><em>?GL_RGBA16I</em> rgba16i</p><p><em>?GL_RGBA8I</em>rgba8i</p><p><em>?GL_RG32I</em> rg32i</p><p><em>?GL_RG16I</em>rg16i</p><p><em>?GL_RG8I</em> rg8i</p><p><em>?GL_R32I</em>r32i</p><p><em>?GL_R16I</em> r16i</p><p><em>?GL_R8I</em>r8i</p><p><em>?GL_RGBA16</em> rgba16</p><p><em>?GL_RGB10_A2</em>rgb10_a2</p><p><em>?GL_RGBA8</em> rgba8</p><p><em>?GL_RG16</em>rg16</p><p><em>?GL_RG8</em> rg8</p><p><em>?GL_R16</em>r16</p><p><em>?GL_R8</em> r8</p><p><em>?GL_RGBA16_SNORM</em>rgba16_snorm</p><p><em>?GL_RGBA8_SNORM</em> rgba8_snorm</p><p><em>?GL_RG16_SNORM</em>rg16_snorm</p><p><em>?GL_RG8_SNORM</em>rg8_snorm</p><p><em>?GL_R16_SNORM</em>r16_snorm</p><p><em>?GL_R8_SNORM</em>r8_snorm</p><p>When a texture is bound to an image unit, the <em>Format</em> parameter for the image unit need not exactly match the texture internal format as long as the formats are considered compatible as defined in the OpenGL Specification. The matching criterion used for a given texture may be determined by calling <strong>gl:getTexParameterfv/2</strong> with <em>Value</em> set to <em>?GL_IMAGE_FORMAT_COMPATIBILITY_TYPE</em>, with return values of <em>?GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE</em> and <em>?GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS</em>, specifying matches by size and class, respectively.</p><p>See external documentation.</p><p><strong></strong> memoryBarrier(Barriers) -&gt; ok</p><p>Types:</p><p>Barriers = integer()</p><p>Defines a barrier ordering memory transactions</p><p><em>gl:memoryBarrier</em> defines a barrier ordering the memory transactions issued prior to the command relative to those issued after the barrier. For the purposes of this ordering, memory transactions performed by shaders are considered to be issued by the rendering command that triggered the execution of the shader. <em>Barriers</em> is a bitfield indicating the set of operations that are synchronized with shader stores; the bits used in <em>Barriers</em> are as follows:</p><p><em>?GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT</em>: If set, vertex data sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. The set of buffer objects affected by this bit is derived from the buffer object bindings used for generic vertex attributes derived from the <em>?GL_VERTEX_ATTRIB_ARRAY_BUFFER</em> bindings.</p><p><em>?GL_ELEMENT_ARRAY_BARRIER_BIT</em>: If set, vertex array indices sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected by this bit are derived from the <em>?GL_ELEMENT_ARRAY_BUFFER</em> binding.</p><p><em>?GL_UNIFORM_BARRIER_BIT</em>: Shader uniforms sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier.</p><p><em>?GL_TEXTURE_FETCH_BARRIER_BIT</em>: Texture fetches from shaders, including fetches from buffer object memory via buffer textures, after the barrier will reflect data written by shaders prior to the barrier.</p><p><em>?GL_SHADER_IMAGE_ACCESS_BARRIER_BIT</em>: Memory accesses using shader image load, store, and atomic built-in functions issued after the barrier will reflect data written by shaders prior to the barrier. Additionally, image stores and atomics issued after the barrier will not execute until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the barrier complete.</p><p><em>?GL_COMMAND_BARRIER_BIT</em>: Command data sourced from buffer objects by Draw*Indirect commands after the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected by this bit are derived from the <em>?GL_DRAW_INDIRECT_BUFFER</em> binding.</p><p><em>?GL_PIXEL_BUFFER_BARRIER_BIT</em>: Reads and writes of buffer objects via the <em>?GL_PIXEL_PACK_BUFFER</em> and <em>?GL_PIXEL_UNPACK_BUFFER</em> bindings (via <strong>gl:readPixels/7</strong> , <strong>gl:texSubImage1D/7</strong> , etc.) after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier.</p><p><em>?GL_TEXTURE_UPDATE_BARRIER_BIT</em>: Writes to a texture via <em>gl:tex(Sub)Image*</em>, <em>gl:copyTex(Sub)Image*</em> , <em>gl:compressedTex(Sub)Image*</em>, and reads via <strong>gl:getTexImage/5</strong> after the barrier will reflect data written by shaders prior to the barrier. Additionally, texture writes from these commands issued after the barrier will not execute until all shader writes initiated prior to the barrier complete.</p><p><em>?GL_BUFFER_UPDATE_BARRIER_BIT</em>: Reads or writes via <strong>gl:bufferSubData/4</strong> , <strong>gl:copyBufferSubData/5</strong> , or <strong>gl:getBufferSubData/4</strong> , or to buffer object memory mapped by see <em>glMapBuffer</em> or see <em>glMapBufferRange</em> after the barrier will reflect data written by shaders prior to the barrier. Additionally, writes via these commands issued after the barrier will wait on the completion of any shader writes to the same memory initiated prior to the barrier.</p><p><em>?GL_FRAMEBUFFER_BARRIER_BIT</em>: Reads and writes via framebuffer object attachments after the barrier will reflect data written by shaders prior to the barrier. Additionally, framebuffer writes issued after the barrier will wait on the completion of all shader writes issued prior to the barrier.</p><p><em>?GL_TRANSFORM_FEEDBACK_BARRIER_BIT</em>: Writes via transform feedback bindings after the barrier will reflect data written by shaders prior to the barrier. Additionally, transform feedback writes issued after the barrier will wait on the completion of all shader writes issued prior to the barrier.</p><p><em>?GL_ATOMIC_COUNTER_BARRIER_BIT</em>: Accesses to atomic counters after the barrier will reflect writes prior to the barrier.</p><p>If <em>Barriers</em> is <em>?GL_ALL_BARRIER_BITS</em>, shader memory accesses will be synchronized relative to all the operations described above.</p><p>Implementations may cache buffer object and texture image memory that could be written by shaders in multiple caches; for example, there may be separate caches for texture, vertex fetching, and one or more caches for shader memory accesses. Implementations are not required to keep these caches coherent with shader memory writes. Stores issued by one invocation may not be immediately observable by other pipeline stages or other shader invocations because the value stored may remain in a cache local to the processor executing the store, or because data overwritten by the store is still in a cache elsewhere in the system. When <em>gl:memoryBarrier</em> is called, the GL flushes and/or invalidates any caches relevant to the operations specified by the <em>Barriers</em> parameter to ensure consistent ordering of operations across the barrier.</p><p>To allow for independent shader invocations to communicate by reads and writes to a common memory address, image variables in the OpenGL Shading Language may be declared as "coherent". Buffer object or texture image memory accessed through such variables may be cached only if caches are automatically updated due to stores issued by any other shader invocation. If the same address is accessed using both coherent and non-coherent variables, the accesses using variables declared as coherent will observe the results stored using coherent variables in other invocations. Using variables declared as "coherent" guarantees only that the results of stores will be immediately visible to shader invocations using similarly-declared variables; calling <em>gl:memoryBarrier</em> is required to ensure that the stores are visible to other operations.</p><p>The following guidelines may be helpful in choosing when to use coherent memory accesses and when to use barriers.</p><p>Data that are read-only or constant may be accessed without using coherent variables or calling MemoryBarrier(). Updates to the read-only data via API calls such as BufferSubData will invalidate shader caches implicitly as required.</p><p>Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another invocation) should use coherent variables to read and write the shared data.</p><p>Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution ("dependent invocations") should use coherent variables in the producing shader invocation and call memoryBarrier() after the last write. The consuming shader invocation should also use coherent variables.</p><p>Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables or memoryBarrier(). Calling MemoryBarrier() with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in <em>Barriers</em> between passes is necessary.</p><p>Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in a later pass need not use coherent variables or memoryBarrier(). Calling <em>gl:memoryBarrier</em> with the appropriate bits set in <em>Barriers</em> between passes is necessary.</p><p>See external documentation.</p><p><strong></strong> texStorage1D(Target, Levels, Internalformat, Width) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Levels = integer()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Simultaneously specify storage for all levels of a one-dimensional texture</p><p><em>gl:texStorage1D</em> specifies the storage requirements for all levels of a one-dimensional texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an <em>immutable-format</em> texture.</p><p>Calling <em>gl:texStorage1D</em> is equivalent, assuming no errors are generated, to executing the following pseudo-code: for (i = 0; i &lt; levels; i++) { glTexImage1D(target, i, internalformat, width, 0, format, type, NULL); width = max(1, (width / 2)); }</p><p>Since no texture data is actually provided, the values used in the pseudo-code for <em>Format</em> and <em>Type</em> are irrelevant and may be considered to be any values that are legal for the chosen <em>Internalformat</em> enumerant. <em>Internalformat</em> must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats <em>?GL_DEPTH_COMPONENT32F</em> , <em>?GL_DEPTH_COMPONENT24</em>, or <em>?GL_DEPTH_COMPONENT16</em>, or one of the combined depth-stencil formats, <em>?GL_DEPTH32F_STENCIL8</em>, or <em>?GL_DEPTH24_STENCIL8</em>. Upon success, the value of <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em> becomes <em>?GL_TRUE</em>. The value of <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em> may be discovered by calling <strong>gl:getTexParameterfv/2</strong> with <em>Pname</em> set to <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em>. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as <strong>gl:texImage1D/8</strong> or another call to <em>gl:texStorage1D</em>) will result in the generation of a <em>?GL_INVALID_OPERATION</em> error, even if it would not, in fact, alter the dimensions or format of the object.</p><p>See external documentation.</p><p><strong></strong> texStorage2D(Target, Levels, Internalformat, Width, Height) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Levels = integer()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Height = integer()</p><p>Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture</p><p><em>gl:texStorage2D</em> specifies the storage requirements for all levels of a two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an <em>immutable-format</em> texture.</p><p>The behavior of <em>gl:texStorage2D</em> depends on the <em>Target</em> parameter. When <em>Target</em> is <em>?GL_TEXTURE_2D</em>, <em>?GL_PROXY_TEXTURE_2D</em>, <em>?GL_TEXTURE_RECTANGLE</em>, <em>?GL_PROXY_TEXTURE_RECTANGLE</em> or <em>?GL_PROXY_TEXTURE_CUBE_MAP</em>, calling <em>gl:texStorage2D</em> is equivalent, assuming no errors are generated, to executing the following pseudo-code: for (i = 0; i &lt; levels; i++) { glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL); width = max(1, (width / 2)); height = max(1, (height / 2)); }</p><p>When <em>Target</em> is <em>?GL_TEXTURE_CUBE_MAP</em>, <em>gl:texStorage2D</em> is equivalent to: for (i = 0; i &lt; levels; i++) { for (face in (+X, -X, +Y, -Y, +Z, -Z)) { glTexImage2D(face, i, internalformat, width, height, 0, format, type, NULL); } width = max(1, (width / 2)); height = max(1, (height / 2)); }</p><p>When <em>Target</em> is <em>?GL_TEXTURE_1D</em> or <em>?GL_TEXTURE_1D_ARRAY</em>, <em>gl:texStorage2D</em> is equivalent to: for (i = 0; i &lt; levels; i++) { glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL); width = max(1, (width / 2)); }</p><p>Since no texture data is actually provided, the values used in the pseudo-code for <em>Format</em> and <em>Type</em> are irrelevant and may be considered to be any values that are legal for the chosen <em>Internalformat</em> enumerant. <em>Internalformat</em> must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats <em>?GL_DEPTH_COMPONENT32F</em> , <em>?GL_DEPTH_COMPONENT24</em>, or <em>?GL_DEPTH_COMPONENT16</em>, or one of the combined depth-stencil formats, <em>?GL_DEPTH32F_STENCIL8</em>, or <em>?GL_DEPTH24_STENCIL8</em>. Upon success, the value of <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em> becomes <em>?GL_TRUE</em>. The value of <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em> may be discovered by calling <strong>gl:getTexParameterfv/2</strong> with <em>Pname</em> set to <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em>. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as <strong>gl:texImage2D/9</strong> or another call to <em>gl:texStorage2D</em>) will result in the generation of a <em>?GL_INVALID_OPERATION</em> error, even if it would not, in fact, alter the dimensions or format of the object.</p><p>See external documentation.</p><p><strong></strong> texStorage3D(Target, Levels, Internalformat, Width, Height, Depth) -&gt; ok</p><p>Types:</p><p>Target = enum()</p><p>Levels = integer()</p><p>Internalformat = enum()</p><p>Width = integer()</p><p>Height = integer()</p><p>Depth = integer()</p><p>Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture</p><p><em>gl:texStorage3D</em> specifies the storage requirements for all levels of a three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an <em>immutable-format</em> texture.</p><p>The behavior of <em>gl:texStorage3D</em> depends on the <em>Target</em> parameter. When <em>Target</em> is <em>?GL_TEXTURE_3D</em>, or <em>?GL_PROXY_TEXTURE_3D</em>, calling <em>gl:texStorage3D</em> is equivalent, assuming no errors are generated, to executing the following pseudo-code: for (i = 0; i &lt; levels; i++) { glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL); width = max(1, (width / 2)); height = max(1, (height / 2)); depth = max(1, (depth / 2)); }</p><p>When <em>Target</em> is <em>?GL_TEXTURE_2D_ARRAY</em>, <em>?GL_PROXY_TEXTURE_2D_ARRAY</em>, <em>?GL_TEXTURE_CUBE_MAP_ARRAY</em> , or <em>?GL_PROXY_TEXTURE_CUBE_MAP_ARRAY</em>, <em>gl:texStorage3D</em> is equivalent to: for (i = 0; i &lt; levels; i++) { glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL); width = max(1, (width / 2)); height = max(1, (height / 2)); }</p><p>Since no texture data is actually provided, the values used in the pseudo-code for <em>Format</em> and <em>Type</em> are irrelevant and may be considered to be any values that are legal for the chosen <em>Internalformat</em> enumerant. <em>Internalformat</em> must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats <em>?GL_DEPTH_COMPONENT32F</em> , <em>?GL_DEPTH_COMPONENT24</em>, or <em>?GL_DEPTH_COMPONENT16</em>, or one of the combined depth-stencil formats, <em>?GL_DEPTH32F_STENCIL8</em>, or <em>?GL_DEPTH24_STENCIL8</em>. Upon success, the value of <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em> becomes <em>?GL_TRUE</em>. The value of <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em> may be discovered by calling <strong>gl:getTexParameterfv/2</strong> with <em>Pname</em> set to <em>?GL_TEXTURE_IMMUTABLE_FORMAT</em>. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as <strong>gl:texImage3D/10</strong> or another call to <em>gl:texStorage3D</em>) will result in the generation of a <em>?GL_INVALID_OPERATION</em> error, even if it would not, in fact, alter the dimensions or format of the object.</p><p>See external documentation.</p><p><strong></strong> depthBoundsEXT(Zmin, Zmax) -&gt; ok</p><p>Types:</p><p>Zmin = clamp()</p><p>Zmax = clamp()</p><p>glDepthBoundsEXT</p><p>See external documentation.</p><p><strong></strong> stencilClearTagEXT(StencilTagBits, StencilClearTag) -&gt; ok</p><p>Types:</p><p>StencilTagBits = integer()</p><p>StencilClearTag = integer()</p><p>glStencilClearTagEXT</p><p>See external documentation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p><em></em> &lt;&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gen_udp.3erl.html"><span aria-hidden="true">&larr;</span> gen_udp.3erl: Interface to udp sockets</a></li>
   <li class="next"><a href="global.3erl.html">global.3erl: A global name registration facility <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

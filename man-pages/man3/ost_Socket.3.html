<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ost_Socket: The socket is used as the base for all internet protocol services under common c++.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The socket is used as the base for all internet protocol services under common c++.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ost_Socket (3) manual">
  <meta name="twitter:description" content="The socket is used as the base for all internet protocol services under common c++.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_Socket-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/ost_Socket.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ost_Socket (3) manual" />
  <meta property="og:description" content="The socket is used as the base for all internet protocol services under common c++." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_Socket-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ost_Socket<small> (3)</small></h1>
        <p class="lead">The socket is used as the base for all internet protocol services under common c++.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_Socket.3.html">
      <span itemprop="name">ost_Socket: The socket is used as the base for all internet protocol services under common c++.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcommoncpp2-doc/">
      <span itemprop="name">libcommoncpp2-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_Socket.3.html">
      <span itemprop="name">ost_Socket: The socket is used as the base for all internet protocol services under common c++.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;socket.h&gt;</p><p>Inherited by <strong>ost::DCCPSocket</strong>, <strong>ost::SimpleTCPStream</strong>, <strong>ost::SocketPort</strong>, <strong>ost::TCPSocket</strong> [protected]<strong>, </strong><strong>ost::TCPStream</strong><strong>, </strong><strong>ost::TCPV6Socket</strong><strong> [protected]</strong><strong>, </strong><strong>ost::UDPSocket</strong><strong>, </strong><strong>ost::UnixSocket</strong><strong> [protected]</strong><strong>, and </strong><strong>ost::UnixStream</strong><strong>.</strong></p><h3>Public Types</h3>
<p>enum <strong>Family</strong> { <strong>IPV6</strong> = AF_INET6, <strong>IPV4</strong> = AF_INET }</p><p>enum <strong>Error</strong> { <strong>errSuccess</strong> = 0, <strong>errCreateFailed</strong>, <strong>errCopyFailed</strong>, <strong>errInput</strong>, <strong>errInputInterrupt</strong>, <strong>errResourceFailure</strong>, <strong>errOutput</strong>, <strong>errOutputInterrupt</strong>, <strong>errNotConnected</strong>, <strong>errConnectRefused</strong>, <strong>errConnectRejected</strong>, <strong>errConnectTimeout</strong>, <strong>errConnectFailed</strong>, <strong>errConnectInvalid</strong>, <strong>errConnectBusy</strong>, <strong>errConnectNoRoute</strong>, <strong>errBindingFailed</strong>, <strong>errBroadcastDenied</strong>, <strong>errRoutingDenied</strong>, <strong>errKeepaliveDenied</strong>, <strong>errServiceDenied</strong>, <strong>errServiceUnavailable</strong>, <strong>errMulticastDisabled</strong>, <strong>errTimeout</strong>, <strong>errNoDelay</strong>, <strong>errExtended</strong>, <strong>errLookupFail</strong>, <strong>errSearchErr</strong>, <strong>errInvalidValue</strong> }</p><p>enum <strong>Tos</strong> { <strong>tosLowDelay</strong> = 0, <strong>tosThroughput</strong>, <strong>tosReliability</strong>, <strong>tosMinCost</strong>, <strong>tosInvalid</strong> }</p><p>enum <strong>Pending</strong> { <strong>pendingInput</strong>, <strong>pendingOutput</strong>, <strong>pendingError</strong> }</p><p>typedef enum <strong>Family</strong> <strong>Family</strong></p><p>typedef enum <strong>Error</strong> <strong>Error</strong></p><p>typedef enum <strong>Tos</strong> <strong>Tos</strong></p><p>typedef enum <strong>Pending</strong> <strong>Pending</strong></p>
<h3>Public Member Functions</h3>
<p>virtual <strong>~Socket</strong> ()</p><p><em>The socket base class may be 'thrown' as a result of an error, and the 'catcher' may then choose to destroy the object. </em> <strong>Socket</strong> & <strong>operator=</strong> (const <strong>Socket</strong> &from)</p><p><em>Sockets may also be duplicated by the assignment operator. </em> virtual <strong>IPV4Host</strong> <strong>getIPV4Sender</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><em>May be used to examine the origin of data waiting in the socket receive queue. </em> <strong>IPV4Host</strong> <strong>getSender</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p>virtual <strong>IPV6Host</strong> <strong>getIPV6Sender</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><strong>IPV4Host</strong> <strong>getIPV4Peer</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><em>Get the host address and port of the socket this socket is connected to. </em> <strong>IPV4Host</strong> <strong>getPeer</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><strong>IPV6Host</strong> <strong>getIPV6Peer</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><strong>IPV4Host</strong> <strong>getIPV4Local</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><em>Get the local address and port number this socket is currently bound to. </em> <strong>IPV4Host</strong> <strong>getLocal</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><strong>IPV6Host</strong> <strong>getIPV6Local</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><strong>IPV4Host</strong> <strong>getIPV4NAT</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p><em>Perform NAT table lookup for this socket. </em> <strong>IPV4Host</strong> <strong>getNAT</strong> (<strong>tpport_t</strong> *port) const </p><p><strong>IPV6Host</strong> <strong>getIPV6NAT</strong> (<strong>tpport_t</strong> *port=NULL) const </p><p>void <strong>setCompletion</strong> (bool immediate)</p><p><em>Used to specify blocking mode for the socket. </em> <strong>Error</strong> <strong>setLinger</strong> (bool <strong>linger</strong>)</p><p><em>Enable lingering sockets on close. </em> <strong>Error</strong> <strong>setKeepAlive</strong> (bool enable)</p><p><em>Set the keep-alive status of this socket and if keep-alive messages will be sent. </em> <strong>Error</strong> <strong>setTypeOfService</strong> (<strong>Tos</strong> service)</p><p><em>Set packet scheduling on platforms which support ip quality of service conventions. </em> bool <strong>isConnected</strong> (void) const </p><p><em>Can test to see if this socket is 'connected', and hence whether a 'catch' can safely call </em><strong>getPeer()</strong><em>. </em><strong></strong> bool <strong>isActive</strong> (void) const </p><p><em>Test to see if the socket is at least operating or if it is mearly initialized. </em> bool <strong>operator!</strong> () const </p><p><em>Operator based testing to see if a socket is currently active. </em> bool <strong>isBroadcast</strong> (void) const </p><p><em>Return if broadcast has been enabled for the specified socket. </em> bool <strong>isRouted</strong> (void) const </p><p><em>Return if socket routing is enabled. </em> <strong>Error</strong> <strong>getErrorNumber</strong> (void) const </p><p><em>Often used by a 'catch' to fetch the last error of a thrown socket. </em> const char * <strong>getErrorString</strong> (void) const </p><p><em>Often used by a 'catch' to fetch the user set error string of a thrown socket, but only if EXTENDED error codes are used. </em> long <strong>getSystemError</strong> (void) const </p><p>const char * <strong>getSystemErrorString</strong> (void) const </p><p>virtual bool <strong>isPending</strong> (<strong>Pending</strong> pend, <strong>timeout_t</strong> timeout=<strong>TIMEOUT_INF</strong>)</p><p><em>Get the status of pending operations. </em></p>
<h3>Static Public Member Functions</h3>
<p>static bool <strong>check</strong> (<strong>Family</strong> fam)</p><p><em>See if a specific protocol family is available in the current runtime environment. </em></p>
<h3>Protected Types</h3>
<p>enum <strong>State</strong> { <strong>INITIAL</strong>, <strong>AVAILABLE</strong>, <strong>BOUND</strong>, <strong>CONNECTED</strong>, <strong>CONNECTING</strong>, <strong>STREAM</strong> }</p><p>typedef enum <strong>State</strong> <strong>State</strong></p>
<h3>Protected Member Functions</h3>
<p><strong>Error</strong> <strong>error</strong> (<strong>Error</strong> error, const char *err=NULL, long systemError=0) const </p><p><em>This service is used to throw all socket errors which usually occur during the socket constructor. </em> void <strong>error</strong> (const char *err) const </p><p><em>This service is used to throw application defined socket errors where the application specific error code is a string. </em> void <strong>setError</strong> (bool enable)</p><p><em>This service is used to turn the error handler on or off for 'throwing' exceptions by manipulating the thrown flag. </em> void <strong>endSocket</strong> (void)</p><p><em>Used as the default destructor for ending a socket. </em> <strong>Error</strong> <strong>connectError</strong> (void)</p><p><em>Used as a common handler for connection failure processing. </em> <strong>Error</strong> <strong>sendLimit</strong> (int limit=2048)</p><p><em>Set the send limit. </em> <strong>Error</strong> <strong>receiveLimit</strong> (int limit=1)</p><p><em>Set thr receive limit. </em> <strong>Error</strong> <strong>sendTimeout</strong> (<strong>timeout_t</strong> timer)</p><p><em>Set the send timeout for sending raw network data. </em> <strong>Error</strong> <strong>receiveTimeout</strong> (<strong>timeout_t</strong> timer)</p><p><em>Receive timeout for receiving raw network data. </em> <strong>Error</strong> <strong>sendBuffer</strong> (unsigned size)</p><p><em>Set the protocol stack network kernel send buffer size associated with the socket. </em> <strong>Error</strong> <strong>receiveBuffer</strong> (unsigned size)</p><p><em>Set the protocol stack network kernel receive buffer size associated with the socket. </em> <strong>Error</strong> <strong>bufferSize</strong> (unsigned size)</p><p><em>Set the total protocol stack network kernel buffer size for both send and receive together. </em> <strong>Error</strong> <strong>setBroadcast</strong> (bool enable)</p><p><em>Set the subnet broadcast flag for the socket. </em> <strong>Error</strong> <strong>setMulticastByFamily</strong> (bool enable, <strong>Family</strong> family=<strong>IPV4</strong>)</p><p><em>Setting multicast binds the multicast interface used for the socket to the interface the socket itself has been implicitly bound to. </em> <strong>Error</strong> <strong>setLoopbackByFamily</strong> (bool enable, <strong>Family</strong> family=<strong>IPV4</strong>)</p><p><em>Set the multicast loopback flag for the socket. </em> <strong>Error</strong> <strong>setTimeToLiveByFamily</strong> (unsigned char <strong>ttl</strong>, <strong>Family</strong> fam=<strong>IPV4</strong>)</p><p><em>Set the multicast time to live for a multicast socket. </em> <strong>Error</strong> <strong>join</strong> (const <strong>IPV4Multicast</strong> &ia)</p><p><em>Join a multicast group. </em> <strong>Error</strong> <strong>join</strong> (const <strong>IPV6Multicast</strong> &ia)</p><p><strong>Error</strong> <strong>drop</strong> (const <strong>IPV4Multicast</strong> &ia)</p><p><em>Drop membership from a multicast group. </em> <strong>Error</strong> <strong>drop</strong> (const <strong>IPV6Multicast</strong> &ia)</p><p><strong>Error</strong> <strong>setRouting</strong> (bool enable)</p><p><em>Set the socket routing to indicate if outgoing messages should bypass normal routing (set false). </em> <strong>Error</strong> <strong>setNoDelay</strong> (bool enable)</p><p><em>Enable/disable delaying packets (Nagle algorithm) </em> <strong>Socket</strong> (int domain, int type, int protocol=0)</p><p><em>An unconnected socket may be created directly on the local machine. </em> <strong>Socket</strong> (<strong>SOCKET</strong> fd)</p><p><em>A socket object may be created from a file descriptor when that descriptor was created either through a socket() or accept() call. </em> <strong>Socket</strong> ()</p><p><em>Create an inactive socket object for base constructors. </em> <strong>Socket</strong> (const <strong>Socket</strong> &source)</p><p><em>A socket can also be constructed from an already existing </em><strong>Socket</strong><em> object. </em><strong></strong> ssize_t <strong>readLine</strong> (char *buf, size_t len, <strong>timeout_t</strong> timeout=0)</p><p><em></em><strong>Process</strong><em> a logical input line from a socket descriptor directly. </em><strong></strong> virtual ssize_t <strong>readData</strong> (void *buf, size_t len, char separator=0, <strong>timeout_t</strong> t=0)</p><p><em>Read in a block of len bytes with specific separator. </em> virtual ssize_t <strong>writeData</strong> (const void *buf, size_t len, <strong>timeout_t</strong> t=0)</p><p><em>Write a block of len bytes to socket. </em></p>
<h3>Protected Attributes</h3>
<p>struct {</p>
<pre>
   bool <strong>thrown</strong>: 1
</pre>

<pre>
   bool <strong>broadcast</strong>: 1
</pre>

<pre>
   bool <strong>route</strong>: 1
</pre>

<pre>
   bool <strong>keepalive</strong>: 1
</pre>

<pre>
   bool <strong>loopback</strong>: 1
</pre>

<pre>
   bool <strong>multicast</strong>: 1
</pre>

<pre>
   bool <strong>completion</strong>: 1
</pre>

<pre>
   bool <strong>linger</strong>: 1
</pre>

<pre>
   unsigned <strong>ttl</strong>: 8
</pre>
<p>} <strong>flags</strong></p><p><strong>SOCKET</strong> volatile <strong>so</strong></p><p><em>the actual socket descriptor, in Windows, unlike posix it </em><em>cannot</em><em> be used as an file descriptor that way madness lies -- jfc </em><em></em> <strong>State</strong> volatile <strong>state</strong></p>
<h3>Static Protected Attributes</h3>
<p>static <strong>Mutex</strong> <strong>mutex</strong></p>
<h3>Friends</h3>
<p><strong>SOCKET</strong> <strong>dupSocket</strong> (<strong>SOCKET</strong> s, <strong>Socket::State</strong> <strong>state</strong>)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>Socket</strong> is used as the base for all Internet protocol services under Common C++.</p><p>A socket is a system resource (or winsock descriptor) that occupies a specific port address (and may be bound to a specific network interface) on the local machine. The socket may also be directly connected to a specific socket on a remote internet host.</p><p>This base class is not directly used, but is provided to offer properties common to other Common C++ socket classes, including the socket exception model and the ability to set socket properties such as QoS, 'sockopts' properties like Dont-Route and Keep-Alive, etc.</p><p><strong>Author:</strong></p><p>David Sugar dyfet@ostel.com base class of all sockets.</p><p><strong>Examples: </strong> <strong>tcpthread.cpp</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>typedef enum \fBError\fP \fBost::Socket::Error\fP</h3>

<h3>typedef enum \fBFamily\fP \fBost::Socket::Family\fP</h3>

<h3>typedef enum \fBPending\fP \fBost::Socket::Pending\fP</h3>

<h3>typedef enum \fBState\fP \fBost::Socket::State\fP\fC [protected]\fP</h3>

<h3>typedef enum \fBTos\fP \fBost::Socket::Tos\fP</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBost::Socket::Error\fP</h3>
<p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>errSuccess </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errCreateFailed </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errCopyFailed </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errInput </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errInputInterrupt </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errResourceFailure </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errOutput </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errOutputInterrupt </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errNotConnected </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errConnectRefused </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errConnectRejected </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errConnectTimeout </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errConnectFailed </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errConnectInvalid </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errConnectBusy </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errConnectNoRoute </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errBindingFailed </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errBroadcastDenied </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errRoutingDenied </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errKeepaliveDenied </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errServiceDenied </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errServiceUnavailable </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errMulticastDisabled </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errTimeout </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errNoDelay </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errExtended </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errLookupFail </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errSearchErr </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>errInvalidValue </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>enum \fBost::Socket::Family\fP</h3>
<p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>IPV6 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>IPV4 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>enum \fBost::Socket::Pending\fP</h3>
<p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>pendingInput </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>pendingOutput </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>pendingError </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>enum \fBost::Socket::State\fP\fC [protected]\fP</h3>
<p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>INITIAL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>AVAILABLE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>BOUND </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>CONNECTED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>CONNECTING </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>STREAM </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>enum \fBost::Socket::Tos\fP</h3>
<p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>tosLowDelay </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>tosThroughput </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>tosReliability </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>tosMinCost </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>tosInvalid </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>ost::Socket::Socket (intdomain, inttype, intprotocol = \fC0\fP)\fC [protected]\fP</h3>
<p>An unconnected socket may be created directly on the local machine. Sockets can occupy both the internet domain (AF_INET) and UNIX socket domain (AF_UNIX) under unix. The socket type (SOCK_STREAM, SOCK_DGRAM) and protocol may also be specified. If the socket cannot be created, an exception is thrown.</p><p><strong>Parameters:</strong></p><p><em>domain</em> socket domain to use.</p><p><em>type</em> base type and protocol family of the socket.</p><p><em>protocol</em> specific protocol to apply.</p>
<h3>ost::Socket::Socket (\fBSOCKET\fPfd)\fC [protected]\fP</h3>
<p>A socket object may be created from a file descriptor when that descriptor was created either through a socket() or accept() call. This constructor is mostly for internal use.</p><p><strong>Parameters:</strong></p><p><em>fd</em> file descriptor of an already existing socket.</p>
<h3>ost::Socket::Socket ()\fC [protected]\fP</h3>
<p>Create an inactive socket object for base constructors.</p>
<h3>ost::Socket::Socket (const \fBSocket\fP &source)\fC [protected]\fP</h3>
<p>A socket can also be constructed from an already existing <strong>Socket</strong> object. On POSIX systems, the socket file descriptor is dup()'d. On Win32, DuplicateHandle() is used.</p><p><strong>Parameters:</strong></p><p><em>source</em> of existing socket to clone.</p>
<h3>virtual ost::Socket::~Socket ()\fC [virtual]\fP</h3>
<p>The socket base class may be 'thrown' as a result of an error, and the 'catcher' may then choose to destroy the object. By assuring the socket base class is a virtual destructor, we can assure the full object is properly terminated.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBError\fP ost::Socket::bufferSize (unsignedsize)\fC [protected]\fP</h3>
<p>Set the total protocol stack network kernel buffer size for both send and receive together.</p><p><strong>Returns:</strong></p><p>errSuccess on success</p><p><strong>Parameters:</strong></p><p><em>size</em> of buffer.</p>
<h3>static bool ost::Socket::check (\fBFamily\fPfam)\fC [static]\fP</h3>
<p>See if a specific protocol family is available in the current runtime environment.</p><p><strong>Returns:</strong></p><p>true if family available.</p>
<h3>\fBError\fP ost::Socket::connectError (void)\fC [protected]\fP</h3>
<p>Used as a common handler for connection failure processing.</p><p><strong>Returns:</strong></p><p>correct failure code to apply.</p>
<h3>\fBError\fP ost::Socket::drop (const \fBIPV4Multicast\fP &ia)\fC [protected]\fP</h3>
<p>Drop membership from a multicast group.</p><p><strong>Returns:</strong></p><p>0 (errSuccess) on success, else error code.</p><p><strong>Parameters:</strong></p><p><em>ia</em> address of multicast group to drop.</p><p>Referenced by ost::UDPReceive::drop().</p>
<h3>\fBError\fP ost::Socket::drop (const \fBIPV6Multicast\fP &ia)\fC [protected]\fP</h3>

<h3>void ost::Socket::endSocket (void)\fC [protected]\fP</h3>
<p>Used as the default destructor for ending a socket. This will cleanly terminate the socket connection. It is provided for use in derived virtual destructors.</p><p>Referenced by ost::UDPReceive::endReceiver(), and ost::UDPTransmit::endTransmitter().</p>
<h3>\fBError\fP ost::Socket::error (\fBError\fPerror, const char *err = \fCNULL\fP, longsystemError = \fC0\fP) const\fC [protected]\fP</h3>
<p>This service is used to throw all socket errors which usually occur during the socket constructor.</p><p><strong>Parameters:</strong></p><p><em>error</em> defined socket error id.</p><p><em>err</em> string or message to pass.</p><p><em>systemError</em> the system error# that caused the error</p>
<h3>void ost::Socket::error (const char *err) const\fC [inline]\fP, \fC [protected]\fP</h3>
<p>This service is used to throw application defined socket errors where the application specific error code is a string.</p><p><strong>Parameters:</strong></p><p><em>err</em> string or message to pass.</p><p>References ost::error().</p>
<h3>\fBError\fP ost::Socket::getErrorNumber (void) const\fC [inline]\fP</h3>
<p>Often used by a 'catch' to fetch the last error of a thrown socket.</p><p><strong>Returns:</strong></p><p>error number of Error error.</p><p><strong>Examples: </strong> <strong>tcpthread.cpp</strong>.</p>
<h3>const char* ost::Socket::getErrorString (void) const\fC [inline]\fP</h3>
<p>Often used by a 'catch' to fetch the user set error string of a thrown socket, but only if EXTENDED error codes are used.</p><p><strong>Returns:</strong></p><p>string for error message.</p>
<h3>\fBIPV4Host\fP ost::Socket::getIPV4Local (\fBtpport_t\fP *port = \fCNULL\fP) const</h3>
<p>Get the local address and port number this socket is currently bound to.</p><p><strong>Parameters:</strong></p><p><em>port</em> ptr to port number on local host.</p><p><strong>Returns:</strong></p><p>host address of interface this socket is bound to.</p><p>Referenced by ost::TCPSocket::getLocal().</p>
<h3>\fBIPV4Host\fP ost::Socket::getIPV4NAT (\fBtpport_t\fP *port = \fCNULL\fP) const</h3>
<p>Perform NAT table lookup for this socket. Used to allow an application to know the original ip:port pair the the client 'thinks' it is connecting to. Used mostly to transparently impersonate a remote server/service.</p><p>On error, 0.0.0.0:0 is returned and one of the following error codes is set: errServiceUnavailable - if nat is not supported on the current platform or if it was not compiled; errLookupFail - if the nat syscall failed for some reason (extended error code); errSearchErr - if the socket does not have nat information (i.e. is not nated).</p><p>NAT lookup is supported on NetFilter for ipv4 and ipv6 (Linux), IPFilter for ipv4 (Solaris, *BSD except OpenBSD, HP-UX, etc.) and Packet Filter for ipv4 and ipv6 (OpenBSD). When using IPFilter or Packet Filter, the first NAT lookup must be performed as root (the NAT device is read only for root and is opened once, unless an error occurs). Permissions on the nat device may be changed to solve this.</p><p><strong>Warning:</strong></p><p>When using IPFilter and Packet Filter, application data model must be the same as the running kernel (32/64 bits).</p><p><strong>Parameters:</strong></p><p><em>port</em> ptr to NATed port number on local host.</p><p><strong>Returns:</strong></p><p>NATed host address that this socket is related to.</p>
<h3>\fBIPV4Host\fP ost::Socket::getIPV4Peer (\fBtpport_t\fP *port = \fCNULL\fP) const</h3>
<p>Get the host address and port of the socket this socket is connected to. If the socket is currently not in a connected state, then a host address of 0.0.0.0 is returned.</p><p><strong>Parameters:</strong></p><p><em>port</em> ptr to port number of remote socket.</p><p><strong>Returns:</strong></p><p>host address of remote socket.</p>
<h3>virtual \fBIPV4Host\fP ost::Socket::getIPV4Sender (\fBtpport_t\fP *port = \fCNULL\fP) const\fC [virtual]\fP</h3>
<p>May be used to examine the origin of data waiting in the socket receive queue. This can tell a TCP server where pending 'connect' requests are coming from, or a UDP socket where it's next packet arrived from.</p><p><strong>Parameters:</strong></p><p><em>port</em> ptr to port number of sender.</p><p><strong>Returns:</strong></p><p>host address, test with 'isInetAddress()'.</p><p>Reimplemented in <strong>ost::DCCPSocket</strong>.</p><p>Referenced by ost::TCPSocket::getRequest().</p>
<h3>\fBIPV6Host\fP ost::Socket::getIPV6Local (\fBtpport_t\fP *port = \fCNULL\fP) const</h3>
<p>Referenced by ost::TCPV6Socket::getLocal().</p>
<h3>\fBIPV6Host\fP ost::Socket::getIPV6NAT (\fBtpport_t\fP *port = \fCNULL\fP) const</h3>

<h3>\fBIPV6Host\fP ost::Socket::getIPV6Peer (\fBtpport_t\fP *port = \fCNULL\fP) const</h3>

<h3>virtual \fBIPV6Host\fP ost::Socket::getIPV6Sender (\fBtpport_t\fP *port = \fCNULL\fP) const\fC [virtual]\fP</h3>
<p>Reimplemented in <strong>ost::DCCPSocket</strong>.</p><p>Referenced by ost::TCPV6Socket::getRequest().</p>
<h3>\fBIPV4Host\fP ost::Socket::getLocal (\fBtpport_t\fP *port = \fCNULL\fP) const\fC [inline]\fP</h3>

<h3>\fBIPV4Host\fP ost::Socket::getNAT (\fBtpport_t\fP *port) const\fC [inline]\fP</h3>

<h3>\fBIPV4Host\fP ost::Socket::getPeer (\fBtpport_t\fP *port = \fCNULL\fP) const\fC [inline]\fP</h3>
<p><strong>Examples: </strong> <strong>tcp.cpp</strong>, and <strong>tcpthread.cpp</strong>.</p>
<h3>\fBIPV4Host\fP ost::Socket::getSender (\fBtpport_t\fP *port = \fCNULL\fP) const\fC [inline]\fP</h3>

<h3>long ost::Socket::getSystemError (void) const\fC [inline]\fP</h3>

<h3>const char* ost::Socket::getSystemErrorString (void) const</h3>

<h3>bool ost::Socket::isActive (void) const</h3>
<p>Test to see if the socket is at least operating or if it is mearly initialized. 'initialized' sockets may be the result of failed constructors.</p><p><strong>Returns:</strong></p><p>true if not in initial state.</p>
<h3>bool ost::Socket::isBroadcast (void) const\fC [inline]\fP</h3>
<p>Return if broadcast has been enabled for the specified socket.</p><p><strong>Returns:</strong></p><p>true if broadcast socket.</p>
<h3>bool ost::Socket::isConnected (void) const</h3>
<p>Can test to see if this socket is 'connected', and hence whether a 'catch' can safely call <strong>getPeer()</strong>. Of course, an unconnected socket will return a 0.0.0.0 address from <strong>getPeer()</strong> as well.</p><p><strong>Returns:</strong></p><p>true when socket is connected to a peer.</p>
<h3>virtual bool ost::Socket::isPending (\fBPending\fPpend, \fBtimeout_t\fPtimeout = \fC\fBTIMEOUT_INF\fP\fP)\fC [virtual]\fP</h3>
<p>Get the status of pending operations. This can be used to examine if input or output is waiting, or if an error has occured on the descriptor.</p><p><strong>Returns:</strong></p><p>true if ready, false on timeout.</p><p><strong>Parameters:</strong></p><p><em>pend</em> ready check to perform.</p><p><em>timeout</em> in milliseconds, inf. if not specified.</p><p>Reimplemented in <strong>ost::SimpleTCPStream</strong>, <strong>ost::TCPStream</strong>, and <strong>ost::UnixStream</strong>.</p><p>Referenced by ost::UDPReceive::isInputReady(), ost::UDPTransmit::isOutputReady(), ost::UnixSocket::isPendingConnection(), ost::DCCPSocket::isPendingConnection(), ost::TCPSocket::isPendingConnection(), ost::TCPV6Socket::isPendingConnection(), and ost::UDPReceive::isPendingReceive().</p>
<h3>bool ost::Socket::isRouted (void) const\fC [inline]\fP</h3>
<p>Return if socket routing is enabled.</p><p><strong>Returns:</strong></p><p>true if routing enabled.</p>
<h3>\fBError\fP ost::Socket::join (const \fBIPV4Multicast\fP &ia)\fC [protected]\fP</h3>
<p>Join a multicast group.</p><p><strong>Returns:</strong></p><p>0 (errSuccess) on success, else error code.</p><p><strong>Parameters:</strong></p><p><em>ia</em> address of multicast group to join.</p><p>Referenced by ost::UDPReceive::join().</p>
<h3>\fBError\fP ost::Socket::join (const \fBIPV6Multicast\fP &ia)\fC [protected]\fP</h3>

<h3>bool ost::Socket::operator! () const</h3>
<p>Operator based testing to see if a socket is currently active.</p>
<h3>\fBSocket\fP& ost::Socket::operator= (const \fBSocket\fP &from)</h3>
<p>Sockets may also be duplicated by the assignment operator.</p>
<h3>virtual ssize_t ost::Socket::readData (void *buf, size_tlen, charseparator = \fC0\fP, \fBtimeout_t\fPt = \fC0\fP)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Read in a block of len bytes with specific separator. Can be zero, or any other char. If &#92;n or &#92;r, it's treated just like a <strong>readLine()</strong>. Otherwise it looks for the separator.</p><p><strong>Parameters:</strong></p><p><em>buf</em> pointer to byte allocation.</p><p><em>len</em> maximum length to read.</p><p><em>separator</em> separator for a particular ASCII character</p><p><em>t</em> timeout for pending data in milliseconds.</p><p><strong>Returns:</strong></p><p>number of bytes actually read.</p><p>Reimplemented in <strong>ost::SSLStream</strong>.</p>
<h3>ssize_t ost::Socket::readLine (char *buf, size_tlen, \fBtimeout_t\fPtimeout = \fC0\fP)\fC [protected]\fP</h3>
<p><strong>Process</strong> a logical input line from a socket descriptor directly.</p><p><strong>Parameters:</strong></p><p><em>buf</em> pointer to string.</p><p><em>len</em> maximum length to read.</p><p><em>timeout</em> for pending data in milliseconds.</p><p><strong>Returns:</strong></p><p>number of bytes actually read.</p>
<h3>\fBError\fP ost::Socket::receiveBuffer (unsignedsize)\fC [protected]\fP</h3>
<p>Set the protocol stack network kernel receive buffer size associated with the socket.</p><p><strong>Returns:</strong></p><p>errSuccess on success, or error.</p><p><strong>Parameters:</strong></p><p><em>size</em> of buffer in bytes.</p>
<h3>\fBError\fP ost::Socket::receiveLimit (intlimit = \fC1\fP)\fC [protected]\fP</h3>
<p>Set thr receive limit.</p>
<h3>\fBError\fP ost::Socket::receiveTimeout (\fBtimeout_t\fPtimer)\fC [protected]\fP</h3>
<p>Receive timeout for receiving raw network data.</p><p><strong>Returns:</strong></p><p>errSuccess if set.</p><p><strong>Parameters:</strong></p><p><em>timer</em> value in milliseconds.</p>
<h3>\fBError\fP ost::Socket::sendBuffer (unsignedsize)\fC [protected]\fP</h3>
<p>Set the protocol stack network kernel send buffer size associated with the socket.</p><p><strong>Returns:</strong></p><p>errSuccess on success, or error.</p><p><strong>Parameters:</strong></p><p><em>size</em> of buffer in bytes.</p>
<h3>\fBError\fP ost::Socket::sendLimit (intlimit = \fC2048\fP)\fC [protected]\fP</h3>
<p>Set the send limit.</p>
<h3>\fBError\fP ost::Socket::sendTimeout (\fBtimeout_t\fPtimer)\fC [protected]\fP</h3>
<p>Set the send timeout for sending raw network data.</p><p><strong>Returns:</strong></p><p>errSuccess if set.</p><p><strong>Parameters:</strong></p><p><em>timer</em> value in millisec.</p>
<h3>\fBError\fP ost::Socket::setBroadcast (boolenable)\fC [protected]\fP</h3>
<p>Set the subnet broadcast flag for the socket. This enables sending to a subnet and may require special image privileges depending on the operating system.</p><p><strong>Returns:</strong></p><p>0 (errSuccess) on success, else error code.</p><p><strong>Parameters:</strong></p><p><em>enable</em> when set to true.</p><p>Referenced by ost::UDPTransmit::setBroadcast().</p>
<h3>void ost::Socket::setCompletion (boolimmediate)</h3>
<p>Used to specify blocking mode for the socket. A socket can be made non-blocking by setting setCompletion(false) or set to block on all access with setCompletion(true). I do not believe this form of non-blocking socket I/O is supported in winsock, though it provides an alternate asynchronous set of socket services.</p><p><strong>Parameters:</strong></p><p><em>immediate</em> mode specify socket I/O call blocking mode.</p>
<h3>void ost::Socket::setError (boolenable)\fC [inline]\fP, \fC [protected]\fP</h3>
<p>This service is used to turn the error handler on or off for 'throwing' exceptions by manipulating the thrown flag.</p><p><strong>Parameters:</strong></p><p><em>enable</em> true to enable handler.</p>
<h3>\fBError\fP ost::Socket::setKeepAlive (boolenable)</h3>
<p>Set the keep-alive status of this socket and if keep-alive messages will be sent.</p><p><strong>Returns:</strong></p><p>0 on success.</p><p><strong>Parameters:</strong></p><p><em>enable</em> keep alive messages.</p>
<h3>\fBError\fP ost::Socket::setLinger (boollinger)</h3>
<p>Enable lingering sockets on close.</p><p><strong>Parameters:</strong></p><p><em>linger</em> specify linger enable.</p>
<h3>\fBError\fP ost::Socket::setLoopbackByFamily (boolenable, \fBFamily\fPfamily = \fC\fBIPV4\fP\fP)\fC [protected]\fP</h3>
<p>Set the multicast loopback flag for the socket. Loopback enables a socket to hear what it is sending.</p><p><strong>Returns:</strong></p><p>0 (errSuccess) on success, else error code.</p><p><strong>Parameters:</strong></p><p><em>enable</em> when set to true.</p><p><em>family</em> of protocol.</p><p>Referenced by ost::UDPSocket::setLoopback().</p>
<h3>\fBError\fP ost::Socket::setMulticastByFamily (boolenable, \fBFamily\fPfamily = \fC\fBIPV4\fP\fP)\fC [protected]\fP</h3>
<p>Setting multicast binds the multicast interface used for the socket to the interface the socket itself has been implicitly bound to. It is also used as a check flag to make sure multicast is enabled before multicast operations are used.</p><p><strong>Returns:</strong></p><p>0 (errSuccess) on success, else error code.</p><p><strong>Parameters:</strong></p><p><em>enable</em> when set to true.</p><p><em>family</em> of protocol.</p><p>Referenced by ost::UDPSocket::setMulticast(), ost::UDPTransmit::setMulticast(), and ost::UDPReceive::setMulticast().</p>
<h3>\fBError\fP ost::Socket::setNoDelay (boolenable)\fC [protected]\fP</h3>
<p>Enable/disable delaying packets (Nagle algorithm)</p><p><strong>Returns:</strong></p><p>0 on success.</p><p><strong>Parameters:</strong></p><p><em>enable</em> disable Nagle algorithm when set to true.</p>
<h3>\fBError\fP ost::Socket::setRouting (boolenable)\fC [protected]\fP</h3>
<p>Set the socket routing to indicate if outgoing messages should bypass normal routing (set false).</p><p><strong>Returns:</strong></p><p>0 on success.</p><p><strong>Parameters:</strong></p><p><em>enable</em> normal routing when set to true.</p><p>Referenced by ost::UDPTransmit::setRouting(), and ost::UDPReceive::setRouting().</p>
<h3>\fBError\fP ost::Socket::setTimeToLiveByFamily (unsigned charttl, \fBFamily\fPfam = \fC\fBIPV4\fP\fP)\fC [protected]\fP</h3>
<p>Set the multicast time to live for a multicast socket.</p><p><strong>Returns:</strong></p><p>0 (errSuccess) on success, else error code.</p><p><strong>Parameters:</strong></p><p><em>ttl</em> time to live.</p><p><em>fam</em> family of protocol.</p><p>Referenced by ost::UDPSocket::setTimeToLive(), and ost::UDPTransmit::setTimeToLive().</p>
<h3>\fBError\fP ost::Socket::setTypeOfService (\fBTos\fPservice)</h3>
<p>Set packet scheduling on platforms which support ip quality of service conventions. This effects how packets in the queue are scheduled through the interface.</p><p><strong>Returns:</strong></p><p>0 on success, error code on failure.</p><p><strong>Parameters:</strong></p><p><em>service</em> type of service enumerated type.</p><p>Referenced by ost::UDPTransmit::setTypeOfService().</p>
<h3>virtual ssize_t ost::Socket::writeData (const void *buf, size_tlen, \fBtimeout_t\fPt = \fC0\fP)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Write a block of len bytes to socket.</p><p><strong>Parameters:</strong></p><p><em>buf</em> pointer to byte allocation.</p><p><em>len</em> maximum length to write.</p><p><em>t</em> timeout for pending data in milliseconds.</p><p><strong>Returns:</strong></p><p>number of bytes actually written.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Friends And Related Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSOCKET\fP dupSocket (\fBSOCKET\fPs, \fBSocket::State\fPstate)\fC [friend]\fP</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>bool ost::Socket::broadcast</h3>

<h3>bool ost::Socket::completion</h3>

<h3>struct { ... }   ost::Socket::flags\fC [protected]\fP</h3>

<h3>bool ost::Socket::keepalive</h3>

<h3>bool ost::Socket::linger</h3>

<h3>bool ost::Socket::loopback</h3>

<h3>bool ost::Socket::multicast</h3>

<h3>\fBMutex\fP ost::Socket::mutex\fC [static]\fP, \fC [protected]\fP</h3>

<h3>bool ost::Socket::route</h3>

<h3>\fBSOCKET\fP volatile ost::Socket::so\fC [protected]\fP</h3>
<p>the actual socket descriptor, in Windows, unlike posix it <em>cannot</em> be used as an file descriptor that way madness lies -- jfc</p>
<h3>\fBState\fP volatile ost::Socket::state\fC [protected]\fP</h3>

<h3>bool ost::Socket::thrown</h3>

<h3>unsigned ost::Socket::ttl</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for GNU CommonC++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ost_Slog.3.html"><span aria-hidden="true">&larr;</span> ost_Slog.3: The slog class is used to stream messages to the system's logging facility (syslogd).</a></li>
   <li class="next"><a href="ost_SocketPort.3.html">ost_SocketPort.3: The socket port is an internal class which is attached to and then serviced by a specific socketservice 'object'. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

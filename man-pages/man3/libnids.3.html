<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libnids: Network intrusion detection system e-box library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Network intrusion detection system e-box library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libnids (3) manual">
  <meta name="twitter:description" content="Network intrusion detection system e-box library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libnids-dev-libnids-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libnids.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libnids (3) manual" />
  <meta property="og:description" content="Network intrusion detection system e-box library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libnids-dev-libnids-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libnids<small> (3)</small></h1>
        <p class="lead">Network intrusion detection system e-box library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libnids.3.html">
      <span itemprop="name">libnids: Network intrusion detection system e-box library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libnids-dev/">
      <span itemprop="name">libnids-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libnids.3.html">
      <span itemprop="name">libnids: Network intrusion detection system e-box library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;nids.h&gt;

extern struct nids_prm <em>nids_params</em>;
extern char <em>nids_errbuf</em>[];

int
<strong>nids_init</strong>(void);

void
<strong>nids_register_ip_frag</strong>(void (*ip_frag_func)(struct ip *pkt, int len));

void
<strong>nids_unregister_ip_frag</strong>(void (*ip_frag_func)(struct ip *pkt, int len));

void
<strong>nids_register_ip</strong>(void (*ip_func)(struct ip *pkt, int len));

void
<strong>nids_unregister_ip</strong>(void (*ip_func)(struct ip *pkt, int len));

void
<strong>nids_register_udp</strong>(void (*udp_func)(struct tuple4 *addr, u_char *data, int len, struct ip *pkt));

void
<strong>nids_unregister_udp</strong>(void (*udp_func)(struct tuple4 *addr, u_char *data, int len, struct ip *pkt));

void
<strong>nids_register_tcp</strong>(void (*tcp_func)(struct tcp_stream *ts, void **param));

void
<strong>nids_unregister_tcp</strong>(void (*tcp_func)(struct tcp_stream *ts, void **param));

void
<strong>nids_killtcp</strong>(struct tcp_stream *ts);

void
<strong>nids_discard</strong>(struct tcp_stream *ts, int numbytes);

void
<strong>nids_run</strong>(void);

int
<strong>nids_dispatch</strong>(int cnt);

int
<strong>nids_next</strong>(void);

int
<strong>nids_getfd</strong>(void);

void
<strong>nids_register_chksum_ctl</strong>(struct nids_chksum_ctl *, int);

void
<strong>nids_pcap_handler</strong>(u_char *par, struct pcap_pkthdr *hdr, u_char *data);

struct tcp_stream *
<strong>nids_find_tcp_stream</strong>(struct tuple4 *addr);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>libnids</strong> provides the functionality of a network intrusion detection system (NIDS) E-box component. It currently performs:</p>
<pre>
	1. IP defragmentation
	2. TCP stream reassembly
	3. TCP port scan detection
</pre>
<p><strong>libnids</strong> performs TCP/IP reassembly in exactly the same way as Linux 2.0.36 kernels, and correctly handles all of the attacks implemented in <strong>fragrouter</strong>(8) (plus many other attacks as well).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ROUTINES</h2>
        <div class="sectioncontent">
<p><strong>nids_init</strong>() initializes the application for sniffing, based on the values set in the global variable <em>nids_params</em>, declared as follows:</p>
<pre>
struct nids_prm {
	int	n_tcp_streams;
	int	n_hosts;
	char	*device;
	char	*filename;
	int	sk_buff_size;
	int	dev_addon;
	void	(*syslog)(int type, int err, struct ip *iph, void *data);
	int	syslog_level;
	int	scan_num_hosts;
	int	scan_num_ports;
	int	scan_delay;
	void	(*no_mem)(void);
	int	(*ip_filter)(struct ip *iph);
	char	*pcap_filter;
	int	promisc;
	int	one_loop_less;
	int	pcap_timeout;
	int	multiproc;
	int	queue_limit;
	int	tcp_workarounds;
	pcap_t	*pcap_desc;
} nids_params;
</pre>
<p>The members of this structure are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>n_tcp_streams</em></p>
  </dt>
  <dd>
    <p>Size of the hash table used for storing TCP connection information ( a maximum of 3/4 * <em>n_tcp_streams</em> TCP connections will be followed simultaneously). Default value: 1024</p>
  </dd>
  <dt>
    <p><em>n_hosts</em></p>
  </dt>
  <dd>
    <p>Size of the hash table used for storing IP defragmentation information. Default value: 256</p>
  </dd>
  <dt>
    <p><em>filename</em></p>
  </dt>
  <dd>
    <p>It this variable is set, libnids will call pcap_open_offline with this variable as the argument (instead of pcap_open_live()). Default value: NULL</p>
  </dd>
  <dt>
    <p><em>device</em></p>
  </dt>
  <dd>
    <p>Interface to monitor. Default value: NULL (in which case an appropriate device is determined automatically). If this variable is assigned value <strong>all</strong>, libnids will attempt to capture packets on all interfaces (which works on Linux only)</p>
  </dd>
  <dt>
    <p><em>sk_buff_size</em></p>
  </dt>
  <dd>
    <p>Size of <em>struct sk_buff</em> (used for queuing packets), which should be set to match the value on the hosts being monitored. Default value: 168</p>
  </dd>
  <dt>
    <p><em>dev_addon</em></p>
  </dt>
  <dd>
    <p>Number of bytes in <em>struct sk_buff</em> reserved for link-layer information. Default value: -1 (in which case an appropriate offset if determined automatically based on link-layer type)</p>
  </dd>
  <dt>
    <p><em>syslog</em></p>
  </dt>
  <dd>
    <p>Syslog callback function, used to report unusual conditions, such as port scan attempts, invalid TCP header flags, etc. Default value: <em>nids_syslog</em> (which logs messages via <a href="../man3/syslog.3.html"><strong>syslog</strong>(3)</a> without regard for message rate per second or free disk space)</p>
  </dd>
  <dt>
    <p><em>syslog_level</em></p>
  </dt>
  <dd>
    <p>Log level used by <em>nids_syslog</em> for reporting events via <a href="../man3/syslog.3.html"><strong>syslog</strong>(3)</a>. Default value: LOG_ALERT</p>
  </dd>
  <dt>
    <p><em>scan_num_hosts</em></p>
  </dt>
  <dd>
    <p>Size of hash table used for storing portscan information (the maximum number portscans that will be detected simultaneously). If set to 0, portscan detection will be disabled. Default value: 256</p>
  </dd>
  <dt>
    <p><em>scan_num_ports</em></p>
  </dt>
  <dd>
    <p>Minimum number of ports that must be scanned from the same source host before it is identifed as a portscan. Default value: 10</p>
  </dd>
  <dt>
    <p><em>scan_delay</em></p>
  </dt>
  <dd>
    <p>Maximum delay (in milliseconds) between connections to different ports for them to be identified as part of a portscan. Default value: 3000</p>
  </dd>
  <dt>
    <p><em>no_mem</em></p>
  </dt>
  <dd>
    <p>Out-of-memory callback function, used to terminate the calling process gracefully.</p>
  </dd>
  <dt>
    <p><em>ip_filter</em></p>
  </dt>
  <dd>
    <p>IP filtering callback function, used to selectively discard IP packets, inspected after reassembly. If the function returns a non-zero value, the packet is processed; otherwise, it is discarded. Default value: <em>nids_ip_filter</em> (which always returns 1)</p>
  </dd>
  <dt>
    <p><em>pcap_filter</em></p>
  </dt>
  <dd>
    <p><strong>pcap</strong>(3) filter string applied to the link-layer (raw, unassembled) packets. <strong>Note</strong>: filters like ``tcp dst port 23'' will NOT correctly handle appropriately fragmented traffic, e.g. 8-byte IP fragments; one should add "or (ip[6:2] & 0x1fff != 0)" at the end of the filter to process reassembled packets. Default value: NULL</p>
  </dd>
  <dt>
    <p><em>promisc</em></p>
  </dt>
  <dd>
    <p>If non-zero, libnids will set the interface(s) it listens on to promiscuous mode. Default value: 1</p>
  </dd>
  <dt>
    <p><em>one_loop_less</em></p>
  </dt>
  <dd>
    <p>Disabled by default; see comments in API.html file</p>
  </dd>
  <dt>
    <p><em>pcap_timeout</em></p>
  </dt>
  <dd>
    <p>Sets the pcap read timeout, which may or may not be supported by your platform.  Default value: 1024.</p>
  </dd>
  <dt>
    <p><em>multiproc</em></p>
  </dt>
  <dd>
    <p>If nonzero, creates a separate thread for packets processing. See API.html. Default value: 0.</p>
  </dd>
  <dt>
    <p><em>queue_limit</em></p>
  </dt>
  <dd>
    <p>If multiproc is nonzero, this is the maximum number of packets queued in the thread which reads packets from libpcap. Default value: 20000</p>
  </dd>
  <dt>
    <p><em>tcp_workarounds</em></p>
  </dt>
  <dd>
    <p>Enables extra checks for faulty implementations of TCP such as the ones which allow connections to be closed despite the fact that there should be retransmissions for lost packets first (as stated by RFC 793, section 3.5). If non-zero, libnids will set the NIDS_TIMED_OUT state for savagely closed connections. Default value: 0</p>
  </dd>
  <dt>
    <p><em>pcap_desc</em></p>
  </dt>
  <dd>
    <p>It this variable is set, libnids will call neither pcap_open_live nor pcap_open_offline, but will use a pre-opened PCAP descriptor; use this with nids_pcap_handler() in order to interactively feed packets to libnids. Default value: NULL</p>
  </dd>

</dl>
<p>Returns 1 on success, 0 on failure (in which case <strong>nids_errbuf</strong> contains an appropriate error message).</p><p><strong>nids_register_ip_frag</strong>() registers a user-defined callback function to process all incoming IP packets (including IP fragments, packets with invalid checksums, etc.).</p><p><strong>nids_unregister_ip_frag</strong>() unregisters a user-defined callback function to process all incoming IP packets.</p><p><strong>nids_register_ip</strong>() registers a user-defined callback function to process IP packets validated and reassembled by <strong>libnids</strong>.</p><p><strong>nids_unregister_ip</strong>() unregisters a user-defined callback function to process IP packets.</p><p><strong>nids_register_udp</strong>() registers a user-defined callback function to process UDP packets validated and reassembled by <strong>libnids</strong>.</p><p><strong>nids_unregister_udp</strong>() unregisters a user-defined callback function to process UDP packets.</p><p><strong>nids_register_tcp</strong>() registers a user-defined callback function to process TCP streams validated and reassembled by <strong>libnids</strong>. The <em>tcp_stream</em> structure is defined as follows:</p>
<pre>
struct tcp_stream {
	struct tuple4 {
		u_short source;
		u_short	dest;
		u_int	saddr;
		u_int	daddr;
	} addr;
	char			nids_state;
	struct half_stream {
		char	state;
		char	collect;
		char	collect_urg;
		char	*data;
		u_char	urgdata;
		int	count;
		int	offset;
		int	count_new;
		char	count_new_urg;
		...
	} client;
	struct half_stream	server;
	...
	void			*user;
};
</pre>
<p>The members of the <em>tuple4</em> structure identify a unique TCP connection:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>source</em>, <em>dest</em></p>
  </dt>
  <dd>
    <p>Client and server port numbers</p>
  </dd>
  <dt>
    <p><em>saddr</em>, <em>daddr</em></p>
  </dt>
  <dd>
    <p>Client and server IP addresses</p>
  </dd>

</dl>
<p>The members of the <em>half_stream</em> structure describe each half of a TCP connection (client and server):</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>state</em></p>
  </dt>
  <dd>
    <p>Socket state (e.g. TCP_ESTABLISHED).</p>
  </dd>
  <dt>
    <p><em>collect</em></p>
  </dt>
  <dd>
    <p>A boolean which specifies whether to collect data for this half of the connection in the <em>data</em> buffer.</p>
  </dd>
  <dt>
    <p><em>collect_urg</em></p>
  </dt>
  <dd>
    <p>A boolean which specifies whether to collect urgent data pointed to by the TCP urgent pointer for this half of the connection in the <em>urgdata</em> buffer.</p>
  </dd>
  <dt>
    <p><em>data</em></p>
  </dt>
  <dd>
    <p>Buffer for normal data.</p>
  </dd>
  <dt>
    <p><em>urgdata</em></p>
  </dt>
  <dd>
    <p>One-byte buffer for urgent data.</p>
  </dd>
  <dt>
    <p><em>count</em></p>
  </dt>
  <dd>
    <p>The number of bytes appended to <em>data</em> since the creation of the connection.</p>
  </dd>
  <dt>
    <p><em>offset</em></p>
  </dt>
  <dd>
    <p>The current offset from the first byte stored in the <em>data</em> buffer, identifying the start of newly received data.</p>
  </dd>
  <dt>
    <p><em>count_new</em></p>
  </dt>
  <dd>
    <p>The number of bytes appended to <em>data</em> since the last invocation of the TCP callback function (if 0, no new data arrived).</p>
  </dd>
  <dt>
    <p><em>count_new_urg</em></p>
  </dt>
  <dd>
    <p>The number of bytes appended to <em>urgdata</em> since the last invocation of the TCP callback function (if 0, no new urgent data arrived).</p>
  </dd>

</dl>
<p>The value of the <em>nids_state</em> field provides information about the state of the TCP connection, to be used by the TCP callback function:</p>
<dl class='dl-vertical'>
  <dt>
    <p>NIDS_JUST_EST</p>
  </dt>
  <dd>
    <p>Connection just established. Connection parameters in the <em>addr</em> structure are available for inspection. If the connection is interesting, the TCP callback function may specify which data it wishes to receive in the future by setting non-zero values for the <em>collect</em> or <em>collect_urg</em> variables in the appropriate <em>client</em> or <em>server</em> half_stream structure members.</p>
  </dd>
  <dt>
    <p>NIDS_DATA</p>
  </dt>
  <dd>
    <p>New data has arrived on a connection. The <em>half_stream</em> structures contain buffers of data.</p>
  </dd>
  <dt>
    <p>NIDS_CLOSE, NIDS_RESET, NIDS_TIMED_OUT</p>
  </dt>
  <dd>
    <p>Connection has closed. The TCP callback function should free any resources it may have allocated for this connection.</p>
  </dd>

</dl>
<p>The <em>param</em> pointer passed by libnids as argument to the TCP callback function may be set to save a pointer to user-defined connection-specific data to pass to subsequent invocations of the TCP callback function (ex. the current working directory for an FTP control connection, etc.).</p><p>The <em>user</em> pointer in the tcp_stream structure has the same purpose except it is global to the stream, whereas the <em>param</em> pointer is different from one callback function to the other even though they were called for the same stream.</p><p><strong>nids_unregister_tcp</strong>() unregisters a user-defined callback function to process TCP streams.</p><p><strong>nids_killtcp</strong>() tears down the specified TCP connection with symmetric RST packets between client and server.</p><p><strong>nids_discard</strong>() may be called from the TCP callback function to specify the number of bytes to discard from the beginning of the <em>data</em> buffer (updating the <em>offset</em> value accordingly) after the TCP callback function exits. Otherwise, the new data (totalling <em>count_new</em> bytes) will be discarded by default.</p><p><strong>nids_run</strong>() starts the packet-driven application, reading packets in an endless loop, and invoking registered callback functions to handle new data as it arrives. This function does not return.</p><p><strong>nids_dispatch</strong>() attempts to process <strong>cnt</strong> packets before returning, with a cnt of -1 understood as all packets available in one pcap buffer, or all packets in a file when reading offline.  On success, returns the count of packets processed, which may be zero upon EOF (offline read) or upon hitting <em>pcap_timeout</em> (if supported by your platform).  On failure, returns -1, putting an appropriate error message in <strong>nids_errbuf</strong>.</p><p><strong>nids_next</strong>() process the next available packet before returning.  Returns 1 on success, 0 if no packet was processed, setting <strong>nids_effbuf</strong> appropriately if an error prevented packet processing.</p><p><strong>nids_getfd</strong>() may be used by an application sleeping in <a href="../man2/select.2.html"><strong>select</strong>(2)</a> to snoop for a socket file descriptor present in the read fd_set. Returns the file descriptor on success, -1 on failure (in which case <strong>nids_errbuf</strong> contains an appropriate error message).</p><p><strong>nids_register_chksum_ctl</strong>() takes as arguments an array of <em>struct nids_chksum_ctl</em> elements and the number of elements in the array.  A <em>nids_chksum_ctl</em> element is defined as follows:</p>
<pre>
struct nids_chksum_ctl {
	u_int netaddr;
	u_int mask;
	u_int action;
	/* private members */
};
</pre>
<p>Internal checksumming functions will first check elements of this array one by one, and if the source ip SRCIP of the current packet satisfies condition</p>
<pre>
       (SRCIP&chksum_ctl_array[i].mask)==chksum_ctl_array[i].netaddr
</pre>
<p>then if  the <em>action</em> field is <strong>NIDS_DO_CHKSUM</strong>, the packet will be checksummed; if the <em>action</em> field is <strong>NIDS_DONT_CHKSUM</strong>, the packet will not be checksummed.  If the packet matches none of the array elements, the default action is to perform checksumming.</p><p><strong>nids_pcap_handler</strong>() may be used by an application already running a capture with libpcap, in order to pass frames to libnids interactively (frame per frame) instead of having libnids itself do the capture.</p><p><strong>nids_find_tcp_stream</strong>() returns a pointer to the tcp_stream structure corresponding to the tuple passed as argument if libnids knows about this TCP connection already, otherwise it returns NULL.</p><p><strong>nids_free_tcp_stream</strong>() removes the given tcp_stream from the list of streams tracked by libnids. Warning: its usage can result in crashes! See comments in the API.html file.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libnids&hellip;</h2>
        <div class="sectioncontent">
<p><strong>pcap</strong>(3), <strong>libnet</strong>(3), <strong>fragrouter</strong>(8)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Rafal Wojtczuk &lt;nergal@icm.edu.pl&gt;</p><p>Manpage by Dug Song &lt;dugsong@monkey.org&gt;, minor updates by Michael Pomraning &lt;mjp@pilcrow.madison.wi.us&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libnetlink.3.html"><span aria-hidden="true">&larr;</span> libnetlink.3: A library for accessing the netlink service</a></li>
   <li class="next"><a href="libnuclient.3.html">libnuclient.3: Nufw client authentication library <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

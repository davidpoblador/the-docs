<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Config::Scoped: Feature rich configuration file parser</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Feature rich configuration file parser">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Config::Scoped (3pm) manual">
  <meta name="twitter:description" content="Feature rich configuration file parser">
  <meta name="twitter:image" content="https://www.carta.tech/images/libconfig-scoped-perl-Config::Scoped-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Config::Scoped.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Config::Scoped (3pm) manual" />
  <meta property="og:description" content="Feature rich configuration file parser" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libconfig-scoped-perl-Config::Scoped-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Config::Scoped<small> (3pm)</small></h1>
        <p class="lead">Feature rich configuration file parser</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Config::Scoped.3pm.html">
      <span itemprop="name">Config::Scoped: Feature rich configuration file parser</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libconfig-scoped-perl/">
      <span itemprop="name">libconfig-scoped-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Config::Scoped.3pm.html">
      <span itemprop="name">Config::Scoped: Feature rich configuration file parser</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Config::Scoped;

  $cs = Config::Scoped-&gt;new( file =&gt; $config_file, ... );
  $cfg_hash = $cs-&gt;parse;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ABSTRACT</h2>
        <div class="sectioncontent">
<p><strong>Config::Scoped</strong> is a configuration file parser.</p><h3>Features</h3>
<ul>
<li><p>recursive data structures with scalars, lists, and hashes</p></li><li><p>simplified syntax with minimal punctuation</p></li><li><p>parses many Perl data structures without <strong>eval</strong>, <strong>do</strong> or <strong>require</strong></p></li><li><p>Perl quoting syntax: single quotes (<strong>''</strong>), double quotes(<strong>""</strong>), and here-docs (<strong>&lt;&lt;\s-1EOF\s0</strong>)</p></li><li><p>Perl code evaluation in <strong>Safe</strong> compartments</p></li><li><p>parses \s-1ISC\s0 named and dhcpd config files</p></li><li><p>include files with recursion checks</p></li><li><p>controlled macro expansion in double quoted tokens</p></li><li><p>lexically scoped parameter assignments and directives</p></li><li><p>duplicate macro, parameter, and declaration checks</p></li><li><p>file permission and ownership safety checks</p></li><li><p>fine control over error checking</p></li><li><p>error messages report config file names and line numbers</p></li><li><p>exception-based error handling</p></li><li><p>based on <strong>Parse::RecDescent</strong></p></li><li><p>configuration caching with \s-1MD5\s0 checksums on the original files</p></li><li><p>may be subclassed to build parsers with specialized features</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REQUIRES</h2>
        <div class="sectioncontent">
<ul>
<li><p><strong>Parse::RecDescent</strong></p></li><li><p><strong>Error</strong></p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p>Nothing.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>Config::Scoped-&gt;new</strong>
  </dt>
  <dd>
    <p>  $cs = Config::Scoped-&gt;new(     file     =&gt; $config_file,     lc       =&gt; $lc,     safe     =&gt; $compartment,     warnings =&gt; $warnings,     your_key =&gt; $your_value, { ... },   ); Creates and returns a new <strong>Config::Scoped</strong> object. The following parameters are optional.</p><p>The configuration file to parse. If omitted, then a <strong></strong><strong>$config_string</strong><strong></strong> must be provided to the <strong>parse</strong> method (see below). If true, all declaration and parameter names will be converted to lower case. A <strong>Safe</strong> compartment for evaluating Perl code blocks in the configuration file. Defaults to a <strong>Safe</strong> compartment with no extra shares and the <strong>:default</strong> operator tag. may be the literal string <strong>'on'</strong> or <strong>'off'</strong> to set all warnings simultan. Or define a hash reference with the following keys to set each warning as specified.   $warnings = { declaration  =&gt; &apos;off&apos;,                 digests      =&gt; &apos;off&apos;,                 macro        =&gt; &apos;off&apos;,                 parameter    =&gt; &apos;off&apos;,                 permissions  =&gt; &apos;off&apos;,                 your_warning =&gt; &apos;off&apos;,  }; All warnings are on by default.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>Arbitrary key/value pairs</strong>
  </dt>
  <dd>
    <p>will be stored in the <strong></strong><strong>$cs</strong><strong></strong> object. This is useful primarily for subclassing.</p>
  </dd>

</dl>
<p>    $cfg_hash = $cs-&gt;parse;     $cfg_hash = $cs-&gt;parse(text =&gt; $config_string); Parses the configuration and returns a reference to the config hash. The first form parses the <strong></strong><strong>$config_file</strong><strong></strong> that was provided to the constructor. If <strong></strong><strong>$config_file</strong><strong></strong> was not provided to the constructor, this form <strong>die</strong>s. The second form parses the <strong></strong><strong>$config_string</strong><strong></strong>. This method must only be called once.     $cs-&gt;store_cache;     $cs-&gt;store_cache(cache =&gt; $cache_file); Stores the config hash on disk for rapid retrieval. If <strong></strong><strong>$config_file</strong><strong></strong> was provided to the constructor, then the stored form includes checksums of <strong></strong><strong>$config_file</strong><strong></strong> and any included files. The first  form writes to <strong></strong><strong>$config_file</strong><strong>.dump</strong> The second form writes to <strong></strong><strong>$cache_file</strong><strong></strong>. If <strong></strong><strong>$config_file</strong><strong></strong> was not provided to the constructor, the first form <strong>die</strong>s.     $cfg_hash = $cs-&gt;retrieve_cache;     $cfg_hash = $cs-&gt;retrieve_cache&gt;(cache =&gt; $cache_file); Retrieves the <strong></strong><strong>$config</strong><strong></strong> hash from a file that was created by <strong>store_cache</strong>. The first  form reads <strong></strong><strong>$config_file</strong><strong>.dump</strong> The second form reads <strong></strong><strong>$cache_file</strong><strong></strong>. If <strong></strong><strong>$config_file</strong><strong></strong> was not provided to the constructor, the first form <strong>die</strong>s. The stored file is subject to <strong>digests</strong> and <strong>permissions</strong> checks.     $cs-&gt;set_warnings(name =&gt; $name, switch =&gt; &apos;on|off&apos;); Change warning for <strong></strong><strong>$name</strong><strong></strong> after construction.     $on = $cs-&gt;warnings_on(name =&gt; $name); Returns true if warning <strong></strong><strong>$name</strong><strong></strong> is on. This is useful primarily for subclassing.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXCEPTIONS</h2>
        <div class="sectioncontent">
<p>All methods <strong>die</strong> on error.</p><p><strong>Config::Scoped::Error</strong> defines a hierarchy of classes that represent <strong>Config::Scoped</strong> errors. When a method detects an error, it creates an instance of the corresponding class and throws it. The error classes are all subclasses of <strong>Config::Scoped::Error</strong>. See Config::Scoped::Error for the complete list.</p><p>If the exception is not caught, the program terminates, and <strong>Config::Scoped</strong> prints the config file name and line number where the error was detected to <strong>\s-1STDERR\s0</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIG FILE FORMAT</h2>
        <div class="sectioncontent">
<p><strong>Config::Scoped</strong> parses configuration files.</p><p>If we have a config file like</p><p>  % cat host.cfg   host {       name = cpan.org       port = 22   }   %</p><p>we can parse it into Perl with code like</p><p>    $cs = Config::Scoped-&gt;new( file =&gt; &apos;host.cfg&apos; );     $cfg_hash = $cs-&gt;parse;</p><p>The result is always a hash ref. We'll call this the <strong>config hash</strong>, and its contents for the example file above is:</p><p>    $cfg_hash = {        host =&gt; {           name =&gt; &apos;cpan.org&apos;,           port =&gt; 22,        }       }</p><h3>Config files and config strings</h3>
<p>As described, <strong>Config::Scoped</strong> can obtain a configuration from a <strong></strong><strong>$config_file</strong><strong></strong>, passed to the constructor, or from a <strong></strong><strong>$config_string</strong><strong></strong>, passed to the <strong>parse</strong> method. For simplicity, we'll talk about parsing configuration files, distinguishing configuration strings only when necessary.</p>
<h3>File layout</h3>
<p>Config files are free-form text files. Comments begin with <strong>#</strong>, and extend to the end of the line.</p>
<h3>Declarations</h3>
<p>The top-level elements of a config file are called <strong>declarations</strong>. A declaration consists of a name, followed by a block</p><p>  foo {   }</p><p>  bar {   }</p><p>The declaration names become keys in the config hash. The value of each key is another hash ref. The config shown above parses to</p><p>    $cfg_hash = {        foo =&gt; {},        bar =&gt; {},       }</p><p>You can create additional levels in the config hash simply by listing successive declaration names before the block. This config</p><p>  dog hound {   }</p><p>  dog beagle {   }</p><p>  cat {   }</p><p>parses to</p><p>    $cfg_hash = {        dog =&gt; {           hound  =&gt; {},           beagle =&gt; {},        },</p><p>       cat =&gt; {}       }</p><p>Declarations may not be nested.</p>
<h3>Parameters</h3>
<p>The ultimate purpose of a configuration file is to provide data values for a program.  These values are specified by <strong>parameters</strong>.</p><p>Parameters have the form</p><p>  name = value</p><p>and go inside declaration blocks. The</p><p>  name = value</p><p>parameters in a spec file become key and value pairs inside the declaration hashes in Perl code.</p><p>For example, this configuration</p><p>  dog {       legs  = 4       wings = 0   }</p><p>  bird {       legs  = 2       wings = 2   }</p><p>parses to</p><p>    $cfg_hash = {        dog =&gt; {           legs  =&gt; 4,           wings =&gt; 0,        },</p><p>       bird =&gt; {           legs  =&gt; 2,           wings =&gt; 2,        }       }</p><p><strong>Parameter values</strong> can be <strong>scalars</strong>, <strong>lists</strong> or <strong>hashes</strong>.</p><p>Scalar values may be numbers or strings</p><p>  shape = square   sides = 4</p><p>Lists values are enclosed in square brackets</p><p>  colors = [ red green blue ]   primes = [ 2 3 5 7 11 13  ]</p><p>Hash values are enclosed in curly brackets</p><p>  capitals = {         England =&gt; London         France  =&gt; Paris   }</p><p>A hash value is also called a <strong>hash block</strong>.</p><p>Lists and hashes can be nested to arbitrary depth</p><p>  Europe {      currency = euro</p><p>     cities   = {         England =&gt; [ London Birmingham Liverpool ]         France  =&gt; [ Paris Canne Calais ]      }    }</p><p>parses to</p><p>    $cfg_hash = {        Europe =&gt; {           currency =&gt; &apos;euro&apos;,</p><p>          cities =&gt; {              England =&gt; [ &apos;London&apos;, &apos;Birmingham&apos;, &apos;Liverpool&apos; ],              France  =&gt; [ &apos;Paris&apos;,  &apos;Canne&apos;,      &apos;Calais&apos; ],           }        }       }</p><p>The <strong>Config::Scoped</strong> data syntax is similar to the Perl data syntax, and <strong>Config::Scoped</strong> will parse many Perl data structures. In general, <strong>Config::Scoped</strong> requires less punctuation that Perl. Note that <strong>Config::Scoped</strong> allows arrow (<strong>=&gt;</strong>) or equals (<strong>=</strong>) between hash keys and values, but not comma (<strong>,</strong>)</p><p>  capitals = { England =&gt; London        # OK                France  =  Paris         # OK                Germany ,  Berlin        # error              }</p>
<h3>_GLOBAL</h3>
<p>If a config file contains no declarations at all</p><p>  name = cpan.org   port = 22</p><p>then any parameters will be placed in a <strong>_GLOBAL</strong> declaration in the config hash</p><p>   $cfg_hash = {       _GLOBAL =&gt; {          name =&gt; &apos;cpan.org&apos;,          port =&gt; 22,       }      }</p><p>This allows very simple config files with just parameters and no declarations.</p>
<h3>Blocks, scoping and inheritance</h3>
<p>Each declaration block in a config file creates a lexical scope. Parameters inside a declaration are scoped to that block. Parameters are inherited by all following declarations within their scope.</p><p>If all your animals have four legs, you can save some typing by writing</p><p>    legs = 4     cat {}     dog {}</p><p>which parses to</p><p>   $cfg_hash = {       cat =&gt; { legs =&gt; 4 },       dog =&gt; { legs =&gt; 4 },      }</p><p>If some of your animals have two legs, you can create additional scopes with anonymous blocks to control inheritance</p><p>    {       legs = 4       cat {}       dog {}     }     {       legs = 2       bird {}     }</p><p>parses to</p><p>   $cfg_hash = {       cat  =&gt; { legs =&gt; 4 },       dog  =&gt; { legs =&gt; 4 },       bird =&gt; { legs =&gt; 2 },      }</p><p>Anonymous blocks may be nested.</p><p>Each hash block also creates a scope. The hash does not inherit parameters from outside its own scope.</p>
<h3>Perl code evaluation</h3>
<p>If you can't express what you need within the <strong>Config::Scoped</strong> syntax, your escape hatch is</p><p>  eval { ... }</p><p>This does a Perl <strong>eval</strong> on the block, and replaces the construct with the results of the <strong>eval</strong>.</p><p>  start = eval { localtime }   foo   = eval { warn &apos;foo,&apos; if $debug; return &apos;bar&apos; }</p><p>The block is evaluated in scalar context. However, it may return a list or hash reference, and the underlying list or hash can become a parameter value.</p><p>For example</p><p>  foo {     list = eval { [ 1 .. 3 ]                 }     hash = eval { { a =&gt; 1, b =&gt; 2, c =&gt; 3 } }   }</p><p>parses to</p><p>   $cfg_hash = {       foo =&gt; {          list =&gt; [ 1, 2, 3 ],          hash =&gt; { a =&gt; 1, b =&gt; 2, c =&gt; 3 },       }      }</p><p>The block is evaluated inside the parser's <strong>Safe</strong> compartment. Variables can be made available to the <strong>eval</strong> by sharing them with the compartment.</p><p>To set the <strong></strong><strong>$debug</strong><strong></strong> variable in the example above, do</p><p>    $compartment     = Safe-&gt;new(&apos;MY_SHARE&apos;);     $MY_SHARE::debug = 1;</p><p>    $cs = Config::Scoped-&gt;new(       file =&gt; &apos;config.txt&apos;,       safe =&gt; $compartment,     );</p><p>    $cfg_hash = $cs-&gt;parse;</p><p>Only global variables can be shared with a compartment; lexical variables cannot.</p><p><strong>perl_code</strong> is a synonym for <strong>eval</strong>.</p>
<h3>Tokens and quoting</h3>
<p>A <strong>token</strong> is a</p><ul>
<li><p>declaration name</p></li><li><p>parameter name</p></li><li><p>hash key</p></li><li><p>scalar value</p></li><li><p>macro name</p></li><li><p>macro value</p></li><li><p>include path</p></li><li><p>warning name</p></li>
</ul><p>Any token may be quoted.</p><p>Tokens that contain special characters must be quoted. The special characters are</p><p>  &#92;s {} [] &lt;&gt; () ; , &apos; " = # %</p><p><strong>Config::Scoped</strong> uses the Perl quoting syntax.</p><p>Tokens may be quoted with either single or double quotes</p><p>  a = &apos;New York&apos;   b = "New Jersey&#92;n"</p><p>Here-docs are supported</p><p>  a = &lt;&lt;EOT   New York   New Jersey   EOT</p><p>but generalized quotes (<strong>q()</strong>, <strong></strong><strong>qq()</strong><strong></strong>, etc.) are not. Text in here-docs is regarded as single-quoted if the delimiter is enclosed in single quotes, and double-quoted if the delimiter is enclosed in double quotes or unquoted.</p><p>Double-quoted tokens are evaluated as Perl strings inside the parser's <strong>Safe</strong> compartment. They are subject to the usual Perl backslash and variable interpolation, as well as macro expansion. Variables to be interpolated are passed via the <strong>Safe</strong> compartment, as shown above in \*(L"Perl code evaluation\*(R". If you need a literal <strong>$</strong> or <strong>@</strong> in a double-quoted string, be sure to escape it with a backslash (<strong>&#92;</strong>) to suppress interpolation.</p><p>An</p><p>  eval { ... }</p><p>may appear anywhere that a token is expected. For example</p><p>  foo {       eval { &apos;b&apos; . &apos;c&apos; } = 1   }</p><p>parses to</p><p>    $cfg_hash = { foo =&gt; { bc =&gt; 1 } }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIRECTIVES</h2>
        <div class="sectioncontent">
<p><strong>Config::Scoped</strong> has three directives: <strong></strong><strong>%macro</strong><strong></strong>, <strong></strong><strong>%warning</strong><strong></strong>, and <strong></strong><strong>%include</strong><strong></strong>.</p><h3>Macros</h3>
<p><strong>Config::Scoped</strong> supports macros. A macro is defined with</p><p>  %macro name value</p><p>Macros may be defined</p><ul>
<li><p>at file scope</p></li><li><p>within anonymous blocks</p></li><li><p>within declaration blocks</p></li><li><p>within hash blocks</p></li>
</ul><p>Macros defined within blocks are lexically scoped to those blocks.</p><p>Macro substitution occurs</p><ul>
<li><p>within <strong>any</strong> double-quoted text</p></li><li><p>within the <strong>entirety</strong> of Perl <strong>eval</strong> blocks</p></li><li><p>nowhere else</p></li>
</ul>
<h3>Include files</h3>
<p><strong>Config::Scoped</strong> supports include files.</p><p>To include one config file within another, write</p><p>  %include path/to/file</p><p><strong></strong><strong>%include</strong><strong></strong> directives may appear</p><ul>
<li><p>at file scope</p></li><li><p>within anonymous blocks</p></li><li><p>nowhere else</p></li>
</ul><p>In particular, <strong></strong><strong>%include</strong><strong></strong> directives may not appear within declaration blocks or hash blocks.</p><p>Parameters and macros in include files are imported to the current scope. You can control this scope with an anonymous block</p><p>  {     %include dog.cfg     dog { }  # sees imports from dog.cfg   }   bird { }   # does not see imports from dog.cfg</p><p>Warnings are scoped to the included file and do not leak to the parent file.</p><p>Pathnames are either</p><ul>
<li><p>absolute</p></li><li><p>relative to the dirname of the current configuration file</p></li>
</ul><p>For example, this config</p><p>    # in configuration file /etc/myapp/global.cfg     %include shared.cfg</p><p>includes the file <em>/etc/myapp/shared.cfg</em>.</p><p>When parsing a configuration string, the path is relative to the current working directory.</p><p>Include files are not actually included as text. Rather, they are processed by a recursive call to <strong>Config::Scoped</strong>. Subclass implementers may need to be aware of this.</p>
<h3>Warnings</h3>
<p><strong>Config::Scoped</strong> can check for 5 problems with config files</p><ul>
<li><p>duplicate declaration names</p></li><li><p>duplicate parameter definitions</p></li><li><p>duplicate macro definitions</p></li><li><p>insecure config file permissions</p></li><li><p>invalid config cache digests</p></li>
</ul><p>The \s-1API\s0 refers to these as \*(L"warnings\*(R", but they are actually errors, and if they occur, the parse fails and throws an exception. For consistency with the \s-1API\s0, we'll use the term \*(L"warning\*(R" in the \s-1POD\s0.</p><p>The five warnings are identified by five predefined <strong>warning names</strong></p><ul>
<li><p><strong>declaration</strong></p></li><li><p><strong>parameter</strong></p></li><li><p><strong>macro</strong></p></li><li><p><strong>permissions</strong></p></li><li><p><strong>digests</strong></p></li>
</ul><p>The <strong>permissions</strong> check requires that the config file</p><ul>
<li><p>be owned by root or the real \s-1UID\s0 of the running process \s-1AND\s0</p></li><li><p>have no group or world write permissions</p></li>
</ul><p>These restrictions help prevent an attacker from subverting a program by altering its config files.</p><p>The <strong>store_cache</strong> method computes \s-1MD5\s0 checksums for the config file and all included files. These checksums are stored with the cached configuration.</p><p>The <strong>retrieve_cache</strong> method recomputes the checksums of the files and compares them to the stored values.</p><p>The <strong>digests</strong> check requires that the checksums agree. This helps prevent programs from relying on stale configuration caches.</p><p>All warnings are enabled by default.</p><p>Warnings can be disabled by passing the <strong>warning</strong> key to the constructor or with the <strong>set_warnings</strong> method.</p><p>Warnings can also be controlled with the <strong></strong><strong>%warnings</strong><strong></strong> directive, which has the form</p><p><strong></strong><strong>%warnings</strong><strong></strong> [<strong>name</strong>] <strong>off</strong>|<strong>on</strong></p><p>A <strong></strong><strong>%warnings</strong><strong></strong> directive applies to the <strong>name</strong>d warning, or to all warnings, if <strong>name</strong> is omitted.</p><p><strong></strong><strong>%warnings</strong><strong></strong> directives allow warnings to be turned on and off as necessary throughout the config file. A <strong></strong><strong>%warnings</strong><strong></strong> directive may appear</p><ul>
<li><p>at file scope</p></li><li><p>within anonymous blocks</p></li><li><p>within declaration blocks</p></li><li><p>within hash blocks</p></li>
</ul><p>Each <strong></strong><strong>%warnings</strong><strong></strong> directive is lexically scoped to its enclosing file or block.</p><p>Example</p><p>  legs = 4   cat  {}   dog  {}   bird   {       legs = 2   }</p><p>fails with a duplicate parameter warning, but</p><p>  legs = 4   cat  {}   dog  {}   bird   {       %warnings parameter off;       legs = 2   }</p><p>successfully parses to</p><p>    $cfg_hash = {         cat  =&gt; { legs =&gt; 4 },         dog  =&gt; { legs =&gt; 4 },         bird =&gt; { legs =&gt; 2 },       }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Best practices</h2>
        <div class="sectioncontent">
<p>As with all things Perl, there's more than one way to write configuration files. Here are some suggestions for writing config files that are concise, readable, and maintainable.</p><h3>Perl data</h3>
<p><strong>Config::Scoped</strong> accepts most Perl data syntax. This allows Perl data to pulled into config files largely unaltered</p><p>  foo   {      a = 1;      b = [ &apos;red&apos;, &apos;green&apos;, &apos;blue&apos; ];      c = { x =&gt; 5,            y =&gt; 6 };   }</p><p>However, <strong>Config::Scoped</strong> doesn't require as much punctuation as Perl, and config files written from scratch will be cleaner without it</p><p>  foo   {      a = 1      b = [ red green blue ]      c = { x =&gt; 5            y =&gt; 6 }   }</p>
<h3>Anonymous blocks</h3>
<p>Don't use anonymous blocks unless you need to restrict the scope of something. In particular, there is no need for a top-level anonymous block around the whole config file</p><p>  {             # unnecessary       foo { }   }</p>
<h3>Inheritance</h3>
<p>Parameters that are outside of a declaration are inherited by <strong>all</strong> following declarations in their scope. Don't do this unless you mean it</p><p>  wheels = 4   car   {       # OK   }   cat   {       # I can haz weelz?   }</p>
<h3>Blocks, blocks, we got blocks...</h3>
<p><strong>Config::Scoped</strong> has four different kinds of blocks</p><ul>
<li><p>anonymous</p></li><li><p>declaration</p></li><li><p>eval</p></li><li><p>hash</p></li>
</ul><p>They all look the same, but they aren't, and they have different rules and restrictions. See \*(L"\s-1CONFIG\s0 \s-1FILE\s0 \s-1FORMAT\s0\*(R" for descriptions of each.</p>
<h3>Macros</h3>
<p>Macros are evil, and <strong>Config::Scoped</strong> macros are specially evil, because</p><ul>
<li><p>they don't respect token boundaries</p></li><li><p>where multiple substitutions are possible, the substitution order is undefined</p></li><li><p>substituted text may or may not be rescanned for further substitutions</p></li>
</ul><p>Caveat scriptor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING</h2>
        <div class="sectioncontent">
<p><strong>Config::Scoped</strong> has no formally defined subclass interface. Here are some guidelines for writing subclasses. Implementers who override (or redefine) base class methods may need to read the <strong>Config::Scoped</strong> sources for more information.</p><p>Arbitrary</p><p>  $your_key =&gt; $value</p><p>pairs may be passed to the <strong>Config::Scoped</strong> constructor. They will be stored in the <strong></strong><strong>$cs</strong><strong>-&gt;{local}</strong> hashref, and methods may access them with code like</p><p>  $cs-&gt;{local}{$your_key}</p><p>To avoid conflict with existing keys in the <strong>local</strong> hash, consider distinguishing your keys with a unique prefix.</p><p>Arbitrary warning names may be defined, set with <strong>new</strong> and <strong>set_warnings</strong>, used in <strong></strong><strong>%warnings</strong><strong></strong> directives, and tested with <strong>warnings_on</strong>. Methods can call <strong>warnings_on</strong> to find out whether a warning is currently enabled.</p><p>All methods throw exceptions (<strong>die</strong>) on error. The exception object should be a subclass of <strong>Config::Scoped::Error</strong>. You can use one of the classes defined in <strong>Config::Scoped::Error</strong>, or you can derive your own. This code</p><p>    Config::Scoped::Error-&gt;throw(         -file =&gt; $cs-&gt;_get_file(%args),         -line =&gt; $cs-&gt;_get_line(%args),         -text =&gt; $message,     );</p><p>will generate an error message that reports the location in the config file where the error was detected, rather than a location in Perl code.</p><p><strong>Config::Scoped</strong> performs validation checks on the elements of configuration files (declarations, parameters, macros, etc). Here are the interfaces to the validation methods. Subclasses can override these methods to modify or extend the validation checks. Called for each <strong></strong><strong>%macro</strong><strong></strong> directive. Receives the <strong></strong><strong>$name</strong><strong></strong> and <strong></strong><strong>$value</strong><strong></strong> from the directive. The returned <strong></strong><strong>$macro_value</strong><strong></strong> becomes the actual value of the macro. If the macro is invalid, throws a <strong>Config::Scoped::Error::Validate::Macro</strong> exception. Called for each parameter definition. Receives the <strong></strong><strong>$name</strong><strong></strong> and <strong></strong><strong>$value</strong><strong></strong> from the definition. The returned <strong></strong><strong>$param_value</strong><strong></strong> becomes the actual value of the parameter. If the parameter is invalid, throws a <strong>Config::Scoped::Error::Validate::Parameter</strong> exception. Called for each declaration. <strong></strong><strong>$name</strong><strong></strong> is an array ref giving the chain of names for the declaration block. <strong></strong><strong>$value</strong><strong></strong> is a hash ref containing all the parameters in the declaration block. <strong></strong><strong>$tail</strong><strong></strong> is a hash ref containing all the parameters in any previously defined declaration with the same name(s). For example, the declaration   foo bar baz { a=1 b=2 } leads to the call   $cs-&gt;declaration_validate(name  =&gt; [ qw(foo bar baz) ],                                 value =&gt; { a =&gt; &apos;1&apos;, b =&gt; &apos;2&apos; },                                 tail  =&gt; $cs-&gt;{local}{config}{foo}{bar}{baz}); The method can test %$tail to discover if there is an existing, non-empty declaration with the same name(s). The method has no return value. However, the method can alter the contents of %$value. Upon return, the parameters in %$value become the actual contents of the declaration block. If the declaration is invalid, throws a <strong>Config::Scoped::Error::Validate::Declaration</strong> exception. Called for the config file, each included file, and each retrieved cache file. One of <strong></strong><strong>$file</strong><strong></strong> or <strong></strong><strong>$handle</strong><strong></strong> must be non-null. Throws a <strong>Config::Scoped::Error::Validate::Permissions</strong> exception if the file is not safe to read.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Config::Scoped&hellip;</h2>
        <div class="sectioncontent">
<ul>
<li><p><strong>Error</strong></p></li><li><p><strong>Safe</strong></p></li><li><p><strong>Config::Scoped::Error</strong></p></li><li><p><strong>Parse::RecDescent</strong></p></li><li><p>\*(L"Quote and Quote-like Operators\*(R" in perlop</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Tests
  </dt>
  <dd>
    <p>Still more tests needed.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>If you find parser bugs, please send the stripped down config file and additional version information to the author.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREDITS</h2>
        <div class="sectioncontent">
<p>\s-1POD\s0 by Steven W. McDougall &lt;swmcd@world.std.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Karl Gaissmaier &lt;karl.gaissmaier at uni-ulm.de&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2004-2012 by Karl Gaissmaier</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Config::Record.3pm.html"><span aria-hidden="true">&larr;</span> Config::Record.3pm: Configuration file access</a></li>
   <li class="next"><a href="Config::Scoped::Error.3pm.html">Config::Scoped::Error.3pm: An exception class hierarchy based on error.pm for config::scoped <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ost_Keydata: Keydata objects are used to load and hold 'configuration' data for a given application.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Keydata objects are used to load and hold 'configuration' data for a given application.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ost_Keydata (3) manual">
  <meta name="twitter:description" content="Keydata objects are used to load and hold 'configuration' data for a given application.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_Keydata-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/ost_Keydata.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ost_Keydata (3) manual" />
  <meta property="og:description" content="Keydata objects are used to load and hold 'configuration' data for a given application." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_Keydata-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ost_Keydata<small> (3)</small></h1>
        <p class="lead">Keydata objects are used to load and hold 'configuration' data for a given application.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_Keydata.3.html">
      <span itemprop="name">ost_Keydata: Keydata objects are used to load and hold 'configuration' data for a given application.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcommoncpp2-doc/">
      <span itemprop="name">libcommoncpp2-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_Keydata.3.html">
      <span itemprop="name">ost_Keydata: Keydata objects are used to load and hold 'configuration' data for a given application.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;misc.h&gt;</p><p>Inherits <strong>ost::MemPager</strong>.</p><h3>Classes</h3>
<p>struct <strong>Define</strong></p><p>struct <strong>Keysym</strong></p><p>struct <strong>Keyval</strong></p>
<h3>Public Member Functions</h3>
<p>void <strong>load</strong> (const char *keypath)</p><p><em>Load additional key values into the currrent object from the specfied config source (a config file/section pair). </em> void <strong>loadPrefix</strong> (const char *prefix, const char *keypath)</p><p><em>Load additional key values into the currrent object from the specfied config source (a config file/section pair). </em> void <strong>loadFile</strong> (const char *filepath, const char *keys=NULL, const char *pre=NULL)</p><p><em>Load additional keys into the current object using a real filename that is directly passed rather than a computed key path. </em> void <strong>load</strong> (<strong>Define</strong> *pairs)</p><p><em>Load default keywords into the current object. </em> <strong>Keydata</strong> ()</p><p><em>Create an empty key data object. </em> <strong>Keydata</strong> (const char *keypath)</p><p><em>Create a new key data object and use 'Load' method to load an initial config file section into it. </em> <strong>Keydata</strong> (<strong>Define</strong> *pairs, const char *keypath=NULL)</p><p><em>Alternate constructor can take a define list and an optional pathfile to parse. </em> virtual <strong>~Keydata</strong> ()</p><p><em>Destroy the keydata object and all allocated memory. </em> void <strong>unlink</strong> (void)</p><p><em>Unlink the keydata object from the cache file stream. </em> int <strong>getCount</strong> (const char *sym)</p><p><em>Get a count of the number of data 'values' that is associated with a specific keyword. </em> const char * <strong>getFirst</strong> (const char *sym)</p><p><em>Get the first data value for a given keyword. </em> const char * <strong>getLast</strong> (const char *sym)</p><p><em>Get the last (most recently set) value for a given keyword. </em> bool <strong>isKey</strong> (const char *sym)</p><p><em>Find if a given key exists. </em> const char * <strong>getString</strong> (const char *sym, const char *def=NULL)</p><p><em>Get a string value, with an optional default if missing. </em> long <strong>getLong</strong> (const char *sym, long def=0)</p><p><em>Get a long value, with an optional default if missing. </em> bool <strong>getBool</strong> (const char *key)</p><p><em>Get a bool value. </em> double <strong>getDouble</strong> (const char *key, double def=0.)</p><p><em>Get a floating value. </em> unsigned <strong>getIndex</strong> (char **data, unsigned max)</p><p><em>Get an index array of ALL keywords that are stored by the current keydata object. </em> unsigned <strong>getCount</strong> (void)</p><p><em>Get the count of keyword indexes that are actually available so one can allocate a table to receive getIndex. </em> void <strong>setValue</strong> (const char *sym, const char *data)</p><p><em>Set (replace) the value of a given keyword. </em> const char *const * <strong>getList</strong> (const char *sym)</p><p><em>Return a list of all values set for the given keyword returned in order. </em> void <strong>clrValue</strong> (const char *sym)</p><p><em>Clear all values associated with a given keyword. </em> const char * <strong>operator[]</strong> (const char *keyword)</p><p><em>A convient notation for accessing the keydata as an associative array of keyword/value pairs through the [] operator. </em></p>
<h3>Static Public Member Functions</h3>
<p>static void <strong>end</strong> (void)</p><p><em>static member to end keydata i/o allocations. </em></p>
<h3>Protected Member Functions</h3>
<p><strong>Keysym</strong> * <strong>getSymbol</strong> (const char *sym, bool create)</p>
<h3>Friends</h3>
<p>void <strong>endKeydata</strong> (void)</p><p><em>Shutdown the file stream cache. </em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p><strong>Keydata</strong> objects are used to load and hold 'configuration' data for a given application.</p><p>This class is used to load and then hold '&lt;code&gt;keyword = value&lt;/code&gt;' pairs parsed from a text based 'config' file that has been divided into '&lt;code&gt;[sections]&lt;/code&gt;'. The syntax is:</p>
<pre>
[section_name]
key1=value1
key2=value2
</pre>
<p>Essentially, the 'path' is a 'keypath' into a theoretical namespace of key pairs, hence one does not use 'real' filepaths that may be OS dependent. The '&lt;code&gt;/&lt;/code&gt;' path refers to '&lt;code&gt;/etc&lt;/code&gt;' prefixed (on UNIX) directories and this is processed within the constructor. It could refer to the /config prefix on QNX, or even, gasp, a '&lt;code&gt;C:&#92;WINDOWS&lt;/code&gt;'. Hence, a keypath of '&lt;code&gt;/bayonne.d/vmhost/smtp&lt;/code&gt;' actually resolves to a '&lt;code&gt;/etc/bayonne.d/vmhost.conf&lt;/code&gt;' and loads key value pairs from the [smtp] section of that .conf file.</p><p>Similarly, something like '&lt;code&gt;~bayonne/smtp&lt;/code&gt;' path refers to a '&lt;code&gt;~/.bayonnerc&lt;/code&gt;' and loads key pairs from the [smtp] section. This coercion occurs before the name is passed to the open call.</p><p>I actually use derived keydata based classes as global initialized objects, and they hence automatically load and parse config file entries even before 'main' has started.</p><p><strong>Keydata</strong> can hold multiple values for the same key pair. This can occur either from storing a 'list' of data items in a config file, or when overlaying multiple config sources (such as /etc/....conf<strong> and ~/.confrc</strong> segments) into a single object. The keys are stored as cumulative (read-only/replacable) config values under a hash index system for quick retrieval.</p><p><strong>Keydata</strong> can also load a table of 'initialization' values for keyword pairs that were not found in the external file.</p><p>One typically derives an application specific keydata class to load a specific portion of a known config file and initialize it's values. One can then declare a global instance of these objects and have configuration data initialized automatically as the executable is loaded.</p><p>Hence, if I have a '[paths]' section in a '&lt;code&gt;/etc/server.conf?&lt;/code&gt;' file, I might define something like:</p>
<pre>
class KeyPaths : public <strong>Keydata</strong>
{
  public:
    KeyPaths() : <strong>Keydata</strong>('/server/paths')
    {
      static <strong>Keydata::Define</strong> *defvalues = {
   {'datafiles', '/var/server'},
   {NULL, NULL}};
</pre>

<pre>
      // override with [paths] from '~/.serverrc' if avail.
</pre>

<pre>
      load('~server/paths');
      load(defvalues);
    }
};
</pre>

<pre>
KeyPaths keypaths;
</pre>
<p><strong>Author:</strong></p><p>David Sugar dyfet@ostel.com load text configuration files into keyword pairs.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>ost::Keydata::Keydata ()</h3>
<p>Create an empty key data object.</p>
<h3>ost::Keydata::Keydata (const char *keypath)</h3>
<p>Create a new key data object and use 'Load' method to load an initial config file section into it.</p><p><strong>Parameters:</strong></p><p><em>keypath</em> (filepath/section) specifies the home path.</p>
<h3>ost::Keydata::Keydata (\fBDefine\fP *pairs, const char *keypath = \fCNULL\fP)</h3>
<p>Alternate constructor can take a define list and an optional pathfile to parse.</p><p><strong>Parameters:</strong></p><p><em>pairs</em> of keyword values from a define list</p><p><em>keypath</em> of optional file and section to load from</p>
<h3>virtual ost::Keydata::~Keydata ()\fC [virtual]\fP</h3>
<p>Destroy the keydata object and all allocated memory. This may also clear the 'cache' file stream if no other keydata objects currently reference it.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void ost::Keydata::clrValue (const char *sym)</h3>
<p>Clear all values associated with a given keyword. This does not de-allocate the keyword from memory, however.</p><p><strong>Returns:</strong></p><p>keyword name to clear.</p>
<h3>static void ost::Keydata::end (void)\fC [static]\fP</h3>
<p>static member to end keydata i/o allocations.</p><p>Referenced by ost::endKeydata().</p>
<h3>bool ost::Keydata::getBool (const char *key)</h3>
<p>Get a bool value.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword name.</p><p><strong>Returns:</strong></p><p>true or false.</p>
<h3>int ost::Keydata::getCount (const char *sym)</h3>
<p>Get a count of the number of data 'values' that is associated with a specific keyword. Each value is from an accumulation of '&lt;code&gt;load()&lt;/code&gt;' requests.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword symbol name.</p><p><strong>Returns:</strong></p><p>count of values associated with keyword.</p>
<h3>unsigned ost::Keydata::getCount (void)</h3>
<p>Get the count of keyword indexes that are actually available so one can allocate a table to receive getIndex.</p><p><strong>Returns:</strong></p><p>number of keywords found.</p>
<h3>double ost::Keydata::getDouble (const char *key, doubledef = \fC0.\fP)</h3>
<p>Get a floating value.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword name.</p><p><em>default</em> if not set.</p><p><strong>Returns:</strong></p><p>value of key.</p>
<h3>const char* ost::Keydata::getFirst (const char *sym)</h3>
<p>Get the first data value for a given keyword. This will typically be the /etc set global default.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword symbol name.</p><p><strong>Returns:</strong></p><p>first set value for this symbol.</p>
<h3>unsigned ost::Keydata::getIndex (char **data, unsignedmax)</h3>
<p>Get an index array of ALL keywords that are stored by the current keydata object.</p><p><strong>Returns:</strong></p><p>number of keywords found.</p><p><strong>Parameters:</strong></p><p><em>data</em> pointer of array to hold keyword strings.</p><p><em>max</em> number of entries the array can hold.</p>
<h3>const char* ost::Keydata::getLast (const char *sym)</h3>
<p>Get the last (most recently set) value for a given keyword. This is typically the value actually used.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword symbol name.</p><p><strong>Returns:</strong></p><p>last set value for this symbol.</p>
<h3>const char* const* ost::Keydata::getList (const char *sym)</h3>
<p>Return a list of all values set for the given keyword returned in order.</p><p><strong>Returns:</strong></p><p>list pointer of array holding all keyword values.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword name to fetch.</p>
<h3>long ost::Keydata::getLong (const char *sym, longdef = \fC0\fP)</h3>
<p>Get a long value, with an optional default if missing.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword name.</p><p><em>default</em> if not present.</p><p><strong>Returns:</strong></p><p>long value of key.</p>
<h3>const char* ost::Keydata::getString (const char *sym, const char *def = \fCNULL\fP)</h3>
<p>Get a string value, with an optional default if missing.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword name.</p><p><em>default</em> if not present.</p><p><strong>Returns:</strong></p><p>string value of key.</p>
<h3>\fBKeysym\fP* ost::Keydata::getSymbol (const char *sym, boolcreate)\fC [protected]\fP</h3>

<h3>bool ost::Keydata::isKey (const char *sym)</h3>
<p>Find if a given key exists.</p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword to find.</p><p><strong>Returns:</strong></p><p>true if exists.</p>
<h3>void ost::Keydata::load (const char *keypath)</h3>
<p>Load additional key values into the currrent object from the specfied config source (a config file/section pair). These values will overlay the current keywords when matches are found. This can be used typically in a derived config object class constructor to first load a /etc section, and then load a matching user specific entry from ~/. to override default system values with user specific keyword values.</p><p><strong>Parameters:</strong></p><p><em>keypath</em> (filepath/section)</p>
<h3>void ost::Keydata::load (\fBDefine\fP *pairs)</h3>
<p>Load default keywords into the current object. This only loads keyword entries which have not already been defined to reduce memory usage. This form of Load is also commonly used in the constructor of a derived <strong>Keydata</strong> class.</p><p><strong>Parameters:</strong></p><p><em>pairs</em> list of NULL terminated default keyword/value pairs.</p>
<h3>void ost::Keydata::loadFile (const char *filepath, const char *keys = \fCNULL\fP, const char *pre = \fCNULL\fP)</h3>
<p>Load additional keys into the current object using a real filename that is directly passed rather than a computed key path. This also uses a [keys] section as passed to the object.</p><p><strong>Parameters:</strong></p><p><em>filepath</em> to load from</p><p><em>keys</em> section to parse from, or NULL to parse from head</p><p><em>pre</em> optional key prefix</p>
<h3>void ost::Keydata::loadPrefix (const char *prefix, const char *keypath)</h3>
<p>Load additional key values into the currrent object from the specfied config source (a config file/section pair). These values will overlay the current keywords when matches are found. This can be used typically in a derived config object class constructor to first load a /etc section, and then load a matching user specific entry from ~/. to override default system values with user specific keyword values. This varient puts a prefix in front of the key name.</p><p><strong>Parameters:</strong></p><p><em>prefix</em></p><p><em>keypath</em> (filepath/section)</p>
<h3>const char* ost::Keydata::operator[] (const char *keyword)\fC [inline]\fP</h3>
<p>A convient notation for accessing the keydata as an associative array of keyword/value pairs through the [] operator.</p>
<h3>void ost::Keydata::setValue (const char *sym, const char *data)</h3>
<p>Set (replace) the value of a given keyword. This new value will become the value returned from <strong>getLast()</strong>, while the prior value will still be stored and found from <strong>getList()</strong><strong>.</strong></p><p><strong>Parameters:</strong></p><p><em>sym</em> keyword name to set.</p><p><em>data</em> string to store for the keyword.</p>
<h3>void ost::Keydata::unlink (void)</h3>
<p>Unlink the keydata object from the cache file stream. This should be used if you plan to keepa <strong>Keydata</strong> object after it is loaded once all keydata objects have been loaded, otherwise the cfgFile stream will remain open. You can also use <strong>endKeydata()</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Friends And Related Function Documentation</h2>
        <div class="sectioncontent">
<h3>void endKeydata (void)\fC [friend]\fP</h3>
<p>Shutdown the file stream cache. This should be used before detaching a deamon, exec(), fork(), etc.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for GNU CommonC++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ost_IZStream.3.html"><span aria-hidden="true">&larr;</span> ost_IZStream.3: Ost::izstream -</a></li>
   <li class="next"><a href="ost_Keydata_Define.3.html">ost_Keydata_Define.3: Ost::keydata::define - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Test::XPath: None</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="None">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Test::XPath (3pm) manual">
  <meta name="twitter:description" content="None">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtest-xpath-perl-Test::XPath-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Test::XPath.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Test::XPath (3pm) manual" />
  <meta property="og:description" content="None" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtest-xpath-perl-Test::XPath-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Test::XPath<small> (3pm)</small></h1>
        <p class="lead">None</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Test::XPath.3pm.html">
      <span itemprop="name">Test::XPath: None</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtest-xpath-perl/">
      <span itemprop="name">libtest-xpath-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Test::XPath.3pm.html">
      <span itemprop="name">Test::XPath: None</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Name</h2>
        <div class="sectioncontent">
<p>Test::XPath - Test \s-1XML\s0 and \s-1HTML\s0 content and structure with XPath expressions</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Synopsis</h2>
        <div class="sectioncontent">

<pre>
  use Test::More tests =&gt; 5;
  use Test::XPath;

  my $xml = &lt;&lt;&apos;XML&apos;;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Hello&lt;/title&gt;
      &lt;style type="text/css" src="foo.css"&gt;&lt;/style&gt;
      &lt;style type="text/css" src="bar.css"&gt;&lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Welcome to my lair.&lt;/h1&gt;
    &lt;/body&gt;
  &lt;/html&gt;
  XML

  my $tx = Test::XPath-&gt;new( xml =&gt; $xml );

  $tx-&gt;ok( &apos;/html/head&apos;, &apos;There should be a head&apos; );
  $tx-&gt;is( &apos;/html/head/title&apos;, &apos;Hello&apos;, &apos;The title should be correct&apos; );

  # Recursing into a document:
  my @css = qw(foo.css bar.css);
  $tx-&gt;ok( &apos;/html/head/style[@type="text/css"]&apos;, sub {
      my $css = shift @css;
      shift-&gt;is( &apos;./@src&apos;, $css, "Style src should be $css");
  }, &apos;Should have style&apos; );

  # Better yet, use PerlX::MethodCallWithBlock:
  use PerlX::MethodCallWithBlock;
  my @css = qw(foo.css bar.css);
  use PerlX::MethodCallWithBlock;
  $tx-&gt;ok( &apos;/html/head/style[@type="text/css"]&apos;, &apos;Should have style&apos; ) {
      my $css = shift @css;
      shift-&gt;is( &apos;./@src&apos;, $css, "Style src should be $css");
  };

  # Or use CSS Selectors:
  $tx = Test::XPath-&gt;new( xml =&gt; $xml, filter =&gt; &apos;css_selector&apos; );
  $tx-&gt;ok( &apos;&gt; html &gt; head&apos;, &apos;There should be a head&apos; );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Description</h2>
        <div class="sectioncontent">
<p>Use the power of XPath expressions to validate the structure of your \s-1XML\s0 and \s-1HTML\s0 documents.</p><h3>About XPath</h3>
<p>XPath is a powerful query language for \s-1XML\s0 documents. Test::XPath relies on the libxml2 implementation provided by XML::LibXML. libxml2 \*(-- pretty much the canonical library for \s-1XML\s0 processing \*(-- provides an efficient and complete implementation of the XPath spec.</p><p>XPath works by selecting nodes in an \s-1XML\s0 document. Nodes, in general, correspond to the elements (a.k.a. tags) defined in the \s-1XML\s0, text within those elements, attribute values, and comments. The expressions for making such selections use a URI-like syntax, the basics of which are: Selects all child nodes with the name. Selects the root node. Selects nodes from the current node that match the selection, regardless of where they are in the node hierarchy. Selects the current node. Selects the parent of the current node. Selects attributes.</p><p>And some examples: Selects all of the child nodes of the \*(L"head\*(R" element. Selects the root \*(L"html\*(R" element. Selects all \*(L"p\*(R" elements that are children of the \*(L"body\*(R" element. Selects all \*(L"p\*(R" elements no matter where they are in the document. Selects all \*(L"p\*(R" elements that are descendants of the \*(L"body\*(R" element, no matter where they appear under the \*(L"body\*(R" element. Selects all attributes named \*(L"lang\*(R".</p><p>There are also useful predicates to select certain nodes. Some examples: Select the first paragraph under the body element. Select the last paragraph under the body element. Select all \*(L"script\*(R" nodes that have a \*(L"src\*(R" attribute. Select all \*(L"script\*(R" nodes that have a \*(L"src\*(R" attribute set to \*(L"foo.js\*(R". Select all \*(L"img\*(R" nodes with a height attribute greater than 400. Select all child nodes below the \*(L"head\*(R" node. Select all \*(L"p\*(R" nodes that have any attribute. Select a count of all \*(L"p\*(R" nodes in the document.</p><p>There are a bunch of core functions in XPath. In addition to the (\*(C`last()\*(C' and \*(C`count()\*(C') examples above, there are functions for node sets, booleans, numbers, and strings. See the XPath 1.0 W3C Recommendation &lt;http://www.w3.org/TR/xpath&gt;, for thorough (and quite readable) documentation of XPath support, including syntax and the core functions. The W3Schools tutorial &lt;http://www.w3schools.com/Xpath/default.asp&gt; provides a nice overview of XPath.</p>
<h3>Testing \s-1HTML\s0</h3>
<p>If you want to use XPath to test the content and structure of an \s-1HTML\s0 document, be sure to pass the \*(C`is_html\*(C' option to \*(C`new()\*(C', like so:</p><p>  my $tx = Test::XPath-&gt;new( xml =&gt; $html, is_html =&gt; 1 );</p><p>Test::XPath will then use XML::LibXML's \s-1HTML\s0 parser to parse the document, rather than its \s-1XML\s0 parser. The upshot is that you won't have to worry about namespace prefixes, and XML::LibXML won't try to fetch any \s-1DTD\s0 specified in the \s-1DOCTYPE\s0 section of your \s-1HTML\s0.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Class Interface</h2>
        <div class="sectioncontent">
<h3>Constructor</h3>
<p><em></em><strong>\*(C`new\*(C'</strong><em></em></p><p>  my $tx = Test::XPath-&gt;new( xml =&gt; $xml );</p><p>Creates and returns an XML::XPath object. This object can be used to run XPath tests on the \s-1XML\s0 passed to it. The supported parameters are:   xml =&gt; &apos;&lt;foo&gt;&lt;bar&gt;hey&lt;/bar&gt;&lt;/foo&gt;&apos;, The \s-1XML\s0 to be parsed and tested. Required unless the \*(C`file\*(C' or \*(C`doc\*(C' option is passed.   file =&gt; &apos;rss.xml&apos;, Name of a file containing the \s-1XML\s0 to be parsed and tested. Required unless the \*(C`xml\*(C' or \*(C`doc\*(C' option is passed.   doc =&gt; XML::LibXML-&gt;new-&gt;parse_file($xml_file), An XML::LibXML document object. Required unless the \*(C`xml\*(C' or \*(C`file\*(C' option is passed.   is_html =&gt; 1, If the \s-1XML\s0 you're testing is actually \s-1HTML\s0, pass this option a true value and XML::LibXML's \s-1HTML\s0 parser will be used instead of the \s-1XML\s0 parser. This is especially useful if your \s-1HTML\s0 has a \s-1DOCTYPE\s0 declaration or an \s-1XML\s0 namespace (xmlns attribute) and you don't want the parser grabbing the \s-1DTD\s0 over the Internet and you don't want to mess with a namespace prefix in your XPath expressions.   xmlns =&gt; {       x =&gt; &apos;http://www.w3.org/1999/xhtml&apos;,       a =&gt; &apos;http://www.w3.org/2007/app&apos;,   }, Set up prefixes for \s-1XML\s0 namespaces. Required if your \s-1XML\s0 uses namespaces and you want to write reasonable XPath expressions.   options =&gt; { recover_silently =&gt; 1, no_network =&gt; 1 }, Optional hash reference of XML::LibXML::Parser options, such as \*(L"validation\*(R", \*(L"recover\*(R", \*(L"suppress_errors\*(R", and \*(L"no_network\*(R". These can be useful for tweaking the behavior of the parser.   filter =&gt; &apos;css_selector&apos;,   filter =&gt; sub { my $xpath = shift; }, Pass a filter name or a code reference for Test::XPath to use to filter XPath expressions before passing them on to XML::LibXML. The code reference argument allows you to transform XPath expressions if, for example, you use a custom XPath syntax that's more concise than XPath. There is currently only one built-in filter, \*(C`css_selector\*(C'. So if you pass   filter =&gt; &apos;css_selector&apos;, Then any paths passed to \*(C`ok()\*(C', \*(C`is()\*(C', etc., will be passed through HTML::Selector::XPath. This allows you to use \s-1CSS\s0 selector syntax, which can be more compact for simple expressions. For example, this \s-1CSS\s0 selector:     $tx-&gt;is(&apos;div#content div.article h1&apos;, &apos;...&apos;) Is equivalent to this XPath expression:     $tx-&gt;is(&apos;//div[@id="content"]//div[@class="article"]//h1&apos;, &apos;...&apos;)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Instance Interface</h2>
        <div class="sectioncontent">
<h3>Assertions</h3>
<p><em></em><strong>\*(C`ok\*(C'</strong><em></em></p><p>  $tx-&gt;ok( $xpath, $description )   $tx-&gt;ok( $xpath, $coderef, $description )</p><p>Test that an XPath expression evaluated against the \s-1XML\s0 document returns a true value. If the XPath expression finds no nodes, the result will be false. If it finds a value, the value must be a true value (in the Perl sense).</p><p>  $tx-&gt;ok( &apos;//foo/bar&apos;, &apos;Should have bar element under foo element&apos; );   $tx-&gt;ok( &apos;contains(//title, "Welcome")&apos;, &apos;Title should "Welcome"&apos; );</p><p>You can also run recursive tests against your document by passing a code reference as the second argument to \*(C`ok()\*(C'. Once the initial selection has been completed, each selected node will be assigned to the \*(C`node\*(C' attribute and the XML::XPath object passed to the code reference. For example, if you wanted to test for the presence of \*(L"story\*(R" elements in your document, and to test that each such element had an incremented \*(L"id\*(R" attribute, you'd do something like this:</p><p>  my $i = 0;   $tx-&gt;ok( &apos;//assets/story&apos;, sub {       shift-&gt;is(&apos;./@id&apos;, ++$i, "ID should be $i in story $i");   }, &apos;Should have story elements&apos; );</p><p>Even better, use PerlX::MethodCallWithBlock to pass a block to the method instead of a code reference:</p><p>  use PerlX::MethodCallWithBlock;   my $i = 0;   $tx-&gt;ok( &apos;//assets/story&apos;, &apos;Should have story elements&apos; ) {       shift-&gt;is(&apos;./@id&apos;, ++$i, "ID should be $i in story $i");   };</p><p>For convenience, the XML::XPath object is also assigned to $_ for the duration of the call to the code reference. Either way, you can call \*(C`ok()\*(C' and pass code references anywhere in the hierarchy. For example, to ensure that an Atom feed has entries and that each entry has a title, a link, and a very specific author element with name, uri, and email subnodes, you can do this:</p><p>  $tx-&gt;ok( &apos;/feed/entry&apos;, sub {       $_-&gt;ok( &apos;./title&apos;, &apos;Should have a title&apos; );       $_-&gt;ok( &apos;./author&apos;, sub {           $_-&gt;is( &apos;./name&apos;,  &apos;Mark Pilgrim&apos;,        &apos;Mark should be author&apos; );           $_-&gt;is( &apos;./uri&apos;,   &apos;http://example.org/&apos;, &apos;URI should be correct&apos; );           $_-&gt;is( &apos;./email&apos;, &apos;f8dy@example.com&apos;,    &apos;Email should be right&apos; );       }, &apos;Should have author elements&apos; );   }, &apos;Should have entry elments&apos; );</p><p><em></em><strong>\*(C`not_ok\*(C'</strong><em></em></p><p>  $tx-&gt;not_ok( $xpath, $description )</p><p>The reverse of the non-recursive \*(C`ok()\*(C', the test succeeds if the XPath expression matches no part of the document.</p><p>  $tx-&gt;not_ok( &apos;//foo/bar[@id=0]&apos;, &apos;Should have no bar elements with Id 0&apos; );</p><p><em></em><strong>\*(C`is\*(C'</strong><em></em></p><p><em></em><strong>\*(C`isnt\*(C'</strong><em></em></p><p>  $tx-&gt;is( $xpath, $want, $description );   $tx-&gt;isnt( $xpath, $dont_want, $description );</p><p>\*(C`is()\*(C' and \*(C`isnt()\*(C' compare the value returned by evaluation of the XPath expression against the document to a value using \*(C`eq\*(C' and \*(C`ne\*(C', respectively.</p><p>  $tx-&gt;is( &apos;/html/head/title&apos;, &apos;Welcome&apos;, &apos;Title should be welcoming&apos; );   $tx-&gt;isnt( &apos;/html/head/link/@type&apos;, &apos;hello&apos;, &apos;Link type should not&apos; );</p><p>As with \*(C`Test::More::ok()\*(C', a failing test will yield a useful diagnostic message, something like:</p><p>  #   Failed test &apos;Title should be welcoming&apos;   #   at t/foo.t line 47.   #          got: &apos;Bienvenidos&apos;   #     expected: &apos;Hello&apos;</p><p><em></em><strong>\*(C`like\*(C'</strong><em></em></p><p><em></em><strong>\*(C`unlike\*(C'</strong><em></em></p><p>  $tx-&gt;like( $xpath, qr/want/, $description );   $tx-&gt;unlike( $xpath, qr/dont_want/, $description );</p><p>Similar to \*(C`is()\*(C' and \*(C`isnt()\*(C', but these methods match the value returned by the XPath expression against a regular expression.</p><p>  $tx-&gt;like( &apos;/html/head/title&apos;, qr/^Foobar Inc.: .+/, &apos;Title context&apos; );   $tx-&gt;unlike( &apos;/html/head/title&apos;, qr/Error/, &apos;Should be no error in title&apos; );</p><p>As with \*(C`Test::More::like()\*(C', a failing test will yield a useful diagnostic message, something like:</p><p>  #   Failed test &apos;Title should, like, welcome&apos;   #   at t/foo.t line 62.   #                   &apos;Bye&apos;   #     doesn&apos;t match &apos;(?-xism:^Howdy$)&apos;</p><p><em></em><strong>\*(C`cmp_ok\*(C'</strong><em></em></p><p>  $tx-&gt;cmp_ok( $xpath, $op, $want, $description );</p><p>Like \*(C`Test::More::cmp_ok()\*(C', this method allows you to compare the value returned by an XPath expression to a value using any binary Perl operator.</p><p>  $tx-&gt;cmp_ok( &apos;/html/head/title&apos;, &apos;eq&apos;, &apos;Welcome&apos; );   $tx-&gt;cmp_ok( &apos;//story[1]/@id&apos;, &apos;==&apos;, 1 );</p><p>As with \*(C`Test::More::cmp_ok()\*(C', a failing test will yield a useful diagnostic message, something like:</p><p>  #   Failed test   #   at t/foo.t line 104.   #     &apos;0&apos;   #         &&   #     &apos;1&apos;</p>
<h3>Accessors</h3>
<p><em></em><strong>\*(C`node\*(C'</strong><em></em></p><p>  my $node = $tx-&gt;node;</p><p>Returns the current context node. This will usually be the node for the entire document, but in recursive tests run in code references passed to \*(C`ok()\*(C', the node will be one of the nodes selected for the test.</p><p><em></em><strong>\*(C`xpc\*(C'</strong><em></em></p><p>Returns the XML::LibXML::XPathContext used to execute the XPath expressions. It can be useful to access this object in order to create new XPath functions to use in your tests. For example, say that you wanted to define a \*(C`grep()\*(C' XPath function that returns true for a node value that matches a regular expression. You can define one like so:</p><p>  $tx-&gt;xpc-&gt;registerFunction( grep =&gt; sub {       my ($nodelist, $regex) =  @_;       my $result = XML::LibXML::NodeList-&gt;new;       for my $node ($nodelist-&gt;get_nodelist) {           $result-&gt;push($node) if $node-&gt;textContent =~ $regex;       }       return $result;   } );</p><p>You can then use \*(C`grep()\*(C' like any other XPath function to select only those nodes with content matching a regular expression. This example makes sure that there are \*(L"email\*(R" nodes under \*(L"author\*(R" nodes that end in \*(L"@example.com\*(R" or \*(L"example.org\*(R":</p><p>  $tx-&gt;ok(       &apos;grep(//author/email, "@example[.](?:com|org)$")&apos;,       &apos;Should have example email&apos;   );</p>
<h3>Utilities</h3>
<p><em></em><strong>\*(C`find_value\*(C'</strong><em></em></p><p>  my $val = $tx-&gt;find_value($xpath);</p><p>Returns the value returned by evaluation of the XPath expression against the document relative to the current node. This is the method used internally to fetch the value to be compared by \*(C`is\*(C', \*(C`isnt\*(C', \*(C`like\*(C', \*(C`unlike\*(C', and \*(C`cmp_ok\*(C'. A simple example:</p><p>  my $val = $tx-&gt;find_value(&apos;/html/head/title&apos;);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">See Also</h2>
        <div class="sectioncontent">
<ul>
<li><p>\s-1XML\s0 Path Language (XPath) Version 1.0 W3C Recommendation &lt;http://www.w3.org/TR/xpath&gt;.</p></li><li><p>W3Schools XPath Tutorial &lt;http://www.w3schools.com/Xpath/default.asp&gt;.</p></li><li><p>XML::LibXML::XPathContext - The XML::LibXML XPath evaluation library.</p></li><li><p>Test::XML::XPath - Another library for testing XPath assertions using a functional interface. Ships with Test::XML.</p></li><li><p>Test::HTML::Content - Another module that that offers \*(C`xpath_ok()\*(C' and \*(C`no_xpath()\*(C' test functions.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Support</h2>
        <div class="sectioncontent">
<p>This module is stored in an open GitHub repository &lt;http://github.com/theory/test-xpath/tree/&gt;. Feel free to fork and contribute!</p><p>Please file bug reports via GitHub Issues &lt;http://github.com/theory/test-xpath/issues/&gt; or by sending mail to bug-Test-XPath@rt.cpan.org &lt;mailto:bug-Test-XPath@rt.cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>David E. Wheeler &lt;david@kineticode.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Copyright and License</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2009-2010 David E. Wheeler. Some Rights Reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Test::XML::XPath.3pm.html"><span aria-hidden="true">&larr;</span> Test::XML::XPath.3pm: Test xpath assertions</a></li>
   <li class="next"><a href="Test::YAML::Meta.3pm.html">Test::YAML::Meta.3pm: Validation of the meta.yml file in a distribution. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Config::Simple: Simple configuration file class</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Simple configuration file class">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Config::Simple (3pm) manual">
  <meta name="twitter:description" content="Simple configuration file class">
  <meta name="twitter:image" content="https://www.carta.tech/images/libconfig-simple-perl-Config::Simple-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Config::Simple.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Config::Simple (3pm) manual" />
  <meta property="og:description" content="Simple configuration file class" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libconfig-simple-perl-Config::Simple-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Config::Simple<small> (3pm)</small></h1>
        <p class="lead">Simple configuration file class</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Config::Simple.3pm.html">
      <span itemprop="name">Config::Simple: Simple configuration file class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libconfig-simple-perl/">
      <span itemprop="name">libconfig-simple-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Config::Simple.3pm.html">
      <span itemprop="name">Config::Simple: Simple configuration file class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Config::Simple;

  # --- Simple usage. Loads the config. file into a hash:
  Config::Simple-&gt;import_from(&apos;app.ini&apos;, &#92;%Config);


  # --- OO interface:
  $cfg = new Config::Simple(&apos;app.ini&apos;);

  # accessing values:
  $user = $cfg-&gt;param(&apos;User&apos;);

  # getting the values as a hash:
  %Config = $cfg-&gt;vars();

  # updating value with a string
  $cfg-&gt;param(&apos;User&apos;, &apos;sherzodR&apos;);

  # updating a value with an array:
  $cfg-&gt;param(&apos;Users&apos;, [&apos;sherzodR&apos;, &apos;geek&apos;, &apos;merlyn&apos;]);

  # adding a new block to an ini-file:
  $cfg-&gt;param(-block=&gt;&apos;last-access&apos;, -values=&gt;{&apos;time&apos;=&gt;time()});

  # accessing a block of an ini-file;
  $mysql = $cfg-&gt;param(-block=&gt;&apos;mysql&apos;);

  # saving the changes back to file:
  $cfg-&gt;save();


  # --- tie() interface
  tie %Config, "Config::Simple", &apos;app.ini&apos;;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ABSTRACT</h2>
        <div class="sectioncontent">
<p>Reading and writing configuration files is one of the most frequent tasks of any software design. Config::Simple is the library that helps you with it.</p><p>Config::Simple is a class representing configuration file object. It supports several configuration file syntax and tries to identify the file syntax automatically. Library supports parsing, updating and creating configuration files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ABOUT CONFIGURATION FILES</h2>
        <div class="sectioncontent">
<p>Keeping configurable variables in your program source code is ugly, really. And for people without much of a programming experience, configuring your programs is like performing black magic. Besides, if you need to access these values from within multiple files, want your programs to be able to update configuration files or want to provide a friendlier user interface for your configuration files, you just have to store them in an external file. That's where Config::Simple comes into play, making it very easy to read and write configuration files.</p><p>If you have never used configuration files before, here is a brief overview of various syntax to choose from. Otherwise you can jump to \*(L"\s-1PROGRAMMING\s0 \s-1STYLE\s0\*(R".</p><h3>\s-1SIMPLE\s0 \s-1CONFIGURATION\s0 \s-1FILE\s0</h3>
<p>Simple syntax is what you need for most of your projects. These are, as the name asserts, the simplest. File consists of key/value pairs, delimited by nothing but white space. Keys (variables) should be strictly alpha-numeric with possible dashes (-). Values can hold any arbitrary text. Here is an example of such a configuration file:</p><p>  Alias     /exec   TempFile  /usr/tmp</p><p>Comments start with a pound ('#') sign and cannot share the same line with other configuration data.</p>
<h3>HTTP-LIKE \s-1SYNTAX\s0</h3>
<p>This format of separating key/value pairs is used by \s-1HTTP\s0 messages. Each key/value is separated by semi-colon (:). Keys are alphanumeric strings with possible '-'. Values can be any arbitrary text:</p><p>Example:</p><p>  Alias: /exec   TempFile: /usr/tmp</p><p>It is \s-1OK\s0 to have spaces around ':'. Comments start with '#' and cannot share the same line with other configuration data.</p>
<h3>INI-FILE</h3>
<p>These configuration files are more native to Win32 systems. Data is organized in blocks. Each key/value pair is delimited with an equal (=) sign. Blocks are declared on their own lines enclosed in '[' and ']':</p><p>  [BLOCK1]   KEY1=VALUE1   KEY2=VALUE2</p><p>  [BLOCK2]   KEY1=VALUE1   KEY2=VALUE2</p><p>Your Winamp 2.x play list is an example of such a configuration file.</p><p>This is the perfect choice if you need to organize your configuration file into categories:</p><p>  [site]   url="http://www.handalak.com"   title="Web site of a &#92;"Geek&#92;""   author=sherzodr</p><p>  [mysql]   dsn="dbi:mysql:db_name;host=handalak.com"   user=sherzodr   password=marley01</p>
<h3>\s-1SIMPLIFIED\s0 INI-FILE</h3>
<p>These files are pretty much similar to traditional ini-files, except they don't have any block declarations. This style is handy if you do not want any categorization in your configuration file, but still want to use '=' delimited key/value pairs. While working with such files, Config::Simple assigns them to a default block, called 'default' by default :-).</p><p>  url = "http://www.handalak.com"</p><p>Comments can begin with either pound ('#') or semi-colon (';'). Each comment should reside on its own line</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROGRAMMING STYLE</h2>
        <div class="sectioncontent">
<p>Most of the programs simply need to be able to read settings from a configuration file and assign them to a hash. If that's all you need, you can simply use its <em>import_from()</em> - class method with the name of the configuration file and a reference to an existing (possibly empty) hash:</p><p>  Config::Simple-&gt;import_from(&apos;myconf.cfg&apos;, &#92;%Config);</p><p>Now your hash %Config holds all the configuration file's key/value pairs. Keys of a hash are variable names inside your configuration file, and values are their respective values. If \*(L"myconf.cfg\*(R" was a traditional ini-file, keys of the hash consist of block name and variable delimited with a dot, such as \*(L"block.var\*(R".</p><p>If that's all you need, you can stop right here. Otherwise, read on. There is much more Config::Simple offers.</p><h3>\s-1READING\s0 \s-1THE\s0 \s-1CONFIGURATION\s0 \s-1FILE\s0</h3>
<p>To be able to use more features of the library, you will need to use its object interface:</p><p>  $cfg = new Config::Simple(&apos;app.cfg&apos;);</p><p>The above line reads and parses the configuration file accordingly. It tries to guess which syntax is used by passing the file to <em>guess_syntax()</em> method. Alternatively, you can create an empty object, and only then read the configuration file in:</p><p>  $cfg = new Config::Simple();   $cfg-&gt;read(&apos;app.cfg&apos;);</p><p>As in the first example, <em>read()</em> also calls <em>guess_syntax()</em> method on the file.</p><p>If, for any reason, it fails to guess the syntax correctly (which is less likely), you can try to debug by using its <em>guess_syntax()</em> method. It expects file handle for a  configuration file and returns the name of a syntax. Return value is one of \*(L"ini\*(R", \*(L"simple\*(R" or \*(L"http\*(R".</p><p>  open(FH, "app.cfg");   printf("This file uses &apos;%s&apos; syntax&#92;n", $cfg-&gt;guess_syntax(&#92;*FH));</p>
<h3>\s-1ACCESSING\s0 \s-1VALUES\s0</h3>
<p>After you read the configuration file in successfully, you can use <em>param()</em> method to access the configuration values. For example:</p><p>  $user = $cfg-&gt;param("User");</p><p>will return the value of \*(L"User\*(R" from either simple configuration file, or http-styled configuration as well as simplified ini-files. To access the value from a traditional ini-file, consider the following syntax:</p><p>  $user = $cfg-&gt;param("mysql.user");</p><p>The above returns the value of \*(L"user\*(R" from within \*(L"[mysql]\*(R" block. Notice the use of dot \*(L".\*(R" to delimit block and key names.</p><p>Config::Simple also supports <em>vars()</em> method, which, depending on the context used, returns all the values either as hashref or hash:</p><p>  my %Config = $cfg-&gt;vars();   print "Username: $Config{User}";</p><p>  # If it was a traditional ini-file:   print "Username: $Config{&apos;mysql.user&apos;}";</p><p>If you call <em>vars()</em> in scalar context, you will end up with a reference to a hash:</p><p>  my $Config = $cfg-&gt;vars();   print "Username: $Config-&gt;{User}";</p><p>If you know what you're doing, you can also have an option of importing all the names from the configuration file into your current name space as global variables. All the block/key names will be uppercased and will be converted to Perl's valid variable names; that is, all the dots (block-key separator) and other '&#92;W' characters will be substituted with underscore '_':</p><p>  $cfg = new Config::Simple(&apos;app.cfg&apos;);   $cfg-&gt;import_names();</p><p>  # or, with a single line:   Config::Simple-&gt;new(&apos;app.cfg&apos;)-&gt;import_names();</p><p>  print STDERR "Debugging mode is on" if $DEBUG_MODE;</p><p>In the above example, if there was a variable 'mode' under '[debug]' block, it will be now accessible via $DEBUG_MODE, as opposed to $cfg-&gt;param('debug.mode');</p><p>\*(C`import_names()\*(C' by default imports the values to its caller's name space. Optionally, you can specify where to import the values by passing the name of the name space as the first argument. It also prevents potential name collisions:</p><p>  Config::Simple-&gt;new(&apos;app.cfg&apos;)-&gt;import_names(&apos;CFG&apos;);   print STDERR "Debugging mode is on" if $CFG::DEBUG_MODE;</p><p>If all you want is to import values from a configuration file, the above syntax may still seem longer than necessary. That's why Config::Simple supports <em>import_from()</em> - class method, which is called with the name of the configuration file. It will call <em>import_names()</em> for you:</p><p>  Config::Simple-&gt;import_from(&apos;app.cfg&apos;);</p><p>The above line imports all the variables into the caller's name space. It's similar to calling <em>import_names()</em> on an object. If you pass a string as the second argument, it will treat it as the alternative name space to import the names into. As we already showed in the very first example, you can also pass a reference to an existing hash as the second argument. In this case, that hash will be modified with the values of the configuration file.</p><p>  # import into $CFG name space:   Config::Simple-&gt;import_from(&apos;app.cfg&apos;, &apos;CFG&apos;);</p><p>  # import into %Config hash:   Config::Simple-&gt;import_from(&apos;app.cfg&apos;, &#92;%Config);</p><p>The above line imports all the values to '\s-1CFG\s0' name space. <em>import_from()</em> returns underlying Config::Simple object (which you may not even need anymore):</p><p>  $cfg = Config::Simple-&gt;import_from(&apos;app.cfg&apos;, &#92;my %Config);   $cfg-&gt;write(&apos;app.cfg.bak&apos;);</p>
<h3>\s-1UPDATING\s0 \s-1THE\s0 \s-1VALUES\s0</h3>
<p>Configuration values, once read into Config::Simple, can be updated from within your program by using the same <em>param()</em> method used for accessing them. For example:</p><p>  $cfg-&gt;param("User", "sherzodR");</p><p>The above line changes the value of \*(L"User\*(R" to \*(L"sherzodR\*(R". Similar syntax is applicable for ini-files as well:</p><p>  $cfg-&gt;param("mysql.user", "sherzodR");</p><p>If the key you're trying to update does not exist, it will be created. For example, to add a new \*(L"[session]\*(R" block to your ini-file, assuming this block doesn't already exist:</p><p>  $cfg-&gt;param("session.life", "+1M");</p><p>You can also delete values calling <em>delete()</em> method with the name of the variable:</p><p>  $cfg-&gt;delete(&apos;mysql.user&apos;); # deletes &apos;user&apos; under [mysql] block</p>
<h3>\s-1SAVING/WRITING\s0 \s-1CONFIGURATION\s0 \s-1FILES\s0</h3>
<p>The above updates to the configuration values are in-memory operations. They do not reflect in the file itself. To modify the files accordingly, you need to call either \*(L"<em>write()</em>\*(R" or \*(L"<em>save()</em>\*(R" methods on the object:</p><p>  $cfg-&gt;write();</p><p>The above line writes the modifications to the configuration file. Alternatively, you can pass a name to either <em>write()</em> or <em>save()</em> to indicate the name of the file to create instead of modifying existing configuration file:</p><p>  $cfg-&gt;write("app.cfg.bak");</p><p>If you want the changes saved at all times, you can turn \*(C`autosave\*(C' mode on by passing true value to $cfg-&gt;<em>autosave()</em>. It will make sure before your program is terminated, all the configuration values are written back to its file:</p><p>  $cfg = new Config::Simple(&apos;aff.cfg&apos;);   $cfg-&gt;<strong>autosave</strong>(1);</p>
<h3>\s-1CREATING\s0 \s-1CONFIGURATION\s0 \s-1FILES\s0</h3>
<p>Occasionally, your programs may want to create their own configuration files on the fly, possibly from a user input. To create a configuration file from scratch using Config::Simple, simply create an empty configuration file object and define your syntax. You can do it by either passing \*(L"syntax\*(R" option to <em>new()</em>, or by calling <em>syntax()</em> method. Then play with <em>param()</em> method as you normally would. When you're done, call <em>write()</em> method with the name of the configuration file:</p><p>  $cfg = new Config::Simple(syntax=&gt;&apos;ini&apos;);   # or you could also do:   # $cfg-&gt;autosave(&apos;ini&apos;)</p><p>  $cfg-&gt;param("mysql.dsn", "DBI:mysql:db;host=handalak.com");   $cfg-&gt;param("mysql.user", "sherzodr");   $cfg-&gt;param("mysql.pass", &apos;marley01&apos;);   $cfg-&gt;param("site.title", &apos;sherzodR "The Geek"&apos;);   $cfg-&gt;write("new.cfg");</p><p>This creates a file \*(L"new.cfg\*(R" with the following content:</p><p>  ; Config::Simple 4.43   ; Sat Mar  8 00:32:49 2003</p><p>  [site]   title=sherzodR "The Geek"</p><p>  [mysql]   pass=marley01   dsn=DBI:mysql:db;host=handalak.com   user=sherzodr</p><p>Neat, huh? Supported syntax keywords are \*(L"ini\*(R", \*(L"simple\*(R" or \*(L"http\*(R". Currently there is no support for creating simplified ini-files.</p>
<h3>\s-1MULTIPLE\s0 \s-1VALUES\s0</h3>
<p>Ever wanted to define array of values in your single configuration variable? I have! That's why Config::Simple supports this fancy feature as well. Simply separate your values with a comma:</p><p>  Files hp.cgi, template.html, styles.css</p><p>Now <em>param()</em> method returns an array of values:</p><p>  @files = $cfg-&gt;param("Files");   unlink $_ for @files;</p><p>If you want a comma as part of a value, enclose the value(s) in double quotes:</p><p>  CVSFiles "hp.cgi,v", "template.html,v", "styles.css,v"</p><p>In case you want either of the values to hold literal quote ("), you can escape it with a backlash:</p><p>  SiteTitle "sherzod &#92;"The Geek&#92;""</p>
<h3>\s-1TIE\s0 \s-1INTERFACE\s0</h3>
<p>If \s-1OO\s0 style intimidates you, and \*(C`import_from()\*(C' is too simple for you, Config::Simple also supports <em>tie()</em> interface. This interface allows you to <em>tie()</em> an ordinary Perl hash to the configuration file. From that point on, you can use the variable as an ordinary Perl hash.</p><p>  tie %Config, "Config::Simple", &apos;app.cfg&apos;;</p><p>  # Using %Config as an ordinary hash   print "Username is &apos;$Config{User}&apos;&#92;n";   $Config{User} = &apos;sherzodR&apos;;</p><p>The difference between \*(C`import_from($file, &#92;%Hash)\*(C' is, all the changes you make to the hash after <em>tie()</em>ing it, will also reflect in the configuration file object. If <em>autosave()</em> was turned on, they will also be written back to file:</p><p>  tie %Config, "Config::Simple", "app.cfg";   tied(%Config)-&gt;<strong>autosave</strong>(1);</p><p>To access the method provided in \s-1OO\s0 syntax, you need to get underlying Config::Simple object. You can do so with <em>tied()</em> function:</p><p>  tied(%Config)-&gt;write();</p><p>\s-1WARNING:\s0 tie interface is experimental and not well tested yet. Let me know if you encounter a problem.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MISCELLANEOUS</h2>
        <div class="sectioncontent">
<h3>\s-1CASE\s0 \s-1SENSITIVITY\s0</h3>
<p>By default, configuration file keys and values are case sensitive. Which means, $cfg-&gt;param(\*(L"User\*(R") and $cfg-&gt;param(\*(L"user\*(R") are referring to two different values. But it is possible to force Config::Simple to ignore cases all together by enabling \*(C`-lc\*(C' switch while loading the library:</p><p>  use Config::Simple (&apos;-lc&apos;);</p><p>\s-1WARNING:\s0 If you call <em>write()</em> or <em>save()</em>, while working on \*(C`-lc\*(C' mode, all the case information of the original file will be lost. So use it if you know what you're doing.</p>
<h3>\s-1USING\s0 \s-1QUOTES\s0</h3>
<p>Some people suggest if values consist of none alpha-numeric strings, they should be enclosed in double quotes. Well, says them! Although Config::Simple supports parsing such configuration files already, it doesn't follow this rule while writing them. If you really need it to generate such compatible configuration files, \*(C`-strict\*(C' switch is what you need:</p><p>  use Config::Simple &apos;-strict&apos;;</p><p>Now, when you write the configuration data back to files, if values hold any none alpha-numeric strings, they will be quoted accordingly. All the double quotes that are part of the value will be escaped with a backslash.</p>
<h3>\s-1EXCEPTION\s0 \s-1HANDLING\s0</h3>
<p>Config::Simple doesn't believe in dying that easily (unless you insult it using wrong syntax). It leaves the decision to the programmer implementing the library. You can use its <em>error()</em> - class method to access underlying error message. Methods that require you to check for their return values are <em>read()</em> and <em>write()</em>. If you pass filename to <em>new()</em>, you will need to check its return value as well. They return any true value indicating success, undef otherwise:</p><p>  # following new() always returns true:   $cfg = new Config::Simple();</p><p>  # read() can fail:   $cfg-&gt;read(&apos;app.cfg&apos;) or die $cfg-&gt;error();</p><p>  # following new() can fail:   $cfg = new Config::Simple(&apos;app.cfg&apos;) or die Config::Simple-&gt;error();</p><p>  # import_from() calls read(), so it can fail:   Config::Simple-&gt;import_from(&apos;app.cfg&apos;, &#92;%Config) or die Config::Simple-&gt;error();</p><p>  # write() may fail:   $cfg-&gt;write() or die $cfg-&gt;error();</p><p>  # tie() may fail, since it calls new() with a filename   tie %Config, "Config::Simple", &apos;app.cfg&apos; or die Config::Simple-&gt;error();</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>new()</em>
  </dt>
  <dd>
    <p>- constructor. Optionally accepts several arguments. Returns Config::Simple object. Supported arguments are <strong>filename</strong>, <strong>syntax</strong>, <strong>autosave</strong>. If there is a single argument, will be treated as the name of the configuration file.</p>
  </dd>
  <dt>
    autosave([$bool])
  </dt>
  <dd>
    <p>- turns 'autosave' mode on if passed true argument. Returns current autosave mode if used without arguments. In 'autosave' mode Config::Simple writes all the changes back to its file without you having to call <em>write()</em> or <em>save()</em></p>
  </dd>
  <dt>
    <em>read()</em>
  </dt>
  <dd>
    <p>- accepts name  of the configuration file to parse. Before that, it tries to guess the syntax of the file by calling <em>guess_syntax()</em> method. Then calls either of <em>parse_ini_file()</em>, <em>parse_cfg_file()</em> or <em>parse_http_file()</em> accordingly. If the name of the file is provided to the constructor - <em>new()</em>, there is no need to call <em>read()</em>.</p>
  </dd>
  <dt>
    param([$name], [$value])
  </dt>
  <dd>
    <p>- used for accessing and updating configuration variables. If used with no arguments returns all the available names from the configuration file.</p>
  </dd>
  <dt>
    delete($name)
  </dt>
  <dd>
    <p>- deletes a variable from a configuration file. $name has the same meaning and syntax as it does in param($name)</p>
  </dd>
  <dt>
    <em>clear()</em>
  </dt>
  <dd>
    <p>- clears all the data from the object. Calling <em>save()</em> or turning <em>autosave()</em> on results in an empty configuration file as well.</p>
  </dd>
  <dt>
    <em>vars()</em>
  </dt>
  <dd>
    <p>- depending on the context used, returns all the values available in the configuration file either as a hash or a reference to a hash</p>
  </dd>
  <dt>
    import_names([$NS])
  </dt>
  <dd>
    <p>- imports all the names from the configuration file to the caller's name space. Optional argument, if passed, will be treated as the name space variables to be imported into. All the names will be uppercased. Non-alphanumeric strings in the values will be underscored - class method. If the second argument is a reference to an existing hash, it will load all the configuration contents into that hash. If the second argument is a string, it will be treated as the name space variables should be imported into, just like <em>import_names()</em> does.</p>
  </dd>
  <dt>
    get_block($name)
  </dt>
  <dd>
    <p>is mostly used for accessing blocks in ini-styled configuration files. Returns a hashref of all the key/value pairs of a given block. Also supported by <em>param()</em> method with the help of \*(L"-block\*(R" option:   $hash = $cfg-&gt;get_block(&apos;Project&apos;);   # is the same as saying:   $hash = $cfg-&gt;param(-block=&gt;&apos;Project&apos;); used in assigning contents to a block in ini-styled configuration files. $name should be the name of a [block], and $values is assumed to be a hashref mapping key/value pairs. Also supported by <em>param()</em> method with the help of \*(L"-block\*(R" and \*(L"-value\*(R" (or \*(L"-values\*(R") options:   $cfg-&gt;set_block(&apos;Project&apos;, {Count=&gt;3, &apos;Multiple Column&apos; =&gt; 20});   # is the same as:   $cfg-&gt;param(-block=&gt;&apos;Project&apos;, -value=&gt;{Count=&gt;3, &apos;Multiple Column&apos; =&gt; 20}); Warning: all the contents of a block, if previously existed will be wiped out. If you want to set specific key/value pairs, use explicit method:   $cfg-&gt;param(&apos;Project.Count&apos;, 3);</p>
  </dd>
  <dt>
    <em>as_string()</em>
  </dt>
  <dd>
    <p>- returns the configuration file as a chunk of text. It is the same text used by <em>write()</em> and <em>save()</em> to store the new configuration file back to file.</p>
  </dd>
  <dt>
    <em>write()</em>
  </dt>
  <dd>
    <p>- writes the configuration file into disk. Argument, if passed, will be treated as the name of the file configuration variables should be saved in.</p>
  </dd>
  <dt>
    <em>save()</em>
  </dt>
  <dd>
    <p>- same as <em>write()</em>.</p>
  </dd>
  <dt>
    <em>dump()</em>
  </dt>
  <dd>
    <p>- for debugging only. Dumps the whole Config::Simple object using Data::Dumper. Argument, if passed, will be treated as the name of the file object should be dumped in. The second argument specifies amount of indentation as documented in Data::Dumper manual. Default indent size is 2.</p>
  </dd>
  <dt>
    <em>error()</em>
  </dt>
  <dd>
    <p>- returns the last error message from read/write or import_* operations.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<ul>
<li><p>Support for lines with continuation character, '&#92;'. Currently its support is restricted and quite possibly buggy.</p></li><li><p>Retaining comments while writing the configuration files back and/or methods for manipulating comments. Everyone loves comments!</p></li><li><p>Retain the order of the blocks and other variables in the configuration files.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Submit bugs and possibly patches to Sherzod B. Ruzmetov &lt;sherzodr@cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREDITS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Michael Caldwell (mjc@mjcnet.com)
  </dt>
  <dd>
    <p>whitespace support, \*(C`-lc\*(C' switch and for various bug fixes</p>
  </dd>
  <dt>
    Scott Weinstein (Scott.Weinstein@lazard.com)
  </dt>
  <dd>
    <p>bug fix in \s-1TIEHASH\s0</p>
  </dd>
  <dt>
    Ruslan U. Zakirov &lt;cubic@wr.miee.ru&gt;
  </dt>
  <dd>
    <p>default name space suggestion and patch</p>
  </dd>
  <dt>
    Hirosi Taguti
  </dt>
  <dd>
    <p><em>import_names()</em> and <em>import_from()</em> idea.</p>
  </dd>
  <dt>
    Vitaly Kushneriuk
  </dt>
  <dd>
    <p>for bug fixes and suggestions</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>  Copyright (C) 2002-2003 Sherzod B. Ruzmetov.</p><p>  This software is free library. You can modify and/or distribute it   under the same terms as Perl itself</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>  Sherzod B. Ruzmetov E&lt;lt&gt;sherzodr@cpan.orgE&lt;gt&gt;   URI: http://author.handalak.com</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Config::Simple&hellip;</h2>
        <div class="sectioncontent">
<p>Config::General, Config::Simple, Config::Tiny</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Config::Scoped::Error.3pm.html"><span aria-hidden="true">&larr;</span> Config::Scoped::Error.3pm: An exception class hierarchy based on error.pm for config::scoped</a></li>
   <li class="next"><a href="Config::YAML.3pm.html">Config::YAML.3pm: Simple configuration automation <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

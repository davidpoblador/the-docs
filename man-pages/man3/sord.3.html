<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>sord: Sord -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Sord -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="sord (3) manual">
  <meta name="twitter:description" content="Sord -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libsord-doc-sord-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/sord.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="sord (3) manual" />
  <meta property="og:description" content="Sord -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libsord-doc-sord-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">sord<small> (3)</small></h1>
        <p class="lead">Sord -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/sord.3.html">
      <span itemprop="name">sord: Sord -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libsord-doc/">
      <span itemprop="name">libsord-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/sord.3.html">
      <span itemprop="name">sord: Sord -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>A lightweight RDF model library.</p><p>Sord stores RDF (subject object predicate context) quads, where the context may be omitted (to represent triples in the default graph).</p><h3>Typedefs</h3>
<p>typedef struct SordWorldImpl <strong>SordWorld</strong></p><p>typedef struct SordModelImpl <strong>SordModel</strong></p><p>typedef struct SordInserterImpl <strong>SordInserter</strong></p><p>typedef struct SordIterImpl <strong>SordIter</strong></p><p>typedef struct SordNodeImpl <strong>SordNode</strong></p><p>typedef const <strong>SordNode</strong> * <strong>SordQuad</strong> [4]</p>
<h3>Enumerations</h3>
<p>enum <strong>SordQuadIndex</strong> { <strong>SORD_SUBJECT</strong> = 0, <strong>SORD_PREDICATE</strong> = 1, <strong>SORD_OBJECT</strong> = 2, <strong>SORD_GRAPH</strong> = 3 }</p><p>enum <strong>SordNodeType</strong> { <strong>SORD_URI</strong> = 1, <strong>SORD_BLANK</strong> = 2, <strong>SORD_LITERAL</strong> = 3 }</p><p>enum <strong>SordIndexOption</strong> { <strong>SORD_SPO</strong> = 1, <strong>SORD_SOP</strong> = 1 &lt;&lt; 1, <strong>SORD_OPS</strong> = 1 &lt;&lt; 2, <strong>SORD_OSP</strong> = 1 &lt;&lt; 3, <strong>SORD_PSO</strong> = 1 &lt;&lt; 4, <strong>SORD_POS</strong> = 1 &lt;&lt; 5 }</p>
<h3>World</h3>
<p><strong>SordWorld</strong> * <strong>sord_world_new</strong> (void)</p><p>void <strong>sord_world_free</strong> (<strong>SordWorld</strong> *world)</p><p>void <strong>sord_world_set_error_sink</strong> (<strong>SordWorld</strong> *world, SerdErrorSink error_sink, void *handle)</p>
<h3>Node</h3>
<p><strong>SordNode</strong> * <strong>sord_new_uri</strong> (<strong>SordWorld</strong> *world, const uint8_t *uri)</p><p><strong>SordNode</strong> * <strong>sord_new_relative_uri</strong> (<strong>SordWorld</strong> *world, const uint8_t *str, const uint8_t *base_uri)</p><p><strong>SordNode</strong> * <strong>sord_new_blank</strong> (<strong>SordWorld</strong> *world, const uint8_t *str)</p><p><strong>SordNode</strong> * <strong>sord_new_literal</strong> (<strong>SordWorld</strong> *world, <strong>SordNode</strong> *datatype, const uint8_t *str, const char *lang)</p><p><strong>SordNode</strong> * <strong>sord_node_copy</strong> (const <strong>SordNode</strong> *node)</p><p>void <strong>sord_node_free</strong> (<strong>SordWorld</strong> *world, <strong>SordNode</strong> *node)</p><p><strong>SordNodeType</strong> <strong>sord_node_get_type</strong> (const <strong>SordNode</strong> *node)</p><p>const uint8_t * <strong>sord_node_get_string</strong> (const <strong>SordNode</strong> *node)</p><p>const uint8_t * <strong>sord_node_get_string_counted</strong> (const <strong>SordNode</strong> *node, size_t *len)</p><p>const char * <strong>sord_node_get_language</strong> (const <strong>SordNode</strong> *node)</p><p><strong>SordNode</strong> * <strong>sord_node_get_datatype</strong> (const <strong>SordNode</strong> *node)</p><p>SerdNodeFlags <strong>sord_node_get_flags</strong> (const <strong>SordNode</strong> *node)</p><p>bool <strong>sord_node_is_inline_object</strong> (const <strong>SordNode</strong> *node)</p><p>bool <strong>sord_node_equals</strong> (const <strong>SordNode</strong> *a, const <strong>SordNode</strong> *b)</p><p>const SerdNode * <strong>sord_node_to_serd_node</strong> (const <strong>SordNode</strong> *node)</p><p><strong>SordNode</strong> * <strong>sord_node_from_serd_node</strong> (<strong>SordWorld</strong> *world, SerdEnv *env, const SerdNode *node, const SerdNode *datatype, const SerdNode *lang)</p>
<h3>Model</h3>
<p><strong>SordModel</strong> * <strong>sord_new</strong> (<strong>SordWorld</strong> *world, unsigned indices, bool graphs)</p><p>void <strong>sord_free</strong> (<strong>SordModel</strong> *model)</p><p><strong>SordWorld</strong> * <strong>sord_get_world</strong> (<strong>SordModel</strong> *model)</p><p>size_t <strong>sord_num_nodes</strong> (const <strong>SordWorld</strong> *world)</p><p>size_t <strong>sord_num_quads</strong> (const <strong>SordModel</strong> *model)</p><p><strong>SordIter</strong> * <strong>sord_begin</strong> (const <strong>SordModel</strong> *model)</p><p><strong>SordIter</strong> * <strong>sord_find</strong> (<strong>SordModel</strong> *model, const <strong>SordQuad</strong> pat)</p><p><strong>SordIter</strong> * <strong>sord_search</strong> (<strong>SordModel</strong> *model, const <strong>SordNode</strong> *s, const <strong>SordNode</strong> *p, const <strong>SordNode</strong> *o, const <strong>SordNode</strong> *g)</p><p><strong>SordNode</strong> * <strong>sord_get</strong> (<strong>SordModel</strong> *model, const <strong>SordNode</strong> *s, const <strong>SordNode</strong> *p, const <strong>SordNode</strong> *o, const <strong>SordNode</strong> *g)</p><p>bool <strong>sord_ask</strong> (<strong>SordModel</strong> *model, const <strong>SordNode</strong> *s, const <strong>SordNode</strong> *p, const <strong>SordNode</strong> *o, const <strong>SordNode</strong> *g)</p><p>uint64_t <strong>sord_count</strong> (<strong>SordModel</strong> *model, const <strong>SordNode</strong> *s, const <strong>SordNode</strong> *p, const <strong>SordNode</strong> *o, const <strong>SordNode</strong> *g)</p><p>bool <strong>sord_contains</strong> (<strong>SordModel</strong> *model, const <strong>SordQuad</strong> pat)</p><p>bool <strong>sord_add</strong> (<strong>SordModel</strong> *model, const <strong>SordQuad</strong> quad)</p><p>void <strong>sord_remove</strong> (<strong>SordModel</strong> *model, const <strong>SordQuad</strong> quad)</p>
<h3>Inserter</h3>
<p><strong>SordInserter</strong> * <strong>sord_inserter_new</strong> (<strong>SordModel</strong> *model, SerdEnv *env)</p><p>void <strong>sord_inserter_free</strong> (<strong>SordInserter</strong> *inserter)</p><p>SerdStatus <strong>sord_inserter_set_base_uri</strong> (<strong>SordInserter</strong> *inserter, const SerdNode *uri)</p><p>SerdStatus <strong>sord_inserter_set_prefix</strong> (<strong>SordInserter</strong> *inserter, const SerdNode *name, const SerdNode *uri)</p><p>SerdStatus <strong>sord_inserter_write_statement</strong> (<strong>SordInserter</strong> *inserter, SerdStatementFlags flags, const SerdNode *graph, const SerdNode *subject, const SerdNode *predicate, const SerdNode *object, const SerdNode *object_datatype, const SerdNode *object_lang)</p>
<h3>Iteration</h3>
<p>void <strong>sord_iter_get</strong> (const <strong>SordIter</strong> *iter, <strong>SordQuad</strong> quad)</p><p>const <strong>SordNode</strong> * <strong>sord_iter_get_node</strong> (const <strong>SordIter</strong> *iter, <strong>SordQuadIndex</strong> index)</p><p>const <strong>SordModel</strong> * <strong>sord_iter_get_model</strong> (<strong>SordIter</strong> *iter)</p><p>bool <strong>sord_iter_next</strong> (<strong>SordIter</strong> *iter)</p><p>bool <strong>sord_iter_end</strong> (const <strong>SordIter</strong> *iter)</p><p>void <strong>sord_iter_free</strong> (<strong>SordIter</strong> *iter)</p>
<h3>Utilities</h3>
<p>bool <strong>sord_quad_match</strong> (const <strong>SordQuad</strong> x, const <strong>SordQuad</strong> y)</p>
<h3>Serialisation</h3>
<p>SerdReader * <strong>sord_new_reader</strong> (<strong>SordModel</strong> *model, SerdEnv *env, SerdSyntax syntax, <strong>SordNode</strong> *graph)</p><p>bool <strong>sord_write</strong> (<strong>SordModel</strong> *model, SerdWriter *writer, <strong>SordNode</strong> *graph)</p><p>bool <strong>sord_write_iter</strong> (<strong>SordIter</strong> *iter, SerdWriter *writer)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>typedef struct SordWorldImpl \fBSordWorld\fP</h3>
<p>Sord World. The World represents all library state, including interned strings.</p>
<h3>typedef struct SordModelImpl \fBSordModel\fP</h3>
<p>Sord Model. A model is an indexed set of Quads (i.e. it can contain several RDF graphs). It may be searched using various patterns depending on which indices are enabled.</p>
<h3>typedef struct SordInserterImpl \fBSordInserter\fP</h3>
<p>Model Inserter. An inserter is used for writing statements to a model using the Serd sink interface. This makes it simple to write to a model directly using a SerdReader, or any other code that writes statements to a SerdStatementSink.</p>
<h3>typedef struct SordIterImpl \fBSordIter\fP</h3>
<p>Model Iterator.</p>
<h3>typedef struct SordNodeImpl \fBSordNode\fP</h3>
<p>RDF Node. A Node is a component of a Quad. Nodes may be URIs, blank nodes, or (in the case of quad objects only) string literals. Literal nodes may have an associate language or datatype (but not both).</p>
<h3>typedef const \fBSordNode\fP* SordQuad[4]</h3>
<p>Quad of nodes (a statement), or a quad pattern. Nodes are ordered (S P O G). The ID of the default graph is 0.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Enumeration Type Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSordQuadIndex\fP</h3>
<p>Index into a SordQuad.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SORD_SUBJECT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Subject.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_PREDICATE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Predicate (a.k.a. 'key')</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_OBJECT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Object (a.k.a. 'value')</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_GRAPH </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Graph (a.k.a. 'context')</p>
  </dd>

</dl>

<h3>enum \fBSordNodeType\fP</h3>
<p>Type of a node.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SORD_URI </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>URI.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_BLANK </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Blank node identifier.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_LITERAL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Literal (string with optional lang or datatype)</p>
  </dd>

</dl>

<h3>enum \fBSordIndexOption\fP</h3>
<p>Indexing option.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SORD_SPO </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Subject, Predicate, Object.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_SOP </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Subject, Object, Predicate.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_OPS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Object, Predicate, Subject.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_OSP </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Object, Subject, Predicate.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_PSO </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Predicate, Subject, Object.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SORD_POS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Predicate, Object, Subject.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSordWorld\fP* sord_world_new (void)</h3>
<p>Create a new Sord World. It is safe to use multiple worlds in one process, though no data (e.g. nodes) can be shared between worlds, and this should be avoided if possible for performance reasons.</p>
<h3>void sord_world_free (\fBSordWorld\fP *world)</h3>
<p>Free world.</p>
<h3>void sord_world_set_error_sink (\fBSordWorld\fP *world, SerdErrorSinkerror_sink, void *handle)</h3>
<p>Set a function to be called when errors occur. The error_sink will be called with handle as its first argument. If no error function is set, errors are printed to stderr.</p>
<h3>\fBSordNode\fP* sord_new_uri (\fBSordWorld\fP *world, const uint8_t *uri)</h3>
<p>Get a URI node from a string. Note this function measures str, which is a common bottleneck. Use sord_node_from_serd_node instead if str is already measured.</p>
<h3>\fBSordNode\fP* sord_new_relative_uri (\fBSordWorld\fP *world, const uint8_t *str, const uint8_t *base_uri)</h3>
<p>Get a URI node from a relative URI string.</p>
<h3>\fBSordNode\fP* sord_new_blank (\fBSordWorld\fP *world, const uint8_t *str)</h3>
<p>Get a blank node from a string. Note this function measures str, which is a common bottleneck. Use sord_node_from_serd_node instead if str is already measured.</p>
<h3>\fBSordNode\fP* sord_new_literal (\fBSordWorld\fP *world, \fBSordNode\fP *datatype, const uint8_t *str, const char *lang)</h3>
<p>Get a literal node from a string. Note this function measures str, which is a common bottleneck. Use sord_node_from_serd_node instead if str is already measured.</p>
<h3>\fBSordNode\fP* sord_node_copy (const \fBSordNode\fP *node)</h3>
<p>Copy a node (obtain a reference). Node that since nodes are interned and reference counted, this does not actually create a deep copy of node.</p>
<h3>void sord_node_free (\fBSordWorld\fP *world, \fBSordNode\fP *node)</h3>
<p>Free a node (drop a reference).</p>
<h3>\fBSordNodeType\fP sord_node_get_type (const \fBSordNode\fP *node)</h3>
<p>Return the type of a node (SORD_URI, SORD_BLANK, or SORD_LITERAL).</p>
<h3>const uint8_t* sord_node_get_string (const \fBSordNode\fP *node)</h3>
<p>Return the string value of a node.</p>
<h3>const uint8_t* sord_node_get_string_counted (const \fBSordNode\fP *node, size_t *len)</h3>
<p>Return the string value of a node, and set len to its length.</p>
<h3>const char* sord_node_get_language (const \fBSordNode\fP *node)</h3>
<p>Return the language of a literal node (or NULL).</p>
<h3>\fBSordNode\fP* sord_node_get_datatype (const \fBSordNode\fP *node)</h3>
<p>Return the datatype URI of a literal node (or NULL).</p>
<h3>SerdNodeFlags sord_node_get_flags (const \fBSordNode\fP *node)</h3>
<p>Return the flags (string attributes) of a node.</p>
<h3>bool sord_node_is_inline_object (const \fBSordNode\fP *node)</h3>
<p>Return true iff node can be serialised as an inline object. More specifically, this returns true iff the node is the object field of exactly one statement, and therefore can be inlined since it needn't be referred to by name.</p>
<h3>bool sord_node_equals (const \fBSordNode\fP *a, const \fBSordNode\fP *b)</h3>
<p>Return true iff a is equal to b. Note this is much faster than comparing the node's strings.</p>
<h3>const SerdNode* sord_node_to_serd_node (const \fBSordNode\fP *node)</h3>
<p>Return a SordNode as a SerdNode. The returned node is shared and must not be freed or modified.</p>
<h3>\fBSordNode\fP* sord_node_from_serd_node (\fBSordWorld\fP *world, SerdEnv *env, const SerdNode *node, const SerdNode *datatype, const SerdNode *lang)</h3>
<p>Create a new SordNode from a SerdNode. The returned node must be freed using sord_node_free.</p>
<h3>\fBSordModel\fP* sord_new (\fBSordWorld\fP *world, unsignedindices, boolgraphs)</h3>
<p>Create a new model.</p><p><strong>Parameters:</strong></p><p><em>world</em> The world in which to make this model.</p><p><em>indices</em> SordIndexOption flags (e.g. SORD_SPO|SORD_OPS). Be sure to enable an index where the most significant node(s) are not variables in your queries (e.g. to make (? P O) queries, enable either SORD_OPS or SORD_POS).</p><p><em>graphs</em> If true, store (and index) graph contexts.</p>
<h3>void sord_free (\fBSordModel\fP *model)</h3>
<p>Close and free model.</p>
<h3>\fBSordWorld\fP* sord_get_world (\fBSordModel\fP *model)</h3>
<p>Get the world associated with model.</p>
<h3>size_t sord_num_nodes (const \fBSordWorld\fP *world)</h3>
<p>Return the number of nodes stored in world. Nodes are included in this count iff they are a part of a quad in world.</p>
<h3>size_t sord_num_quads (const \fBSordModel\fP *model)</h3>
<p>Return the number of quads stored in model.</p>
<h3>\fBSordIter\fP* sord_begin (const \fBSordModel\fP *model)</h3>
<p>Return an iterator to the start of model.</p>
<h3>\fBSordIter\fP* sord_find (\fBSordModel\fP *model, const \fBSordQuad\fPpat)</h3>
<p>Search for statements by a quad pattern.</p><p><strong>Returns:</strong></p><p>an iterator to the first match, or NULL if no matches found.</p>
<h3>\fBSordIter\fP* sord_search (\fBSordModel\fP *model, const \fBSordNode\fP *s, const \fBSordNode\fP *p, const \fBSordNode\fP *o, const \fBSordNode\fP *g)</h3>
<p>Search for statements by nodes.</p><p><strong>Returns:</strong></p><p>an iterator to the first match, or NULL if no matches found.</p>
<h3>\fBSordNode\fP* sord_get (\fBSordModel\fP *model, const \fBSordNode\fP *s, const \fBSordNode\fP *p, const \fBSordNode\fP *o, const \fBSordNode\fP *g)</h3>
<p>Search for a single node that matches a pattern. Exactly one of s, p, o must be NULL. This function is mainly useful for predicates that only have one value. The returned node must be freed using sord_node_free.</p><p><strong>Returns:</strong></p><p>the first matching node, or NULL if no matches are found.</p>
<h3>bool sord_ask (\fBSordModel\fP *model, const \fBSordNode\fP *s, const \fBSordNode\fP *p, const \fBSordNode\fP *o, const \fBSordNode\fP *g)</h3>
<p>Return true iff a statement exists.</p>
<h3>uint64_t sord_count (\fBSordModel\fP *model, const \fBSordNode\fP *s, const \fBSordNode\fP *p, const \fBSordNode\fP *o, const \fBSordNode\fP *g)</h3>
<p>Return the number of matching statements.</p>
<h3>bool sord_contains (\fBSordModel\fP *model, const \fBSordQuad\fPpat)</h3>
<p>Check if model contains a triple pattern.</p>
<h3>bool sord_add (\fBSordModel\fP *model, const \fBSordQuad\fPquad)</h3>
<p>Add a quad to a model.</p>
<h3>void sord_remove (\fBSordModel\fP *model, const \fBSordQuad\fPquad)</h3>
<p>Remove a quad from a model. Note that is it illegal to remove while iterating over model.</p>
<h3>\fBSordInserter\fP* sord_inserter_new (\fBSordModel\fP *model, SerdEnv *env)</h3>
<p>Create an inserter for writing statements to a model.</p>
<h3>void sord_inserter_free (\fBSordInserter\fP *inserter)</h3>
<p>Free an inserter.</p>
<h3>SerdStatus sord_inserter_set_base_uri (\fBSordInserter\fP *inserter, const SerdNode *uri)</h3>
<p>Set the current base URI for writing to the model. Note this function can be safely casted to SerdBaseSink.</p>
<h3>SerdStatus sord_inserter_set_prefix (\fBSordInserter\fP *inserter, const SerdNode *name, const SerdNode *uri)</h3>
<p>Set a namespace prefix for writing to the model. Note this function can be safely casted to SerdPrefixSink.</p>
<h3>SerdStatus sord_inserter_write_statement (\fBSordInserter\fP *inserter, SerdStatementFlagsflags, const SerdNode *graph, const SerdNode *subject, const SerdNode *predicate, const SerdNode *object, const SerdNode *object_datatype, const SerdNode *object_lang)</h3>
<p>Write a statement to the model. Note this function can be safely casted to SerdStatementSink.</p>
<h3>void sord_iter_get (const \fBSordIter\fP *iter, \fBSordQuad\fPquad)</h3>
<p>Set quad to the quad pointed to by iter.</p>
<h3>const \fBSordNode\fP* sord_iter_get_node (const \fBSordIter\fP *iter, \fBSordQuadIndex\fPindex)</h3>
<p>Return a field of the quad pointed to by iter.</p>
<h3>const \fBSordModel\fP* sord_iter_get_model (\fBSordIter\fP *iter)</h3>
<p>Return the store pointed to by iter.</p>
<h3>bool sord_iter_next (\fBSordIter\fP *iter)</h3>
<p>Increment iter to point to the next statement.</p>
<h3>bool sord_iter_end (const \fBSordIter\fP *iter)</h3>
<p>Return true iff iter is at the end of its range.</p>
<h3>void sord_iter_free (\fBSordIter\fP *iter)</h3>
<p>Free iter.</p>
<h3>bool sord_quad_match (const \fBSordQuad\fPx, const \fBSordQuad\fPy)</h3>
<p>Match two quads (using ID comparison only). This function is a straightforward and fast equivalence match with wildcard support (ID 0 is a wildcard). It does not actually read node data.</p><p><strong>Returns:</strong></p><p>true iff x and y match.</p>
<h3>SerdReader* sord_new_reader (\fBSordModel\fP *model, SerdEnv *env, SerdSyntaxsyntax, \fBSordNode\fP *graph)</h3>
<p>Return a reader that will read into model.</p>
<h3>bool sord_write (\fBSordModel\fP *model, SerdWriter *writer, \fBSordNode\fP *graph)</h3>
<p>Write a model to a writer.</p>
<h3>bool sord_write_iter (\fBSordIter\fP *iter, SerdWriter *writer)</h3>
<p>Write a range to a writer. This increments iter to its end, then frees it.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Sord from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="sorcsd2by1.f.3.html"><span aria-hidden="true">&larr;</span> sorcsd2by1.f.3: Sorcsd2by1.f -</a></li>
   <li class="next"><a href="sorg2l.3.html">sorg2l.3: Sorg2l.f - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

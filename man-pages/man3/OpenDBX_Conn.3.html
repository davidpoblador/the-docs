<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>OpenDBX_Conn: Encapsulates a connection to a database.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Encapsulates a connection to a database.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="OpenDBX_Conn (3) manual">
  <meta name="twitter:description" content="Encapsulates a connection to a database.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libopendbx1-dev-OpenDBX_Conn-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/OpenDBX_Conn.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="OpenDBX_Conn (3) manual" />
  <meta property="og:description" content="Encapsulates a connection to a database." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libopendbx1-dev-OpenDBX_Conn-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">OpenDBX_Conn<small> (3)</small></h1>
        <p class="lead">Encapsulates a connection to a database.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/OpenDBX_Conn.3.html">
      <span itemprop="name">OpenDBX_Conn: Encapsulates a connection to a database.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libopendbx1-dev/">
      <span itemprop="name">libopendbx1-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/OpenDBX_Conn.3.html">
      <span itemprop="name">OpenDBX_Conn: Encapsulates a connection to a database.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<h3>Public Member Functions</h3>
<p>void <strong>bind</strong> (const char *database, const char *who='', const char *cred='', odbxbind method=ODBX_BIND_SIMPLE)  throw ( std::exception )</p><p><em>Authenticates the user and selects the database using C style string parameters. </em> void <strong>bind</strong> (const string &database, const string &who='', const string &cred='', odbxbind method=ODBX_BIND_SIMPLE)  throw ( std::exception )</p><p><em>Authenticates the user and selects the database using C++ style string parameters. </em> <strong>Conn</strong> ()  throw ()</p><p><em>The default constructor for newly created connection objects without parameters. </em> <strong>Conn</strong> (const char *backend, const char *host='', const char *port='')  throw ( std::exception )</p><p><em>Creates a connection object using C style string parameters. </em> <strong>Conn</strong> (const string &backend, const string &host='', const string &port='')  throw ( std::exception )</p><p><em>Creates a connection object using C++ style string parameters. </em> <strong>Conn</strong> (const <strong>Conn</strong> &ref)  throw ()</p><p><em>Copy constructor. </em> <strong>Stmt</strong> <strong>create</strong> (const char *sql, unsigned long size=0, <strong>Stmt::Type</strong> type=Stmt::Simple)  throw ( std::exception )</p><p><em>Creates a statement object from a SQL text string using a C style buffer. </em> <strong>Stmt</strong> <strong>create</strong> (const string &sql, <strong>Stmt::Type</strong> type=Stmt::Simple)  throw ( std::exception )</p><p><em>Creates a statement object from a SQL text string using a C++ string. </em> string & <strong>escape</strong> (const char *from, unsigned long fromlen, string &to)  throw ( std::exception )</p><p><em>Escapes potentially dangerous characters in user input using a C style buffer. </em> string & <strong>escape</strong> (const string &from, string &to)  throw ( std::exception )</p><p><em>Escapes potentially dangerous characters in user input using a C++ style string parameter. </em> void <strong>finish</strong> ()  throw ( std::exception )</p><p><em>Cleans up the connection object. </em> bool <strong>getCapability</strong> (odbxcap cap)  throw ( std::exception )</p><p><em>Tests if the database driver module does understand certain extensions. </em> void <strong>getOption</strong> (odbxopt option, void *value)  throw ( std::exception )</p><p><em>Gets the value of a certain option provided by the database driver module. </em> <strong>Conn</strong> & <strong>operator=</strong> (const <strong>Conn</strong> &ref)  throw ()</p><p><em>Assigns a connection instance to another one. </em> void <strong>setOption</strong> (odbxopt option, void *value)  throw ( std::exception )</p><p><em>Sets a certain option provided by the database driver module. </em> void <strong>unbind</strong> ()  throw ( std::exception )</p><p><em>Releases the connection to the database and resets the authentication status. </em> <strong>~Conn</strong> ()  throw ()</p><p><em>Destroys the connection instance if no other references exist. </em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>Encapsulates a connection to a database.</p><p><strong>Author:</strong></p><p>Norbert Sendetzky norbert@linuxnetworks.de</p><p><strong>Version:</strong></p><p>1.0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>OpenDBX::Conn::Conn ()</h3>
<p>The default constructor for newly created connection objects without parameters. This is method is provided to enable programmers to use connection objects as member variables of other classes. They are initialized at construction time of the encapsulating object when no values for backend, host and port are available yet.</p><p>It's necessary to replace the created object later on by a connection instance where the necessary parameters have been given via one of the other constructors. Calling one of the member functions of an instance created by the default constructor isn't possible and will throw an exception.</p><p><strong>Returns:</strong></p><p>Empty connection instance</p><p><strong>See also:</strong></p><p><strong>Conn( const char*, const char*, const char* )</strong></p><p><strong>Conn( const string&, const string&, const string& )</strong></p>
<h3>OpenDBX::Conn::Conn (const char *backend, const char *host = \fC''\fP, const char *port = \fC''\fP)std::exception</h3>
<p>Creates a connection object using C style string parameters. Initializes a new connection using the parameters <em>backend</em>, <em>host</em> and <em>port</em>, but doesn't open the connection to the database yet. This method allows C style strings as values for all parameters. Another constructor for C++ style strings is also available. It returns a new connection instance, which can be used to query options implemented by the driver or to create a statement. In case of an error, it throws an <strong>OpenDBX</strong> exception with error message, code and severity.</p><p>The parameter <em>backend</em> is the name of the driver the <strong>OpenDBX</strong> library should use to connect to a database. The name must be one of the implemented and available drivers on the system and is case sensitive. All driver names are in lower case, e.g. 'mysql'.</p><p>Depending on the database driver, <em>host</em> can have different meanings. Normally, it's the name or IP address of the server hosting the database server application. In case of serverless database implementations like SQLite it's the directory path where the database file is located. The path must contain the platform specific path separators like slash ('/') on Unix-like systems and backslash ('&#92;') on Windows systems. Also the path must end with the path separator like '/path/to/file/'.</p><p>Furthermore <em>port</em> can be the number or name the database server application is listening to. If a name instead of the number is allowed depends on the database client library but the number as string does always work. If an empty string is given, the default port of the database server application is used by the database client library.</p><p><strong>Parameters:</strong></p><p><em>backend</em> Name of the backend module to use</p><p><em>host</em> Name or IP address of the database server</p><p><em>port</em> Name or number of the port used by the database server</p><p><strong>Returns:</strong></p><p>Connection instance</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p><p><strong>See also:</strong></p><p><strong>Conn( const string&, const string&, const string& )</strong></p>
<h3>OpenDBX::Conn::Conn (const string &backend, const string &host = \fC''\fP, const string &port = \fC''\fP)std::exception</h3>
<p>Creates a connection object using C++ style string parameters. Initializes a new connection using the parameters backend, host and port, but doesn't open the connection to the database yet. This method allows C++ style strings as values for all parameters. Another construtor for C style strings is also available. It returns a new connection instance, which can be used to query options implemented by the driver or to create a statement. In case of an error, it throws an <strong>OpenDBX</strong> exception with error message, code and severity.</p><p>The parameter <em>backend</em> is the name of the driver the <strong>OpenDBX</strong> library should use to connect to a database. The name must be one of the implemented and available drivers on the system and is case sensitive. All driver names are in lower case, e.g. 'mysql'.</p><p>Depending on the database driver, <em>host</em> can have different mearings. Normally, it's the name or IP address of the server hosting the database server application. In case of serverless database implementations like SQLite it's the directory path where the database file is located. The path must contain the platform specific path separators like slash ('/') on Unix-like systems and backslash ('&#92;') on Windows systems. Also the path must end with the path separator like '/path/to/file/'.</p><p>Furthermore <em>port</em> can be the number or name the database server application is listening to. If a name instead of the number is allowed depends on the database client library but the number as string does always work. If an empty string is given, the default port of the database server application is used by the database client library.</p><p><strong>Parameters:</strong></p><p><em>backend</em> Name of the backend module to use</p><p><em>host</em> Name or IP address of the database server</p><p><em>port</em> Name or number of the port used by the database server</p><p><strong>Returns:</strong></p><p>Connection instance</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p><p><strong>See also:</strong></p><p><strong>Conn( const char*, const char*, const char* )</strong></p>
<h3>OpenDBX::Conn::~Conn ()</h3>
<p>Destroys the connection instance if no other references exist. Each connection object uses a reference counter to remember if the connection is shared with other objects. If this isn't the case or if this object is the last one referencing the connection, the connection is closed and the allocated memory is freed.</p>
<h3>OpenDBX::Conn::Conn (const \fBConn\fP &ref)</h3>
<p>Copy constructor. Enables the transfer of the internal state of an object <em>ref</em> of the same type to this object. Both objects share the same database connection and the reference counter afterwards. The reference counter is incremented each time an object is copied and will be decremented if it is destroyed.</p><p><strong>Parameters:</strong></p><p><em>ref</em> Original connection object instance</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void OpenDBX::Conn::bind (const char *database, const char *who = \fC''\fP, const char *cred = \fC''\fP, odbxbindmethod = \fCODBX_BIND_SIMPLE\fP)std::exception</h3>
<p>Authenticates the user and selects the database using C style string parameters. After initializing the object instance with one of the constructors taking a backend, host and port string as parameter, it's necessary to authenticate the user and select a database. Depending on the database client library, it also establishes the connection to the database server. This method accepts C style strings for the database name, the user name and the password.</p><p>The first parameter, the name of the database will be used to select the database all further commands are operating on. The database is the container for the tables, views, etc., which store the records and provide access to them.</p><p>Authentication is done in most cases by a combination of a user name and a password. If the user name is known by the database server and the supplied password matches with the stored one, the database server will allow the user to operate on the selected database and its tables provided the user has permissions to read and/or modify the content.</p><p>The <em>method</em> parameter can be used to select different methods of authentication. At the moment, only simple authentication (ODBX_BIND_SIMPLE) with user name and password is available.</p><p><strong>Parameters:</strong></p><p><em>database</em> Name of the database managed by the database server</p><p><em>who</em> Name of the user account known by the database server</p><p><em>cred</em> Necessary credential which belongs to the user account</p><p><em>method</em> Method used for authentication</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>
<h3>void OpenDBX::Conn::bind (const string &database, const string &who = \fC''\fP, const string &cred = \fC''\fP, odbxbindmethod = \fCODBX_BIND_SIMPLE\fP)std::exception</h3>
<p>Authenticates the user and selects the database using C++ style string parameters. After initializing the object instance with one of the constructors taking a backend, host and port string as parameter, it's necessary to authenticate the user and select a database. Depending on the database client library, it also establishes the connection to the database server. This method accepts C++ style strings for the database name, the user name and the password.</p><p>The first parameter, the name of the database will be used to select the database all further commands are operating on. The database is the container for the tables, views, etc., which store the records and provide access to them.</p><p>Authentication is done in most cases by a combination of a user name and a password. If the user name is known by the database server and the supplied password matches with the stored one, the database server will allow the user to operate on the selected database and its tables provided the user has permissions to read and/or modify the content.</p><p>The <em>method</em> parameter can be used to select different methods of authentication. At the moment, only simple authentication (ODBX_BIND_SIMPLE) with user name and password is available.</p><p><strong>Parameters:</strong></p><p><em>database</em> Name of the database managed by the database server</p><p><em>who</em> Name of the user account known by the database server</p><p><em>cred</em> Necessary credential which belongs to the user account</p><p><em>method</em> Method used for authentication</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>
<h3>\fBStmt\fP OpenDBX::Conn::create (const char *sql, unsigned longsize = \fC0\fP, \fBStmt::Type\fPtype = \fCStmt::Simple\fP)std::exception</h3>
<p>Creates a statement object from a SQL text string using a C style buffer. This method returns an instance of the <strong>Stmt</strong> class that contains the statement sent to the database server later on. Currently, only simple statements are supported, which are sent to the database server for parsing and returning the result after calling <strong>Stmt::execute()</strong>. Later on also prepared statements will be possible which are parsed by the database server when creating the object and only the parameters will be sent to the database server on execution. This can speed up processing especially if the statement is executed multiple times with different content for the parameters.</p><p>The parameter named <em>sql</em> must contain the SQL text string that should be sent to the database server for execution. It have to be a C style buffer in this case. For a reference of valid SQL statements, please have a look at the documentation of your database server.</p><p>The length of the statement excluding the trailing '0' byte should be given via the second parameter <em>size</em>. If the length of the statement is unknown, you can also supply zero (0) as size value which is also the default value if you hand over only one parameter. In this case, the length of the string is calculated internally by this function before the statement is given to the native database library.</p><p>Via the last parameter it can be selected how the statement should be treated internally by the <strong>OpenDBX</strong> and the native database library. Currently, only simple processing is available which sends complete SQL statements including its parameters as string to the database server for parsing and execution. Later on, also prepared statement handling will be available which parses the statements first and sends only the parameters to the server before execution. This parameter is also optional.</p><p>The returned object is representing the given statement, which can be executed later on. The statement is only valid for the current connection and as soon as the connection gets invalid or is closed, working with this object will throw an error.</p><p><strong>Parameters:</strong></p><p><em>sql</em> SQL text string containing a valid statement understood by the database server</p><p><em>size</em> Size of the SQL text string in bytes</p><p><em>type</em> Type of statement object that should be created</p><p><strong>Returns:</strong></p><p>Statement instance bound to this connection</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p><p><strong>See also:</strong></p><p><strong>Stmt</strong></p>
<h3>\fBStmt\fP OpenDBX::Conn::create (const string &sql, \fBStmt::Type\fPtype = \fCStmt::Simple\fP)std::exception</h3>
<p>Creates a statement object from a SQL text string using a C++ string. This method returns an instance of the <strong>Stmt</strong> class that contains the statement sent to the database server later on. Currently, only simple statements are supported, which are sent to the database server for parsing and returning the result after calling <strong>Stmt::execute()</strong>. Later on also prepared statements will be possible which are parsed by the database server when creating the object and only the parameters will be sent to the database server on execution. This can speed up processing especially if the statement is executed multiple times with different content for the parameters.</p><p>The parameter named <em>sql</em> must contain the SQL text string that should be sent to the database server for execution. It have to be a C++ style string in this case. For a reference of valid SQL statements, please have a look at the documentation of your database server.</p><p>Via the last parameter <em>type</em> it can be selected how the statement should be treated internally by the <strong>OpenDBX</strong> and the native database library. Currently, only simple processing is available which sends complete SQL statements including its parameters as string to the database server for parsing and execution. Later on, also prepared statement handling will be available which parses the statements first and sends only the parameters to the server before execution. This parameter is also optional.</p><p>The returned object is representing the given statement, which can be executed later on. The statement is only valid for the current connection and as soon as the connection gets invalid or is closed, working with this object will throw an error.</p><p><strong>Parameters:</strong></p><p><em>sql</em> SQL text string containing a valid statement understood by the database server</p><p><em>type</em> Type of statement object that should be created</p><p><strong>Returns:</strong></p><p>Statement instance bound to this connection</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p><p><strong>See also:</strong></p><p><strong>Stmt</strong></p>
<h3>string& OpenDBX::Conn::escape (const char *from, unsigned longfromlen, string &to)std::exception</h3>
<p>Escapes potentially dangerous characters in user input using a C style buffer. For preventing SQL injection attacks which can have desasterous effects, all text input that will be part of an SQL statement must be escaped. This does also apply to user content that is already stored in the database and should be copied to another record or stored again as the escaping is removed before the database server writes the content to disk.</p><p>The first parameter must contain the character sequence that should be escaped as C style string. This string itself won't be modified by this method.</p><p>The escaped string will be written to the third parameter named <em>to</em>, which have to be also an C++ style string. After transforming the input to an escaped string, the result may be more then twice the size of the original input. The additional escape sequences aren't stored in the database column so only the original string will be written to the disk.</p><p>A C++ reference of the third parameter containing the escaped string afterwards is also returned by this method to providing the possibility to write more elegant code.</p><p><strong>Parameters:</strong></p><p><em>from</em> Input string with which may contain dangerous characters</p><p><em>fromlen</em> Size of the input string to escape in bytes</p><p><em>to</em> String instance where the escaped characters should be written to</p><p><strong>Returns:</strong></p><p>Reference to the second parameter containing the escaped characters</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>
<h3>string& OpenDBX::Conn::escape (const string &from, string &to)std::exception</h3>
<p>Escapes potentially dangerous characters in user input using a C++ style string parameter. For preventing SQL injection attacks which can have desasterous effects, all text input that will be part of an SQL statement must be escaped. This does also apply to user content that is already stored in the database and should be copied to another record or stored again as the escaping is removed before the database server writes the content to disk.</p><p>The first parameter must contain the character sequence that should be escaped as C++ style string. This string itself won't be modified by this method.</p><p>The escaped string will be written to the third parameter named <em>to</em>, which have to be also an C++ style string. After transforming the input to an escaped string, the result may be more then twice the size of the original input. The additional escape sequences aren't stored in the database column so only the original string will be written to the disk.</p><p>A C++ reference of the second parameter containing the escaped string afterwards is also returned by this method too, providing the possibility to write more elegant code.</p><p><strong>Parameters:</strong></p><p><em>from</em> Input string with which may contain dangerous characters</p><p><em>to</em> String instance where the escaped characters should be written to</p><p><strong>Returns:</strong></p><p>Reference to the second parameter containing the escaped characters</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>
<h3>void OpenDBX::Conn::finish ()std::exception</h3>
<p>Cleans up the connection object.</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>
<h3>bool OpenDBX::Conn::getCapability (odbxcapcap)std::exception</h3>
<p>Tests if the database driver module does understand certain extensions. The <strong>OpenDBX</strong> library consists of a basic set of functions that must be implemented by all drivers and optional sets for additional functionality. This method allows an application to ask the driver selected by the first parameter of the constructor of this object if it supports one or more optional sets. The available sets and its constants are:</p><ul>
<li><p>ODBX_CAP_BASIC</p><p> The core function set which have to be implemented by all backends. It consists of all functions necessary to connect to, send textual queries to and process simple results returned from the database server as well as error handling functions.</p></li><li><p>ODBX_CAP_LO</p><p> The function set for handling large objects whose content isn't accessible by the basic function. Currently, Firebird/Interbase and Oracle requires using the LOB functions.</p></li>
</ul><p>The basic set makes sure that all drivers can handle connections to the databases, send statements and retrieve results. It's supported by all drivers and usually don't have to be checked.</p><p>Some databases client libraries provide the content of large objects not via the basic functions. Instead, the <strong>Result::fieldValue()</strong> method returns only a handle to the large object and reading or modifying the content of this data object requires calling additional methods.</p><p><strong>Parameters:</strong></p><p><em>cap</em> Constant of the capability</p><p><strong>Returns:</strong></p><p>True if supported, false if not</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>
<h3>void OpenDBX::Conn::getOption (odbxoptoption, void *value)std::exception</h3>
<p>Gets the value of a certain option provided by the database driver module. It asks the backend module for implemented options and their current values. This function can be used at every stage and its primary use is to find out supported features of the backend module. This features can be enable with <strong>setOption()</strong> before the connection to the database server is established by calling <strong>bind()</strong>.</p><p>There are several option values defined as named constants in the opendbx/api.h header file. A few of them are for informational purpose only while most of the options can also be set to different values by <strong>setOption()</strong> to change the behavior of the backend module. These options are:</p><ul>
<li><p>ODBX_OPT_API_VERSION</p><p> The API version implemented by the backend. It returns a five digit number representing the API version of the backend module in the form XYYZZ where X is the major number, YY the revision and ZZ the minor number of the API.</p></li><li><p>ODBX_OPT_THREAD_SAFE</p><p> If it is safe to use this backend and especially the native database client library in an application which uses threads where more than one thread opens database connections via the <strong>OpenDBX</strong> library.</p></li><li><p>ODBX_OPT_TLS</p><p> The database client library may support transmitting all data securely by encrypting the network traffic via SSL or TLS.</p></li><li><p>ODBX_OPT_MULTI_STATEMENTS</p><p> The database server may be able to support multiple SQL statements in one string sent to the database.</p></li><li><p>ODBX_OPT_PAGED_RESULTS</p><p> All database servers and client libraries are able to transfer the records row by row. Some of them can also transfer multiple rows or even all at once to minimize server load, network traffic and latency. The downside of this is an increased memory consumption.</p></li><li><p>ODBX_OPT_COMPRESS</p><p> Support of compressed network traffic between database client and server. This can lead to higher throughput if the network is the bottleneck.</p></li><li><p>ODBX_OPT_MODE</p><p> Some database servers support different modes of operation, e.g. modes for compliance to other SQL implementations or completely different query languages.</p></li>
</ul><p>The parameter <em>value</em> must be a pointer to an integer variable where the backend module will store the result for the supplied option. If it's not stated otherwise, the value assigned to the this parameter will be of boolean nature and therefore is ODBX_ENABLE for a supported option or ODBX_DISABLE for an option which isn't supported.</p><p><strong>Parameters:</strong></p><p><em>option</em> Constant of the option</p><p><em>value</em> Pointer to memory where the result is stored</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>
<h3>\fBConn\fP& OpenDBX::Conn::operator= (const \fBConn\fP &ref)</h3>
<p>Assigns a connection instance to another one. Assigns the internal state of an object <em>ref</em> of the same type to this object. Both objects share the same database connection and the reference counter afterwards. The reference counter is incremented each time an object is copied and will be decremented if it is destroyed.</p><p><strong>Parameters:</strong></p><p><em>ref</em> Connection instance</p><p><strong>Returns:</strong></p><p>Connection reference of this instance</p>
<h3>void OpenDBX::Conn::setOption (odbxoptoption, void *value)std::exception</h3>
<p>Sets a certain option provided by the database driver module. Changes the value of the specified option in the backend module or the native database library. Before trying to set an option, it should be tested with <strong>getOption()</strong> first to ensure that it is supported by the backend. Almost all options need to be set before connecting to the database server using <strong>bind()</strong> to take any effect.</p><p>There are several option values defined as named constants in the opendbx/api.h header file. The possible options are:</p><ul>
<li><p>ODBX_OPT_TLS</p><p> Use encryption to transmit all data securely over the network via SSL or TLS. This option can be set to ODBX_TLS_NEVER (the default value) to prevent encrpytion, ODBX_TLS_ALWAYS to enforce encryption and to fail if it can't be used between the client library and the server or ODBX_TLS_TRY to use encryption if possible with the option to fall back to a connection which isn't encrypted.</p></li><li><p>ODBX_OPT_MULTI_STATEMENTS</p><p> Enables the database server to accept multiple statements in one string to the database if the value of value is set to ODBX_ENABLE. Although, it might be possible to disable it by setting it to ODBX_DISABLE.</p></li><li><p>ODBX_OPT_PAGED_RESULTS</p><p> All database servers and client libraries are able to transfer the records row by row. Some of them can also transfer multiple rows or even all at once to minimize server load, network traffic and latency. The downside of this is an increased memory consumption. If paged results are supported by the backend, passing positive values will fetch the specified number of records at once from the database server. The value of zero ('0') is special in this case because it asks the backend module to retrieve all records at once.</p></li><li><p>ODBX_OPT_COMPRESS</p><p> Enable compressed network traffic between database client and server. This can maximize the throughput if the network is the bottleneck. Pass an integer variable with ODBX_ENABLE to enable compression or with ODBX_DISABLE to disable it for this connection.</p></li><li><p>ODBX_OPT_MODE</p><p> Some database servers support different modes of operation, e.g. modes for compliance to other SQL implementations or completely different query languages. The value for this option must point to a zero terminated string.</p></li>
</ul><p>If not stated otherwise, the type of the variable passed to the second parameter named <em>value</em> must be an integer pointer. Its values must be in the range specified by the option being changed.</p><p><strong>Parameters:</strong></p><p><em>option</em> Constant of the option</p><p><em>value</em> Pointer to memory which contains the new value</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>
<h3>void OpenDBX::Conn::unbind ()std::exception</h3>
<p>Releases the connection to the database and resets the authentication status.</p><p><strong>Exceptions:</strong></p><p><em>std::invalid_argument</em> If the object was only initialized by the default constructor</p><p><em></em><strong>OpenDBX::Exception</strong><em></em><strong> If the underlying database library returns an error</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for opendbx from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="OpenDBX.3.html"><span aria-hidden="true">&larr;</span> OpenDBX.3: Opendbx c++ api.</a></li>
   <li class="next"><a href="OpenDBX_Exception.3.html">OpenDBX_Exception.3: Exceptions thrown by the opendbx classes. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

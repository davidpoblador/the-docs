<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>snmpa: Interface functions to the snmp toolkit agent</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Interface functions to the snmp toolkit agent">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="snmpa (3erl) manual">
  <meta name="twitter:description" content="Interface functions to the snmp toolkit agent">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-snmpa-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/snmpa.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="snmpa (3erl) manual" />
  <meta property="og:description" content="Interface functions to the snmp toolkit agent" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-snmpa-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">snmpa<small> (3erl)</small></h1>
        <p class="lead">Interface functions to the snmp toolkit agent</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/snmpa.3erl.html">
      <span itemprop="name">snmpa: Interface functions to the snmp toolkit agent</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/snmpa.3erl.html">
      <span itemprop="name">snmpa: Interface functions to the snmp toolkit agent</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The module <em>snmpa</em> contains interface functions to the SNMP agent.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
oid() = [byte()]
atl_type() = read | write | read_write
notification_delivery_info() = #snmpa_notification_delivery_info{}

</pre>
<p>The <em>oid()</em> type is used to represent an ASN.1 OBJECT IDENTIFIER.</p><p>The record <em>snmpa_notification_delivery_info</em> contains the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>tag = term()</em>: A user defined identity representing this notification send operation.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>mod = module()</em>: A module implementing the <strong>snmpa_notification_delivery_info_receiver</strong> behaviour. The info functions of this module will be called at various stages of delivery.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>extra = term()</em>: This is any extra info the user wants to have supplied when the functions in the callback module is called.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> add_agent_caps(SysORID, SysORDescr) -&gt; SysORIndex</p><p>Types:</p><p>SysORID = oid()</p><p>SysORDescr = string()</p><p>SysORIndex = integer()</p><p>This function can be used to add an AGENT-CAPABILITY statement to the sysORTable in the agent. The table is defined in the SNMPv2-MIB.</p><p><strong></strong> del_agent_caps(SysORIndex) -&gt; void()</p><p>Types:</p><p>SysORIndex = integer()</p><p>This function can be used to delete an AGENT-CAPABILITY statement to the sysORTable in the agent. This table is defined in the SNMPv2-MIB.</p><p><strong></strong> get_agent_caps() -&gt; [[SysORIndex, SysORID, SysORDescr, SysORUpTime]]</p><p>Types:</p><p>SysORIndex = integer()</p><p>SysORId = oid()</p><p>SysORDescr = string()</p><p>SysORUpTime = integer()</p><p>Returns all AGENT-CAPABILITY statements in the sysORTable in the agent. This table is defined in the SNMPv2-MIB.</p><p><strong></strong> get(Agent, Vars) -&gt; Values | {error, Reason}</p><p><strong></strong> get(Agent, Vars, Context) -&gt; Values | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Vars = [oid()]</p><p>Context = string()</p><p>Values = [term()]</p><p>Reason = {atom(), oid()}</p><p>Performs a GET operation on the agent. All loaded MIB objects are visible in this operation. The agent calls the corresponding instrumentation functions just as if it was a GET request coming from a manager.</p><p>Note that the request specific parameters (such as <strong>current_request_id</strong>) are not accessible for the instrumentation functions if this function is used.</p><p><strong></strong> get_next(Agent, Vars) -&gt; Values | {error, Reason}</p><p><strong></strong> get_next(Agent, Vars, Context) -&gt; Values | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Vars = [oid()]</p><p>Context = string()</p><p>Values = [{oid(), term()}]</p><p>Reason = {atom(), oid()}</p><p>Performs a GET-NEXT operation on the agent. All loaded MIB objects are visible in this operation. The agent calls the corresponding instrumentation functions just as if it was a GET request coming from a manager.</p><p>Note that the request specific parameters (such as <em>snmpa:current_request_id/0</em> are not accessible for the instrumentation functions if this function is used.</p><p><strong></strong> backup(BackupDir) -&gt; ok | {error, Reason}</p><p><strong></strong> backup(Agent, BackupDir) -&gt; ok | {error, Reason}</p><p>Types:</p><p>BackupDir = string()</p><p>Agent = pid() | atom()</p><p>Reason = backup_in_progress | term()</p><p>Backup persistent/permanent data handled by the agent (such as local-db, mib-data and vacm).</p><p>Data stored by mnesia is not handled.</p><p>BackupDir cannot be identical to DbDir.</p><p>Simultaneous backup calls are <em>not</em> allowed. That is, two different processes cannot simultaneously successfully call this function. One of them will be first, and succeed. The second will fail with the error reason <em>backup_in_progress</em>.</p><p><strong></strong> info() -&gt; [{Key, Value}]</p><p><strong></strong> info(Agent) -&gt; [{Key, Value}]</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Returns a list (a dictionary) containing information about the agent. Information includes loaded MIBs, registered sub-agents, some information about the memory allocation.</p><p>As of version 4.4 the format of the info has been changed. To convert the info to the old format, call the <strong>old_info_format</strong> function.</p><p><strong></strong> old_info_format(NewInfo) -&gt; OldInfo</p><p>Types:</p><p>OldInfo = NewInfo = [{Key, Value}]</p><p>As of version 4.4 the format of the info has been changed. This function is used to convert to the old (pre-4.4) info format.</p><p><strong></strong> load_mib(Mib) -&gt; ok | {error, Reason}</p><p><strong></strong> load_mib(Agent, Mib) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>MibName = string()</p><p>Reason = already_loaded | term()</p><p>Load a single <em>Mib</em> into an agent. The <em>MibName</em> is the name of the Mib, including the path to where the compiled mib is found. For example:</p>
<pre>
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpa:load_mib(snmp_master_agent, Dir ++ "MY-MIB").

</pre>
<p><strong></strong> load_mibs(Mibs) -&gt; ok | {error, Reason}</p><p><strong></strong> load_mibs(Mibs, Force) -&gt; ok | {error, Reason}</p><p><strong></strong> load_mibs(Agent, Mibs) -&gt; ok | {error, Reason}</p><p><strong></strong> load_mibs(Agent, Mibs, Force) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Mibs = [MibName]</p><p>Force = boolean()</p><p>MibName = string()</p><p>Reason = {'load aborted at', MibName, InternalReason}</p><p>InternalReason = already_loaded | term()</p><p>Load <em>Mibs</em> into an agent. If the agent cannot load all MIBs (the default value of the <em>Force</em> argument is <em>false</em>), it will indicate where loading was aborted. The <em>MibName</em> is the name of the Mib, including the path to where the compiled mib is found. For example,</p>
<pre>
          Dir = code:priv_dir(my_app) ++ "/mibs/",
          snmpa:load_mibs(snmp_master_agent, [Dir ++ "MY-MIB"]).

</pre>
<p>If <em>Force = true</em> then the agent will continue attempting to load each mib even after failing to load a previous mib. Use with care.</p><p><strong></strong> unload_mib(Mib) -&gt; ok | {error, Reason}</p><p><strong></strong> unload_mib(Agent, Mib) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>MibName = string()</p><p>Reason = not_loaded | term()</p><p>Unload a single <em>Mib</em> from an agent.</p><p><strong></strong> unload_mibs(Mibs) -&gt; ok | {error, Reason}</p><p><strong></strong> unload_mibs(Mibs, Force) -&gt; ok | {error, Reason}</p><p><strong></strong> unload_mibs(Agent, Mibs) -&gt; ok | {error, Reason}</p><p><strong></strong> unload_mibs(Agent, Mibs, Force) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Mibs = [MibName]</p><p>Force = boolean()</p><p>MibName = string()</p><p>Reason = {'unload aborted at', MibName, InternalReason}</p><p>InternalReason = not_loaded | term()</p><p>Unload <em>Mibs</em> from an agent. If it cannot unload all MIBs (the default value of the <em>Force</em> argument is <em>false</em>), it will indicate where unloading was aborted.</p><p>If <em>Force = true</em> then the agent will continue attempting to unload each mib even after failing to unload a previous mib. Use with care.</p><p><strong></strong> which_mibs() -&gt; Mibs</p><p><strong></strong> which_mibs(Agent) -&gt; Mibs</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Mibs = [{MibName, MibFile}]</p><p>MibName = atom()</p><p>MibFile = string()</p><p>Retrieve the list of all the mibs loaded into this agent. Default is the master agent.</p><p><strong></strong> whereis_mib(MibName) -&gt; {ok, MibFile} | {error, Reason}</p><p><strong></strong> whereis_mib(Agent, MibName) -&gt; {ok, MibFile} | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>MibName = atom()</p><p>MibFile = string()</p><p>Reason = term()</p><p>Get the full path to the (compiled) mib-file.</p><p><strong></strong> current_request_id() -&gt; {value, RequestId} | false</p><p><strong></strong> current_context() -&gt; {value, Context} | false</p><p><strong></strong> current_community() -&gt; {value, Community} | false</p><p><strong></strong> current_address() -&gt; {value, Address} | false</p><p>Types:</p><p>RequestId = integer()</p><p>Context = string()</p><p>Community = string()</p><p>Address = term()</p><p>Get the request-id, context, community and address of the request currently being processed by the agent.</p><p>Note that these functions is intended to be called by the instrumentation functions and <em>only</em> if they are executed in the context of the agent process (e.g. it does not work if called from a spawned process).</p><p><strong></strong> enum_to_int(Name, Enum) -&gt; {value, Int} | false</p><p><strong></strong> enum_to_int(Db, Name, Enum) -&gt; {value, Int} | false</p><p>Types:</p><p>Db = term()</p><p>Name = atom()</p><p>Enum = atom()</p><p>Int = int()</p><p>Converts the symbolic value <em>Enum</em> to the corresponding integer of the enumerated object or type <em>Name</em> in a MIB. The MIB must be loaded.</p><p><em>false</em> is returned if the object or type is not defined in any loaded MIB, or if it does not define the symbolic value as enumerated.</p><p><em>Db</em> is a reference to the symbolic store database (retrieved by a call to <em>get_symbolic_store_db/0</em>).</p><p><strong></strong> int_to_enum(Name, Int) -&gt; {value, Enum} | false</p><p><strong></strong> int_to_enum(Db, Name, Int) -&gt; {value, Enum} | false</p><p>Types:</p><p>Db = term()</p><p>Name = atom()</p><p>Int = int()</p><p>Enum = atom()</p><p>Converts the integer <em>Int</em> to the corresponding symbolic value of the enumerated object or type <em>Name</em> in a MIB. The MIB must be loaded.</p><p><em>false</em> is returned if the object or type is not defined in any loaded MIB, or if it does not define the symbolic value as enumerated.</p><p><em>Db</em> is a reference to the symbolic store database (retrieved by a call to <em>get_symbolic_store_db/0</em>).</p><p><strong></strong> name_to_oid(Name) -&gt; {value, oid()} | false</p><p><strong></strong> name_to_oid(Db, Name) -&gt; {value, oid()} | false</p><p>Types:</p><p>Db = term()</p><p>Name = atom()</p><p>Looks up the OBJECT IDENTIFIER of a MIB object, given the symbolic name. Note, the OBJECT IDENTIFIER is given for the object, not for an instance.</p><p><em>false</em> is returned if the object is not defined in any loaded MIB.</p><p><em>Db</em> is a reference to the symbolic store database (retrieved by a call to <em>get_symbolic_store_db/0</em>).</p><p><strong></strong> oid_to_name(OID) -&gt; {value, Name} | false</p><p><strong></strong> oid_to_name(Db, OID) -&gt; {value, Name} | false</p><p>Types:</p><p>Db = term()</p><p>OID = oid()</p><p>Name = atom()</p><p>Looks up the symbolic name of a MIB object, given OBJECT IDENTIFIER.</p><p><em>false</em> is returned if the object is not defined in any loaded MIB.</p><p><em>Db</em> is a reference to the symbolic store database (retrieved by a call to <em>get_symbolic_store_db/0</em>).</p><p><strong></strong> which_aliasnames() -&gt; Result</p><p>Types:</p><p>Result = [atom()]</p><p>Retrieve all alias-names known to the agent.</p><p><strong></strong> which_tables() -&gt; Result</p><p>Types:</p><p>Result = [atom()]</p><p>Retrieve all tables known to the agent.</p><p><strong></strong> which_variables() -&gt; Result</p><p>Types:</p><p>Result = [atom()]</p><p>Retrieve all variables known to the agent.</p><p><strong></strong> which_notifications() -&gt; Result</p><p>Types:</p><p>Result = [{Name, MibName, Info}]</p><p>Name = atom()</p><p>MibName = atom()</p><p>Info = term()</p><p>Retrieve all notifications (and traps) known to the agent.</p><p><strong></strong> log_to_txt(LogDir)</p><p><strong></strong> log_to_txt(LogDir, Block | Mibs)</p><p><strong></strong> log_to_txt(LogDir, Mibs, Block | OutFile) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_txt(LogDir, Mibs, OutFile, Block | LogName) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start, Stop) -&gt; ok | {error, Reason}</p><p>Types:</p><p>LogDir = string()</p><p>Mibs = [MibName]</p><p>MibName = string()</p><p>Block = boolean()</p><p>OutFile = string()</p><p>LogName = string()</p><p>LogFile = string()</p><p>Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()}</p><p>Reason = disk_log_open_error() | file_open_error() | term()</p><p>disk_log_open_error() = {LogName, term()}</p><p>file_open_error() = {OutFile, term()}</p><p>Converts an Audit Trail Log to a readable text file. <em>OutFile</em> defaults to "./snmpa_log.txt". <em>LogName</em> defaults to "snmpa_log". <em>LogFile</em> defaults to "snmpa.log".</p><p>The <em>Block</em> option indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to <em>true</em>.</p><p>See <strong>snmp:log_to_txt</strong> for more info.</p><p><strong></strong> log_to_io(LogDir) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_io(LogDir, Block | Mibs) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_io(LogDir, Mibs, Block | LogName) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_io(LogDir, Mibs, LogName, Block | LogFile) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop) -&gt; ok | {error, Reason}</p><p><strong></strong> log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop) -&gt; ok | {error, Reason}</p><p>Types:</p><p>LogDir = string()</p><p>Mibs = [MibName]</p><p>MibName = string()</p><p>Block = boolean()</p><p>LogName = string()</p><p>LogFile = string()</p><p>Start = Stop = null | calendar:datetime() | {local_time, calendar:datetime()} | {universal_time, calendar:datetime()}</p><p>Reason = disk_log_open_error() | file_open_error() | term()</p><p>disk_log_open_error() = {LogName, term()}</p><p>file_open_error() = {OutFile, term()}</p><p>Converts an Audit Trail Log to a readable format and prints it on stdio. <em>LogName</em> defaults to "snmpa_log". <em>LogFile</em> defaults to "snmpa.log".</p><p>The <em>Block</em> option indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to <em>true</em>. See <strong>snmp:log_to_io</strong> for more info.</p><p><strong></strong> change_log_size(NewSize) -&gt; ok | {error, Reason}</p><p>Types:</p><p>NewSize = {MaxBytes, MaxFiles}</p><p>MaxBytes = integer()</p><p>MaxFiles = integer()</p><p>Reason = term()</p><p>Changes the log size of the Audit Trail Log. The application must be configured to use the audit trail log function. Please refer to disk_log(3erl) in Kernel Reference Manual for a description of how to change the log size.</p><p>The change is permanent, as long as the log is not deleted. That means, the log size is remembered across reboots.</p><p><strong></strong> set_log_type(NewType) -&gt; {ok, OldType} | {error, Reason}</p><p><strong></strong> set_log_type(Agent, NewType) -&gt; {ok, OldType} | {error, Reason}</p><p>Types:</p><p>NewType = OldType = atl_type()</p><p>Agent = pid() | atom()</p><p>Reason = term()</p><p>Changes the run-time Audit Trail log type.</p><p>Note that this has no effect on the application configuration as defined by configuration files, so a node restart will revert the config to whatever is in those files.</p><p>This function is primarily useful in testing/debugging scenarios.</p><p><strong></strong> mib_of(Oid) -&gt; {ok, MibName} | {error, Reason}</p><p><strong></strong> mib_of(Agent, Oid) -&gt; {ok, MibName} | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Oid = oid()</p><p>MibName = atom()</p><p>Reason = term()</p><p>Finds the mib corresponding to the <em>Oid</em>. If it is a variable, the Oid must be &lt;Oid for var&gt;.0 and if it is a table, Oid must be &lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;</p><p><strong></strong> me_of(Oid) -&gt; {ok, Me} | {error, Reason}</p><p><strong></strong> me_of(Agent, Oid) -&gt; {ok, Me} | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Oid = oid()</p><p>Me = #me{}</p><p>Reason = term()</p><p>Finds the mib entry corresponding to the <em>Oid</em>. If it is a variable, the Oid must be &lt;Oid for var&gt;.0 and if it is a table, Oid must be &lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;</p><p><strong></strong> invalidate_mibs_cache() -&gt; void()</p><p><strong></strong> invalidate_mibs_cache(Agent) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Invalidate the mib server cache.</p><p>The entire contents of the cache will be deleted.</p><p><strong></strong> enable_mibs_cache() -&gt; void()</p><p><strong></strong> enable_mibs_cache(Agent) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Enable the mib server cache.</p><p><strong></strong> disable_mibs_cache() -&gt; void()</p><p><strong></strong> disable_mibs_cache(Agent) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Disable the mib server cache.</p><p><strong></strong> which_mibs_cache_size() -&gt; void()</p><p><strong></strong> which_mibs_cache_size(Agent) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Retreive the size of the mib server cache.</p><p><strong></strong> gc_mibs_cache() -&gt; {ok, NumElementsGCed} | {error, Reason}</p><p><strong></strong> gc_mibs_cache(Agent) -&gt; {ok, NumElementsGCed} | {error, Reason}</p><p><strong></strong> gc_mibs_cache(Age) -&gt; {ok, NumElementsGCed} | {error, Reason}</p><p><strong></strong> gc_mibs_cache(Agent, Age) -&gt; {ok, NumElementsGCed} | {error, Reason}</p><p><strong></strong> gc_mibs_cache(Age, GcLimit) -&gt; {ok, NumElementsGCed} | {error, Reason}</p><p><strong></strong> gc_mibs_cache(Agent, Age, GcLimit) -&gt; {ok, NumElementsGCed} | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Age = integer() &gt; 0</p><p>GcLimit = integer() &gt; 0 | infinity</p><p>NumElementsGCed = integer() &gt;= 0</p><p>Reason = term()</p><p>Perform mib server cache gc.</p><p>Manually performs a mib server cache gc. This can be done regardless of the value of the <em>autogc</em> option. The <em>NumElementsGCed</em> value indicates how many elements where actually removed from the cache.</p><p><strong></strong> enable_mibs_cache_autogc() -&gt; void()</p><p><strong></strong> enable_mibs_cache_autogc(Agent) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Enable automatic gc of the mib server cache.</p><p><strong></strong> disable_mibs_cache_autogc() -&gt; void()</p><p><strong></strong> disable_mibs_cache_autogc(Agent) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Disable automatic gc of the mib server cache.</p><p><strong></strong> update_mibs_cache_age(NewAge) -&gt; ok | {error, Reason}</p><p><strong></strong> update_mibs_cache_age(Agent, NewAge) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>NewAge = integer() &gt; 0</p><p>Reason = term()</p><p>Change the mib server cache <em>age</em> property.</p><p><strong></strong> update_mibs_cache_gclimit(NewGcLimit) -&gt; ok | {error, Reason}</p><p><strong></strong> update_mibs_cache_gclimit(Agent, NewGCLimit) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>NewGcLimit = integer() &gt; 0 | infinity</p><p>Reason = term()</p><p>Change the mib server cache <em>gclimit</em> property.</p><p><strong></strong> register_notification_filter(Id, Mod, Data) -&gt; ok | {error, Reason}</p><p><strong></strong> register_notification_filter(Agent, Id, Mod, Data) -&gt; ok | {error, Reason}</p><p><strong></strong> register_notification_filter(Id, Mod, Data, Where) -&gt; ok | {error, Reason}</p><p><strong></strong> register_notification_filter(Agent, Id, Mod, Data, Where) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Id = filter_id()</p><p>filter_id() = term()</p><p>Mod = atom()</p><p>Data = term()</p><p>Where = filter_position()</p><p>Reason = term()</p><p>filter_position() = first | last | {insert_before, filter_id()} | {insert_after, filter_id()}</p><p>Registers a notification filter.</p><p><em>Mod</em> is a module implementing the <em>snmpa_notification_filter</em> behaviour.</p><p><em>Data</em> will be passed on to the filter when calling the functions of the behaviour.</p><p><strong></strong> unregister_notification_filter(Id) -&gt; ok | {error, Reason}</p><p><strong></strong> unregister_notification_filter(Agent, Id) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Id = filter_id()</p><p>filter_id() = term()</p><p>Unregister a notification filter.</p><p><strong></strong> which_notification_filter() -&gt; Filters</p><p><strong></strong> which_notification_filter(Agent) -&gt; Filters</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Filters = [filter_id()]</p><p>filter_id() = term()</p><p>List all notification filters in an agent.</p><p><strong></strong> set_request_limit(NewLimit) -&gt; {ok, OldLimit} | {error, Reason}</p><p><strong></strong> set_request_limit(Agent, NewLimit) -&gt; {ok, OldLimit} | {error, Reason}</p><p>Types:</p><p>NewLimit = OldLimit = infinity | integer() &gt;= 0</p><p>Agent = pid() | atom()</p><p>Reason = term()</p><p>Changes the request limit.</p><p>Note that this has no effect on the application configuration as defined by configuration files, so a node restart will revert the config to whatever is in those files.</p><p>This function is primarily useful in load regulation scenarios.</p><p><strong></strong> register_subagent(Agent, SubTreeOid, Subagent) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>SubTreeOid = oid()</p><p>SubAgent = pid()</p><p>Registers a sub-agent under a sub-tree of another agent.</p><p>It is easy to make mistakes when registering sub-agents and this activity should be done carefully. For example, a strange behaviour would result from the following configuration:</p>
<pre>
snmp_agent:register_subagent(MAPid,[1,2,3,4],SA1),
snmp_agent:register_subagent(SA1,[1,2,3], SA2).

</pre>
<p><em>SA2</em> will not get requests starting with object identifier <em>[1,2,3]</em> since <em>SA1</em> does not.</p><p><strong></strong> unregister_subagent(Agent, SubagentOidOrPid) -&gt; ok | {ok, SubAgentPid} | {error, Reason}</p><p>Types:</p><p>Agent = pid() | atom()</p><p>SubTreeOidorPid = oid() | pid()</p><p>Unregister a sub-agent. If the second argument is a pid, then that sub-agent will be unregistered from all trees in <em>Agent</em>.</p><p><strong></strong> send_notification2(Agent, Notification, SendOpts) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Notification = atom()</p><p>SendOpts = [send_option()]</p><p>send_option() = {receiver, receiver()} | {name, notify_name()} | {context, context_name()} | {varbinds, varbinds()} | {local_engine_id, string()} | {extra, extra_info()}</p><p>receiver() = no_receiver | {tag(), tag_receiver()} | notification_delivery_info()</p><p>tag() = term(()</p><p>tag_receiver() = pid() | registered_name() | {Mod, Func, Args}</p><p>registered_name() = atom()</p><p>Mod = atom()</p><p>Func = atom()</p><p>Args = list()</p><p>notify_name() = string()</p><p>context_name() = string()</p><p>varbinds() = [varbind()]</p><p>varbind() = {variable(), value()} | {column(), row_index(), value()} | {oid(), value()}</p><p>variable() = atom()</p><p>value() = term()</p><p>column() = atom()</p><p>row_index() = [int()]</p><p>extra_info() = term()</p><p>Send the notification <em>Notification</em> to the management targets defined for notify-name (<em>name</em>) in the <em>snmpNotifyTable</em> in SNMP-NOTIFICATION-MIB from the specified <em>context</em>.</p><p>If no <em>name</em> is specified (or if it is <em>""</em>), the notification is sent to all management targets.</p><p>If no <em>context</em> is specified, the default context, <em>""</em>, is used.</p><p>The send option <em>receiver</em> specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the management targets. The <em>receiver</em> can have three values:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>no_receiver</em> - No information is delivered.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>notification_delivery_info()</em> - The information is delivered via a function call according to this data. See the <strong>DATA TYPES</strong> section above for details.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{tag(), tag_receiver()}</em> - The information is delivered either via messages or via a function call according to the value of <em>tag_receiver()</em>.</p><p>Delivery is done differently depending on the value of <em>tag_receiver()</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>pid() | registered_name()</em> - The info will be delivered in the following messages:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{snmp_targets, tag(), Addresses}</em></p><p>This informs the user which target addresses the notification was sent to.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{snmp_notification, tag(), {got_response, Address}}</em></p><p>This informs the user that this target address acknowledged the notification.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{snmp_notification, tag(), {no_response, Address}}</em></p><p>This informs the user that this target address did not acknowledge the notification.</p>
  </dd>

</dl>
<p>The notification is sent as an Inform-Request to each target address in <em>Addresses</em> and if there are no targets for which an Inform-Request is sent, <em>Addresses</em> is the empty list <em>[]</em>.</p><p>The <em>tag_receiver()</em> will first be sent the <em>snmp_targets</em> message, and then for each address in <em>Addresses</em> list, one of the two <em>snmp_notification</em> messages.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{Mod, Func, Args}</em> - The info will be delivered via the function call:</p><p><em>Mod:Func([Msg | Args])</em></p><p>where <em>Msg</em> has the same content and purpose as the messages descrived above.</p>
  </dd>

</dl>

  </dd>

</dl>
<p><strong></strong> Note:</p><p>The <em>extra</em> info is not normally interpreted by the agent, instead it is passed through to the <strong>net-if</strong> process. It is up to the implementor of that process to make use of this data.</p><p>The version of net-if provided by this application makes no use of this data, with one exception: Any tuple containing the atom <em>snmpa_default_notification_extra_info</em> may be used by the agent and is therefor <em>reserved</em>.</p><p>See the net-if incomming messages for sending a <strong> trap</strong> and <strong> notification</strong> for more info.</p><p><strong></strong> send_notification(Agent, Notification, Receiver)</p><p><strong></strong> send_notification(Agent, Notification, Receiver, Varbinds)</p><p><strong></strong> send_notification(Agent, Notification, Receiver, NotifyName, Varbinds)</p><p><strong></strong> send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds) -&gt; void()</p><p><strong></strong> send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds, LocalEngineID) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Notification = atom()</p><p>Receiver = no_receiver | {Tag, Recv} | notification_delivery_info()</p><p>Tag = term()</p><p>Recv = receiver()</p><p>receiver() = pid() | atom() | {Mod, Func, Args}</p><p>Mod = atom()</p><p>Func = atom()</p><p>Args = list()</p><p>NotifyName = string()</p><p>ContextName = string()</p><p>Varbinds = varbinds()</p><p>varbinds() = [varbind()]</p><p>varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</p><p>Variable = atom()</p><p>Column = atom()</p><p>OID = oid()</p><p>Value = term()</p><p>RowIndex = [int()]</p><p>LocalEngineID = string()</p><p>Sends the notification <em>Notification</em> to the management targets defined for <em>NotifyName</em> in the <em>snmpNotifyTable</em> in SNMP-NOTIFICATION-MIB from the specified context.</p><p>If no <em>NotifyName</em> is specified (or if it is <em>""</em>), the notification is sent to all management targets (<em>Addresses</em> below).</p><p>If no <em>ContextName</em> is specified, the default <em>""</em> context is used.</p><p>The parameter <em>Receiver</em> specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the managers. <em>Receiver</em> can have three values:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>no_receiver</em> - No information is delivered.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>notification_delivery_info()</em> - The information is delivered via a function call according to this data. See the <strong>DATA TYPES</strong> section above for details.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{Tag, Recv}</em> - The information is delivered either via messages or via a function call according to the value of <em>Recv</em>.</p>
  </dd>

</dl>
<p>If <em>Receiver</em> has the value <em>{Tag, Recv}</em>, the delivery is done according to <em>Recv</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>pid() | atom()</em> - The info will be delivered in the following messages:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{snmp_targets, Tag, Addresses}</em></p><p>This inform the user which target addresses the notification was sent to.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{snmp_notification, Tag, {got_response, Address}}</em></p><p>This informs the user that this target address acknowledged the notification.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{snmp_notification, Tag, {no_response, Address}}</em></p><p>This informs the user that this target address did not acknowledge notification.</p>
  </dd>

</dl>
<p>The notification is sent as an Inform-Request to each target address in <em>Addresses</em> and if there are no targets for which an Inform-Request is sent, <em>Addresses</em> is the empty list <em>[]</em>.</p><p>The <em>receiver</em> will first be sent the <em>snmp_targets</em> message, and then for each address in <em>Addresses</em> list, one of the two <em>snmp_notification</em> messages.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{Mod, Func, Args}</em> - The info will be delivered via the function call:</p><p><em>Mod:Func([Msg | Args])</em></p><p>where <em>Msg</em> has the same content and purpose as the messages descrived above.</p>
  </dd>

</dl>
<p><em>Address</em> is a management target address and <em>Addresses</em> is a list of management target addresses. They are defined as followes:</p>
<pre>
        Addresses  = [address()]
        Address    = address()
        address()  = v1_address() | v3_address()
        v1_address() = {TDomain, TAddress}
        v3_address() = {{TDomain, TAddress}, V3MsgData}
        TDomain    = tdoamin()
        TAddress   = taddress()
        tdomain()  = The oid of snmpUDPDomain
                     This is the only supported transport domain.
        taddress() = [A1, A2, A3, A4, P1, P3]
                     The 4 first bytes makes up the IP-address and the last 2,
                     the UDP-port number.
        V3MsgData  = v3_msg_data()
        v3_msg_data() = term()

</pre>
<p>If <em>Receiver</em> is a <em>notification_delivery_info()</em> record, then the information about the notification delivery will be delivered to the <em>receiver</em> via the callback functions defined by the <strong>snmpa_notification_delivery_info_receiver</strong> behaviour according to the content of the <em>notification_delivery_info()</em> record.</p><p>The optional argument <em>Varbinds</em> defines values for the objects in the notification. If no value is given for an object, the <em>Agent</em> performs a get-operation to retrieve the value.</p><p><em>Varbinds</em> is a list of <em>Varbind</em>, where each <em>Varbind</em> is one of:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{Variable, Value}</em>, where <em>Variable</em> is the symbolic name of a scalar variable referred to in the notification specification.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{Column, RowIndex, Value}</em>, where <em>Column</em> is the symbolic name of a column variable. <em>RowIndex</em> is a list of indices for the specified element. If this is the case, the OBJECT IDENTIFIER sent in the notification is the <em>RowIndex</em> appended to the OBJECT IDENTIFIER for the table column. This is the OBJECT IDENTIFIER which specifies the element.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{OID, Value}</em>, where <em>OID</em> is the OBJECT IDENTIFIER for an instance of an object, scalar variable, or column variable.</p>
  </dd>

</dl>
<p>For example, to specify that <em>sysLocation</em> should have the value <em>"upstairs"</em> in the notification, we could use one of:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{sysLocation, "upstairs"}</em> or</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{[1,3,6,1,2,1,1,6,0], "upstairs"}</em> or</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{?sysLocation_instance, "upstairs"}</em> (provided that the generated <em>.hrl</em> file is included)</p>
  </dd>

</dl>
<p>If a variable in the notification is a table element, the <em>RowIndex</em> for the element must be given in the <em>Varbinds</em> list. In this case, the OBJECT IDENTIFIER sent in the notification is the OBJECT IDENTIFIER that identifies this element. This OBJECT IDENTIFIER could be used in a get operation later.</p><p>This function is asynchronous, and does not return any information. If an error occurs, <em>user_err/2</em> of the error report module is called and the notification is discarded.</p><p><strong></strong> Note:</p><p>Note that the use of the LocalEngineID argument is only intended for special cases, if the agent is to "emulate" multiple EngineIDs! By default, the agent uses the value of <em>SnmpEngineID</em> (see SNMP-FRAMEWORK-MIB).</p><p><em>ExtraInfo</em> is not normally used in any way by the agent. It is intended to be passed along to the net-if process, which is a component that a user can implement themself. The users own net-if may then make use of ExtraInfo. The net-if provided with this application does not process ExtraInfo.</p><p>There is one exception. <em>Any</em> tuple containing the atom <em>snmpa_default_notification_extra_info</em> will, in this context, be considered belonging to this application, and may be processed by the agent.</p><p><strong></strong> discovery(TargetName, Notification) -&gt; {ok, ManagerEngineID} | {error, Reason}</p><p><strong></strong> discovery(TargetName, Notification, Varbinds) -&gt; {ok, ManagerEngineID} | {error, Reason}</p><p><strong></strong> discovery(TargetName, Notification, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</p><p><strong></strong> discovery(TargetName, Notification, ContextName, Varbinds) -&gt; {ok, ManagerEngineID} | {error, Reason}</p><p><strong></strong> discovery(TargetName, Notification, Varbinds, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</p><p><strong></strong> discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler) -&gt; {ok, ManagerEngineID} | {error, Reason}</p><p><strong></strong> discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler, ExtraInfo) -&gt; {ok, ManagerEngineID} | {error, Reason}</p><p>Types:</p><p>TargetName = string()</p><p>Notification = atom()</p><p>ContextName = string() (defaults to "")</p><p>Varbinds = varbinds()</p><p>varbinds() = [varbind()]</p><p>DiscoHandler = snmpa_discovery_handler()</p><p>ExtraInfo = term()</p><p>snmpa_discovery_handler() = Module implementing the snmpa_discovery_handler behaviour</p><p>ManagerEngineID = string()</p><p>varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</p><p>Variable = atom()</p><p>Column = atom()</p><p>OID = oid()</p><p>Value = term()</p><p>RowIndex = [int()]</p><p>Reason = term()</p><p>Initiate the discovery process with the manager identified by <em>TargetName</em> using the notification <em>Notification</em>.</p><p>This function is synchronous, which means that it will return when the discovery process has been completed or failed.</p><p>The <em>DiscoHandler</em> module is used during the discovery process. See <strong>discovery handler</strong> for more info.</p><p>The <em>ExtraInfo</em> argument is passed on to the callback functions of the <em>DiscoHandler</em>.</p><p><strong></strong> Note:</p><p>If we are not at security-level <em>noAuthNoPriv</em>, this could be complicated, since the agent will then continue with stage 2, before which the usm-related updates must be done.</p><p><strong></strong> Note:</p><p>The default discovery handler will require additional actions by the caller and the discovery will not work if the security-level is higher then <em>noAuthNoPriv</em>.</p><p><strong></strong> convert_config(OldConfig) -&gt; AgentConfig</p><p>Types:</p><p>OldConfig = list()</p><p>AgentConfig = list()</p><p>This off-line utility function can be used to convert the old snmp application config (pre snmp-4.0) to the new snmp agent config (as of snmp-4.0).</p><p>For information about the old config (<em>OldConfig</em>) see the OTP R9C documentation.</p><p>For information about the current agent config (<em>AgentConfig</em>), see either the <strong>SNMP application</strong> part of the reference manual or the <strong>Configuring the application</strong> chapter of the SNMP user's guide.</p><p><strong></strong> restart_worker() -&gt; void()</p><p><strong></strong> restart_worker(Agent) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Restart the worker process of a multi-threaded agent.</p><p>This is a utility function, that can be useful when e.g. debugging instrumentation functions.</p><p><strong></strong> restart_set_worker() -&gt; void()</p><p><strong></strong> restart_set_worker(Agent) -&gt; void()</p><p>Types:</p><p>Agent = pid() | atom()</p><p>Restart the set worker process of a multi-threaded agent.</p><p>This is a utility function, that can be useful when e.g. debugging instrumentation functions.</p><p><strong></strong> print_mib_info() -&gt; void()</p><p>Prints the content of all the (snmp) tables and variables for all mibs handled by the snmp agent.</p><p><strong></strong> print_mib_tables() -&gt; void()</p><p>Prints the content of all the (snmp) tables for all mibs handled by the snmp agent.</p><p><strong></strong> print_mib_variables() -&gt; void()</p><p>Prints the content of all the (snmp) variables for all mibs handled by the snmp agent.</p><p><strong></strong> verbosity(Ref,Verbosity) -&gt; void()</p><p>Types:</p><p>Ref = pid() | sub_agents | master_agent | net_if | mib_server | symbolic_store | note_store | local_db</p><p>Verbosity = verbosity() | {subagents, verbosity()}</p><p>verbosity() = silence | info | log | debug | trace</p><p>Sets verbosity for the designated process. For the lowest verbosity <em>silence</em>, nothing is printed. The higher the verbosity, the more is printed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO snmpa&hellip;</h2>
        <div class="sectioncontent">
<p>calendar(3erl), <a href="../man1/erlc.1.html"><strong>erlc</strong>(1)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="snmp_view_based_acm_mib.3erl.html"><span aria-hidden="true">&larr;</span> snmp_view_based_acm_mib.3erl: Instrumentation functions for snmp-view-based-acm-mib</a></li>
   <li class="next"><a href="snmpa_conf.3erl.html">snmpa_conf.3erl: Utility functions for handling the agent config files. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoSceneManager: The soscenemanager class provides the main interface between the scene graph and the gui toolkit.  the renderarea class from the gui toolkit you are using uses this class as the interface against the scene graph. event handling and providing 'hooks' to do rendering are the main functions of the class.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soscenemanager class provides the main interface between the scene graph and the gui toolkit.  the renderarea class from the gui toolkit you are using uses this class as the interface against the scene graph. event handling and providing 'hooks' to do rendering are the main functions of the class.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoSceneManager (3) manual">
  <meta name="twitter:description" content="The soscenemanager class provides the main interface between the scene graph and the gui toolkit.  the renderarea class from the gui toolkit you are using uses this class as the interface against the scene graph. event handling and providing 'hooks' to do rendering are the main functions of the class.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoSceneManager-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoSceneManager.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoSceneManager (3) manual" />
  <meta property="og:description" content="The soscenemanager class provides the main interface between the scene graph and the gui toolkit.  the renderarea class from the gui toolkit you are using uses this class as the interface against the scene graph. event handling and providing 'hooks' to do rendering are the main functions of the class." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoSceneManager-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoSceneManager<small> (3)</small></h1>
        <p class="lead">The soscenemanager class provides the main interface between the scene graph and the gui toolkit.  the renderarea class from the gui toolkit you are using uses this class as the interface against the scene graph. event handling and providing 'hooks' to do rendering are the main functions of the class.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoSceneManager.3.html">
      <span itemprop="name">SoSceneManager: The soscenemanager class provides the main interface between the scene graph and the gui toolkit.  the renderarea class from the gui toolkit you are using uses this class as the interface against the scene graph. event handling and providing 'hooks' to do rendering are the main functions of the class.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoSceneManager.3.html">
      <span itemprop="name">SoSceneManager: The soscenemanager class provides the main interface between the scene graph and the gui toolkit.  the renderarea class from the gui toolkit you are using uses this class as the interface against the scene graph. event handling and providing 'hooks' to do rendering are the main functions of the class.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SoSceneManager.h&gt;</p><h3>Public Member Functions</h3>
<p><strong>SoSceneManager</strong> (void)</p><p>virtual <strong>~SoSceneManager</strong> ()</p><p>virtual void <strong>render</strong> (const SbBool clearwindow=TRUE, const SbBool clearzbuffer=TRUE)</p><p>virtual void <strong>render</strong> (<strong>SoGLRenderAction</strong> *action, const SbBool initmatrices=TRUE, const SbBool clearwindow=TRUE, const SbBool clearzbuffer=TRUE)</p><p>void <strong>setCamera</strong> (<strong>SoCamera</strong> *camera)</p><p><strong>SoCamera</strong> * <strong>getCamera</strong> (void) const </p><p>virtual SbBool <strong>processEvent</strong> (const <strong>SoEvent</strong> *const event)</p><p>void <strong>reinitialize</strong> (void)</p><p>void <strong>scheduleRedraw</strong> (void)</p><p>virtual void <strong>setSceneGraph</strong> (<strong>SoNode</strong> *const sceneroot)</p><p>virtual <strong>SoNode</strong> * <strong>getSceneGraph</strong> (void) const </p><p>void <strong>setWindowSize</strong> (const <strong>SbVec2s</strong> &newsize)</p><p>const <strong>SbVec2s</strong> & <strong>getWindowSize</strong> (void) const </p><p>void <strong>setSize</strong> (const <strong>SbVec2s</strong> &newsize)</p><p>const <strong>SbVec2s</strong> & <strong>getSize</strong> (void) const </p><p>void <strong>setOrigin</strong> (const <strong>SbVec2s</strong> &newOrigin)</p><p>const <strong>SbVec2s</strong> & <strong>getOrigin</strong> (void) const </p><p>void <strong>setViewportRegion</strong> (const <strong>SbViewportRegion</strong> &newRegion)</p><p>const <strong>SbViewportRegion</strong> & <strong>getViewportRegion</strong> (void) const </p><p>void <strong>setBackgroundColor</strong> (const <strong>SbColor</strong> &color)</p><p>const <strong>SbColor</strong> & <strong>getBackgroundColor</strong> (void) const </p><p>void <strong>setBackgroundIndex</strong> (const int index)</p><p>int <strong>getBackgroundIndex</strong> (void) const </p><p>void <strong>setRGBMode</strong> (const SbBool onOrOff)</p><p>SbBool <strong>isRGBMode</strong> (void) const </p><p>virtual void <strong>activate</strong> (void)</p><p>virtual void <strong>deactivate</strong> (void)</p><p>void <strong>setRenderCallback</strong> (<strong>SoSceneManagerRenderCB</strong> *f, void *const userData=NULL)</p><p>SbBool <strong>isAutoRedraw</strong> (void) const </p><p>void <strong>setRedrawPriority</strong> (const uint32_t priority)</p><p>uint32_t <strong>getRedrawPriority</strong> (void) const </p><p>void <strong>setAntialiasing</strong> (const SbBool smoothing, const int numPasses)</p><p>void <strong>getAntialiasing</strong> (SbBool &smoothing, int &numPasses) const </p><p>void <strong>setGLRenderAction</strong> (<strong>SoGLRenderAction</strong> *const action)</p><p><strong>SoGLRenderAction</strong> * <strong>getGLRenderAction</strong> (void) const </p><p>void <strong>setAudioRenderAction</strong> (<strong>SoAudioRenderAction</strong> *const action)</p><p><strong>SoAudioRenderAction</strong> * <strong>getAudioRenderAction</strong> (void) const </p><p>void <strong>setHandleEventAction</strong> (<strong>SoHandleEventAction</strong> *hea)</p><p><strong>SoHandleEventAction</strong> * <strong>getHandleEventAction</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static uint32_t <strong>getDefaultRedrawPriority</strong> (void)</p><p>static void <strong>enableRealTimeUpdate</strong> (const SbBool flag)</p><p>static SbBool <strong>isRealTimeUpdateEnabled</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p>int <strong>isActive</strong> (void) const </p><p>void <strong>redraw</strong> (void)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoSceneManager</strong> class provides the main interface between the scene graph and the GUI toolkit.</p><p>The renderarea class from the GUI toolkit you are using uses this class as the interface against the scene graph. Event handling and providing 'hooks' to do rendering are the main functions of the class.</p><p>A Coin library instance within an application will typically contain a single <strong>SoSceneManager</strong> object. The pointer for this object is stored in the GUI renderarea class.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoSceneManager::SoSceneManager (void)</h3>
<p>Constructor. Sets up default <strong>SoGLRenderAction</strong> and <strong>SoHandleEventAction</strong> instances.</p>
<h3>SoSceneManager::~SoSceneManager ()\fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SoSceneManager::render (const SbBoolclearwindow = \fCTRUE\fP, const SbBoolclearzbuffer = \fCTRUE\fP)\fC [virtual]\fP</h3>
<p>Render the scene graph.</p><p>If <em>clearwindow</em> is TRUE<em>, clear the rendering buffer before drawing. If </em><em>clearzbuffer</em><em> is TRUE</em><em>, clear the depth buffer values before rendering. Both of these arguments should normally be TRUE</em><em>, but they can be set to FALSE</em><em> to optimize for special cases (e.g. when doing wireframe rendering one doesn't need a depth buffer).</em></p>
<h3>void SoSceneManager::render (\fBSoGLRenderAction\fP *action, const SbBoolinitmatrices = \fCTRUE\fP, const SbBoolclearwindow = \fCTRUE\fP, const SbBoolclearzbuffer = \fCTRUE\fP)\fC [virtual]\fP</h3>
<p>Render method used for thread safe rendering.</p><p>Since only one thread can use an <strong>SoGLRenderAction</strong>, this method enables you to supply your own thread-specific <strong>SoGLRenderAction</strong> to be used for rendering the scene.</p><p>If <em>initmatrices</em> is TRUE<em>, the OpenGL model and projection matrices will be initialized to identity matrices before applying the action.</em></p><p>If <em>clearwindow</em> is TRUE<em>, clear the rendering buffer before drawing. If </em><em>clearzbuffer</em><em> is TRUE</em><em>, clear the depth buffer values before rendering.</em></p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoSceneManager::setCamera (\fBSoCamera\fP *camera)</h3>
<p>Sets the camera to be used.</p>
<h3>\fBSoCamera\fP * SoSceneManager::getCamera (void) const</h3>
<p>Returns the current camera.</p>
<h3>SbBool SoSceneManager::processEvent (const \fBSoEvent\fP *constevent)\fC [virtual]\fP</h3>
<p>Process the given event by applying an <strong>SoHandleEventAction</strong> on the scene graph.</p>
<h3>void SoSceneManager::reinitialize (void)</h3>
<p>Reinitialize after parameters affecting the OpenGL context has changed.</p>
<h3>void SoSceneManager::scheduleRedraw (void)</h3>
<p>Redraw at first opportunity as system becomes idle.</p><p>Multiple calls to this method before an actual redraw has taken place will only result in a single redraw of the scene.</p>
<h3>void SoSceneManager::setSceneGraph (\fBSoNode\fP *constsceneroot)\fC [virtual]\fP</h3>
<p>Set the node which is top of the scene graph we're managing. The <em>sceneroot</em> node reference count will be increased by 1, and any previously set scene graph top node will have it's reference count decreased by 1.</p><p><strong>See also:</strong></p><p><strong>getSceneGraph()</strong></p>
<h3>\fBSoNode\fP * SoSceneManager::getSceneGraph (void) const\fC [virtual]\fP</h3>
<p>Returns pointer to root of scene graph.</p>
<h3>void SoSceneManager::setWindowSize (const \fBSbVec2s\fP &newsize)</h3>
<p>Update window size of our <strong>SoGLRenderAction</strong>'s viewport settings.</p><p>Note that this will <em>only</em> change the information about window dimensions, the actual viewport size and origin (ie the rectangle which redraws are confined to) will stay the same.</p><p><strong>See also:</strong></p><p><strong>setViewportRegion()</strong></p>
<h3>const \fBSbVec2s\fP & SoSceneManager::getWindowSize (void) const</h3>
<p>Returns the current render action window size.</p><p><strong>See also:</strong></p><p><strong>setWindowSize()</strong></p>
<h3>void SoSceneManager::setSize (const \fBSbVec2s\fP &newsize)</h3>
<p>Set size of rendering area for the viewport within the current window.</p>
<h3>const \fBSbVec2s\fP & SoSceneManager::getSize (void) const</h3>
<p>Returns size of render area.</p>
<h3>void SoSceneManager::setOrigin (const \fBSbVec2s\fP &newOrigin)</h3>
<p>Set <em>only</em> the origin of the viewport region within the rendering window.</p><p><strong>See also:</strong></p><p><strong>setViewportRegion()</strong>, <strong>setWindowSize()</strong></p>
<h3>const \fBSbVec2s\fP & SoSceneManager::getOrigin (void) const</h3>
<p>Returns origin of rendering area viewport.</p><p><strong>See also:</strong></p><p><strong>setOrigin()</strong></p>
<h3>void SoSceneManager::setViewportRegion (const \fBSbViewportRegion\fP &newregion)</h3>
<p>Update our <strong>SoGLRenderAction</strong>'s viewport settings.</p><p>This will change <em>both</em> the information about window dimensions and the actual viewport size and origin.</p><p><strong>See also:</strong></p><p><strong>setWindowSize()</strong></p>
<h3>const \fBSbViewportRegion\fP & SoSceneManager::getViewportRegion (void) const</h3>
<p>Returns current viewport region used by the renderaction and the event handling.</p><p><strong>See also:</strong></p><p><strong>setViewportRegion()</strong></p>
<h3>void SoSceneManager::setBackgroundColor (const \fBSbColor\fP &color)</h3>
<p>Sets color of rendering canvas.</p>
<h3>const \fBSbColor\fP & SoSceneManager::getBackgroundColor (void) const</h3>
<p>Returns color used for clearing the rendering area before rendering the scene.</p>
<h3>void SoSceneManager::setBackgroundIndex (const intindex)</h3>
<p>Set index of background color in the color lookup table if rendering in colorindex mode.</p><p>Note: colorindex mode is not supported yet in Coin.</p>
<h3>int SoSceneManager::getBackgroundIndex (void) const</h3>
<p>Returns index of colormap for background filling.</p><p><strong>See also:</strong></p><p><strong>setBackgroundIndex()</strong></p>
<h3>void SoSceneManager::setRGBMode (const SbBoolyes)</h3>
<p>Turn RGB truecolor mode on or off. If you turn truecolor mode off, colorindex mode will be used instead.</p>
<h3>SbBool SoSceneManager::isRGBMode (void) const</h3>
<p>Returns the 'truecolor or colorindex' mode flag.</p>
<h3>void SoSceneManager::activate (void)\fC [virtual]\fP</h3>
<p>Activate rendering and event handling. Default is off.</p>
<h3>void SoSceneManager::deactivate (void)\fC [virtual]\fP</h3>
<p>Deactive rendering and event handling.</p>
<h3>void SoSceneManager::setRenderCallback (\fBSoSceneManagerRenderCB\fP *f, void *constuserdata = \fCNULL\fP)</h3>
<p>Set the callback function <em>f</em> to invoke when rendering the scene. <em>userdata</em> will be passed as the first argument of the function.</p>
<h3>SbBool SoSceneManager::isAutoRedraw (void) const</h3>
<p>Returns TRUE if the <strong>SoSceneManager</strong> automatically redraws the scene upon detecting changes in the scene graph.</p><p>The automatic redraw is turned on and off by setting either a valid callback function with <strong>setRenderCallback()</strong>, or by passing NULL<strong>.</strong></p>
<h3>void SoSceneManager::setRedrawPriority (const uint32_tpriority)</h3>
<p>Set up the redraw <em>priority</em> for the <strong>SoOneShotSensor</strong> used to trigger redraws. By setting this lower than for your own sensors, you can make sure some code is always run before redraw happens.</p><p><strong>See also:</strong></p><p><strong>SoDelayQueueSensor</strong></p>
<h3>uint32_t SoSceneManager::getRedrawPriority (void) const</h3>
<p>Returns value of priority on the redraw sensor.</p>
<h3>void SoSceneManager::setAntialiasing (const SbBoolsmoothing, const intnumpasses)</h3>
<p>Turn antialiased rendering on or off.</p><p>See documentation for <strong>SoGLRenderAction::setSmoothing()</strong> and <strong>SoGLRenderAction::setNumPasses()</strong>.</p>
<h3>void SoSceneManager::getAntialiasing (SbBool &smoothing, int &numpasses) const</h3>
<p>Returns rendering pass information.</p><p><strong>See also:</strong></p><p><strong>setAntialiasing()</strong></p>
<h3>void SoSceneManager::setGLRenderAction (\fBSoGLRenderAction\fP *constaction)</h3>
<p>Set the <em>action</em> to use for rendering. Overrides the default action made in the constructor.</p>
<h3>\fBSoGLRenderAction\fP * SoSceneManager::getGLRenderAction (void) const</h3>
<p>Returns pointer to render action.</p>
<h3>void SoSceneManager::setAudioRenderAction (\fBSoAudioRenderAction\fP *constaction)</h3>
<p>Set the <em>action</em> to use for rendering audio. Overrides the default action made in the constructor.</p>
<h3>\fBSoAudioRenderAction\fP * SoSceneManager::getAudioRenderAction (void) const</h3>
<p>Returns pointer to audio render action.</p>
<h3>void SoSceneManager::setHandleEventAction (\fBSoHandleEventAction\fP *hea)</h3>
<p>Set the <em>action</em> to use for event handling. Overrides the default action made in the constructor.</p>
<h3>\fBSoHandleEventAction\fP * SoSceneManager::getHandleEventAction (void) const</h3>
<p>Returns pointer to event handler action.</p>
<h3>uint32_t SoSceneManager::getDefaultRedrawPriority (void)\fC [static]\fP</h3>
<p>Returns the default priority of the redraw sensor.</p><p><strong>See also:</strong></p><p><strong>SoDelayQueueSensor</strong>, <strong>setRedrawPriority()</strong></p>
<h3>void SoSceneManager::enableRealTimeUpdate (const SbBoolflag)\fC [static]\fP</h3>
<p>Set whether or not for <strong>SoSceneManager</strong> instances to 'touch' the global realTime<strong> field after a redraw. If this is not done, redrawing when animating the scene will only happen as fast as the realTime</strong> interval goes (which defaults to 12 times a second).</p><p><strong>See also:</strong></p><p><strong>SoDB::setRealTimeInterval()</strong></p>
<h3>SbBool SoSceneManager::isRealTimeUpdateEnabled (void)\fC [static]\fP</h3>
<p>Returns whether or not we automatically notifies everything connected to the realTime field after a redraw.</p>
<h3>int SoSceneManager::isActive (void) const\fC [protected]\fP</h3>
<p>Returns the <em>active</em> flag.</p>
<h3>void SoSceneManager::redraw (void)\fC [protected]\fP</h3>
<p>Do an immediate redraw by calling the redraw callback function.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoSceneKit.3.html"><span aria-hidden="true">&larr;</span> SoSceneKit.3: The soscenekit class collects node kits needed to set up a scene: camera, light and shapes.  node kit structure (new entries versus parent class marked with arrow prefix):</a></li>
   <li class="next"><a href="SoSceneManager.h.3.html">SoSceneManager.h.3: Soscenemanager.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

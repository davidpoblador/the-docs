<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::Stream: Creates an xml stream connection and parses return data</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Creates an xml stream connection and parses return data">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::Stream (3pm) manual">
  <meta name="twitter:description" content="Creates an xml stream connection and parses return data">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-stream-perl-XML::Stream-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::Stream.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::Stream (3pm) manual" />
  <meta property="og:description" content="Creates an xml stream connection and parses return data" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-stream-perl-XML::Stream-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::Stream<small> (3pm)</small></h1>
        <p class="lead">Creates an xml stream connection and parses return data</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Stream.3pm.html">
      <span itemprop="name">XML::Stream: Creates an xml stream connection and parses return data</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-stream-perl/">
      <span itemprop="name">libxml-stream-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Stream.3pm.html">
      <span itemprop="name">XML::Stream: Creates an xml stream connection and parses return data</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  XML::Stream is an attempt at solidifying the use of XML via streaming.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>  This module provides the user with methods to connect to a remote   server, send a stream of XML to the server, and receive/parse an XML   stream from the server.  It is primarily based work for the Etherx XML   router developed by the Jabber Development Team.  For more information   about this project visit http://xmpp.org/protocols/streams/.</p><p>  XML::Stream gives the user the ability to define a central callback   that will be used to handle the tags received from the server.  These   tags are passed in the format defined at instantiation time.   the closing tag of an object is seen, the tree is finished and passed   to the call back function.  What the user does with it from there is up   to them.</p><p>  For a detailed description of how this module works, and about the data   structure that it returns, please view the source of Stream.pm and   look at the detailed description at the end of the file.</p><p>  NOTE: The parser that XML::Stream::Parser provides, as are most Perl   parsers, is synchronous.  If you are in the middle of parsing a   packet and call a user defined callback, the Parser is blocked until   your callback finishes.  This means you cannot be operating on a   packet, send out another packet and wait for a response to that packet.   It will never get to you.  Threading might solve this, but as we all   know threading in Perl is not quite up to par yet.  This issue will be   revisted in the future.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>  new(debug=&gt;string,       - creates the XML::Stream object.  debug       debugfh=&gt;FileHandle,   should be set to the path for the debug log       debuglevel=&gt;0|1|N,     to be written.  If set to "stdout" then the       debugtime=&gt;0|1,        debug will go there.   Also, you can specify       style=&gt;string)         a filehandle that already exists byt using                              debugfh.  debuglevel determines the amount                              of debug to generate.  0 is the least, 1 is                              a little more, N is the limit you want.                              debugtime determines wether a timestamp                              should be preappended to the entry.  style                              defines the way the data structure is                              returned.  The two available styles are:</p><p>                               tree - XML::Parser Tree format                                node - XML::Stream::Node format</p><p>                             For more information see the respective man                              pages.</p><p>  Connect(hostname=&gt;string,       - opens a tcp connection to the           port=&gt;integer,            specified server and sends the proper           to=&gt;string,               opening XML Stream tag.  hostname,           from=&gt;string,             port, and namespace are required.           myhostname=&gt;string,       namespaces allows you to use           namespace=&gt;string,        XML::Stream::Namespace objects.           namespaces=&gt;array,        to is needed if you want the stream           connectiontype=&gt;string,   to attribute to be something other           ssl=&gt;0|1,                 than the hostname you are connecting           srv=&gt;string)              to.  from is needed if you want the                                     stream from attribute to be something                                     other than the hostname you are                                     connecting from.  myhostname should                                     not be needed but if the module                                     cannot determine your hostname                                     properly (check the debug log), set                                     this to the correct value, or if you                                     want the other side of the  stream to                                     think that you are someone else.  The                                     type determines the kind of                                     connection that is made:                                       "tcpip"    - TCP/IP (default)                                       "stdinout" - STDIN/STDOUT                                       "http"     - HTTP                                     HTTP recognizes proxies if the ENV                                     variables http_proxy or https_proxy                                     are set.  ssl specifies if an SSL                                     socket should be used for encrypted                                     communications.  This function                                     returns the same hash from GetRoot()                                     below. Make sure you get the SID                                     (Session ID) since you have to use it                                     to call most other functions in here.</p><p>                                    If srv is specified AND Net::DNS is                                     installed and can be loaded, then                                     an SRV query is sent to srv.hostname                                     and the results processed to replace                                     the hostname and port.  If the lookup                                     fails, or Net::DNS cannot be loaded,                                     then hostname and port are left alone                                     as the defaults.</p><p>  OpenFile(string) - opens a filehandle to the argument specified, and                      pretends that it is a stream.  It will ignore the                      outer tag, and not check if it was a                      &lt;stream:stream/&gt;. This is useful for writing a                      program that has to parse any XML file that is                      basically made up of small packets (like RDF).</p><p>  Disconnect(sid) - sends the proper closing XML tag and closes the                     specified socket down.</p><p>  Process(integer) - waits for data to be available on the socket.  If                      a timeout is specified then the Process function                      waits that period of time before returning nothing.                      If a timeout period is not specified then the                      function blocks until data is received.  The                      function returns a hash with session ids as the key,                      and status values or data as the hash values.</p><p>  SetCallBacks(node=&gt;function,   - sets the callback that should be                update=&gt;function)   called in various situations.  node                                    is used to handle the data structures                                    that are built for each top level tag.                                    Update is used for when Process is                                    blocking waiting for data, but you                                    want your original code to be updated.</p><p>  GetRoot(sid) - returns the attributes that the stream:stream tag sent                  by the other end listed in a hash for the specified                  session.</p><p>  GetSock(sid) - returns a pointer to the IO::Socket object for the                  specified session.</p><p>  Send(sid,    - sends the string over the specified connection as is.        string)   This does no checking if valid XML was sent or not.                  Best behavior when sending information.</p><p>  GetErrorCode(sid) - returns a string for the specified session that                       will hopefully contain some useful information                       about why Process or Connect returned an undef                       to you.</p><p>  XPath(node,path) - returns an array of results that match the xpath.                      node can be any of the three types (Tree, Node).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VARIABLES</h2>
        <div class="sectioncontent">
<p>  $NONBLOCKING - tells the Parser to enter into a nonblocking state.  This                  might cause some funky behavior since you can get nested                  callbacks while things are waiting.  1=on, 0=off(default).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>  ##########################   # simple example</p><p>  use XML::Stream qw( Tree );</p><p>  $stream = new XML::Stream;</p><p>  my $status = $stream-&gt;Connect(hostname =&gt; "jabber.org",                                 port =&gt; 5222,                                 namespace =&gt; "jabber:client");</p><p>  if (!defined($status)) {     print "ERROR: Could not connect to server&#92;n";     print "       (",$stream-&gt;GetErrorCode(),")&#92;n";     <strong>exit</strong>(0);   }</p><p>  while($node = $stream-&gt;Process()) {     # do something with $node   }</p><p>  $stream-&gt;Disconnect();</p><p>  ###########################   # example using a handler</p><p>  use XML::Stream qw( Tree );</p><p>  $stream = new XML::Stream;   $stream-&gt;SetCallBacks(node=&gt;&#92;&noder);   $stream-&gt;Connect(hostname =&gt; "jabber.org",                    port =&gt; 5222,                    namespace =&gt; "jabber:client",                    timeout =&gt; undef) || die $!;</p><p>  # Blocks here forever, noder is called for incoming   # packets when they arrive.   while(defined($stream-&gt;Process())) { }</p><p>  print "ERROR: Stream died (",$stream-&gt;GetErrorCode(),")&#92;n";</p><p>  sub noder   {     my $sid = shift;     my $node = shift;     # do something with $node   }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Tweaked, tuned, and brightness changes by Ryan Eatmon, reatmon@ti.com in May of 2000. Colorized, and Dolby Surround sound added by Thomas Charron, tcharron@jabber.org By Jeremie in October of 1999 for http://etherx.jabber.org/streams/</p><p>Currently maintained by Darian Anthony Patrick.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::SimpleObject::LibXML.3pm.html"><span aria-hidden="true">&larr;</span> XML::SimpleObject::LibXML.3pm: Perl extension allowing a simple(r) object representation of an xml::libxml dom object.</a></li>
   <li class="next"><a href="XML::Stream::IO::Select::Win32.3pm.html">XML::Stream::IO::Select::Win32.3pm: Fake filehandle support for xml::stream <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

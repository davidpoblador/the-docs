<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Locale::TextDomain: Perl interface to uniforum message translation</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl interface to uniforum message translation">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Locale::TextDomain (3pm) manual">
  <meta name="twitter:description" content="Perl interface to uniforum message translation">
  <meta name="twitter:image" content="https://www.carta.tech/images/libintl-perl-Locale::TextDomain-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Locale::TextDomain.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Locale::TextDomain (3pm) manual" />
  <meta property="og:description" content="Perl interface to uniforum message translation" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libintl-perl-Locale::TextDomain-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Locale::TextDomain<small> (3pm)</small></h1>
        <p class="lead">Perl interface to uniforum message translation</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Locale::TextDomain.3pm.html">
      <span itemprop="name">Locale::TextDomain: Perl interface to uniforum message translation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libintl-perl/">
      <span itemprop="name">libintl-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Locale::TextDomain.3pm.html">
      <span itemprop="name">Locale::TextDomain: Perl interface to uniforum message translation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Locale::TextDomain (&apos;my-package&apos;, @locale_dirs);

 use Locale::TextDomain qw (my-package);

 my $translated = _\|_"Hello World!&#92;n";

 my $alt = $_\|_{"Hello World!&#92;n"};

 my $alt2 = $_\|_-&gt;{"Hello World!&#92;n"};

 my @list = (N_\|_"Hello",
             N_\|_"World");

 printf (_\|_n ("one file read",
              "%d files read",
              $num_files),
         $num_files);

 print _\|_nx ("one file read", "{num} files read", $num_files,
             num =&gt; $num_files);

 my $translated_context = _\|_p ("Verb, to view", "View");

 printf (_\|_np ("Files read from filesystems",
               "one file read",
               "%d files read",
               $num_files),
         $num_files);

 print _\|_npx ("Files read from filesystems",
              "one file read",
              "{num} files read",
              $num_files,
              num =&gt; $num_files);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The module <em>Locale::TextDomain</em>\|(3pm) provides a high-level interface to Perl message translation.</p><h3>Textdomains</h3>
<p>When you request a translation for a given string, the system used in libintl-perl follows a standard strategy to find a suitable message catalog containing the translation: Unless you explicitely define a name for the message catalog, libintl-perl will assume that your catalog is called 'messages' (unless you have changed the default value to something else via <em>Locale::Messages</em>\|(3pm), method <em>textdomain()</em>).</p><p>You might think that his default strategy leaves room for optimization and you are right.  It would be a lot smarter if multiple software packages, all with their individual message catalogs, could be installed on one system, and it should also be possible that third-party components of your software (like Perl modules) can load their message catalogs, too, without interfering with yours.</p><p>The solution is clear, you have to assign a unique name to your message database, and you have to specify that name at run-time.  That unique name is the so-called <em>textdomain</em> of your software package.  The name is actually arbitrary but you should follow these best-practice guidelines to ensure maximum interoperability:</p>
<dl class='dl-vertical'>
  <dt>
    File System Safety
  </dt>
  <dd>
    <p>In practice, textdomains get mapped into file names, and you should therefore make sure that the textdomain you choose is a valid filename on every system that will run your software.</p>
  </dd>
  <dt>
    Case-sensitivity
  </dt>
  <dd>
    <p>Textdomains are always case-sensitive (i. e. 'Package' and '\s-1PACKAGE\s0' are not the same).  However, since the message catalogs will be stored on file systems, that may or may not distinguish case when looking up file names, you should avoid potential conflicts here.</p>
  </dd>
  <dt>
    Textdomain Should Match \s-1CPAN\s0 Name
  </dt>
  <dd>
    <p>If your software is listed as a module on \s-1CPAN\s0, you should simply choose the name on \s-1CPAN\s0 as your textdomain.  The textdomain for libintl-perl is hence 'libintl-perl'.  But please replace all periods ('.') in your package name with an underscore because ...</p>
  </dd>
  <dt>
    Internet Domain Names as a Fallback
  </dt>
  <dd>
    <p>... if your software is <em>not</em> a module listed on \s-1CPAN\s0, as a last resort you should use the Java(tm) package scheme, i. e. choose an internet domain that you are owner of (or ask the owner of an internet domain) and concatenate your preferred textdomain with the reversed internet domain.  Example: Your company runs the web-site 'www.foobar.org' and is the owner of the domain 'foobar.org'.  The textdomain for your company's software 'barfoos' should hence be 'org.foobar.barfoos'.</p>
  </dd>

</dl>
<p>If your software is likely to be installed in different versions on the same system, it is probably a good idea to append some version information to your textdomain.</p><p>Other systems are less strict with the naming scheme for textdomains but the phenomena known as Perl is actually a plethora of small, specialized modules and it is probably wisest to postulate some namespace model in order to avoid chaos.</p>
<h3>Binding textdomains to directories</h3>
<p>Once the system knows the <em>textdomain</em> of the message that you want to get translated into the user's language, it still has to find the correct message catalog.  By default, libintl-perl will look up the string in the translation database found in the directories <em>/usr/share/locale</em> and <em>/usr/local/share/locale</em> (in that order).</p><p>It is neither guaranteed that these directories exist on the target machine, nor can you be sure that the installation routine has write access to these locations.  You can therefore instruct libintl-perl to search other directories prior to the default directories.  Specifying a differnt search directory is called <em>binding</em> a textdomain to a directory.</p><p>Beginning with version 1.20, <strong>Locale::TextDomain</strong> extends the default strategy by a Perl-specific approach.  If File::ShareDir is installed, it will look in the subdirectories named <em>locale</em> and <em>LocaleData</em> (in that order) in the directory returned by \*(C`File::ShareDir::dist_dir ($textdomain)\*(C' (if File::ShareDir is installed), and check for a database containing the message for your textdomain there. This allows you to install your database in the Perl-specific shared directory using Module::Install's \*(C`install_share\*(C' directive or the Dist::Zilla ShareDir plugin.</p><p>If File::ShareDir is not availabe, or if Locale::TextDomain fails to find the translation files in the File::ShareDir directory, it will next look in every directory found in the standard include path @INC, and check for a database containing the message for your textdomain there. Example: If the path <em>/usr/lib/perl/5.8.0/site_perl</em> is in your @INC, you can install your translation files in <em>/usr/lib/perl/5.8.0/site_perl/LocaleData</em>, and they will be found at run-time.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>It is crucial to remember that you use <em>Locale::TextDomain</em>\|(3) as specified in the section \*(L"\s-1SYNOPSIS\s0\*(R", that means you have to <strong>use</strong> it, not <strong>require</strong> it.  The module behaves quite differently compared to other modules.</p><p>The most significant difference is the meaning of the list passed as an argument to the <em>use()</em> function.  It actually works like this:</p><p>    use Locale::TextDomain (TEXTDOMAIN, DIRECTORY, ...)</p><p>The first argument (the first string passed to <em>use()</em>) is the textdomain of your package, optionally followed by a list of directories to search <em>instead</em> of the Perl-specific directories (see above: <em>/LocaleData</em> appended to a <em>File::ShareDir</em> directory and every path in @INC).</p><p>If you are the author of a package 'barfoos', you will probably put the line</p><p>    use Locale::TextDomain &apos;barfoos&apos;;</p><p>resp. for non-CPAN modules</p><p>    use Locale::TextDomain &apos;org.foobar.barfoos&apos;;</p><p>in every module of your package that contains translatable strings. If your module has been installed properly, including the message catalogs, it will then be able to retrieve these translations at run-time.</p><p>If you have not installed the translation database in a directory <em>LocaleData</em> in the File::ShareDir directory or the standard include path @INC (or in the system directories <em>/usr/share/locale</em> resp. <em>/usr/local/share/locale</em>), you have to explicitely specify a search path by giving the names of directories (as strings!) as additional arguments to <em>use()</em>:</p><p>    use Locale::TextDomain qw (barfoos ./dir1 ./dir2);</p><p>Alternatively you can call the function <em>bindtextdomain()</em> with suitable arguments (see the entry for <em>bindtextdomain()</em> in \*(L"\s-1FUNCTIONS\s0\*(R" in Locale::Messages).  If you do so, you should pass \*(C`undef\*(C' as an additional argument in order to avoid unnecessary lookups:</p><p>    use Locale::TextDomain (&apos;barfoos&apos;, undef);</p><p>You see that the arguments given to <em>use()</em> have nothing to do with what is imported into your namespace, but they are rather arguments to <em>textdomain()</em>, resp. <em>bindtextdomain()</em>.  Does that mean that <strong>Locale::TextDomain</strong> exports nothing into your namespace? Umh, not exactly ... in fact it imports <em>all</em> functions listed below into your namespace, and hence you should not define conflicting functions (and variables) yourself.</p><p>So, why has Locale::TextDomain to be different from other modules? If you have ever written software in C and prepared it for internationalization (i18n), you will probably have defined some preprocessor macros like:</p><p>    #define _(String) dgettext ("my-textdomain", String)     #define N_(String) String</p><p>You only have to define that once in C, and the textdomain for your package is automatically inserted into all gettext functions.  In Perl there is no such mechanism (at least it is not portable, option -P) and using the gettext functions could become quite cumbersome without some extra fiddling:</p><p>    print dgettext ("my-textdomain", "Hello world!&#92;n");</p><p>This is no fun.  In C it would merely be a</p><p>    printf (_("Hello world!&#92;n"));</p><p>Perl has to be more concise and shorter than C ... see the next section for how you can use <strong>Locale::TextDomain</strong> to end up in Perl with a mere</p><p>    print _\|_"Hello World!&#92;n";</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTED FUNCTIONS</h2>
        <div class="sectioncontent">
<p>All functions have quite funny names on purpose.  In fact the purpose for that is quite clear: They should be short, operator-like, and they should not yell for conflicts with existing functions in <em>your</em> namespace.  You will understand it, when you internationalize your first Perl program or module.  Preparing it is more like marking strings as being translatable than inserting function calls.  Here we go:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>_\|_ \s-1MSGID\s0</strong>
  </dt>
  <dd>
    <p><strong>\s-1NOTE:\s0</strong> This is a <em>double</em> underscore! The basic and most-used function.  It is a short-cut for a call to <em>gettext()</em> resp. <em>dgettext()</em>, and simply returns the translation for <strong>\s-1MSGID\s0</strong>.  If your old code reads like this:     print "permission denied"; You will now write:     print _\|_"permission denied"; That's all, the string will be output in the user's preferred language, provided that you have installed a translation for it. Of course you can also use parentheses:     print _\|_("permission denied"); Or even:     print (_\|_("permission denied")); In my eyes, the first version without parentheses looks best.</p>
  </dd>
  <dt>
    <strong>_\|_x \s-1MSGID\s0, \s-1ID1\s0 =&gt; \s-1VAL1\s0, \s-1ID2\s0 =&gt; \s-1VAL2\s0, ...</strong>
  </dt>
  <dd>
    <p>One of the nicest features in Perl is its capability to interpolate variables into strings:     print "This is the $color $thing.&#92;n"; This nice feature might con you into thinking that you could now write     print _\|_"This is the $color $thing.&#92;n"; Alas, that would be nice, but it is not possible.  Remember that the function _\|_() serves both as an operator for translating strings <em>and</em> as a mark for translatable strings.  If the above string would get extracted from your Perl code, the un-interpolated form would end up in the message catalog because when parsing your code it is unpredictable what values the variables $thing and $color will have at run-time (this fact is most probably one of the reasons you have written your program for). However, at run-time, Perl will have interpolated the values already <em>before</em> _\|_() (resp. the underlying <em>gettext()</em> function) has seen the original string.  Consequently something like \*(L"This is the red car.&#92;n\*(R" will be looked up in the message catalog, it will not be found (because only \*(L"This is the $color $thing.&#92;n\*(R" is included in the database), and the original, untranslated string will be returned. Honestly, because this is almost always an error, the <em>xgettext</em>\|(1) program will bail out with a fatal error when it comes across that string in your code. There are two workarounds for that:     printf _\|_"This is the %s %s.&#92;n", $color, $thing; But that has several disadvantages: Your translator will only see the isolated string, and without the surrounding code it is almost impossible to interpret it correctly.  Of course, \s-1GNU\s0 emacs and other software capable of editing \s-1PO\s0 translation files will allow you to examine the context in the source code, but it is more likely that your translator will look for a less challenging translation project when she frequently comes across such messages. And even if she does understand the underlying programming, what if she has to reorder the color and the thing like in French:     msgid "This is the red car.&#92;n";     msgstr "Cela est la voiture rouge.&#92;n" Zut alors! No way! You cannot portably reorder the arguments to <em>printf()</em> and friends in Perl (it is possible in C, but at the time of this writing not supported in Perl, and it would lead to other problems anyway). So what? The Perl backend to \s-1GNU\s0 gettext has defined an alternative format for interpolatable strings:     "This is the {color} {thing}.&#92;n"; Instead of Perl variables you use place-holders (legal Perl variables are also legal place-holders) in curly braces, and then you call     print _\|_x ("This is the {color} {thing}.&#92;n",                thing =&gt; $thang,                color =&gt; $color); The function _\|<em>_x()</em> will take the additional hash and replace all occurencies of the hash keys in curly braces with the corresponding values.  Simple, readable, understandable to translators, what else would you want?  And if the translator forgets, misspells or otherwise messes up some \*(L"variables\*(R", the <em>msgfmt</em>\|(1) program, that is used to compile the textual translation file into its binary representation will even choke on these errors and refuse to compile the translation.</p>
  </dd>
  <dt>
    <strong>_\|_n \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0</strong>
  </dt>
  <dd>
    <p>Whew! That looks complicated ... It is best explained with an example. We'll have another look at your vintage code:     if ($files_deleted &gt; 1) {         print "All files have been deleted.&#92;n";     } else {         print "One file has been deleted.&#92;n";     } Your intent is clear, you wanted to avoid the cumbersome \*(L"1 files deleted\*(R".  This is okay for English, but other languages have more than one plural form.  For example in Russian it makes a difference whether you want to say 1 file, 3 files or 6 files. You will use three different forms of the noun 'file' in each case.  [Note: Yep, very smart you are, the Russian word for 'file' is in fact the English word, and it is an invariable noun, but if you know that, you will also understand the rest despite this little simplification ...]. That is the reason for the existance of the function <em>ngettext()</em>, that _\|<em>_n()</em> is a short-cut for:     print _\|_n"One file has been deleted.&#92;n",              "All files have been deleted.&#92;n",              $files_deleted; Alternatively:     print _\|_n ("One file has been deleted.&#92;n",                "All files have been deleted.&#92;n",                $files_deleted); The effect is always the same: libintl-perl will find out which plural form to pick for your user's language, and the output string will always look okay.</p>
  </dd>
  <dt>
    <strong>_\|_nx \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0, \s-1VAR1\s0 =&gt; \s-1VAL1\s0, \s-1VAR2\s0 =&gt; \s-1VAL2\s0, ...</strong>
  </dt>
  <dd>
    <p>Bringing it all together:     print _\|_nx ("One file has been deleted.&#92;n",                 "{count} files have been deleted.&#92;n",                 $num_files,                 count =&gt; $num_files); The function _\|<em>_nx()</em> picks the correct plural form (also for English!) <em>and</em> it is capable of interpolating variables into strings. Have a close look at the order of arguments: The first argument is the string in the singular, the second one is the plural string. The third one is an integer indicating the number of items.  This third argument is <em>only</em> used to pick the correct translation.  The optionally following arguments make up the hash used for interpolation.  In the beginning it is often a little confusing that the variable holding the number of items will usually be repeated somewhere in the interpolation hash.</p>
  </dd>
  <dt>
    <strong>_\|_xn \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0, \s-1VAR1\s0 =&gt; \s-1VAL1\s0, \s-1VAR2\s0 =&gt; \s-1VAL2\s0, ...</strong>
  </dt>
  <dd>
    <p>Does exactly the same thing as _\|<em>_nx()</em>.  In fact it is a common typo promoted to a feature.</p>
  </dd>
  <dt>
    <strong>_\|_p \s-1MSGCTXT\s0, \s-1MSGID\s0</strong>
  </dt>
  <dd>
    <p>This is much like _\|_. The \*(L"p\*(R" stands for \*(L"particular\*(R", and the \s-1MSGCTXT\s0 is used to provide context to the translator. This may be neccessary when your string is short, and could stand for multiple things. For example:     print _\|_p"Verb, to view", "View";     print _\|_p"Noun, a view", "View"; The above may be \*(L"View\*(R" entries in a menu, where View-&gt;Source and File-&gt;View are different forms of \*(L"View\*(R", and likely need to be translated differently. A typical usage are \s-1GUI\s0 programs.  Imagine a program with a main menu and the notorious \*(L"Open\*(R" entry in the \*(L"File\*(R" menu.  Now imagine, there is another menu entry Preferences-&gt;Advanced-&gt;Policy where you have a choice between the alternatives \*(L"Open\*(R" and \*(L"Closed\*(R".  In English, \*(L"Open\*(R" is the adequate text at both places.  In other languages, it is very likely that you need two different translations.  Therefore, you would now write:     _\|_p"File|", "Open";     _\|_p"Preferences|Advanced|Policy", "Open"; In English, or if no translation can be found, the second argument (\s-1MSGID\s0) is returned. This function was introduced in libintl-perl 1.17.</p>
  </dd>
  <dt>
    <strong>_\|_px \s-1MSGCTXT\s0, \s-1MSGID\s0, \s-1VAR1\s0 =&gt; \s-1VAL1\s0, \s-1VAR2\s0 =&gt; \s-1VAL2\s0, ...</strong>
  </dt>
  <dd>
    <p>Like _\|<em>_p()</em>, but supports variable substitution in the string, like _\|<em>_x()</em>.     print _\|_px("Verb, to view", "View {file}", file =&gt; $filename); See _\|<em>_p()</em> and _\|<em>_x()</em> for more details. This function was introduced in libintl-perl 1.17.</p>
  </dd>
  <dt>
    <strong>_\|_np \s-1MSGCTXT\s0, \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0</strong>
  </dt>
  <dd>
    <p>This adds context to plural calls. It should not be needed very often, if at all, due to the _\|<em>_nx()</em> function. The type of variable substitution used in other gettext libraries (using sprintf-like sybols, like %s or %1) sometimes required context. For a (bad) example of this:     printf (_\|_np("[count] files have been deleted",                 "One file has been deleted.&#92;n",                 "%s files have been deleted.&#92;n",                 $num_files),             $num_files); \s-1NOTE:\s0 The above usage is discouraged. Just use the _\|<em>_nx()</em> call, which provides inline context via the key names. This function was introduced in libintl-perl 1.17.</p>
  </dd>
  <dt>
    <strong>_\|_npx \s-1MSGCTXT\s0, \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0, \s-1VAR1\s0 =&gt; \s-1VAL1\s0, \s-1VAR2\s0 =&gt; \s-1VAL2\s0, ...</strong>
  </dt>
  <dd>
    <p>This is provided for comleteness. It adds the variable interpolation into the string to the previous method, _\|<em>_np()</em>. It's usage would be like so:     print _\|_nx ("Files being permenantly removed",                 "One file has been deleted.&#92;n",                 "{count} files have been deleted.&#92;n",                 $num_files,                 count =&gt; $num_files); I cannot think of any situations requiring this, but we can easily support it, so here it is. This function was introduced in libintl-perl 1.17.</p>
  </dd>
  <dt>
    <strong>N_\|_ (\s-1ARG1\s0, \s-1ARG2\s0, ...)</strong>
  </dt>
  <dd>
    <p>A no-op function that simply echoes its arguments to the caller.  Take the following piece of Perl:     my @options = (         "Open",         "Save",         "Save As",     );</p><p>    ...</p><p>    my $option = $options[1]; Now say that you want to have this translatable.  You could sometimes simply do:     my @options = (         _\|_"Open",         _\|_"Save",         _\|_"Save As",     );</p><p>    ...</p><p>    my $option = $options[1]; But often times this will not be what you want, for example when you also need the unmodified original string.  Sometimes it may not even work, for example, when the preferred user language is not yet determined at the time that the list is initialized. In these cases you would write:     my @options = (         N_\|_"Open",         N_\|_"Save",         N_\|_"Save As",     );</p><p>    ...</p><p>    my $option = _\|_($options[1]);     # or: my $option = dgettext (&apos;my-domain&apos;, $options[1]); Now all the strings in @options will be left alone, since N_\|_() returns its arguments (one ore more) unmodified.  Nevertheless, the string extractor will be able to recognize the strings as being translatable.  And you can still get the translation later by passing the variable instead of the string to one of the above translation functions.</p>
  </dd>
  <dt>
    <strong>N_\|_n (\s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0)</strong>
  </dt>
  <dd>
    <p>Does exactly the same as N_\|_().  You will use this form if you have to mark the strings as having plural forms.</p>
  </dd>
  <dt>
    <strong>N_\|_p (\s-1MSGCTXT\s0, \s-1MSGID\s0)</strong>
  </dt>
  <dd>
    <p>Marks <strong>\s-1MSGID\s0</strong> as N_\|_() does, but in the context <strong>\s-1MSGCTXT\s0</strong>.</p>
  </dd>
  <dt>
    <strong>N_\|_np (\s-1MSGCTXT\s0, \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0)</strong>
  </dt>
  <dd>
    <p>Marks <strong>\s-1MSGID\s0</strong> as N_\|<em>_n()</em> does, but in the context <strong>\s-1MSGCTXT\s0</strong>. =back</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTED VARIABLES</h2>
        <div class="sectioncontent">
<p>The module exports several variables into your namespace: A tied hash.  Its keys are your original messages, the values are their translations:     my $title = "&lt;h1&gt;$_\|_{&apos;My Homepage&apos;}&lt;/h1&gt;"; This is much better for your translation team than     my $title = _\|_"&lt;h1&gt;My Homepage&lt;/h1&gt;"; In the second case the \s-1HTML\s0 code will make it into the translation database and your translators have to be aware of \s-1HTML\s0 syntax when translating strings. <strong>Warning:</strong> Do <em>not</em> use this hash outside of double-quoted strings! The code in the tied hash object relies on the correct working of the function <em>caller()</em> (see \*(L"perldoc -f caller\*(R"), and this function will report incorrect results if the tied hash value is the argument to a function from another package, for example:   my $result = Other::Package::do_it ($_\|_{&apos;Some string&apos;}); The tied hash code will see \*(L"Other::Package\*(R" as the calling package, instead of your own package.  Consequently it will look up the message in the wrong text domain.  There is no workaround for this bug. Therefore: Never use the tied hash interpolated strings! A reference to \*(C`%_\|_\*(C', in case you prefer:      my $title = "&lt;h1&gt;$_\|_-&gt;{&apos;My Homepage&apos;}&lt;/h1&gt;";</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERFORMANCE</h2>
        <div class="sectioncontent">
<p>Message translation can be a time-consuming task.  Take this little example:</p><p>    1: use Locale::TextDomain (&apos;my-domain&apos;);     2: use POSIX (:locale_h);     3:     4: setlocale (LC_ALL, &apos;&apos;);     5: print _\|_"Hello world!&#92;n";</p><p>This will usually be quite fast, but in pathological cases it may run for several seconds.  A worst-case scenario would be a Chinese user at a terminal that understands the codeset Big5-HKSCS. Your translator for Chinese has however chosen to encode the translations in the codeset EUC-TW.</p><p>What will happen at run-time?  First, the library will search and load a (maybe large) message catalog for your textdomain 'my-domain'.  Then it will look up the translation for \*(L"Hello world!&#92;n\*(R", it will find that it is encoded in EUC-TW.  Since that differs from the output codeset Big5-HKSCS, it will first load a conversion table containing several ten-thousands of codepoints for EUC-TW, then it does the same with the smaller, but still very large conversion table for Big5-HKSCS, it will convert the translation on the fly from EUC-TW into Big5-HKSCS, and finally it will return the converted translation.</p><p>A worst-case scenario but realistic.  And for these five lines of codes, there is not much you can do to make it any faster.  You should understand, however, <em>when</em> the different steps will take place, so that you can arrange your code for it.</p><p>You have learned in the section \*(L"\s-1DESCRIPTION\s0\*(R" that line 1 is responsible for locating your message database.  However, the <em>use()</em> will do nothing more than remembering your settings.  It will not search any directories, it will not load any catalogs or conversion tables.</p><p>Somewhere in your code you will always have a call to <em>POSIX::setlocale()</em>, and the performance of this call may be time-consuming, depending on the architecture of your system.  On some systems, this will consume very little time, on others it will only consume a considerable amount of time for the first call, and on others it may always be time-consuming.  Since you cannot know, how <em>setlocale()</em> is implemented on the target system, you should reduce the calls to <em>setlocale()</em> to a minimum.</p><p>Line 5 requests the translation for your string.  Only now, the library will actually load the message catalog, and only now will it load eventually needed conversion tables.  And from now on, all this information will be cached in memory.  This strategy is used throughout libintl-perl, and you may describe it as 'load-on-first-access'.  Getting the next translation will consume very little resources.</p><p>However, although the translation retrieval is somewhat obfuscated by an operator-like function call, it is still a function call, and in fact it even involves a chain of function calls.  Consequently, the following example is probably bad practice:</p><p>    foreach (1 .. 100_000) {         print _\|_"Hello world!&#92;n";     }</p><p>This example introduces a lot of overhead into your program.  Better do this:</p><p>    my $string = _\|_"Hello world!&#92;n";     foreach (1 .. 100_000) {         print $string;     }</p><p>The translation will never change, there is no need to retrieve it over and over again.  Although libintl-perl will of course cache the translation read from the file system, you can still avoid the overhead for the function calls.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2002-2013, Guido Flohr &lt;guido@imperia.net&gt;, all rights reserved.  See the source code for details.</p><p>This software is contributed to the Perl community by Imperia (&lt;http://www.imperia.net/&gt;).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Locale::TextDomain&hellip;</h2>
        <div class="sectioncontent">
<p><em>Locale::Messages</em>\|(3pm), <em>Locale::gettext_pp</em>\|(3pm), <em>perl</em>\|(1), <em>gettext</em>\|(1), <em>gettext</em>\|(3)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">POD ERRORS</h2>
        <div class="sectioncontent">
<p>Hey! <strong>The above document had some coding errors, which are explained below:</strong></p>
<dl class='dl-vertical'>
  <dt>
    Around line 924:
  </dt>
  <dd>
    <p>You forgot a '=back' before '=head1'</p>
  </dd>
  <dt>
    Around line 1070:
  </dt>
  <dd>
    <p>=cut found outside a pod block.  Skipping to next block.</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Locale::RecodeData::_Encode.3pm.html"><span aria-hidden="true">&larr;</span> Locale::RecodeData::_Encode.3pm: Internal wrapper around encode</a></li>
   <li class="next"><a href="Locale::US.3pm.html">Locale::US.3pm: Two letter codes for state identification in the united states and vice versa. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

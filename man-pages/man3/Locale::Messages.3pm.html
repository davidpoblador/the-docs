<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Locale::Messages: Gettext like message retrieval</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Gettext like message retrieval">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Locale::Messages (3pm) manual">
  <meta name="twitter:description" content="Gettext like message retrieval">
  <meta name="twitter:image" content="https://www.carta.tech/images/libintl-perl-Locale::Messages-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Locale::Messages.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Locale::Messages (3pm) manual" />
  <meta property="og:description" content="Gettext like message retrieval" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libintl-perl-Locale::Messages-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Locale::Messages<small> (3pm)</small></h1>
        <p class="lead">Gettext like message retrieval</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Locale::Messages.3pm.html">
      <span itemprop="name">Locale::Messages: Gettext like message retrieval</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libintl-perl/">
      <span itemprop="name">libintl-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Locale::Messages.3pm.html">
      <span itemprop="name">Locale::Messages: Gettext like message retrieval</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Locale::Messages (:locale_h :libintl_h);

 gettext $msgid;
 dgettext $textdomain, $msgid;
 dcgettext $textdomain, $msgid, LC_MESSAGES;
 ngettext $msgid, $msgid_plural, $count;
 dngettext $textdomain, $msgid, $msgid_plural, $count;
 dcngettext $textdomain, $msgid, $msgid_plural, $count, LC_MESSAGES;
 pgettext $msgctxt, $msgid;
 dpgettext $textdomain, $msgctxt, $msgid;
 dcpgettext $textdomain, $msgctxt, $msgid, LC_MESSAGES;
 npgettext $msgctxt, $msgid, $msgid_plural, $count;
 dnpgettext $textdomain, $msgctxt, $msgid, $msgid_plural, $count;
 dcnpgettext $textdomain, $msgctxt, $msgid, $msgid_plural, $count, LC_MESSAGES;
 textdomain $textdomain;
 bindtextdomain $textdomain, $directory;
 bind_textdomain_codeset $textdomain, $encoding;
 bind_textdomain_filter $textdomain, &#92;&filter, $data;
 turn_utf_8_on ($variable);
 turn_utf_8_off ($variable);
 nl_putenv (&apos;OUTPUT_CHARSET=koi8-r&apos;);
 my $category = LC_CTYPE;
 my $category = LC_NUMERIC;
 my $category = LC_TIME;
 my $category = LC_COLLATE;
 my $category = LC_MONETARY;
 my $category = LC_MESSAGES;
 my $category = LC_ALL;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The module <strong>Locale::Messages</strong> is a wrapper around the interface to message translation according to the Uniforum approach that is for example used in \s-1GNU\s0 gettext and Sun's Solaris.  It is intended to allow <em>Locale::Messages</em>\|(3) to switch between different implementations of the lower level libraries but this is not yet implemented.</p><p>Normally you should not use this module directly, but the high level interface <em>Locale::TextDomain</em>\|(3) that provides a much simpler interface.  This description is therefore deliberately kept brief.  Please refer to the \s-1GNU\s0 gettext documentation available at &lt;http://www.gnu.org/manual/gettext/&gt; for in-depth and background information on the topic.</p><p>The lower level module <em>Locale::gettext_pp</em>\|(3) provides the Perl implementation of <em>gettext()</em> and related functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The module exports by default nothing.  Every function has to be imported explicitely or via an export tag (\*(L"\s-1EXPORT\s0 \s-1TAGS\s0\*(R").</p>
<dl class='dl-vertical'>
  <dt>
    <strong>gettext \s-1MSGID\s0</strong>
  </dt>
  <dd>
    <p>Returns the translation for <strong>\s-1MSGID\s0</strong>.  Example:     print gettext "Hello World!&#92;n"; If no translation can be found, the unmodified <strong>\s-1MSGID\s0</strong> is returned, i. e. the function can <em>never</em> fail, and will <em>never</em> mess up your original message. Note for Perl 5.6 and later: The returned string will <em>always</em> have the \s-1UTF-8\s0 flag off by default.  See the documentation for function <em>bind_textdomain_filter()</em> for a way to change this behavior. One common mistake is this:     print gettext "Hello $name!"; Perl will interpolate the variable $name <em>before</em> the function will see the string.  Unless the corresponding message catalog contains a message \*(L"Hello Tom!\*(R", \*(L"Hello Dick!\*(R" or \*(L"Hello Harry!\*(R", no translation will be found. Using <em>printf()</em> and friends has its own problems:     print sprintf (gettext ("This is the %s %s."), $color, $thing); (The example is stupid because neither color nor thing will get translated here ...). In English the adjective (the color) will precede the noun, many other languages (for example French or Italian) differ here.  The translator of the message may therefore have a hard time to find a translation that will still work and not sound stupid in the target language.  Many C implementations of <em>printf()</em> allow to change the order of the arguments, and a French translator could then say:     "C&apos;est le %2$s %1$s." Perl <em>printf()</em> implements this feature as of version 5.8 or better. Consequently you can only use it, if you are sure that your software will run with Perl 5.8 or a later version. Another disadvantage of using <em>printf()</em> is its cryptic syntax (maybe not for you but translators of your software may have their own opinion). See the description of the function \*(C`_\|_x()\*(C' in <em>Locale::TextDomain</em>\|(3) for a much better way to get around this problem. Non-ASCII message ids ... You should note that the function (and all other similar functions in this module) does a bytewise comparison of the <strong>\s-1MSGID\s0</strong> for the lookup in the translation catalog, no matter whether obscure utf-8 flags are set on it, whether the string looks like utf-8, whether the <em>utf8</em>\|(3pm) pragma is used, or whatever other weird method past or future <em>perl</em>\|(1) versions invent for guessing character sets of strings. Using other than us-ascii characters in Perl source code is a call for trouble, a compatibility nightmare.  Furthermore, \s-1GNU\s0 gettext only lately introduced support for non-ascii character sets in sources, and support for this feature may not be available everywhere.  If you absolutely want to use <strong>\s-1MSGID\s0</strong>s in non-ascii character sets, it is wise to choose utf-8.  This will minimize the risk that <em>perl</em>\|(1) itself will mess with the strings, and it will also be a guaranty that you can later translate your project into arbitrary target languages. Other character sets can theoretically work.  Yet, using another character set in the Perl source code than the one used in your message catalogs will <strong>never</strong> work, since the lookup is done bytewise, and all strings with non-ascii characters will not be found. Even if you have solved all these problems, there is still one show stopper left: The gettext runtime \s-1API\s0 lacks a possibility to specify the character set of the source code (including the original strings). Consequently - in absence of a hint for the input encoding - strings without a translation are not subject to output character set conversion. In other words: If the (non-determinable) output character set differs from the character set used in the source code, output can be a mixture of two character sets.  There is no point in trying to address this problem in the pure Perl version of the gettext functions.  because breaking compatibilty between the Perl and the C version is a price too high to pay. This all boils down to: Only use \s-1ASCII\s0 characters in your translatable strings!</p>
  </dd>
  <dt>
    <strong>dgettext \s-1TEXTDOMAIN\s0, \s-1MSGID\s0</strong>
  </dt>
  <dd>
    <p>Like <em>gettext()</em>, but retrieves the message for the specified <strong>\s-1TEXTDOMAIN\s0</strong> instead of the default domain.  In case you wonder what a textdomain is, you should really read on with <em>Locale::TextDomain</em>\|(3).</p>
  </dd>
  <dt>
    <strong>dcgettext \s-1TEXTDOMAIN\s0, \s-1MSGID\s0, \s-1CATEGORY\s0</strong>
  </dt>
  <dd>
    <p>Like <em>dgettext()</em> but retrieves the message from the specified <strong>\s-1CATEGORY\s0</strong> instead of the default category \*(C`LC_MESSAGES\*(C'.</p>
  </dd>
  <dt>
    <strong>ngettext \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0</strong>
  </dt>
  <dd>
    <p>Retrieves the correct translation for <strong>\s-1COUNT\s0</strong> items.  In legacy software you will often find something like:     print "$count file(s) deleted.&#92;n"; or     printf "$count file%s deleted.&#92;n", $count == 1 ? &apos;&apos; : &apos;s&apos;; The first example looks awkward, the second will only work in English and languages with similar plural rules.  Before <em>ngettext()</em> was introduced, the best practice for internationalized programs was:     if ($count == 1) {         print gettext "One file deleted.&#92;n";     } else {         printf gettext "%d files deleted.&#92;n";     } This is a nuisance for the programmer and often still not sufficient for an adequate translation.  Many languages have completely different ideas on numerals.  Some (French, Italian, ...) treat 0 and 1 alike, others make no distinction at all (Japanese, Korean, Chinese, ...), others have two or more plural forms (Russian, Latvian, Czech, Polish, ...).  The solution is:     printf (ngettext ("One file deleted.&#92;n",                      "%d files deleted.&#92;n",                      $count), # argument to ngettext!             $count);          # argument to printf! In English, or if no translation can be found, the first argument (<strong>\s-1MSGID\s0</strong>) is picked if $count is one, the second one otherwise. For other languages, the correct plural form (of 1, 2, 3, 4, ...) is automatically picked, too.  You don't have to know anything about the plural rules in the target language, <em>ngettext()</em> will take care of that. This is most of the time sufficient but you will have to prove your creativity in cases like     printf "%d file(s) deleted, and %d file(s) created.&#92;n";</p>
  </dd>
  <dt>
    <strong>dngettext \s-1TEXTDOMAIN\s0, \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0</strong>
  </dt>
  <dd>
    <p>Like <em>ngettext()</em> but retrieves the translation from the specified textdomain instead of the default domain.</p>
  </dd>
  <dt>
    <strong>dcngettext \s-1TEXTDOMAIN\s0, \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0, \s-1CATEGORY\s0</strong>
  </dt>
  <dd>
    <p>Like <em>dngettext()</em> but retrieves the translation from the specified category, instead of the default category \*(C`LC_MESSAGES\*(C'.</p>
  </dd>
  <dt>
    <strong>pgettext \s-1MSGCTXT\s0, \s-1MSGID\s0</strong>
  </dt>
  <dd>
    <p>Returns the translation of \s-1MSGID\s0, given the context of \s-1MSGCTXT\s0. Both items are used as a unique key into the message catalog. This allows the translator to have two entries for words that may translate to different foreign words based on their context. For example, the word \*(L"View\*(R" may be a noun or a verb, which may be used in a menu as File-&gt;View or View-&gt;Source.     pgettext "Verb: To View", "View&#92;n";     pgettext "Noun: A View", "View&#92;n"; The above will both lookup different entries in the message catalog. A typical usage are \s-1GUI\s0 programs.  Imagine a program with a main menu and the notorious \*(L"Open\*(R" entry in the \*(L"File\*(R" menu.  Now imagine, there is another menu entry Preferences-&gt;Advanced-&gt;Policy where you have a choice between the alternatives \*(L"Open\*(R" and \*(L"Closed\*(R".  In English, \*(L"Open\*(R" is the adequate text at both places.  In other languages, it is very likely that you need two different translations.  Therefore, you would now write:     pgettext "File|", "Open";     pgettext "Preferences|Advanced|Policy", "Open"; In English, or if no translation can be found, the second argument (\s-1MSGID\s0) is returned. The function was introduced with libintl-perl version 1.17.</p>
  </dd>
  <dt>
    <strong>dpgettext \s-1TEXTDOMAIN\s0, \s-1MSGCTXT\s0, \s-1MSGID\s0</strong>
  </dt>
  <dd>
    <p>Like <em>pgettext()</em>, but retrieves the message for the specified <strong>\s-1TEXTDOMAIN\s0</strong> instead of the default domain. The function was introduced with libintl-perl version 1.17.</p>
  </dd>
  <dt>
    <strong>dcpgettext \s-1TEXTDOMAIN\s0, \s-1MSGCTXT\s0, \s-1MSGID\s0, \s-1CATEGORY\s0</strong>
  </dt>
  <dd>
    <p>Like <em>dpgettext()</em> but retrieves the message from the specified <strong>\s-1CATEGORY\s0</strong> instead of the default category \*(C`LC_MESSAGES\*(C'. The function was introduced with libintl-perl version 1.17.</p>
  </dd>
  <dt>
    <strong>npgettext \s-1MSGCTXT\s0, \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0</strong>
  </dt>
  <dd>
    <p>Like <em>ngettext()</em> with the addition of context as in <em>pgettext()</em>. In English, or if no translation can be found, the second argument (\s-1MSGID\s0) is picked if $count is one, the third one otherwise. The function was introduced with libintl-perl version 1.17.</p>
  </dd>
  <dt>
    <strong>dnpgettext \s-1TEXTDOMAIN\s0, \s-1MSGCTXT\s0, \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0</strong>
  </dt>
  <dd>
    <p>Like <em>npgettext()</em> but retrieves the translation from the specified textdomain instead of the default domain. The function was introduced with libintl-perl version 1.17.</p>
  </dd>
  <dt>
    <strong>dcnpgettext \s-1TEXTDOMAIN\s0, \s-1MSGCTXT\s0, \s-1MSGID\s0, \s-1MSGID_PLURAL\s0, \s-1COUNT\s0, \s-1CATEGORY\s0</strong>
  </dt>
  <dd>
    <p>Like <em>dnpgettext()</em> but retrieves the translation from the specified category, instead of the default category \*(C`LC_MESSAGES\*(C'. The function was introduced with libintl-perl version 1.17.</p>
  </dd>
  <dt>
    <strong>textdomain \s-1TEXTDOMAIN\s0</strong>
  </dt>
  <dd>
    <p>Sets the default textdomain (initially 'messages').</p>
  </dd>
  <dt>
    <strong>bindtextdomain \s-1TEXTDOMAIN\s0, \s-1DIRECTORY\s0</strong>
  </dt>
  <dd>
    <p>Binds <strong>\s-1TEXTDOMAIN\s0</strong> to <strong>\s-1DIRECTORY\s0</strong>.  Huh? An example:     bindtextdomain "my-package", "./mylocale"; Say, the selected locale (actually the selected locale for category \*(C`LC_MESSAGES\*(C') of the program is 'fr_CH', then the message catalog will be expected in <em>./mylocale/fr_CH/LC_MESSAGES/my-package.mo</em>.</p>
  </dd>
  <dt>
    <strong>bind_textdomain_codeset \s-1TEXTDOMAIN\s0, \s-1ENCODING\s0</strong>
  </dt>
  <dd>
    <p>Sets the output encoding for <strong>\s-1TEXTDOMAIN\s0</strong> to <strong>\s-1ENCODING\s0</strong>.</p>
  </dd>
  <dt>
    <strong>bind_textdomain_filter \s-1TEXTDOMAN\s0, \s-1CODEREF\s0, \s-1DATA\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>bind_textdomain_filter \s-1TEXTDOMAN\s0, \s-1CODEREF\s0</strong>
  </dt>
  <dd>
    <p>By default, Locale::Messages will turn the utf-8 flag of all returned messages off.  If you want to change this behavior, you can pass a reference to a subroutine that does different things - for example turn the utf-8 flag on, or leave it untouched.  The callback function will be called with <strong>\s-1DATA\s0</strong> as the first, and the possibly translated string as the second argument.  It should return the possibly modified string. If you want an object method to be called, pass the object itself in the data parameter and write a wrapper function.  Example:     sub wrapper {         my ($string, $obj) = @_;</p><p>        $obj-&gt;filterMethod ($string);     }     my $obj = MyPackage-&gt;new;</p><p>    bind_textdomain_filter (&apos;mydomain&apos;, &#92;&wrapper, $obj); The function cannot fail and always returns a true value. <strong>Attention:</strong> If you use the function for setting the utf-8 flag, it is <strong>your</strong> responsability to ensure that the output is really utf-8.  You should only use it, if you have set the environment variable <strong>\s-1OUTPUT_CHARSET\s0</strong> to \*(L"utf-8\*(R".  Additionally you should call <em>bind_textdomain_codeset()</em> with \*(L"utf-8\*(R" as the second argument. This function has been introduced in libintl-perl 1.16 and it is <strong>not</strong> part of the standard gettext \s-1API\s0.</p>
  </dd>
  <dt>
    <strong>turn_utf_8_on \s-1VARIABLE\s0</strong>
  </dt>
  <dd>
    <p>Returns \s-1VARIABLE\s0 but with the \s-1UTF-8\s0 flag (only known in Perl &gt;=5.6) guaranteed to be turned on.  This function does not really fit into the module, but it is often handy nevertheless. The flag does <strong>not</strong> mean that the string is in fact valid utf-8! The function was introduced with libintl-perl version 1.16.</p>
  </dd>
  <dt>
    <strong>turn_utf_8_off \s-1VARIABLE\s0</strong>
  </dt>
  <dd>
    <p>Returns \s-1VARIABLE\s0 but with the \s-1UTF-8\s0 flag (only known in Perl &gt;=5.6) guaranteed to be turned off.  This function does not really fit into the module, but it is often handy nevertheless. The function was introduced with libintl-perl version 1.07.</p>
  </dd>
  <dt>
    <strong>select_package \s-1PACKAGE\s0</strong>
  </dt>
  <dd>
    <p>By default, <strong>Locale::Messages</strong> will try to load the \s-1XS\s0 version of the gettext implementation, i. e. <em>Locale::gettext_xs</em>\|(3) and will fall back to the pure Perl implementation <em>Locale::gettext_pp</em>\|(3).  You can override this behavior by passing the string \*(L"gettext_pp\*(R" or \*(L"gettext_xs\*(R" to the function <em>select_package()</em>.  Passing \*(L"gettext_pp\*(R" here, will prefer the pure Perl implementation. You will normally want to use that in a \s-1BEGIN\s0 block of your main script. The function was introduced with libintl-perl version 1.03 and is not part of the standard gettext \s-1API\s0. Beginning with version 1.22 you can pass other package names than \*(L"gettext_pp\*(R" or \*(L"gettext_xs\*(R" and use a completely different backend.  It is the caller's responsability to make sure that the selected package offers the same interface as the two standard packages. One package that offers that functionality is <em>Locale::gettext_dump</em>\|(3pm).</p>
  </dd>
  <dt>
    <strong>nl_putenv \s-1ENVSPEC\s0</strong>
  </dt>
  <dd>
    <p>Resembles the \s-1ANSI\s0 C <em>putenv</em>\|(3) function.  The sole purpose of this function is to work around some ideosyncrasies in the environment processing of Windows systems.  If you want to portably set or unset environment variables, use this function instead of directly manipulating %ENV. The argument <strong>\s-1ENVSPEC\s0</strong> may have three different forms.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>LANGUAGE=fr_CH</strong>
  </dt>
  <dd>
    <p>This would set the environment variable \*(C`LANGUAGE\*(C' to \*(L"fr_CH\*(R".</p>
  </dd>
  <dt>
    <strong>LANGUAGE=</strong>
  </dt>
  <dd>
    <p>Normally, this will set the environment variable \*(C`LANGUAGE\*(C' to an empty string.  Under Windows, however, the environment variable will be deleted instead (and is no longer present in %ENV).  Since within libintl-perl empty environment variables are useless, consider this usage as deprecated.</p>
  </dd>
  <dt>
    <strong>\s-1LANGUAGE\s0</strong>
  </dt>
  <dd>
    <p>This will delete the environment variable <strong>\s-1LANGUAGE\s0</strong>.  If you are familiar with the brain-damaged implementation of <em>putenv</em>\|(3) (resp. <em>_putenv()</em>) in the so-called standard C library of MS-Windows, you may suspect that this is an invalid argument.  This is not the case! Passing a variable name not followed by an equal sign will always delete the variable, no matter which operating system you use.</p>
  </dd>

</dl>
<p>The function returns true for success, and false for failure.  Possible reasons for failure are an invalid syntax or - only under Windows - failure to allocate space for the new environment entry ($! will be set accordingly in this case). Why all this hassle?  The 32-bit versions of MS-DOS (currently Windows 95/98/ME/NT/2000/XP/CE/.NET) maintain two distinct blocks of environment variables per process.  Which block is considered the \*(L"correct\*(R" environment is a compile-time option of the Perl interpreter.  Unfortunately, if you have build the \s-1XS\s0 version <em>Locale::gettext_xs</em>\|(3) under Windows, the underlying library may use a different environment block, and changes you make to %ENV may not be visible to the library. The function <em>nl_putenv()</em> is mostly a funny way of saying     LANGUAGE=some_value but it does its best, to pass this information to the gettext library.  Under other operating systems than Windows, it only operates on %ENV, under Windows it will call the C library function <em>_putenv()</em> (after doing some cleanup to its arguments), before manipulating %ENV. Please note, that you %ENV is updated by <em>nl_putenv()</em> automatically. The function has been introduced in libintl-perl version 1.10.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTANTS</h2>
        <div class="sectioncontent">
<p>You can (maybe) get the same constants from \s-1<em>POSIX\s0</em>\|(3); see there for a detailed description</p>
<dl class='dl-vertical'>
  <dt>
    <strong>\s-1LC_CTYPE\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_NUMERIC\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_TIME\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_COLLATE\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_MONETARY\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_MESSAGES\s0</strong>
  </dt>
  <dd>
    <p>This locale category was the reason that these constants from \s-1<em>POSIX\s0</em>\|(3) were included here.  Even if it was present in your systems C include file <em>locale.h</em>, it was not provided by \s-1<em>POSIX\s0</em>\|(3).  Perl 5.8 and later seems to export the constant if available, although it is not documented in \s-1<em>POSIX\s0</em>\|(3). <em>Locale::Messages</em>\|(3) makes an attempt to guess the value of this category for all systems, and assumes the arbitrary value 1729 otherwise.</p>
  </dd>
  <dt>
    <strong>\s-1LC_ALL\s0</strong>
  </dt>
  <dd>
    <p>If you specify the category <strong>\s-1LC_ALL\s0</strong> as the first argument to <em>POSIX::setlocale()</em>, <em>all</em> locale categories will be affected at once.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORT TAGS</h2>
        <div class="sectioncontent">
<p>The module does not export anything unless explicitely requested. You can import groups of functions via two tags:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>use Locale::Messages (':locale_h')</strong>
  </dt>
  <dd>
    <p>Imports the functions that are normally defined in the C include file <em>locale.h</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <strong></strong><strong>gettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>dgettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>dcgettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>ngettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>dngettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>dcngettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>pgettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>dpgettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>dcpgettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>npgettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>dnpgettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>dcnpgettext()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>textdomain()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>bindtextdomain()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong></strong><strong>bind_textdomain_codeset()</strong><strong></strong>
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>
  <dt>
    <strong>use Locale::Messages (':libintl_h')</strong>
  </dt>
  <dd>
    <p>Imports the locale category constants:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>\s-1LC_CTYPE\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_NUMERIC\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_TIME\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_COLLATE\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_MONETARY\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_MESSAGES\s0</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>\s-1LC_ALL\s0</strong>
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER EXPORTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>select_package \s-1PACKAGE\s0</strong>
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>A complete example:</p><p>    1: use Locale::Messages qw (:locale_h :libintl_h);     2: use POSIX qw (setlocale);     3: setlocale (LC_MESSAGES, &apos;&apos;);     4: textdomain (&apos;my-package&apos;);     5: bindtextdomain (&apos;my-package&apos; =&gt; &apos;/usr/local/share/locale&apos;);     6:     7: print gettext ("Hello world!&#92;n");</p><p>Step by step: Line 1 imports the necessary functions and constants. In line 3 we set the locale for category \s-1LC_MESSAGES\s0 to the default user settings.  For C programs you will often read that \s-1LC_ALL\s0 is the best category here but this will also change the locale for \s-1LC_NUMERIC\s0 and many programs will not work reliably after changing that category in Perl; choose your own poison!</p><p>In line 4 we say that all messages (translations) without an explicit domain specification should be retrieved from the message catalog for the domain 'my-package'.  Line 5 has the effect that the message catalog will be searched under the directory <em>/usr/local/share/locale</em>.</p><p>If the user has selected the locale 'fr_CH', and if the file <em>/usr/local/share/locale/fr_CH/LC_MESSAGES/my-package.mo</em> exists, and if it contains a \s-1GNU\s0 message object file with a translation for the string \*(L"Hello world!&#92;n\*(R", then line 7 will print the French translation (for Switzerland \s-1CH\s0) to \s-1STDOUT\s0.</p><p>The documentation for \s-1GNU\s0 gettext explains how to extract translatable strings from your Perl files and how to create message catalogs.</p><p>Another less portable example: If your system uses the \s-1GNU\s0 libc you should be able to find various files with the name <em>libc.mo</em>, the message catalog for the library itself.  If you have found these files under <em>/usr/share/locale</em>, then you can try the following:</p><p>    use Locale::Messages qw (:locale_h :libintl_h);     use POSIX qw (setlocale);</p><p>    setlocale LC_MESSAGES, "";     textdomain "libc";</p><p>    # The following is actually not needed, since this is     # one of the default search directories.     bindtextdomain libc =&gt; &apos;/usr/share/locale&apos;;     bind_textdomain_codeset libc =&gt; &apos;iso-8859-1&apos;;</p><p>    print gettext ("No such file or directory");</p><p>See <em>Locale::TextDomain</em>\|(3) for much simpler ways.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2002-2013, Guido Flohr &lt;guido@imperia.net&gt;, all rights reserved.  See the source code for details.</p><p>This software is contributed to the Perl community by Imperia (&lt;http://www.imperia.net/&gt;).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Locale::Messages&hellip;</h2>
        <div class="sectioncontent">
<p><em>Locale::TextDomain</em>\|(3pm), <em>Locale::gettext_pp</em>\|(3pm), <em>Encode</em>\|(3pm), <em>perllocale</em>\|(3pm), \s-1<em>POSIX\s0</em>\|(3pm), <em>perl</em>\|(1), <em>gettext</em>\|(1), <em>gettext</em>\|(3)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">POD ERRORS</h2>
        <div class="sectioncontent">
<p>Hey! <strong>The above document had some coding errors, which are explained below:</strong></p>
<dl class='dl-vertical'>
  <dt>
    Around line 957:
  </dt>
  <dd>
    <p>'=item' outside of any '=over'</p>
  </dd>
  <dt>
    Around line 959:
  </dt>
  <dd>
    <p>You forgot a '=back' before '=head1'</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Locale::Maketext::Fuzzy.3pm.html"><span aria-hidden="true">&larr;</span> Locale::Maketext::Fuzzy.3pm: Maketext from already interpolated strings</a></li>
   <li class="next"><a href="Locale::Msgfmt.3pm.html">Locale::Msgfmt.3pm: Compile .po files to .mo files <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gl_tty_signals: How to use gl_get_line() from an external event loop.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="How to use gl_get_line() from an external event loop.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gl_tty_signals (3) manual">
  <meta name="twitter:description" content="How to use gl_get_line() from an external event loop.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtecla-dev-gl_tty_signals-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/gl_tty_signals.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gl_tty_signals (3) manual" />
  <meta property="og:description" content="How to use gl_get_line() from an external event loop." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtecla-dev-gl_tty_signals-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gl_tty_signals<small> (3)</small></h1>
        <p class="lead">How to use gl_get_line() from an external event loop.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/gl_tty_signals.3.html">
      <span itemprop="name">gl_tty_signals: How to use gl_get_line() from an external event loop.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtecla-dev/">
      <span itemprop="name">libtecla-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/gl_tty_signals.3.html">
      <span itemprop="name">gl_tty_signals: How to use gl_get_line() from an external event loop.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;libtecla.h&gt;

int gl_io_mode(GetLine *gl, GlIOMode mode);

int gl_raw_io(GetLine *gl);

int gl_normal_io(GetLine *gl);

int gl_tty_signals(void (*term_handler)(int),
                   void (*susp_handler)(int),
                   void (*cont_handler)(int),
                   void (*size_handler)(int));

void gl_abandon_line(GetLine *gl);

void gl_handle_signal(int signo, GetLine *gl, int ngl);

GlPendingIO gl_pending_io(GetLine *gl);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>gl_get_line()</strong> function, which is documented separately in the <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a></strong> man page, supports two different I/O modes. These are selected by calling the <strong>gl_io_mode()</strong> function.</p>
<pre>
  int gl_io_mode(GetLine *gl, GlIOMode mode);
</pre>
<p>The <strong>mode</strong> argument of this function specifies the new I/O mode, and must be one of the following.</p>
<pre>
  GL_NORMAL_MODE   -  Select the normal blocking-I/O mode.
                      In this mode <strong>gl_get_line()</strong>
                      doesn't return until either an error
                      occurs of the user finishes entering a
                      new line. This mode is the focus of
                      the <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a></strong> man page.

  GL_SERVER_MODE   -  Select non-blocking server I/O mode.
                      In this mode, since non-blocking
                      terminal I/O is used, the entry of
                      each new input line typically requires
                      many calls to <strong>gl_get_line()</strong> from
                      an external I/O-driven event loop.
                      This mode is the focus of this man
                      page.
</pre>
<p>Newly created <strong>GetLine</strong> objects start in normal I/O mode, so to switch to non-blocking server mode requires an initial call to <strong>gl_io_mode()</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SERVER I/O MODE</h2>
        <div class="sectioncontent">
<p>In non-blocking server I/O mode, the application is required to have an event loop which calls <strong>gl_get_line()</strong> whenever the terminal file descriptor can do the type I/O that <strong>gl_get_line()</strong> is waiting for. To determine which type of I/O <strong>gl_get_line()</strong> is waiting for, the application calls the <strong>gl_pending_io()</strong> function.</p>
<pre>
  GlPendingIO gl_pending_io(GetLine *gl);
</pre>
<p>The return value of this function is one of the following two enumerated values.</p>
<pre>
  GLP_READ    -  gl_get_line() is waiting to write a
                 character to the terminal.

  GLP_WRITE   -  gl_get_line() is waiting to read a
                 character from the keyboad.
</pre>
<p>If the application is using either the <strong>select()</strong> or <strong>poll()</strong> system calls to watch for I/O on a group of file descriptors, then it should call the <strong>gl_pending_io()</strong> function before each call to these functions to see which direction of I/O it should tell them to watch for, and configure their arguments accordingly. In the case of the <strong>select()</strong> system call, this means using the <strong>FD_SET()</strong> macro to add the terminal file descriptor either to the set of file descriptors to be watched for readability, or the set to be watched for writability.</p><p>As in normal I/O mode, the return value of <strong>gl_get_line()</strong> is either a pointer to a completed input line, or <strong>NULL</strong>. However, whereas in normal I/O mode a <strong>NULL</strong> return value always means that an error occurred, in non-blocking server mode, <strong>NULL</strong> is also returned when <strong>gl_get_line()</strong> can't read or write to the terminal without blocking. Thus in non-blocking server mode, in order to determine when a <strong>NULL</strong> return value signifies that an error occurred or not, it is necessary to call the <strong>gl_return_status()</strong> function. If this function returns the enumerated value, <strong>GLR_BLOCKED</strong>, as documented in the <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a></strong> man page, this means that <strong>gl_get_line()</strong> is waiting for I/O, and no error has occurred.</p><p>When <strong>gl_get_line()</strong> returns <strong>NULL</strong> and <strong>gl_return_status()</strong> indicates that this is due to blocked terminal I/O, the application should call <strong>gl_get_line()</strong> again when the type of I/O reported by <strong>gl_pending_io()</strong> becomes possible. The <strong>prompt</strong>, <strong>start_line</strong> and <strong>start_pos</strong> arguments of <strong>gl_get_line()</strong> will be ignored on these calls.  If you need to change the prompt of the line that is currently being edited, then you can call the <strong>gl_replace_prompt()</strong> function (documented in the <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a> man page) between calls to</strong> <strong>gl_get_line()</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GIVING UP THE TERMINAL</h2>
        <div class="sectioncontent">
<p>A complication that is unique to non-blocking server mode is that it requires that the terminal be left in raw mode between calls to <strong>gl_get_line()</strong>. If this weren't the case, the external event loop wouldn't be able to detect individual key-presses, and the basic line editing implemented by the terminal driver would clash with the editing provided by <strong>gl_get_line()</strong>. What this means is that any time that the terminal needs to be used for other things than entering a new input line with <strong>gl_get_line()</strong>, it needs to be restored to a usable state. In particular, whenever the process is suspended or terminated, the terminal must be returned to a normal state. If this isn't done, then depending on the characteristics of the shell that was used to invoke the program, the user may end up with a hung terminal. To this end, the <strong>gl_normal_io()</strong> function is provided for switching the terminal back to the state that it was in when raw mode was last established.</p>
<pre>
  int gl_normal_io(GetLine *gl);
</pre>
<p>What this function does is first flush any pending output to the terminal, then move the cursor to the start of the terminal line which follows the end of the incompletely entered input line. At this point it is safe to suspend or terminate the process, and it is safe for the application to read and write to the terminal. To resume entry of the input line, the application should call the <strong>gl_raw_io()</strong> function.</p>
<pre>
  int gl_raw_io(GetLine *gl);
</pre>
<p>This function starts a new line, redisplays the partially completed input line (if any), restores the cursor position within this line to where it was when <strong>gl_normal_io()</strong> was called, then switches back to raw, non-blocking terminal mode ready to continue entry of the input line when <strong>gl_get_line()</strong> is next called.</p><p>Note that in non-blocking server mode, if <strong>gl_get_line()</strong> is called after a call to <strong>gl_normal_io()</strong>, without an intervening call to <strong>gl_raw_io()</strong>, <strong>gl_get_line()</strong> will call <strong>gl_raw_mode()</strong> itself, and the terminal will remain in this mode when <strong>gl_get_line()</strong> returns.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNAL HANDLING</h2>
        <div class="sectioncontent">
<p>In the previous section it was pointed out that in non-blocking server mode, the terminal must be restored to a sane state whenever a signal is received that either suspends or terminates the process. In normal I/O mode, this is done for you by <strong>gl_get_line()</strong>, but in non-blocking server mode, since the terminal is left in raw mode between calls to <strong>gl_get_line()</strong>, this signal handling has to be done by the application. Since there are many signals that can suspend or terminate a process, as well as other signals that are important to <strong>gl_get_line()</strong>, such as the <strong>SIGWINCH</strong> signal, which tells it when the terminal size has changed, the <strong>gl_tty_signals()</strong> function is provided for installing signal handlers for all pertinent signals.</p>
<pre>
  int gl_tty_signals(void (*term_handler)(int),
                     void (*susp_handler)(int),
                     void (*cont_handler)(int),
                     void (*size_handler)(int));
</pre>
<p>What this does is use <strong>gl_get_line()</strong>'s internal list of signals to assign specified signal handlers to groups of signals. The arguments of this function are as follows.</p>
<pre>
  term_handler  -  This is the signal handler that is to be
                   used to trap signals that by default
                   terminate any process that receives
                   them (eg. SIGINT or SIGTERM).

  susp_handler  -  This is the signal handler that is to be
                   used to trap signals that by default
                   suspend any process that receives them,
                   (eg. SIGTSTP or SIGTTOU).

  cont_handler  -  This is the signal handler that is to be
                   used to trap signals that are usually
                   sent when a process resumes after being
                   suspended (usually SIGCONT). Beware that there is
                   nothing to stop a user from sending one of these
                   signals at other times.

  size_handler  -  This signal handler is used to trap
                   signals that are sent to processes when
                   their controlling terminals are resized
                   by the user (eg. SIGWINCH).
</pre>
<p>These arguments can all be the same, if so desired, and you can specify <strong>SIG_IGN</strong> (ignore this signal) or <strong>SIG_DFL</strong> (use the system-provided default signal handler) instead of a function where pertinent. In particular, it is rarely useful to trap <strong>SIGCONT</strong>, so the <strong>cont_handler</strong> argument will usually be <strong>SIG_DFL</strong> or <strong>SIG_IGN</strong>.</p><p>The <strong>gl_tty_signals()</strong> function uses the POSIX <strong>sigaction()</strong> function to install these signal handlers, and it is careful to use the <strong>sa_mask</strong> member of each sigaction structure to ensure that only one of these signals is ever delivered at a time. This guards against different instances of these signal handlers from simultaneously trying to write to common global data, such as a shared <strong>sigsetjmp()</strong> buffer or a signal-received flag.</p><p>The signal handlers that are installed by this function, should call the <strong>gl_handle_signal().</strong></p>
<pre>
  void gl_handle_signal(int signo, GetLine *gl, int ngl);
</pre>
<p>The <strong>signo</strong> argument tells this function which signal it is being asked to respond to, and the <strong>gl</strong> argument should be a pointer to the first element of an array of <strong>ngl</strong> <strong>GetLine</strong> objects. If your application only has one of these objects, just pass its pointer as the <strong>gl</strong> argument and specify <strong>ngl</strong> as <strong>1</strong>.</p><p>Depending on the signal that is being handled, this function does different things.</p><h3>Terminal resize signals (SIGWINCH)</h3>
<p>If the signal indicates that the terminal was resized, then it arranges for the next call to <strong>gl_get_line()</strong> to ask the terminal for its new size and redraw the input line accordingly. In order that <strong>gl_get_line()</strong> be called as soon as possible to do this, <strong>gl_handle_signal()</strong> also arranges that the next call to <strong>gl_pending_io()</strong> will return <strong>GLP_WRITE</strong>. Thus if the application waits for I/O in <strong>select()</strong> or <strong>poll()</strong>, then the application needs to ensure that these functions will be reliably aborted when a signal is caught and handled by the application. More on this below.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Process termination signals.</h2>
        <div class="sectioncontent">
<p>If the signal that was caught is one of those that by default terminates any process that receives it, then <strong>gl_handle_signal()</strong> does the following steps.</p><p>1. First it blocks the delivery of all signals that can be</p>
<pre>
   blocked (ie. <strong>SIGKILL</strong> and <strong>SIGSTOP</strong> can't be blocked)
</pre>
<p>2. Next it calls <strong>gl_normal_io()</strong> for each of the <strong>ngl</strong></p>
<pre>
   <strong>GetLine</strong> objects. Note that this does nothing to any of the
   <strong>GetLine</strong> objects that aren't currently in raw mode.
</pre>
<p>3. Next it sets the signal handler of the signal to its default,</p>
<pre>
   process-termination disposition.
</pre>
<p>4. Next it re-sends the process the signal that was caught.</p><p>5. Finally it unblocks delivery of this signal, which</p>
<pre>
   results in the process being terminated.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Process suspension signals.</h2>
        <div class="sectioncontent">
<p>If the default disposition of the signal is to suspend the process, the same steps are executed as for process termination signals, except that when the process is later resumed, <strong>gl_handle_signal()</strong> continues, and does the following steps.</p><p>6. It re-blocks delivery of the signal.</p><p>7. It reinstates the signal handler of the signal to the one</p>
<pre>
   that was displaced when its default disposition was substituted.
</pre>
<p>8. For any of the <strong>GetLine</strong> objects that were in raw mode when</p>
<pre>
   <strong>gl_handle_signal()</strong> was called, <strong>gl_handle_signal()</strong> then
   calls <strong>gl_raw_io()</strong>, to resume entry of the input lines on
   those terminals.
</pre>
<p>9. Finally, it restores the signal process mask to how it</p>
<pre>
   was when <strong>gl_handle_signal()</strong> was called.
</pre>
<p>Note that the process is suspended or terminated using the original signal that was caught, rather than using the uncatchable <strong>SIGSTOP</strong> and <strong>SIGKILL</strong> signals. This is important, because when a process is suspended or terminated, the parent of the process may wish to use the status value returned by the <strong>wait()</strong> system call to figure out which signal was responsible. In particular, most shells use this information to print a corresponding message to the terminal. Users would be rightly confused if when their process received a <strong>SIGPIPE</strong> signal, the program responded by sending itself a <strong>SIGKILL</strong> signal, and the shell then printed out the provocative statement, "Killed!".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERRUPTING THE EVENT LOOP</h2>
        <div class="sectioncontent">
<p>If a signal is caught and handled when the application's event loop is waiting in <strong>select()</strong> or <strong>poll()</strong>, these functions will be aborted with <strong>errno</strong> set to <strong>EINTR</strong>. When this happens the event loop should call <strong>gl_pending_io()</strong>, before calling <strong>select()</strong> or <strong>poll()</strong> again. It should then arrange for <strong>select()</strong> or <strong>poll()</strong> to wait for the type of I/O that this reports. This is necessary, because any signal handler which calls <strong>gl_handle_signal()</strong>, will frequently change the type of I/O that <strong>gl_get_line()</strong> is waiting for.</p><p>Unfortunately, if a signal arrives between the statements which configure the arguments of <strong>select()</strong> or <strong>poll()</strong> and the calls to these functions, then the signal will not be seen by these functions, which will then not be aborted. If these functions are waiting for keyboard input from the user when the signal is received, and the signal handler arranges to redraw the input line to accomodate a terminal resize or the resumption of the process, then this redisplay will be end up being delayed until the user hits the next key. Apart from puzzling the user, this clearly isn't a serious problem. However there is a way, albeit complicated, to completely avoid this race condition. The following steps illustrate this.</p><p>1. Block all of the signals that <strong>gl_get_line()</strong> catches,</p>
<pre>
   by passing the signal set returned by <strong>gl_list_signals()</strong> to
   <strong>sigprocmask()</strong>.
</pre>
<p>2. Call <strong>gl_pending_io()</strong> and set up the arguments of</p>
<pre>
   <strong>select()</strong> or <strong>poll()</strong> accordingly.
</pre>
<p>3. Call <strong>sigsetjmp()</strong> with a non-zero <strong>savesigs</strong> argument.</p><p>4. Initially this <strong>sigsetjmp()</strong> statement will return zero,</p>
<pre>
   indicating that control isn't resuming there after a matching
   call to <strong>siglongjmp()</strong>.
</pre>
<p>5. Replace all of the handlers of the signals that <strong>gl_get_line()</strong></p>
<pre>
   is configured to catch, with a signal handler that first records
   the number of the signal that was caught, in a file-scope variable,
   then calls <strong>siglongjmp()</strong> with a non-zero value argument, to
   return execution to the above <strong>sigsetjmp()</strong>
   statement.  Registering these signal handlers can conveniently be
   done using the <strong>gl_tty_signals()</strong> function.
</pre>
<p>6. Set the file-scope variable that the above signal handler uses to</p>
<pre>
   record any signal that is caught to -1, so that we can check
   whether a signal was caught by seeing if it contains a valid signal
   number.
</pre>
<p>7. Now unblock the signals that were blocked in step 1. Any signal</p>
<pre>
   that was received by the process in between step 1 and now will
   now be delivered, and trigger our signal handler, as will any
   signal that is received until we block these signals again.
</pre>
<p>8. Now call <strong>select()</strong> or <strong>poll()</strong>.</p><p>9. When <strong>select()</strong> returns, again block the signals that were</p>
<pre>
   unblocked in step 7.
</pre>
<p>If a signal is arrived any time during the above steps, our signal handler will be triggered and cause control to return to the <strong>sigsetjmp()</strong> statement, where this time, <strong>sigsetjmp()</strong> will return non-zero, indicating that a signal was caught. When this happens we simply skip the above block of statements, and continue with the following statements, which are executed regardless of whether or not a signal is caught. Note that when <strong>sigsetjmp()</strong> returns, regardless of why it returned, the process signal mask is returned to how it was when <strong>sigsetjmp()</strong> was called. Thus the following statements are always executed with all of our signals blocked.</p><p>9. Reinstate the signal handlers that were displaced in step 5.</p><p>10. Check wether a signal was caught, by checking the file-scope</p>
<pre>
    variable that the signal handler records signal numbers in.
</pre>
<p>11. If a signal was caught, send this signal to the application</p>
<pre>
    again, and unblock just this signal, so that it invokes the
    signal handler which we just reinstated in step 10.
</pre>
<p>12. Unblock all of the signals that were blocked in step 7.</p><p>Since this is complicated, note that <strong>demo3.c</strong> includes a working example of how to do this. The method used there however, is more general than the above. What it provides is a wrapper function around <strong>select()</strong> which encompasses steps 3 to 11. In this wrapper, rather than use <strong>gl_list_signals()</strong> to figure out the signals to block, and and <strong>gl_tty_signals()</strong> to assign and revert signal handlers, one of its arguments is a <strong>sigset_t</strong> which specifies which signals to block and assign signal handlers to. This function thus doesn't depend on <strong>gl_get_line()</strong> and can thus be used in other situations where race-condition-free signal handling is required.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNALS CAUGHT BY GL_GET_LINE</h2>
        <div class="sectioncontent">
<p>Since the application is expected to handle signals in non-blocking server mode, <strong>gl_get_line()</strong> doesn't attempt to duplicate this when it is being called. If one of the signals that it is configured to catch is sent to the application while <strong>gl_get_line()</strong> is being called, <strong>gl_get_line()</strong> reinstates the caller's signal handlers, then just before returning, re-sends the signal to the process to let the application's signal handler handle it. If the process isn't terminated by this signal, <strong>gl_get_line()</strong> returns <strong>NULL</strong>, and a following call to <strong>gl_return_status()</strong> returns the enumerated value <strong>GLR_SIGNAL</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ABORTING LINE INPUT</h2>
        <div class="sectioncontent">
<p>Often, rather than letting it terminate the process, applications respond to the SIGINT user-interrupt signal by aborting the current input line. The way to do this in non-blocking server-I/O mode is to not call <strong>gl_handle_signal()</strong> when this signal is caught, but instead to call the <strong>gl_abandon_line()</strong>.</p>
<pre>
  void gl_abandon_line(GetLine *gl);
</pre>
<p>This function arranges that when <strong>gl_get_line()</strong> is next called, it first flushes any pending output to the terminal, then discardes the current input line, outputs a new prompt on the next line, and finally starts accepting input of a new input line from the user.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNAL SAFE FUNCTIONS</h2>
        <div class="sectioncontent">
<p>Provided that certain rules are followed, the following functions can have been written to be safely callable from signal handlers. Other functions in this library should not be called from signal handlers.</p>
<pre>
  gl_normal_io()
  gl_raw_io()
  gl_handle_signal()
  gl_abandon_line()
</pre>
<p>In order for this to be true, all signal handlers that call these functions must be registered in such a way that only one instance of any one of them can be running at one time. The way to do this is to use the POSIX <strong>sigaction()</strong> function to register all signal handlers, and when doing this, use the <strong>sa_mask</strong> member of the corresponding sigaction structure, to indicate that all of the signals who's handlers invoke the above functions, should be blocked when the current signal is being handled. This prevents two signal handlers from operating on a <strong>GetLine</strong> object at the same time.</p><p>To prevent signal handlers from accessing a <strong>GetLine</strong> object while <strong>gl_get_line()</strong> or any of its associated public functions are operating on it, all public functions associated with <strong>gl_get_line()</strong>, including <strong>gl_get_line()</strong> itself, temporarily block the delivery of signals when they are accessing <strong>GetLine</strong> objects. Beware that the only signals that they block are the signals that <strong>gl_get_line()</strong> is currently configured to catch, so be sure that if you call any of the above functions from signal handlers, that the signals that these handlers are assigned to are configured to be caught by <strong>gl_get_line()</strong> (see <strong>gl_trap_signal()</strong>).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USING TIMEOUTS TO POLL</h2>
        <div class="sectioncontent">
<p>If instead of using <strong>select()</strong> or <strong>poll()</strong> to wait for I/O, your application just needs to get out of <strong>gl_get_line()</strong> periodically to briefly do something else before returning to accept input from the user, this can be done in non-blocking server mode by using the <strong>gl_inactivity_timeout()</strong> function (see <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a></strong>), to specify that a callback function that returns <strong>GLTO_CONTINUE</strong> should be called whenever <strong>gl_get_line()</strong> has been waiting for I/O for more than a specified amount of time.</p><p>When this callback is triggered, <strong>gl_get_line()</strong> will return <strong>NULL</strong>, and a following call to <strong>gl_return_status()</strong> will return <strong>GLR_BLOCKED</strong>.</p><p>Beware that <strong>gl_get_line()</strong> won't return until the user hasn't typed a key for the specified interval, so if the interval is long, and the user keeps typing, <strong>gl_get_line()</strong> may not return for a while. In other words there is no guarantee that it will return in the time specified.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SERVER DEMO PROGRAM</h2>
        <div class="sectioncontent">
<p>The <strong>demo3</strong> program that is distributed with the library, provides a working example of how to use non-blocking server I/O mode in a real program. As far as the user is concerned, this program operates identically to the main demo program (called <strong>demo</strong>), except that whereas the main demo program uses the normal blocking I/O mode, <strong>demo3</strong> using non-blocking I/O and an external event loop. The source code can be found in <strong>demo3.c</strong>, and the comments therein explain the various steps.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<pre>
libtecla.a      -    The tecla library
libtecla.h      -    The tecla header file.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO gl_tty_signals&hellip;</h2>
        <div class="sectioncontent">

<pre>
<a href="../man3/libtecla.3.html"><strong>libtecla</strong>(3)</a>, <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a>, <a href="../man7/tecla.7.html"><strong>tecla</strong>(7)</a>, <a href="../man3/ef_expand_file.3.html"><strong>ef_expand_file</strong>(3)</a>,
<a href="../man3/cpl_complete_word.3.html"><strong>cpl_complete_word</strong>(3)</a>, <a href="../man3/pca_lookup_file.3.html"><strong>pca_lookup_file</strong>(3)</a>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Martin Shepherd  (mcs@astro.caltech.edu)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gl_trap_signal.3.html"><span aria-hidden="true">&larr;</span> gl_trap_signal.3: Allow the user to compose an input line</a></li>
   <li class="next"><a href="gl_watch_fd.3.html">gl_watch_fd.3: Allow the user to compose an input line <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

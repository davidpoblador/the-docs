<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LW2: Perl http library version 2.5</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl http library version 2.5">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="LW2 (3perl) manual">
  <meta name="twitter:description" content="Perl http library version 2.5">
  <meta name="twitter:image" content="https://www.carta.tech/images/libwhisker2-perl-LW2-3perl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3perl/LW2.3perl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="LW2 (3perl) manual" />
  <meta property="og:description" content="Perl http library version 2.5" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libwhisker2-perl-LW2-3perl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">LW2<small> (3perl)</small></h1>
        <p class="lead">Perl http library version 2.5</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3perl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3perl/LW2.3perl.html">
      <span itemprop="name">LW2: Perl http library version 2.5</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libwhisker2-perl/">
      <span itemprop="name">libwhisker2-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3perl/LW2.3perl.html">
      <span itemprop="name">LW2: Perl http library version 2.5</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>use \s-1LW2\s0;</p><p>require '\s-1LW2\s0.pm';</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Libwhisker is a Perl library useful for \s-1HTTP\s0 testing scripts.  It contains a pure-Perl reimplementation of functionality found in the \*(C`LWP\*(C', \*(C`URI\*(C', \*(C`Digest::MD5\*(C', \*(C`Digest::MD4\*(C', \*(C`Data::Dumper\*(C', \*(C`Authen::NTLM\*(C', \*(C`HTML::Parser\*(C', \*(C`HTML::FormParser\*(C', \*(C`CGI::Upload\*(C', \*(C`MIME::Base64\*(C', and \*(C`GetOpt::Std\*(C' modules.</p><p>Libwhisker is designed to be portable (a single perl file), fast (general benchmarks show libwhisker is faster than \s-1LWP\s0), and flexible (great care was taken to ensure the library does exactly what you want to do, even if it means breaking the protocol).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The following are the functions contained in Libwhisker:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>auth_brute_force</strong>
  </dt>
  <dd>
    <p>Params: $auth_method, &#92;%req, $user, &#92;@passwords [, $domain, $fail_code ] Return: $first_valid_password, undef if error/none found Perform a \s-1HTTP\s0 authentication brute force against a server (host and \s-1URI\s0 defined in %req).  It will try every password in the password array for the given user.  The first password (in conjunction with the given user) that doesn't return \s-1HTTP\s0 401 is returned (and the brute force is stopped at that point).  You should retry the request with the given password and double-check that you got a useful \s-1HTTP\s0 return code that indicates successful authentication (200, 302), and not something a bit more abnormal (407, 500, etc).  $domain is optional, and is only used for \s-1NTLM\s0 auth. Note: set up any proxy settings and proxy auth in %req before calling this function. You can brute-force proxy authentication by setting up the target proxy as proxy_host and proxy_port in %req, using an arbitrary host and uri (preferably one that is reachable upon successful proxy authorization), and setting the $fail_code to 407.  The $auth_method passed to this function should be a proxy-based one ('proxy-basic', 'proxy-ntlm', etc). if your server returns something other than 401 upon auth failure, then set $fail_code to whatever is returned (and it needs to be something *different* than what is received on auth success, or this function won't be able to tell the difference).</p>
  </dd>
  <dt>
    <strong>auth_unset</strong>
  </dt>
  <dd>
    <p>Params: &#92;%req Return: nothing (modifies %req) Modifes %req to disable all authentication (regular and proxy). Note: it only removes the values set by <em>auth_set()</em>.  Manually-defined [Proxy-]Authorization headers will also be deleted (but you shouldn't be using the auth_* functions if you're manually handling your own auth...)</p>
  </dd>
  <dt>
    <strong>auth_set</strong>
  </dt>
  <dd>
    <p>Params: $auth_method, &#92;%req, $user, $password [, $domain] Return: nothing (modifies %req) Modifes %req to use the indicated authentication info. Auth_method can be: 'basic', 'proxy-basic', 'ntlm', 'proxy-ntlm'. Note: this function may not necessarily set any headers after being called. Also, proxy-ntlm with \s-1SSL\s0 is not currently supported.</p>
  </dd>
  <dt>
    <strong>cookie_new_jar</strong>
  </dt>
  <dd>
    <p>Params: none Return: $jar Create a new cookie jar, for use with the other functions.  Even though the jar is technically just a hash, you should still use this function in order to be future-compatible (should the jar format change).</p>
  </dd>
  <dt>
    <strong>cookie_read</strong>
  </dt>
  <dd>
    <p>Params: $jar, &#92;%response [, &#92;%request, $reject ] Return: $num_of_cookies_read Read in cookies from an %response hash, and put them in $jar. Notice: cookie_read uses internal magic done by http_do_request in order to read cookies regardless of 'Set-Cookie[2]' header appearance. If the optional %request hash is supplied, then it will be used to calculate default host and path values, in case the cookie doesn't specify them explicitly.  If $reject is set to 1, then the %request hash values are used to calculate and reject cookies which are not appropriate for the path and domains of the given request.</p>
  </dd>
  <dt>
    <strong>cookie_parse</strong>
  </dt>
  <dd>
    <p>Params: $jar, $cookie [, $default_domain, $default_path, $reject ] Return: nothing Parses the cookie into the various parts and then sets the appropriate values in the cookie $jar. If the cookie value is blank, it will delete it from the $jar.  See the 'docs/cookies.txt' document for a full explanation of how Libwhisker parses cookies and what \s-1RFC\s0 aspects are supported. The optional $default_domain value is taken literally.  Values with no leading dot (e.g. 'www.host.com') are considered to be strict hostnames and will only match the identical hostname.  Values with leading dots (e.g. '.host.com') are treated as sub-domain matches for a single domain level. If the cookie does not indicate a domain, and a $default_domain is not provided, then the cookie is considered to match all domains/hosts. The optional $default_path is used when the cookie does not specify a path. $default_path must be absolute (start with '/'), or it will be ignored.  If the cookie does not specify a path, and $default_path is not provided, then the default value '/' will be used. Set $reject to 1 if you wish to reject cookies based upon the provided $default_domain and $default_path.  Note that $default_domain and $default_path must be specified for $reject to actually do something meaningful.</p>
  </dd>
  <dt>
    <strong>cookie_write</strong>
  </dt>
  <dd>
    <p>Params: $jar, &#92;%request, $override Return: nothing Goes through the given $jar and sets the Cookie header in %req pending the correct domain and path.  If $override is true, then the secure, domain and path restrictions of the cookies are ignored and all cookies are essentially included. Notice: cookie expiration is currently not implemented.  \s-1URL\s0 restriction comparision is also case-insensitive.</p>
  </dd>
  <dt>
    <strong>cookie_get</strong>
  </dt>
  <dd>
    <p>Params: $jar, $name Return: @elements Fetch the named cookie from the $jar, and return the components.  The returned items will be an array in the following order: value, domain, path, expire, secure value  = cookie value, should always be non-empty string domain = domain root for cookie, can be undefined path   = \s-1URL\s0 path for cookie, should always be a non-empty string expire = undefined (depreciated, but exists for backwards-compatibility) secure = whether or not the cookie is limited to HTTPs; value is 0 or 1</p>
  </dd>
  <dt>
    <strong>cookie_get_names</strong>
  </dt>
  <dd>
    <p>Params: $jar Return: @names Fetch all the cookie names from the jar, which then let you <em>cooke_get()</em> them individually.</p>
  </dd>
  <dt>
    <strong>cookie_get_valid_names</strong>
  </dt>
  <dd>
    <p>Params: $jar, $domain, $url, $ssl Return: @names Fetch all the cookie names from the jar which are valid for the given $domain, $url, and $ssl values.  $domain should be string scalar of the target host domain ('www.example.com', etc.).  $url should be the absolute \s-1URL\s0 for the page ('/index.html', '/cgi-bin/foo.cgi', etc.).  $ssl should be 0 for non-secure cookies, or 1 for all (secure and normal) cookies.  The return value is an array of names compatible with <em>cookie_get()</em>.</p>
  </dd>
  <dt>
    <strong>cookie_set</strong>
  </dt>
  <dd>
    <p>Params: $jar, $name, $value, $domain, $path, $expire, $secure Return: nothing Set the named cookie with the provided values into the %jar.  $name is required to be a non-empty string.  $value is required, and will delete the named cookie from the $jar if it is an empty string.  $domain and $path can be strings or undefined.  $expire is ignored (but exists for backwards-compatibility).  $secure should be the numeric value of 0 or 1.</p>
  </dd>
  <dt>
    <strong>crawl_new</strong>
  </dt>
  <dd>
    <p>Params: $START, $MAX_DEPTH, &#92;%request_hash [, &#92;%tracking_hash ] Return: $crawl_object The <em>crawl_new()</em> functions initializes a crawl object (hash) to the default values, and then returns it for later use by <em>crawl()</em>.  $START is the starting \s-1URL\s0 (in the form of 'http://www.host.com/url'), and \s-1MAX_DEPTH\s0 is the maximum number of levels to crawl (the \s-1START\s0 \s-1URL\s0 counts as 1, so a value of 2 will crawl the \s-1START\s0 \s-1URL\s0 and all URLs found on that page).  The request_hash is a standard initialized request hash to be used for requests; you should set any authentication information or headers in this hash in order for the crawler to use them.  The optional tracking_hash lets you supply a hash for use in tracking \s-1URL\s0 results (otherwise <em>crawl_new()</em> will allocate a new anon hash).</p>
  </dd>
  <dt>
    <strong>crawl</strong>
  </dt>
  <dd>
    <p>Params: $crawl_object [, $START, $MAX_DEPTH ] Return: $count [ undef on error ] The heart of the crawl package.  Will perform an \s-1HTTP\s0 crawl on the specified \s-1HOST\s0, starting at \s-1START\s0 \s-1URI\s0, proceeding up to \s-1MAX_DEPTH\s0. Crawl_object needs to be the variable returned by <em>crawl_new()</em>.  You can also indirectly call <em>crawl()</em> via the crawl_object itself:</p>
<pre>
        $crawl_object-&gt;{crawl}-&gt;($START,$MAX_DEPTH)
</pre>
<p>Returns the number of URLs actually crawled (not including those skipped).</p>
  </dd>
  <dt>
    <strong>dump</strong>
  </dt>
  <dd>
    <p>Params: $name, &#92;@array [, $name, &#92;%hash, $name, &#92;$scalar ] Return: $code [ undef on error ] The dump function will take the given $name and data reference, and will create an \s-1ASCII\s0 perl code representation suitable for eval'ing later to recreate the same structure.  $name is the name of the variable that it will be saved as.  Example:  $output = LW2::dump(&apos;request&apos;,&#92;%request); \s-1NOTE:\s0 <em>dump()</em> creates anonymous structures under the name given.  For example, if you dump the hash %hin under the name 'hin', then when you eval the dumped code you will need to use %$hin, since $hin is now a *reference* to a hash.</p>
  </dd>
  <dt>
    <strong>dump_writefile</strong>
  </dt>
  <dd>
    <p>Params: $file, $name, &#92;@array [, $name, &#92;%hash, $name, &#92;@scalar ] Return: 0 if success; 1 if error This calls <em>dump()</em> and saves the output to the specified $file. Note: \s-1LW\s0 does not checking on the validity of the file name, it's creation, or anything of the sort.  Files are opened in overwrite mode.</p>
  </dd>
  <dt>
    <strong>encode_base64</strong>
  </dt>
  <dd>
    <p>Params: $data [, $eol] Return: $b64_encoded_data This function does Base64 encoding.  If the binary MIME::Base64 module is available, it will use that; otherwise, it falls back to an internal perl version.  The perl version carries the following copyright:  Copyright 1995-1999 Gisle Aas &lt;gisle@aas.no&gt; \s-1NOTE:\s0 the $eol parameter will be inserted every 76 characters.  This is used to format the data for output on a 80 character wide terminal.</p>
  </dd>
  <dt>
    <strong>decode_base64</strong>
  </dt>
  <dd>
    <p>Params: $data Return: $b64_decoded_data A perl implementation of base64 decoding.  The perl code for this function was actually taken from an older MIME::Base64 perl module, and bears the following copyright: Copyright 1995-1999 Gisle Aas &lt;gisle@aas.no&gt;</p>
  </dd>
  <dt>
    <strong>encode_uri_hex</strong>
  </dt>
  <dd>
    <p>Params: $data Return: $result This function encodes every character (except the / character) with normal \s-1URL\s0 hex encoding.</p>
  </dd>
  <dt>
    <strong>encode_uri_randomhex</strong>
  </dt>
  <dd>
    <p>Params: $data Return: $result This function randomly encodes characters (except the / character) with normal \s-1URL\s0 hex encoding.</p>
  </dd>
  <dt>
    <strong>encode_uri_randomcase</strong>
  </dt>
  <dd>
    <p>Params: $data Return: $result This function randomly changes the case of characters in the string.</p>
  </dd>
  <dt>
    <strong>encode_unicode</strong>
  </dt>
  <dd>
    <p>Params: $data Return: $result This function converts a normal string into Windows unicode format (non-overlong or anything fancy).</p>
  </dd>
  <dt>
    <strong>decode_unicode</strong>
  </dt>
  <dd>
    <p>Params: $unicode_string Return: $decoded_string This function attempts to decode a unicode (\s-1UTF-8\s0) string by converting it into a single-byte-character string.  Overlong characters are converted to their standard characters in place; non-overlong (aka multi-byte) characters are substituted with the 0xff; invalid encoding characters are left as-is. Note: this function is useful for dealing with the various unicode exploits/vulnerabilities found in web servers; it is *not* good for doing actual \s-1UTF-8\s0 parsing, since characters over a single byte are basically dropped/replaced with a placeholder.</p>
  </dd>
  <dt>
    <strong>encode_anti_ids</strong>
  </dt>
  <dd>
    <p>Params: &#92;%request, $modes Return: nothing encode_anti_ids computes the proper anti-ids encoding/tricks specified by $modes, and sets up %hin in order to use those tricks. Valid modes are (the mode numbers are the same as those found in whisker 1.4):</p>
<dl class='dl-vertical'>
  <dt>
    1 Encode some of the characters via normal \s-1URL\s0 encoding
  </dt>
  <dd>
    
  </dd>
  <dt>
    2 Insert directory self-references (/./)
  </dt>
  <dd>
    
  </dd>
  <dt>
    3 Premature \s-1URL\s0 ending (make it appear the request line is done)
  </dt>
  <dd>
    
  </dd>
  <dt>
    5 Add a fake \s-1URL\s0 parameter
  </dt>
  <dd>
    
  </dd>
  <dt>
    6 Use a tab instead of a space as a request spacer
  </dt>
  <dd>
    
  </dd>
  <dt>
    7 Change the case of the \s-1URL\s0 (works against Windows and Novell)
  </dt>
  <dd>
    
  </dd>
  <dt>
    8 Change normal seperators ('/') to Windows version ('&#92;')
  </dt>
  <dd>
    
  </dd>
  <dt>
    9 Session splicing [\s-1NOTE:\s0 not currently available]
  </dt>
  <dd>
    
  </dd>
  <dt>
    A Use a carriage return (0x0d) as a request spacer
  </dt>
  <dd>
    
  </dd>
  <dt>
    B Use binary value 0x0b as a request spacer
  </dt>
  <dd>
    
  </dd>

</dl>
<p>You can set multiple modes by setting the string to contain all the modes desired; i.e. $modes=\*(L"146\*(R" will use modes 1, 4, and 6.</p>
  </dd>
  <dt>
    <strong>\s-1FORMS\s0 \s-1FUNCTIONS\s0</strong>
  </dt>
  <dd>
    <p>The goal is to parse the variable, human-readable \s-1HTML\s0 into concrete structures useable by your program.  The forms functions does do a good job at making these structures, but I will admit: they are not exactly simple, and thus not a cinch to work with.  But then again, representing something as complex as a \s-1HTML\s0 form is not a simple thing either.  I think the results are acceptable for what's trying to be done.  Anyways... Forms are stored in perl hashes, with elements in the following format:  $form{&apos;element_name&apos;}=@([ &apos;type&apos;, &apos;value&apos;, @params ]) Thus every element in the hash is an array of anonymous arrays.  The first array value contains the element type (which is 'select', 'textarea', 'button', or an 'input' value of the form 'input-text', 'input-hidden', 'input-radio', etc). The second value is the value, if applicable (it could be undef if no value was specified).  Note that select elements will always have an undef value\*(--the actual values are in the subsequent options elements. The third value, if defined, is an anonymous array of additional tag parameters found in the element (like 'onchange=\*(L"blah\*(R"', 'size=\*(L"20\*(R"', 'maxlength=\*(L"40\*(R"', 'selected', etc). The array does contain one special element, which is stored in the hash under a \s-1NULL\s0 character (\*(L"&#92;0\*(R") key.  This element is of the format:  $form{"&#92;0"}=[&apos;name&apos;, &apos;method&apos;, &apos;action&apos;, @parameters]; The element is an anonymous array that contains strings of the form's name, method, and action (values can be undef), and a @parameters array similar to that found in normal elements (above). Accessing individual values stored in the form hash becomes a test of your perl referencing skills.  Hint: to access the 'value' of the third element named 'choices', you would need to do:  $form{&apos;choices&apos;}-&gt;[2]-&gt;[1]; The '[2]' is the third element (normal array starts with 0), and the actual value is '[1]' (the type is '[0]', and the parameter array is '[2]').</p>
  </dd>
  <dt>
    <strong>forms_read</strong>
  </dt>
  <dd>
    <p>Params: &#92;$html_data Return: &#92;@found_forms This function parses the given $html_data into libwhisker form hashes. It returns a reference to an array of hash references to the found forms.</p>
  </dd>
  <dt>
    <strong>forms_write</strong>
  </dt>
  <dd>
    <p>Params: &#92;%form_hash Return: $html_of_form [undef on error] This function will take the given %form hash and compose a generic \s-1HTML\s0 representation of it, formatted with tabs and newlines in order to make it neat and tidy for printing. Note: this function does *not* escape any special characters that were embedded in the element values.</p>
  </dd>
  <dt>
    <strong>html_find_tags</strong>
  </dt>
  <dd>
    <p>Params: &#92;$data, &#92;&callback_function [, $xml_flag, $funcref, &#92;%tag_map] Return: nothing html_find_tags parses a piece of \s-1HTML\s0 and 'extracts' all found tags, passing the info to the given callback function.  The callback function must accept two parameters: the current tag (as a scalar), and a hash ref of all the tag's elements. For example, the tag &lt;a href=\*(L"/file\*(R"&gt; will pass 'a' as the current tag, and a hash reference which contains {'href'=&gt;\*(L"/file\*(R"}. The xml_flag, when set, causes the parser to do some extra processing and checks to accomodate \s-1XML\s0 style tags such as &lt;tag foo=\*(L"bar\*(R"/&gt;. The optional %tagmap is a hash of lowercase tag names.  If a tagmap is supplied, then the parser will only call the callback function if the tag name exists in the tagmap. The optional $funcref variable is passed straight to the callback function, allowing you to pass flags or references to more complex structures to your callback function.</p>
  </dd>
  <dt>
    <strong>html_find_tags_rewrite</strong>
  </dt>
  <dd>
    <p>Params: $position, $length, $replacement Return: nothing <em>html_find_tags_rewrite()</em> is used to 'rewrite' an \s-1HTML\s0 stream from within an <em>html_find_tags()</em> callback function.  In general, you can think of html_find_tags_rewrite working as: substr(\s-1DATA\s0, $position, $length) = $replacement Where \s-1DATA\s0 is the current \s-1HTML\s0 string the html parser is using. The reason you need to use this function and not <em>substr()</em> is because a few internal parser pointers and counters need to be adjusted to accomodate the changes. If you want to remove a piece of the string, just set the replacement to an empty string ('').  If you wish to insert a string instead of overwrite, just set $length to 0; your string will be inserted at the indicated $position.</p>
  </dd>
  <dt>
    <strong>html_link_extractor</strong>
  </dt>
  <dd>
    <p>Params: &#92;$html_data Return: @urls The <em>html_link_extractor()</em> function uses the internal crawl tests to extract all the \s-1HTML\s0 links from the given \s-1HTML\s0 data stream. Note: <em>html_link_extractor()</em> does not unique the returned array of discovered links, nor does it attempt to remove javascript links or make the links absolute.  It just extracts every raw link from the \s-1HTML\s0 stream and returns it.  You'll have to do your own post-processing.</p>
  </dd>
  <dt>
    <strong>http_new_request</strong>
  </dt>
  <dd>
    <p>Params: %parameters Return: &#92;%request_hash This function basically 'objectifies' the creation of whisker request hash objects.  You would call it like:  $req = http_new_request( host=&gt;&apos;www.example.com&apos;, uri=&gt;&apos;/&apos; ) where 'host' and 'uri' can be any number of {whisker} hash control values (see http_init_request for default list).</p>
  </dd>
  <dt>
    <strong>http_new_response</strong>
  </dt>
  <dd>
    <p>Params: [none] Return: &#92;%response_hash This function basically 'objectifies' the creation of whisker response hash objects.  You would call it like:         $resp = http_new_response()</p>
  </dd>
  <dt>
    <strong>http_init_request</strong>
  </dt>
  <dd>
    <p>Params: &#92;%request_hash_to_initialize Return: Nothing (modifies input hash) Sets default values to the input hash for use.  Sets the host to 'localhost', port 80, request \s-1URI\s0 '/', using \s-1HTTP\s0 1.1 with \s-1GET\s0 method.  The timeout is set to 10 seconds, no proxies are defined, and all \s-1URI\s0 formatting is set to standard \s-1HTTP\s0 syntax.  It also sets the Connection (Keep-Alive) and User-Agent headers. \s-1NOTICE\s0!!  It's important to use http_init_request before calling http_do_request, or http_do_request might puke.  Thus, a special magic value is placed in the hash to let http_do_request know that the hash has been properly initialized.  If you really must 'roll your own' and not use http_init_request before you call http_do_request, you will at least need to set the \s-1MAGIC\s0 value (amongst other things).</p>
  </dd>
  <dt>
    <strong>http_do_request</strong>
  </dt>
  <dd>
    <p>Params: &#92;%request, &#92;%response [, &#92;%configs] Return: &gt;=1 if error; 0 if no error (also modifies response hash) *THE* core function of libwhisker.  http_do_request actually performs the \s-1HTTP\s0 request, using the values submitted in %request, and placing result values in %response.  This allows you to resubmit %request in subsequent requests (%response is automatically cleared upon execution).  You can submit 'runtime' config directives as %configs, which will be spliced into $hin{whisker}-&gt;{} before anything else.  That means you can do: LW2::http_do_request(&#92;%req,&#92;%resp,{'uri'=&gt;'/cgi-bin/'}); This will set $req{whisker}-&gt;{'uri'}='/cgi-bin/' before execution, and provides a simple shortcut (note: it does modify %req). This function will also retry any requests that bomb out during the transaction (but not during the connecting phase).  This is controlled by the {whisker}-&gt;{retry} value.  Also note that the returned error message in hout is the *last* error received.  All retry errors are put into {whisker}-&gt;{retry_errors}, which is an anonymous array. Also note that all \s-1NTLM\s0 auth logic is implemented in <em>http_do_request()</em>. \s-1NTLM\s0 requires multiple requests in order to work correctly, and so this function attempts to wrap that and make it all transparent, so that the final end result is what's passed to the application. This function will return 0 on success, 1 on \s-1HTTP\s0 protocol error, and 2 on non-recoverable network connection error (you can retry error 1, but error 2 means that the server is totally unreachable and there's no point in retrying).</p>
  </dd>
  <dt>
    <strong>http_req2line</strong>
  </dt>
  <dd>
    <p>Params: &#92;%request, $uri_only_switch Return: $request req2line is used internally by http_do_request, as well as provides a convienient way to turn a %request configuration into an actual \s-1HTTP\s0 request line.  If $switch is set to 1, then the returned $request will be the \s-1URI\s0 only ('/requested/page.html'), versus the entire \s-1HTTP\s0 request ('\s-1GET\s0 /requested/page.html \s-1HTTP/1\s0.0&#92;n&#92;n').  Also, if the 'full_request_override' whisker config variable is set in %hin, then it will be returned instead of the constructed \s-1URI\s0.</p>
  </dd>
  <dt>
    <strong>http_resp2line</strong>
  </dt>
  <dd>
    <p>Params: &#92;%response Return: $response http_resp2line provides a convienient way to turn a %response hash back into the original \s-1HTTP\s0 response line.</p>
  </dd>
  <dt>
    <strong>http_fixup_request</strong>
  </dt>
  <dd>
    <p>Params: $hash_ref Return: Nothing This function takes a %hin hash reference and makes sure the proper headers exist (for example, it will add the Host: header, calculate the Content-Length: header for \s-1POST\s0 requests, etc).  For standard requests (i.e. you want the request to be \s-1HTTP\s0 RFC-compliant), you should call this function right before you call http_do_request.</p>
  </dd>
  <dt>
    <strong>http_reset</strong>
  </dt>
  <dd>
    <p>Params: Nothing Return: Nothing The http_reset function will walk through the %http_host_cache, closing all open sockets and freeing \s-1SSL\s0 resources.  It also clears out the host cache in case you need to rerun everything fresh. Note: if you just want to close a single connection, and you have a copy of the %request hash you used, you should use the <em>http_close()</em> function instead.</p>
  </dd>
  <dt>
    <strong>ssl_is_available</strong>
  </dt>
  <dd>
    <p>Params: Nothing Return: $boolean [, $lib_name, $version] The <em>ssl_is_available()</em> function will inform you whether \s-1SSL\s0 requests are allowed, which is dependant on whether the appropriate \s-1SSL\s0 libraries are installed on the machine.  In scalar context, the function will return 1 or 0.  In array context, the second element will be the \s-1SSL\s0 library name that is currently being used by \s-1LW2\s0, and the third elment will be the \s-1SSL\s0 library version number. Elements two and three (name and version) will be undefined if called in array context and no \s-1SSL\s0 libraries are available.</p>
  </dd>
  <dt>
    <strong>http_read_headers</strong>
  </dt>
  <dd>
    <p>Params: $stream, &#92;%in, &#92;%out Return: $result_code, $encoding, $length, $connection Read \s-1HTTP\s0 headers from the given stream, storing the results in %out.  On success, $result_code will be 1 and $encoding, $length, and $connection will hold the values of the Transfer-Encoding, Content-Length, and Connection headers, respectively.  If any of those headers are not present, then it will have an 'undef' value.  On an error, the $result_code will be 0 and $encoding will contain an error message. This function can be used to parse both request and response headers. Note: if there are multiple Transfer-Encoding, Content-Length, or Connection headers, then only the last header value is the one returned by the function.</p>
  </dd>
  <dt>
    <strong>http_read_body</strong>
  </dt>
  <dd>
    <p>Params: $stream, &#92;%in, &#92;%out, $encoding, $length Return: 1 on success, 0 on error (and sets $hout-&gt;{whisker}-&gt;{error}) Read the body from the given stream, placing it in $out-&gt;{whisker}-&gt;{data}. Handles chunked encoding.  Can be used to read \s-1HTTP\s0 (\s-1POST\s0) request or \s-1HTTP\s0 response bodies.  $encoding parameter should be lowercase encoding type. \s-1NOTE:\s0 $out-&gt;{whisker}-&gt;{data} is erased/cleared when this function is called, leaving {data} to just contain this particular \s-1HTTP\s0 body.</p>
  </dd>
  <dt>
    <strong>http_construct_headers</strong>
  </dt>
  <dd>
    <p>Params: &#92;%in Return: $data This function assembles the headers in the given hash into a data string.</p>
  </dd>
  <dt>
    <strong>http_close</strong>
  </dt>
  <dd>
    <p>Params: &#92;%request Return: nothing This function will close any open streams for the given request. Note: in order for <em>http_close()</em> to find the right connection, all original host/proxy/port parameters in %request must be the exact same as when the original request was made.</p>
  </dd>
  <dt>
    <strong>http_do_request_timeout</strong>
  </dt>
  <dd>
    <p>Params: &#92;%request, &#92;%response, $timeout Return: $result This function is identical to <em>http_do_request()</em>, except that it wraps the entire request in a timeout wrapper.  $timeout is the number of seconds to allow for the entire request to be completed. Note: this function uses <em>alarm()</em> and signals, and thus will only work on Unix-ish platforms.  It should be safe to call on any platform though.</p>
  </dd>
  <dt>
    <strong>md5</strong>
  </dt>
  <dd>
    <p>Params: $data Return: $hex_md5_string This function takes a data scalar, and composes a \s-1MD5\s0 hash of it, and returns it in a hex ascii string.  It will use the fastest \s-1MD5\s0 function available.</p>
  </dd>
  <dt>
    <strong>md4</strong>
  </dt>
  <dd>
    <p>Params: $data Return: $hex_md4_string This function takes a data scalar, and composes a \s-1MD4\s0 hash of it, and returns it in a hex ascii string.  It will use the fastest \s-1MD4\s0 function available.</p>
  </dd>
  <dt>
    <strong>multipart_set</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash, $param_name, $param_value Return: nothing This function sets the named parameter to the given value within the supplied multipart hash.</p>
  </dd>
  <dt>
    <strong>multipart_get</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash, $param_name Return: $param_value, undef on error This function retrieves the named parameter to the given value within the supplied multipart hash.  There is a special case where the named parameter is actually a file\*(--in which case the resulting value will be \*(L"&#92;0FILE\*(R".  In general, all special values will be prefixed with a \s-1NULL\s0 character.  In order to get a file's info, use <em>multipart_getfile()</em>.</p>
  </dd>
  <dt>
    <strong>multipart_setfile</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash, $param_name, $file_path [, $filename] Return: undef on error, 1 on success \s-1NOTE:\s0 this function does not actually add the contents of $file_path into the %multi_hash; instead, <em>multipart_write()</em> inserts the content when generating the final request.</p>
  </dd>
  <dt>
    <strong>multipart_getfile</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash, $file_param_name Return: $path, $name ($path=undef on error) multipart_getfile is used to retrieve information for a file parameter contained in %multi_hash.  To use this you would most likely do:  ($path,$fname)=LW2::multipart_getfile(&#92;%multi,"param_name");</p>
  </dd>
  <dt>
    <strong>multipart_boundary</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash [, $new_boundary_name] Return: $current_boundary_name multipart_boundary is used to retrieve, and optionally set, the multipart boundary used for the request. \s-1NOTE:\s0 the function does no checking on the supplied boundary, so if you want things to work make sure it's a legit boundary.  Libwhisker does *not* prefix it with any '---' characters.</p>
  </dd>
  <dt>
    <strong>multipart_write</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash, &#92;%request Return: 1 if successful, undef on error multipart_write is used to parse and construct the multipart data contained in %multi_hash, and place it ready to go in the given whisker hash (%request) structure, to be sent to the server. \s-1NOTE:\s0 file contents are read into the final %request, so it's possible for the hash to get *very* large if you have (a) large file(s).</p>
  </dd>
  <dt>
    <strong>multipart_read</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash, &#92;%hout_response [, $filepath ] Return: 1 if successful, undef on error multipart_read will parse the data contents of the supplied %hout_response hash, by passing the appropriate info to <em>multipart_read_data()</em>.  Please see <em>multipart_read_data()</em> for more info on parameters and behaviour. \s-1NOTE:\s0 this function will return an error if the given %hout_response Content-Type is not set to \*(L"multipart/form-data\*(R".</p>
  </dd>
  <dt>
    <strong>multipart_read_data</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash, &#92;$data, $boundary [, $filepath ] Return: 1 if successful, undef on error multipart_read_data parses the contents of the supplied data using the given boundary and puts the values in the supplied %multi_hash. Embedded files will *not* be saved unless a $filepath is given, which should be a directory suitable for writing out temporary files. \s-1NOTE:\s0 currently only application/octet-stream is the only supported file encoding.  All other file encodings will not be parsed/saved.</p>
  </dd>
  <dt>
    <strong>multipart_files_list</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash Return: @files multipart_files_list returns an array of parameter names for all the files that are contained in %multi_hash.</p>
  </dd>
  <dt>
    <strong>multipart_params_list</strong>
  </dt>
  <dd>
    <p>Params: &#92;%multi_hash Return: @params multipart_files_list returns an array of parameter names for all the regular parameters (non-file) that are contained in %multi_hash.</p>
  </dd>
  <dt>
    <strong>ntlm_new</strong>
  </dt>
  <dd>
    <p>Params: $username, $password [, $domain, $ntlm_only] Return: $ntlm_object Returns a reference to an array (otherwise known as the 'ntlm object') which contains the various informations specific to a user/pass combo. If $ntlm_only is set to 1, then only the \s-1NTLM\s0 hash (and not the LanMan hash) will be generated.  This results in a speed boost, and is typically fine for using against \s-1IIS\s0 servers. The array contains the following items, in order: username, password, domain, lmhash(password), ntlmhash(password)</p>
  </dd>
  <dt>
    <strong>ntlm_decode_challenge</strong>
  </dt>
  <dd>
    <p>Params: $challenge Return: @challenge_parts Splits the supplied challenge into the various parts.  The returned array contains elements in the following order: unicode_domain, ident, packet_type, domain_len, domain_maxlen, domain_offset, flags, challenge_token, reserved, empty, raw_data</p>
  </dd>
  <dt>
    <strong>ntlm_client</strong>
  </dt>
  <dd>
    <p>Params: $ntlm_obj [, $server_challenge] Return: $response <em>ntlm_client()</em> is responsible for generating the base64-encoded text you include in the \s-1HTTP\s0 Authorization header.  If you call <em>ntlm_client()</em> without a $server_challenge, the function will return the initial \s-1NTLM\s0 request packet (message packet #1).  You send this to the server, and take the server's response (message packet #2) and pass that as $server_challenge, causing <em>ntlm_client()</em> to generate the final response packet (message packet #3). Note: $server_challenge is expected to be base64 encoded.</p>
  </dd>
  <dt>
    <strong>get_page</strong>
  </dt>
  <dd>
    <p>Params: $url [, &#92;%request] Return: $code, $data ($code will be set to undef on error, $data will 			contain error message) This function will fetch the page at the given \s-1URL\s0, and return the \s-1HTTP\s0 response code and page contents.  Use this in the form of: ($code,$html)=LW2::get_page(\*(L"http://host.com/page.html\*(R") The optional %request will be used if supplied.  This allows you to set headers and other parameters.</p>
  </dd>
  <dt>
    <strong>get_page_hash</strong>
  </dt>
  <dd>
    <p>Params: $url [, &#92;%request] Return: $hash_ref (undef on no \s-1URL\s0) This function will fetch the page at the given \s-1URL\s0, and return the whisker \s-1HTTP\s0 response hash.  The return code of the function is set to $hash_ref-&gt;{whisker}-&gt;{get_page_hash}, and uses the <em>http_do_request()</em> return values. Note: undef is returned if no \s-1URL\s0 is supplied</p>
  </dd>
  <dt>
    <strong>get_page_to_file</strong>
  </dt>
  <dd>
    <p>Params: $url, $filepath [, &#92;%request] Return: $code ($code will be set to undef on error) This function will fetch the page at the given \s-1URL\s0, place the resulting \s-1HTML\s0 in the file specified, and return the \s-1HTTP\s0 response code.  The optional %request hash sets the default parameters to be used in the request. \s-1NOTE:\s0 libwhisker does not do any file checking; libwhisker will open the supplied filepath for writing, overwriting any previously-existing files. Libwhisker does not differentiate between a bad request, and a bad file open.  If you're having troubles making this function work, make sure that your $filepath is legal and valid, and that you have appropriate write permissions to create/overwrite that file.</p>
  </dd>
  <dt>
    <strong>time_mktime</strong>
  </dt>
  <dd>
    <p>Params: $seconds, $minutes, $hours, $day_of_month, $month, $year_minus_1900 Return: $seconds [ -1 on error ] Performs a general mktime calculation with the given time components. Note that the input parameter values are expected to be in the format output by localtime/gmtime.  Namely, $seconds is 0-60 (yes, there can be a leap second value of 60 occasionally), $minutes is 0-59, $hours is 0-23, $days is 1-31, $month is 0-11, and $year is 70-127.  This function is limited in that it will not process dates prior to 1970 or after 2037 (that way 32-bit time_t overflow calculations aren't required). Additional parameters passed to the function are ignored, so it is safe to use the full localtime/gmtime output, such as:         $seconds = LW2::time_mktime( localtime( time ) ); Note: this function does not adjust for time zone, daylight savings time, etc.  You must do that yourself.</p>
  </dd>
  <dt>
    <strong>time_gmtolocal</strong>
  </dt>
  <dd>
    <p>Params: $seconds_gmt Return: $seconds_local_timezone Takes a seconds value in \s-1UTC/GMT\s0 time and adjusts it to reflect the current timezone.  This function is slightly expensive; it takes the <em>gmtime()</em> and <em>localtime()</em> representations of the current time, calculates the delta difference by turning them back into seconds via time_mktime, and then applies this delta difference to $seconds_gmt. Note that if you give this function a time and subtract the return value from the original time, you will get the delta value.  At that point, you can just apply the delta directly and skip calling this function, which is a massive performance boost.  However, this will cause problems if you have a long running program which crosses daylight savings time boundaries, as the \s-1DST\s0 adjustment will not be accounted for unless you recalculate the new delta.</p>
  </dd>
  <dt>
    <strong>uri_split</strong>
  </dt>
  <dd>
    <p>Params: $uri_string [, &#92;%request_hash] Return: @uri_parts Return an array of the following values, in order:  uri, protocol, host, port, params, frag, user, password.  Values not defined are given an undef value.  If a %request hash is passed in, then <em>uri_split()</em> will also set the appropriate values in the hash. Note:  <em>uri_split()</em> will only set the %request hash if the protocol is \s-1HTTP\s0 or \s-1HTTPS\s0!</p>
  </dd>
  <dt>
    <strong>uri_join</strong>
  </dt>
  <dd>
    <p>Params: @vals Return: $url Takes the @vals array output from http_split_uri, and returns a single scalar/string with them joined again, in the form of: protocol://user:pass@host:port/uri?params#frag</p>
  </dd>
  <dt>
    <strong>uri_absolute</strong>
  </dt>
  <dd>
    <p>Params: $uri, $base_uri [, $normalize_flag ] Return: $absolute_uri Double checks that the given $uri is in absolute form (that is, \*(L"http://host/file\*(R"), and if not (it's in the form \*(L"/file\*(R"), then it will append the given $base_uri to make it absolute.  This provides a compatibility similar to that found in the \s-1URI\s0 subpackage. If $normalize_flag is set to 1, then the output will be passed through uri_normalize before being returned.</p>
  </dd>
  <dt>
    <strong>uri_normalize</strong>
  </dt>
  <dd>
    <p>Params: $uri [, $fix_windows_slashes ] Return: $normalized_uri [ undef on error ] Takes the given $uri and does any /./ and /../ dereferencing in order to come up with the correct absolute \s-1URL\s0.  If the $fix_ windows_slashes parameter is set to 1, all &#92; (back slashes) will be converted to / (forward slashes). Non-http/https URIs return an error.</p>
  </dd>
  <dt>
    <strong>uri_get_dir</strong>
  </dt>
  <dd>
    <p>Params: $uri Return: $uri_directory Will take a \s-1URI\s0 and return the directory base of it, i.e. /rfp/page.php will return /rfp/.</p>
  </dd>
  <dt>
    <strong>uri_strip_path_parameters</strong>
  </dt>
  <dd>
    <p>Params: $uri [, &#92;%param_hash] Return: $stripped_uri This function removes all \s-1URI\s0 path parameters of the form  /blah1;foo=bar/blah2;baz and returns the stripped \s-1URI\s0 ('/blah1/blah2').  If the optional parameter hash reference is provided, the stripped parameters are saved in the form of 'blah1'=&gt;'foo=bar', 'blah2'=&gt;'baz'. Note: only the last value of a duplicate name is saved into the param_hash, if provided.  So a $uri of '/foo;A/foo;B/' will result in a single hash entry of 'foo'=&gt;'B'.</p>
  </dd>
  <dt>
    <strong>uri_parse_parameters</strong>
  </dt>
  <dd>
    <p>Params: $parameter_string [, $decode, $multi_flag ] Return: &#92;%parameter_hash This function takes a string in the form of:  foo=1&bar=2&baz=3&foo=4 And parses it into a hash.  In the above example, the element 'foo' has two values (1 and 4).  If $multi_flag is set to 1, then the 'foo' hash entry will hold an anonymous array of both values. Otherwise, the default is to just contain the last value (in this case, '4'). If $decode is set to 1, then normal hex decoding is done on the characters, where needed (both the name and value are decoded). Note: if a \s-1URL\s0 parameter name appears without a value, then the value will be set to undef.  E.g. for the string \*(L"foo=1&bar&baz=2\*(R", the 'bar' hash element will have an undef value.</p>
  </dd>
  <dt>
    <strong>uri_escape</strong>
  </dt>
  <dd>
    <p>Params: $data Return: $encoded_data This function encodes the given $data so it is safe to be used in URIs.</p>
  </dd>
  <dt>
    <strong>uri_unescape</strong>
  </dt>
  <dd>
    <p>Params: $encoded_data Return: $data This function decodes the given $data out of \s-1URI\s0 format.</p>
  </dd>
  <dt>
    <strong>utils_recperm</strong>
  </dt>
  <dd>
    <p>Params: $uri, $depth, &#92;@dir_parts, &#92;@valid, &#92;&func, &#92;%track, &#92;%arrays, &#92;&cfunc Return: nothing This is a special function which is used to recursively-permutate through a given directory listing.  This is really only used by whisker, in order to traverse down directories, testing them as it goes.  See whisker 2.0 for exact usage examples.</p>
  </dd>
  <dt>
    <strong>utils_array_shuffle</strong>
  </dt>
  <dd>
    <p>Params: &#92;@array Return: nothing This function will randomize the order of the elements in the given array.</p>
  </dd>
  <dt>
    <strong>utils_randstr</strong>
  </dt>
  <dd>
    <p>Params: [ $size, $chars ] Return: $random_string This function generates a random string between 10 and 20 characters long, or of $size if specified.  If $chars is specified, then the random function picks characters from the supplied string.  For example, to have a random string of 10 characters, composed of only the characters 'abcdef', then you would run:  utils_randstr(10,&apos;abcdef&apos;); The default character string is alphanumeric.</p>
  </dd>
  <dt>
    <strong>utils_port_open</strong>
  </dt>
  <dd>
    <p>Params: $host, $port Return: $result Quick function to attempt to make a connection to the given host and port.  If a connection was successfully made, function will return true (1).  Otherwise it returns false (0). Note: this uses standard \s-1TCP\s0 connections, thus is not recommended for use in port-scanning type applications.  Extremely slow.</p>
  </dd>
  <dt>
    <strong>utils_lowercase_keys</strong>
  </dt>
  <dd>
    <p>Params: &#92;%hash Return: $number_changed Will lowercase all the header names (but not values) of the given hash.</p>
  </dd>
  <dt>
    <strong>utils_find_lowercase_key</strong>
  </dt>
  <dd>
    <p>Params: &#92;%hash, $key Return: $value, undef on error or not exist Searches the given hash for the $key (regardless of case), and returns the value. If the return value is placed into an array, the will dereference any multi-value references and return an array of all values. \s-1WARNING\s0!  In scalar context, $value can either be a single-value scalar or an array reference for multiple scalar values.  That means you either need to check the return value and act appropriately, or use an array context (even if you only want a single value).  This is very important, even if you know there are no multi-value hash keys. This function may still return an array of multiple values even if all hash keys are single value, since lowercasing the keys could result in multiple keys matching.  For example, a hash with the values { 'Foo'=&gt;'a', 'fOo'=&gt;'b' } technically has two keys with the lowercase name 'foo', and so this function will either return an array or array reference with both 'a' and 'b'.</p>
  </dd>
  <dt>
    <strong>utils_find_key</strong>
  </dt>
  <dd>
    <p>Params: &#92;%hash, $key Return: $value, undef on error or not exist Searches the given hash for the $key (case-sensitive), and returns the value. If the return value is placed into an array, the will dereference any multi-value references and return an array of all values.</p>
  </dd>
  <dt>
    <strong>utils_delete_lowercase_key</strong>
  </dt>
  <dd>
    <p>Params: &#92;%hash, $key Return: $number_found Searches the given hash for the $key (regardless of case), and deletes the key out of the hash if found.  The function returns the number of keys found and deleted (since multiple keys can exist under the names 'Key', 'key', 'keY', '\s-1KEY\s0', etc.).</p>
  </dd>
  <dt>
    <strong>utils_getline</strong>
  </dt>
  <dd>
    <p>Params: &#92;$data [, $resetpos ] Return: $line (undef if no more data) Fetches the next &#92;n terminated line from the given data.  Use the optional $resetpos to reset the internal position pointer. Does *NOT* return trialing &#92;n.</p>
  </dd>
  <dt>
    <strong>utils_getline_crlf</strong>
  </dt>
  <dd>
    <p>Params: &#92;$data [, $resetpos ] Return: $line (undef if no more data) Fetches the next &#92;r&#92;n terminated line from the given data.  Use the optional $resetpos to reset the internal position pointer. Does *NOT* return trialing &#92;r&#92;n.</p>
  </dd>
  <dt>
    <strong>utils_save_page</strong>
  </dt>
  <dd>
    <p>Params: $file, &#92;%response Return: 0 on success, 1 on error Saves the data portion of the given whisker %response hash to the indicated file.  Can technically save the data portion of a %request hash too.  A file is not written if there is no data. Note: \s-1LW\s0 does not do any special file checking; files are opened in overwrite mode.</p>
  </dd>
  <dt>
    <strong>utils_getopts</strong>
  </dt>
  <dd>
    <p>Params: $opt_str, &#92;%opt_results Return: 0 on success, 1 on error This function is a general implementation of GetOpts::Std.  It will parse @ARGV, looking for the options specified in $opt_str, and will put the results in %opt_results.  Behavior/parameter values are similar to GetOpts::Std's <em>getopts()</em>. Note: this function does *not* support long options (--option), option grouping (-opq), or options with immediate values (-ovalue). If an option is indicated as having a value, it will take the next argument regardless.</p>
  </dd>
  <dt>
    <strong>utils_text_wrapper</strong>
  </dt>
  <dd>
    <p>Params: $long_text_string [, $crlf, $width ] Return: $formatted_test_string This is a simple function used to format a long line of text for display on a typical limited-character screen, such as a unix shell console. $crlf defaults to \*(L"&#92;n\*(R", and $width defaults to 76.</p>
  </dd>
  <dt>
    <strong>utils_bruteurl</strong>
  </dt>
  <dd>
    <p>Params: &#92;%req, $pre, $post, &#92;@values_in, &#92;@values_out Return: Nothing (adds to @out) Bruteurl will perform a brute force against the host/server specified in %req.  However, it will make one request per entry in @in, taking the value and setting $hin{'whisker'}-&gt;{'uri'}= $pre.value.$post.  Any \s-1URI\s0 responding with an \s-1HTTP\s0 200 or 403 response is pushed into @out.  An example of this would be to brute force usernames, putting a list of common usernames in @in, setting $pre='/~' and $post='/'.</p>
  </dd>
  <dt>
    <strong>utils_join_tag</strong>
  </dt>
  <dd>
    <p>Params: $tag_name, &#92;%attributes Return: $tag_string [undef on error] This function takes the $tag_name (like 'A') and a hash full of attributes (like {href=&gt;'http://foo/'}) and returns the constructed \s-1HTML\s0 tag string (&lt;A href=\*(L"http://foo\*(R"&gt;).</p>
  </dd>
  <dt>
    <strong>utils_request_clone</strong>
  </dt>
  <dd>
    <p>Params: &#92;%from_request, &#92;%to_request Return: 1 on success, 0 on error This function takes the connection/request-specific values from the given from_request hash, and copies them to the to_request hash.</p>
  </dd>
  <dt>
    <strong>utils_request_fingerprint</strong>
  </dt>
  <dd>
    <p>Params: &#92;%request [, $hash ] Return: $fingerprint [undef on error] This function constructs a 'fingerprint' of the given request by using a cryptographic hashing function on the constructed original \s-1HTTP\s0 request. Note: $hash can be 'md5' (default) or 'md4'.</p>
  </dd>
  <dt>
    <strong>utils_flatten_lwhash</strong>
  </dt>
  <dd>
    <p>Params: &#92;%lwhash Return: $flat_version [undef on error] This function takes a %request or %response libwhisker hash, and creates an approximate flat data string of the original request/ response (i.e. before it was parsed into components and placed into the libwhisker hash).</p>
  </dd>
  <dt>
    <strong>utils_carp</strong>
  </dt>
  <dd>
    <p>Params: [ $package_name ] Return: nothing This function acts like Carp's carp function.  It warn's with the file and line number of user's code which causes a problem.  It traces up the call stack and reports the first function that is not in the \s-1LW2\s0 or optional $package_name package package.</p>
  </dd>
  <dt>
    <strong>utils_croak</strong>
  </dt>
  <dd>
    <p>Params: [ $package_name ] Return: nothing This function acts like Carp's croak function.  It die's with the file and line number of user's code which causes a problem.  It traces up the call stack and reports the first function that is not in the \s-1LW2\s0 or optional $package_name package package.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO LW2&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1LWP\s0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2009 Jeff Forristal</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="next"><a href="Lingua::DE::ASCII.3perl.html">Lingua::DE::ASCII.3perl: Perl extension to convert german umlauts to and from ascii <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

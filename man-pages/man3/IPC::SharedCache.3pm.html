<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>IPC::SharedCache: A perl module to manage a cache in sysv ipc shared memory.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A perl module to manage a cache in sysv ipc shared memory.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="IPC::SharedCache (3pm) manual">
  <meta name="twitter:description" content="A perl module to manage a cache in sysv ipc shared memory.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libipc-sharedcache-perl-IPC::SharedCache-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/IPC::SharedCache.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="IPC::SharedCache (3pm) manual" />
  <meta property="og:description" content="A perl module to manage a cache in sysv ipc shared memory." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libipc-sharedcache-perl-IPC::SharedCache-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">IPC::SharedCache<small> (3pm)</small></h1>
        <p class="lead">A perl module to manage a cache in sysv ipc shared memory.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IPC::SharedCache.3pm.html">
      <span itemprop="name">IPC::SharedCache: A perl module to manage a cache in sysv ipc shared memory.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libipc-sharedcache-perl/">
      <span itemprop="name">libipc-sharedcache-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IPC::SharedCache.3pm.html">
      <span itemprop="name">IPC::SharedCache: A perl module to manage a cache in sysv ipc shared memory.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use IPC::SharedCache;

  # the cache is accessed using a tied hash.
  tie %cache, &apos;IPC::SharedCache&apos;, ipc_key =&gt; &apos;AKEY&apos;,
                                  load_callback =&gt; &#92;&load,
                                  validate_callback =&gt; &#92;&validate;

  # get an item from the cache
  $config_file = $cache{&apos;/some/path/to/some.config&apos;};
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides a shared memory cache accessed as a tied hash.</p><p>Shared memory is an area of memory that is available to all processes. It is accessed by choosing a key, the ipc_key arguement to tie.  Every process that accesses shared memory with the same key gets access to the same region of memory.  In some ways it resembles a file system, but it is not hierarchical and it is resident in memory.  This makes it harder to use than a filesystem but much faster.  The data in shared memory persists until the machine is rebooted or it is explicitely deleted.</p><p>This module attempts to make shared memory easy to use for one specific application - a shared memory cache.  For other uses of shared memory see the documentation to the excelent module I use, IPC::ShareLite (IPC::ShareLite).</p><p>A cache is a place where processes can store the results of their computations for use at a later time, possibly by other instances of the application.  A good example of the use of a cache is a web server.  When a web server receieves a request for an html page it goes to the file system to read it.  This is pretty slow, so the web server will probably save the file in memory and use the in memory copy the next time a request for that file comes in, as long as the file hasn't changed on disk.  This certainly speeds things up but web servers have to serve multiple clients at once, and that means multiple copies of the in-memory data.  If the web server uses a shared memory cache, like the one this module provides, then all the servers can use the same cache and much less memory is consumed.</p><p>This module handles all shared memory interaction using the IPC::ShareLite module (version 0.06 and higher) and all data serialization using Storable.  See IPC::ShareLite and Storable for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MOTIVATION</h2>
        <div class="sectioncontent">
<p>This module began its life as an internal piece of HTML::Template (see HTML::Template).  HTML::Template has the ability to maintain a cache of parsed template structures when running in a persistent environment like Apache/mod_perl.  Since parsing a template from disk takes a fair ammount of time this can provide a big performance gain. Unfortunately it can also consume large ammounts of memory since each web server maintains its own cache in its own memory space.</p><p>By using IPC::ShareLite and Storable (IPC::ShareLite and Storable), HTML::Template was able to maintain a single shared cache of templates.  The downside was that HTML::Template's cache routines became complicated by a lot of \s-1IPC\s0 code.  My solution is to break out the \s-1IPC\s0 cache mechanisms into their own module, IPC::SharedCache.  Hopefully over time it can become general enough to be usable by more than just HTML::Template.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>This module allows you to store data in shared memory and have it load automatically when needed.  You can also define a test to screen cached data for vailidty - if the test fails the data will be reloaded.  This is useful for defining a max-age for cached data or keeping cached data in sync with other resources.  In the web server example above the validation test would look to see wether the file had changed on disk.</p><p>To initialize this module you provide two callback subroutines.  The first is the \*(L"load_callback\*(R".  This gets called when a user of the cache requests an item from that is not yet present or is stale.  It must return a reference to the data structure that will be stored in the cache.  The second is the \*(L"validate_callback\*(R".  This gets called on every cache access - its job is to check the cached object for freshness (and/or some other validity, of course).  It must return true or false.  When it returns true, the cached object is valid and is retained in the cache.  When it returns false, the object is re-loaded using the \*(L"load_callback\*(R" and the result is stored in the cache.</p><p>To use the module you just request entries for the objects you need. If the object is present in the cache and the \*(L"validate_callback\*(R" returns true, then you get the object from the cache.  If not, the object is loaded into the cache with the \*(L"load_callback\*(R" and returned to you.</p><p>The cache can be used to store any perl data structures that can be serialized by the Storable module.  See Storable for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>In this example a shared cache of files is maintained.  The \*(L"load_callback\*(R" reads the file from disk into the cache and the \*(L"validate_callback\*(R" checks its modification time using <em>stat()</em>.  Note that the \*(L"load_callback\*(R" stores information into the cached object that \*(L"validate_callback\*(R" uses to check the freshness of the cache.</p><p>  # the "load_callback", loads the file from disk, storing its stat()   # information along with the file into the cache.  The key in this   # case is the filename to load.   sub load_file {     my $key = shift;</p><p>    open(FILE, $key) or die "Unable to open file named $key : $!");</p><p>    # note the modification time of this file - the 9th element of a     # stat() is the modification time of the file.     my $mtime = (stat($key))[9];</p><p>    # read the file into the variable $contents in 1k chunks     my ($buffer, $contents);     while(read(FILE, $buffer, 1024)) { $contents .= $buffer }     close(FILE);</p><p>    # prepare the record to store in the cache     my %record = ( mtime =&gt; $mtime, contents =&gt; $contents );</p><p>    # this record goes into the cache associated with $key, which is     # the filename.  Notice that we&apos;re returning a reference to the     # data structure here.     return &#92;%record;   }</p><p>  # the "validate" callback, checks the mtime of the file on disk and   # compares it to the cache value.  The $record is a reference to the   # cached values array returned from load_file above.   sub validate_file {     my ($key, $record) = @_;</p><p>    # get the modification time out of the record     my $stored_mtime = $record-&gt;{mtime};</p><p>    # get the current modification time from the filesystem - the 9th     # element of a stat() is the modification time of the file.     my $current_mtime = (stat($key))[9];</p><p>    # compare and return the appropriate result.     if ($stored_mtime == $current_mtime) {       # the cached object is valid, return true       return 1;     } else {       # the cached object is stale, return false - load_callback will       # be called to load it afresh from disk.       return 0;     }   }</p><p>  # now we can construct the IPC::SharedCache object, using as a root   # key &apos;SAMS&apos;.</p><p>  tie %cache &apos;IPC::SharedCache&apos; ipc_key =&gt; &apos;SAMS&apos;,                                 load_callback =&gt; &#92;&load_file,                                 validate_callback =&gt; &#92;&validate_file;</p><p>  # fetch an object from the cache - if it&apos;s already in the cache and   # validate_file() returns 1, then we&apos;ll get the cached file.  If it&apos;s   # not in the cache, or validate_file returns 0, then load_file is   # called to load the file into the cache.</p><p>  $config_file = $cache{&apos;/some/path/to/some.config&apos;};</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DETAILS</h2>
        <div class="sectioncontent">
<p>The module implements a full tied hash interface, meaning that you can use <em>exists()</em>, <em>delete()</em>, <em>keys()</em> and <em>each()</em>.  However, in normal usage all you'll need to do is to fetch values from the cache and possible delete keys.  Just in case you were wondering, <em>exists()</em> doesn't trigger a cache load - it returns 1 if the given key is already in the cache and 0 if it isn't.  Similarily, <em>keys()</em> and <em>each()</em> operate on key/value pairs already loaded into the cache.</p><p>The most important thing to realize is that there is no need to explicitely store into the cache since the load_callback is called automatically when it is necessary to load new data.  If you find yourself using more than just "\*(C`$data = $cache{&apos;key&apos;};\*(C'" you need to make sure you really know what you're doing!</p><h3>\s-1OPTIONS\s0</h3>
<p>There are a number parameters to tie that can be used to control the behavior of IPC::SharedCache.  Some of them are required, and some art optional. Here's a preview:</p><p>   tie %cache, &apos;IPC::SharedCache&apos;,</p><p>      # required parameters       ipc_key =&gt; &apos;MYKI&apos;,       load_callback =&gt; &#92;&load,       validate_callback =&gt; &#92;&validate,</p><p>      # optional parameters       ipc_mode =&gt; 0666,       ipc_segment_size =&gt; 1_000_000,       max_size =&gt; 50_000_000,       debug =&gt; 1;</p>
<h3>ipc_key (required)</h3>
<p>This is the unique identifier for the particular cache.  It can be specified as either a four-character string or an integer value.  Any script that wishes to access the cache must use the same ipc_key value.  You can use the <em>ftok()</em> function from IPC::SysV to generate this value, see IPC::SysV for details.  Using an ipc_key value that's already in use by a non-IPC::SharedCache application will cause an error.  Many systems provide a utility called 'ipcs' to examine shared memory; you can use it to check for existing shared memory usage before choosing your ipc_key.</p>
<h3>load_callback and validate_callback (required)</h3>
<p>These parameters both specify callbacks for IPC::SharedCache to use when the cache gets a request for a key.  When you access the cache (\*(C`$data = $cache{$key}\*(C'), the cache first looks to see if it already has an object for the given key.  If it doesn't, it calls the load_callback and returns the result which is also stored in the cache.  Alternately, if it does have the object in the cache it calls the validate_callback to check if the object is still good.  If the validate_callback returns true then object is good and is returned. If the validate_callback returns false then the object is discarded and the load_callback is called.</p><p>The load_callback recieves a single parameter - the requested key.  It must return a reference to the data object be stored in the cache. Returning something that is not a reference results in an error.</p><p>The validate_callback recieves two parameters - the key and the reference to the stored object.  It must return true or false.</p><p>There are two ways to specify the callbacks.  The first is simply to specify a subroutine reference.  This can be an anonymous subroutine or a named one.  Example:</p><p>  tie %cache, &apos;IPC::SharedCache&apos;,       ipc_key =&gt; &apos;TEST&apos;,       load_callback =&gt; sub { ... },       validate_callback =&gt; &#92;&validate;</p><p>The second method allows parameters to be passed to the subroutine when it is called.  This is done by specifying a reference to an array of values, the first being the subroutine reference and the rest are parameters for the subroutine.  The extra parameters are passed in before the IPC::SharedCache provided parameters.  Example:</p><p>  tie %cache, &apos;IPC::SharedCache&apos;,       ipc_key =&gt; &apos;TEST&apos;,       load_callback =&gt; [&#92;&load, $arg1, $arg2, $arg3]       validate_callback =&gt; [&#92;&validate, $self];</p>
<h3>ipc_mode (optional)</h3>
<p>This option specifies the access mode of the \s-1IPC\s0 cache.  It defaults to 0666.  See IPC::ShareLite for more information on \s-1IPC\s0 access modes.  The default should be fine for most applications.</p>
<h3>ipc_segment_size (optional)</h3>
<p>This option allows you to specify the \*(L"chunk size\*(R" of the \s-1IPC\s0 shared memory segments.  The default is 65,536, which is 64K.  This is a good default and is very portable.  If you know that your system supports larger \s-1IPC\s0 segment sizes and you know that your cache will be storing large data items you might get better performance by increasing this value.</p><p>This value places no limit on the size of an object stored in the cache - IPC::SharedCache automatically spreads large objects across multiple \s-1IPC\s0 segments.</p><p>\s-1WARNING:\s0 setting this value too low (below 1024 in my experience) can cause errors.</p>
<h3>max_size (optional)</h3>
<p>By setting this parameter you are setting a logical maximum to the ammount of data stored in the cache.  When an item is stored in the cache and this limit is exceded the oldest item (or items, as necessary) in the cache will be deleted to make room.  This value is specified in bytes.  It defaults to 0, which specifies no limit on the size of the cache.</p><p>Turning this feature on costs a fair ammount of performance - how much depends largely on home much data is being stored into the cache versus the size of max_cache.  In the worst case (where the max_size is set much too low) this option can cause severe \*(L"thrashing\*(R" and negate the benefit of maintaining a cache entirely.</p><p>\s-1NOTE:\s0 The size of the cache may in fact exceed this value - the book-keeping data stored in the root segment is not counted towards the total.  Also, extra padding imposed by the ipc_segment_size is not counted.  This may change in the future if I learn that it would be appropriate to count this padding as used memory.  It is not clear to me that all \s-1IPC\s0 implementations will really waste this memory.</p>
<h3>debug (optional)</h3>
<p>Set this option to 1 to see a whole bunch of text on \s-1STDERR\s0 about what IPC::SharedCache is doing.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UTILITIES</h2>
        <div class="sectioncontent">
<p>Two static functions are included in this package that are meant to be used from the command-line.</p><h3>walk</h3>
<p>Walk prints out a detailed listing of the contents of a shared cache at a given ipc_key.  It provides information the current keys stored and a dump of the objects stored in each key.  Be warned, this can be quite a lot of data!  Also, you'll need the Data::Dumper module installed to use 'walk'.  You can get it on \s-1CPAN\s0.</p><p>You can call walk like:</p><p>   perl -MIPC::SharedCache -e &apos;IPC::SharedCache::walk AKEY&apos;"</p><p>Example:</p><p>   $ perl -MIPC::SharedCache -e &apos;IPC::SharedCache::walk MYKI&apos;"    *===================*    IPC::SharedCache Root    *===================*    IPC_KEY: MYKI    ELEMENTS: 3    TOTAL SIZE: 99 bytes    KEYS: a, b, c</p><p>   *=======*    Data List    *=======*</p><p>   KEY: a    $CONTENTS = [                  950760892,                  950760892,                  950760892                ];</p><p>   KEY: b    $CONTENTS = [                  950760892,                  950760892,                  950760892                ];</p><p>   KEY: c    $CONTENTS = [                  950760892,                  950760892,                  950760892                ];</p>
<h3>remove</h3>
<p>This function totally removes an entire cache given an ipc_key value. This should not be done to a running system!  Still, it's an invaluable tool during development when flawed data may become 'stuck' in the cache.</p><p>   $ perl -MIPC::SharedCache -e &apos;IPC::SharedCache::remove MYKI&apos;</p><p>This function is silent and thus may be usefully called from within a script if desired.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>I am aware of no bugs - if you find one please email me at sam@tregar.com.  When submitting bug reports, be sure to include full details, including the \s-1VERSION\s0 of the module and a test script demonstrating the problem.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREDITS</h2>
        <div class="sectioncontent">
<p>I would like to thank Maurice Aubrey for making this module possible by producing the excelent IPC::ShareLite.</p><p>The following people have contributed patches, ideas or new features:</p><p>   Tim Bunce    Roland Mas    Drew Taylor    Ed Loehr    Maverick</p><p>Thanks everyone!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sam Tregar, sam@tregar.com (you can also find me on the mailing list for HTML::Template at htmltmpl@lists.vm.com - join it by sending a blank message to htmltmpl-subscribe@lists.vm.com).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>IPC::SharedCache - a Perl module to manage a SysV \s-1IPC\s0 shared cache. Copyright (C) 2000 Sam Tregar (sam@tregar.com)</p><p>This program is free software; you can redistribute it and/or modify it under the terms of the \s-1GNU\s0 General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0 General Public License for more details.</p><p>You should have received a copy of the \s-1GNU\s0 General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, \s-1MA\s0 02111-1307 \s-1USA\s0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sam Tregar, sam@tregar.com</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO IPC::SharedCache&hellip;</h2>
        <div class="sectioncontent">
<p><em>perl</em>\|(1).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="IPC::Shareable::SharedMem.3pm.html"><span aria-hidden="true">&larr;</span> IPC::Shareable::SharedMem.3pm: Object oriented interface to shared memory</a></li>
   <li class="next"><a href="IPC::Signal.3pm.html">IPC::Signal.3pm: Utility functions dealing with signals <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

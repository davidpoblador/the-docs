<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dynload_overview: Dynamic loading of extension nodes when coin tries to get hold of a node type object (sotype) for a class based on the name string of the node type, it will - if no such node type has been initialized yet - scan the file system for a dynamically loadable extension node with that given name. this can be completely disabled by setting the environment variable coin_no_sotype_dynload to a positive integer value, new from coin v2.5.0.  on unix, extensions nodes are regular .so files. on win32, extension nodes are built as dlls. on mac os x systems, extension nodes are built as .dylib files. (note: the extension nodes have to be built using the flag '-dynamiclib', not '-bundle'.)  whether the dynamically loadable objects should be named with or without the 'lib' prefix is optional. both schemes will work.  people don't usually program in a way so that they instantiate new nodes through the node class' sotype object, but that is the way nodes are created when model files are loaded. this means that for all coin applications that load model files, the custom extension nodes will automatically be supported for the model files without you having to modify their source code and rebuild the applications.  see ftp://ftp.coin3d.org/pub/coin/src/dynloadsample.tar.gz for an example using two dynamically loadable extension nodes. you only use an examiner viewer to view the two extension nodes in action.  only a limited set of c++ compilers are supported as of yet. this is because, to initialize the extension node, it is necessary to know something about how the c++ compiler mangles the initclass symbol. if we don't know that, there is no way to locate the initclass method in the library, which means the extension node can not make itself known to the type system.  if your c++ compiler is not supported, the source file to add support for a new compiler in is src/misc/cppmangle.icc. it is fairly trivial to add support for new compilers, but if you don't understand how, just ask us about it. patches with support for new compilers are of course very welcome.  see also: sotype  since: coin 2.0</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Dynamic loading of extension nodes when coin tries to get hold of a node type object (sotype) for a class based on the name string of the node type, it will - if no such node type has been initialized yet - scan the file system for a dynamically loadable extension node with that given name. this can be completely disabled by setting the environment variable coin_no_sotype_dynload to a positive integer value, new from coin v2.5.0.  on unix, extensions nodes are regular .so files. on win32, extension nodes are built as dlls. on mac os x systems, extension nodes are built as .dylib files. (note: the extension nodes have to be built using the flag '-dynamiclib', not '-bundle'.)  whether the dynamically loadable objects should be named with or without the 'lib' prefix is optional. both schemes will work.  people don't usually program in a way so that they instantiate new nodes through the node class' sotype object, but that is the way nodes are created when model files are loaded. this means that for all coin applications that load model files, the custom extension nodes will automatically be supported for the model files without you having to modify their source code and rebuild the applications.  see ftp://ftp.coin3d.org/pub/coin/src/dynloadsample.tar.gz for an example using two dynamically loadable extension nodes. you only use an examiner viewer to view the two extension nodes in action.  only a limited set of c++ compilers are supported as of yet. this is because, to initialize the extension node, it is necessary to know something about how the c++ compiler mangles the initclass symbol. if we don't know that, there is no way to locate the initclass method in the library, which means the extension node can not make itself known to the type system.  if your c++ compiler is not supported, the source file to add support for a new compiler in is src/misc/cppmangle.icc. it is fairly trivial to add support for new compilers, but if you don't understand how, just ask us about it. patches with support for new compilers are of course very welcome.  see also: sotype  since: coin 2.0">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dynload_overview (3) manual">
  <meta name="twitter:description" content="Dynamic loading of extension nodes when coin tries to get hold of a node type object (sotype) for a class based on the name string of the node type, it will - if no such node type has been initialized yet - scan the file system for a dynamically loadable extension node with that given name. this can be completely disabled by setting the environment variable coin_no_sotype_dynload to a positive integer value, new from coin v2.5.0.  on unix, extensions nodes are regular .so files. on win32, extension nodes are built as dlls. on mac os x systems, extension nodes are built as .dylib files. (note: the extension nodes have to be built using the flag '-dynamiclib', not '-bundle'.)  whether the dynamically loadable objects should be named with or without the 'lib' prefix is optional. both schemes will work.  people don't usually program in a way so that they instantiate new nodes through the node class' sotype object, but that is the way nodes are created when model files are loaded. this means that for all coin applications that load model files, the custom extension nodes will automatically be supported for the model files without you having to modify their source code and rebuild the applications.  see ftp://ftp.coin3d.org/pub/coin/src/dynloadsample.tar.gz for an example using two dynamically loadable extension nodes. you only use an examiner viewer to view the two extension nodes in action.  only a limited set of c++ compilers are supported as of yet. this is because, to initialize the extension node, it is necessary to know something about how the c++ compiler mangles the initclass symbol. if we don't know that, there is no way to locate the initclass method in the library, which means the extension node can not make itself known to the type system.  if your c++ compiler is not supported, the source file to add support for a new compiler in is src/misc/cppmangle.icc. it is fairly trivial to add support for new compilers, but if you don't understand how, just ask us about it. patches with support for new compilers are of course very welcome.  see also: sotype  since: coin 2.0">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-dynload_overview-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/dynload_overview.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dynload_overview (3) manual" />
  <meta property="og:description" content="Dynamic loading of extension nodes when coin tries to get hold of a node type object (sotype) for a class based on the name string of the node type, it will - if no such node type has been initialized yet - scan the file system for a dynamically loadable extension node with that given name. this can be completely disabled by setting the environment variable coin_no_sotype_dynload to a positive integer value, new from coin v2.5.0.  on unix, extensions nodes are regular .so files. on win32, extension nodes are built as dlls. on mac os x systems, extension nodes are built as .dylib files. (note: the extension nodes have to be built using the flag '-dynamiclib', not '-bundle'.)  whether the dynamically loadable objects should be named with or without the 'lib' prefix is optional. both schemes will work.  people don't usually program in a way so that they instantiate new nodes through the node class' sotype object, but that is the way nodes are created when model files are loaded. this means that for all coin applications that load model files, the custom extension nodes will automatically be supported for the model files without you having to modify their source code and rebuild the applications.  see ftp://ftp.coin3d.org/pub/coin/src/dynloadsample.tar.gz for an example using two dynamically loadable extension nodes. you only use an examiner viewer to view the two extension nodes in action.  only a limited set of c++ compilers are supported as of yet. this is because, to initialize the extension node, it is necessary to know something about how the c++ compiler mangles the initclass symbol. if we don't know that, there is no way to locate the initclass method in the library, which means the extension node can not make itself known to the type system.  if your c++ compiler is not supported, the source file to add support for a new compiler in is src/misc/cppmangle.icc. it is fairly trivial to add support for new compilers, but if you don't understand how, just ask us about it. patches with support for new compilers are of course very welcome.  see also: sotype  since: coin 2.0" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-dynload_overview-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dynload_overview<small> (3)</small></h1>
        <p class="lead">Dynamic loading of extension nodes when coin tries to get hold of a node type object (sotype) for a class based on the name string of the node type, it will - if no such node type has been initialized yet - scan the file system for a dynamically loadable extension node with that given name. this can be completely disabled by setting the environment variable coin_no_sotype_dynload to a positive integer value, new from coin v2.5.0.  on unix, extensions nodes are regular .so files. on win32, extension nodes are built as dlls. on mac os x systems, extension nodes are built as .dylib files. (note: the extension nodes have to be built using the flag '-dynamiclib', not '-bundle'.)  whether the dynamically loadable objects should be named with or without the 'lib' prefix is optional. both schemes will work.  people don't usually program in a way so that they instantiate new nodes through the node class' sotype object, but that is the way nodes are created when model files are loaded. this means that for all coin applications that load model files, the custom extension nodes will automatically be supported for the model files without you having to modify their source code and rebuild the applications.  see ftp://ftp.coin3d.org/pub/coin/src/dynloadsample.tar.gz for an example using two dynamically loadable extension nodes. you only use an examiner viewer to view the two extension nodes in action.  only a limited set of c++ compilers are supported as of yet. this is because, to initialize the extension node, it is necessary to know something about how the c++ compiler mangles the initclass symbol. if we don't know that, there is no way to locate the initclass method in the library, which means the extension node can not make itself known to the type system.  if your c++ compiler is not supported, the source file to add support for a new compiler in is src/misc/cppmangle.icc. it is fairly trivial to add support for new compilers, but if you don't understand how, just ask us about it. patches with support for new compilers are of course very welcome.  see also: sotype  since: coin 2.0</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/dynload_overview.3.html">
      <span itemprop="name">dynload_overview: Dynamic loading of extension nodes when coin tries to get hold of a node type object (sotype) for a class based on the name string of the node type, it will - if no such node type has been initialized yet - scan the file system for a dynamically loadable extension node with that given name. this can be completely disabled by setting the environment variable coin_no_sotype_dynload to a positive integer value, new from coin v2.5.0.  on unix, extensions nodes are regular .so files. on win32, extension nodes are built as dlls. on mac os x systems, extension nodes are built as .dylib files. (note: the extension nodes have to be built using the flag '-dynamiclib', not '-bundle'.)  whether the dynamically loadable objects should be named with or without the 'lib' prefix is optional. both schemes will work.  people don't usually program in a way so that they instantiate new nodes through the node class' sotype object, but that is the way nodes are created when model files are loaded. this means that for all coin applications that load model files, the custom extension nodes will automatically be supported for the model files without you having to modify their source code and rebuild the applications.  see ftp://ftp.coin3d.org/pub/coin/src/dynloadsample.tar.gz for an example using two dynamically loadable extension nodes. you only use an examiner viewer to view the two extension nodes in action.  only a limited set of c++ compilers are supported as of yet. this is because, to initialize the extension node, it is necessary to know something about how the c++ compiler mangles the initclass symbol. if we don't know that, there is no way to locate the initclass method in the library, which means the extension node can not make itself known to the type system.  if your c++ compiler is not supported, the source file to add support for a new compiler in is src/misc/cppmangle.icc. it is fairly trivial to add support for new compilers, but if you don't understand how, just ask us about it. patches with support for new compilers are of course very welcome.  see also: sotype  since: coin 2.0</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/dynload_overview.3.html">
      <span itemprop="name">dynload_overview: Dynamic loading of extension nodes when coin tries to get hold of a node type object (sotype) for a class based on the name string of the node type, it will - if no such node type has been initialized yet - scan the file system for a dynamically loadable extension node with that given name. this can be completely disabled by setting the environment variable coin_no_sotype_dynload to a positive integer value, new from coin v2.5.0.  on unix, extensions nodes are regular .so files. on win32, extension nodes are built as dlls. on mac os x systems, extension nodes are built as .dylib files. (note: the extension nodes have to be built using the flag '-dynamiclib', not '-bundle'.)  whether the dynamically loadable objects should be named with or without the 'lib' prefix is optional. both schemes will work.  people don't usually program in a way so that they instantiate new nodes through the node class' sotype object, but that is the way nodes are created when model files are loaded. this means that for all coin applications that load model files, the custom extension nodes will automatically be supported for the model files without you having to modify their source code and rebuild the applications.  see ftp://ftp.coin3d.org/pub/coin/src/dynloadsample.tar.gz for an example using two dynamically loadable extension nodes. you only use an examiner viewer to view the two extension nodes in action.  only a limited set of c++ compilers are supported as of yet. this is because, to initialize the extension node, it is necessary to know something about how the c++ compiler mangles the initclass symbol. if we don't know that, there is no way to locate the initclass method in the library, which means the extension node can not make itself known to the type system.  if your c++ compiler is not supported, the source file to add support for a new compiler in is src/misc/cppmangle.icc. it is fairly trivial to add support for new compilers, but if you don't understand how, just ask us about it. patches with support for new compilers are of course very welcome.  see also: sotype  since: coin 2.0</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    <nav>
  <ul class="pager">
   <li class="previous"><a href="duplocale.3.html"><span aria-hidden="true">&larr;</span> duplocale.3: Duplicate a locale object</a></li>
   <li class="next"><a href="dysize.3.html">dysize.3: Get number of days for a given year <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

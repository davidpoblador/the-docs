<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libsolv-bindings: Access libsolv from perl/python/ruby</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Access libsolv from perl/python/ruby">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libsolv-bindings (3) manual">
  <meta name="twitter:description" content="Access libsolv from perl/python/ruby">
  <meta name="twitter:image" content="https://www.carta.tech/images/libsolv-doc-libsolv-bindings-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libsolv-bindings.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libsolv-bindings (3) manual" />
  <meta property="og:description" content="Access libsolv from perl/python/ruby" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libsolv-doc-libsolv-bindings-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libsolv-bindings<small> (3)</small></h1>
        <p class="lead">Access libsolv from perl/python/ruby</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libsolv-bindings.3.html">
      <span itemprop="name">libsolv-bindings: Access libsolv from perl/python/ruby</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libsolv-doc/">
      <span itemprop="name">libsolv-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libsolv-bindings.3.html">
      <span itemprop="name">libsolv-bindings: Access libsolv from perl/python/ruby</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Libsolv\(cqs language bindings offer an abstract, object orientated interface to the library. The supported languages are currently perl, python, and ruby. All example code (except in the specifics sections, of course) lists first the &ldquo;C-ish&rdquo; interface, then the syntax for perl, python, and ruby (in that order).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERL SPECIFICS</h2>
        <div class="sectioncontent">
<p>Libsolv\(cqs perl bindings can be loaded with the following statement:</p>
<pre>
<strong>use solv</strong>;
</pre>
<p>Objects are either created by calling the new() method on a class or they are returned by calling methods on other objects.</p>
<pre>
my <em>$pool</em> <strong>= solv::Pool-&gt;new()</strong>;
my <em>$repo</em> <strong>=</strong> <em>$pool</em><strong>-&gt;add_repo("my_first_repo")</strong>;
</pre>
<p>Swig encapsulates all objects as tied hashes, thus the attributes can be accessed by treating the object as standard hash reference:</p>
<pre>
<em>$pool</em><strong>-&gt;{appdata} = 42</strong>;
<strong>printf "appdata is %d&#92;n",</strong> <em>$pool</em><strong>-&gt;{appdata}</strong>;
</pre>
<p>A special exception to this are iterator objects, they are encapsulated as tied arrays so that it is possible to iterate with a for() statement:</p>
<pre>
my <em>$iter</em> <strong>=</strong> <em>$pool</em><strong>-&gt;solvables_iter()</strong>;
<strong>for my</strong> <em>$solvable</em> <strong>(</strong><em>@$iter</em><strong>) { ... }</strong>;
</pre>
<p>As a downside of this approach, iterator objects cannot have attributes.</p><p>If an array needs to be passed to a method it is usually done by reference, if a method returns an array it returns it on the stack:</p>
<pre>
my <em>@problems</em> <strong>=</strong> <em>$solver</em><strong>-&gt;solve(&#92;</strong><em>@jobs</em><strong>)</strong>;
</pre>
<p>Due to a bug in swig, stringification does not work for libsolv\(cqs objects. Instead, you have to call the object\(cqs str() method.</p>
<pre>
<strong>print</strong> <em>$dep</em><strong>-&gt;str() . "&#92;</strong><em>n</em><strong>"</strong>;
</pre>
<p>Swig implements all constants as numeric variables (instead of the more natural constant subs), so don\(cqt forget the leading &ldquo;$&rdquo; when accessing a constant. Also do not forget to prepend the namespace of the constant:</p>
<pre>
<em>$pool</em><strong>-&gt;set_flag($solv::Pool::POOL_FLAG_OBSOLETEUSESCOLORS, 1)</strong>;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PYTHON SPECIFICS</h2>
        <div class="sectioncontent">
<p>The python bindings can be loaded with:</p>
<pre>
<strong>import solv</strong>
</pre>
<p>Objects are either created by calling the constructor method for a class or they are returned by calling methods on other objects.</p>
<pre>
<em>pool</em> <strong>= solv.Pool()</strong>
<em>repo</em> <strong>=</strong> <em>pool</em><strong>.add_repo("my_first_repo")</strong>
</pre>
<p>Attributes can be accessed as usual:</p>
<pre>
<em>pool</em><strong>.appdata = 42</strong>
<strong>print "appdata is %d" % (</strong><em>pool</em><strong>.appdata)</strong>
</pre>
<p>Iterators also work as expected:</p>
<pre>
<strong>for</strong> <em>solvable</em> <strong>in</strong> <em>pool</em><strong>.solvables_iter():</strong>
</pre>
<p>Arrays are passed and returned as list objects:</p>
<pre>
<em>jobs</em> <strong>= []</strong>
<em>problems</em> <strong>=</strong> <em>solver</em><strong>.solve(</strong><em>jobs</em><strong>)</strong>
</pre>
<p>The bindings define stringification for many classes, some also have a <em>repr</em> method to ease debugging.</p>
<pre>
<strong>print</strong> <em>dep</em>
<strong>print repr(</strong><em>repo</em><strong>)</strong>
</pre>
<p>Constants are attributes of the classes:</p>
<pre>
<em>pool</em><strong>.set_flag(solv.Pool.POOL_FLAG_OBSOLETEUSESCOLORS, 1)</strong>;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RUBY SPECIFICS</h2>
        <div class="sectioncontent">
<p>The ruby bindings can be loaded with:</p>
<pre>
<strong>require &apos;solv&apos;</strong>
</pre>
<p>Objects are either created by calling the new method on a class or they are returned by calling methods on other objects. Note that all classes start with an uppercase letter in ruby, so the class is called &ldquo;Solv&rdquo;.</p>
<pre>
<em>pool</em> <strong>= Solv::Pool.new</strong>
<em>repo</em> <strong>=</strong> <em>pool</em><strong>.add_repo("my_first_repo")</strong>
</pre>
<p>Attributes can be accessed as usual:</p>
<pre>
<em>pool</em><strong>.appdata = 42</strong>
<strong>puts "appdata is #{</strong><em>pool</em><strong>.appdata}"</strong>
</pre>
<p>Iterators also work as expected:</p>
<pre>
<strong>for</strong> <em>solvable</em> <strong>in</strong> <em>pool</em><strong>.solvables_iter() do ...</strong>
</pre>
<p>Arrays are passed and returned as array objects:</p>
<pre>
<em>jobs</em> <strong>= []</strong>
<em>problems</em> <strong>=</strong> <em>solver</em><strong>.solve(</strong><em>jobs</em><strong>)</strong>
</pre>
<p>Most classes define a to_s method, so objects can be easily stringified. Many also define an inspect() method.</p>
<pre>
<strong>puts</strong> <em>dep</em>
<strong>puts</strong> <em>repo</em><strong>.inspect</strong>
</pre>
<p>Constants live in the namespace of the class they belong to:</p>
<pre>
<em>pool</em><strong>.set_flag(Solv::Pool::POOL_FLAG_OBSOLETEUSESCOLORS, 1)</strong>;
</pre>
<p>Note that boolean methods have an added trailing &ldquo;?&rdquo;, to be consistent with other ruby modules:</p>
<pre>
<strong>puts "empty</strong> <em>repo</em><strong>" if</strong> <em>repo</em><strong>.isempty?</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SOLV CLASS</h2>
        <div class="sectioncontent">
<p>This is the main namespace of the library, you cannot create objects of this type but it contains some useful constants.</p><h3>CONSTANTS</h3>
<p>Relational flag constants, the first three can be or-ed together</p><p><strong>REL_LT</strong></p><p>the &ldquo;less than&rdquo; bit</p><p><strong>REL_EQ</strong></p><p>the &ldquo;equals to&rdquo; bit</p><p><strong>REL_GT</strong></p><p>the &ldquo;greater then&rdquo; bit</p><p><strong>REL_ARCH</strong></p><p>used for relations that describe an extra architecture filter, the version part of the relation is interpreted as architecture.</p><p>Special Solvable Ids</p><p><strong>SOLVID_META</strong></p><p>Access the meta section of a repository or repodata area. This is like an extra Solvable that has the Id SOLVID_META.</p><p><strong>SOLVID_POS</strong></p><p>Use the data position stored inside of the pool instead of accessing some solvable by Id. The bindings have the Datapos objects as an abstraction mechanism, so you do not need this constant.</p><p>Constant string Ids</p><p><strong>ID_NULL</strong></p><p>Always zero</p><p><strong>ID_EMPTY</strong></p><p>Always one, describes the empty string</p><p><strong>SOLVABLE_NAME</strong></p><p>The keyname Id of the name of the solvable.</p><p><strong>...</strong></p><p>see the libsolv-constantids manpage for a list of fixed Ids.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE POOL CLASS</h2>
        <div class="sectioncontent">
<p>The pool is libsolv\(cqs central resource manager. A pool consists of Solvables, Repositories, Dependencies, each indexed by Ids.</p><h3>CLASS METHODS</h3>

<pre>
<strong>Pool *Pool()</strong>
my <em>$pool</em> <strong>= solv::Pool-&gt;new()</strong>;
<em>pool</em> <strong>= solv.Pool()</strong>
<em>pool</em> <strong>= Solv::Pool.new()</strong>
</pre>
<p>Create a new pool instance. In most cases you just need one pool. Note that the returned object "owns" the pool, i.e. if the object is freed, the pool is also freed. You can use the disown method to break this ownership relation.</p>
<h3>ATTRIBUTES</h3>

<pre>
<strong>void *appdata;</strong>                  /* read/write */
<em>$pool</em><strong>-&gt;{appdata}</strong>
<em>pool</em><strong>.appdata</strong>
<em>pool</em><strong>.appdata</strong>
</pre>
<p>Application specific data that may be used in any way by the code using the pool.</p>
<pre>
<strong>Solvable solvables[];</strong>           /* read only */
my <em>$solvable</em> <strong>=</strong> <em>$pool</em><strong>-&gt;{solvables}-&gt;[</strong><em>$solvid</em><strong>]</strong>;
<em>solvable</em> <strong>=</strong> <em>pool</em><strong>.solvables[</strong><em>solvid</em><strong>]</strong>
<em>solvable</em> <strong>=</strong> <em>pool</em><strong>.solvables[</strong><em>solvid</em><strong>]</strong>
</pre>
<p>Look up a Solvable by its id.</p>
<pre>
<strong>Repo repos[];</strong>                   /* read only */
my <em>$repo</em> <strong>=</strong> <em>$pool</em><strong>-&gt;{repos}-&gt;[</strong><em>$repoid</em><strong>]</strong>;
<em>repo</em> <strong>=</strong> <em>pool</em><strong>.repos[</strong><em>repoid</em><strong>]</strong>
<em>repo</em> <strong>=</strong> <em>pool</em><strong>.repos[</strong><em>repoid</em><strong>]</strong>
</pre>
<p>Look up a Repository by its id.</p>
<pre>
<strong>Repo *installed;</strong>                /* read/write */
<em>$pool</em><strong>-&gt;{installed} =</strong> <em>$repo</em>;
<em>pool</em><strong>.installed =</strong> <em>repo</em>
<em>pool</em><strong>.installed =</strong> <em>repo</em>
</pre>
<p>Define which repository contains all the installed packages.</p>
<pre>
<strong>const char *errstr;</strong>             /* read only */
my <em>$err</em> <strong>=</strong> <em>$pool</em><strong>-&gt;{errstr}</strong>;
<em>err</em> <strong>=</strong> <em>pool</em><strong>.errstr</strong>
<em>err</em> <strong>=</strong> <em>pool</em><strong>.errstr</strong>
</pre>
<p>Return the last error string that was stored in the pool.</p>
<h3>CONSTANTS</h3>
<p><strong>POOL_FLAG_PROMOTEEPOCH</strong></p><p>Promote the epoch of the providing dependency to the requesting dependency if it does not contain an epoch. Used at some time in old rpm versions, modern systems should never need this.</p><p><strong>POOL_FLAG_FORBIDSELFCONFLICTS</strong></p><p>Disallow the installation of packages that conflict with themselves. Debian always allows self-conflicting packages, rpm used to forbid them but switched to also allowing them recently.</p><p><strong>POOL_FLAG_OBSOLETEUSESPROVIDES</strong></p><p>Make obsolete type dependency match against provides instead of just the name and version of packages. Very old versions of rpm used the name/version, then it got switched to provides and later switched back again to just name/version.</p><p><strong>POOL_FLAG_IMPLICITOBSOLETEUSESPROVIDES</strong></p><p>An implicit obsoletes is the internal mechanism to remove the old package on an update. The default is to remove all packages with the same name, rpm-5 switched to also removing packages providing the same name.</p><p><strong>POOL_FLAG_OBSOLETEUSESCOLORS</strong></p><p>Rpm\(cqs multilib implementation (used in RedHat and Fedora) distinguishes between 32bit and 64bit packages (the terminology is that they have a different color). If obsoleteusescolors is set, packages with different colors will not obsolete each other.</p><p><strong>POOL_FLAG_IMPLICITOBSOLETEUSESCOLORS</strong></p><p>Same as POOL_FLAG_OBSOLETEUSESCOLORS, but used to find out if packages of the same name can be installed in parallel. For current Fedora systems, POOL_FLAG_OBSOLETEUSESCOLORS should be false and POOL_FLAG_IMPLICITOBSOLETEUSESCOLORS should be true (this is the default if FEDORA is defined when libsolv is compiled).</p><p><strong>POOL_FLAG_NOINSTALLEDOBSOLETES</strong></p><p>New versions of rpm consider the obsoletes of installed packages when checking for dependency, thus you may not install a package that is obsoleted by some other installed package, unless you also erase the other package.</p><p><strong>POOL_FLAG_HAVEDISTEPOCH</strong></p><p>Mandriva added a new field called distepoch that gets checked in version comparison if the epoch/version/release of two packages are the same.</p><p><strong>POOL_FLAG_NOOBSOLETESMULTIVERSION</strong></p><p>If a package is installed in multiversionmode, rpm used to ignore both the implicit obsoletes and the obsolete dependency of a package. This was changed to ignoring just the implicit obsoletes, thus you may install multiple versions of the same name, but obsoleted packages still get removed.</p><p><strong>POOL_FLAG_ADDFILEPROVIDESFILTERED</strong></p><p>Make the addfileprovides method only add files from the standard locations (i.e. the &ldquo;bin&rdquo; and &ldquo;etc&rdquo; directories). This is useful if you have only few packages that use non-standard file dependencies, but you still wand the fast speed that addfileprovides() generates.</p>
<h3>METHODS</h3>

<pre>
<strong>void free()</strong>
<em>$pool</em><strong>-&gt;free()</strong>;
<em>pool</em><strong>.free()</strong>
<em>pool</em><strong>.free()</strong>
</pre>
<p>Force a free of the pool. After this call, you must not access any object that still references the pool.</p>
<pre>
<strong>void disown()</strong>
<em>$pool</em><strong>-&gt;disown()</strong>;
<em>pool</em><strong>.disown()</strong>
<em>pool</em><strong>.disown()</strong>
</pre>
<p>Break the ownership relation betwen the binding object and the pool. After this call, the pool will not get freed even if the object goes out of scope. This also means that you must manually call the free method to free the pool data.</p>
<pre>
<strong>void setdebuglevel(int</strong> <em>level</em><strong>)</strong>
<em>$pool</em><strong>-&gt;setdebuglevel(</strong><em>$level</em><strong>)</strong>;
<em>pool</em><strong>.setdebuglevel(</strong><em>level</em><strong>)</strong>
<em>pool</em><strong>.setdebuglevel(</strong><em>level</em><strong>)</strong>
</pre>
<p>Set the debug level. A value of zero means no debug output, the higher the value, the more output is generated.</p>
<pre>
<strong>int set_flag(int</strong> <em>flag</em><strong>, int</strong> <em>value</em><strong>)</strong>
my <em>$oldvalue</em> <strong>=</strong> <em>$pool</em><strong>-&gt;set_flag(</strong><em>$flag</em><strong>,</strong> <em>$value</em><strong>)</strong>;
<em>oldvalue</em> <strong>=</strong> <em>pool</em><strong>.set_flag(</strong><em>flag</em><strong>,</strong> <em>value</em><strong>)</strong>
<em>oldvalue</em> <strong>=</strong> <em>pool</em><strong>.set_flag(</strong><em>flag</em><strong>,</strong> <em>value</em><strong>)</strong>
</pre>

<pre>
<strong>int get_flag(int</strong> <em>flag</em><strong>)</strong>
my <em>$value</em> <strong>=</strong> <em>$pool</em><strong>-&gt;get_flag(</strong><em>$flag</em><strong>)</strong>;
<em>value</em> <strong>=</strong> <em>pool</em><strong>.get_flag(</strong><em>flag</em><strong>)</strong>
<em>value</em> <strong>=</strong> <em>pool</em><strong>.get_flag(</strong><em>flag</em><strong>)</strong>
</pre>
<p>Set/get a pool specific flag. The flags define how the system works, e.g. how the package manager treats obsoletes. The default flags should be sane for most applications, but in some cases you may want to tweak a flag, for example if you want to solv package dependencies for some other system than yours.</p>
<pre>
<strong>void set_rootdir(const char *</strong><em>rootdir</em><strong>)</strong>
<em>$pool</em><strong>-&gt;set_rootdir(</strong><em>rootdir</em><strong>)</strong>;
<em>pool</em><strong>.set_rootdir(</strong><em>rootdir</em><strong>)</strong>
<em>pool</em><strong>.set_rootdir(</strong><em>rootdir</em><strong>)</strong>
</pre>

<pre>
<strong>const char *get_rootdir()</strong>
my <em>$rootdir</em> <strong>=</strong> <em>$pool</em><strong>-&gt;get_rootdir()</strong>;
<em>rootdir</em> <strong>=</strong> <em>pool</em><strong>.get_rootdir()</strong>
<em>rootdir</em> <strong>=</strong> <em>pool</em><strong>.get_rootdir()</strong>
</pre>
<p>Set/get the rootdir to use. This is useful if you want package management to work only in some directory, for example if you want to setup a chroot jail. Note that the rootdir will only be prepended to file paths if the <strong>REPO_USE_ROOTDIR</strong> flag is used.</p>
<pre>
<strong>void setarch(const char *</strong><em>arch</em> <strong>= 0)</strong>
<em>$pool</em><strong>-&gt;setarch()</strong>;
<em>pool</em><strong>.setarch()</strong>
<em>pool</em><strong>.setarch()</strong>
</pre>
<p>Set the architecture for your system. The architecture is used to determine which packages are installable. It defaults to the result of &ldquo;uname -m&rdquo;.</p>
<pre>
<strong>Repo add_repo(const char *</strong><em>name</em><strong>)</strong>
<em>$repo</em> <strong>=</strong> <em>$pool</em><strong>-&gt;add_repo(</strong><em>$name</em><strong>)</strong>;
<em>repo</em> <strong>=</strong> <em>pool</em><strong>.add_repo(</strong><em>name</em><strong>)</strong>
<em>repo</em> <strong>=</strong> <em>pool</em><strong>.add_repo(</strong><em>name</em><strong>)</strong>
</pre>
<p>Add a Repository with the specified name to the pool. The repository is empty on creation, use the repository methods to populate it with packages.</p>
<pre>
<strong>Repoiterator repos_iter()</strong>
<strong>for my</strong> <em>$repo</em> <strong>(</strong><em>@</em><strong>{</strong><em>$pool</em><strong>-&gt;repos_iter()})</strong>
<strong>for</strong> <em>repo</em> <strong>in</strong> <em>pool</em><strong>.repos_iter():</strong>
<strong>for</strong> <em>repo</em> <strong>in</strong> <em>pool</em><strong>.repos_iter()</strong>
</pre>
<p>Iterate over the existing repositories.</p>
<pre>
<strong>Solvableiterator solvables_iter()</strong>
<strong>for my</strong> <em>$solvable</em> <strong>(</strong><em>@</em><strong>{</strong><em>$pool</em><strong>-&gt;solvables_iter()})</strong>
<strong>for</strong> <em>solvable</em> <strong>in</strong> <em>pool</em><strong>.solvables_iter():</strong>
<strong>for</strong> <em>solvable</em> <strong>in</strong> <em>pool</em><strong>.solvables_iter()</strong>
</pre>
<p>Iterate over the existing solvables.</p>
<pre>
<strong>Dep Dep(const char *</strong><em>str</em><strong>, bool</strong> <em>create</em> <strong>= 1)</strong>
my <em>$dep</em> <strong>=</strong> <em>$pool</em><strong>-&gt;Dep(</strong><em>$string</em><strong>)</strong>;
<em>dep</em> <strong>=</strong> <em>pool</em><strong>.Dep(</strong><em>string</em><strong>)</strong>
<em>dep</em> <strong>=</strong> <em>pool</em><strong>.Dep(</strong><em>string</em><strong>)</strong>
</pre>
<p>Create an object describing a string or dependency. If the string is currently not in the pool and <em>create</em> is false, <strong>undef</strong>/<strong>None</strong>/<strong>nil</strong> is returned.</p>
<pre>
<strong>void addfileprovides()</strong>
<em>$pool</em><strong>-&gt;addfileprovides()</strong>;
<em>pool</em><strong>.addfileprovides()</strong>
<em>pool</em><strong>.addfileprovides()</strong>
</pre>

<pre>
<strong>Id *addfileprovides_queue()</strong>
my <em>@ids</em> <strong>=</strong> <em>$pool</em><strong>-&gt;addfileprovides_queue()</strong>;
<em>ids</em> <strong>=</strong> <em>pool</em><strong>.addfileprovides_queue()</strong>
<em>ids</em> <strong>=</strong> <em>pool</em><strong>.addfileprovides_queue()</strong>
</pre>
<p>Some package managers like rpm allow dependencies on files contained in other packages. To allow libsolv to deal with those dependencies in an efficient way, you need to call the addfileprovides method after creating and reading all repositories. This method will scan all dependency for file names and than scan all packages for matching files. If a filename has been matched, it will be added to the provides list of the corresponding package. The addfileprovides_queue variant works the same way but returns an array containing all file dependencies. This information can be stored in the meta section of the repositories to speed up the next time the repository is loaded and addfileprovides is called.</p>
<pre>
<strong>void createwhatprovides()</strong>
<em>$pool</em><strong>-&gt;createwhatprovides()</strong>;
<em>pool</em><strong>.createwhatprovides()</strong>
<em>pool</em><strong>.createwhatprovides()</strong>
</pre>
<p>Create the internal &ldquo;whatprovides&rdquo; hash over all of the provides of all packages. This method must be called before doing any lookups on provides. It\(cqs encouraged to do it right after all repos are set up, usually right after the call to addfileprovides().</p>
<pre>
<strong>Solvable *whatprovides(DepId</strong> <em>dep</em><strong>)</strong>
my <em>@solvables</em> <strong>=</strong> <em>$pool</em><strong>-&gt;whatprovides(</strong><em>$dep</em><strong>)</strong>;
<em>solvables</em> <strong>=</strong> <em>pool</em><strong>.whatprovides(</strong><em>dep</em><strong>)</strong>
<em>solvables</em> <strong>=</strong> <em>pool</em><strong>.whatprovides(</strong><em>dep</em><strong>)</strong>
</pre>
<p>Return all solvables that provide the specified dependency. You can use either a Dep object or an simple Id as argument.</p>
<pre>
<strong>Id *matchprovidingids(const char *</strong><em>match</em><strong>, int</strong> <em>flags</em><strong>)</strong>
my <em>@ids</em> <strong>=</strong> <em>$pool</em><strong>-&gt;matchprovidingids(</strong><em>$match</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>ids</em> <strong>=</strong> <em>pool</em><strong>.matchprovidingids(</strong><em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>ids</em> <strong>=</strong> <em>pool</em><strong>.matchprovidingids(</strong><em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>
<p>Search the names of all provides and return the ones matching the specified string. See the Dataiterator class for the allowed flags.</p>
<pre>
<strong>Id towhatprovides(Id *</strong><em>ids</em><strong>)</strong>
my <em>$offset</em> <strong>=</strong> <em>$pool</em><strong>-&gt;towhatprovides(&#92;</strong><em>@ids</em><strong>)</strong>;
<em>offset</em> <strong>=</strong> <em>pool</em><strong>.towhatprovides(</strong><em>ids</em><strong>)</strong>
<em>offset</em> <strong>=</strong> <em>pool</em><strong>.towhatprovides(</strong><em>ids</em><strong>)</strong>
</pre>
<p>&ldquo;Internalize&rdquo; an array containing Ids. The returned value can be used to create solver jobs working on a specific set of packages. See the Solver class for more information.</p>
<pre>
<strong>bool isknownarch(DepId</strong> <em>id</em><strong>)</strong>
my <em>$bool</em> <strong>=</strong> <em>$pool</em><strong>-&gt;isknownarch(</strong><em>$id</em><strong>)</strong>;
<em>bool</em> <strong>=</strong> <em>pool</em><strong>.isknownarch(</strong><em>id</em><strong>)</strong>
<em>bool</em> <strong>=</strong> <em>pool</em><strong>.isknownarch?(</strong><em>id</em><strong>)</strong>
</pre>
<p>Return true if the specified Id describes a known architecture.</p>
<pre>
<strong>Solver Solver()</strong>
my <em>$solver</em> <strong>=</strong> <em>$pool</em><strong>-&gt;Solver()</strong>;
<em>solver</em> <strong>=</strong> <em>pool</em><strong>.Solver()</strong>
<em>solver</em> <strong>=</strong> <em>pool</em><strong>.Solver()</strong>
</pre>
<p>Create a new solver object.</p>
<pre>
<strong>Job Job(int</strong> <em>how</em><strong>, Id</strong> <em>what</em><strong>)</strong>
my <em>$job</em> <strong>=</strong> <em>$pool</em><strong>-&gt;Job(</strong><em>$how</em><strong>,</strong> <em>$what</em><strong>)</strong>;
<em>job</em> <strong>=</strong> <em>pool</em><strong>.Job(</strong><em>how</em><strong>,</strong> <em>what</em><strong>)</strong>
<em>job</em> <strong>=</strong> <em>pool</em><strong>.Job(</strong><em>how</em><strong>,</strong> <em>what</em><strong>)</strong>
</pre>
<p>Create a new Job object. Kind of low level, in most cases you would use a Selection or Dep job constructor instead.</p>
<pre>
<strong>Selection Selection()</strong>
my <em>$sel</em> <strong>=</strong> <em>$pool</em><strong>-&gt;Selection()</strong>;
<em>sel</em> <strong>=</strong> <em>pool</em><strong>.Selection()</strong>
<em>sel</em> <strong>=</strong> <em>pool</em><strong>.Selection()</strong>
</pre>
<p>Create an empty selection. Useful as a starting point for merging other selections.</p>
<pre>
<strong>Selection Selection_all()</strong>
my <em>$sel</em> <strong>=</strong> <em>$pool</em><strong>-&gt;Selection_all()</strong>;
<em>sel</em> <strong>=</strong> <em>pool</em><strong>.Selection_all()</strong>
<em>sel</em> <strong>=</strong> <em>pool</em><strong>.Selection_all()</strong>
</pre>
<p>Create a selection containing all packages. Useful as starting point for intersecting other selections or for update/distupgrade jobs.</p>
<pre>
<strong>Selection select(const char *</strong><em>name</em><strong>, int</strong> <em>flags</em><strong>)</strong>
my <em>$sel</em> <strong>=</strong> <em>$pool</em><strong>-&gt;select(</strong><em>$name</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>sel</em> <strong>=</strong> <em>pool</em><strong>.select(</strong><em>name</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>sel</em> <strong>=</strong> <em>pool</em><strong>.select(</strong><em>name</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>
<p>Create a selection by matching packages against the specified string. See the Selection class for a list of flags and how to create solver jobs from a selection.</p>
<pre>
<strong>void setpooljobs(Jobs *</strong><em>jobs</em><strong>)</strong>
<em>$pool</em><strong>-&gt;setpooljobs(&#92;</strong><em>@jobs</em><strong>)</strong>;
<em>pool</em><strong>.setpooljobs(</strong><em>jobs</em><strong>)</strong>
<em>pool</em><strong>.setpooljobs(</strong><em>jobs</em><strong>)</strong>
</pre>

<pre>
<strong>Job *getpooljobs()</strong>
<em>@jobs</em> <strong>=</strong> <em>$pool</em><strong>-&gt;getpooljobs()</strong>;
<em>jobs</em> <strong>=</strong> <em>pool</em><strong>.getpooljobs()</strong>
<em>jobs</em> <strong>=</strong> <em>pool</em><strong>.getpooljobs()</strong>
</pre>
<p>Get/Set fixed jobs stored in the pool. Those jobs are automatically appended to all solver jobs, they are meant for fixed configurations like which packages can be multiversion installed, which packages were userinstalled or must not be erased.</p>
<pre>
<strong>void set_loadcallback(Callable *</strong><em>callback</em><strong>)</strong>
<em>$pool</em><strong>-&gt;setloadcallback(&#92;</strong><em>&callbackfunction</em><strong>)</strong>;
<em>pool</em><strong>.setloadcallback(</strong><em>callbackfunction</em><strong>)</strong>
<em>pool</em><strong>.setloadcallback { |</strong><em>repodata</em><strong>| ... }</strong>
</pre>
<p>Set the callback function called when repository metadata needs to be loaded on demand. To make use of this feature, you need to create repodata stubs that tell the library which data is available but not loaded. If later on the data needs to be accessed, the callback function is called with a repodata argument. You can then load the data (maybe fetching it first from an remote server). The callback should return true if the data has been made available.</p>
<h3>DATA RETRIEVAL METHODS</h3>
<p>In the following functions, the <em>keyname</em> argument describes what to retrieve. For the standard cases you can use the available Id constants. For example,</p>
<pre>
<strong>$solv::SOLVABLE_SUMMARY</strong>
<strong>solv.SOLVABLE_SUMMARY</strong>
<strong>Solv::SOLVABLE_SUMMARY</strong>
</pre>
<p>selects the &ldquo;Summary&rdquo; entry of a solvable. The <em>solvid</em> argument selects the desired solvable by Id.</p>
<pre>
<strong>const char *lookup_str(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>$string</em> <strong>=</strong> <em>$pool</em><strong>-&gt;lookup_str(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>string</em> <strong>=</strong> <em>pool</em><strong>.lookup_str(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>string</em> <strong>=</strong> <em>pool</em><strong>.lookup_str(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Id lookup_id(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>$id</em> <strong>=</strong> <em>$pool</em><strong>-&gt;lookup_id(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>id</em> <strong>=</strong> <em>pool</em><strong>.lookup_id(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>id</em> <strong>=</strong> <em>pool</em><strong>.lookup_id(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>unsigned long long lookup_num(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, unsigned long long</strong> <em>notfound</em> <strong>= 0)</strong>
my <em>$num</em> <strong>=</strong> <em>$pool</em><strong>-&gt;lookup_num(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>num</em> <strong>=</strong> <em>pool</em><strong>.lookup_num(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>num</em> <strong>=</strong> <em>pool</em><strong>.lookup_num(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>bool lookup_void(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>$bool</em> <strong>=</strong> <em>$pool</em><strong>-&gt;lookup_void(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>bool</em> <strong>=</strong> <em>pool</em><strong>.lookup_void(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>bool</em> <strong>=</strong> <em>pool</em><strong>.lookup_void(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Id *lookup_idarray(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>@ids</em> <strong>=</strong> <em>$pool</em><strong>-&gt;lookup_idarray(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>ids</em> <strong>=</strong> <em>pool</em><strong>.lookup_idarray(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>ids</em> <strong>=</strong> <em>pool</em><strong>.lookup_idarray(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Chksum lookup_checksum(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>$chksum</em> <strong>=</strong> <em>$pool</em><strong>-&gt;lookup_checksum(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>chksum</em> <strong>=</strong> <em>pool</em><strong>.lookup_checksum(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>chksum</em> <strong>=</strong> <em>pool</em><strong>.lookup_checksum(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>
<p>Lookup functions. Return the data element stored in the specified solvable. You should probably use the methods of the Solvable class instead.</p>
<pre>
<strong>Dataiterator Dataiterator(Id</strong> <em>keyname</em><strong>, const char *</strong><em>match</em> <strong>= 0, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$di</em> <strong>=</strong> <em>$pool</em><strong>-&gt;Dataiterator(</strong><em>$keyname</em><strong>,</strong> <em>$match</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>di</em> <strong>=</strong> <em>pool</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>di</em> <strong>=</strong> <em>pool</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>

<pre>
<strong>Dataiterator Dataiterator_solvid(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, const char *</strong><em>match</em> <strong>= 0, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$di</em> <strong>=</strong> <em>$pool</em><strong>-&gt;Dataiterator(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>,</strong> <em>$match</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>di</em> <strong>=</strong> <em>pool</em><strong>.Dataiterator(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>di</em> <strong>=</strong> <em>pool</em><strong>.Dataiterator(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>

<pre>
<strong>for my</strong> <em>$d</em> <strong>(</strong><em>@$di</em><strong>)</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em><strong>:</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em>
</pre>
<p>Iterate over the matching data elements. See the Dataiterator class for more information. The Dataiterator method iterates over all solvables in the pool, whereas the Dataiterator_solvid only iterates over the specified solvable.</p>
<h3>ID METHODS</h3>
<p>The following methods deal with Ids, i.e. integers representing objects in the pool. They are considered &ldquo;low level&rdquo;, in most cases you would not use them but instead the object orientated methods.</p>
<pre>
<strong>Repo id2repo(Id</strong> <em>id</em><strong>)</strong>
<em>$repo</em> <strong>=</strong> <em>$pool</em><strong>-&gt;id2repo(</strong><em>$id</em><strong>)</strong>;
<em>repo</em> <strong>=</strong> <em>pool</em><strong>.id2repo(</strong><em>id</em><strong>)</strong>
<em>repo</em> <strong>=</strong> <em>pool</em><strong>.id2repo(</strong><em>id</em><strong>)</strong>
</pre>
<p>Lookup an existing Repository by id. You can also do this by using the <strong>repos</strong> attribute.</p>
<pre>
<strong>Solvable id2solvable(Id</strong> <em>id</em><strong>)</strong>
<em>$solvable</em> <strong>=</strong> <em>$pool</em><strong>-&gt;id2solvable(</strong><em>$id</em><strong>)</strong>;
<em>solvable</em> <strong>=</strong> <em>pool</em><strong>.id2solvable(</strong><em>id</em><strong>)</strong>
<em>solvable</em> <strong>=</strong> <em>pool</em><strong>.id2solvable(</strong><em>id</em><strong>)</strong>
</pre>
<p>Lookup an existing Repository by id. You can also do this by using the <strong>solvables</strong> attribute.</p>
<pre>
<strong>const char *solvid2str(Id</strong> <em>id</em><strong>)</strong>
my <em>$str</em> <strong>=</strong> <em>$pool</em><strong>-&gt;solvid2str(</strong><em>$id</em><strong>)</strong>;
<em>str</em> <strong>=</strong> <em>pool</em><strong>.solvid2str(</strong><em>id</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>pool</em><strong>.solvid2str(</strong><em>id</em><strong>)</strong>
</pre>
<p>Return a string describing the Solvable with the specified id. The string consists of the name, version, and architecture of the Solvable.</p>
<pre>
<strong>Id str2id(const char *</strong><em>str</em><strong>, bool</strong> <em>create</em> <strong>= 1)</strong>
my <em>$id</em> <strong>=</strong> <em>pool</em><strong>-&gt;str2id(</strong><em>$string</em><strong>)</strong>;
<em>id</em> <strong>=</strong> <em>pool</em><strong>.str2id(</strong><em>string</em><strong>)</strong>
<em>id</em> <strong>=</strong> <em>pool</em><strong>.str2id(</strong><em>string</em><strong>)</strong>
</pre>

<pre>
<strong>const char *id2str(Id</strong> <em>id</em><strong>)</strong>
<em>$string</em> <strong>=</strong> <em>pool</em><strong>-&gt;id2str(</strong><em>$id</em><strong>)</strong>;
<em>string</em> <strong>=</strong> <em>pool</em><strong>.id2str(</strong><em>id</em><strong>)</strong>
<em>string</em> <strong>=</strong> <em>pool</em><strong>.id2str(</strong><em>id</em><strong>)</strong>
</pre>
<p>Convert a string into an Id and back. If the string is currently not in the pool and <em>create</em> is false, zero is returned.</p>
<pre>
<strong>Id rel2id(Id</strong> <em>name</em><strong>, Id</strong> <em>evr</em><strong>, int</strong> <em>flags</em><strong>, bool</strong> <em>create</em> <strong>= 1)</strong>
my <em>$id</em> <strong>=</strong> <em>pool</em><strong>-&gt;rel2id(</strong><em>$nameid</em><strong>,</strong> <em>$evrid</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>id</em> <strong>=</strong> <em>pool</em><strong>.rel2id(</strong><em>nameid</em><strong>,</strong> <em>evrid</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>id</em> <strong>=</strong> <em>pool</em><strong>.rel2id(</strong><em>nameid</em><strong>,</strong> <em>evrid</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>
<p>Create a &ldquo;relational&rdquo; dependency. Such dependencies consist of a name part, the <em>flags</em> describing the relation, and a version part. The flags are:</p>
<pre>
<strong>$solv::REL_EQ | $solv::REL_GT | $solv::REL_LT</strong>
<strong>solv.REL_EQ | solv.REL_GT | solv.REL_LT</strong>
<strong>Solv::REL_EQ | Solv::REL_GT | Solv::REL_LT</strong>
</pre>
<p>Thus, if you want a &ldquo;&lt;=&rdquo; relation, you would use <strong>REL_LT | REL_EQ</strong>.</p>
<pre>
<strong>Id id2langid(Id</strong> <em>id</em><strong>, const char *</strong><em>lang</em><strong>, bool</strong> <em>create</em> <strong>= 1)</strong>
my <em>$id</em> <strong>=</strong> <em>$pool</em><strong>-&gt;id2langid(</strong><em>$id</em><strong>,</strong> <em>$language</em><strong>)</strong>;
<em>id</em> <strong>=</strong> <em>pool</em><strong>.id2langid(</strong><em>id</em><strong>,</strong> <em>language</em><strong>)</strong>
<em>id</em> <strong>=</strong> <em>pool</em><strong>.id2langid(</strong><em>id</em><strong>,</strong> <em>language</em><strong>)</strong>
</pre>
<p>Create a language specific Id from some other id. This function simply converts the id into a string, appends a dot and the specified language to the string and converts the result back into an Id.</p>
<pre>
<strong>const char *dep2str(Id</strong> <em>id</em><strong>)</strong>
<em>$string</em> <strong>=</strong> <em>pool</em><strong>-&gt;dep2str(</strong><em>$id</em><strong>)</strong>;
<em>string</em> <strong>=</strong> <em>pool</em><strong>.dep2str(</strong><em>id</em><strong>)</strong>
<em>string</em> <strong>=</strong> <em>pool</em><strong>.dep2str(</strong><em>id</em><strong>)</strong>
</pre>
<p>Convert a dependency id into a string. If the id is just a string, this function has the same effect as id2str(). For relational dependencies, the result is the correct &ldquo;name relation evr&rdquo; string.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE DEPENDENCY CLASS</h2>
        <div class="sectioncontent">
<p>The dependency class is an object orientated way to work with strings and dependencies. Internally, dependencies are represented as Ids, i.e. simple numbers. Dependency objects can be constructed by using the Pool\(cqs Dep() method.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Pool *pool;</strong>             /* read only */
<em>$dep</em><strong>-&gt;{pool}</strong>
<em>dep</em><strong>.pool</strong>
<em>dep</em><strong>.pool</strong>
</pre>
<p>Back reference to the pool this dependency belongs to.</p>
<pre>
<strong>Id id;</strong>          /* read only */
<em>$dep</em><strong>-&gt;{id}</strong>
<em>dep</em><strong>.id</strong>
<em>dep</em><strong>.id</strong>
</pre>
<p>The id of this dependency.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<pre>
<strong>Dep Rel(int</strong> <em>flags</em><strong>, DepId</strong> <em>evrid</em><strong>, bool</strong> <em>create</em> <strong>= 1)</strong>
my <em>$reldep</em> <strong>=</strong> <em>$dep</em><strong>-&gt;Rel(</strong><em>$flags</em><strong>,</strong> <em>$evrdep</em><strong>)</strong>;
<em>reldep</em> <strong>=</strong> <em>dep</em><strong>.Rel(</strong><em>flags</em><strong>,</strong> <em>evrdep</em><strong>)</strong>
<em>reldep</em> <strong>=</strong> <em>dep</em><strong>.Rel(</strong><em>flags</em><strong>,</strong> <em>evrdep</em><strong>)</strong>
</pre>
<p>Create a relational dependency from to string dependencies and a flags argument. See the pool\(cqs rel2id method for a description of the flags.</p>
<pre>
<strong>Selection Selection_name(int</strong> <em>setflags</em> <strong>= 0)</strong>
my <em>$sel</em> <strong>=</strong> <em>$dep</em><strong>-&gt;Selection_name()</strong>;
<em>sel</em> <strong>=</strong> <em>dep</em><strong>.Selection_name()</strong>
<em>sel</em> <strong>=</strong> <em>dep</em><strong>.Selection_name()</strong>
</pre>
<p>Create a Selection from a dependency. The selection consists of all packages that have a name equal to the dependency. If the dependency is of a relational type, the packages version must also fulfill the dependency.</p>
<pre>
<strong>Selection Selection_provides(int</strong> <em>setflags</em> <strong>= 0)</strong>
my <em>$sel</em> <strong>=</strong> <em>$dep</em><strong>-&gt;Selection_provides()</strong>;
<em>sel</em> <strong>=</strong> <em>dep</em><strong>.Selection_provides()</strong>
<em>sel</em> <strong>=</strong> <em>dep</em><strong>.Selection_provides()</strong>
</pre>
<p>Create a Selection from a dependency. The selection consists of all packages that have at least one provides matching the dependency.</p>
<pre>
<strong>const char *str()</strong>
my <em>$str</em> <strong>=</strong> <em>$dep</em><strong>-&gt;str()</strong>;
<em>str</em> <strong>=</strong> <em>$dep</em><strong>.str()</strong>
<em>str</em> <strong>=</strong> <em>$dep</em><strong>.str()</strong>
</pre>
<p>Return a string describing the dependency.</p>
<pre>
<strong>&lt;stringification&gt;</strong>
my <em>$str</em> <strong>=</strong> <em>$dep</em><strong>-&gt;str</strong>;
<em>str</em> <strong>= str(</strong><em>dep</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>dep</em><strong>.to_s</strong>
</pre>
<p>Same as calling the str() method.</p>
<pre>
<strong>&lt;equality&gt;</strong>
<strong>if (</strong><em>$dep1</em> <strong>==</strong> <em>$dep2</em><strong>)</strong>
<strong>if</strong> <em>dep1</em> <strong>==</strong> <em>dep2</em><strong>:</strong>
<strong>if</strong> <em>dep1</em> <strong>==</strong> <em>dep2</em>
</pre>
<p>The dependencies are equal if they are part of the same pool and have the same ids.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE REPOSITORY CLASS</h2>
        <div class="sectioncontent">
<p>A Repository describes a group of packages, normally coming from the same source. Repositories are created by the Pool\(cqs add_repo() method.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Pool *pool;</strong>                     /* read only */
<em>$repo</em><strong>-&gt;{pool}</strong>
<em>repo</em><strong>.pool</strong>
<em>repo</em><strong>.pool</strong>
</pre>
<p>Back reference to the pool this dependency belongs to.</p>
<pre>
<strong>Id id;</strong>                          /* read only */
<em>$repo</em><strong>-&gt;{id}</strong>
<em>repo</em><strong>.id</strong>
<em>repo</em><strong>.id</strong>
</pre>
<p>The id of the repository.</p>
<pre>
<strong>const char *name;</strong>               /* read/write */
<em>$repo</em><strong>-&gt;{name}</strong>
<em>repo</em><strong>.name</strong>
<em>repo</em><strong>.name</strong>
</pre>
<p>The repositories name. To libsolv, the name is just a string with no specific meaning.</p>
<pre>
<strong>int priority;</strong>                   /* read/write */
<em>$repo</em><strong>-&gt;{priority}</strong>
<em>repo</em><strong>.priority</strong>
<em>repo</em><strong>.priority</strong>
</pre>
<p>The priority of the repository. A higher number means that packages of this repository will be chosen over other repositories, even if they have a greater package version.</p>
<pre>
<strong>int subpriority;</strong>                /* read/write */
<em>$repo</em><strong>-&gt;{subpriority}</strong>
<em>repo</em><strong>.subpriority</strong>
<em>repo</em><strong>.subpriority</strong>
</pre>
<p>The sub-priority of the repository. This value is compared when the priorities of two repositories are the same. It is useful to make the library prefer on-disk repositories to remote ones.</p>
<pre>
<strong>int nsolvables;</strong>                 /* read only */
<em>$repo</em><strong>-&gt;{nsolvables}</strong>
<em>repo</em><strong>.nsolvables</strong>
<em>repo</em><strong>.nsolvables</strong>
</pre>
<p>The number of solvables in this repository.</p>
<pre>
<strong>void *appdata;</strong>                  /* read/write */
<em>$repo</em><strong>-&gt;{appdata}</strong>
<em>repo</em><strong>.appdata</strong>
<em>repo</em><strong>.appdata</strong>
</pre>
<p>Application specific data that may be used in any way by the code using the repository.</p>
<pre>
<strong>Datapos *meta;</strong>                  /* read only */
<em>$repo</em><strong>-&gt;{meta}</strong>
<em>repo</em><strong>.meta</strong>
<em>repo</em><strong>.meta</strong>
</pre>
<p>Return a Datapos object of the repodata\(cqs metadata. You can use the lookup methods of the Datapos class to lookup metadata attributes, like the repository timestamp.</p>
<h3>CONSTANTS</h3>
<p><strong>REPO_REUSE_REPODATA</strong></p><p>Reuse the last repository data area (&ldquo;repodata&rdquo;) instead of creating a new one.</p><p><strong>REPO_NO_INTERNALIZE</strong></p><p>Do not internalize the added repository data. This is useful if you plan to add more data because internalization is a costly operation.</p><p><strong>REPO_LOCALPOOL</strong></p><p>Use the repodata\(cqs pool for Id storage instead of the global pool. Useful if you don\(cqt want to pollute the global pool with many unneeded ids, like when storing the filelist.</p><p><strong>REPO_USE_LOADING</strong></p><p>Use the repodata that is currently being loaded instead of creating a new one. This only makes sense if used in a load callback.</p><p><strong>REPO_EXTEND_SOLVABLES</strong></p><p>Do not create new solvables for the new data, but match existing solvables and add the data to them. Repository metadata is often split into multiple parts, with one primary file describing all packages and other parts holding information that is normally not needed, like the changelog.</p><p><strong>REPO_USE_ROOTDIR</strong></p><p>Prepend the pool\(cqs rootdir to the path when doing file operations.</p><p><strong>REPO_NO_LOCATION</strong></p><p>Do not add a location element to the solvables. Useful if the solvables are not in the final position, so you can add the correct location later in your code.</p><p><strong>SOLV_ADD_NO_STUBS</strong></p><p>Do not create stubs for repository parts that can be downloaded on demand.</p><p><strong>SUSETAGS_RECORD_SHARES</strong></p><p>This is specific to the add_susetags() method. Susetags allows one to refer to already read packages to save disk space. If this data sharing needs to work over multiple calls to add_susetags, you need to specify this flag so that the share information is made available to subsequent calls.</p>
<h3>METHODS</h3>

<pre>
<strong>void free(bool</strong> <em>reuseids</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;free()</strong>;
<em>repo</em><strong>.free()</strong>
<em>repo</em><strong>.free()</strong>
</pre>
<p>Free the repository and all solvables it contains. If <em>reuseids</em> is set to true, the solvable ids and the repository id may be reused by the library when added new solvables. Thus you should leave it false if you are not sure that somebody holds a reference.</p>
<pre>
<strong>void empty(bool</strong> <em>reuseids</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;empty()</strong>;
<em>repo</em><strong>.empty()</strong>
<em>repo</em><strong>.empty()</strong>
</pre>
<p>Free all the solvables in a repository. The repository will be empty after this call. See the free() method for the meaning of <em>reuseids</em>.</p>
<pre>
<strong>bool isempty()</strong>
<em>$repo</em><strong>-&gt;isempty()</strong>
<em>repo</em><strong>.empty()</strong>
<em>repo</em><strong>.empty?</strong>
</pre>
<p>Return true if there are no solvables in this repository.</p>
<pre>
<strong>void internalize()</strong>
<em>$repo</em><strong>-&gt;internalize()</strong>;
<em>repo</em><strong>.internalize()</strong>
<em>repo</em><strong>.internalize()</strong>
</pre>
<p>Internalize added data. Data must be internalized before it is available to the lookup and data iterator functions.</p>
<pre>
<strong>bool write(FILE *</strong><em>fp</em><strong>)</strong>
<em>$repo</em><strong>-&gt;write(</strong><em>$fp</em><strong>)</strong>
<em>repo</em><strong>.write(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.write(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Write a repo as a &ldquo;solv&rdquo; file. These files can be read very fast and thus are a good way to cache repository data. Returns false if there was some error writing the file.</p>
<pre>
<strong>Solvableiterator solvables_iter()</strong>
<strong>for my</strong> <em>$solvable</em> <strong>(</strong><em>@</em><strong>{</strong><em>$repo</em><strong>-&gt;solvables_iter()})</strong>
<strong>for</strong> <em>solvable</em> <strong>in</strong> <em>repo</em><strong>.solvables_iter():</strong>
<strong>for</strong> <em>solvable</em> <strong>in</strong> <em>repo</em><strong>.solvables_iter()</strong>
</pre>
<p>Iterate over all solvables in a repository.</p>
<pre>
<strong>Repodata add_repodata(int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$repodata</em> <strong>=</strong> <em>$repo</em><strong>-&gt;add_repodata()</strong>;
<em>repodata</em> <strong>=</strong> <em>repo</em><strong>.add_repodata()</strong>
<em>repodata</em> <strong>=</strong> <em>repo</em><strong>.add_repodata()</strong>
</pre>
<p>Add a new repodata area to the repository. This is normally automatically done by the repo_add methods, so you need this method only in very rare circumstances.</p>
<pre>
<strong>void create_stubs()</strong>
<em>$repo</em><strong>-&gt;create_stubs()</strong>;
<em>repo</em><strong>.create_stubs()</strong>
<em>repo</em><strong>.create_stubs()</strong>
</pre>
<p>Calls the create_stubs() repodata method for the last repodata of the repository.</p>
<pre>
<strong>bool iscontiguous()</strong>
<em>$repo</em><strong>-&gt;iscontiguous()</strong>
<em>repo</em><strong>.iscontiguous()</strong>
<em>repo</em><strong>.iscontiguous?</strong>
</pre>
<p>Return true if the solvables of this repository are all in a single block with no holes, i.e. they have consecutive ids.</p>
<pre>
<strong>Repodata first_repodata()</strong>
my <em>$repodata</em> <strong>=</strong> <em>$repo</em><strong>-&gt;first_repodata()</strong>;
<em>repodata</em> <strong>=</strong> <em>repo</em><strong>.first_repodata()</strong>
<em>repodata</em> <strong>=</strong> <em>repo</em><strong>.first_repodata()</strong>
</pre>
<p>Checks if all repodatas but the first repodata are extensions, and return the first repodata if this is the case. Useful if you want to do a store/retrieve sequence on the repository to reduce the memory using and enable paging, as this does not work if the repository contains multiple non-extension repodata areas.</p>
<pre>
<strong>Selection Selection(int</strong> <em>setflags</em> <strong>= 0)</strong>
my <em>$sel</em> <strong>=</strong> <em>$repo</em><strong>-&gt;Selection()</strong>;
<em>sel</em> <strong>=</strong> <em>repo</em><strong>.Selection()</strong>
<em>sel</em> <strong>=</strong> <em>repo</em><strong>.Selection()</strong>
</pre>
<p>Create a Selection consisting of all packages in the repository.</p>
<pre>
<strong>Dataiterator Dataiterator(Id</strong> <em>key</em><strong>, const char *</strong><em>match</em> <strong>= 0, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$di</em> <strong>=</strong> <em>$repo</em><strong>-&gt;Dataiterator(</strong><em>$keyname</em><strong>,</strong> <em>$match</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>di</em> <strong>=</strong> <em>repo</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>di</em> <strong>=</strong> <em>repo</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>

<pre>
<strong>Dataiterator Dataiterator_meta(Id</strong> <em>key</em><strong>, const char *</strong><em>match</em> <strong>= 0, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$di</em> <strong>=</strong> <em>$repo</em><strong>-&gt;Dataiterator_meta(</strong><em>$keyname</em><strong>,</strong> <em>$match</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>di</em> <strong>=</strong> <em>repo</em><strong>.Dataiterator_meta(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>di</em> <strong>=</strong> <em>repo</em><strong>.Dataiterator_meta(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>

<pre>
<strong>for my</strong> <em>$d</em> <strong>(</strong><em>@$di</em><strong>)</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em><strong>:</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em>
</pre>
<p>Iterate over the matching data elements in this repository. See the Dataiterator class for more information. The Dataiterator() method iterates over all solvables in a repository, whereas the Dataiterator_meta method only iterates over the repository\(cqs meta data.</p>
<pre>
<strong>&lt;stringification&gt;</strong>
my <em>$str</em> <strong>=</strong> <em>$repo</em><strong>-&gt;str</strong>;
<em>str</em> <strong>= str(</strong><em>repo</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>repo</em><strong>.to_s</strong>
</pre>
<p>Return the name of the repository, or "Repo#&lt;id&gt;" if no name is set.</p>
<pre>
<strong>&lt;equality&gt;</strong>
<strong>if (</strong><em>$repo1</em> <strong>==</strong> <em>$repo2</em><strong>)</strong>
<strong>if</strong> <em>repo1</em> <strong>==</strong> <em>repo2</em><strong>:</strong>
<strong>if</strong> <em>repo1</em> <strong>==</strong> <em>repo2</em>
</pre>
<p>Two repositories are equal if they belong to the same pool and have the same id.</p>
<h3>DATA ADD METHODS</h3>

<pre>
<strong>Solvable add_solvable()</strong>
<em>$repo</em><strong>-&gt;add_solvable()</strong>;
<em>repo</em><strong>.add_solvable()</strong>
<em>repo</em><strong>.add_solvable()</strong>
</pre>
<p>Add a single empty solvable to the repository. Returns a Solvable object, see the Solvable class for more information.</p>
<pre>
<strong>bool add_solv(const char *</strong><em>name</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_solv(</strong><em>$name</em><strong>)</strong>;
<em>repo</em><strong>.add_solv(</strong><em>name</em><strong>)</strong>
<em>repo</em><strong>.add_solv(</strong><em>name</em><strong>)</strong>
</pre>

<pre>
<strong>bool add_solv(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_solv(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_solv(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.add_solv(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Read a &ldquo;solv&rdquo; file and add its contents to the repository. These files can be written with the write() method and are normally used as fast cache for repository metadata.</p>
<pre>
<strong>bool add_rpmdb(int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_rpmdb()</strong>;
<em>repo</em><strong>.add_rpmdb()</strong>
<em>repo</em><strong>.add_rpmdb()</strong>
</pre>

<pre>
<strong>bool add_rpmdb_reffp(FILE *</strong><em>reffp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_rpmdb_reffp(</strong><em>$reffp</em><strong>)</strong>;
<em>repo</em><strong>.add_rpmdb_reffp(</strong><em>reffp</em><strong>)</strong>
<em>repo</em><strong>.add_rpmdb_reffp(</strong><em>reffp</em><strong>)</strong>
</pre>
<p>Add the contents of the rpm database to the repository. If a solv file containing an old version of the database is available, it can be passed as reffp to speed up reading.</p>
<pre>
<strong>Solvable add_rpm(const char *</strong><em>filename</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$solvable</em> <strong>=</strong> <em>$repo</em><strong>-&gt;add_rpm(</strong><em>$filename</em><strong>)</strong>;
<em>solvable</em> <strong>=</strong> <em>repo</em><strong>.add_rpm(</strong><em>filename</em><strong>)</strong>
<em>solvable</em> <strong>=</strong> <em>repo</em><strong>.add_rpm(</strong><em>filename</em><strong>)</strong>
</pre>
<p>Add the metadata of a single rpm package to the repository.</p>
<pre>
<strong>bool add_rpmdb_pubkeys(int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_rpmdb_pubkeys()</strong>;
<em>repo</em><strong>.add_rpmdb_pubkeys()</strong>
<em>repo</em><strong>.add_rpmdb_pubkeys()</strong>
</pre>
<p>Add all pubkeys contained in the rpm database to the repository. Note that newer rpm versions also allow to store the pubkeys in some directory instead of the rpm database.</p>
<pre>
<strong>Solvable add_pubkey(const char *</strong><em>keyfile</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$solvable</em> <strong>=</strong> <em>$repo</em><strong>-&gt;add_pubkey(</strong><em>$keyfile</em><strong>)</strong>;
<em>solvable</em> <strong>=</strong> <em>repo</em><strong>.add_pubkey(</strong><em>keyfile</em><strong>)</strong>
<em>solvable</em> <strong>=</strong> <em>repo</em><strong>.add_pubkey(</strong><em>keyfile</em><strong>)</strong>
</pre>
<p>Add a pubkey from a file to the repository.</p>
<pre>
<strong>bool add_rpmmd(FILE *</strong><em>fp</em><strong>, const char *</strong><em>language</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_rpmmd(</strong><em>$fp</em><strong>,</strong> <em>undef</em><strong>)</strong>;
<em>repo</em><strong>.add_rpmmd(</strong><em>fp</em><strong>,</strong> <em>None</em><strong>)</strong>
<em>repo</em><strong>.add_rpmmd(</strong><em>fp</em><strong>,</strong> <em>nil</em><strong>)</strong>
</pre>
<p>Add metadata stored in the "rpm-md" format (i.e. from files in the &ldquo;repodata&rdquo; directory) to a repository. Supported files are "primary", "filelists", "other", "suseinfo". Do not forget to specify the <strong>REPO_EXTEND_SOLVABLES</strong> for extension files like "filelists" and "other". Use the <em>language</em> parameter if you have language extension files, otherwise simply use a <strong>undef</strong>/<strong>None</strong>/<strong>nil</strong> parameter.</p>
<pre>
<strong>bool add_repomdxml(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_repomdxml(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_repomdxml(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.add_repomdxml(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Add the repomd.xml meta description from the "rpm-md" format to the repository. This file contains information about the repository like keywords, and also a list of all database files with checksums. The data is added the the "meta" section of the repository, i.e. no package gets created.</p>
<pre>
<strong>bool add_updateinfoxml(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_updateinfoxml(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_updateinfoxml(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.add_updateinfoxml(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Add the updateinfo.xml file containing available maintenance updates to the repository. All updates are created as special packages that have a "patch:" prefix in their name.</p>
<pre>
<strong>bool add_deltainfoxml(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_deltainfoxml(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_deltainfoxml(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.add_deltainfoxml(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Add the deltainfo.xml file (also called prestodelta.xml) containing available delta-rpms to the repository. The data is added to the "meta" section, i.e. no package gets created.</p>
<pre>
<strong>bool add_debdb(int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_debdb()</strong>;
<em>repo</em><strong>.add_debdb()</strong>
<em>repo</em><strong>.add_debdb()</strong>
</pre>
<p>Add the contents of the debian installed package database to the repository.</p>
<pre>
<strong>bool add_debpackages(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_debpackages(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_debpackages(</strong><em>$fp</em><strong>)</strong>
<em>repo</em><strong>.add_debpackages(</strong><em>$fp</em><strong>)</strong>
</pre>
<p>Add the contents of the debian repository metadata (the "packages" file) to the repository.</p>
<pre>
<strong>Solvable add_deb(const char *</strong><em>filename</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$solvable</em> <strong>=</strong> <em>$repo</em><strong>-&gt;add_deb(</strong><em>$filename</em><strong>)</strong>;
<em>solvable</em> <strong>=</strong> <em>repo</em><strong>.add_deb(</strong><em>filename</em><strong>)</strong>
<em>solvable</em> <strong>=</strong> <em>repo</em><strong>.add_deb(</strong><em>filename</em><strong>)</strong>
</pre>
<p>Add the metadata of a single deb package to the repository.</p>
<pre>
<strong>bool add_mdk(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_mdk(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_mdk(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.add_mdk(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Add the contents of the mageia/mandriva repository metadata (the "synthesis.hdlist" file) to the repository.</p>
<pre>
<strong>bool add_mdk_info(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_mdk(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_mdk(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.add_mdk(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Extend the packages from the synthesis file with the info.xml and files.xml data. Do not forget to specify <strong>REPO_EXTEND_SOLVABLES</strong>.</p>
<pre>
<strong>bool add_arch_repo(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_arch_repo(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_arch_repo(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.add_arch_repo(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Add the contents of the archlinux repository metadata (the ".db.tar" file) to the repository.</p>
<pre>
<strong>bool add_arch_local(const char *</strong><em>dir</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_arch_local(</strong><em>$dir</em><strong>)</strong>;
<em>repo</em><strong>.add_arch_local(</strong><em>dir</em><strong>)</strong>
<em>repo</em><strong>.add_arch_local(</strong><em>dir</em><strong>)</strong>
</pre>
<p>Add the contents of the archlinux installed package database to the repository. The <em>dir</em> parameter is usually set to "/var/lib/pacman/local".</p>
<pre>
<strong>bool add_content(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_content(</strong><em>$fp</em><strong>)</strong>;
<em>repo</em><strong>.add_content(</strong><em>fp</em><strong>)</strong>
<em>repo</em><strong>.add_content(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Add the &ldquo;content&rdquo; meta description from the susetags format to the repository. This file contains information about the repository like keywords, and also a list of all database files with checksums. The data is added the the "meta" section of the repository, i.e. no package gets created.</p>
<pre>
<strong>bool add_susetags(FILE *</strong><em>fp</em><strong>, Id</strong> <em>defvendor</em><strong>, const char *</strong><em>language</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_susetags(</strong><em>$fp</em><strong>,</strong> <em>$defvendor</em><strong>,</strong> <em>$language</em><strong>)</strong>;
<em>repo</em><strong>.add_susetags(</strong><em>fp</em><strong>,</strong> <em>defvendor</em><strong>,</strong> <em>language</em><strong>)</strong>
<em>repo</em><strong>.add_susetags(</strong><em>fp</em><strong>,</strong> <em>defvendor</em><strong>,</strong> <em>language</em><strong>)</strong>
</pre>
<p>Add repository metadata in the susetags format to the repository. Like with add_rpmmd, you can specify a language if you have language extension files. The <em>defvendor</em> parameter provides a default vendor for packages with missing vendors, it is usually provided in the content file.</p>
<pre>
<strong>bool add_products(const char *</strong><em>dir</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>
<em>$repo</em><strong>-&gt;add_products(</strong><em>$dir</em><strong>)</strong>;
<em>repo</em><strong>.add_products(</strong><em>dir</em><strong>)</strong>
<em>repo</em><strong>.add_products(</strong><em>dir</em><strong>)</strong>
</pre>
<p>Add the installed SUSE products database to the repository. The <em>dir</em> parameter is usually "/etc/products.d".</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SOLVABLE CLASS</h2>
        <div class="sectioncontent">
<p>A solvable describes all the information of one package. Each solvable belongs to one repository, it can be added and filled manually but in most cases solvables will get created by the repo_add methods.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Repo *repo;</strong>                     /* read only */
<em>$solvable</em><strong>-&gt;{repo}</strong>
<em>solvable</em><strong>.repo</strong>
<em>solvable</em><strong>.repo</strong>
</pre>
<p>The repository this solvable belongs to.</p>
<pre>
<strong>Pool *pool;</strong>                     /* read only */
<em>$solvable</em><strong>-&gt;{pool}</strong>
<em>solvable</em><strong>.pool</strong>
<em>solvable</em><strong>.pool</strong>
</pre>
<p>The pool this solvable belongs to, same as the pool of the repo.</p>
<pre>
<strong>Id id;</strong>                          /* read only */
<em>$solvable</em><strong>-&gt;{id}</strong>
<em>solvable</em><strong>.id</strong>
<em>solvable</em><strong>.id</strong>
</pre>
<p>The specific id of the solvable.</p>
<pre>
<strong>char *name;</strong>                     /* read/write */
<em>$solvable</em><strong>-&gt;{name}</strong>
<em>solvable</em><strong>.name</strong>
<em>solvable</em><strong>.name</strong>
</pre>

<pre>
<strong>char *evr;</strong>                      /* read/write */
<em>$solvable</em><strong>-&gt;{evr}</strong>
<em>solvable</em><strong>.evr</strong>
<em>solvable</em><strong>.evr</strong>
</pre>

<pre>
<strong>char *arch;</strong>                     /* read/write */
<em>$solvable</em><strong>-&gt;{arch}</strong>
<em>solvable</em><strong>.arch</strong>
<em>solvable</em><strong>.arch</strong>
</pre>

<pre>
<strong>char *vendor;</strong>                   /* read/write */
<em>$solvable</em><strong>-&gt;{vendor}</strong>
<em>solvable</em><strong>.vendor</strong>
<em>solvable</em><strong>.vendor</strong>
</pre>
<p>Easy access to often used attributes of solvables. They are internally stored as Ids.</p>
<pre>
<strong>Id nameid;</strong>                      /* read/write */
<em>$solvable</em><strong>-&gt;{nameid}</strong>
<em>solvable</em><strong>.nameid</strong>
<em>solvable</em><strong>.nameid</strong>
</pre>

<pre>
<strong>Id evrid;</strong>                       /* read/write */
<em>$solvable</em><strong>-&gt;{evrid}</strong>
<em>solvable</em><strong>.evrid</strong>
<em>solvable</em><strong>.evrid</strong>
</pre>

<pre>
<strong>Id archid;</strong>                      /* read/write */
<em>$solvable</em><strong>-&gt;{archid}</strong>
<em>solvable</em><strong>.archid</strong>
<em>solvable</em><strong>.archid</strong>
</pre>

<pre>
<strong>Id vendorid;</strong>                    /* read/write */
<em>$solvable</em><strong>-&gt;{vendorid}</strong>
<em>solvable</em><strong>.vendorid</strong>
<em>solvable</em><strong>.vendorid</strong>
</pre>
<p>Raw interface to the ids. Useful if you want to search for a specific id and want to avoid the string compare overhead.</p>
<h3>METHODS</h3>

<pre>
<strong>const char *lookup_str(Id</strong> <em>keyname</em><strong>)</strong>
my <em>$string</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;lookup_str(</strong><em>$keyname</em><strong>)</strong>;
<em>string</em> <strong>=</strong> <em>solvable</em><strong>.lookup_str(</strong><em>keyname</em><strong>)</strong>
<em>string</em> <strong>=</strong> <em>solvable</em><strong>.lookup_str(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Id lookup_id(Id</strong> <em>keyname</em><strong>)</strong>
my <em>$id</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;lookup_id(</strong><em>$keyname</em><strong>)</strong>;
<em>id</em> <strong>=</strong> <em>solvable</em><strong>.lookup_id(</strong><em>solvid</em><strong>)</strong>
<em>id</em> <strong>=</strong> <em>solvable</em><strong>.lookup_id(</strong><em>solvid</em><strong>)</strong>
</pre>

<pre>
<strong>unsigned long long lookup_num(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, unsigned long long</strong> <em>notfound</em> <strong>= 0)</strong>
my <em>$num</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;lookup_num(</strong><em>$keyname</em><strong>)</strong>;
<em>num</em> <strong>=</strong> <em>solvable</em><strong>.lookup_num(</strong><em>keyname</em><strong>)</strong>
<em>num</em> <strong>=</strong> <em>solvable</em><strong>.lookup_num(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>bool lookup_void(Id</strong> <em>keyname</em><strong>)</strong>
my <em>$bool</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;lookup_void(</strong><em>$keyname</em><strong>)</strong>;
<em>bool</em> <strong>=</strong> <em>solvable</em><strong>.lookup_void(</strong><em>keyname</em><strong>)</strong>
<em>bool</em> <strong>=</strong> <em>solvable</em><strong>.lookup_void(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Chksum lookup_checksum(Id</strong> <em>keyname</em><strong>)</strong>
my <em>$chksum</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;lookup_checksum(</strong><em>$keyname</em><strong>)</strong>;
<em>chksum</em> <strong>=</strong> <em>solvable</em><strong>.lookup_checksum(</strong><em>keyname</em><strong>)</strong>
<em>chksum</em> <strong>=</strong> <em>solvable</em><strong>.lookup_checksum(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Id *lookup_idarray(Id</strong> <em>keyname</em><strong>, Id</strong> <em>marker</em> <strong>= -1)</strong>
my <em>@ids</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;lookup_idarray(</strong><em>$keyname</em><strong>)</strong>;
<em>ids</em> <strong>=</strong> <em>solvable</em><strong>.lookup_idarray(</strong><em>keyname</em><strong>)</strong>
<em>ids</em> <strong>=</strong> <em>solvable</em><strong>.lookup_idarray(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Dep *lookup_deparray(Id</strong> <em>keyname</em><strong>, Id</strong> <em>marker</em> <strong>= -1)</strong>
my <em>@deps</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;lookup_deparray(</strong><em>$keyname</em><strong>)</strong>;
<em>deps</em> <strong>=</strong> <em>solvable</em><strong>.lookup_deparray(</strong><em>keyname</em><strong>)</strong>
<em>deps</em> <strong>=</strong> <em>solvable</em><strong>.lookup_deparray(</strong><em>keyname</em><strong>)</strong>
</pre>
<p>Generic lookup methods. Retrieve data stored for the specific keyname. The lookup_idarray() method will return an array of Ids, use lookup_deparray if you want an array of Dependency objects instead. Some Id arrays contain two parts of data divided by a specific marker, for example the provides array uses the SOLVABLE_FILEMARKER id to store both the ids provided by the package and the ids added by the addfileprovides method. The default, -1, translates to the correct marker for the keyname and returns the first part of the array, use 1 to select the second part or 0 to retrieve all ids including the marker.</p>
<pre>
<strong>const char *lookup_location(unsigned int *</strong><em>OUTPUT</em><strong>)</strong>;
my <strong>(</strong><em>$location</em><strong>,</strong> <em>$medianr</em><strong>) =</strong> <em>$solvable</em><strong>-&gt;lookup_location()</strong>;
<em>location</em><strong>,</strong> <em>medianr</em> <strong>=</strong> <em>solvable</em><strong>.lookup_location()</strong>
<em>location</em><strong>,</strong> <em>medianr</em> <strong>=</strong> <em>solvable</em><strong>.lookup_location()</strong>
</pre>
<p>Return a tuple containing the on-media location and an optional media number for multi-part repositories (e.g. repositories spawning multiple DVDs).</p>
<pre>
<strong>Dataiterator Dataiterator(Id</strong> <em>keyname</em><strong>, const char *</strong><em>match</em> <strong>= 0, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$di</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;Dataiterator(</strong><em>$keyname</em><strong>,</strong> <em>$match</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>di</em> <strong>=</strong> <em>solvable</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>di</em> <strong>=</strong> <em>solvable</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>

<pre>
<strong>for my</strong> <em>$d</em> <strong>(</strong><em>@$di</em><strong>)</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em><strong>:</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em>
</pre>
<p>Iterate over the matching data elements. See the Dataiterator class for more information.</p>
<pre>
<strong>void add_deparray(Id</strong> <em>keyname</em><strong>, DepId</strong> <em>dep</em><strong>, Id</strong> <em>marker</em> <strong>= -1)</strong>;
<em>$solvable</em><strong>-&gt;add_deparray(</strong><em>$keyname</em><strong>,</strong> <em>$dep</em><strong>)</strong>;
<em>solvable</em><strong>.add_deparray(</strong><em>keyname</em><strong>,</strong> <em>dep</em><strong>)</strong>
<em>solvable</em><strong>.add_deparray(</strong><em>keyname</em><strong>,</strong> <em>dep</em><strong>)</strong>
</pre>
<p>Add a new dependency to the attributes stored in keyname.</p>
<pre>
<strong>void unset(Id</strong> <em>keyname</em><strong>)</strong>;
<em>$solvable</em><strong>-&gt;unset(</strong><em>$keyname</em><strong>)</strong>;
<em>solvable</em><strong>.unset(</strong><em>keyname</em><strong>)</strong>
<em>solvable</em><strong>.unset(</strong><em>keyname</em><strong>)</strong>
</pre>
<p>Delete data stored for the specific keyname.</p>
<pre>
<strong>bool installable()</strong>;
<em>$solvable</em><strong>-&gt;installable()</strong>
<em>solvable</em><strong>.installable()</strong>
<em>solvable</em><strong>.installable?</strong>
</pre>
<p>Return true if the solvable is installable on the system. Solvables are not installable if the system does not support their architecture.</p>
<pre>
<strong>bool isinstalled()</strong>;
<em>$solvable</em><strong>-&gt;isinstalled()</strong>
<em>solvable</em><strong>.isinstalled()</strong>
<em>solvable</em><strong>.isinstalled?</strong>
</pre>
<p>Return true if the solvable is installed on the system.</p>
<pre>
<strong>bool identical(Solvable *</strong><em>other</em><strong>)</strong>
<em>$solvable</em><strong>-&gt;identical(</strong><em>$other</em><strong>)</strong>
<em>$solvable</em><strong>.identical(</strong><em>other</em><strong>)</strong>
<em>$solvable</em><strong>.identical?(</strong><em>other</em><strong>)</strong>
</pre>
<p>Return true if the two solvables are identical.</p>
<pre>
<strong>int evrcmp(Solvable *</strong><em>other</em><strong>)</strong>
<em>$solvable</em><strong>-&gt;evrcmp(</strong><em>other</em><strong>)</strong>
<em>$solvable</em><strong>.evrcmp(</strong><em>other</em><strong>)</strong>
<em>$solvable</em><strong>.evrcmp(</strong><em>other</em><strong>)</strong>
</pre>
<p>Returns -1 if the epoch/version/release of the solvable is less then the one from the other solvable, 1 if it is greater, and 0 if they are equal. Note that "equal" does not mean that the evr is identical.</p>
<pre>
<strong>Selection Selection(int</strong> <em>setflags</em> <strong>= 0)</strong>
my <em>$sel</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;Selection()</strong>;
<em>sel</em> <strong>=</strong> <em>solvable</em><strong>.Selection()</strong>
<em>sel</em> <strong>=</strong> <em>solvable</em><strong>.Selection()</strong>
</pre>
<p>Create a Selection containing just the single solvable.</p>
<pre>
<strong>const char *str()</strong>
my <em>$str</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;str()</strong>;
<em>str</em> <strong>=</strong> <em>$solvable</em><strong>.str()</strong>
<em>str</em> <strong>=</strong> <em>$solvable</em><strong>.str()</strong>
</pre>
<p>Return a string describing the solvable. The string consists of the name, version, and architecture of the Solvable.</p>
<pre>
<strong>&lt;stringification&gt;</strong>
my <em>$str</em> <strong>=</strong> <em>$solvable</em><strong>-&gt;str</strong>;
<em>str</em> <strong>= str(</strong><em>solvable</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>solvable</em><strong>.to_s</strong>
</pre>
<p>Same as calling the str() method.</p>
<pre>
<strong>&lt;equality&gt;</strong>
<strong>if (</strong><em>$solvable1</em> <strong>==</strong> <em>$solvable2</em><strong>)</strong>
<strong>if</strong> <em>solvable1</em> <strong>==</strong> <em>solvable2</em><strong>:</strong>
<strong>if</strong> <em>solvable1</em> <strong>==</strong> <em>solvable2</em>
</pre>
<p>Two solvables are equal if they are part of the same pool and have the same ids.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE DATAITERATOR CLASS</h2>
        <div class="sectioncontent">
<p>Dataiterators can be used to do complex string searches or to iterate over arrays. They can be created via the constructors in the Pool, Repo, and Solvable classes. The Repo and Solvable constructors will limit the search to the repository or the specific package.</p><h3>CONSTANTS</h3>
<p><strong>SEARCH_STRING</strong></p><p>Return a match if the search string matches the value.</p><p><strong>SEARCH_STRINGSTART</strong></p><p>Return a match if the value starts with the search string.</p><p><strong>SEARCH_STRINGEND</strong></p><p>Return a match if the value ends with the search string.</p><p><strong>SEARCH_SUBSTRING</strong></p><p>Return a match if the search string can be matched somewhere in the value.</p><p><strong>SEARCH_GLOB</strong></p><p>Do a glob match of the search string against the value.</p><p><strong>SEARCH_REGEX</strong></p><p>Do a regular expression match of the search string against the value.</p><p><strong>SEARCH_NOCASE</strong></p><p>Ignore case when matching strings. Works for all the above match types.</p><p><strong>SEARCH_FILES</strong></p><p>Match the complete filenames of the file list, not just the base name.</p><p><strong>SEARCH_COMPLETE_FILELIST</strong></p><p>When matching the file list, check every file of the package not just the subset from the primary metadata.</p><p><strong>SEARCH_CHECKSUMS</strong></p><p>Allow the matching of checksum entries.</p>
<h3>METHODS</h3>

<pre>
<strong>void prepend_keyname(Id</strong> <em>keyname</em><strong>)</strong>;
<em>$di</em><strong>-&gt;prepend_keyname(</strong><em>$keyname</em><strong>)</strong>;
<em>di</em><strong>.prepend_keyname(</strong><em>keyname</em><strong>)</strong>
<em>di</em><strong>.prepend_keyname(</strong><em>keyname</em><strong>)</strong>
</pre>
<p>Do a sub-search in the array stored in keyname.</p>
<pre>
<strong>void skip_solvable()</strong>;
<em>$di</em><strong>-&gt;kip_solvable()</strong>;
<em>di</em><strong>.skip_solvable()</strong>
<em>di</em><strong>.skip_solvable()</strong>
</pre>
<p>Stop matching the current solvable and advance to the next one.</p>
<pre>
<strong>&lt;iteration&gt;</strong>
<strong>for my</strong> <em>$d</em> <strong>(</strong><em>@$di</em><strong>)</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em><strong>:</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em>
</pre>
<p>Iterate through the matches. If there is a match, the object in d will be of type Datamatch.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE DATAMATCH CLASS</h2>
        <div class="sectioncontent">
<p>Objects of this type will be created for every value matched by a dataiterator.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Pool *pool;</strong>                             /* read only */
<em>$d</em><strong>-&gt;{pool}</strong>
<em>d</em><strong>.pool</strong>
<em>d</em><strong>.pool</strong>
</pre>
<p>Back pointer to pool.</p>
<pre>
<strong>Repo *repo;</strong>                             /* read only */
<em>$d</em><strong>-&gt;{repo}</strong>
<em>d</em><strong>.repo</strong>
<em>d</em><strong>.repo</strong>
</pre>
<p>The repository containing the matched object.</p>
<pre>
<strong>Solvable *solvable;</strong>                     /* read only */
<em>$d</em><strong>-&gt;{solvable}</strong>
<em>d</em><strong>.solvable</strong>
<em>d</em><strong>.solvable</strong>
</pre>
<p>The solvable containing the value that was matched.</p>
<pre>
<strong>Id solvid;</strong>                              /* read only */
<em>$d</em><strong>-&gt;{solvid}</strong>
<em>d</em><strong>.solvid</strong>
<em>d</em><strong>.solvid</strong>
</pre>
<p>The id of the solvable that matched.</p>
<pre>
<strong>Id</strong> <em>key_id</em>;
<em>$d</em><strong>-&gt;{</strong><em>key_id</em><strong>}</strong>
<em>d</em><strong>.key_id</strong>
<em>d</em><strong>.key_id</strong>
</pre>

<pre>
<strong>const char *</strong><em>key_idstr</em>;
<em>$d</em><strong>-&gt;{</strong><em>key_idstr</em><strong>}</strong>
<em>d</em><strong>.key_idstr</strong>
<em>d</em><strong>.key_idstr</strong>
</pre>
<p>The keyname that matched, either as id or string.</p>
<pre>
<strong>Id</strong> <em>type_id</em>;
<em>$d</em><strong>-&gt;{</strong><em>type_id</em><strong>}</strong>
<em>d</em><strong>.type_id</strong>
<em>d</em><strong>.type_id</strong>
</pre>

<pre>
<strong>const char *</strong><em>type_idstr</em>;
<em>$d</em><strong>-&gt;{</strong><em>type_idstr</em><strong>}</strong>;
<em>d</em><strong>.type_idstr</strong>
<em>d</em><strong>.type_idstr</strong>
</pre>
<p>The key type of the value that was matched, either as id or string.</p>
<pre>
<strong>Id</strong> <em>id</em>;
<em>$d</em><strong>-&gt;{id}</strong>
<em>d</em><strong>.id</strong>
<em>d</em><strong>.id</strong>
</pre>

<pre>
<strong>Id</strong> <em>idstr</em>;
<em>$d</em><strong>-&gt;{idstr}</strong>
<em>d</em><strong>.idstr</strong>
<em>d</em><strong>.idstr</strong>
</pre>
<p>The Id of the value that was matched (only valid for id types), either as id or string.</p>
<pre>
<strong>const char *</strong><em>str</em>;
<em>$d</em><strong>-&gt;{str}</strong>
<em>d</em><strong>.str</strong>
<em>d</em><strong>.str</strong>
</pre>
<p>The string value that was matched (only valid for string types).</p>
<pre>
<strong>unsigned long long</strong> <em>num</em>;
<em>$d</em><strong>-&gt;{num}</strong>
<em>d</em><strong>.num</strong>
<em>d</em><strong>.num</strong>
</pre>
<p>The numeric value that was matched (only valid for numeric types).</p>
<pre>
<strong>unsigned int</strong> <em>num2</em>;
<em>$d</em><strong>-&gt;{num2}</strong>
<em>d</em><strong>.num2</strong>
<em>d</em><strong>.num2</strong>
</pre>
<p>The secondary numeric value that was matched (only valid for types containing two values).</p>
<pre>
<strong>unsigned int</strong> <em>binary</em>;
<em>$d</em><strong>-&gt;{binary}</strong>
<em>d</em><strong>.binary</strong>
<em>d</em><strong>.binary</strong>
</pre>
<p>The value in binary form, useful for checksums and other data that cannot be represented as a string.</p>
<h3>METHODS</h3>

<pre>
<strong>Datapos pos()</strong>;
my <em>$pos</em> <strong>=</strong> <em>$d</em><strong>-&gt;pos()</strong>;
<em>pos</em> <strong>=</strong> <em>d</em><strong>.pos()</strong>
<em>pos</em> <strong>=</strong> <em>d</em><strong>.pos()</strong>
</pre>
<p>The position object of the current match. It can be used to do sub-searches starting at the match (if it is of an array type). See the Datapos class for more information.</p>
<pre>
<strong>Datapos parentpos()</strong>;
my <em>$pos</em> <strong>=</strong> <em>$d</em><strong>-&gt;parentpos()</strong>;
<em>pos</em> <strong>=</strong> <em>d</em><strong>.parentpos()</strong>
<em>pos</em> <strong>=</strong> <em>d</em><strong>.parentpos()</strong>
</pre>
<p>The position object of the array containing the current match. It can be used to do sub-searches, see the Datapos class for more information.</p>
<pre>
<strong>&lt;stringification&gt;</strong>
my <em>$str</em> <strong>=</strong> <em>$d</em><strong>-&gt;str</strong>;
<em>str</em> <strong>= str(</strong><em>d</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>d</em><strong>.to_s</strong>
</pre>
<p>Return the stringification of the matched value. Stringification depends on the search flags, for file list entries it will return just the base name unless SEARCH_FILES is used, for checksums it will return an empty string unless SEARCH_CHECKSUMS is used. Numeric values are currently stringified to an empty string.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SELECTION CLASS</h2>
        <div class="sectioncontent">
<p>Selections are a way to easily deal with sets of packages. There are multiple constructors to create them, the most useful is probably the select() method in the Pool class.</p><h3>CONSTANTS</h3>
<p><strong>SELECTION_NAME</strong></p><p>Create the selection by matching package names.</p><p><strong>SELECTION_PROVIDES</strong></p><p>Create the selection by matching package provides.</p><p><strong>SELECTION_FILELIST</strong></p><p>Create the selection by matching package files.</p><p><strong>SELECTION_CANON</strong></p><p>Create the selection by matching the canonical representation of the package. This is normally a combination of the name, the version, and the architecture of a package.</p><p><strong>SELECTION_DOTARCH</strong></p><p>Allow an &ldquo;.&lt;architecture&gt;&rdquo; suffix when matching names or provides.</p><p><strong>SELECTION_REL</strong></p><p>Allow the specification of a relation when matching names or provides, e.g. "name &gt;= 1.2".</p><p><strong>SELECTION_INSTALLED_ONLY</strong></p><p>Limit the package search to installed packages.</p><p><strong>SELECTION_SOURCE_ONLY</strong></p><p>Limit the package search to source packages only.</p><p><strong>SELECTION_WITH_SOURCE</strong></p><p>Extend the package search to also match source packages. The default is only to match binary packages.</p><p><strong>SELECTION_GLOB</strong></p><p>Allow glob matching for package names, package provides, and file names.</p><p><strong>SELECTION_NOCASE</strong></p><p>Ignore case when matching package names, package provides, and file names.</p><p><strong>SELECTION_FLAT</strong></p><p>Return only one selection element describing the selected packages. The default is to create multiple elements for all globbed packages. Multiple elements are useful if you want to turn the selection into an install job, in that case you want an install job for every globbed package.</p>
<h3>ATTRIBUTES</h3>

<pre>
<strong>Pool *pool;</strong>                             /* read only */
<em>$d</em><strong>-&gt;{pool}</strong>
<em>d</em><strong>.pool</strong>
<em>d</em><strong>.pool</strong>
</pre>
<p>Back pointer to pool.</p>
<h3>METHODS</h3>

<pre>
<strong>int flags()</strong>;
my <em>$flags</em> <strong>=</strong> <em>$sel</em><strong>-&gt;flags()</strong>;
<em>flags</em> <strong>=</strong> <em>sel</em><strong>.flags()</strong>
<em>flags</em> <strong>=</strong> <em>sel</em><strong>.flags()</strong>
</pre>
<p>Return the result flags of the selection. The flags are a subset of the ones used when creating the selection, they describe which method was used to get the result. For example, if you create the selection with &ldquo;SELECTION_NAME | SELECTION_PROVIDES&rdquo;, the resulting flags will either be SELECTION_NAME or SELECTION_PROVIDES depending if there was a package that matched the name or not. If there was no match at all, the flags will be zero.</p>
<pre>
<strong>bool isempty()</strong>;
<em>$sel</em><strong>-&gt;isempty()</strong>
<em>sel</em><strong>.isempty()</strong>
<em>sel</em><strong>.isempty?</strong>
</pre>
<p>Return true if the selection is empty, i.e. no package could be matched.</p>
<pre>
<strong>void filter(Selection *</strong><em>other</em><strong>)</strong>
<em>$sel</em><strong>-&gt;filter(</strong><em>$other</em><strong>)</strong>;
<em>sel</em><strong>.filter(</strong><em>other</em><strong>)</strong>
<em>sel</em><strong>.filter(</strong><em>other</em><strong>)</strong>
</pre>
<p>Intersect two selections. Packages will only stay in the selection if there are also included in the other selecting. Does an in-place modification.</p>
<pre>
<strong>void add(Selection *</strong><em>other</em><strong>)</strong>
<em>$sel</em><strong>-&gt;add(</strong><em>$other</em><strong>)</strong>;
<em>sel</em><strong>.add(</strong><em>other</em><strong>)</strong>
<em>sel</em><strong>.add(</strong><em>other</em><strong>)</strong>
</pre>
<p>Build the union of two selections. All packages of the other selection will be added to the set of packages of the selection object. Does an in-place modification. Note that the selection flags are no longer meaningful after the add operation.</p>
<pre>
<strong>void add_raw(Id</strong> <em>how</em><strong>, Id</strong> <em>what</em><strong>)</strong>
<em>$sel</em><strong>-&gt;add_raw(</strong><em>$how</em><strong>,</strong> <em>$what</em><strong>)</strong>;
<em>sel</em><strong>.add_raw(</strong><em>how</em><strong>,</strong> <em>what</em><strong>)</strong>
<em>sel</em><strong>.add_raw(</strong><em>how</em><strong>,</strong> <em>what</em><strong>)</strong>
</pre>
<p>Add a raw element to the selection. Check the Job class for information about the how and what parameters.</p>
<pre>
<strong>Job *jobs(int</strong> <em>action</em><strong>)</strong>
my <em>@jobs</em> <strong>=</strong> <em>$sel</em><strong>-&gt;jobs(</strong><em>$action</em><strong>)</strong>;
<em>jobs</em> <strong>=</strong> <em>sel</em><strong>.jobs(</strong><em>action</em><strong>)</strong>
<em>jobs</em> <strong>=</strong> <em>sel</em><strong>.jobs(</strong><em>action</em><strong>)</strong>
</pre>
<p>Convert a selection into an array of Job objects. The action parameter is or-ed to the &ldquo;how&rdquo; part of the job, it describes the type of job (e.g. install, erase). See the Job class for the action and action modifier constants.</p>
<pre>
<strong>Solvable *solvables()</strong>
my <em>@solvables</em> <strong>=</strong> <em>$sel</em><strong>-&gt;solvables()</strong>;
<em>solvables</em> <strong>=</strong> <em>sel</em><strong>.solvables()</strong>
<em>solvables</em> <strong>=</strong> <em>sel</em><strong>.solvables()</strong>
</pre>
<p>Convert a selection into an array of Solvable objects.</p>
<pre>
<strong>&lt;stringification&gt;</strong>
my <em>$str</em> <strong>=</strong> <em>$sel</em><strong>-&gt;str</strong>;
<em>str</em> <strong>= str(</strong><em>sel</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>sel</em><strong>.to_s</strong>
</pre>
<p>Return a string describing the selection.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE JOB CLASS</h2>
        <div class="sectioncontent">
<p>Jobs are the way to specify to the dependency solver what to do. Most of the times jobs will get created by calling the jobs() method on a Selection object, but there is also a Job() constructor in the Pool class.</p><h3>CONSTANTS</h3>
<p>Selection constants:</p><p><strong>SOLVER_SOLVABLE</strong></p><p>The &ldquo;what&rdquo; part is the id of a solvable.</p><p><strong>SOLVER_SOLVABLE_NAME</strong></p><p>The &ldquo;what&rdquo; part is the id of a package name.</p><p><strong>SOLVER_SOLVABLE_PROVIDES</strong></p><p>The &ldquo;what&rdquo; part is the id of a package provides.</p><p><strong>SOLVER_SOLVABLE_ONE_OF</strong></p><p>The &ldquo;what&rdquo; part is an offset into the &ldquo;whatprovides&rdquo; data, created by calling the towhatprovides() pool method.</p><p><strong>SOLVER_SOLVABLE_REPO</strong></p><p>The &ldquo;what&rdquo; part is the id of a repository.</p><p><strong>SOLVER_SOLVABLE_ALL</strong></p><p>The &ldquo;what&rdquo; part is ignored, all packages are selected.</p><p><strong>SOLVER_SOLVABLE_SELECTMASK</strong></p><p>A mask containing all the above selection bits.</p><p>Action constants:</p><p><strong>SOLVER_NOOP</strong></p><p>Do nothing.</p><p><strong>SOLVER_INSTALL</strong></p><p>Install a package of the specified set of packages. It tries to install the best matching package (i.e. the highest version of the packages from the repositories with the highest priority).</p><p><strong>SOLVER_ERASE</strong></p><p>Erase all of the packages from the specified set. If a package is not installed, erasing it will keep it from getting installed.</p><p><strong>SOLVER_UPDATE</strong></p><p>Update the matching installed packages to their best version. If none of the specified packages are installed, try to update the installed packages to the specified versions. See the section about targeted updates about more information.</p><p><strong>SOLVER_WEAKENDEPS</strong></p><p>Allow to break the dependencies of the matching packages. Handle with care.</p><p><strong>SOLVER_MULTIVERSION</strong></p><p>Mark the matched packages for multiversion install. If they get to be installed because of some other job, the installation will keep the old version of the package installed (for rpm this is done by using &ldquo;-i&rdquo; instead of &ldquo;-U&rdquo;).</p><p><strong>SOLVER_LOCK</strong></p><p>Do not change the state of the matched packages, i.e. when they are installed they stay installed, if not they are not selected for installation.</p><p><strong>SOLVER_DISTUPGRADE</strong></p><p>Update the matching installed packages to the best version included in one of the repositories. After this operation, all come from one of the available repositories except orphaned packages. Orphaned packages are packages that have no relation to the packages in the repositories, i.e. no package in the repositories have the same name or obsolete the orphaned package. This action brings the installed packages in sync with the ones in the repository. By default it also turns of arch/vendor/version locking for the affected packages to simulate a fresh installation. This means that distupgrade can actually downgrade packages if only lower versions of a package are available in the repositories. You can tweak this behavior with the SOLVER_FLAG_DUP_ solver flags.</p><p><strong>SOLVER_DROP_ORPHANED</strong></p><p>Erase all the matching installed packages if they are orphaned. This only makes sense if there is a &ldquo;distupgrade all packages&rdquo; job. The default is to erase orphaned packages only if they block the installation of other packages.</p><p><strong>SOLVER_VERIFY</strong></p><p>Fix dependency problems of matching installed packages. The default is to ignore dependency problems for installed packages.</p><p><strong>SOLVER_USERINSTALLED</strong></p><p>The matching installed packages are considered to be installed by a user, thus not installed to fulfill some dependency. This is needed input for the calculation of unneeded packages for jobs that have the SOLVER_CLEANDEPS flag set.</p><p><strong>SOLVER_JOBMASK</strong></p><p>A mask containing all the above action bits.</p><p>Action modifier constants:</p><p><strong>SOLVER_WEAK</strong></p><p>Makes the job a weak job. The solver tries to fulfill weak jobs, but does not report a problem if it is not possible to do so.</p><p><strong>SOLVER_ESSENTIAL</strong></p><p>Makes the job an essential job. If there is a problem with the job, the solver will not propose to remove the job as one solution (unless all other solutions are also to remove essential jobs).</p><p><strong>SOLVER_CLEANDEPS</strong></p><p>The solver will try to also erase all packages dragged in through dependencies when erasing the package. This needs SOLVER_USERINSTALLED jobs to maximize user satisfaction.</p><p><strong>SOLVER_FORCEBEST</strong></p><p>Insist on the best package for install, update, and distupgrade jobs. If this flag is not used, the solver will use the second-best package if the best package cannot be installed for some reason. When this flag is used, the solver will generate a problem instead.</p><p><strong>SOLVER_TARGETED</strong></p><p>Forces targeted operation update and distupgrade jobs. See the section about targeted updates about more information.</p><p>Set constants.</p><p><strong>SOLVER_SETEV</strong></p><p>The job specified the exact epoch and version of the package set.</p><p><strong>SOLVER_SETEVR</strong></p><p>The job specified the exact epoch, version, and release of the package set.</p><p><strong>SOLVER_SETARCH</strong></p><p>The job specified the exact architecture of the packages from the set.</p><p><strong>SOLVER_SETVENDOR</strong></p><p>The job specified the exact vendor of the packages from the set.</p><p><strong>SOLVER_SETREPO</strong></p><p>The job specified the exact repository of the packages from the set.</p><p><strong>SOLVER_SETNAME</strong></p><p>The job specified the exact name of the packages from the set.</p><p><strong>SOLVER_NOAUTOSET</strong></p><p>Turn of automatic set flag generation for SOLVER_SOLVABLE jobs.</p><p><strong>SOLVER_SETMASK</strong></p><p>A mask containing all the above set bits.</p><p>See the section about set bits for more information.</p>
<h3>ATTRIBUTES</h3>

<pre>
<strong>Pool *pool;</strong>                             /* read only */
<em>$job</em><strong>-&gt;{pool}</strong>
<em>d</em><strong>.pool</strong>
<em>d</em><strong>.pool</strong>
</pre>
<p>Back pointer to pool.</p>
<pre>
<strong>Id how;</strong>                                 /* read/write */
<em>$job</em><strong>-&gt;{how}</strong>
<em>d</em><strong>.how</strong>
<em>d</em><strong>.how</strong>
</pre>
<p>Union of the selection, action, action modifier, and set flags. The selection part describes the semantics of the &ldquo;what&rdquo; Id.</p>
<pre>
<strong>Id what;</strong>                                /* read/write */
<em>$job</em><strong>-&gt;{what}</strong>
<em>d</em><strong>.what</strong>
<em>d</em><strong>.what</strong>
</pre>
<p>Id describing the set of packages, the meaning depends on the selection part of the &ldquo;how&rdquo; attribute.</p>
<h3>METHODS</h3>

<pre>
<strong>Solvable *solvables()</strong>
my <em>@solvables</em> <strong>=</strong> <em>$job</em><strong>-&gt;solvables()</strong>;
<em>solvables</em> <strong>=</strong> <em>job</em><strong>.solvables()</strong>
<em>solvables</em> <strong>=</strong> <em>job</em><strong>.solvables()</strong>
</pre>
<p>Return the set of solvables of the job as an array of Solvable objects.</p>
<pre>
<strong>bool isemptyupdate()</strong>;
<em>$job</em><strong>-&gt;isemptyupdate()</strong>
<em>job</em><strong>.isemptyupdate()</strong>
<em>job</em><strong>.isemptyupdate?</strong>
</pre>
<p>Convenience function to find out if the job describes an update job with no matching packages, i.e. a job that does nothing. Some package managers like &ldquo;zypper&rdquo; like to turn those jobs into install jobs, i.e. an update of a not-installed package will result into the installation of the package.</p>
<pre>
<strong>&lt;stringification&gt;</strong>
my <em>$str</em> <strong>=</strong> <em>$job</em><strong>-&gt;str</strong>;
<em>str</em> <strong>= str(</strong><em>job</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>job</em><strong>.to_s</strong>
</pre>
<p>Return a string describing the job.</p>
<pre>
<strong>&lt;equality&gt;</strong>
<strong>if (</strong><em>$job1</em> <strong>==</strong> <em>$job2</em><strong>)</strong>
<strong>if</strong> <em>job1</em> <strong>==</strong> <em>job2</em><strong>:</strong>
<strong>if</strong> <em>job1</em> <strong>==</strong> <em>job2</em>
</pre>
<p>Two jobs are equal if they belong to the same pool and both the &ldquo;how&rdquo; and the &ldquo;what&rdquo; attributes are the same.</p>
<h3>TARGETED UPDATES</h3>
<p>Libsolv has two modes for upgrades and distupgrade: targeted and untargeted. Untargeted mode means that the installed packages from the specified set will be updated to the best version. Targeted means that packages that can be updated to a package in the specified set will be updated to the best package of the set.</p><p>Here\(cqs an example to explain the subtle difference. Suppose that you have package A installed in version "1.1", "A-1.2" is available in one of the repositories and there is also package "B" that obsoletes package A.</p><p>An untargeted update of "A" will update the installed "A-1.1" to package "B", because that is the newest version (B obsoletes A and is thus newer).</p><p>A targeted update of "A" will update "A-1.1" to "A-1.2", as the set of packages contains both "A-1.1" and "A-1.2", and "A-1.2" is the newer one.</p><p>An untargeted update of "B" will do nothing, as "B" is not installed.</p><p>An targeted update of "B" will update "A-1.1" to "B".</p><p>Note that the default is to do "auto-targeting", thus if the specified set of packages does not include an installed package, the solver will assume targeted operation even if SOLVER_TARGETED is not used.</p><p>This mostly matches the intent of the user, with one exception: In the example above, an update of "A-1.2" will update "A-1.1" to "A-1.2" (targeted mode), but a second update of "A-1.2" will suddenly update to "B", as untargeted mode is chosen because "A-1.2" is now installed.</p><p>If you want to have full control over when targeting mode is chosen, turn off auto-targeting with the SOLVER_FLAG_NO_AUTOTARGET solver option. In that case, all updates are considered to be untargeted unless they include the SOLVER_TARGETED flag.</p>
<h3>SET BITS</h3>
<p>Set bits specify which parts of the specified packages where specified by the user. It is used by the solver when checking if an operation is allowed or not. For example, the solver will normally not allow the downgrade of an installed package. But it will not report a problem if the SOLVER_SETEVR flag is used, as it then assumes that the user specified the exact version and thus knows what he is doing.</p><p>So if a package "screen-1-1" is installed for the x86_64 architecture and version "2-1" is only available for the i586 architecture, installing package "screen-2.1" will ask the user for confirmation because of the different architecture. When using the Selection class to create jobs the set bits are automatically added, e.g. selecting &ldquo;screen.i586&rdquo; will automatically add SOLVER_SETARCH, and thus no problem will be reported.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SOLVER CLASS</h2>
        <div class="sectioncontent">
<p>Dependency solving is what this library is about. A solver object is needed for solving to store the result of the solver run. The solver object can be used multiple times for different jobs, reusing it allows the solver to re-use the dependency rules it already computed.</p><h3>CONSTANTS</h3>
<p>Flags to modify some of the solver\(cqs behavior:</p><p><strong>SOLVER_FLAG_ALLOW_DOWNGRADE</strong></p><p>Allow the solver to downgrade packages without asking for confirmation (i.e. reporting a problem).</p><p><strong>SOLVER_FLAG_ALLOW_ARCHCHANGE</strong></p><p>Allow the solver to change the architecture of an installed package without asking for confirmation. Note that changes to/from noarch are always considered to be allowed.</p><p><strong>SOLVER_FLAG_ALLOW_VENDORCHANGE</strong></p><p>Allow the solver to change the vendor of an installed package without asking for confirmation. Each vendor is part of one or more vendor equivalence classes, normally installed packages may only change their vendor if the new vendor shares at least one equivalence class.</p><p><strong>SOLVER_FLAG_ALLOW_NAMECHANGE</strong></p><p>Allow the solver to change the name of an installed package, i.e. install a package with a different name that obsoletes the installed package. This option is on by default.</p><p><strong>SOLVER_FLAG_ALLOW_UNINSTALL</strong></p><p>Allow the solver to erase installed packages to fulfill the jobs. This flag also includes the above flags. You may want to set this flag if you only have SOLVER_ERASE jobs, as in that case it\(cqs better for the user to check the transaction overview instead of approving every single package that needs to be erased.</p><p><strong>SOLVER_FLAG_DUP_ALLOW_DOWNGRADE</strong></p><p>Like SOLVER_FLAG_ALLOW_DOWNGRADE, but used in distupgrade mode.</p><p><strong>SOLVER_FLAG_DUP_ALLOW_ARCHCHANGE</strong></p><p>Like SOLVER_FLAG_ALLOW_ARCHCHANGE, but used in distupgrade mode.</p><p><strong>SOLVER_FLAG_DUP_ALLOW_VENDORCHANGE</strong></p><p>Like SOLVER_FLAG_ALLOW_VENDORCHANGE, but used in distupgrade mode.</p><p><strong>SOLVER_FLAG_DUP_ALLOW_NAMECHANGE</strong></p><p>Like SOLVER_FLAG_ALLOW_NAMECHANGE, but used in distupgrade mode.</p><p><strong>SOLVER_FLAG_NO_UPDATEPROVIDE</strong></p><p>If multiple packages obsolete an installed package, the solver checks the provides of every such package and ignores all packages that do not provide the installed package name. Thus, you can have an official update candidate that provides the old name, and other packages that also obsolete the package but are not considered for updating. If you cannot use this feature, you can turn it off by setting this flag.</p><p><strong>SOLVER_FLAG_SPLITPROVIDES</strong></p><p>Make the solver aware of special provides of the form &ldquo;&lt;packagename&gt;:&lt;path&gt;&rdquo; used in SUSE systems to support package splits.</p><p><strong>SOLVER_FLAG_IGNORE_RECOMMENDED</strong></p><p>Do not process optional (aka weak) dependencies.</p><p><strong>SOLVER_FLAG_ADD_ALREADY_RECOMMENDED</strong></p><p>Install recommended or supplemented packages even if they have no connection to the current transaction. You can use this feature to implement a simple way for the user to install new recommended packages that were not available in the past.</p><p><strong>SOLVER_FLAG_NO_INFARCHCHECK</strong></p><p>Turn off the inferior architecture checking that is normally done by the solver. Normally, the solver allows only the installation of packages from the "best" architecture if a package is available for multiple architectures.</p><p><strong>SOLVER_FLAG_BEST_OBEY_POLICY</strong></p><p>Make the SOLVER_FORCEBEST job option consider only packages that meet the policies for installed packages, i.e. no downgrades, no architecture change, no vendor change (see the first flags of this section). If the flag is not specified, the solver will enforce the installation of the best package ignoring the installed packages, which may conflict with the set policy.</p><p><strong>SOLVER_FLAG_NO_AUTOTARGET</strong></p><p>Do not enable auto-targeting up update and distupgrade jobs. See the section on targeted updates for more information.</p><p>Basic rule types:</p><p><strong>SOLVER_RULE_UNKNOWN</strong></p><p>A rule of an unknown class. You should never encounter those.</p><p><strong>SOLVER_RULE_RPM</strong></p><p>A package dependency rule, called rpm rule for historical reasons.</p><p><strong>SOLVER_RULE_UPDATE</strong></p><p>A rule to implement the update policy of installed packages. Every installed package has an update rule that consists of the packages that may replace the installed package.</p><p><strong>SOLVER_RULE_FEATURE</strong></p><p>Feature rules are fallback rules used when a update rule is disabled. They include all packages that may replace the installed package ignoring the update policy, i.e. they contain downgrades, arch changes and so on. Without them, the solver would simply erase installed packages if their update rule gets disabled.</p><p><strong>SOLVER_RULE_JOB</strong></p><p>Job rules implement the job given to the solver.</p><p><strong>SOLVER_RULE_DISTUPGRADE</strong></p><p>This are simple negative assertions that make sure that only packages are kept that are also available in one of the repositories.</p><p><strong>SOLVER_RULE_INFARCH</strong></p><p>Infarch rules are also negative assertions, they disallow the installation of packages when there are packages of the same name but with a better architecture.</p><p><strong>SOLVER_RULE_CHOICE</strong></p><p>Choice rules are used to make sure that the solver prefers updating to installing different packages when some dependency is provided by multiple packages with different names. The solver may always break choice rules, so you will not see them when a problem is found.</p><p><strong>SOLVER_RULE_LEARNT</strong></p><p>These rules are generated by the solver to keep it from running into the same problem multiple times when it has to backtrack. They are the main reason why a sat solver is faster then other dependency solver implementations.</p><p>Special dependency rule types:</p><p><strong>SOLVER_RULE_RPM_NOT_INSTALLABLE</strong></p><p>This rule was added to prevent the installation of a package of an architecture that does not work on the system.</p><p><strong>SOLVER_RULE_RPM_NOTHING_PROVIDES_DEP</strong></p><p>The package contains a required dependency which was not provided by any package.</p><p><strong>SOLVER_RULE_RPM_PACKAGE_REQUIRES</strong></p><p>Similar to SOLVER_RULE_RPM_NOTHING_PROVIDES_DEP, but in this case some packages provided the dependency but none of them could be installed due to other dependency issues.</p><p><strong>SOLVER_RULE_RPM_SELF_CONFLICT</strong></p><p>The package conflicts with itself. This is not allowed by older rpm versions.</p><p><strong>SOLVER_RULE_RPM_PACKAGE_CONFLICT</strong></p><p>To fulfill the dependencies two packages need to be installed, but one of the packages contains a conflict with the other one.</p><p><strong>SOLVER_RULE_RPM_SAME_NAME</strong></p><p>The dependencies can only be fulfilled by multiple versions of a package, but installing multiple versions of the same package is not allowed.</p><p><strong>SOLVER_RULE_RPM_PACKAGE_OBSOLETES</strong></p><p>To fulfill the dependencies two packages need to be installed, but one of the packages obsoletes the other one.</p><p><strong>SOLVER_RULE_RPM_IMPLICIT_OBSOLETES</strong></p><p>To fulfill the dependencies two packages need to be installed, but one of the packages has provides a dependency that is obsoleted by the other one. See the POOL_FLAG_IMPLICITOBSOLETEUSESPROVIDES flag.</p><p><strong>SOLVER_RULE_RPM_INSTALLEDPKG_OBSOLETES</strong></p><p>To fulfill the dependencies a package needs to be installed that is obsoleted by an installed package. See the POOL_FLAG_NOINSTALLEDOBSOLETES flag.</p><p><strong>SOLVER_RULE_JOB_NOTHING_PROVIDES_DEP</strong></p><p>The user asked for installation of a package providing a specific dependency, but no available package provides it.</p><p><strong>SOLVER_RULE_JOB_UNKNOWN_PACKAGE</strong></p><p>The user asked for installation of a package with a specific name, but no available package has that name.</p><p><strong>SOLVER_RULE_JOB_PROVIDED_BY_SYSTEM</strong></p><p>The user asked for the erasure of a dependency that is provided by the system (i.e. for special hardware or language dependencies), this cannot be done with a job.</p><p><strong>SOLVER_RULE_JOB_UNSUPPORTED</strong></p><p>The user asked for something that is not yet implemented, e.g. the installation of all packages at once.</p><p>Policy error constants</p><p><strong>POLICY_ILLEGAL_DOWNGRADE</strong></p><p>The solver ask for permission before downgrading packages.</p><p><strong>POLICY_ILLEGAL_ARCHCHANGE</strong></p><p>The solver ask for permission before changing the architecture of installed packages.</p><p><strong>POLICY_ILLEGAL_VENDORCHANGE</strong></p><p>The solver ask for permission before changing the vendor of installed packages.</p><p><strong>POLICY_ILLEGAL_NAMECHANGE</strong></p><p>The solver ask for permission before replacing an installed packages with a package that has a different name.</p><p>Solution element type constants</p><p><strong>SOLVER_SOLUTION_JOB</strong></p><p>The problem can be solved by removing the specified job.</p><p><strong>SOLVER_SOLUTION_POOLJOB</strong></p><p>The problem can be solved by removing the specified job that is defined in the pool.</p><p><strong>SOLVER_SOLUTION_INFARCH</strong></p><p>The problem can be solved by allowing the installation of the specified package with an inferior architecture.</p><p><strong>SOLVER_SOLUTION_DISTUPGRADE</strong></p><p>The problem can be solved by allowing to keep the specified package installed.</p><p><strong>SOLVER_SOLUTION_BEST</strong></p><p>The problem can be solved by allowing to install the specified package that is not the best available package.</p><p><strong>SOLVER_SOLUTION_ERASE</strong></p><p>The problem can be solved by allowing to erase the specified package.</p><p><strong>SOLVER_SOLUTION_REPLACE</strong></p><p>The problem can be solved by allowing to replace the package with some other package.</p><p><strong>SOLVER_SOLUTION_REPLACE_DOWNGRADE</strong></p><p>The problem can be solved by allowing to replace the package with some other package that has a lower version.</p><p><strong>SOLVER_SOLUTION_REPLACE_ARCHCHANGE</strong></p><p>The problem can be solved by allowing to replace the package with some other package that has a different architecture.</p><p><strong>SOLVER_SOLUTION_REPLACE_VENDORCHANGE</strong></p><p>The problem can be solved by allowing to replace the package with some other package that has a different vendor.</p><p><strong>SOLVER_SOLUTION_REPLACE_NAMECHANGE</strong></p><p>The problem can be solved by allowing to replace the package with some other package that has a different name.</p><p>Reason constants</p><p><strong>SOLVER_REASON_UNRELATED</strong></p><p>The package status did not change as it was not related to any job.</p><p><strong>SOLVER_REASON_UNIT_RULE</strong></p><p>The package was installed/erased/kept because of a unit rule, i.e. a rule where all literals but one were false.</p><p><strong>SOLVER_REASON_KEEP_INSTALLED</strong></p><p>The package was chosen when trying to keep as many packages installed as possible.</p><p><strong>SOLVER_REASON_RESOLVE_JOB</strong></p><p>The decision happened to fulfill a job rule.</p><p><strong>SOLVER_REASON_UPDATE_INSTALLED</strong></p><p>The decision happened to fulfill a package update request.</p><p><strong>SOLVER_REASON_CLEANDEPS_ERASE</strong></p><p>The package was erased when cleaning up dependencies from other erased packages.</p><p><strong>SOLVER_REASON_RESOLVE</strong></p><p>The package was installed to fulfill package dependencies.</p><p><strong>SOLVER_REASON_WEAKDEP</strong></p><p>The package was installed because of a weak dependency (Recommends or Supplements).</p><p><strong>SOLVER_REASON_RESOLVE_ORPHAN</strong></p><p>The decision about the package was made when deciding the fate of orphaned packages.</p><p><strong>SOLVER_REASON_RECOMMENDED</strong></p><p>This is a special case of SOLVER_REASON_WEAKDEP.</p><p><strong>SOLVER_REASON_SUPPLEMENTED</strong></p><p>This is a special case of SOLVER_REASON_WEAKDEP.</p>
<h3>ATTRIBUTES</h3>

<pre>
<strong>Pool *pool;</strong>                             /* read only */
<em>$job</em><strong>-&gt;{pool}</strong>
<em>d</em><strong>.pool</strong>
<em>d</em><strong>.pool</strong>
</pre>
<p>Back pointer to pool.</p>
<h3>METHODS</h3>

<pre>
<strong>int set_flag(int</strong> <em>flag</em><strong>, int</strong> <em>value</em><strong>)</strong>
my <em>$oldvalue</em> <strong>=</strong> <em>$solver</em><strong>-&gt;set_flag(</strong><em>$flag</em><strong>,</strong> <em>$value</em><strong>)</strong>;
<em>oldvalue</em> <strong>=</strong> <em>solver</em><strong>.set_flag(</strong><em>flag</em><strong>,</strong> <em>value</em><strong>)</strong>
<em>oldvalue</em> <strong>=</strong> <em>solver</em><strong>.set_flag(</strong><em>flag</em><strong>,</strong> <em>value</em><strong>)</strong>
</pre>

<pre>
<strong>int get_flag(int</strong> <em>flag</em><strong>)</strong>
my <em>$value</em> <strong>=</strong> <em>$solver</em><strong>-&gt;get_flag(</strong><em>$flag</em><strong>)</strong>;
<em>value</em> <strong>=</strong> <em>solver</em><strong>.get_flag(</strong><em>flag</em><strong>)</strong>
<em>value</em> <strong>=</strong> <em>solver</em><strong>.get_flag(</strong><em>flag</em><strong>)</strong>
</pre>
<p>Set/get a solver specific flag. The flags define the policies the solver has to obey. The flags are explained in the CONSTANTS section of this class.</p>
<pre>
<strong>Problem *solve(Job *</strong><em>jobs</em><strong>)</strong>
my <em>@problems</em> <strong>=</strong> <em>$solver</em><strong>-&gt;solve(&#92;</strong><em>@jobs</em><strong>)</strong>;
<em>problems</em> <strong>=</strong> <em>solver</em><strong>.solve(</strong><em>jobs</em><strong>)</strong>
<em>problems</em> <strong>=</strong> <em>solver</em><strong>.solve(</strong><em>jobs</em><strong>)</strong>
</pre>
<p>Solve a problem specified in the job list (plus the jobs defined in the pool). Returns an array of problems that need user interaction, or an empty array if no problems were encountered. See the Problem class on how to deal with problems.</p>
<pre>
<strong>Transaction transaction()</strong>
my <em>$trans</em> <strong>=</strong> <em>$solver</em><strong>-&gt;transaction()</strong>;
<em>trans</em> <strong>=</strong> <em>solver</em><strong>.transaction()</strong>
<em>trans</em> <strong>=</strong> <em>solver</em><strong>.transaction()</strong>
</pre>
<p>Return the transaction to implement the calculated package changes. A transaction is available even if problems were found, this is useful for interactive user interfaces that show both the job result and the problems.</p>
<pre>
<strong>int</strong> <em>reason</em> <strong>= describe_decision(Solvable *</strong><em>s</em><strong>, Rule *</strong><em>OUTPUT</em><strong>)</strong>
my <strong>(</strong><em>$reason</em><strong>,</strong> <em>$rule</em><strong>) =</strong> <em>$solver</em><strong>-&gt;describe_decision(</strong><em>$solvable</em><strong>)</strong>;
<strong>(</strong><em>reason</em><strong>,</strong> <em>rule</em><strong>) =</strong> <em>solver</em><strong>.describe_decision(</strong><em>solvable</em><strong>)</strong>
<strong>(</strong><em>reason</em><strong>,</strong> <em>rule</em><strong>) =</strong> <em>solver</em><strong>.describe_decision(</strong><em>solvable</em><strong>)</strong>
</pre>
<p>Return the reason why a specific solvable was installed or erased. For most of the reasons the rule that triggered the decision is also returned.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE PROBLEM CLASS</h2>
        <div class="sectioncontent">
<p>Problems are the way of the solver to interact with the user. You can simply list all problems and terminate your program, but a better way is to present solutions to the user and let him pick the ones he likes.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Solver *solv;</strong>                           /* read only */
<em>$problem</em><strong>-&gt;{solv}</strong>
<em>problem</em><strong>.solv</strong>
<em>problem</em><strong>.solv</strong>
</pre>
<p>Back pointer to solver object.</p>
<pre>
<strong>Id id;</strong>                                  /* read only */
<em>$problem</em><strong>-&gt;{id}</strong>
<em>problem</em><strong>.id</strong>
<em>problem</em><strong>.id</strong>
</pre>
<p>Id of the problem. The first problem has Id 1, they are numbered consecutively.</p>
<h3>METHODS</h3>

<pre>
<strong>Rule findproblemrule()</strong>
my <em>$probrule</em> <strong>=</strong> <em>$problem</em><strong>-&gt;findproblemrule()</strong>;
<em>probrule</em> <strong>=</strong> <em>problem</em><strong>.findproblemrule()</strong>
<em>probrule</em> <strong>=</strong> <em>problem</em><strong>.findproblemrule()</strong>
</pre>
<p>Return the rule that caused the problem. Of course in most situations there is no single responsible rule, but many rules that interconnect with each created the problem. Nevertheless, the solver uses some heuristic approach to find a rule that somewhat describes the problem best to the user.</p>
<pre>
<strong>Rule *findallproblemrules(bool</strong> <em>unfiltered</em> <strong>= 0)</strong>
my <em>@probrules</em> <strong>=</strong> <em>$problem</em><strong>-&gt;findallproblemrules()</strong>;
<em>probrules</em> <strong>=</strong> <em>problem</em><strong>.findallproblemrule()</strong>
<em>probrules</em> <strong>=</strong> <em>problem</em><strong>.findallproblemrule()</strong>
</pre>
<p>Return all rules responsible for the problem. The returned set of rules contains all the needed information why there was a problem, but it\(cqs hard to present them to the user in a sensible way. The default is to filter out all update and job rules (unless the returned rules only consist of those types).</p>
<pre>
<strong>Solution *solutions()</strong>
my <em>@solutions</em> <strong>=</strong> <em>$problem</em><strong>-&gt;solutions()</strong>;
<em>solutions</em> <strong>=</strong> <em>problem</em><strong>.solutions()</strong>
<em>solutions</em> <strong>=</strong> <em>problem</em><strong>.solutions()</strong>
</pre>
<p>Return an array containing multiple possible solutions to fix the problem. See the solution class for more information.</p>
<pre>
<strong>int solution_count()</strong>
my <em>$cnt</em> <strong>=</strong> <em>$problem</em><strong>-&gt;solution_count()</strong>;
<em>cnt</em> <strong>=</strong> <em>problem</em><strong>.solution_count()</strong>
<em>cnt</em> <strong>=</strong> <em>problem</em><strong>.solution_count()</strong>
</pre>
<p>Return the number of solutions without creating solution objects.</p>
<pre>
<strong>&lt;stringification&gt;</strong>
my <em>$str</em> <strong>=</strong> <em>$problem</em><strong>-&gt;str</strong>;
<em>str</em> <strong>= str(</strong><em>problem</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>problem</em><strong>.to_s</strong>
</pre>
<p>Return a string describing the problem. This is a convenience function, it is a shorthand for calling findproblemrule(), then ruleinfo() on the problem rule and problemstr() on the ruleinfo object.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE RULE CLASS</h2>
        <div class="sectioncontent">
<p>Rules are the basic block of sat solving. Each package dependency gets translated into one or multiple rules.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Solver *solv;</strong>                           /* read only */
<em>$rule</em><strong>-&gt;{solv}</strong>
<em>rule</em><strong>.solv</strong>
<em>rule</em><strong>.solv</strong>
</pre>
<p>Back pointer to solver object.</p>
<pre>
<strong>Id id;</strong>                                  /* read only */
<em>$rule</em><strong>-&gt;{id}</strong>
<em>rule</em><strong>.id</strong>
<em>rule</em><strong>.id</strong>
</pre>
<p>The id of the rule.</p>
<pre>
<strong>int type;</strong>                               /* read only */
<em>$rule</em><strong>-&gt;{type}</strong>
<em>rule</em><strong>.type</strong>
<em>rule</em><strong>.type</strong>
</pre>
<p>The basic type of the rule. See the constant section of the solver class for the type list.</p>
<h3>METHODS</h3>

<pre>
<strong>Ruleinfo info()</strong>
my <em>$ruleinfo</em> <strong>=</strong> <em>$rule</em><strong>-&gt;info()</strong>;
<em>ruleinfo</em> <strong>=</strong> <em>rule</em><strong>.info()</strong>
<em>ruleinfo</em> <strong>=</strong> <em>rule</em><strong>.info()</strong>
</pre>
<p>Return a Ruleinfo object that contains information about why the rule was created. But see the allinfos() method below.</p>
<pre>
<strong>Ruleinfo *allinfos()</strong>
my <em>@ruleinfos</em> <strong>=</strong> <em>$rule</em><strong>-&gt;allinfos()</strong>;
<em>ruleinfos</em> <strong>=</strong> <em>rule</em><strong>.allinfos()</strong>
<em>ruleinfos</em> <strong>=</strong> <em>rule</em><strong>.allinfos()</strong>
</pre>
<p>As the same dependency rule can get created because of multiple dependencies, one Ruleinfo is not enough to describe the reason. Thus the allinfos() method returns an array of all infos about a rule.</p>
<pre>
<strong>&lt;equality&gt;</strong>
<strong>if (</strong><em>$rule1</em> <strong>==</strong> <em>$rule2</em><strong>)</strong>
<strong>if</strong> <em>rule1</em> <strong>==</strong> <em>rule2</em><strong>:</strong>
<strong>if</strong> <em>rule1</em> <strong>==</strong> <em>rule2</em>
</pre>
<p>Two rules are equal if they belong to the same solver and have the same id.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE RULEINFO CLASS</h2>
        <div class="sectioncontent">
<p>A Ruleinfo describes one reason why a rule was created.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Solver *solv;</strong>                           /* read only */
<em>$ruleinfo</em><strong>-&gt;{solv}</strong>
<em>ruleinfo</em><strong>.solv</strong>
<em>ruleinfo</em><strong>.solv</strong>
</pre>
<p>Back pointer to solver object.</p>
<pre>
<strong>int type;</strong>                               /* read only */
<em>$ruleinfo</em><strong>-&gt;{type}</strong>
<em>ruleinfo</em><strong>.type</strong>
<em>ruleinfo</em><strong>.type</strong>
</pre>
<p>The type of the ruleinfo. See the constant section of the solver class for the rule type list and the special type list.</p>
<pre>
<strong>Dep *dep;</strong>                               /* read only */
<em>$ruleinfo</em><strong>-&gt;{dep}</strong>
<em>ruleinfo</em><strong>.dep</strong>
<em>ruleinfo</em><strong>.dep</strong>
</pre>
<p>The dependency leading to the creation of the rule.</p>
<pre>
<strong>Dep *dep_id;</strong>                            /* read only */
<em>$ruleinfo</em><strong>-&gt;{&apos;dep_id&apos;}</strong>
<em>ruleinfo</em><strong>.dep_id</strong>
<em>ruleinfo</em><strong>.dep_id</strong>
</pre>
<p>The Id of the dependency leading to the creation of the rule, or zero.</p>
<pre>
<strong>Solvable *solvable;</strong>                     /* read only */
<em>$ruleinfo</em><strong>-&gt;{solvable}</strong>
<em>ruleinfo</em><strong>.solvable</strong>
<em>ruleinfo</em><strong>.solvable</strong>
</pre>
<p>The involved Solvable, e.g. the one containing the dependency.</p>
<pre>
<strong>Solvable *othersolvable;</strong>                /* read only */
<em>$ruleinfo</em><strong>-&gt;{othersolvable}</strong>
<em>ruleinfo</em><strong>.othersolvable</strong>
<em>ruleinfo</em><strong>.othersolvable</strong>
</pre>
<p>The other involved Solvable (if any), e.g. the one containing providing the dependency for conflicts.</p>
<pre>
<strong>const char *problemstr()</strong>;
my <em>$str</em> <strong>=</strong> <em>$ruleinfo</em><strong>-&gt;problemstr()</strong>;
<em>str</em> <strong>=</strong> <em>ruleinfo</em><strong>.problemstr()</strong>
<em>str</em> <strong>=</strong> <em>ruleinfo</em><strong>.problemstr()</strong>
</pre>
<p>A string describing the ruleinfo from a problem perspective. This probably only makes sense if the rule is part of a problem.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SOLUTION CLASS</h2>
        <div class="sectioncontent">
<p>A solution solves one specific problem. It consists of multiple solution elements that all need to be executed.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Solver *solv;</strong>                           /* read only */
<em>$solution</em><strong>-&gt;{solv}</strong>
<em>solution</em><strong>.solv</strong>
<em>solution</em><strong>.solv</strong>
</pre>
<p>Back pointer to solver object.</p>
<pre>
<strong>Id problemid;</strong>                           /* read only */
<em>$solution</em><strong>-&gt;{problemid}</strong>
<em>solution</em><strong>.problemid</strong>
<em>solution</em><strong>.problemid</strong>
</pre>
<p>Id of the problem the solution solves.</p>
<pre>
<strong>Id id;</strong>                                  /* read only */
<em>$solution</em><strong>-&gt;{id}</strong>
<em>solution</em><strong>.id</strong>
<em>solution</em><strong>.id</strong>
</pre>
<p>Id of the solution. The first solution has Id 1, they are numbered consecutively.</p>
<h3>METHODS</h3>

<pre>
<strong>Solutionelement *elements(bool</strong> <em>expandreplaces</em> <strong>= 0)</strong>
my <em>@solutionelements</em> <strong>=</strong> <em>$solution</em><strong>-&gt;elements()</strong>;
<em>solutionelements</em> <strong>=</strong> <em>solution</em><strong>.elements()</strong>
<em>solutionelements</em> <strong>=</strong> <em>solution</em><strong>.elements()</strong>
</pre>
<p>Return an array containing the elements describing what needs to be done to implement the specific solution. If expandreplaces is true, elements of type SOLVER_SOLUTION_REPLACE will be replaced by one or more elements replace elements describing the policy mismatches.</p>
<pre>
<strong>int element_count()</strong>
my <em>$cnt</em> <strong>=</strong> <em>$solution</em><strong>-&gt;solution_count()</strong>;
<em>cnt</em> <strong>=</strong> <em>solution</em><strong>.element_count()</strong>
<em>cnt</em> <strong>=</strong> <em>solution</em><strong>.element_count()</strong>
</pre>
<p>Return the number of solution elements without creating objects. Note that the count does not match the number of objects returned by the elements() method of expandreplaces is set to true.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SOLUTIONELEMENT CLASS</h2>
        <div class="sectioncontent">
<p>A solution element describes a single action of a solution. The action is always either to remove one specific job or to add a new job that installs or erases a single specific package.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Solver *solv;</strong>                           /* read only */
<em>$solutionelement</em><strong>-&gt;{solv}</strong>
<em>solutionelement</em><strong>.solv</strong>
<em>solutionelement</em><strong>.solv</strong>
</pre>
<p>Back pointer to solver object.</p>
<pre>
<strong>Id problemid;</strong>                           /* read only */
<em>$solutionelement</em><strong>-&gt;{problemid}</strong>
<em>solutionelement</em><strong>.problemid</strong>
<em>solutionelement</em><strong>.problemid</strong>
</pre>
<p>Id of the problem the element (partly) solves.</p>
<pre>
<strong>Id solutionid;</strong>                          /* read only */
<em>$solutionelement</em><strong>-&gt;{solutionid}</strong>
<em>solutionelement</em><strong>.solutionid</strong>
<em>solutionelement</em><strong>.solutionid</strong>
</pre>
<p>Id of the solution the element is a part of.</p>
<pre>
<strong>Id id;</strong>                                  /* read only */
<em>$solutionelement</em><strong>-&gt;{id}</strong>
<em>solutionelement</em><strong>.id</strong>
<em>solutionelement</em><strong>.id</strong>
</pre>
<p>Id of the solution element. The first element has Id 1, they are numbered consecutively.</p>
<pre>
<strong>Id type;</strong>                                /* read only */
<em>$solutionelement</em><strong>-&gt;{type}</strong>
<em>solutionelement</em><strong>.type</strong>
<em>solutionelement</em><strong>.type</strong>
</pre>
<p>Type of the solution element. See the constant section of the solver class for the existing types.</p>
<pre>
<strong>Solvable *solvable;</strong>                     /* read only */
<em>$solutionelement</em><strong>-&gt;{solvable}</strong>
<em>solutionelement</em><strong>.solvable</strong>
<em>solutionelement</em><strong>.solvable</strong>
</pre>
<p>The installed solvable that needs to be replaced for replacement elements.</p>
<pre>
<strong>Solvable *replacement;</strong>                  /* read only */
<em>$solutionelement</em><strong>-&gt;{replacement}</strong>
<em>solutionelement</em><strong>.replacement</strong>
<em>solutionelement</em><strong>.replacement</strong>
</pre>
<p>The solvable that needs to be installed to fix the problem.</p>
<pre>
<strong>int jobidx;</strong>                             /* read only */
<em>$solutionelement</em><strong>-&gt;{jobidx}</strong>
<em>solutionelement</em><strong>.jobidx</strong>
<em>solutionelement</em><strong>.jobidx</strong>
</pre>
<p>The index of the job that needs to be removed to fix the problem, or -1 if the element is of another type. Note that it\(cqs better to change the job to SOLVER_NOOP type so that the numbering of other elements does not get disturbed. This method works both for types SOLVER_SOLUTION_JOB and SOLVER_SOLUTION_POOLJOB.</p>
<h3>METHODS</h3>

<pre>
<strong>Solutionelement *replaceelements()</strong>
my <em>@solutionelements</em> <strong>=</strong> <em>$solutionelement</em><strong>-&gt;replaceelements()</strong>;
<em>solutionelements</em> <strong>=</strong> <em>solutionelement</em><strong>.replaceelements()</strong>
<em>solutionelements</em> <strong>=</strong> <em>solutionelement</em><strong>.replaceelements()</strong>
</pre>
<p>If the solution element is of type SOLVER_SOLUTION_REPLACE, return an array of elements describing the policy mismatches, otherwise return a copy of the element. See also the &ldquo;expandreplaces&rdquo; option in the solution\(cqs elements() method.</p>
<pre>
<strong>int illegalreplace()</strong>
my <em>$illegal</em> <strong>=</strong> <em>$solutionelement</em><strong>-&gt;illegalreplace()</strong>;
<em>illegal</em> <strong>=</strong> <em>solutionelement</em><strong>.illegalreplace()</strong>
<em>illegal</em> <strong>=</strong> <em>solutionelement</em><strong>.illegalreplace()</strong>
</pre>
<p>Return an integer that contains the policy mismatch bits or-ed together, or zero if there was no policy mismatch. See the policy error constants in the solver class.</p>
<pre>
<strong>Job Job()</strong>
my <em>$job</em> <strong>=</strong> <em>$solutionelement</em><strong>-&gt;Job()</strong>;
<em>illegal</em> <strong>=</strong> <em>solutionelement</em><strong>.Job()</strong>
<em>illegal</em> <strong>=</strong> <em>solutionelement</em><strong>.Job()</strong>
</pre>
<p>Create a job that implements the solution element. Add this job to the array of jobs for all elements of type different to SOLVER_SOLUTION_JOB and SOLVER_SOLUTION_POOLJOB. For the later two, a SOLVER_NOOB Job is created, you should replace the old job with the new one.</p>
<pre>
<strong>const char *str()</strong>
my <em>$str</em> <strong>=</strong> <em>$solutionelement</em><strong>-&gt;str()</strong>;
<em>str</em> <strong>=</strong> <em>solutionelement</em><strong>.str()</strong>
<em>str</em> <strong>=</strong> <em>solutionelement</em><strong>.str()</strong>
</pre>
<p>A string describing the change the solution element consists of.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE TRANSACTION CLASS</h2>
        <div class="sectioncontent">
<p>Transactions describe the output of a solver run. A transaction contains a number of transaction elements, each either the installation of a new package or the removal of an already installed package. The Transaction class supports a classify() method that puts the elements into different groups so that a transaction can be presented to the user in a meaningful way.</p><h3>CONSTANTS</h3>
<p>Transaction element types, both active and passive</p><p><strong>SOLVER_TRANSACTION_IGNORE</strong></p><p>This element does nothing. Used to map element types that do not match the view mode.</p><p><strong>SOLVER_TRANSACTION_INSTALL</strong></p><p>This element installs a package.</p><p><strong>SOLVER_TRANSACTION_ERASE</strong></p><p>This element erases a package.</p><p><strong>SOLVER_TRANSACTION_MULTIINSTALL</strong></p><p>This element installs a package with a different version keeping the other versions installed.</p><p><strong>SOLVER_TRANSACTION_MULTIREINSTALL</strong></p><p>This element reinstalls a installed package keeping the other versions installed.</p><p>Transaction element types, active view</p><p><strong>SOLVER_TRANSACTION_REINSTALL</strong></p><p>This element re-installs a package, i.e. installs the same package again.</p><p><strong>SOLVER_TRANSACTION_CHANGE</strong></p><p>This element installs a package with same name, version, architecture but different content.</p><p><strong>SOLVER_TRANSACTION_UPGRADE</strong></p><p>This element installs a newer version of an installed package.</p><p><strong>SOLVER_TRANSACTION_DOWNGRADE</strong></p><p>This element installs a older version of an installed package.</p><p><strong>SOLVER_TRANSACTION_OBSOLETES</strong></p><p>This element installs a package that obsoletes an installed package.</p><p>Transaction element types, passive view</p><p><strong>SOLVER_TRANSACTION_REINSTALLED</strong></p><p>This element re-installs a package, i.e. installs the same package again.</p><p><strong>SOLVER_TRANSACTION_CHANGED</strong></p><p>This element replaces an installed package with one of the same name, version, architecture but different content.</p><p><strong>SOLVER_TRANSACTION_UPGRADED</strong></p><p>This element replaces an installed package with a new version.</p><p><strong>SOLVER_TRANSACTION_DOWNGRADED</strong></p><p>This element replaces an installed package with an old version.</p><p><strong>SOLVER_TRANSACTION_OBSOLETED</strong></p><p>This element replaces an installed package with a package that obsoletes it.</p><p>Pseudo element types for showing extra information used by classify()</p><p><strong>SOLVER_TRANSACTION_ARCHCHANGE</strong></p><p>This element replaces an installed package with a package of a different architecture.</p><p><strong>SOLVER_TRANSACTION_VENDORCHANGE</strong></p><p>This element replaces an installed package with a package of a different vendor.</p><p>Transaction mode flags</p><p><strong>SOLVER_TRANSACTION_SHOW_ACTIVE</strong></p><p>Filter for active view types. The default is to return passive view type, i.e. to show how the installed packages get changed.</p><p><strong>SOLVER_TRANSACTION_SHOW_OBSOLETES</strong></p><p>Do not map the obsolete view type into INSTALL/ERASE elements.</p><p><strong>SOLVER_TRANSACTION_SHOW_ALL</strong></p><p>If multiple packages replace an installed package, only the best of them is kept as OBSOLETE element, the other ones are mapped to INSTALL/ERASE elements. This is because most applications want to show just one package replacing the installed one. The SOLVER_TRANSACTION_SHOW_ALL makes the library keep all OBSOLETE elements.</p><p><strong>SOLVER_TRANSACTION_SHOW_MULTIINSTALL</strong></p><p>The library maps MULTIINSTALL elements to simple INSTALL elements. This flag can be used to disable the mapping.</p><p><strong>SOLVER_TRANSACTION_CHANGE_IS_REINSTALL</strong></p><p>Use this flag if you want to map CHANGE elements to the REINSTALL type.</p><p><strong>SOLVER_TRANSACTION_OBSOLETE_IS_UPGRADE</strong></p><p>Use this flag if you want to map OBSOLETE elements to the UPGRADE type.</p><p><strong>SOLVER_TRANSACTION_MERGE_ARCHCHANGES</strong></p><p>Do not add extra categories for every architecture change, instead cumulate them in one category.</p><p><strong>SOLVER_TRANSACTION_MERGE_VENDORCHANGES</strong></p><p>Do not add extra categories for every vendor change, instead cumulate them in one category.</p><p><strong>SOLVER_TRANSACTION_RPM_ONLY</strong></p><p>Special view mode that just returns IGNORE, ERASE, INSTALL, MULTIINSTALL elements. Useful if you want to find out what to feed to the underlying package manager.</p><p>Transaction order flags</p><p><strong>SOLVER_TRANSACTION_KEEP_ORDERDATA</strong></p><p>Do not throw away the dependency graph used for ordering the transaction. This flag is needed if you want to do manual ordering.</p>
<h3>ATTRIBUTES</h3>

<pre>
<strong>Pool *pool;</strong>                             /* read only */
<em>$trans</em><strong>-&gt;{pool}</strong>
<em>trans</em><strong>.pool</strong>
<em>trans</em><strong>.pool</strong>
</pre>
<p>Back pointer to pool.</p>
<h3>METHODS</h3>

<pre>
<strong>bool isempty()</strong>;
<em>$trans</em><strong>-&gt;isempty()</strong>
<em>trans</em><strong>.isempty()</strong>
<em>trans</em><strong>.isempty?</strong>
</pre>
<p>Returns true if the transaction does not do anything, i.e. has no elements.</p>
<pre>
<strong>Solvable *newsolvables()</strong>;
my <em>@newsolvables</em> <strong>=</strong> <em>$trans</em><strong>-&gt;newsolvables()</strong>;
<em>newsolvables</em> <strong>=</strong> <em>trans</em><strong>.newsolvables()</strong>
<em>newsolvables</em> <strong>=</strong> <em>trans</em><strong>.newsolvables()</strong>
</pre>
<p>Return all packages that are to be installed by the transaction. This are the packages that need to be downloaded from the repositories.</p>
<pre>
<strong>Solvable *keptsolvables()</strong>;
my <em>@keptsolvables</em> <strong>=</strong> <em>$trans</em><strong>-&gt;keptsolvables()</strong>;
<em>keptsolvables</em> <strong>=</strong> <em>trans</em><strong>.keptsolvables()</strong>
<em>keptsolvables</em> <strong>=</strong> <em>trans</em><strong>.keptsolvables()</strong>
</pre>
<p>Return all installed packages that the transaction will keep installed.</p>
<pre>
<strong>Solvable *steps()</strong>;
my <em>@steps</em> <strong>=</strong> <em>$trans</em><strong>-&gt;steps()</strong>;
<em>steps</em> <strong>=</strong> <em>trans</em><strong>.steps()</strong>
<em>steps</em> <strong>=</strong> <em>trans</em><strong>.steps()</strong>
</pre>
<p>Return all solvables that need to be installed (if the returned solvable is not already installed) or erased (if the returned solvable is installed). A step is also called a transaction element.</p>
<pre>
<strong>int steptype(Solvable *</strong><em>solvable</em><strong>, int</strong> <em>mode</em><strong>)</strong>
my <em>$type</em> <strong>=</strong> <em>$trans</em><strong>-&gt;steptype(</strong><em>$solvable</em><strong>,</strong> <em>$mode</em><strong>)</strong>;
<em>type</em> <strong>=</strong> <em>trans</em><strong>.steptype(</strong><em>solvable</em><strong>,</strong> <em>mode</em><strong>)</strong>
<em>type</em> <strong>=</strong> <em>trans</em><strong>.steptype(</strong><em>solvable</em><strong>,</strong> <em>mode</em><strong>)</strong>
</pre>
<p>Return the transaction type of the specified solvable. See the CONSTANTS sections for the mode argument flags and the list of returned types.</p>
<pre>
<strong>TransactionClass *classify(int</strong> <em>mode</em> <strong>= 0)</strong>
my <em>@classes</em> <strong>=</strong> <em>$trans</em><strong>-&gt;classify()</strong>;
<em>classes</em> <strong>=</strong> <em>trans</em><strong>.classify()</strong>
<em>classes</em> <strong>=</strong> <em>trans</em><strong>.classify()</strong>
</pre>
<p>Group the transaction elements into classes so that they can be displayed in a structured way. You can use various mapping mode flags to tweak the result to match your preferences, see the mode argument flag in the CONSTANTS section. See the TransactionClass class for how to deal with the returned objects.</p>
<pre>
<strong>Solvable othersolvable(Solvable *</strong><em>solvable</em><strong>)</strong>;
my <em>$other</em> <strong>=</strong> <em>$trans</em><strong>-&gt;othersolvable(</strong><em>$solvable</em><strong>)</strong>;
<em>other</em> <strong>=</strong> <em>trans</em><strong>.othersolvable(</strong><em>solvable</em><strong>)</strong>
<em>other</em> <strong>=</strong> <em>trans</em><strong>.othersolvable(</strong><em>solvable</em><strong>)</strong>
</pre>
<p>Return the &ldquo;other&rdquo; solvable for a given solvable. For installed packages the other solvable is the best package with the same name that replaces the installed package, or the best package of the obsoleting packages if the package does not get replaced by one with the same name.</p><p>For to be installed packages, the &ldquo;other&rdquo; solvable is the best installed package with the same name that will be replaced, or the best packages of all the packages that are obsoleted if the new package does not replace a package with the same name.</p><p>Thus, the &ldquo;other&rdquo; solvable is normally the package that is also shown for a given package.</p>
<pre>
<strong>Solvable *allothersolvables(Solvable *</strong><em>solvable</em><strong>)</strong>;
my <em>@others</em> <strong>=</strong> <em>$trans</em><strong>-&gt;allothersolvables(</strong><em>$solvable</em><strong>)</strong>;
<em>others</em> <strong>=</strong> <em>trans</em><strong>.allothersolvables(</strong><em>solvable</em><strong>)</strong>
<em>others</em> <strong>=</strong> <em>trans</em><strong>.allothersolvables(</strong><em>solvable</em><strong>)</strong>
</pre>
<p>For installed packages, returns all of the packages that replace us. For to be installed packages, returns all of the packages that the new package replaces. The special &ldquo;other&rdquo; solvable is always the first entry of the returned array.</p>
<pre>
<strong>int calc_installsizechange()</strong>;
my <em>$change</em> <strong>=</strong> <em>$trans</em><strong>-&gt;calc_installsizechange()</strong>;
<em>change</em> <strong>=</strong> <em>trans</em><strong>.calc_installsizechange()</strong>
<em>change</em> <strong>=</strong> <em>trans</em><strong>.calc_installsizechange()</strong>
</pre>
<p>Return the size change of the installed system in kilobytes (kibibytes).</p>
<pre>
<strong>void order(int</strong> <em>flags</em> <strong>= 0)</strong>;
<em>$trans</em><strong>-&gt;order()</strong>;
<em>trans</em><strong>.order()</strong>
<em>trans</em><strong>.order()</strong>
</pre>
<p>Order the steps in the transactions so that dependent packages are updated before packages that depend on them. For rpm, you can also use rpmlib\(cqs ordering functionality, debian\(cqs dpkg does not provide a way to order a transaction.</p>
<h3>ACTIVE/PASSIVE VIEW</h3>
<p>Active view list what new packages get installed, while passive view shows what happens to the installed packages. Most often there\(cqs not much difference between the two modes, but things get interesting of multiple package get replaced by one new package. Say you have installed package A-1-1 and B-1-1, and now install A-2-1 with has a new dependency that obsoletes B. The transaction elements will be</p>
<pre>
updated   A-1-1 (other: A-2-1)
obsoleted B-1-1 (other: A-2-1)
</pre>
<p>in passive mode, but</p>
<pre>
update A-2-1 (other: A-1-1)
erase  B
</pre>
<p>in active mode. If the mode contains SOLVER_TRANSACTION_SHOW_ALL, the passive mode list will be unchanged but the active mode list will just contain A-2-1.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE TRANSACTIONCLASS CLASS</h2>
        <div class="sectioncontent">
<p>Objects of this type are returned by the classify() Transaction method.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Transaction *transaction;</strong>               /* read only */
<em>$class</em><strong>-&gt;{transaction}</strong>
<em>class</em><strong>.transaction</strong>
<em>class</em><strong>.transaction</strong>
</pre>
<p>Back pointer to transaction object.</p>
<pre>
<strong>int type;</strong>                               /* read only */
<em>$class</em><strong>-&gt;{type}</strong>
<em>class</em><strong>.type</strong>
<em>class</em><strong>.type</strong>
</pre>
<p>The type of the transaction elements in the class.</p>
<pre>
<strong>int count;</strong>                              /* read only */
<em>$class</em><strong>-&gt;{count}</strong>
<em>class</em><strong>.count</strong>
<em>class</em><strong>.count</strong>
</pre>
<p>The number of elements in the class.</p>
<pre>
<strong>const char *</strong><em>fromstr</em>;
<em>$class</em><strong>-&gt;{fromstr}</strong>
<em>class</em><strong>.fromstr</strong>
<em>class</em><strong>.fromstr</strong>
</pre>
<p>The old vendor or architecture.</p>
<pre>
<strong>const char *</strong><em>tostr</em>;
<em>$class</em><strong>-&gt;{tostr}</strong>
<em>class</em><strong>.tostr</strong>
<em>class</em><strong>.tostr</strong>
</pre>
<p>The new vendor or architecture.</p>
<pre>
<strong>Id</strong> <em>fromid</em>;
<em>$class</em><strong>-&gt;{fromid}</strong>
<em>class</em><strong>.fromid</strong>
<em>class</em><strong>.fromid</strong>
</pre>
<p>The id of the old vendor or architecture.</p>
<pre>
<strong>Id</strong> <em>toid</em>;
<em>$class</em><strong>-&gt;{toid}</strong>
<em>class</em><strong>.toid</strong>
<em>class</em><strong>.toid</strong>
</pre>
<p>The id of the new vendor or architecture.</p>
<h3>METHODS</h3>

<pre>
<strong>void solvables()</strong>;
my <em>@solvables</em> <strong>=</strong> <em>$class</em><strong>-&gt;solvables()</strong>;
<em>solvables</em> <strong>=</strong> <em>class</em><strong>.solvables()</strong>
<em>solvables</em> <strong>=</strong> <em>class</em><strong>.solvables()</strong>
</pre>
<p>Return the solvables for all transaction elements in the class.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHECKSUMS</h2>
        <div class="sectioncontent">
<p>Checksums (also called hashes) are used to make sure that downloaded data is not corrupt and also as a fingerprint mechanism to check if data has changed.</p><h3>CLASS METHODS</h3>

<pre>
<strong>Chksum Chksum(Id</strong> <em>type</em><strong>)</strong>
my <em>$chksum</em> <strong>= solv::Chksum-&gt;new(</strong><em>$type</em><strong>)</strong>;
<em>chksum</em> <strong>= solv.Chksum(</strong><em>type</em><strong>)</strong>
<em>chksum</em> <strong>= Solv::Chksum.new(</strong><em>type</em><strong>)</strong>
</pre>
<p>Create a checksum object. Currently the following types are supported:</p>
<pre>
<strong>REPOKEY_TYPE_MD5</strong>
<strong>REPOKEY_TYPE_SHA1</strong>
<strong>REPOKEY_TYPE_SHA256</strong>
</pre>
<p>These keys are constants in the <strong>solv</strong> class.</p>
<pre>
<strong>Chksum Chksum(Id</strong> <em>type</em><strong>, const char *</strong><em>hex</em><strong>)</strong>
my <em>$chksum</em> <strong>= solv::Chksum-&gt;new(</strong><em>$type</em><strong>,</strong> <em>$hex</em><strong>)</strong>;
<em>chksum</em> <strong>= solv.Chksum(</strong><em>type</em><strong>,</strong> <em>hex</em><strong>)</strong>
<em>chksum</em> <strong>= Solv::Chksum.new(</strong><em>type</em><strong>,</strong> <em>hex</em><strong>)</strong>
</pre>
<p>Create an already finalized checksum object.</p>
<h3>ATTRIBUTES</h3>

<pre>
<strong>Id type;</strong>                        /* read only */
<em>$chksum</em><strong>-&gt;{type}</strong>
<em>chksum</em><strong>.type</strong>
<em>chksum</em><strong>.type</strong>
</pre>
<p>Return the type of the checksum object.</p>
<h3>METHODS</h3>

<pre>
<strong>void add(const char *</strong><em>str</em><strong>)</strong>
<em>$chksum</em><strong>-&gt;add(</strong><em>$str</em><strong>)</strong>;
<em>chksum</em><strong>.add(</strong><em>str</em><strong>)</strong>
<em>chksum</em><strong>.add(</strong><em>str</em><strong>)</strong>
</pre>
<p>Add a string to the checksum.</p>
<pre>
<strong>void add_fp(FILE *</strong><em>fp</em><strong>)</strong>
<em>$chksum</em><strong>-&gt;add_fp(</strong><em>$file</em><strong>)</strong>;
<em>chksum</em><strong>.add_fp(</strong><em>file</em><strong>)</strong>
<em>chksum</em><strong>.add_fp(</strong><em>file</em><strong>)</strong>
</pre>
<p>Add the contents of a file to the checksum.</p>
<pre>
<strong>void add_stat(const char *</strong><em>filename</em><strong>)</strong>
<em>$chksum</em><strong>-&gt;add_stat(</strong><em>$filename</em><strong>)</strong>;
<em>chksum</em><strong>.add_stat(</strong><em>filename</em><strong>)</strong>
<em>chksum</em><strong>.add_stat(</strong><em>filename</em><strong>)</strong>
</pre>
<p>Stat the file and add the dev/ino/size/mtime member to the checksum. If the stat fails, the members are zeroed.</p>
<pre>
<strong>void add_fstat(int</strong> <em>fd</em><strong>)</strong>
<em>$chksum</em><strong>-&gt;add_fstat(</strong><em>$fd</em><strong>)</strong>;
<em>chksum</em><strong>.add_fstat(</strong><em>fd</em><strong>)</strong>
<em>chksum</em><strong>.add_fstat(</strong><em>fd</em><strong>)</strong>
</pre>
<p>Same as add_stat, but instead of the filename a file descriptor is used.</p>
<pre>
<strong>unsigned char *raw()</strong>
my <em>$raw</em> <strong>=</strong> <em>$chksum</em><strong>-&gt;raw()</strong>;
<em>raw</em> <strong>=</strong> <em>chksum</em><strong>.raw()</strong>
<em>raw</em> <strong>=</strong> <em>chksum</em><strong>.raw()</strong>
</pre>
<p>Finalize the checksum and return the result as raw bytes. This means that the result can contain NUL bytes or unprintable characters.</p>
<pre>
<strong>const char *hex()</strong>
my <em>$raw</em> <strong>=</strong> <em>$chksum</em><strong>-&gt;hex()</strong>;
<em>raw</em> <strong>=</strong> <em>chksum</em><strong>.hex()</strong>
<em>raw</em> <strong>=</strong> <em>chksum</em><strong>.hex()</strong>
</pre>
<p>Finalize the checksum and return the result as hex string.</p>
<pre>
<strong>const char *typestr()</strong>
my <em>$typestr</em> <strong>=</strong> <em>$chksum</em><strong>-&gt;typestr()</strong>;
<em>typestr</em> <strong>=</strong> <em>chksum</em><strong>.typestr</strong>
<em>typestr</em> <strong>=</strong> <em>chksum</em><strong>.typestr</strong>
</pre>
<p>Return the type of the checksum as a string, e.g. "sha256".</p>
<pre>
<strong>&lt;equality&gt;</strong>
<strong>if (</strong><em>$chksum1</em> <strong>==</strong> <em>$chksum2</em><strong>)</strong>
<strong>if</strong> <em>chksum1</em> <strong>==</strong> <em>chksum2</em><strong>:</strong>
<strong>if</strong> <em>chksum1</em> <strong>==</strong> <em>chksum2</em>
</pre>
<p>Checksums are equal if they are of the same type and the finalized results are the same.</p>
<pre>
<strong>&lt;stringification&gt;</strong>
my <em>$str</em> <strong>=</strong> <em>$chksum</em><strong>-&gt;str</strong>;
<em>str</em> <strong>= str(</strong><em>chksum</em><strong>)</strong>
<em>str</em> <strong>=</strong> <em>chksum</em><strong>.to_s</strong>
</pre>
<p>If the checksum is finished, the checksum is returned as "&lt;type&gt;:&lt;hex&gt;" string. Otherwise "&lt;type&gt;:unfinished" is returned.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILE MANAGEMENT</h2>
        <div class="sectioncontent">
<p>This functions were added because libsolv uses standard <strong>FILE</strong> pointers to read/write files, but languages like perl have their own implementation of files. The libsolv functions also support decompression and compression, the algorithm is selected by looking at the file name extension.</p>
<pre>
<strong>FILE *xfopen(char *</strong><em>fn</em><strong>, char *</strong><em>mode</em> <strong>= "r")</strong>
my <em>$file</em> <strong>= solv::xfopen(</strong><em>$path</em><strong>)</strong>;
<em>file</em> <strong>= solv.xfopen(</strong><em>path</em><strong>)</strong>
<em>file</em> <strong>= Solv::xfopen(</strong><em>path</em><strong>)</strong>
</pre>
<p>Open a file at the specified path. The mode argument is passed on to the stdio library.</p>
<pre>
<strong>FILE *xfopen_fd(char *</strong><em>fn</em><strong>, int</strong> <em>fileno</em><strong>)</strong>
my <em>$file</em> <strong>= solv::xfopen_fd(</strong><em>$path</em><strong>,</strong> <em>$fileno</em><strong>)</strong>;
<em>file</em> <strong>= solv.xfopen_fd(</strong><em>path</em><strong>,</strong> <em>fileno</em><strong>)</strong>
<em>file</em> <strong>= Solv::xfopen_fd(</strong><em>path</em><strong>,</strong> <em>fileno</em><strong>)</strong>
</pre>
<p>Create a file handle from the specified file descriptor. The path argument is only used to select the correct (de-)compression algorithm, use an empty path if you want to make sure to read/write raw data.</p><h3>METHODS</h3>

<pre>
<strong>int fileno()</strong>
my <em>$fileno</em> <strong>=</strong> <em>$file</em><strong>-&gt;fileno()</strong>;
<em>fileno</em> <strong>=</strong> <em>file</em><strong>.fileno()</strong>
<em>fileno</em> <strong>=</strong> <em>file</em><strong>.fileno()</strong>
</pre>
<p>Return file file descriptor of the file. If the file is not open, -1 is returned.</p>
<pre>
<strong>int dup()</strong>
my <em>$fileno</em> <strong>=</strong> <em>$file</em><strong>-&gt;dup()</strong>;
<em>fileno</em> <strong>=</strong> <em>file</em><strong>.dup()</strong>
<em>fileno</em> <strong>=</strong> <em>file</em><strong>.dup()</strong>
</pre>
<p>Return a copy of the descriptor of the file. If the file is not open, -1 is returned.</p>
<pre>
<strong>bool flush()</strong>
<em>$file</em><strong>-&gt;flush()</strong>;
<em>file</em><strong>.flush()</strong>
<em>file</em><strong>.flush()</strong>
</pre>
<p>Flush the file. Returns false if there was an error. Flushing a closed file always returns true.</p>
<pre>
<strong>bool close()</strong>
<em>$file</em><strong>-&gt;close()</strong>;
<em>file</em><strong>.close()</strong>
<em>file</em><strong>.close()</strong>
</pre>
<p>Close the file. This is needed for languages like Ruby, that do not destruct objects right after they are no longer referenced. In that case, it is good style to close open files so that the file descriptors are freed right away. Returns false if there was an error.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE REPODATA CLASS</h2>
        <div class="sectioncontent">
<p>The Repodata stores attributes for packages and the repository itself, each repository can have multiple repodata areas. You normally only need to directly access them if you implement lazy downloading of repository data. Repodata areas are created by calling the repository\(cqs add_repodata() method or by using repo_add methods without the REPO_REUSE_REPODATA or REPO_USE_LOADING flag.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Repo *repo;</strong>                     /* read only */
<em>$data</em><strong>-&gt;{repo}</strong>
<em>data</em><strong>.repo</strong>
<em>data</em><strong>.repo</strong>
</pre>
<p>Back pointer to repository object.</p>
<pre>
<strong>Id id;</strong>                                  /* read only */
<em>$data</em><strong>-&gt;{id}</strong>
<em>data</em><strong>.id</strong>
<em>data</em><strong>.id</strong>
</pre>
<p>The id of the repodata area. Repodata ids of different repositories overlap.</p>
<h3>METHODS</h3>

<pre>
<strong>internalize()</strong>;
<em>$data</em><strong>-&gt;internalize()</strong>;
<em>data</em><strong>.internalize()</strong>
<em>data</em><strong>.internalize()</strong>
</pre>
<p>Internalize newly added data. The lookup functions will only see the new data after it has been internalized.</p>
<pre>
<strong>bool write(FILE *</strong><em>fp</em><strong>)</strong>;
<em>$data</em><strong>-&gt;write(</strong><em>$fp</em><strong>)</strong>;
<em>data</em><strong>.write(</strong><em>fp</em><strong>)</strong>
<em>data</em><strong>.write(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Write the contents of the repodata area as solv file.</p>
<pre>
<strong>bool add_solv(FILE *</strong><em>fp</em><strong>, int</strong> <em>flags</em> <strong>= 0)</strong>;
<em>$data</em><strong>-&gt;add_solv(</strong><em>$fp</em><strong>)</strong>;
<em>data</em><strong>.add_solv(</strong><em>fp</em><strong>)</strong>
<em>data</em><strong>.add_solv(</strong><em>fp</em><strong>)</strong>
</pre>
<p>Replace a stub repodata object with the data from a solv file. This method automatically adds the REPO_USE_LOADING flag. It should only be used from a load callback.</p>
<pre>
<strong>void create_stubs()</strong>;
<em>$data</em><strong>-&gt;create_stubs()</strong>
<em>data</em><strong>.create_stubs()</strong>
<em>data</em><strong>.create_stubs()</strong>
</pre>
<p>Create stub repodatas from the information stored in the repodata meta area.</p>
<pre>
<strong>void extend_to_repo()</strong>;
<em>$data</em><strong>-&gt;extend_to_repo()</strong>;
<em>data</em><strong>.extend_to_repo()</strong>
<em>data</em><strong>.extend_to_repo()</strong>
</pre>
<p>Extend the repodata so that it has the same size as the repo it belongs to. This method is only needed when switching to a just written repodata extension to make the repodata match the written extension (which is always of the size of the repo).</p>
<pre>
<strong>&lt;equality&gt;</strong>
<strong>if (</strong><em>$data1</em> <strong>==</strong> <em>$data2</em><strong>)</strong>
<strong>if</strong> <em>data1</em> <strong>==</strong> <em>data2</em><strong>:</strong>
<strong>if</strong> <em>data1</em> <strong>==</strong> <em>data2</em>
</pre>
<p>Two repodata objects are equal if they belong to the same repository and have the same id.</p>
<h3>DATA RETRIEVAL METHODS</h3>

<pre>
<strong>const char *lookup_str(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>$string</em> <strong>=</strong> <em>$data</em><strong>-&gt;lookup_str(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>string</em> <strong>=</strong> <em>data</em><strong>.lookup_str(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>string</em> <strong>=</strong> <em>data</em><strong>.lookup_str(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Id *lookup_idarray(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>@ids</em> <strong>=</strong> <em>$data</em><strong>-&gt;lookup_idarray(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>ids</em> <strong>=</strong> <em>data</em><strong>.lookup_idarray(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>ids</em> <strong>=</strong> <em>data</em><strong>.lookup_idarray(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Chksum lookup_checksum(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>$chksum</em> <strong>=</strong> <em>$data</em><strong>-&gt;lookup_checksum(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>)</strong>;
<em>chksum</em> <strong>=</strong> <em>data</em><strong>.lookup_checksum(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
<em>chksum</em> <strong>=</strong> <em>data</em><strong>.lookup_checksum(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>)</strong>
</pre>
<p>Lookup functions. Return the data element stored in the specified solvable. The methods probably only make sense to retrieve data from the special SOLVID_META solvid that stores repodata meta information.</p>
<h3>DATA STORAGE METHODS</h3>

<pre>
<strong>void set_id(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, DepId</strong> <em>id</em><strong>)</strong>;
<em>$data</em><strong>-&gt;set_id(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>,</strong> <em>$id</em><strong>)</strong>;
<em>data</em><strong>.set_id(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>id</em><strong>)</strong>
<em>data</em><strong>.set_id(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>id</em><strong>)</strong>
</pre>

<pre>
<strong>void set_str(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, const char *</strong><em>str</em><strong>)</strong>;
<em>$data</em><strong>-&gt;set_str(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>,</strong> <em>$str</em><strong>)</strong>;
<em>data</em><strong>.set_str(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>str</em><strong>)</strong>
<em>data</em><strong>.set_str(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>str</em><strong>)</strong>
</pre>

<pre>
<strong>void set_poolstr(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, const char *</strong><em>str</em><strong>)</strong>;
<em>$data</em><strong>-&gt;set_poolstr(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>,</strong> <em>$str</em><strong>)</strong>;
<em>data</em><strong>.set_poolstr(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>str</em><strong>)</strong>
<em>data</em><strong>.set_poolstr(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>str</em><strong>)</strong>
</pre>

<pre>
<strong>void set_checksum(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, Chksum *</strong><em>chksum</em><strong>)</strong>;
<em>$data</em><strong>-&gt;set_checksum(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>,</strong> <em>$chksum</em><strong>)</strong>;
<em>data</em><strong>.set_checksum(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>chksum</em><strong>)</strong>
<em>data</em><strong>.set_checksum(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>chksum</em><strong>)</strong>
</pre>

<pre>
<strong>void add_idarray(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, DepId</strong> <em>id</em><strong>)</strong>;
<em>$data</em><strong>-&gt;add_idarray(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>,</strong> <em>$id</em><strong>)</strong>;
<em>data</em><strong>.add_idarray(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>id</em><strong>)</strong>
<em>data</em><strong>.add_idarray(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>id</em><strong>)</strong>
</pre>

<pre>
<strong>Id new_handle()</strong>;
my <em>$handle</em> <strong>=</strong> <em>$data</em><strong>-&gt;new_handle()</strong>;
<em>handle</em> <strong>=</strong> <em>data</em><strong>.new_handle()</strong>
<em>handle</em> <strong>=</strong> <em>data</em><strong>.new_handle()</strong>
</pre>

<pre>
<strong>void add_flexarray(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>, Id</strong> <em>handle</em><strong>)</strong>;
<em>$data</em><strong>-&gt;add_flexarray(</strong><em>$solvid</em><strong>,</strong> <em>$keyname</em><strong>,</strong> <em>$handle</em><strong>)</strong>;
<em>data</em><strong>.add_flexarray(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>handle</em><strong>)</strong>
<em>data</em><strong>.add_flexarray(</strong><em>solvid</em><strong>,</strong> <em>keyname</em><strong>,</strong> <em>handle</em><strong>)</strong>
</pre>
<p>Data storage methods. Probably only useful to store data in the special SOLVID_META solvid that stores repodata meta information. Note that repodata areas can have their own Id pool (see the REPO_LOCALPOOL flag), so be careful if you need to store ids. Arrays are created by calling the add function for every element. A flexarray is an array of sub-structures, call new_handle to create a new structure, use the handle as solvid to fill the structure with data and call add_flexarray to put the structure in an array.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE DATAPOS CLASS</h2>
        <div class="sectioncontent">
<p>Datapos objects describe a specific position in the repository data area. Thus they are only valid until the repository is modified in some way. Datapos objects can be created by the pos() and parentpos() methods of a Datamatch object or by accessing the &ldquo;meta&rdquo; attribute of a repository.</p><h3>ATTRIBUTES</h3>

<pre>
<strong>Repo *repo;</strong>                     /* read only */
<em>$data</em><strong>-&gt;{repo}</strong>
<em>data</em><strong>.repo</strong>
<em>data</em><strong>.repo</strong>
</pre>
<p>Back pointer to repository object.</p>
<h3>METHODS</h3>

<pre>
<strong>Dataiterator(Id</strong> <em>keyname</em><strong>, const char *</strong><em>match</em><strong>, int</strong> <em>flags</em><strong>)</strong>
my <em>$di</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;Dataiterator(</strong><em>$keyname</em><strong>,</strong> <em>$match</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>di</em> <strong>=</strong> <em>datapos</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>di</em> <strong>=</strong> <em>datapos</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>
<p>Create a Dataiterator at the position of the datapos object.</p>
<pre>
<strong>const char *lookup_deltalocation(unsigned int *</strong><em>OUTPUT</em><strong>)</strong>;
my <strong>(</strong><em>$location</em><strong>,</strong> <em>$medianr</em><strong>) =</strong> <em>$datapos</em><strong>-&gt;lookup_deltalocation()</strong>;
<em>location</em><strong>,</strong> <em>medianr</em> <strong>=</strong> <em>datapos</em><strong>.lookup_deltalocation()</strong>
<em>location</em><strong>,</strong> <em>medianr</em> <strong>=</strong> <em>datapos</em><strong>.lookup_deltalocation()</strong>
</pre>
<p>Return a tuple containing the on-media location and an optional media number for a delta rpm. This obviously only works if the data position points to structure describing a delta rpm.</p>
<pre>
<strong>const char *lookup_deltaseq()</strong>;
my <em>$seq</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;lookup_deltaseq()</strong>;
<em>seq</em> <strong>=</strong> <em>datapos</em><strong>.lookup_deltaseq()</strong>;
<em>seq</em> <strong>=</strong> <em>datapos</em><strong>.lookup_deltaseq()</strong>;
</pre>
<p>Return the delta rpm sequence from the structure describing a delta rpm.</p>
<h3>DATA RETRIEVAL METHODS</h3>

<pre>
<strong>const char *lookup_str(Id</strong> <em>keyname</em><strong>)</strong>
my <em>$string</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;lookup_str(</strong><em>$keyname</em><strong>)</strong>;
<em>string</em> <strong>=</strong> <em>datapos</em><strong>.lookup_str(</strong><em>keyname</em><strong>)</strong>
<em>string</em> <strong>=</strong> <em>datapos</em><strong>.lookup_str(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Id lookup_id(Id</strong> <em>solvid</em><strong>, Id</strong> <em>keyname</em><strong>)</strong>
my <em>$id</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;lookup_id(</strong><em>$keyname</em><strong>)</strong>;
<em>id</em> <strong>=</strong> <em>datapos</em><strong>.lookup_id(</strong><em>keyname</em><strong>)</strong>
<em>id</em> <strong>=</strong> <em>datapos</em><strong>.lookup_id(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>unsigned long long lookup_num(Id</strong> <em>keyname</em><strong>, unsigned long long</strong> <em>notfound</em> <strong>= 0)</strong>
my <em>$num</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;lookup_num(</strong><em>$keyname</em><strong>)</strong>;
<em>num</em> <strong>=</strong> <em>datapos</em><strong>.lookup_num(</strong><em>keyname</em><strong>)</strong>
<em>num</em> <strong>=</strong> <em>datapos</em><strong>.lookup_num(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>bool lookup_void(Id</strong> <em>keyname</em><strong>)</strong>
my <em>$bool</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;lookup_void(</strong><em>$keyname</em><strong>)</strong>;
<em>bool</em> <strong>=</strong> <em>datapos</em><strong>.lookup_void(</strong><em>keyname</em><strong>)</strong>
<em>bool</em> <strong>=</strong> <em>datapos</em><strong>.lookup_void(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Id *lookup_idarray(Id</strong> <em>keyname</em><strong>)</strong>
my <em>@ids</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;lookup_idarray(</strong><em>$keyname</em><strong>)</strong>;
<em>ids</em> <strong>=</strong> <em>datapos</em><strong>.lookup_idarray(</strong><em>keyname</em><strong>)</strong>
<em>ids</em> <strong>=</strong> <em>datapos</em><strong>.lookup_idarray(</strong><em>keyname</em><strong>)</strong>
</pre>

<pre>
<strong>Chksum lookup_checksum(Id</strong> <em>keyname</em><strong>)</strong>
my <em>$chksum</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;lookup_checksum(</strong><em>$keyname</em><strong>)</strong>;
<em>chksum</em> <strong>=</strong> <em>datapos</em><strong>.lookup_checksum(</strong><em>keyname</em><strong>)</strong>
<em>chksum</em> <strong>=</strong> <em>datapos</em><strong>.lookup_checksum(</strong><em>keyname</em><strong>)</strong>
</pre>
<p>Lookup functions. Note that the returned Ids are always translated into the Ids of the global pool even if the repodata area contains its own pool.</p>
<pre>
<strong>Dataiterator Dataiterator(Id</strong> <em>keyname</em><strong>, const char *</strong><em>match</em> <strong>= 0, int</strong> <em>flags</em> <strong>= 0)</strong>
my <em>$di</em> <strong>=</strong> <em>$datapos</em><strong>-&gt;Dataiterator(</strong><em>$keyname</em><strong>,</strong> <em>$match</em><strong>,</strong> <em>$flags</em><strong>)</strong>;
<em>di</em> <strong>=</strong> <em>datapos</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
<em>di</em> <strong>=</strong> <em>datapos</em><strong>.Dataiterator(</strong><em>keyname</em><strong>,</strong> <em>match</em><strong>,</strong> <em>flags</em><strong>)</strong>
</pre>

<pre>
<strong>for my</strong> <em>$d</em> <strong>(</strong><em>@$di</em><strong>)</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em><strong>:</strong>
<strong>for</strong> <em>d</em> <strong>in</strong> <em>di</em>
</pre>
<p>Iterate over the matching data elements. See the Dataiterator class for more information.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Michael Schroeder &lt;mls@suse.de&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libsolv.3.html"><span aria-hidden="true">&larr;</span> libsolv.3: Package dependency solver library using a satisfiability algorithm</a></li>
   <li class="next"><a href="libsolv-constantids.3.html">libsolv-constantids.3: Fixed ids for often used strings <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

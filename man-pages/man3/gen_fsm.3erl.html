<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gen_fsm: Generic finite state machine behaviour</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Generic finite state machine behaviour">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gen_fsm (3erl) manual">
  <meta name="twitter:description" content="Generic finite state machine behaviour">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-gen_fsm-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/gen_fsm.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gen_fsm (3erl) manual" />
  <meta property="og:description" content="Generic finite state machine behaviour" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-gen_fsm-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gen_fsm<small> (3erl)</small></h1>
        <p class="lead">Generic finite state machine behaviour</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gen_fsm.3erl.html">
      <span itemprop="name">gen_fsm: Generic finite state machine behaviour</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gen_fsm.3erl.html">
      <span itemprop="name">gen_fsm: Generic finite state machine behaviour</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A behaviour module for implementing a finite state machine. A generic finite state machine process (gen_fsm) implemented using this module will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into an OTP supervision tree. Refer to <strong>OTP Design Principles</strong> for more information.</p><p>A gen_fsm assumes all specific parts to be located in a callback module exporting a pre-defined set of functions. The relationship between the behaviour functions and the callback functions can be illustrated as follows:</p>
<pre>
gen_fsm module                    Callback module
--------------                    ---------------
gen_fsm:start_link                -----&gt; Module:init/1

gen_fsm:send_event                -----&gt; Module:StateName/2

gen_fsm:send_all_state_event      -----&gt; Module:handle_event/3

gen_fsm:sync_send_event           -----&gt; Module:StateName/3

gen_fsm:sync_send_all_state_event -----&gt; Module:handle_sync_event/4

-                                 -----&gt; Module:handle_info/3

-                                 -----&gt; Module:terminate/3

-                                 -----&gt; Module:code_change/4
</pre>
<p>If a callback function fails or returns a bad value, the gen_fsm will terminate.</p><p>A gen_fsm handles system messages as documented in <strong>sys(3erl)</strong>. The <em>sys</em> module can be used for debugging a gen_fsm.</p><p>Note that a gen_fsm does not trap exit signals automatically, this must be explicitly initiated in the callback module.</p><p>Unless otherwise stated, all functions in this module fail if the specified gen_fsm does not exist or if bad arguments are given.</p><p>The gen_fsm process can go into hibernation (see <strong>erlang(3erl)</strong>) if a callback function specifies <em>'hibernate'</em> instead of a timeout value. This might be useful if the server is expected to be idle for a long time. However this feature should be used with care as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you'd want to do between each call to a busy state machine.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> start_link(Module, Args, Options) -&gt; Result</p><p><strong></strong> start_link(FsmName, Module, Args, Options) -&gt; Result</p><p>Types:</p><p>FsmName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</p><p> Name = atom()</p><p> GlobalName = ViaName = term()</p><p>Module = atom()</p><p>Args = term()</p><p>Options = [Option]</p><p> Option = {debug,Dbgs} | {timeout,Time} | {spawn_opt,SOpts}</p><p> Dbgs = [Dbg]</p><p> Dbg = trace | log | statistics</p><p> | {log_to_file,FileName} | {install,{Func,FuncState}}</p><p> SOpts = [SOpt]</p><p> SOpt - see erlang:spawn_opt/2,3,4,5</p><p>Result = {ok,Pid} | ignore | {error,Error}</p><p> Pid = pid()</p><p> Error = {already_started,Pid} | term()</p><p>Creates a gen_fsm process as part of a supervision tree. The function should be called, directly or indirectly, by the supervisor. It will, among other things, ensure that the gen_fsm is linked to the supervisor.</p><p>The gen_fsm process calls <em>Module:init/1</em> to initialize. To ensure a synchronized start-up procedure, <em>start_link/3,4</em> does not return until <em>Module:init/1</em> has returned.</p><p>If <em>FsmName={local,Name}</em>, the gen_fsm is registered locally as <em>Name</em> using <em>register/2</em>. If <em>FsmName={global,GlobalName}</em>, the gen_fsm is registered globally as <em>GlobalName</em> using <em>global:register_name/2</em>. If <em>FsmName={via,Module,ViaName}</em>, the gen_fsm will register with the registry represented by <em>Module</em>. The <em>Module</em> callback should export the functions <em>register_name/2</em>, <em>unregister_name/1</em>, <em>whereis_name/1</em> and <em>send/2</em>, which should behave like the corresponding functions in <em>global</em>. Thus, <em>{via,global,GlobalName}</em> is a valid reference.</p><p>If no name is provided, the gen_fsm is not registered.</p><p><em>Module</em> is the name of the callback module.</p><p><em>Args</em> is an arbitrary term which is passed as the argument to <em>Module:init/1</em>.</p><p>If the option <em>{timeout,Time}</em> is present, the gen_fsm is allowed to spend <em>Time</em> milliseconds initializing or it will be terminated and the start function will return <em>{error,timeout}</em>.</p><p>If the option <em>{debug,Dbgs}</em> is present, the corresponding <em>sys</em> function will be called for each item in <em>Dbgs</em>. See <strong>sys(3erl)</strong>.</p><p>If the option <em>{spawn_opt,SOpts}</em> is present, <em>SOpts</em> will be passed as option list to the <em>spawn_opt</em> BIF which is used to spawn the gen_fsm process. See <strong>erlang(3erl)</strong>.</p><p><strong></strong> Note:</p><p>Using the spawn option <em>monitor</em> is currently not allowed, but will cause the function to fail with reason <em>badarg</em>.</p><p>If the gen_fsm is successfully created and initialized the function returns <em>{ok,Pid}</em>, where <em>Pid</em> is the pid of the gen_fsm. If there already exists a process with the specified <em>FsmName</em>, the function returns <em>{error,{already_started,Pid}}</em> where <em>Pid</em> is the pid of that process.</p><p>If <em>Module:init/1</em> fails with <em>Reason</em>, the function returns <em>{error,Reason}</em>. If <em>Module:init/1</em> returns <em>{stop,Reason}</em> or <em>ignore</em>, the process is terminated and the function returns <em>{error,Reason}</em> or <em>ignore</em>, respectively.</p><p><strong></strong> start(Module, Args, Options) -&gt; Result</p><p><strong></strong> start(FsmName, Module, Args, Options) -&gt; Result</p><p>Types:</p><p>FsmName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</p><p> Name = atom()</p><p> GlobalName = ViaName = term()</p><p>Module = atom()</p><p>Args = term()</p><p>Options = [Option]</p><p> Option = {debug,Dbgs} | {timeout,Time} | {spawn_opt,SOpts}</p><p> Dbgs = [Dbg]</p><p> Dbg = trace | log | statistics</p><p> | {log_to_file,FileName} | {install,{Func,FuncState}}</p><p> SOpts = [term()]</p><p>Result = {ok,Pid} | ignore | {error,Error}</p><p> Pid = pid()</p><p> Error = {already_started,Pid} | term()</p><p>Creates a stand-alone gen_fsm process, i.e. a gen_fsm which is not part of a supervision tree and thus has no supervisor.</p><p>See <strong>start_link/3,4</strong> for a description of arguments and return values.</p><p><strong></strong> send_event(FsmRef, Event) -&gt; ok</p><p>Types:</p><p>FsmRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Event = term()</p><p>Sends an event asynchronously to the gen_fsm <em>FsmRef</em> and returns <em>ok</em> immediately. The gen_fsm will call <em>Module:StateName/2</em> to handle the event, where <em>StateName</em> is the name of the current state of the gen_fsm.</p><p><em>FsmRef</em> can be:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>the pid,</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Name</em>, if the gen_fsm is locally registered,</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{Name,Node}</em>, if the gen_fsm is locally registered at another node, or</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{global,GlobalName}</em>, if the gen_fsm is globally registered.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{via,Module,ViaName}</em>, if the gen_fsm is registered through an alternative process registry.</p>
  </dd>

</dl>
<p><em>Event</em> is an arbitrary term which is passed as one of the arguments to <em>Module:StateName/2</em>.</p><p><strong></strong> send_all_state_event(FsmRef, Event) -&gt; ok</p><p>Types:</p><p>FsmRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Event = term()</p><p>Sends an event asynchronously to the gen_fsm <em>FsmRef</em> and returns <em>ok</em> immediately. The gen_fsm will call <em>Module:handle_event/3</em> to handle the event.</p><p>See <strong>send_event/2</strong> for a description of the arguments.</p><p>The difference between <em>send_event</em> and <em>send_all_state_event</em> is which callback function is used to handle the event. This function is useful when sending events that are handled the same way in every state, as only one <em>handle_event</em> clause is needed to handle the event instead of one clause in each state name function.</p><p><strong></strong> sync_send_event(FsmRef, Event) -&gt; Reply</p><p><strong></strong> sync_send_event(FsmRef, Event, Timeout) -&gt; Reply</p><p>Types:</p><p>FsmRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Event = term()</p><p>Timeout = int()&gt;0 | infinity</p><p>Reply = term()</p><p>Sends an event to the gen_fsm <em>FsmRef</em> and waits until a reply arrives or a timeout occurs. The gen_fsm will call <em>Module:StateName/3</em> to handle the event, where <em>StateName</em> is the name of the current state of the gen_fsm.</p><p>See <strong>send_event/2</strong> for a description of <em>FsmRef</em> and <em>Event</em>.</p><p><em>Timeout</em> is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom <em>infinity</em> to wait indefinitely. Default value is 5000. If no reply is received within the specified time, the function call fails.</p><p>The return value <em>Reply</em> is defined in the return value of <em>Module:StateName/3</em>.</p><p>The ancient behaviour of sometimes consuming the server exit message if the server died during the call while linked to the client has been removed in OTP R12B/Erlang 5.6.</p><p><strong></strong> sync_send_all_state_event(FsmRef, Event) -&gt; Reply</p><p><strong></strong> sync_send_all_state_event(FsmRef, Event, Timeout) -&gt; Reply</p><p>Types:</p><p>FsmRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Event = term()</p><p>Timeout = int()&gt;0 | infinity</p><p>Reply = term()</p><p>Sends an event to the gen_fsm <em>FsmRef</em> and waits until a reply arrives or a timeout occurs. The gen_fsm will call <em>Module:handle_sync_event/4</em> to handle the event.</p><p>See <strong>send_event/2</strong> for a description of <em>FsmRef</em> and <em>Event</em>. See <strong>sync_send_event/3</strong> for a description of <em>Timeout</em> and <em>Reply</em>.</p><p>See <strong>send_all_state_event/2</strong> for a discussion about the difference between <em>sync_send_event</em> and <em>sync_send_all_state_event</em>.</p><p><strong></strong> reply(Caller, Reply) -&gt; true</p><p>Types:</p><p>Caller - see below</p><p>Reply = term()</p><p>This function can be used by a gen_fsm to explicitly send a reply to a client process that called <strong>sync_send_event/2,3</strong> or <strong>sync_send_all_state_event/2,3</strong>, when the reply cannot be defined in the return value of <em>Module:State/3</em> or <em>Module:handle_sync_event/4</em>.</p><p><em>Caller</em> must be the <em>From</em> argument provided to the callback function. <em>Reply</em> is an arbitrary term, which will be given back to the client as the return value of <em>sync_send_event/2,3</em> or <em>sync_send_all_state_event/2,3</em>.</p><p><strong></strong> send_event_after(Time, Event) -&gt; Ref</p><p>Types:</p><p>Time = integer()</p><p>Event = term()</p><p>Ref = reference()</p><p>Sends a delayed event internally in the gen_fsm that calls this function after <em>Time</em> ms. Returns immediately a reference that can be used to cancel the delayed send using <strong>cancel_timer/1</strong>.</p><p>The gen_fsm will call <em>Module:StateName/2</em> to handle the event, where <em>StateName</em> is the name of the current state of the gen_fsm at the time the delayed event is delivered.</p><p><em>Event</em> is an arbitrary term which is passed as one of the arguments to <em>Module:StateName/2</em>.</p><p><strong></strong> start_timer(Time, Msg) -&gt; Ref</p><p>Types:</p><p>Time = integer()</p><p>Msg = term()</p><p>Ref = reference()</p><p>Sends a timeout event internally in the gen_fsm that calls this function after <em>Time</em> ms. Returns immediately a reference that can be used to cancel the timer using <strong>cancel_timer/1</strong>.</p><p>The gen_fsm will call <em>Module:StateName/2</em> to handle the event, where <em>StateName</em> is the name of the current state of the gen_fsm at the time the timeout message is delivered.</p><p><em>Msg</em> is an arbitrary term which is passed in the timeout message, <em>{timeout, Ref, Msg}</em>, as one of the arguments to <em>Module:StateName/2</em>.</p><p><strong></strong> cancel_timer(Ref) -&gt; RemainingTime | false</p><p>Types:</p><p>Ref = reference()</p><p>RemainingTime = integer()</p><p>Cancels an internal timer referred by <em>Ref</em> in the gen_fsm that calls this function.</p><p><em>Ref</em> is a reference returned from <strong>send_event_after/2</strong> or <strong>start_timer/2</strong>.</p><p>If the timer has already timed out, but the event not yet been delivered, it is cancelled as if it had <em>not</em> timed out, so there will be no false timer event after returning from this function.</p><p>Returns the remaining time in ms until the timer would have expired if <em>Ref</em> referred to an active timer, <em>false</em> otherwise.</p><p><strong></strong> enter_loop(Module, Options, StateName, StateData)</p><p><strong></strong> enter_loop(Module, Options, StateName, StateData, FsmName)</p><p><strong></strong> enter_loop(Module, Options, StateName, StateData, Timeout)</p><p><strong></strong> enter_loop(Module, Options, StateName, StateData, FsmName, Timeout)</p><p>Types:</p><p>Module = atom()</p><p>Options = [Option]</p><p> Option = {debug,Dbgs}</p><p> Dbgs = [Dbg]</p><p> Dbg = trace | log | statistics</p><p> | {log_to_file,FileName} | {install,{Func,FuncState}}</p><p>StateName = atom()</p><p>StateData = term()</p><p>FsmName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</p><p> Name = atom()</p><p> GlobalName = ViaName = term()</p><p>Timeout = int() | infinity</p><p>Makes an existing process into a gen_fsm. Does not return, instead the calling process will enter the gen_fsm receive loop and become a gen_fsm process. The process <em>must</em> have been started using one of the start functions in <em>proc_lib</em>, see <strong>proc_lib(3erl)</strong>. The user is responsible for any initialization of the process, including registering a name for it.</p><p>This function is useful when a more complex initialization procedure is needed than the gen_fsm behaviour provides.</p><p><em>Module</em>, <em>Options</em> and <em>FsmName</em> have the same meanings as when calling <strong>start[_link]/3,4</strong>. However, if <em>FsmName</em> is specified, the process must have been registered accordingly <em>before</em> this function is called.</p><p><em>StateName</em>, <em>StateData</em> and <em>Timeout</em> have the same meanings as in the return value of <strong>Module:init/1</strong>. Also, the callback module <em>Module</em> does not need to export an <em>init/1</em> function.</p><p>Failure: If the calling process was not started by a <em>proc_lib</em> start function, or if it is not registered according to <em>FsmName</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACK FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The following functions should be exported from a <em>gen_fsm</em> callback module.</p><p>In the description, the expression <em>state name</em> is used to denote a state of the state machine. <em>state data</em> is used to denote the internal state of the Erlang process which implements the state machine.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> Module:init(Args) -&gt; Result</p><p>Types:</p><p>Args = term()</p><p>Result = {ok,StateName,StateData} | {ok,StateName,StateData,Timeout}</p><p> | {ok,StateName,StateData,hibernate}</p><p> | {stop,Reason} | ignore</p><p> StateName = atom()</p><p> StateData = term()</p><p> Timeout = int()&gt;0 | infinity</p><p> Reason = term()</p><p>Whenever a gen_fsm is started using <strong>gen_fsm:start/3,4</strong> or <strong>gen_fsm:start_link/3,4</strong>, this function is called by the new process to initialize.</p><p><em>Args</em> is the <em>Args</em> argument provided to the start function.</p><p>If initialization is successful, the function should return <em>{ok,StateName,StateData}</em>, <em>{ok,StateName,StateData,Timeout}</em> or <em>{ok,StateName,StateData,hibernate}</em>, where <em>StateName</em> is the initial state name and <em>StateData</em> the initial state data of the gen_fsm.</p><p>If an integer timeout value is provided, a timeout will occur unless an event or a message is received within <em>Timeout</em> milliseconds. A timeout is represented by the atom <em>timeout</em> and should be handled by the <em>Module:StateName/2</em> callback functions. The atom <em>infinity</em> can be used to wait indefinitely, this is the default value.</p><p>If <em>hibernate</em> is specified instead of a timeout value, the process will go into hibernation when waiting for the next message to arrive (by calling <strong>proc_lib:hibernate/3</strong>).</p><p>If something goes wrong during the initialization the function should return <em>{stop,Reason}</em>, where <em>Reason</em> is any term, or <em>ignore</em>.</p><p><strong></strong> Module:StateName(Event, StateData) -&gt; Result</p><p>Types:</p><p>Event = timeout | term()</p><p>StateData = term()</p><p>Result = {next_state,NextStateName,NewStateData}</p><p> | {next_state,NextStateName,NewStateData,Timeout}</p><p> | {next_state,NextStateName,NewStateData,hibernate}</p><p> | {stop,Reason,NewStateData}</p><p> NextStateName = atom()</p><p> NewStateData = term()</p><p> Timeout = int()&gt;0 | infinity</p><p> Reason = term()</p><p>There should be one instance of this function for each possible state name. Whenever a gen_fsm receives an event sent using <strong>gen_fsm:send_event/2</strong>, the instance of this function with the same name as the current state name <em>StateName</em> is called to handle the event. It is also called if a timeout occurs.</p><p><em>Event</em> is either the atom <em>timeout</em>, if a timeout has occurred, or the <em>Event</em> argument provided to <em>send_event/2</em>.</p><p><em>StateData</em> is the state data of the gen_fsm.</p><p>If the function returns <em>{next_state,NextStateName,NewStateData}</em>, <em>{next_state,NextStateName,NewStateData,Timeout}</em> or <em>{next_state,NextStateName,NewStateData,hibernate}</em>, the gen_fsm will continue executing with the current state name set to <em>NextStateName</em> and with the possibly updated state data <em>NewStateData</em>. See <em>Module:init/1</em> for a description of <em>Timeout</em> and <em>hibernate</em>.</p><p>If the function returns <em>{stop,Reason,NewStateData}</em>, the gen_fsm will call <em>Module:terminate(Reason,NewStateData)</em> and terminate.</p><p><strong></strong> Module:handle_event(Event, StateName, StateData) -&gt; Result</p><p>Types:</p><p>Event = term()</p><p>StateName = atom()</p><p>StateData = term()</p><p>Result = {next_state,NextStateName,NewStateData}</p><p> | {next_state,NextStateName,NewStateData,Timeout}</p><p> | {next_state,NextStateName,NewStateData,hibernate}</p><p> | {stop,Reason,NewStateData}</p><p> NextStateName = atom()</p><p> NewStateData = term()</p><p> Timeout = int()&gt;0 | infinity</p><p> Reason = term()</p><p>Whenever a gen_fsm receives an event sent using <strong>gen_fsm:send_all_state_event/2</strong>, this function is called to handle the event.</p><p><em>StateName</em> is the current state name of the gen_fsm.</p><p>See <em>Module:StateName/2</em> for a description of the other arguments and possible return values.</p><p><strong></strong> Module:StateName(Event, From, StateData) -&gt; Result</p><p>Types:</p><p>Event = term()</p><p>From = {pid(),Tag}</p><p>StateData = term()</p><p>Result = {reply,Reply,NextStateName,NewStateData}</p><p> | {reply,Reply,NextStateName,NewStateData,Timeout}</p><p> | {reply,Reply,NextStateName,NewStateData,hibernate}</p><p> | {next_state,NextStateName,NewStateData}</p><p> | {next_state,NextStateName,NewStateData,Timeout}</p><p> | {next_state,NextStateName,NewStateData,hibernate}</p><p> | {stop,Reason,Reply,NewStateData} | {stop,Reason,NewStateData}</p><p> Reply = term()</p><p> NextStateName = atom()</p><p> NewStateData = term()</p><p> Timeout = int()&gt;0 | infinity</p><p> Reason = normal | term()</p><p>There should be one instance of this function for each possible state name. Whenever a gen_fsm receives an event sent using <strong>gen_fsm:sync_send_event/2,3</strong>, the instance of this function with the same name as the current state name <em>StateName</em> is called to handle the event.</p><p><em>Event</em> is the <em>Event</em> argument provided to <em>sync_send_event</em>.</p><p><em>From</em> is a tuple <em>{Pid,Tag}</em> where <em>Pid</em> is the pid of the process which called <em>sync_send_event/2,3</em> and <em>Tag</em> is a unique tag.</p><p><em>StateData</em> is the state data of the gen_fsm.</p><p>If the function returns <em>{reply,Reply,NextStateName,NewStateData}</em>, <em>{reply,Reply,NextStateName,NewStateData,Timeout}</em> or <em>{reply,Reply,NextStateName,NewStateData,hibernate}</em>, <em>Reply</em> will be given back to <em>From</em> as the return value of <em>sync_send_event/2,3</em>. The gen_fsm then continues executing with the current state name set to <em>NextStateName</em> and with the possibly updated state data <em>NewStateData</em>. See <em>Module:init/1</em> for a description of <em>Timeout</em> and <em>hibernate</em>.</p><p>If the function returns <em>{next_state,NextStateName,NewStateData}</em>, <em>{next_state,NextStateName,NewStateData,Timeout}</em> or <em>{next_state,NextStateName,NewStateData,hibernate}</em>, the gen_fsm will continue executing in <em>NextStateName</em> with <em>NewStateData</em>. Any reply to <em>From</em> must be given explicitly using <strong>gen_fsm:reply/2</strong>.</p><p>If the function returns <em>{stop,Reason,Reply,NewStateData}</em>, <em>Reply</em> will be given back to <em>From</em>. If the function returns <em>{stop,Reason,NewStateData}</em>, any reply to <em>From</em> must be given explicitly using <em>gen_fsm:reply/2</em>. The gen_fsm will then call <em>Module:terminate(Reason,NewStateData)</em> and terminate.</p><p><strong></strong> Module:handle_sync_event(Event, From, StateName, StateData) -&gt; Result</p><p>Types:</p><p>Event = term()</p><p>From = {pid(),Tag}</p><p>StateName = atom()</p><p>StateData = term()</p><p>Result = {reply,Reply,NextStateName,NewStateData}</p><p> | {reply,Reply,NextStateName,NewStateData,Timeout}</p><p> | {reply,Reply,NextStateName,NewStateData,hibernate}</p><p> | {next_state,NextStateName,NewStateData}</p><p> | {next_state,NextStateName,NewStateData,Timeout}</p><p> | {next_state,NextStateName,NewStateData,hibernate}</p><p> | {stop,Reason,Reply,NewStateData} | {stop,Reason,NewStateData}</p><p> Reply = term()</p><p> NextStateName = atom()</p><p> NewStateData = term()</p><p> Timeout = int()&gt;0 | infinity</p><p> Reason = term()</p><p>Whenever a gen_fsm receives an event sent using <strong>gen_fsm:sync_send_all_state_event/2,3</strong>, this function is called to handle the event.</p><p><em>StateName</em> is the current state name of the gen_fsm.</p><p>See <em>Module:StateName/3</em> for a description of the other arguments and possible return values.</p><p><strong></strong> Module:handle_info(Info, StateName, StateData) -&gt; Result</p><p>Types:</p><p>Info = term()</p><p>StateName = atom()</p><p>StateData = term()</p><p>Result = {next_state,NextStateName,NewStateData}</p><p> | {next_state,NextStateName,NewStateData,Timeout}</p><p> | {next_state,NextStateName,NewStateData,hibernate}</p><p> | {stop,Reason,NewStateData}</p><p> NextStateName = atom()</p><p> NewStateData = term()</p><p> Timeout = int()&gt;0 | infinity</p><p> Reason = normal | term()</p><p>This function is called by a gen_fsm when it receives any other message than a synchronous or asynchronous event (or a system message).</p><p><em>Info</em> is the received message.</p><p>See <em>Module:StateName/2</em> for a description of the other arguments and possible return values.</p><p><strong></strong> Module:terminate(Reason, StateName, StateData)</p><p>Types:</p><p>Reason = normal | shutdown | {shutdown,term()} | term()</p><p>StateName = atom()</p><p>StateData = term()</p><p>This function is called by a gen_fsm when it is about to terminate. It should be the opposite of <em>Module:init/1</em> and do any necessary cleaning up. When it returns, the gen_fsm terminates with <em>Reason</em>. The return value is ignored.</p><p><em>Reason</em> is a term denoting the stop reason, <em>StateName</em> is the current state name, and <em>StateData</em> is the state data of the gen_fsm.</p><p><em>Reason</em> depends on why the gen_fsm is terminating. If it is because another callback function has returned a stop tuple <em>{stop,..}</em>, <em>Reason</em> will have the value specified in that tuple. If it is due to a failure, <em>Reason</em> is the error reason.</p><p>If the gen_fsm is part of a supervision tree and is ordered by its supervisor to terminate, this function will be called with <em>Reason=shutdown</em> if the following conditions apply:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>the gen_fsm has been set to trap exit signals, and</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>the shutdown strategy as defined in the supervisor's child specification is an integer timeout value, not <em>brutal_kill</em>.</p>
  </dd>

</dl>
<p>Even if the gen_fsm is <em>not</em> part of a supervision tree, this function will be called if it receives an <em>'EXIT'</em> message from its parent. <em>Reason</em> will be the same as in the <em>'EXIT'</em> message.</p><p>Otherwise, the gen_fsm will be immediately terminated.</p><p>Note that for any other reason than <em>normal</em>, <em>shutdown</em>, or <em>{shutdown,Term}</em> the gen_fsm is assumed to terminate due to an error and an error report is issued using <strong>error_logger:format/2</strong>.</p><p><strong></strong> Module:code_change(OldVsn, StateName, StateData, Extra) -&gt; {ok, NextStateName, NewStateData}</p><p>Types:</p><p>OldVsn = Vsn | {down, Vsn}</p><p> Vsn = term()</p><p>StateName = NextStateName = atom()</p><p>StateData = NewStateData = term()</p><p>Extra = term()</p><p>This function is called by a gen_fsm when it should update its internal state data during a release upgrade/downgrade, i.e. when the instruction <em>{update,Module,Change,...}</em> where <em>Change={advanced,Extra}</em> is given in the <em>appup</em> file. See <strong>OTP Design Principles</strong>.</p><p>In the case of an upgrade, <em>OldVsn</em> is <em>Vsn</em>, and in the case of a downgrade, <em>OldVsn</em> is <em>{down,Vsn}</em>. <em>Vsn</em> is defined by the <em>vsn</em> attribute(s) of the old version of the callback module <em>Module</em>. If no such attribute is defined, the version is the checksum of the BEAM file.</p><p><em>StateName</em> is the current state name and <em>StateData</em> the internal state data of the gen_fsm.</p><p><em>Extra</em> is passed as-is from the <em>{advanced,Extra}</em> part of the update instruction.</p><p>The function should return the new current state name and updated internal data.</p><p><strong></strong> Module:format_status(Opt, [PDict, StateData]) -&gt; Status</p><p>Types:</p><p>Opt = normal | terminate</p><p>PDict = [{Key, Value}]</p><p>StateData = term()</p><p>Status = term()</p><p><strong></strong> Note:</p><p>This callback is optional, so callback modules need not export it. The gen_fsm module provides a default implementation of this function that returns the callback module state data.</p><p>This function is called by a gen_fsm process when:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>One of <strong>sys:get_status/1,2</strong> is invoked to get the gen_fsm status. <em>Opt</em> is set to the atom <em>normal</em> for this case.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>The gen_fsm terminates abnormally and logs an error. <em>Opt</em> is set to the atom <em>terminate</em> for this case.</p>
  </dd>

</dl>
<p>This function is useful for customising the form and appearance of the gen_fsm status for these cases. A callback module wishing to customise the <em>sys:get_status/1,2</em> return value as well as how its status appears in termination error logs exports an instance of <em>format_status/2</em> that returns a term describing the current status of the gen_fsm.</p><p><em>PDict</em> is the current value of the gen_fsm's process dictionary.</p><p><em>StateData</em> is the internal state data of the gen_fsm.</p><p>The function should return <em>Status</em>, a term that customises the details of the current state and status of the gen_fsm. There are no restrictions on the form <em>Status</em> can take, but for the <em>sys:get_status/1,2</em> case (when <em>Opt</em> is <em>normal</em>), the recommended form for the <em>Status</em> value is <em>[{data, [{"StateData", Term}]}]</em> where <em>Term</em> provides relevant details of the gen_fsm state data. Following this recommendation isn't required, but doing so will make the callback module status consistent with the rest of the <em>sys:get_status/1,2</em> return value.</p><p>One use for this function is to return compact alternative state data representations to avoid having large state terms printed in logfiles.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO gen_fsm&hellip;</h2>
        <div class="sectioncontent">
<p><strong>gen_event(3erl)</strong>, <strong>gen_server(3erl)</strong>, <strong>supervisor(3erl)</strong>, <strong>proc_lib(3erl)</strong>, <strong>sys(3erl)</strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gen_event.3erl.html"><span aria-hidden="true">&larr;</span> gen_event.3erl: Generic event handling behaviour</a></li>
   <li class="next"><a href="gen_sctp.3erl.html">gen_sctp.3erl: The gen_sctp module provides functions for communicating with sockets using the sctp protocol. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ei: Routines for handling the erlang binary term format</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Routines for handling the erlang binary term format">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ei (3erl) manual">
  <meta name="twitter:description" content="Routines for handling the erlang binary term format">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-ei-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/ei.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ei (3erl) manual" />
  <meta property="og:description" content="Routines for handling the erlang binary term format" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-ei-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ei<small> (3erl)</small></h1>
        <p class="lead">Routines for handling the erlang binary term format</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ei.3erl.html">
      <span itemprop="name">ei: Routines for handling the erlang binary term format</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ei.3erl.html">
      <span itemprop="name">ei: Routines for handling the erlang binary term format</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The library <em>ei</em> contains macros and functions to encode and decode the erlang binary term format.</p><p>With <em>ei</em>, you can convert atoms, lists, numbers and binaries to and from the binary format. This is useful when writing port programs and drivers. <em>ei</em> uses a given buffer, and no dynamic memory (with the exception of <em>ei_decode_fun()</em>), and is often quite fast.</p><p>It also handles C-nodes, C-programs that talks erlang distribution with erlang nodes (or other C-nodes) using the erlang distribution format. The difference between <em>ei</em> and <em>erl_interface</em> is that <em>ei</em> uses the binary format directly when sending and receiving terms. It is also thread safe, and using threads, one process can handle multiple C-nodes. The <em>erl_interface</em> library is built on top of <em>ei</em>, but of legacy reasons, it doesn't allow for multiple C-nodes. In general, <em>ei</em> is the preferred way of doing C-nodes.</p><p>The decode and encode functions use a buffer an index into the buffer, which points at the point where to encode and decode. The index is updated to point right after the term encoded/decoded. No checking is done whether the term fits in the buffer or not. If encoding goes outside the buffer, the program may crash.</p><p>All functions takes two parameter, <em>buf</em> is a pointer to the buffer where the binary data is / will be, <em>index</em> is a pointer to an index into the buffer. This parameter will be incremented with the size of the term decoded / encoded. The data is thus at <em>buf[*index]</em> when an <em>ei</em> function is called.</p><p>The encode functions all assumes that the <em>buf</em> and <em>index</em> parameters points to a buffer big enough for the data. To get the size of an encoded term, without encoding it, pass <em>NULL</em> instead of a buffer pointer. The <em>index</em> parameter will be incremented, but nothing will be encoded. This is the way in <em>ei</em> to "preflight" term encoding.</p><p>There are also encode-functions that uses a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions: those starting with <em>ei_x</em>, uses a dynamic buffer.</p><p>All functions return <em>0</em> if successful, and <em>-1</em> if not. (For instance, if a term is not of the expected type, or the data to decode is not a valid erlang term.)</p><p>Some of the decode-functions needs a preallocated buffer. This buffer must be allocated big enough, and for non compound types the <em>ei_get_type()</em> function returns the size required (note that for strings an extra byte is needed for the 0 string terminator).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>erlang_char_encoding:</p>
  </dd>

</dl>

<pre>
typedef enum {
    ERLANG_ASCII = 1,
    ERLANG_LATIN1 = 2,
    ERLANG_UTF8 = 4
}erlang_char_encoding;

</pre>
<p>The character encodings used for atoms. <em>ERLANG_ASCII</em> represents 7-bit ASCII. Latin1 and UTF8 are different extensions of 7-bit ASCII. All 7-bit ASCII characters are valid Latin1 and UTF8 characters. ASCII and Latin1 both represent each character by one byte. A UTF8 character can consist of one to four bytes. Note that these constants are bit-flags and can be combined with bitwise-or.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> void ei_set_compat_rel(release_number)</p><p>Types:</p><p>unsigned release_number;</p><p>By default, the <em>ei</em> library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the <em>ei</em> library itself. For example, <em>ei</em> from the OTP R10 release is not compatible with an Erlang emulator from the OTP R9 release by default.</p><p>A call to <em>ei_set_compat_rel(release_number)</em> sets the <em>ei</em> library in compatibility mode of release <em>release_number</em>. Valid range of <em>release_number</em> is [7, current release]. This makes it possible to communicate with Erlang/OTP components from earlier releases.</p><p><strong></strong> Note:</p><p>If this function is called, it may only be called once and must be called before any other functions in the <em>ei</em> library is called.</p><p><strong></strong> Warning:</p><p>You may run into trouble if this feature is used carelessly. Always make sure that all communicating components are either from the same Erlang/OTP release, or from release X and release Y where all components from release Y are in compatibility mode of release X.</p><p><strong></strong> int ei_encode_version(char *buf, int *index)</p><p><strong></strong> int ei_x_encode_version(ei_x_buff* x)</p><p>Encodes a version magic number for the binary format. Must be the first token in a binary term.</p><p><strong></strong> int ei_encode_long(char *buf, int *index, long p)</p><p><strong></strong> int ei_x_encode_long(ei_x_buff* x, long p)</p><p>Encodes a long integer in the binary format. Note that if the code is 64 bits the function ei_encode_long() is exactly the same as ei_encode_longlong().</p><p><strong></strong> int ei_encode_ulong(char *buf, int *index, unsigned long p)</p><p><strong></strong> int ei_x_encode_ulong(ei_x_buff* x, unsigned long p)</p><p>Encodes an unsigned long integer in the binary format. Note that if the code is 64 bits the function ei_encode_ulong() is exactly the same as ei_encode_ulonglong().</p><p><strong></strong> int ei_encode_longlong(char *buf, int *index, long long p)</p><p><strong></strong> int ei_x_encode_longlong(ei_x_buff* x, long long p)</p><p>Encodes a GCC <em>long long</em> or Visual C++ <em>__int64</em> (64 bit) integer in the binary format. Note that this function is missing in the VxWorks port.</p><p><strong></strong> int ei_encode_ulonglong(char *buf, int *index, unsigned long long p)</p><p><strong></strong> int ei_x_encode_ulonglong(ei_x_buff* x, unsigned long long p)</p><p>Encodes a GCC <em>unsigned long long</em> or Visual C++ <em>unsigned __int64</em> (64 bit) integer in the binary format. Note that this function is missing in the VxWorks port.</p><p><strong></strong> int ei_encode_bignum(char *buf, int *index, mpz_t obj)</p><p><strong></strong> int ei_x_encode_bignum(ei_x_buff *x, mpz_t obj)</p><p>Encodes a GMP <em>mpz_t</em> integer to binary format. To use this function the ei library needs to be configured and compiled to use the GMP library.</p><p><strong></strong> int ei_encode_double(char *buf, int *index, double p)</p><p><strong></strong> int ei_x_encode_double(ei_x_buff* x, double p)</p><p>Encodes a double-precision (64 bit) floating point number in the binary format.</p><p><strong></strong> int ei_encode_boolean(char *buf, int *index, int p)</p><p><strong></strong> int ei_x_encode_boolean(ei_x_buff* x, int p)</p><p>Encodes a boolean value, as the atom <em>true</em> if p is not zero or <em>false</em> if p is zero.</p><p><strong></strong> int ei_encode_char(char *buf, int *index, char p)</p><p><strong></strong> int ei_x_encode_char(ei_x_buff* x, char p)</p><p>Encodes a char (8-bit) as an integer between 0-255 in the binary format. Note that for historical reasons the integer argument is of type <em>char</em>. Your C code should consider the given argument to be of type <em>unsigned char</em> even if the C compilers and system may define <em>char</em> to be signed.</p><p><strong></strong> int ei_encode_string(char *buf, int *index, const char *p)</p><p><strong></strong> int ei_encode_string_len(char *buf, int *index, const char *p, int len)</p><p><strong></strong> int ei_x_encode_string(ei_x_buff* x, const char *p)</p><p><strong></strong> int ei_x_encode_string_len(ei_x_buff* x, const char* s, int len)</p><p>Encodes a string in the binary format. (A string in erlang is a list, but is encoded as a character array in the binary format.) The string should be zero-terminated, except for the <em>ei_x_encode_string_len()</em> function.</p><p><strong></strong> int ei_encode_atom(char *buf, int *index, const char *p)</p><p><strong></strong> int ei_encode_atom_len(char *buf, int *index, const char *p, int len)</p><p><strong></strong> int ei_x_encode_atom(ei_x_buff* x, const char *p)</p><p><strong></strong> int ei_x_encode_atom_len(ei_x_buff* x, const char *p, int len)</p><p>Encodes an atom in the binary format. The <em>p</em> parameter is the name of the atom in latin1 encoding. Only upto <em>MAXATOMLEN-1</em> bytes are encoded. The name should be zero-terminated, except for the <em>ei_x_encode_atom_len()</em> function.</p><p><strong></strong> int ei_encode_atom_as(char *buf, int *index, const char *p, erlang_char_encoding from_enc, erlang_char_encoding to_enc)</p><p><strong></strong> int ei_encode_atom_len_as(char *buf, int *index, const char *p, int len, erlang_char_encoding from_enc, erlang_char_encoding to_enc)</p><p><strong></strong> int ei_x_encode_atom_as(ei_x_buff* x, const char *p, erlang_char_encoding from_enc, erlang_char_encoding to_enc)</p><p><strong></strong> int ei_x_encode_atom_len_as(ei_x_buff* x, const char *p, int len, erlang_char_encoding from_enc, erlang_char_encoding to_enc)</p><p>Encodes an atom in the binary format with character encoding <em></em><strong>to_enc</strong> (latin1 or utf8). The <em>p</em> parameter is the name of the atom with character encoding <em></em><strong>from_enc</strong> (ascii, latin1 or utf8). The name must either be zero-terminated or a function variant with a <em>len</em> parameter must be used. If <em>to_enc</em> is set to the bitwise-or'd combination <em>(ERLANG_LATIN1|ERLANG_UTF8)</em>, utf8 encoding is only used if the atom string can not be represented in latin1 encoding.</p><p>The encoding will fail if <em>p</em> is not a valid string in encoding <em>from_enc</em>, if the string is too long or if it can not be represented with character encoding <em>to_enc</em>.</p><p>These functions were introduced in R16 release of Erlang/OTP as part of a first step to support UTF8 atoms. Atoms encoded with <em>ERLANG_UTF8</em> can not be decoded by earlier releases than R16.</p><p><strong></strong> int ei_encode_binary(char *buf, int *index, const void *p, long len)</p><p><strong></strong> int ei_x_encode_binary(ei_x_buff* x, const void *p, long len)</p><p>Encodes a binary in the binary format. The data is at <em>p</em>, of <em>len</em> bytes length.</p><p><strong></strong> int ei_encode_pid(char *buf, int *index, const erlang_pid *p)</p><p><strong></strong> int ei_x_encode_pid(ei_x_buff* x, const erlang_pid *p)</p><p>Encodes an erlang process identifier, pid, in the binary format. The <em>p</em> parameter points to an <em>erlang_pid</em> structure (which should have been obtained earlier with <em>ei_decode_pid()</em>).</p><p><strong></strong> int ei_encode_fun(char *buf, int *index, const erlang_fun *p)</p><p><strong></strong> int ei_x_encode_fun(ei_x_buff* x, const erlang_fun* fun)</p><p>Encodes a fun in the binary format. The <em>p</em> parameter points to an <em>erlang_fun</em> structure. The <em>erlang_fun</em> is not freed automatically, the <em>free_fun</em> should be called if the fun is not needed after encoding.</p><p><strong></strong> int ei_encode_port(char *buf, int *index, const erlang_port *p)</p><p><strong></strong> int ei_x_encode_port(ei_x_buff* x, const erlang_port *p)</p><p>Encodes an erlang port in the binary format. The <em>p</em> parameter points to a <em>erlang_port</em> structure (which should have been obtained earlier with <em>ei_decode_port()</em>.</p><p><strong></strong> int ei_encode_ref(char *buf, int *index, const erlang_ref *p)</p><p><strong></strong> int ei_x_encode_ref(ei_x_buff* x, const erlang_ref *p)</p><p>Encodes an erlang reference in the binary format. The <em>p</em> parameter points to a <em>erlang_ref</em> structure (which should have been obtained earlier with <em>ei_decode_ref()</em>.</p><p><strong></strong> int ei_encode_term(char *buf, int *index, void *t)</p><p><strong></strong> int ei_x_encode_term(ei_x_buff* x, void *t)</p><p>This function encodes an <em>ETERM</em>, as obtained from <em>erl_interface</em>. The <em>t</em> parameter is actually an <em>ETERM</em> pointer. This function doesn't free the <em>ETERM</em>.</p><p><strong></strong> int ei_encode_trace(char *buf, int *index, const erlang_trace *p)</p><p><strong></strong> int ei_x_encode_trace(ei_x_buff* x, const erlang_trace *p)</p><p>This function encodes an erlang trace token in the binary format. The <em>p</em> parameter points to a <em>erlang_trace</em> structure (which should have been obtained earlier with <em>ei_decode_trace()</em>.</p><p><strong></strong> int ei_encode_tuple_header(char *buf, int *index, int arity)</p><p><strong></strong> int ei_x_encode_tuple_header(ei_x_buff* x, int arity)</p><p>This function encodes a tuple header, with a specified arity. The next <em>arity</em> terms encoded will be the elements of the tuple. Tuples and lists are encoded recursively, so that a tuple may contain another tuple or list.</p><p>E.g. to encode the tuple <em>{a, {b, {}}}</em>:</p>
<pre>
ei_encode_tuple_header(buf, &i, 2);
ei_encode_atom(buf, &i, "a");
ei_encode_tuple_header(buf, &i, 2);
ei_encode_atom(buf, &i, "b");
ei_encode_tuple_header(buf, &i, 0);

</pre>
<p><strong></strong> int ei_encode_list_header(char *buf, int *index, int arity)</p><p><strong></strong> int ei_x_encode_list_header(ei_x_buff* x, int arity)</p><p>This function encodes a list header, with a specified arity. The next <em>arity+1</em> terms are the elements (actually its <em>arity</em> cons cells) and the tail of the list. Lists and tuples are encoded recursively, so that a list may contain another list or tuple.</p><p>E.g. to encode the list <em>[c, d, [e | f]]</em>:</p>
<pre>
ei_encode_list_header(buf, &i, 3);
ei_encode_atom(buf, &i, "c");
ei_encode_atom(buf, &i, "d");
ei_encode_list_header(buf, &i, 1);
ei_encode_atom(buf, &i, "e");
ei_encode_atom(buf, &i, "f");
ei_encode_empty_list(buf, &i);

</pre>
<p><strong></strong> Note:</p><p>It may seem that there is no way to create a list without knowing the number of elements in advance. But indeed there is a way. Note that the list <em>[a, b, c]</em> can be written as <em>[a | [b | [c]]]</em>. Using this, a list can be written as conses.</p><p>To encode a list, without knowing the arity in advance:</p>
<pre>
while (something()) {
    ei_x_encode_list_header(&x, 1);
    ei_x_encode_ulong(&x, i); /* just an example */
}
ei_x_encode_empty_list(&x);

</pre>
<p><strong></strong> int ei_encode_empty_list(char* buf, int* index)</p><p><strong></strong> int ei_x_encode_empty_list(ei_x_buff* x)</p><p>This function encodes an empty list. It's often used at the tail of a list.</p><p><strong></strong> int ei_encode_map_header(char *buf, int *index, int arity)</p><p><strong></strong> int ei_x_encode_map_header(ei_x_buff* x, int arity)</p><p>This function encodes a map header, with a specified arity. The next <em>arity*2</em> terms encoded will be the keys and values of the map encoded in the following order: <em>K1, V1, K2, V2, ..., Kn, Vn</em>.</p><p>E.g. to encode the map <em>#{a =&gt; "Apple", b =&gt; "Banana"}</em>:</p>
<pre>
ei_x_encode_map_header(&x, 2);
ei_x_encode_atom(&x, "a");
ei_x_encode_string(&x, "Apple");
ei_x_encode_atom(&x, "b");
ei_x_encode_string(&x, "Banana");

</pre>
<p>A correctly encoded map can not have duplicate keys.</p><p><strong></strong> int ei_get_type(const char *buf, const int *index, int *type, int *size)</p><p>This function returns the type in <em>type</em> and size in <em>size</em> of the encoded term. For strings and atoms, size is the number of characters <em>not</em> including the terminating 0. For binaries, <em>size</em> is the number of bytes. For lists and tuples, <em>size</em> is the arity of the object. For other types, <em>size</em> is 0. In all cases, <em>index</em> is left unchanged.</p><p><strong></strong> int ei_decode_version(const char *buf, int *index, int *version)</p><p>This function decodes the version magic number for the erlang binary term format. It must be the first token in a binary term.</p><p><strong></strong> int ei_decode_long(const char *buf, int *index, long *p)</p><p>This function decodes a long integer from the binary format. Note that if the code is 64 bits the function ei_decode_long() is exactly the same as ei_decode_longlong().</p><p><strong></strong> int ei_decode_ulong(const char *buf, int *index, unsigned long *p)</p><p>This function decodes an unsigned long integer from the binary format. Note that if the code is 64 bits the function ei_decode_ulong() is exactly the same as ei_decode_ulonglong().</p><p><strong></strong> int ei_decode_longlong(const char *buf, int *index, long long *p)</p><p>This function decodes a GCC <em>long long</em> or Visual C++ <em>__int64</em> (64 bit) integer from the binary format. Note that this function is missing in the VxWorks port.</p><p><strong></strong> int ei_decode_ulonglong(const char *buf, int *index, unsigned long long *p)</p><p>This function decodes a GCC <em>unsigned long long</em> or Visual C++ <em>unsigned __int64</em> (64 bit) integer from the binary format. Note that this function is missing in the VxWorks port.</p><p><strong></strong> int ei_decode_bignum(const char *buf, int *index, mpz_t obj)</p><p>This function decodes an integer in the binary format to a GMP <em>mpz_t</em> integer. To use this function the ei library needs to be configured and compiled to use the GMP library.</p><p><strong></strong> int ei_decode_double(const char *buf, int *index, double *p)</p><p>This function decodes an double-precision (64 bit) floating point number from the binary format.</p><p><strong></strong> int ei_decode_boolean(const char *buf, int *index, int *p)</p><p>This function decodes a boolean value from the binary format. A boolean is actually an atom, <em>true</em> decodes 1 and <em>false</em> decodes 0.</p><p><strong></strong> int ei_decode_char(const char *buf, int *index, char *p)</p><p>This function decodes a char (8-bit) integer between 0-255 from the binary format. Note that for historical reasons the returned integer is of type <em>char</em>. Your C code should consider the returned value to be of type <em>unsigned char</em> even if the C compilers and system may define <em>char</em> to be signed.</p><p><strong></strong> int ei_decode_string(const char *buf, int *index, char *p)</p><p>This function decodes a string from the binary format. A string in erlang is a list of integers between 0 and 255. Note that since the string is just a list, sometimes lists are encoded as strings by <em>term_to_binary/1</em>, even if it was not intended.</p><p>The string is copied to <em>p</em>, and enough space must be allocated. The returned string is null terminated so you need to add an extra byte to the memory requirement.</p><p><strong></strong> int ei_decode_atom(const char *buf, int *index, char *p)</p><p>This function decodes an atom from the binary format. The null terminated name of the atom is placed at <em>p</em>. There can be at most <em>MAXATOMLEN</em> bytes placed in the buffer.</p><p><strong></strong> int ei_decode_atom_as(const char *buf, int *index, char *p, int plen, erlang_char_encoding want, erlang_char_encoding* was, erlang_char_encoding* result)</p><p>This function decodes an atom from the binary format. The null terminated name of the atom is placed in buffer at <em>p</em> of length <em>plen</em> bytes.</p><p>The wanted string encoding is specified by <em></em><strong> want</strong>. The original encoding used in the binary format (latin1 or utf8) can be obtained from <em>*was</em>. The actual encoding of the resulting string (7-bit ascii, latin1 or utf8) can be obtained from <em>*result</em>. Both <em>was</em> and <em>result</em> can be <em>NULL</em>. <em>*result</em> may differ from <em>want</em> if <em>want</em> is a bitwise-or'd combination like <em>ERLANG_LATIN1|ERLANG_UTF8</em> or if <em>*result</em> turn out to be pure 7-bit ascii (compatible with both latin1 and utf8).</p><p>This function fails if the atom is too long for the buffer or if it can not be represented with encoding <em>want</em>.</p><p>This function was introduced in R16 release of Erlang/OTP as part of a first step to support UTF8 atoms.</p><p><strong></strong> int ei_decode_binary(const char *buf, int *index, void *p, long *len)</p><p>This function decodes a binary from the binary format. The <em>len</em> parameter is set to the actual size of the binary. Note that <em>ei_decode_binary()</em> assumes that there are enough room for the binary. The size required can be fetched by <em>ei_get_type()</em>.</p><p><strong></strong> int ei_decode_fun(const char *buf, int *index, erlang_fun *p)</p><p><strong></strong> void free_fun(erlang_fun* f)</p><p>This function decodes a fun from the binary format. The <em>p</em> parameter should be NULL or point to an <em>erlang_fun</em> structure. This is the only decode function that allocates memory; when the <em>erlang_fun</em> is no longer needed, it should be freed with <em>free_fun</em>. (This has to do with the arbitrary size of the environment for a fun.)</p><p><strong></strong> int ei_decode_pid(const char *buf, int *index, erlang_pid *p)</p><p>Decodes a pid, process identifier, from the binary format.</p><p><strong></strong> int ei_decode_port(const char *buf, int *index, erlang_port *p)</p><p>This function decodes a port identifier from the binary format.</p><p><strong></strong> int ei_decode_ref(const char *buf, int *index, erlang_ref *p)</p><p>This function decodes a reference from the binary format.</p><p><strong></strong> int ei_decode_trace(const char *buf, int *index, erlang_trace *p)</p><p>Decodes an erlang trace token from the binary format.</p><p><strong></strong> int ei_decode_tuple_header(const char *buf, int *index, int *arity)</p><p>This function decodes a tuple header, the number of elements is returned in <em>arity</em>. The tuple elements follows in order in the buffer.</p><p><strong></strong> int ei_decode_list_header(const char *buf, int *index, int *arity)</p><p>This function decodes a list header from the binary format. The number of elements is returned in <em>arity</em>. The <em>arity+1</em> elements follows (the last one is the tail of the list, normally an empty list.) If <em>arity</em> is <em>0</em>, it's an empty list.</p><p>Note that lists are encoded as strings, if they consist entirely of integers in the range 0..255. This function will not decode such strings, use <em>ei_decode_string()</em> instead.</p><p><strong></strong> int ei_decode_map_header(const char *buf, int *index, int *arity)</p><p>This function decodes a map header from the binary format. The number of key-value pairs is returned in <em>*arity</em>. Keys and values follow in the following order: <em>K1, V1, K2, V2, ..., Kn, Vn</em>. This makes a total of <em>arity*2</em> terms. If <em>arity</em> is zero, it's an empty map. A correctly encoded map does not have duplicate keys.</p><p><strong></strong> int ei_decode_ei_term(const char* buf, int* index, ei_term* term)</p><p>This function decodes any term, or at least tries to. If the term pointed at by <em>*index</em> in <em>buf</em> fits in the <em>term</em> union, it is decoded, and the appropriate field in <em>term-&gt;value</em> is set, and <em>*index</em> is incremented by the term size.</p><p>The function returns 1 on successful decoding, -1 on error, and 0 if the term seems alright, but does not fit in the <em>term</em> structure. If it returns 1, the <em>index</em> will be incremented, and the <em>term</em> contains the decoded term.</p><p>The <em>term</em> structure will contain the arity for a tuple or list, size for a binary, string or atom. It will contains a term if it's any of the following: integer, float, atom, pid, port or ref.</p><p><strong></strong> int ei_decode_term(const char *buf, int *index, void *t)</p><p>This function decodes a term from the binary format. The term is return in <em>t</em> as a <em>ETERM*</em>, so <em>t</em> is actually an <em>ETERM**</em> (see <em>erl_interface(3erl)</em>. The term should later be deallocated.</p><p>Note that this function is located in the erl_interface library.</p><p><strong></strong> int ei_print_term(FILE* fp, const char* buf, int* index)</p><p><strong></strong> int ei_s_print_term(char** s, const char* buf, int* index)</p><p>This function prints a term, in clear text, to the file given by <em>fp</em>, or the buffer pointed to by <em>s</em>. It tries to resemble the term printing in the erlang shell.</p><p>In <em>ei_s_print_term()</em>, the parameter <em>s</em> should point to a dynamically (malloc) allocated string of <em>BUFSIZ</em> bytes or a NULL pointer. The string may be reallocated (and <em>*s</em> may be updated) by this function if the result is more than <em>BUFSIZ</em> characters. The string returned is zero-terminated.</p><p>The return value is the number of characters written to the file or string, or -1 if <em>buf[index]</em> doesn't contain a valid term. Unfortunately, I/O errors on <em>fp</em> is not checked.</p><p>The argument <em>index</em> is updated, i.e. this function can be viewed as en decode function that decodes a term into a human readable format.</p><p><strong></strong> int ei_x_format(ei_x_buff* x, const char* fmt, ...)</p><p><strong></strong> int ei_x_format_wo_ver(ei_x_buff* x, const char *fmt, ... )</p><p>Format a term, given as a string, to a buffer. This functions works like a sprintf for erlang terms. The <em>fmt</em> contains a format string, with arguments like <em>~d</em>, to insert terms from variables. The following formats are supported (with the C types given):</p>
<pre>
~a - an atom, char*
~c - a character, char
~s - a string, char*
~i - an integer, int
~l - a long integer, long int
~u - a unsigned long integer, unsigned long int
~f - a float, float
~d - a double float, double float
~p - an Erlang PID, erlang_pid*

</pre>
<p>For instance, to encode a tuple with some stuff:</p>
<pre>
ei_x_format("{~a,~i,~d}", "numbers", 12, 3.14159)
encodes the tuple {numbers,12,3.14159}

</pre>
<p>The <em>ei_x_format_wo_ver()</em> formats into a buffer, without the initial version byte.</p><p><strong></strong> int ei_x_new(ei_x_buff* x)</p><p><strong></strong> int ei_x_new_with_version(ei_x_buff* x)</p><p>This function allocates a new <em>ei_x_buff</em> buffer. The fields of the structure pointed to by <em>x</em> parameter is filled in, and a default buffer is allocated. The <em>ei_x_new_with_version()</em> also puts an initial version byte, that is used in the binary format. (So that <em>ei_x_encode_version()</em> won't be needed.)</p><p><strong></strong> int ei_x_free(ei_x_buff* x)</p><p>This function frees an <em>ei_x_buff</em> buffer. The memory used by the buffer is returned to the OS.</p><p><strong></strong> int ei_x_append(ei_x_buff* x, const ei_x_buff* x2)</p><p><strong></strong> int ei_x_append_buf(ei_x_buff* x, const char* buf, int len)</p><p>These functions appends data at the end of the buffer <em>x</em>.</p><p><strong></strong> int ei_skip_term(const char* buf, int* index)</p><p>This function skips a term in the given buffer, it recursively skips elements of lists and tuples, so that a full term is skipped. This is a way to get the size of an erlang term.</p><p><em>buf</em> is the buffer.</p><p><em>index</em> is updated to point right after the term in the buffer.</p><p><strong></strong> Note:</p><p>This can be useful when you want to hold arbitrary terms: just skip them and copy the binary term data to some buffer.</p><p>The function returns <em>0</em> on success and <em>-1</em> on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUG INFORMATION</h2>
        <div class="sectioncontent">
<p>Some tips on what to check when the emulator doesn't seem to receive the terms that you send.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>be careful with the version header, use <em>ei_x_new_with_version()</em> when appropriate</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>turn on distribution tracing on the erlang node</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>check the result codes from ei_decode_-calls</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO ei&hellip;</h2>
        <div class="sectioncontent">
<p>erl_interface(3erl)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="egd.3erl.html"><span aria-hidden="true">&larr;</span> egd.3erl: Egd - erlang graphical drawer.</a></li>
   <li class="next"><a href="ei_connect.3erl.html">ei_connect.3erl: Communicate with distributed erlang <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>avr_lock: Introduction   the lockbit api allows a user to specify the lockbit settings for the specific avr device they are compiling for. these lockbit settings will be placed in a special section in the elf output file, after linking.  programming tools can take advantage of the lockbit information embedded in the elf file, by extracting this information and determining if the lockbits need to be programmed after programming the flash and eeprom memories. this also allows a single elf file to contain all the information needed to program an avr.  to use the lockbit api, include the avr/io.h header file, which in turn automatically includes the individual i/o header file and the avr/lock.h file. these other two files provides everything necessary to set the avr lockbits.  lockbit api   each i/o header file may define up to 3 macros that controls what kinds of lockbits are available to the user.  if __lock_bits_exist is defined, then two lock bits are available to the user and 3 mode settings are defined for these two bits.  if __boot_lock_bits_0_exist is defined, then the two blb0 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_bits_1_exist is defined, then the two blb1 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_application_table_bits_exist is defined then two lock bits are available to set the locking mode for the application table section (which is used in the xmega family).  if __boot_lock_application_bits_exist is defined then two lock bits are available to set the locking mode for the application section (which is used in the xmega family).  if __boot_lock_boot_bits_exist is defined then two lock bits are available to set the locking mode for the boot loader section (which is used in the xmega family).  the avr lockbit modes have inverted values, logical 1 for an unprogrammed (disabled) bit and logical 0 for a programmed (enabled) bit. the defined macros for each individual lock bit represent this in their definition by a bit-wise inversion of a mask. for example, the lb_mode_3 macro is defined as:</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Introduction   the lockbit api allows a user to specify the lockbit settings for the specific avr device they are compiling for. these lockbit settings will be placed in a special section in the elf output file, after linking.  programming tools can take advantage of the lockbit information embedded in the elf file, by extracting this information and determining if the lockbits need to be programmed after programming the flash and eeprom memories. this also allows a single elf file to contain all the information needed to program an avr.  to use the lockbit api, include the avr/io.h header file, which in turn automatically includes the individual i/o header file and the avr/lock.h file. these other two files provides everything necessary to set the avr lockbits.  lockbit api   each i/o header file may define up to 3 macros that controls what kinds of lockbits are available to the user.  if __lock_bits_exist is defined, then two lock bits are available to the user and 3 mode settings are defined for these two bits.  if __boot_lock_bits_0_exist is defined, then the two blb0 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_bits_1_exist is defined, then the two blb1 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_application_table_bits_exist is defined then two lock bits are available to set the locking mode for the application table section (which is used in the xmega family).  if __boot_lock_application_bits_exist is defined then two lock bits are available to set the locking mode for the application section (which is used in the xmega family).  if __boot_lock_boot_bits_exist is defined then two lock bits are available to set the locking mode for the boot loader section (which is used in the xmega family).  the avr lockbit modes have inverted values, logical 1 for an unprogrammed (disabled) bit and logical 0 for a programmed (enabled) bit. the defined macros for each individual lock bit represent this in their definition by a bit-wise inversion of a mask. for example, the lb_mode_3 macro is defined as:">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="avr_lock (3avr) manual">
  <meta name="twitter:description" content="Introduction   the lockbit api allows a user to specify the lockbit settings for the specific avr device they are compiling for. these lockbit settings will be placed in a special section in the elf output file, after linking.  programming tools can take advantage of the lockbit information embedded in the elf file, by extracting this information and determining if the lockbits need to be programmed after programming the flash and eeprom memories. this also allows a single elf file to contain all the information needed to program an avr.  to use the lockbit api, include the avr/io.h header file, which in turn automatically includes the individual i/o header file and the avr/lock.h file. these other two files provides everything necessary to set the avr lockbits.  lockbit api   each i/o header file may define up to 3 macros that controls what kinds of lockbits are available to the user.  if __lock_bits_exist is defined, then two lock bits are available to the user and 3 mode settings are defined for these two bits.  if __boot_lock_bits_0_exist is defined, then the two blb0 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_bits_1_exist is defined, then the two blb1 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_application_table_bits_exist is defined then two lock bits are available to set the locking mode for the application table section (which is used in the xmega family).  if __boot_lock_application_bits_exist is defined then two lock bits are available to set the locking mode for the application section (which is used in the xmega family).  if __boot_lock_boot_bits_exist is defined then two lock bits are available to set the locking mode for the boot loader section (which is used in the xmega family).  the avr lockbit modes have inverted values, logical 1 for an unprogrammed (disabled) bit and logical 0 for a programmed (enabled) bit. the defined macros for each individual lock bit represent this in their definition by a bit-wise inversion of a mask. for example, the lb_mode_3 macro is defined as:">
  <meta name="twitter:image" content="https://www.carta.tech/images/avr-libc-avr_lock-3avr.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3avr/avr_lock.3avr.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="avr_lock (3avr) manual" />
  <meta property="og:description" content="Introduction   the lockbit api allows a user to specify the lockbit settings for the specific avr device they are compiling for. these lockbit settings will be placed in a special section in the elf output file, after linking.  programming tools can take advantage of the lockbit information embedded in the elf file, by extracting this information and determining if the lockbits need to be programmed after programming the flash and eeprom memories. this also allows a single elf file to contain all the information needed to program an avr.  to use the lockbit api, include the avr/io.h header file, which in turn automatically includes the individual i/o header file and the avr/lock.h file. these other two files provides everything necessary to set the avr lockbits.  lockbit api   each i/o header file may define up to 3 macros that controls what kinds of lockbits are available to the user.  if __lock_bits_exist is defined, then two lock bits are available to the user and 3 mode settings are defined for these two bits.  if __boot_lock_bits_0_exist is defined, then the two blb0 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_bits_1_exist is defined, then the two blb1 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_application_table_bits_exist is defined then two lock bits are available to set the locking mode for the application table section (which is used in the xmega family).  if __boot_lock_application_bits_exist is defined then two lock bits are available to set the locking mode for the application section (which is used in the xmega family).  if __boot_lock_boot_bits_exist is defined then two lock bits are available to set the locking mode for the boot loader section (which is used in the xmega family).  the avr lockbit modes have inverted values, logical 1 for an unprogrammed (disabled) bit and logical 0 for a programmed (enabled) bit. the defined macros for each individual lock bit represent this in their definition by a bit-wise inversion of a mask. for example, the lb_mode_3 macro is defined as:" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/avr-libc-avr_lock-3avr.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">avr_lock<small> (3avr)</small></h1>
        <p class="lead">Introduction   the lockbit api allows a user to specify the lockbit settings for the specific avr device they are compiling for. these lockbit settings will be placed in a special section in the elf output file, after linking.  programming tools can take advantage of the lockbit information embedded in the elf file, by extracting this information and determining if the lockbits need to be programmed after programming the flash and eeprom memories. this also allows a single elf file to contain all the information needed to program an avr.  to use the lockbit api, include the avr/io.h header file, which in turn automatically includes the individual i/o header file and the avr/lock.h file. these other two files provides everything necessary to set the avr lockbits.  lockbit api   each i/o header file may define up to 3 macros that controls what kinds of lockbits are available to the user.  if __lock_bits_exist is defined, then two lock bits are available to the user and 3 mode settings are defined for these two bits.  if __boot_lock_bits_0_exist is defined, then the two blb0 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_bits_1_exist is defined, then the two blb1 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_application_table_bits_exist is defined then two lock bits are available to set the locking mode for the application table section (which is used in the xmega family).  if __boot_lock_application_bits_exist is defined then two lock bits are available to set the locking mode for the application section (which is used in the xmega family).  if __boot_lock_boot_bits_exist is defined then two lock bits are available to set the locking mode for the boot loader section (which is used in the xmega family).  the avr lockbit modes have inverted values, logical 1 for an unprogrammed (disabled) bit and logical 0 for a programmed (enabled) bit. the defined macros for each individual lock bit represent this in their definition by a bit-wise inversion of a mask. for example, the lb_mode_3 macro is defined as:</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/avr_lock.3avr.html">
      <span itemprop="name">avr_lock: Introduction   the lockbit api allows a user to specify the lockbit settings for the specific avr device they are compiling for. these lockbit settings will be placed in a special section in the elf output file, after linking.  programming tools can take advantage of the lockbit information embedded in the elf file, by extracting this information and determining if the lockbits need to be programmed after programming the flash and eeprom memories. this also allows a single elf file to contain all the information needed to program an avr.  to use the lockbit api, include the avr/io.h header file, which in turn automatically includes the individual i/o header file and the avr/lock.h file. these other two files provides everything necessary to set the avr lockbits.  lockbit api   each i/o header file may define up to 3 macros that controls what kinds of lockbits are available to the user.  if __lock_bits_exist is defined, then two lock bits are available to the user and 3 mode settings are defined for these two bits.  if __boot_lock_bits_0_exist is defined, then the two blb0 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_bits_1_exist is defined, then the two blb1 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_application_table_bits_exist is defined then two lock bits are available to set the locking mode for the application table section (which is used in the xmega family).  if __boot_lock_application_bits_exist is defined then two lock bits are available to set the locking mode for the application section (which is used in the xmega family).  if __boot_lock_boot_bits_exist is defined then two lock bits are available to set the locking mode for the boot loader section (which is used in the xmega family).  the avr lockbit modes have inverted values, logical 1 for an unprogrammed (disabled) bit and logical 0 for a programmed (enabled) bit. the defined macros for each individual lock bit represent this in their definition by a bit-wise inversion of a mask. for example, the lb_mode_3 macro is defined as:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/avr-libc/">
      <span itemprop="name">avr-libc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/avr_lock.3avr.html">
      <span itemprop="name">avr_lock: Introduction   the lockbit api allows a user to specify the lockbit settings for the specific avr device they are compiling for. these lockbit settings will be placed in a special section in the elf output file, after linking.  programming tools can take advantage of the lockbit information embedded in the elf file, by extracting this information and determining if the lockbits need to be programmed after programming the flash and eeprom memories. this also allows a single elf file to contain all the information needed to program an avr.  to use the lockbit api, include the avr/io.h header file, which in turn automatically includes the individual i/o header file and the avr/lock.h file. these other two files provides everything necessary to set the avr lockbits.  lockbit api   each i/o header file may define up to 3 macros that controls what kinds of lockbits are available to the user.  if __lock_bits_exist is defined, then two lock bits are available to the user and 3 mode settings are defined for these two bits.  if __boot_lock_bits_0_exist is defined, then the two blb0 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_bits_1_exist is defined, then the two blb1 lock bits are available to the user and 4 mode settings are defined for these two bits.  if __boot_lock_application_table_bits_exist is defined then two lock bits are available to set the locking mode for the application table section (which is used in the xmega family).  if __boot_lock_application_bits_exist is defined then two lock bits are available to set the locking mode for the application section (which is used in the xmega family).  if __boot_lock_boot_bits_exist is defined then two lock bits are available to set the locking mode for the boot loader section (which is used in the xmega family).  the avr lockbit modes have inverted values, logical 1 for an unprogrammed (disabled) bit and logical 0 for a programmed (enabled) bit. the defined macros for each individual lock bit represent this in their definition by a bit-wise inversion of a mask. for example, the lb_mode_3 macro is defined as:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for avr-libc from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="avr_io.3avr.html"><span aria-hidden="true">&larr;</span> avr_io.3avr: Avr/io.h: avr device-specific io definitions -</a></li>
   <li class="next"><a href="avr_math.3avr.html">avr_math.3avr: Math.h: mathematics - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

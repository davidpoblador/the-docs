<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>csv: Csv parser and writer library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Csv parser and writer library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="csv (3) manual">
  <meta name="twitter:description" content="Csv parser and writer library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcsv-dev-csv-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/csv.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="csv (3) manual" />
  <meta property="og:description" content="Csv parser and writer library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcsv-dev-csv-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">csv<small> (3)</small></h1>
        <p class="lead">Csv parser and writer library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/csv.3.html">
      <span itemprop="name">csv: Csv parser and writer library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcsv-dev/">
      <span itemprop="name">libcsv-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/csv.3.html">
      <span itemprop="name">csv: Csv parser and writer library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;libcsv/csv.h&gt;

</pre>
<p>int csv_init(struct csv_parser *<em>p</em><strong>, unsigned char </strong><em>options</em><strong>);</strong></p>
<pre>

</pre>
<p>size_t csv_parse(struct csv_parser *<em>p</em><strong>,</strong> const void *<em>s</em><strong>,</strong> size_t <em>len</em><strong>,</strong> void (*<em>cb1</em><strong>)(void *, size_t, void *),</strong> void (*<em>cb2</em><strong>)(int, void *),</strong> void *<em>data</em><strong>);</strong></p>
<pre>

</pre>
<p>int csv_fini(struct csv_parser *<em>p</em><strong>,</strong> void (*<em>cb1</em><strong>)(void *, size_t, void *),</strong> void (*<em>cb2</em><strong>)(int, void *),</strong> void *<em>data</em><strong>);</strong></p>
<pre>
void csv_free(struct csv_parser *<em>p</em><strong>);</strong>

unsigned char csv_get_delim(struct csv_parser *<em>p</em><strong>);</strong>
unsigned char csv_get_quote(struct csv_parser *<em>p</em><strong>);</strong>
void csv_set_space_func(struct csv_parser *<em>p</em><strong>, int (*</strong><em>f</em><strong>)(unsigned char));</strong>
void csv_set_term_func(struct csv_parser *<em>p</em><strong>, int (*</strong><em>f</em><strong>)(unsigned char));</strong>

int csv_get_opts(struct csv_parser *<em>p</em><strong>);</strong>
int csv_set_opts(struct csv_parser *<em>p</em><strong>, unsigned char </strong><em>options</em><strong>);</strong>
int csv_error(struct csv_parser *<em>p</em><strong>);</strong>
char * csv_strerror(int <em>error</em><strong>);</strong>

size_t csv_write(void *<em>dest</em><strong>, size_t </strong><em>dest_size</em><strong>, const void *</strong><em>src</em><strong>,</strong>
size_t <em>src_size</em><strong>);</strong>
int csv_fwrite(FILE *<em>fp</em><strong>, const void *</strong><em>src</em><strong>, size_t </strong><em>src_size</em><strong>);</strong>

size_t csv_write2(void *<em>dest</em><strong>, size_t </strong><em>dest_size</em><strong>, const void *</strong><em>src</em><strong>,</strong>
size_t <em>src_size</em><strong>, unsigned char </strong><em>quote</em><strong>);</strong>
int csv_fwrite2(FILE *<em>fp</em><strong>, const void *</strong><em>src</em><strong>, size_t </strong><em>src_size</em><strong>, unsigned char </strong><em>quote</em><strong>);</strong>

void csv_set_realloc_func(struct csv_parser *<em>p</em><strong>, void *(*</strong><em>func</em><strong>)(void *, size_t));</strong>
void csv_set_free_func(struct csv_parser *<em>p</em><strong>, void (*</strong><em>func</em><strong>)(void *));</strong>
void csv_set_blk_size(struct csv_parser *<em>p</em><strong>, size_t </strong><em>size</em><strong>);</strong>
size_t csv_get_blk_size(struct csv_parser *<em>p</em><strong>);</strong>
size_t csv_get_buffer_size(struct csv_parser *<em>p</em><strong>);</strong>

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The CSV library provides a flexible, intuitive interface for parsing and writing csv data.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>The idea behind parsing with <strong>libcsv</strong> is straight-forward: you initialize a parser object with <strong>csv_init()</strong> and feed data to the parser over one or more calls to <strong>csv_parse()</strong> providing callback functions that handle end-of-field and end-of-row events.  <strong>csv_parse()</strong> parses the data provided calling the user-defined callback functions as it reads fields and rows. When complete, <strong>csv_fini()</strong> is called to finish processing the current field and make a final call to the callback functions if necessary. <strong>csv_free()</strong> is then called to free the parser object. <strong>csv_error()</strong> and <strong>csv_strerror()</strong> provide information about errors encountered by the functions. <strong>csv_write()</strong> and <strong>csv_fwrite()</strong> provide a simple interface for converting raw data into CSV data and storing the result into a buffer or file respectively.</p><p>CSV is a binary format allowing the storage of arbitrary binary data, files opened for reading or writing CSV data should be opened in binary mode.</p><p><strong>libcsv</strong> provides a default mode in which the parser will happily process any data as CSV without complaint, this is useful for parsing files which don't adhere to all the traditional rules. A strict mode is also supported which will cause any violation of the imposed rules to cause a parsing failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ROUTINES</h2>
        <div class="sectioncontent">
<p>PARSING DATA</p><p><strong>csv_init()</strong> initializes a pointer to a <strong>csv_parser</strong> structure. This structure contains housekeeping information such as the current state of the parser, the buffer, current size and position, etc. The <strong>csv_init()</strong> function returns 0 on success and a non-zero value upon failure.  <strong>csv_init()</strong> will fail if the pointer passed to it is a null pointer.  The <em>options</em> argument specifies the parser options, these may be changed later with the <strong>csv_set_opts()</strong> function.</p><p><em>OPTIONS</em></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CSV_STRICT</strong></p>
  </dt>
  <dd>
    <p>Enables strict mode.</p>
  </dd>
  <dt>
    <p><strong>CSV_REPALL_NL</strong></p>
  </dt>
  <dd>
    <p>Causes each instance of a carriage return or linefeed outside of a record to be reported.</p>
  </dd>
  <dt>
    <p><strong>CSV_STRICT_FINI</strong></p>
  </dt>
  <dd>
    <p>Causes unterminated quoted fields encountered in <strong>csv_fini()</strong> to cause a parsing error (see below).</p>
  </dd>
  <dt>
    <p><strong>CSV_APPEND_NULL</strong></p>
  </dt>
  <dd>
    <p>Will cause all fields to be nul-terminated when provided to <em>cb1</em>, introduced in 3.0.0.</p>
  </dd>
  <dt>
    <p><strong>CSV_EMPTY_IS_NULL</strong></p>
  </dt>
  <dd>
    <p>Will cause NULL to be passed as the first argument to <em>cb1</em> for empty, unquoted, fields.  Empty means consisting only of either spaces and tabs or the values defined by the a custom function registered via <strong>csv_set_space_func()</strong>.  Added in 3.0.3.</p>
  </dd>

</dl>
<p>Multiple options can be specified by OR-ing them together.</p><p><strong>csv_parse()</strong> is the function that does the actual parsing, it takes 6 arguments:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>p</em> is a pointer to an initialized <strong>struct csv_parser</strong>.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>s</em> is a pointer to the data to read in, such as a dynamically allocated region of memory containing data read in from a call to <strong>fread()</strong>.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>len</em> is the number of bytes of data to process.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>cb1</em> is a pointer to the callback function that will be called from <strong>csv_parse()</strong> after an entire field has been read. <em>cb1</em> will be called with a pointer to the parsed data (which is NOT nul-terminated unless the CSV_APPEND_NULL option is set), the number of bytes in the data, and the pointer that was passed to <strong>csv_parse()</strong>.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>cb2</em> is a pointer to the callback function that will be called when the end of a record is encountered, it will be called with the character that caused the record to end, cast to an unsigned char, or -1 if called from csv_fini, and the pointer that was passed to <strong>csv_init()</strong>.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>data</em> is a pointer to user-defined data that will be passed to the callback functions when invoked.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>cb1</em> and/or <em>cb2</em> may be <strong>NULL</strong> in which case no function will be called for the associated actions.  <em>data</em> may also be <strong>NULL</strong> but the callback functions must be prepared to handle receiving a null pointer.</p>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>By default <em>cb2</em> is not called when rows that do not contain any fields are encountered.  This behavior is meant to accommodate files using only either a linefeed or a carriage return as a record separator to be parsed properly while at the same time being able to parse files with rows terminated by multiple characters from resulting in blank rows after each actual row of data (for example, processing a text CSV file created that was created on a Windows machine on a Unix machine). The <strong>CSV_REPALL_NL</strong> option will cause <strong>cb2</strong> to be called once for every carraige return or linefeed encountered outside of a field. <em>cb2</em> is called with the character that prompted the call to the function, , cast to an unsigned char, either <strong>CSV_CR</strong> for carriage return, <strong>CSV_LF</strong> for linefeed, or <strong>-1</strong> for record termination from a call to <strong>csv_fini()</strong> (see below). A carriage return or linefeed within a non-quoted field always marks both the end of the field and the row.  Other characters can be used as row terminators and thus be provided as an argument to <em>cb2</em> using <strong>csv_set_space_func()</strong>.</p><p><strong>Note:</strong> The first parameter of the <em>cb1</em> function is <strong>void *</strong>, not <strong>const void *</strong>; the pointer passed to the callback function is actually a pointer to the entry buffer inside the <strong>csv_parser struct</strong>, this data may safely be modified from the callback function (or any function that the callback function calls) but you must not attempt to access more than <em>len</em> bytes and you should not access the data after the callback function returns as the buffer is dynamically allocated and its location and size may change during calls to <strong>csv_parse()</strong>.</p><p><strong>Note:</strong> Different callback functions may safely be specified during each call to <strong>csv_parse()</strong> but keep in mind that the callback functions may be called many times during a single call to <strong>csv_parse()</strong> depending on the amount of data being processed in a given call.</p><p><strong>csv_parse()</strong> returns the number of bytes processed, on a successful call this will be <em>len</em>, if it is less than len an error has occurred. An error can occur, for example, if there is insufficient memory to store the contents of the current field in the entry buffer. An error can also occur if malformed data is encountered while running in strict mode.</p><p>The <strong>csv_error()</strong> function can be used to determine what the error is and the <strong>csv_strerror()</strong> function can be used to provide a textual description of the error. <strong>csv_error()</strong> takes a single argument, a pointer to a <strong>struct csv_parser</strong>, and returns one of the following values defined in <strong>csv.h</strong>:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CSV_EPARSE</strong>&nbsp;&nbsp;&nbsp;A parse error has occurred while in strict mode</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>CSV_ENOMEM</strong>&nbsp;&nbsp;&nbsp;There was not enough memory while attempting to increase the entry buffer for the current field</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>CSV_ETOOBIG</strong>&nbsp;&nbsp;Continuing to process the current field would require a buffer of more than SIZE_MAX bytes</p>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>The value passed to <strong>csv_strerror()</strong> should be one returned from <strong>csv_error()</strong>.  The return value of <strong>csv_strerror()</strong> is a pointer to a static string. The pointer may be used for the entire lifetime of the program and the contents will not change during execution but you must not attempt to modify the string it points to.</p><p>When you have finished submitting data to <strong>csv_parse()</strong>, you need to call the <strong>csv_fini()</strong> function.  This function will call the <em>cb1</em> function with any remaining data in the entry buffer (if there is any) and call the <em>cb2</em> function unless we are already at the end of a row (the last byte processed was a newline character for example). It is necessary to call this function because the file being processed might not end with a carriage return or newline but the data that has been read in to this point still needs to be submitted to the callback routines. If <em>cb2</em> is called from within <strong>csv_fini()</strong> it will be because the row was not terminated with a newline sequence, in this case <em>cb2</em> will be called with an argument of -1.</p><p><strong>Note:</strong> A call to <strong>csv_fini</strong> implicitly ends the field current field and row.  If the last field processed is a quoted field that ends before a closing quote is encountered, no error will be reported by default, even if CSV_STRICT is specified.  To cause <strong>csv_fini()</strong> to report an error in such a case, set the CSV_STRICT_FINI option (new in version 1.0.1) in addition to the CSV_STRICT option.</p><p><strong>csv_fini()</strong> also reinitializes the parser state so that it is ready to be used on the next file or set of data.  <strong>csv_fini()</strong> does not alter the current buffer size. If the last set of data that was being parsed contained a very large field that increased the size of the buffer, and you need to free that memory before continuing, you must call <strong>csv_free()</strong>, you do not need to call <strong>csv_init()</strong> again after <strong>csv_free()</strong>. Like csv_parse, the callback functions provided to <strong>csv_fini()</strong> may be NULL.  <strong>csv_fini()</strong> returns 0 on success and a non-zero value if you pass it a null pointer.</p><p>After calling <strong>csv_fini()</strong> you may continue to use the same struct csv_parser pointer without reinitializing it (in fact you must not call <strong>csv_init()</strong> with an initialized csv_parser object or the memory allocated for the original structure will be lost).</p><p>When you are finished using the csv_parser object you can free any dynamically allocated memory associated with it by calling <strong>csv_free()</strong>. You may call <strong>csv_free()</strong> at any time, it need not be preceded by a call to <strong>csv_fini()</strong>.  You must only call <strong>csv_free()</strong> on a csv_parser object that has been initialized with a successful call to <strong>csv_init()</strong>.</p><p>WRITING DATA</p><p><strong>libcsv</strong> provides two functions to transform raw data into CSV formatted data: the <strong>csv_write()</strong> function which writes the result to a provided buffer, and the <strong>csv_fwrite()</strong> function which writes the result to a file. The functionality of both functions is straight-forward, they write out a single field including the opening and closing quotes and escape each encountered quote with another quote.</p><p>The <strong>csv_write()</strong> function takes a pointer to a source buffer (<em>src</em>) and processes at most <em>src_size</em> characters from <em>src</em>. <strong>csv_write()</strong> will write at most <em>dest_size</em> characters to <em>dest</em> and returns the number of characters that would have been written if <em>dest</em> was large enough.  This can be used to determine if all the characters were written and, if not, how large <em>dest</em> needs to be to write out all of the data. <strong>csv_write()</strong> may be called with a null pointer for the <em>dest</em> argument in which case no data is written but the size required to write out the data will be returned.  The space needed to write out the data is the size of the data + number of quotes appearing in data (each one will be escaped) + 2 (the leading and terminating quotes). <em>csv_write()</em> and <em>csv_fwrite()</em> always surround the output data with quotes. If <em>src_size</em> is very large (SIZE_MAX/2 or greater) it is possible that the number of bytes needed to represent the data, after inserting escaping quotes, will be greater than SIZE_MAX.  In such a case, csv_write will return SIZE_MAX which should be interpreted as meaning the data is too large to write to a single field.  The <strong>csv_fwrite()</strong> function is not similiarly limited.</p><p><strong>csv_fwrite()</strong> takes a FILE pointer (which should have been opened in binary mode) and converts and writes the data pointed to by <em>src</em> of size <em>src_size</em>.  It returns <strong>0</strong> on success and <strong>EOF</strong> if there was an error writing to the file. <strong>csv_fwrite()</strong> doesn't provide the number of characters processed or written.  If this functionality is required, use the <strong>csv_write()</strong> function combined with <strong>fwrite()</strong>.</p><p><strong>csv_write2()</strong> and <strong>csv_fwrite2()</strong> work similiarly but take an additional argument, the quote character to use when composing the field.</p><p>CUSTOMIZING THE PARSER</p><p>The <strong>csv_set_delim()</strong> and <strong>csv_set_quote()</strong> functions provide a means to change the characters that the parser will consider the delimiter and quote characters respetively, cast to unsigned char.  <strong>csv_get_delim()</strong>  and <strong>csv_get_delim()</strong> return the current delimiter and quote characters respectively.  When <strong>csv_init()</strong> is called the delimiter is set to <strong>CSV_COMMA</strong> and the quote to <strong>CSV_QUOTE</strong>.  Note that the rest of the CSV conventions still apply when these functions are used to change the delimiter and/or quote characters, fields containing the new quote character or delimiter must be quoted and quote characters must be escaped with an immediately preceding instance of the same character. Additionally, the <strong>csv_set_space_func()</strong> and <strong>csv_set_term_func()</strong> allow a user-defined function to be provided which will be used determine what constitutes a space character and what constitutes a record terminator character.  The space characters determine which characters are removed from the beginning and end of non-quoted fields and the terminator characters govern when a record ends.  When <strong>csv_init()</strong> is called, the effect is as if these functions were each called with a NULL argument in which case no function is called and CSV_SPACE and CSV_TAB are used for space characters, and CSV_CR and CSV_LF are used for terminator characters.</p><p><strong>csv_set_realloc_func()</strong> can be used to set the function that is called when the internal buffer needs to be resized, only realloc, not malloc, is used internally; the default is to use the standard realloc function. Likewise, <strong>csv_set_free_func()</strong> is used to set the function called to free the internal buffer, the default is the standard free function.</p><p><strong>csv_get_blk_size()</strong> and <strong>csv_set_blk_size()</strong> can be used to get and set the block size of the parser respectively.  The block size if the amount of extra memory allocated every time the internal buffer needs to be increased, the default is 128.  <strong>csv_get_buffer_size()</strong> will return the current number of bytes allocated for the internal buffer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE CSV FORMAT</h2>
        <div class="sectioncontent">
<p>Although quite prevelant there is no standard for the CSV format.  There are however, a set of traditional conventions used by many applications.  <strong>libcsv</strong> follows the conventions described at http://www.creativyst.com/Doc/Articles/CSV/CSV01.htm which seem to reflect the most common usage of the format, namely:</p>
<dl class='dl-vertical'>
  <dt>
    <p>Fields are separated with commas.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>Rows are delimited by newline sequences (see below).</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>Fields may be surrounded with quotes.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>Fields that contain comma, quote, or newline characters MUST be quoted.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>Each instance of a quote character must be escaped with an immediately preceding quote character.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>Leading and trailing spaces and tabs are removed from non-quoted fields.</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>The final line need not contain a newline sequence.</p>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>In strict mode, any detectable violation of these rules results in an error.</p><p>RFC 4180 is an informational memo which attempts to document the CSV format, especially with regards to its use as a MIME type. There are a several parts of the description documented in this memo which either do not accurately reflect widely used conventions or artificially limit the usefulness of the format.  The differences between the RFC and <strong>libcsv</strong> are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>"Each line should contain the same number of fields throughout the file"</p>
  </dt>
  <dd>
    <p><strong>libcsv</strong> doesn't care if every record contains a different number of fields, such a restriction could easily be enforced by the application itself if desired.</p>
  </dd>
  <dt>
    <p>"Spaces are considered part of a field and should not be ignored"</p>
  </dt>
  <dd>
    <p>Leading and trailing spaces that are part of non-quoted fields are ignored as this is by far the most common behavior and expected by many applications.</p><p><strong>abc ,  def</strong></p><p>is considered equivalent to:</p><p><strong>"abc", "def"</strong></p>
  </dd>
  <dt>
    <p>"The last field in the record must not be followed by a comma"</p>
  </dt>
  <dd>
    <p>The meaning of this statement is not clear but if the last character of a record is a comma, <strong>libcsv</strong> will interpret that as a final empty field, i.e.:</p><p><strong>"abc", "def",</strong></p><p>will be interpreted as 3 fields, equivalent to:</p><p><strong>"abc", "def", ""</strong></p>
  </dd>

</dl>
<p>RFC 4180 limits the allowable characters in a CSV field, <strong>libcsv</strong> allows any character to be present in a field provided it adheres to the conventions mentioned above.  This makes it possible to store binary data in CSV format, an attribute that many application rely on.</p><p>RFC 4180 states that a Carriage Return plus Linefeed combination is used to delimit records, <strong>libcsv</strong> allows any combination of Carriage Returns and Linefeeds to signify the end of a record.  This is to increase portability among systems that use different combinations to denote a newline sequence.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARSING MALFORMED DATA</h2>
        <div class="sectioncontent">
<p><strong>libcsv</strong> should correctly parse any CSV data that conforms to the rules discussed above.  By default, however, <strong>libcsv</strong> will also attempt to parse malformed CSV data such as data containing unescaped quotes or quotes within non-quoted fields.  For example:</p>
<pre>
<strong>a"c, "d"f"</strong>

would be parsed equivalently to the correct form:

<strong>"a""c", "d""f"</strong>

</pre>
<p>This is often desirable as there are some applications that do not adhere to the specifications previously discussed.  However, there are instances where malformed CSV data is ambiguous, namely when a comma or newline is the next non-space character following a quote such as:</p>
<pre>
<strong>"Sally said "Hello", Wally said "Goodbye""</strong>

This could either be parsed as a single field containing the data:

<strong>Sally said "Hello", Wally said "Goodbye"</strong>

or as 2 separate fields:

</pre>
<p><strong>Sally said "Hello</strong> and <strong>Wally said "Goodbye""</strong></p><p>Since the data is malformed, there is no way to know if the quote before the comma is meant to be a literal quote or if it signifies the end of the field.  This is of course not an issue for properly formed data as all quotes must be escaped.  <strong>libcsv</strong> will parse this example as 2 separate fields.</p><p><strong>libcsv</strong> provides a strict mode that will return with a parse error if a quote is seen inside a non-quoted field or if a non-escaped quote is seen whose next non-space character isn't a comma or newline sequence.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARSER DETAILS</h2>
        <div class="sectioncontent">
<p>A field is considered quoted if the first non-space character for a new field is a quote.</p><p>If a quote is encountered in a quoted field and the next non-space character is a comma, the field ends at the closed quote and the field data is submitted when the comma is encountered.  If the next non-space character after a quote is a newline character, the row has ended and the field data is submitted and the end of row is signalled (via the appropriate callback function).  If two quotes are immediately adjacent, the first one is interpreted as escaping the second one and one quote is written to the field buffer.  If the next non-space character following a quote is anything else, the quote is interpreted as a non-escaped literal quote and it and what follows are written to the field buffer, this would cause a parse error in strict mode.</p>
<pre>
Example 1
<strong>"abc"""</strong>
Parses as: <strong>abc"</strong>
</pre>
<p>The first quote marks the field as quoted, the second quote escapes the following quote and the last quote ends the field.  This is valid in both strict and non-strict modes.</p>
<pre>
Example 2
<strong>"ab"c</strong>
Parses as: <strong>ab"c</strong>
</pre>
<p>The first qute marks the field as quoted, the second quote is taken as a literal quote since the next non-space character is not a comma, or newline and the quote is not escaped.  The last quote ends the field (assuming there is a newline character following). A parse error would result upon seeing the character c in strict mode.</p>
<pre>
Example 3
<strong>"abc" "</strong>
Parses as: <strong>abc"</strong>
</pre>
<p>In this case, since the next non-space character following the second quote is not a comma or newline character, a literal quote is written, the space character after is part of the field, and the last quote terminated the field.  This demonstrates the fact that a quote must immediately precede another quote to escape it.  This would be a strict-mode violation as all quotes are required to be escaped.</p><p>If the field is not quoted, any quote character is taken as part of the field data, any comma terminated the field, and any newline character terminated the field and the record.</p>
<pre>
Example 4
<strong>ab""c</strong>
Parses as: <strong>ab""c</strong>
</pre>
<p>Quotes are not considered special in non-quoted fields.  This would be a strict mode violation since quotes may not exist in non-quoted fields in strict mode.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>The following example prints the number of fields and rows in a file. This is a simplified version of the csvinfo program provided in the examples directory.  Error checking not related to <strong>libcsv</strong> has been removed for clarity, the csvinfo program also provides an option for enabling strict mode and handles multiple files.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include "libcsv/csv.h"

struct counts {
  long unsigned fields;
  long unsigned rows;
};

void cb1 (void *s, size_t len, void *data) {
  ((struct counts *)data)-&gt;fields++; }
void cb2 (int c, void *data) {
  ((struct counts *)data)-&gt;rows++; }

int main (int argc, char *argv[]) {
  FILE *fp;
  struct csv_parser p;
  char buf[1024];
  size_t bytes_read;
  struct counts c = {0, 0};

  if (csv_init(&p, 0) != 0) exit(EXIT_FAILURE);
  fp = fopen(argv[1], "rb");
  if (!fp) exit(EXIT_FAILURE);

  while ((bytes_read=fread(buf, 1, 1024, fp)) &gt; 0)
    if (csv_parse(&p, buf, bytes_read, cb1, cb2, &c) != bytes_read) {
      fprintf(stderr, "Error while parsing file: %s&#92;n",
      csv_strerror(csv_error(&p)) );
      exit(EXIT_FAILURE);
    }

  csv_fini(&p, cb1, cb2, &c);

  fclose(fp);
  printf("%lu fields, %lu rows&#92;n", c.fields, c.rows);

  csv_free(&p);
  exit(EXIT_SUCCESS);
}

</pre>
<p>See the examples directory for several complete example programs.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Written by Robert Gamble.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Please send questions, comments, bugs, etc. to:</p><p>rgamble@users.sourceforge.net</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="csteqr.f.3.html"><span aria-hidden="true">&larr;</span> csteqr.f.3: Csteqr.f -</a></li>
   <li class="next"><a href="csycon.3.html">csycon.3: Csycon.f - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

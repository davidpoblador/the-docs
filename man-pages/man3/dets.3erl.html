<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dets: A disk based term storage</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A disk based term storage">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dets (3erl) manual">
  <meta name="twitter:description" content="A disk based term storage">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-dets-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/dets.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dets (3erl) manual" />
  <meta property="og:description" content="A disk based term storage" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-dets-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dets<small> (3erl)</small></h1>
        <p class="lead">A disk based term storage</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/dets.3erl.html">
      <span itemprop="name">dets: A disk based term storage</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/dets.3erl.html">
      <span itemprop="name">dets: A disk based term storage</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The module <em>dets</em> provides a term storage on file. The stored terms, in this module called <em>objects</em>, are tuples such that one element is defined to be the key. A Dets <em>table</em> is a collection of objects with the key at the same position stored on a file.</p><p>Dets is used by the Mnesia application, and is provided as is for users who are interested in an efficient storage of Erlang terms on disk only. Many applications just need to store some terms in a file. Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If larger tables are needed, Mnesia's table fragmentation can be used.</p><p>There are three types of Dets tables: set, bag and duplicate_bag. A table of type <em>set</em> has at most one object with a given key. If an object with a key already present in the table is inserted, the existing object is overwritten by the new object. A table of type <em>bag</em> has zero or more different objects with a given key. A table of type <em>duplicate_bag</em> has zero or more possibly matching objects with a given key.</p><p>Dets tables must be opened before they can be updated or read, and when finished they must be properly closed. If a table has not been properly closed, Dets will automatically repair the table. This can take a substantial time if the table is large. A Dets table is closed when the process which opened the table terminates. If several Erlang processes (users) open the same Dets table, they will share the table. The table is properly closed when all users have either terminated or closed the table. Dets tables are not properly closed if the Erlang runtime system is terminated abnormally.</p><p><strong></strong> Note:</p><p>A ^C command abnormally terminates an Erlang runtime system in a Unix environment with a break-handler.</p><p>Since all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. For this reason, the Dets functions are much slower than the corresponding Ets functions, although Dets exports a similar interface.</p><p>Dets organizes data as a linear hash list and the hash list grows gracefully as more data is inserted into the table. Space management on the file is performed by what is called a buddy system. The current implementation keeps the entire buddy system in RAM, which implies that if the table gets heavily fragmented, quite some memory can be used up. The only way to defragment a table is to close it and then open it again with the <em>repair</em> option set to <em>force</em>.</p><p>It is worth noting that the ordered_set type present in Ets is not yet implemented by Dets, neither is the limited support for concurrent updates which makes a sequence of <em>first</em> and <em>next</em> calls safe to use on fixed Ets tables. Both these features will be implemented by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user implemented method for locking) has to be used to implement safe concurrency. Currently, no library of Erlang/OTP has support for ordered disk based term storage.</p><p>Two versions of the format used for storing objects on file are supported by Dets. The first version, 8, is the format always used for tables created by OTP R7 and earlier. The second version, 9, is the default version of tables created by OTP R8 (and later OTP releases). OTP R8 can create version 8 tables, and convert version 8 tables to version 9, and vice versa, upon request.</p><p>All Dets functions return <em>{error, Reason}</em> if an error occurs (<em>first/1</em> and <em>next/2</em> are exceptions, they exit the process with the error tuple). If given badly formed arguments, all functions exit the process with a <em>badarg</em> message.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>access()</strong> = read | read_write

</pre>

<pre>
<strong>auto_save()</strong> = infinity | integer() &gt;= 0

</pre>

<pre>
<strong>bindings_cont()</strong>

</pre>
<p>Opaque continuation used by <strong></strong><em>match/1</em> and <strong></strong><em>match/3</em>.</p>
<pre>
<strong>cont()</strong>

</pre>
<p>Opaque continuation used by <strong></strong><em>bchunk/2</em>.</p>
<pre>
<strong>keypos()</strong> = integer() &gt;= 1

</pre>

<pre>
<strong>match_spec()</strong> = <strong>ets:match_spec()</strong>

</pre>
<p>Match specifications, see the <strong>match specification</strong> documentation in the ERTS User's Guide and <strong>ms_transform(3erl).</strong></p>
<pre>
<strong>no_slots()</strong> = integer() &gt;= 0 | default

</pre>

<pre>
<strong>object()</strong> = tuple()

</pre>

<pre>
<strong>object_cont()</strong>

</pre>
<p>Opaque continuation used by <strong></strong><em>match_object/1</em> and <strong></strong><em>match_object/3</em>.</p>
<pre>
<strong>pattern()</strong> = atom() | tuple()

</pre>
<p>See <strong>ets:match/2</strong> for a description of patterns.</p>
<pre>
<strong>select_cont()</strong>

</pre>
<p>Opaque continuation used by <strong></strong><em>select/1</em> and <strong></strong><em>select/3</em>.</p>
<pre>
<strong>tab_name()</strong> = term()

</pre>

<pre>
<strong>type()</strong> = bag | duplicate_bag | set

</pre>

<pre>
<strong>version()</strong> = 8 | 9 | default

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
all() -&gt; [tab_name()]

</pre>
<p>Returns a list of the names of all open tables on this node.</p>
<pre>
<strong></strong>
bchunk(Name, Continuation) -&gt;
<strong></strong>
          {Continuation2, Data} |
<strong></strong>
          '$end_of_table' |
<strong></strong>
          {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Continuation = start | <strong>cont()</strong></p><p>Continuation2 = <strong>cont()</strong></p><p>Data = binary() | tuple()</p><p>Reason = term()</p><p>Returns a list of objects stored in a table. The exact representation of the returned objects is not public. The lists of data can be used for initializing a table by giving the value <em>bchunk</em> to the <em>format</em> option of the <strong></strong><em>init_table/3</em> function. The Mnesia application uses this function for copying open tables.</p><p>Unless the table is protected using <em>safe_fixtable/2</em>, calls to <em>bchunk/2</em> may not work as expected if concurrent updates are made to the table.</p><p>The first time <em>bchunk/2</em> is called, an initial continuation, the atom <em>start</em>, must be provided.</p><p>The <em>bchunk/2</em> function returns a tuple <em>{Continuation2, Data}</em>, where <em>Data</em> is a list of objects. <em>Continuation2</em> is another continuation which is to be passed on to a subsequent call to <em>bchunk/2</em>. With a series of calls to <em>bchunk/2</em> it is possible to extract all objects of the table.</p><p><em>bchunk/2</em> returns <em>'$end_of_table'</em> when all objects have been returned, or <em>{error, Reason}</em> if an error occurs.</p>
<pre>
<strong></strong>
close(Name) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Reason = term()</p><p>Closes a table. Only processes that have opened a table are allowed to close it.</p><p>All open tables must be closed before the system is stopped. If an attempt is made to open a table which has not been properly closed, Dets automatically tries to repair the table.</p>
<pre>
<strong></strong>
delete(Name, Key) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Key = Reason = term()</p><p>Deletes all objects with the key <em>Key</em> from the table <em>Name</em>.</p>
<pre>
<strong></strong>
delete_all_objects(Name) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Reason = term()</p><p>Deletes all objects from a table in almost constant time. However, if the table if fixed, <em>delete_all_objects(T)</em> is equivalent to <em>match_delete(T, '_')</em>.</p>
<pre>
<strong></strong>
delete_object(Name, Object) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Object = <strong>object()</strong></p><p>Reason = term()</p><p>Deletes all instances of a given object from a table. If a table is of type <em>bag</em> or <em>duplicate_bag</em>, the <em>delete/2</em> function cannot be used to delete only some of the objects with a given key. This function makes this possible.</p>
<pre>
<strong></strong>
first(Name) -&gt; Key | '$end_of_table'

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Key = term()</p><p>Returns the first key stored in the table <em>Name</em> according to the table's internal order, or <em>'$end_of_table'</em> if the table is empty.</p><p>Unless the table is protected using <em>safe_fixtable/2</em>, subsequent calls to <strong></strong><em>next/2</em> may not work as expected if concurrent updates are made to the table.</p><p>Should an error occur, the process is exited with an error tuple <em>{error, Reason}</em>. The reason for not returning the error tuple is that it cannot be distinguished from a key.</p><p>There are two reasons why <em>first/1</em> and <em>next/2</em> should not be used: they are not very efficient, and they prevent the use of the key <em>'$end_of_table'</em> since this atom is used to indicate the end of the table. If possible, the <em>match</em>, <em>match_object</em>, and <em>select</em> functions should be used for traversing tables.</p>
<pre>
<strong></strong>
foldl(Function, Acc0, Name) -&gt; Acc | {error, Reason}

</pre>

<pre>
<strong></strong>
foldr(Function, Acc0, Name) -&gt; Acc | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Function = fun((Object :: <strong>object()</strong>, AccIn) -&gt; AccOut)</p><p>Acc0 = Acc = AccIn = AccOut = Reason = term()</p><p>Calls <em>Function</em> on successive elements of the table <em>Name</em> together with an extra argument <em>AccIn</em>. The order in which the elements of the table are traversed is unspecified. <em>Function</em> must return a new accumulator which is passed to the next call. <em>Acc0</em> is returned if the table is empty.</p>
<pre>
<strong></strong>
from_ets(Name, EtsTab) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>EtsTab = <strong>ets:tab()</strong></p><p>Reason = term()</p><p>Deletes all objects of the table <em>Name</em> and then inserts all the objects of the Ets table <em>EtsTab</em>. The order in which the objects are inserted is not specified. Since <em>ets:safe_fixtable/2</em> is called the Ets table must be public or owned by the calling process.</p>
<pre>
<strong></strong>
info(Name) -&gt; InfoList | undefined

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>InfoList = [InfoTuple]</p><p>InfoTuple = {file_size, integer() &gt;= 0}</p>
<pre>
          | {filename, <strong>file:name()</strong>}
</pre>

<pre>
          | {keypos, <strong>keypos()</strong>}
</pre>

<pre>
          | {size, integer() &gt;= 0}
</pre>

<pre>
          | {type, <strong>type()</strong>}
</pre>
<p>Returns information about the table <em>Name</em> as a list of tuples:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{file_size, integer() &gt;= 0}</em>, the size of the file in bytes.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{filename, </em><strong>file:name()</strong>}, the name of the file where objects are stored.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{keypos, </em><strong>keypos()</strong>} , the position of the key.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{size, integer() &gt;= 0}</em>, the number of objects stored in the table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{type, </em><strong>type()</strong>}, the type of the table.</p>
  </dd>

</dl>

<pre>
<strong></strong>
info(Name, Item) -&gt; Value | undefined

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Item = access</p>
<pre>
     | auto_save
</pre>

<pre>
     | bchunk_format
</pre>

<pre>
     | hash
</pre>

<pre>
     | file_size
</pre>

<pre>
     | filename
</pre>

<pre>
     | keypos
</pre>

<pre>
     | memory
</pre>

<pre>
     | no_keys
</pre>

<pre>
     | no_objects
</pre>

<pre>
     | no_slots
</pre>

<pre>
     | owner
</pre>

<pre>
     | ram_file
</pre>

<pre>
     | safe_fixed
</pre>

<pre>
     | size
</pre>

<pre>
     | type
</pre>

<pre>
     | version
</pre>
<p>Value = term()</p><p>Returns the information associated with <em>Item</em> for the table <em>Name</em>. In addition to the <em>{Item, Value}</em> pairs defined for <em>info/1</em>, the following items are allowed:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{access, </em><strong>access()</strong>} , the access mode.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{auto_save, </em><strong> auto_save()</strong>}, the auto save interval.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{bchunk_format, binary()}</em>, an opaque binary describing the format of the objects returned by <em>bchunk/2</em>. The binary can be used as argument to <em>is_compatible_chunk_format/2</em>. Only available for version 9 tables.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{hash,</em> Hash<em>}</em>. Describes which BIF is used to calculate the hash values of the objects stored in the Dets table. Possible values of Hash are <em>hash</em>, which implies that the <em>erlang:hash/2</em> BIF is used, <em>phash</em>, which implies that the <em>erlang:phash/2</em> BIF is used, and <em>phash2</em>, which implies that the <em>erlang:phash2/1</em> BIF is used.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{memory, integer() &gt;= 0}</em>, the size of the file in bytes. The same value is associated with the item <em>file_size</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{no_keys, integer &gt;= 0()}</em>, the number of different keys stored in the table. Only available for version 9 tables.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{no_objects, integer &gt;= 0()}</em>, the number of objects stored in the table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{no_slots, {</em>Min<em>, </em>Used<em>, </em>Max<em>}}</em>, the number of slots of the table. <em>Min</em> is the minimum number of slots, <em>Used</em> is the number of currently used slots, and <em>Max</em> is the maximum number of slots. Only available for version 9 tables.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{owner, pid()}</em>, the pid of the process that handles requests to the Dets table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{ram_file, boolean()}</em>, whether the table is kept in RAM.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{safe_fixed,</em> SafeFixed<em>}</em>. If the table is fixed, SafeFixed is a tuple <em>{FixedAtTime, [{Pid,RefCount}]}</em>. <em>FixedAtTime</em> is the time when the table was first fixed, and <em>Pid</em> is the pid of the process that fixes the table <em>RefCount</em> times. There may be any number of processes in the list. If the table is not fixed, SafeFixed is the atom <em>false</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{version, integer()</em>, the version of the format of the table.</p>
  </dd>

</dl>

<pre>
<strong></strong>
init_table(Name, InitFun) -&gt; ok | {error, Reason}

</pre>

<pre>
<strong></strong>
init_table(Name, InitFun, Options) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>InitFun = fun((Arg) -&gt; Res)</p><p>Arg = read | close</p><p>Res = end_of_input</p>
<pre>
    | {[<strong>object()</strong>], InitFun}
</pre>

<pre>
    | {Data, InitFun}
</pre>

<pre>
    | term()
</pre>
<p>Options = Option | [Option]</p><p>Option = {min_no_slots, <strong>no_slots()</strong>} | {format, term | bchunk}</p><p>Reason = term()</p><p>Data = binary() | tuple()</p><p>Replaces the existing objects of the table <em>Name</em> with objects created by calling the input function <em>InitFun</em>, see below. The reason for using this function rather than calling <em>insert/2</em> is that of efficiency. It should be noted that the input functions are called by the process that handles requests to the Dets table, not by the calling process.</p><p>When called with the argument <em>read</em> the function <em>InitFun</em> is assumed to return <em>end_of_input</em> when there is no more input, or <em>{Objects, Fun}</em>, where <em>Objects</em> is a list of objects and <em>Fun</em> is a new input function. Any other value Value is returned as an error <em>{error, {init_fun, Value}}</em>. Each input function will be called exactly once, and should an error occur, the last function is called with the argument <em>close</em>, the reply of which is ignored.</p><p>If the type of the table is <em>set</em> and there is more than one object with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Duplicate keys should be avoided, or the file will be unnecessarily fragmented. This holds also for duplicated objects stored in tables of type <em>bag</em>.</p><p>It is important that the table has a sufficient number of slots for the objects. If not, the hash list will start to grow when <em>init_table/2</em> returns which will significantly slow down access to the table for a period of time. The minimum number of slots is set by the <em>open_file/2</em> option <em>min_no_slots</em> and returned by the <em>info/2</em> item <em>no_slots</em>. See also the <em>min_no_slots</em> option below.</p><p>The <em>Options</em> argument is a list of <em>{Key, Val}</em> tuples where the following values are allowed:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{min_no_slots, no_slots()}</em>. Specifies the estimated number of different keys that will be stored in the table. The <em>open_file</em> option with the same name is ignored unless the table is created, and in that case performance can be enhanced by supplying an estimate when initializing the table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{format, Format}</em>. Specifies the format of the objects returned by the function <em>InitFun</em>. If <em>Format</em> is <em>term</em> (the default), <em>InitFun</em> is assumed to return a list of tuples. If <em>Format</em> is <em>bchunk</em>, <em>InitFun</em> is assumed to return <em>Data</em> as returned by <strong></strong><em>bchunk/2</em>. This option overrides the <em>min_no_slots</em> option.</p>
  </dd>

</dl>

<pre>
<strong></strong>
insert(Name, Objects) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Objects = <strong>object()</strong> | [<strong>object()</strong>]</p><p>Reason = term()</p><p>Inserts one or more objects into the table <em>Name</em>. If there already exists an object with a key matching the key of some of the given objects and the table type is <em>set</em>, the old object will be replaced.</p>
<pre>
<strong></strong>
insert_new(Name, Objects) -&gt; boolean() | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Objects = <strong>object()</strong> | [<strong>object()</strong>]</p><p>Reason = term()</p><p>Inserts one or more objects into the table <em>Name</em>. If there already exists some object with a key matching the key of any of the given objects the table is not updated and <em>false</em> is returned, otherwise the objects are inserted and <em>true</em> returned.</p>
<pre>
<strong></strong>
is_compatible_bchunk_format(Name, BchunkFormat) -&gt; boolean()

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>BchunkFormat = binary()</p><p>Returns <em>true</em> if it would be possible to initialize the table <em>Name</em>, using <strong></strong><em>init_table/3</em> with the option <em>{format, bchunk}</em>, with objects read with <strong></strong><em>bchunk/2</em> from some table <em>T</em> such that calling <em>info(T, bchunk_format)</em> returns <em>BchunkFormat</em>.</p>
<pre>
<strong></strong>
is_dets_file(Filename) -&gt; boolean() | {error, Reason}

</pre>
<p>Types:</p><p>Filename = <strong>file:name()</strong></p><p>Reason = term()</p><p>Returns <em>true</em> if the file <em>Filename</em> is a Dets table, <em>false</em> otherwise.</p>
<pre>
<strong></strong>
lookup(Name, Key) -&gt; Objects | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Key = term()</p><p>Objects = [<strong>object()</strong>]</p><p>Reason = term()</p><p>Returns a list of all objects with the key <em>Key</em> stored in the table <em>Name</em>. For example:</p>
<pre>
2&gt; dets:open_file(abc, [{type, bag}]).
{ok,abc}
3&gt; dets:insert(abc, {1,2,3}).
ok
4&gt; dets:insert(abc, {1,3,4}).
ok
5&gt; dets:lookup(abc, 1).
[{1,2,3},{1,3,4}]
</pre>
<p>If the table is of type <em>set</em>, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table is of type <em>bag</em> or <em>duplicate_bag</em>, the function returns a list of arbitrary length.</p><p>Note that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.</p>
<pre>
<strong></strong>
match(Continuation) -&gt;
<strong></strong>
         {[Match], Continuation2} |
<strong></strong>
         '$end_of_table' |
<strong></strong>
         {error, Reason}

</pre>
<p>Types:</p><p>Continuation = Continuation2 = <strong>bindings_cont()</strong></p><p>Match = [term()]</p><p>Reason = term()</p><p>Matches some objects stored in a table and returns a non-empty list of the bindings that match a given pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by <em>Continuation</em>, which has been returned by a prior call to <em>match/1</em> or <em>match/3</em>.</p><p>When all objects of the table have been matched, <em>'$end_of_table'</em> is returned.</p>
<pre>
<strong></strong>
match(Name, Pattern) -&gt; [Match] | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Pattern = <strong>pattern()</strong></p><p>Match = [term()]</p><p>Reason = term()</p><p>Returns for each object of the table <em>Name</em> that matches <em>Pattern</em> a list of bindings in some unspecified order. See <strong>ets:match/2</strong> for a description of patterns. If the keypos'th element of <em>Pattern</em> is unbound, all objects of the table are matched. If the keypos'th element is bound, only the objects with the right key are matched.</p>
<pre>
<strong></strong>
match(Name, Pattern, N) -&gt;
<strong></strong>
         {[Match], Continuation} |
<strong></strong>
         '$end_of_table' |
<strong></strong>
         {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Pattern = <strong>pattern()</strong></p><p>N = default | integer() &gt;= 0</p><p>Continuation = <strong>bindings_cont()</strong></p><p>Match = [term()]</p><p>Reason = term()</p><p>Matches some or all objects of the table <em>Name</em> and returns a non-empty list of the bindings that match <em>Pattern</em> in some unspecified order. See <strong>ets:match/2</strong> for a description of patterns.</p><p>A tuple of the bindings and a continuation is returned, unless the table is empty, in which case <em>'$end_of_table'</em> is returned. The continuation is to be used when matching further objects by calling <strong></strong><em>match/1</em>.</p><p>If the keypos'th element of <em>Pattern</em> is bound, all objects of the table are matched. If the keypos'th element is unbound, all objects of the table are matched, <em>N</em> objects at a time, until at least one object matches or the end of the table has been reached. The default, indicated by giving <em>N</em> the value <em>default</em>, is to let the number of objects vary depending on the sizes of the objects. If <em>Name</em> is a version 9 table, all objects with the same key are always matched at the same time which implies that more than N objects may sometimes be matched.</p><p>The table should always be protected using <em>safe_fixtable/2</em> before calling <em>match/3</em>, or errors may occur when calling <em>match/1</em>.</p>
<pre>
<strong></strong>
match_delete(Name, Pattern) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Pattern = <strong>pattern()</strong></p><p>Reason = term()</p><p>Deletes all objects that match <em>Pattern</em> from the table <em>Name</em>. See <strong>ets:match/2</strong> for a description of patterns.</p><p>If the keypos'th element of <em>Pattern</em> is bound, only the objects with the right key are matched.</p>
<pre>
<strong></strong>
match_object(Continuation) -&gt;
<strong></strong>
                {Objects, Continuation2} |
<strong></strong>
                '$end_of_table' |
<strong></strong>
                {error, Reason}

</pre>
<p>Types:</p><p>Continuation = Continuation2 = <strong>object_cont()</strong></p><p>Objects = [<strong>object()</strong>]</p><p>Reason = term()</p><p>Returns a non-empty list of some objects stored in a table that match a given pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by <em>Continuation</em>, which has been returned by a prior call to <em>match_object/1</em> or <em>match_object/3</em>.</p><p>When all objects of the table have been matched, <em>'$end_of_table'</em> is returned.</p>
<pre>
<strong></strong>
match_object(Name, Pattern) -&gt; Objects | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Pattern = <strong>pattern()</strong></p><p>Objects = [<strong>object()</strong>]</p><p>Reason = term()</p><p>Returns a list of all objects of the table <em>Name</em> that match <em>Pattern</em> in some unspecified order. See <strong>ets:match/2</strong> for a description of patterns.</p><p>If the keypos'th element of <em>Pattern</em> is unbound, all objects of the table are matched. If the keypos'th element of <em>Pattern</em> is bound, only the objects with the right key are matched.</p><p>Using the <em>match_object</em> functions for traversing all objects of a table is more efficient than calling <em>first/1</em> and <em>next/2</em> or <em>slot/2</em>.</p>
<pre>
<strong></strong>
match_object(Name, Pattern, N) -&gt;
<strong></strong>
                {Objects, Continuation} |
<strong></strong>
                '$end_of_table' |
<strong></strong>
                {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Pattern = <strong>pattern()</strong></p><p>N = default | integer() &gt;= 0</p><p>Continuation = <strong>object_cont()</strong></p><p>Objects = [<strong>object()</strong>]</p><p>Reason = term()</p><p>Matches some or all objects stored in the table <em>Name</em> and returns a non-empty list of the objects that match <em>Pattern</em> in some unspecified order. See <strong>ets:match/2</strong> for a description of patterns.</p><p>A list of objects and a continuation is returned, unless the table is empty, in which case <em>'$end_of_table'</em> is returned. The continuation is to be used when matching further objects by calling <em>match_object/1</em>.</p><p>If the keypos'th element of <em>Pattern</em> is bound, all objects of the table are matched. If the keypos'th element is unbound, all objects of the table are matched, <em>N</em> objects at a time, until at least one object matches or the end of the table has been reached. The default, indicated by giving <em>N</em> the value <em>default</em>, is to let the number of objects vary depending on the sizes of the objects. If <em>Name</em> is a version 9 table, all matching objects with the same key are always returned in the same reply which implies that more than N objects may sometimes be returned.</p><p>The table should always be protected using <em>safe_fixtable/2</em> before calling <em>match_object/3</em>, or errors may occur when calling <em>match_object/1</em>.</p>
<pre>
<strong></strong>
member(Name, Key) -&gt; boolean() | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Key = Reason = term()</p><p>Works like <em>lookup/2</em>, but does not return the objects. The function returns <em>true</em> if one or more elements of the table has the key <em>Key</em>, <em>false</em> otherwise.</p>
<pre>
<strong></strong>
next(Name, Key1) -&gt; Key2 | '$end_of_table'

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Key1 = Key2 = term()</p><p>Returns the key following <em>Key1</em> in the table <em>Name</em> according to the table's internal order, or <em>'$end_of_table'</em> if there is no next key.</p><p>Should an error occur, the process is exited with an error tuple <em>{error, Reason}</em>.</p><p>Use <strong></strong><em>first/1</em> to find the first key in the table.</p>
<pre>
<strong></strong>
open_file(Filename) -&gt; {ok, Reference} | {error, Reason}

</pre>
<p>Types:</p><p>Filename = <strong>file:name()</strong></p><p>Reference = reference()</p><p>Reason = term()</p><p>Opens an existing table. If the table has not been properly closed, it will be repaired. The returned reference is to be used as the name of the table. This function is most useful for debugging purposes.</p>
<pre>
<strong></strong>
open_file(Name, Args) -&gt; {ok, Name} | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Args = [OpenArg]</p><p>OpenArg = {access, <strong>access()</strong>}</p>
<pre>
        | {auto_save, <strong>auto_save()</strong>}
</pre>

<pre>
        | {estimated_no_objects, integer() &gt;= 0}
</pre>

<pre>
        | {file, <strong>file:name()</strong>}
</pre>

<pre>
        | {max_no_slots, <strong>no_slots()</strong>}
</pre>

<pre>
        | {min_no_slots, <strong>no_slots()</strong>}
</pre>

<pre>
        | {keypos, <strong>keypos()</strong>}
</pre>

<pre>
        | {ram_file, boolean()}
</pre>

<pre>
        | {repair, boolean() | force}
</pre>

<pre>
        | {type, <strong>type()</strong>}
</pre>

<pre>
        | {version, <strong>version()</strong>}
</pre>
<p>Reason = term()</p><p>Opens a table. An empty Dets table is created if no file exists.</p><p>The atom <em>Name</em> is the name of the table. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and several process can share one table.</p><p>If two processes open the same table by giving the same name and arguments, then the table will have two users. If one user closes the table, it still remains open until the second user closes the table.</p><p>The <em>Args</em> argument is a list of <em>{Key, Val}</em> tuples where the following values are allowed:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{access, </em><strong> access()</strong>}. It is possible to open existing tables in read-only mode. A table which is opened in read-only mode is not subjected to the automatic file reparation algorithm if it is later opened after a crash. The default value is <em>read_write</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{auto_save, </em><strong> auto_save()</strong>}, the auto save interval. If the interval is an integer <em>Time</em>, the table is flushed to disk whenever it is not accessed for <em>Time</em> milliseconds. A table that has been flushed will require no reparation when reopened after an uncontrolled emulator halt. If the interval is the atom <em>infinity</em>, auto save is disabled. The default value is 180000 (3 minutes).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{estimated_no_objects, </em><strong> no_slots()</strong>}. Equivalent to the <em>min_no_slots</em> option.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{file, </em><strong> file:name()</strong>}, the name of the file to be opened. The default value is the name of the table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{max_no_slots, </em><strong> no_slots()</strong>}, the maximum number of slots that will be used. The default value as well as the maximal value is 32 M. Note that a higher value may increase the fragmentation of the table, and conversely, that a smaller value may decrease the fragmentation, at the expense of execution time. Only available for version 9 tables.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{min_no_slots, </em><strong> no_slots()</strong>}. Application performance can be enhanced with this flag by specifying, when the table is created, the estimated number of different keys that will be stored in the table. The default value as well as the minimum value is 256.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{keypos, </em><strong> keypos()</strong>}, the position of the element of each object to be used as key. The default value is 1. The ability to explicitly state the key position is most convenient when we want to store Erlang records in which the first position of the record is the name of the record type.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{ram_file, boolean()}</em>, whether the table is to be kept in RAM. Keeping the table in RAM may sound like an anomaly, but can enhance the performance of applications which open a table, insert a set of objects, and then close the table. When the table is closed, its contents are written to the disk file. The default value is <em>false</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{repair, Value}</em>. <em>Value</em> can be either a <em>boolean()</em> or the atom <em>force</em>. The flag specifies whether the Dets server should invoke the automatic file reparation algorithm. The default is <em>true</em>. If <em>false</em> is specified, there is no attempt to repair the file and <em>{error, {needs_repair, FileName}}</em> is returned if the table needs to be repaired.</p><p>The value <em>force</em> means that a reparation will take place even if the table has been properly closed. This is how to convert tables created by older versions of STDLIB. An example is tables hashed with the deprecated <em>erlang:hash/2</em> BIF. Tables created with Dets from a STDLIB version of 1.8.2 and later use the <em>erlang:phash/2</em> function or the <em>erlang:phash2/1</em> function, which is preferred.</p><p>The <em>repair</em> option is ignored if the table is already open.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{type, </em><strong>type()</strong>}, the type of the table. The default value is <em>set</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{version, </em><strong> version()</strong>}, the version of the format used for the table. The default value is <em>9</em>. Tables on the format used before OTP R8 can be created by giving the value <em>8</em>. A version 8 table can be converted to a version 9 table by giving the options <em>{version,9}</em> and <em>{repair,force}</em>.</p>
  </dd>

</dl>

<pre>
<strong></strong>
pid2name(Pid) -&gt; {ok, Name} | undefined

</pre>
<p>Types:</p><p>Pid = pid()</p><p>Name = <strong>tab_name()</strong></p><p>Returns the name of the table given the pid of a process that handles requests to a table, or <em>undefined</em> if there is no such table.</p><p>This function is meant to be used for debugging only.</p>
<pre>
<strong></strong>
repair_continuation(Continuation, MatchSpec) -&gt; Continuation2

</pre>
<p>Types:</p><p>Continuation = Continuation2 = <strong>select_cont()</strong></p><p>MatchSpec = <strong>match_spec()</strong></p><p>This function can be used to restore an opaque continuation returned by <em>select/3</em> or <em>select/1</em> if the continuation has passed through external term format (been sent between nodes or stored on disk).</p><p>The reason for this function is that continuation terms contain compiled match specifications and therefore will be invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent <em>select/1</em> calls even though it has been stored on disk or on another node.</p><p>See also <em>ets(3erl)</em> for further explanations and examples.</p><p><strong></strong> Note:</p><p>This function is very rarely needed in application code. It is used by Mnesia to implement distributed <em>select/3</em> and <em>select/1</em> sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format.</p><p>The reason for not having an external representation of compiled match specifications is performance. It may be subject to change in future releases, while this interface will remain for backward compatibility.</p>
<pre>
<strong></strong>
safe_fixtable(Name, Fix) -&gt; ok

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Fix = boolean()</p><p>If <em>Fix</em> is <em>true</em>, the table <em>Name</em> is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates.</p><p>If several processes fix a table, the table will remain fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table.</p><p>It is not guaranteed that calls to <em>first/1</em>, <em>next/2</em>, select and match functions work as expected even if the table has been fixed; the limited support for concurrency implemented in Ets has not yet been implemented in Dets. Fixing a table currently only disables resizing of the hash list of the table.</p><p>If objects have been added while the table was fixed, the hash list will start to grow when the table is released which will significantly slow down access to the table for a period of time.</p>
<pre>
<strong></strong>
select(Continuation) -&gt;
<strong></strong>
          {Selection, Continuation2} |
<strong></strong>
          '$end_of_table' |
<strong></strong>
          {error, Reason}

</pre>
<p>Types:</p><p>Continuation = Continuation2 = <strong>select_cont()</strong></p><p>Selection = [term()]</p><p>Reason = term()</p><p>Applies a match specification to some objects stored in a table and returns a non-empty list of the results. The table, the match specification, and the number of objects that are matched are all defined by <em>Continuation</em>, which has been returned by a prior call to <em>select/1</em> or <em>select/3</em>.</p><p>When all objects of the table have been matched, <em>'$end_of_table'</em> is returned.</p>
<pre>
<strong></strong>
select(Name, MatchSpec) -&gt; Selection | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>MatchSpec = <strong>match_spec()</strong></p><p>Selection = [term()]</p><p>Reason = term()</p><p>Returns the results of applying the match specification <em>MatchSpec</em> to all or some objects stored in the table <em>Name</em>. The order of the objects is not specified. See the ERTS User's Guide for a description of match specifications.</p><p>If the keypos'th element of <em>MatchSpec</em> is unbound, the match specification is applied to all objects of the table. If the keypos'th element is bound, the match specification is applied to the objects with the right key(s) only.</p><p>Using the <em>select</em> functions for traversing all objects of a table is more efficient than calling <em>first/1</em> and <em>next/2</em> or <em>slot/2</em>.</p>
<pre>
<strong></strong>
select(Name, MatchSpec, N) -&gt;
<strong></strong>
          {Selection, Continuation} |
<strong></strong>
          '$end_of_table' |
<strong></strong>
          {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>MatchSpec = <strong>match_spec()</strong></p><p>N = default | integer() &gt;= 0</p><p>Continuation = <strong>select_cont()</strong></p><p>Selection = [term()]</p><p>Reason = term()</p><p>Returns the results of applying the match specification <em>MatchSpec</em> to some or all objects stored in the table <em>Name</em>. The order of the objects is not specified. See the ERTS User's Guide for a description of match specifications.</p><p>A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case <em>'$end_of_table'</em> is returned. The continuation is to be used when matching further objects by calling <em>select/1</em>.</p><p>If the keypos'th element of <em>MatchSpec</em> is bound, the match specification is applied to all objects of the table with the right key(s). If the keypos'th element of <em>MatchSpec</em> is unbound, the match specification is applied to all objects of the table, <em>N</em> objects at a time, until at least one object matches or the end of the table has been reached. The default, indicated by giving <em>N</em> the value <em>default</em>, is to let the number of objects vary depending on the sizes of the objects. If <em>Name</em> is a version 9 table, all objects with the same key are always handled at the same time which implies that the match specification may be applied to more than N objects.</p><p>The table should always be protected using <em>safe_fixtable/2</em> before calling <em>select/3</em>, or errors may occur when calling <em>select/1</em>.</p>
<pre>
<strong></strong>
select_delete(Name, MatchSpec) -&gt; N | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>MatchSpec = <strong>match_spec()</strong></p><p>N = integer() &gt;= 0</p><p>Reason = term()</p><p>Deletes each object from the table <em>Name</em> such that applying the match specification <em>MatchSpec</em> to the object returns the value <em>true</em>. See the ERTS User's Guide for a description of match specifications. Returns the number of deleted objects.</p><p>If the keypos'th element of <em>MatchSpec</em> is bound, the match specification is applied to the objects with the right key(s) only.</p>
<pre>
<strong></strong>
slot(Name, I) -&gt; '$end_of_table' | Objects | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>I = integer() &gt;= 0</p><p>Objects = [<strong>object()</strong>]</p><p>Reason = term()</p><p>The objects of a table are distributed among slots, starting with slot <em>0</em> and ending with slot n. This function returns the list of objects associated with slot <em>I</em>. If <em>I</em> is greater than n <em>'$end_of_table'</em> is returned.</p>
<pre>
<strong></strong>
sync(Name) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Reason = term()</p><p>Ensures that all updates made to the table <em>Name</em> are written to disk. This also applies to tables which have been opened with the <em>ram_file</em> flag set to <em>true</em>. In this case, the contents of the RAM file are flushed to disk.</p><p>Note that the space management data structures kept in RAM, the buddy system, is also written to the disk. This may take some time if the table is fragmented.</p>
<pre>
<strong></strong>
table(Name) -&gt; QueryHandle

</pre>

<pre>
<strong></strong>
table(Name, Options) -&gt; QueryHandle

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Options = Option | [Option]</p><p>Option = {n_objects, Limit} | {traverse, TraverseMethod}</p><p>Limit = default | integer() &gt;= 1</p><p>TraverseMethod = first_next | select | {select, <strong>match_spec()</strong>}</p><p>QueryHandle = <strong>qlc:query_handle()</strong></p><p>Returns a QLC (Query List Comprehension) query handle. The module <em>qlc</em> implements a query language aimed mainly at Mnesia but Ets tables, Dets tables, and lists are also recognized by <em>qlc</em> as sources of data. Calling <em>dets:table/1,2</em> is the means to make the Dets table <em>Name</em> usable to <em>qlc</em>.</p><p>When there are only simple restrictions on the key position <em>qlc</em> uses <em>dets:lookup/2</em> to look up the keys, but when that is not possible the whole table is traversed. The option <em>traverse</em> determines how this is done:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>first_next</em>. The table is traversed one key at a time by calling <em>dets:first/1</em> and <em>dets:next/2</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>select</em>. The table is traversed by calling <em>dets:select/3</em> and <em>dets:select/1</em>. The option <em>n_objects</em> determines the number of objects returned (the third argument of <em>select/3</em>). The match specification (the second argument of <em>select/3</em>) is assembled by <em>qlc</em>: simple filters are translated into equivalent match specifications while more complicated filters have to be applied to all objects returned by <em>select/3</em> given a match specification that matches all objects.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{select, </em><strong> match_spec()}</strong>. As for <em>select</em> the table is traversed by calling <em>dets:select/3</em> and <em>dets:select/1</em>. The difference is that the match specification is explicitly given. This is how to state match specifications that cannot easily be expressed within the syntax provided by <em>qlc</em>.</p>
  </dd>

</dl>
<p>The following example uses an explicit match specification to traverse the table:</p>
<pre>
1&gt; dets:open_file(t, []),
ok = dets:insert(t, [{1,a},{2,b},{3,c},{4,d}]),
MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end),
QH1 = dets:table(t, [{traverse, {select, MS}}]).
</pre>
<p>An example with implicit match specification:</p>
<pre>
2&gt; QH2 = qlc:q([{Y} || {X,Y} &lt;- dets:table(t), (X &gt; 1) or (X &lt; 5)]).
</pre>
<p>The latter example is in fact equivalent to the former which can be verified using the function <em>qlc:info/1</em>:</p>
<pre>
3&gt; qlc:info(QH1) =:= qlc:info(QH2).
true
</pre>
<p><em>qlc:info/1</em> returns information about a query handle, and in this case identical information is returned for the two query handles.</p>
<pre>
<strong></strong>
to_ets(Name, EtsTab) -&gt; EtsTab | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>EtsTab = <strong>ets:tab()</strong></p><p>Reason = term()</p><p>Inserts the objects of the Dets table <em>Name</em> into the Ets table <em>EtsTab</em>. The order in which the objects are inserted is not specified. The existing objects of the Ets table are kept unless overwritten.</p>
<pre>
<strong></strong>
traverse(Name, Fun) -&gt; Return | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Fun = fun((Object) -&gt; FunReturn)</p><p>Object = <strong>object()</strong></p><p>FunReturn = continue</p>
<pre>
          | {continue, Val}
</pre>

<pre>
          | {done, Value}
</pre>

<pre>
          | OtherValue
</pre>
<p>Return = [term()] | OtherValue</p><p>Val = Value = OtherValue = Reason = term()</p><p>Applies <em>Fun</em> to each object stored in the table <em>Name</em> in some unspecified order. Different actions are taken depending on the return value of <em>Fun</em>. The following <em>Fun</em> return values are allowed:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>continue</em>: Continue to perform the traversal. For example, the following function can be used to print out the contents of a table:</p>
  </dd>

</dl>

<pre>
fun(X) -&gt; io:format("~p~n", [X]), continue end.
</pre>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{continue, Val}</em>: Continue the traversal and accumulate <em>Val</em>. The following function is supplied in order to collect all objects of a table in a list:</p>
  </dd>

</dl>

<pre>
fun(X) -&gt; {continue, X} end.
</pre>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{done, Value}</em>: Terminate the traversal and return <em>[Value | Acc]</em>.</p>
  </dd>

</dl>
<p>Any other value <em>OtherValue</em> returned by <em>Fun</em> terminates the traversal and is immediately returned.</p>
<pre>
<strong></strong>
update_counter(Name, Key, Increment) -&gt; Result

</pre>
<p>Types:</p><p>Name = <strong>tab_name()</strong></p><p>Key = term()</p><p>Increment = {Pos, Incr} | Incr</p><p>Pos = Incr = Result = integer()</p><p>Updates the object with key <em>Key</em> stored in the table <em>Name</em> of type <em>set</em> by adding <em>Incr</em> to the element at the <em>Pos</em>:th position. The new counter value is returned. If no position is specified, the element directly following the key is updated.</p><p>This functions provides a way of updating a counter, without having to look up an object, update the object by incrementing an element and insert the resulting object into the table again.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO dets&hellip;</h2>
        <div class="sectioncontent">
<p><strong>ets(3erl)</strong>, mnesia(3erl), <strong>qlc(3erl)</strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="debugger.3erl.html"><span aria-hidden="true">&larr;</span> debugger.3erl: Erlang debugger</a></li>
   <li class="next"><a href="dialyzer.3erl.html">dialyzer.3erl: The dialyzer, a discrepancy analyzer for erlang programs <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

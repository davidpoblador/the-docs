<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Perl6::Form: Implements the perl 6 'form' built-in</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Implements the perl 6 'form' built-in">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Perl6::Form (3pm) manual">
  <meta name="twitter:description" content="Implements the perl 6 'form' built-in">
  <meta name="twitter:image" content="https://www.carta.tech/images/libperl6-form-perl-Perl6::Form-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Perl6::Form.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Perl6::Form (3pm) manual" />
  <meta property="og:description" content="Implements the perl 6 'form' built-in" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libperl6-form-perl-Perl6::Form-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Perl6::Form<small> (3pm)</small></h1>
        <p class="lead">Implements the perl 6 'form' built-in</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Perl6::Form.3pm.html">
      <span itemprop="name">Perl6::Form: Implements the perl 6 'form' built-in</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libperl6-form-perl/">
      <span itemprop="name">libperl6-form-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Perl6::Form.3pm.html">
      <span itemprop="name">Perl6::Form: Implements the perl 6 'form' built-in</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use Perl6::Form;
</pre>
<p>    $text = form " =================================== ",                  "| NAME     |    AGE     | ID NUMBER |",                  "|----------+------------+-----------|",                  "| {&lt;&lt;&lt;&lt;&lt;&lt;} | {||||||||} | {&gt;&gt;&gt;&gt;&gt;&gt;&gt;} |",                     $name,     $age,        $ID,                  "|===================================|",                  "| COMMENTS                          |",                  "|-----------------------------------|",                  "| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |",                     $comments,                  " =================================== ";</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Formats are Perl 5's mechanism for creating text templates with fixed-width fields. Those fields are then filled in using values from prespecified package variables.</p><p>Unlike Perl 5, Perl 6 doesn't have a \*(C`format\*(C' keyword. Or the associated built-in formatting mechanism. Instead it has a Form.pm module. And a \*(C`form\*(C' function.</p><p>Like a Perl 5 \*(C`format\*(C' statement, the \*(C`form\*(C' function takes a series of format (or \*(L"picture\*(R") strings, each of which is immediately followed by a suitable set of replacement values. It interpolates those values into the placeholders specified within each picture string, and returns the result:</p><p>    $text = form                                  $format_f1,                                          $datum1, $datum2, $datum3,                                  $format_f2,                                          $datum4,                                  $format_f3,                                          $datum5;</p><p>So, whereas in Perl 5 we might write:</p><p>    # Perl 5 code...</p><p>    our ($name, $age, $ID, $comments);</p><p>    format STDOUT      ===================================     | NAME     |    AGE     | ID NUMBER |     |----------+------------+-----------|     | @&lt;&lt;&lt;&lt;&lt;&lt;&lt; | @||||||||| | @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; |       $name,     $age,        $ID,     |===================================|     | COMMENTS                          |     |-----------------------------------|     | ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |~~       $comments,      ===================================     .</p><p>    write STDOUT;</p><p>in Perl 6 we could write:</p><p>        # Perl 6 code...</p><p>    print form         " =================================== ",         "| NAME     |    AGE     | ID NUMBER |",         "|----------+------------+-----------|",         "| {&lt;&lt;&lt;&lt;&lt;&lt;} | {||||||||} | {&gt;&gt;&gt;&gt;&gt;&gt;&gt;} |",            $name,     $age,        $ID,         "|===================================|",         "| COMMENTS                          |",         "|-----------------------------------|",         "| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |",            $comments,         " =================================== ";</p><p>And both of them would print something like:</p><p>     ===================================     | NAME     |    AGE     | ID NUMBER |     |----------+------------+-----------|     | Richard  |     33     |    000003 |     |===================================|     | COMMENTS                          |     |-----------------------------------|     | Talks to self. Seems to be        |     | overcompensating for inferiority  |     | complex rooted in post-natal      |     | materal rejection due to physical |     | handicap (congenital or perhaps   |     | the result of premature birth).   |     | Shows numerous indications of     |     | psychotic (esp. nepocidal)        |     | tendencies. Naturally, subject    |     | gravitated to career in politics. |      ===================================</p><p>This module implements virtually all of the functionality of the Perl 6 Form.pm module. The only differences are:</p><ul>
<li><p>Option pairs must be passed in a hash reference;</p></li><li><p>Array data sources must be passed as array references;</p></li><li><p>Options specified on the \*(C`use Perl6::Form\*(C' line are not (yet) lexically scoped;</p></li><li><p>User-defined line-breaking subroutines are passed their data source as a reference to a scalar;</p></li>
</ul><p><strong>&#92;$1</strong></p>
<dl class='dl-vertical'>
  <dt>
    Format
  </dt>
  <dd>
    <p>A string that is used as a template for the creation of <em>text</em>. It will contain zero or more <em>fields</em>, usually with some literal characters and whitespace between them.</p>
  </dd>
  <dt>
    Text
  </dt>
  <dd>
    <p>A string that is created by replacing the fields of a format with specific <em>data</em> values.  For example, the string that a call to \*(C`form\*(C' returns.</p>
  </dd>
  <dt>
    Field
  </dt>
  <dd>
    <p>A fixed-width slot within a format string, into which <em>data</em> will be formatted.</p>
  </dd>
  <dt>
    Data
  </dt>
  <dd>
    <p>A string or numeric value (or an array of such values) that is interpolated into a format, in order to fill in a particular field.</p>
  </dd>
  <dt>
    Single-line field
  </dt>
  <dd>
    <p>A field that interpolates only as much of its corresponding data value as will fit inside it within a single line of text.</p>
  </dd>
  <dt>
    Block field
  </dt>
  <dd>
    <p>A field that interpolates all of its corresponding data value, over a series of text lines E&lt;ndash&gt; as many as necessary E&lt;ndash&gt; producing a <em>text block</em>.</p>
  </dd>
  <dt>
    Text block
  </dt>
  <dd>
    <p>The column of newline-separated text lines. A text block is produced when data is formatted into a block field that is too small to contain the data in a single line</p>
  </dd>
  <dt>
    Column
  </dt>
  <dd>
    <p>The amount of space on an output device required to display one single-width character. One character will occupy one column in most cases, the most obvious exceptions being \s-1CJK\s0 double-width characters. When called in a scalar or list context, \*(C`form\*(C' returns a string containing the complete formatted text:</p>
  </dd>

</dl>
<p>    my $formatted_text = form $format, *@data;</p><p>    @texts = ( form($format, *@data1), form($format, *@data2) );  # 2 elems</p><p>When called in a void context, \*(C`form\*(C' dies, bitterly pointing out how useless that is to format something and then just throw the result away.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field types</h2>
        <div class="sectioncontent">
<p>The format strings passed to \*(C`form\*(C' determine what the resulting formatted text looks like. Each format consists of a series of field specifiers, which are usually separated by literal characters.</p><p>\*(C`form\*(C' understands a far larger number of field specifiers than \*(C`format\*(C' did, designed around a small number of conventions:</p><ul>
<li><p>Each field is enclosed in a pair of braces.</p></li><li><p>Within the braces, left or right angle brackets (\*(C`&lt;\*(C' or \*(C`&gt;\*(C'), bars (\*(C`|\*(C'), and single-quotes (\*(C`'\*(C') indicate various types of single-line fields.</p></li><li><p>Left or right square brackets (\*(C`[\*(C' or \*(C`]\*(C'), I's (\*(C`I\*(C'), and double- quotes (\*(C`"\*(C') indicate block fields of various types.</p></li><li><p>The direction of the brackets within a field indicates the direction towards which text will be justified in that field. For example:     {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}   Justify the text to the left     {&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;}                  Justify the text to the right     {&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;}                 Centre the text     {&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;}   Fully  justify  the  text  to  both  margins This is even true for numeric fields, which look like: \*(C`{&gt;&gt;&gt;&gt;&gt;.&lt;&lt;}\*(C'. The whole digits are right-justified before the dot and the decimals are left-justified after it.</p></li><li><p>An \*(C`=\*(C' at either end of a field (or both ends) indicates the data interpolated into the field is to be vertically \*(L"middled\*(R" within the resulting block. That is, the text is to be centred vertically on the middle of all the lines produced by the complete format.</p></li><li><p>An \*(C`_\*(C' at the start and/or end of a field indicates the interpolated data is to be vertically \*(L"bottomed\*(R" within the resulting block. That is, the text is to be pushed to the bottom of the lines produced by the format.</p></li>
</ul><p>For example:</p><p>                                      Field specifier     Field type                 One-line             Block     ==========                ==========          ==========</p><p>    left justified            {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}          {[[[[[[[[}     right justified           {&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;}          {]]]]]]]]}     centred                   {&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;}          {]]]][[[[}     centred (alternative)     {||||||||}          {IIIIIIII}     fully justified           {&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;}          {[[[[]]]]}     verbatim                  {&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;}          {""""""""}</p><p>    numeric                   {&gt;&gt;&gt;&gt;&gt;.&lt;&lt;}          {]]]]].[[}     euronumeric               {&gt;&gt;&gt;&gt;&gt;,&lt;&lt;}          {]]]]],[[}     comma&apos;d                   {&gt;,&gt;&gt;&gt;,&gt;&gt;&gt;.&lt;&lt;}      {],]]],]]].[[}     space&apos;d                   {&gt; &gt;&gt;&gt; &gt;&gt;&gt;.&lt;&lt;}      {] ]]] ]]].[[}     eurocomma&apos;d               {&gt;.&gt;&gt;&gt;.&gt;&gt;&gt;,&lt;&lt;}      {].]]].]]],[[}     Swiss Army comma&apos;d        {&gt;&apos;&gt;&gt;&gt;&apos;&gt;&gt;&gt;,&lt;&lt;}      {]&apos;]]]&apos;]]],[[}     subcontinental            {&gt;&gt;,&gt;&gt;,&gt;&gt;&gt;.&lt;&lt;}      {]],]],]]].[[}</p><p>    signed numeric            {-&gt;&gt;&gt;.&lt;&lt;&lt;}          {-]]].[[[}     post-signed numeric       {&gt;&gt;&gt;&gt;.&lt;&lt;-}          {]]]].[[-}     paren-signed numeric      {(&gt;&gt;&gt;.&lt;&lt;)}          {(]]].[[)}</p><p>    prefix currency           {$&gt;&gt;&gt;.&lt;&lt;&lt;}          {$]]].[[[}     postfix currency          {&gt;&gt;&gt;.&lt;&lt;&lt;DM}         {]]].[[[DM}     infix currency            {&gt;&gt;&gt;$&lt;&lt; Esc}        {]]]$[[ Esc}</p><p>    left/middled              {=&lt;&lt;&lt;&lt;&lt;&lt;=}          {=[[[[[[=}     right/middled             {=&gt;&gt;&gt;&gt;&gt;&gt;=}          {=]]]]]]=}     infix currency/middled    {=&gt;&gt;$&lt;&lt; Esc}        {=]]$[[ Esc}     eurocomma&apos;d/middled       {&gt;.&gt;&gt;&gt;.&gt;&gt;&gt;,&lt;&lt;=}     {].]]].]]],[[=}     etc.</p><p>    left/bottomed             {_&lt;&lt;&lt;&lt;&lt;&lt;_}          {_[[[[[[_}     right/bottomed            {_&gt;&gt;&gt;&gt;&gt;&gt;_}          {_]]]]]]_}     etc.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">How fields are filled</h2>
        <div class="sectioncontent">
<p>When data is interpolated into a line field, the field grabs as much of the data as will fit on a single line, formats that data appropriately, and interpolates it into the format.</p><p>That means that if we use a one-line field, it only shows as much of the data as will fit on one lime. For example:</p><p>    my $data1 = &apos;By the pricking of my thumbs, something wicked this way comes&apos;;     my $data2 = &apos;A horse! A horse! My kingdom for a horse!&apos;;</p><p>    print form         "...{&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}...{&gt;&gt;&gt;&gt;&gt;&gt;&gt;}...",             $data1,               $data2;</p><p>prints:</p><p>    ...By the pricking of ... A horse!...</p><p>On the other hand, if our format string used block fields instead, the fields would extract one line of data at a time, repeating that process as many times as necessary to display all the available data. So:</p><p>    print form         "...{[[[[[[[[[[[[[[[[[}...{]]]]]]]}...",             $data1,               $data2;</p><p>would produce:</p><p>    ...By the pricking of ... A horse!...     ...my thumbs,         ... A horse!...     ...something wicked   ...       My...     ...this way comes     ...  kingdom...     ...                   ...    for a...     ...                   ...   horse!...</p><p>We can mix line fields and block fields in the same format and \*(C`form\*(C' will extract and interpolate only as much data as each field requires. For example:</p><p>    print form         "...{&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}...{]]]]]]]}...",             $data1,               $data2;</p><p>which produces:</p><p>    ...By the pricking of ... A horse!...     ...                   ... A horse!...     ...                   ...       My...     ...                   ...  kingdom...     ...                   ...    for a...     ...                   ...   horse!...</p><p>Notice that, after the first line, the single-line \*(C`{&lt;&lt;&lt;&lt;&lt;&lt;}\*(C' field is simply replaced by the appropriate number of space characters, to keep the columns correctly aligned.</p><p>The usual reason for mixing line and block fields in this way is to allow numbered or bulleted points:</p><p>    print "I couldn&apos;t do my English Lit homework because...&#92;n&#92;n";</p><p>        my $index = 0;     for my $reason (@reasons) {         my $n = @reasons - $index . &apos;.&apos;;         print form "   {&gt;}  {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}",                        $n,  $reason,                    "";     }</p><p>which might produce:</p><p>    I couldn&apos;t do my English Lit homework because...</p><p>         10. Three witches told me I was going to be              king.</p><p>          9. I was busy explaining wherefore am I Romeo.</p><p>          8. I was busy scrubbing the blood off my              hands.</p><p>          7. Some dear friends had to charge once more              unto the breach.</p><p>          6. My so-called best friend tricked me into              killing my wife.</p><p>          5. My so-called best friend tricked me into              killing Caesar.</p><p>          4. My so-called best friend tricked me into              taming a shrew.</p><p>          3. My uncle killed my father and married my              mother.</p><p>          2. I fell in love with my manservant, who was              actually the disguised twin sister of the              man that my former love secretly married,              having mistaken him for my manservant who              was wooing her on my behalf whilst secretly              in love with me.</p><p>          1. I was abducted by fairies.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Keeping track of what's been formatted</h2>
        <div class="sectioncontent">
<p>Obviously, as a call to \*(C`form\*(C' builds up each line of its output E&lt;ndash&gt; extracting data from one or more data arguments and formatting it into the corresponding fields E&lt;ndash&gt; it needs to keep track of where it's up to in each datum. It does this by progressively updating the \*(C`pos\*(C' of each datum, in exactly the same way as a pattern match does.</p><p>And as with a pattern match, by default that updated \*(C`pos\*(C' is only used internally and <strong>not</strong> preserved after the call to \*(C`form\*(C' is finished. So passing a string to \*(C`form\*(C' doesn't interfere with any other pattern matching or text formatting that we might subsequently do with that data.</p><p>However, sometimes we <em>do</em> want to know how much of our data a call to \*(C`form\*(C' managed to extract and format. Or we may want to split a formatting task into several stages, with separate calls to \*(C`form\*(C' for each stage. So we need a way of telling \*(C`form\*(C' to preserve the \*(C`pos\*(C' information in our data.</p><p>But, if we want to apply a series of \*(C`form\*(C' calls to the same data we also need to be able to tell \*(C`form\*(C' to <em>respect</em> the \*(C`pos\*(C' information of that data E&lt;ndash&gt; to start extracting from the previously preserved \*(C`.pos\*(C' position, rather than from the start of the string.</p><p>To achieve both those goals, we use a <em>follow-on field</em>. That is we use an ordinary field but mark it as \*(C`pos\*(C'-sensitive with a special notation: \s-1ASCII\s0 colons at either end. So instead of \*(C`{&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;}\*(C', we'd write \*(C`{:&lt;&lt;&lt;&gt;&gt;&gt;:}\*(C'.</p><p>Follow-on fields are most useful when we want to split a formatting task into distinct stages E&lt;ndash&gt; or iterations E&lt;ndash&gt; but still allow the contents of the follow-on field to flow uninterrupted from line to line. For example:</p><p>    print "The best Shakespearean roles are:&#92;n&#92;n";</p><p>    for my $role (@roles) {         print form "   * {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}   *{:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;:}*",                          $role,                            $disclaimer;     }</p><p>which produces:</p><p>    The best Shakespearean roles are:</p><p>       * Macbeth                          *WARNING:          *        * King Lear                        *This list of roles*        * Juliet                           *constitutes      a*        * Othello                          *personal   opinion*        * Hippolyta                        *only and is in  no*        * Don John                         *way  endorsed   by*        * Katerina                         *Shakespeare&apos;R&apos;Us. *        * Richard                          *It   may   contain*        * Malvolio                         *nuts.             *        * Bottom                           *                  *</p><p>The multiple calls to \*(C`form\*(C' manage to produce a coherent disclaimer because the colons in the second field tell each call to start extracting data from $disclaimer at the offset indicated by \*(C`pos $disclaimer\*(C', and then to update \*(C`pos $disclaimer\*(C' with the final position at which the field extracted data. So the next time \*(C`form\*(C' is called, the follow-on field starts extracting from where it left off in the previous call.</p><p>Follow-on fields are similar to \*(C`^&lt;&lt;&lt;&lt;&lt;\*(C' fields in a Perl 5 format, except they don't destroy the contents of a data source; they merely change that data source's \*(C`pos\*(C' marker.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Array data sources</h2>
        <div class="sectioncontent">
<p>Data, especially numeric data, is often stored in arrays. So \*(C`form\*(C' also accepts arrays as data arguments too. Or, more precisely, it accepts <strong>references</strong> to arrays as arguments.</p><p>Once inside \*(C`form\*(C', each array that was specified as the data source for a field is internally converted to a single string by joining it together with a newline between each element.</p><p>The upshot is that, instead of:</p><p>    print "The best Shakespearean roles are:&#92;n&#92;n";</p><p>    for my $role (@roles) {         print form "   * {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}   *{:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;:}*",                          $role,                            $disclaimer;     }</p><p>we could just write:</p><p>    print "The best Shakespearean roles are:&#92;n&#92;n";</p><p>    print form "   * {[[[[[[[[[[[[[[[[[[[[[[[[[[[[}   *{[[[[[[[[]]]]]]]]}*",                      &#92;@roles,                          $disclaimer;</p><p>And the array of roles would be internally converted to a single string, with one role per line. Note that we also changed the disclaimer field to a regular block field, so that the entire disclaimer would be formatted. And there was no longer any need for the disclaimer field to be a follow-on field, since the block field would extract and format the entire disclaimer anyway.</p><p>Array data sources are particularly useful when formatting, especially if the data is known to fit within the specified width. For example:</p><p>    print form         &apos;-------------------------------------------&apos;,         &apos;Name             Score   Time  | Normalized&apos;,         &apos;-------------------------------------------&apos;,         &apos;{[[[[[[[[[[[[}   {III}   {II}  |  {]]].[[} &apos;,          @name,           @score, @time,   [map {$score[$_]/$time[$_]} 0..$#score]</p><p>is a very easy way to produce the table:</p><p>    -------------------------------------------     Name             Score   Time  | Normalized     -------------------------------------------     Thomas Mowbray    88      15   |     5.867     Richard Scroop    54      13   |     4.154     Harry Percy       99      18   |     5.5 The most commonly used fields are those that justify their contents: to the left, to the right, to the left <em>and</em> right, or towards the centre.</p><p>Left-justified and right-justified fields extract from their data source the largest substring that will fit inside them, push that string to the left or right as appropriate, and then pad the string out to the required field width with spaces (or the nominated fill character).</p><p>Centred fields (\*(C`{&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;}\*(C' and \*(C`{]]]][[[[}\*(C') likewise extract as much data as possible, and then pad both sides of it with (near) equal numbers of spaces. If the amount of padding required is not evenly divisible by 2, the one extra space is added <em>after</em> the data.</p><p>There is a second syntax for centred fields E&lt;ndash&gt; a tip-o'-the-hat to Perl 5 formats: \*(C`{|||||||||}\*(C' and \*(C`{IIIIIIII}\*(C'. This variant also makes it easier to specify centering fields that are only three columns wide: \*(C`{|}\*(C' and \*(C`{I}\*(C'.</p><p>Note, however, that the behaviour of centering fields specified this way is exactly the same in every respect as the bracket-based versions, so we're free to use whichever we prefer.</p><p>Fully justified fields (\*(C`{&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;}\*(C' and \*(C`{[[[[]]]]}\*(C') extract a maximal substring and then distribute any padding as evenly as possible into the existing whitespace gaps in that data. For example:</p><p>    print form &apos;({&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;})&apos;,                "A fellow of infinite jest, of most excellent fancy";</p><p>would print:</p><p>    (A fellow  of  infinite)</p><p>A fully-justified block field (\*(C`{[[[[]]]]}\*(C') does the same across multiple lines, except that the very last line is always left-justified. Hence, this:</p><p>    print form &apos;({[[[[[[[[]]]]]]]})&apos;,                "All the world&apos;s a stage, And all the men and women merely players."</p><p>would print:</p><p>    (All the world&apos;s a)     (stage,  And   all)     (the men and women)     (merely players.  )</p><p>By the way, with both centred fields (\*(C`{&gt;&gt;&gt;&gt;&lt;&lt;&lt;}\*(C') and fully justified fields (\*(C`{&lt;&lt;&lt;&gt;&gt;&gt;&gt;}\*(C'), the actual number of left vs right arrows is irrelevant, so long as there is at least one of each.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Short fields</h2>
        <div class="sectioncontent">
<p>One special case we need to consider is an empty set of field delimiters:</p><p>    form &apos;ID number: {}&apos;</p><p>This specification is treated as a two-column-wide, left-justified block field (since that seems to be the type of two-column-wide field most often required).</p><p>Other kinds of two-column (and single-column) fields can also be created using imperative field widths and and user-defined fields.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Numerical fields</h2>
        <div class="sectioncontent">
<p>A field specifier of the form \*(C`{&gt;&gt;&gt;&gt;.&lt;&lt;}\*(C' or \*(C`{]]]].[[}\*(C' represents a decimal-aligned numeric field. The decimal marker always appears in exactly the position indicated and the rest of the number is aligned around it. The decimal places are rounded to the specific number of places indicated, but only \*(L"significant\*(R" digits are shown. For example:</p><p>    @nums = (1, 1.2, 1.23, 11.234, 111.235, 1.0001);</p><p>    print form "Thy score be: {]]]].[[}",                               &#92;@nums;</p><p>prints:</p><p>    Thy score be:     1.0     Thy score be:     1.2     Thy score be:     1.23     Thy score be:    11.234     Thy score be:   111.235     Thy score be:     1.000 You're probably wondering what happens if we try to format a number that's too large for the available places (as 123456.78 would be in the above format). Whereas \*(C`sprintf\*(C' would extend a numeric field to accommodate the number, \*(C`form\*(C' insists on preserving the specified layout; in particular, the position of the decimal point. But it obviously can't just cut off the extra high-order digits; that would change the value:</p><p>    Thy score be: 23456.78</p><p>So, instead, it indicates that the number doesn't fit by filling the field with octothorpes (the way many spreadsheets do):</p><p>    Thy score be: #####.###</p><p>It's also possible that someone (not you, of course!) might attempt to pass a numeric field some data that isn't numeric at all:</p><p>    my @mixed_data = (1, 2, "three", {4=&gt;5}, "6", "7-Up");</p><p>    print form &apos;Thy score be: {]]]].[[}&apos;,                               &#92;@mixed_data;</p><p>Unlike Perl itself, \*(C`form\*(C' doesn't autoconvert non-numeric values. Instead it marks them with another special string, by filling the field with question-marks:</p><p>    Thy score be:     1.0     Thy score be:     2.0     Thy score be: ?????.???     Thy score be: ?????.???     Thy score be:     6.0     Thy score be: ?????.???</p><p>Note that strings per se aren't a problem E&lt;ndash&gt; \*(C`form\*(C' will happily convert strings that contain valid numbers, such as "6" in the above example. But it does reject strings that contain anything else besides a number (even when Perl itself would successfully convert the number E&lt;ndash&gt; as it would for "7-Up" above).</p><p>Those who'd prefer Perl's usual, more laissez-faire attitude to numerical conversion can just pre-numerify the values themselves:</p><p>    print form &apos;Thy score be: {]]]].[[}&apos;,                               [map {$_+0} @mixed_data];</p><p>This version would print something like:</p><p>    Thy score be:     1.0     Thy score be:     2.0     Thy score be:     0.0     Thy score be:     1.0     Thy score be:     6.0     Thy score be:     7.0 Of course, not everyone uses a dot for their decimal point. The other main contender is the comma, and naturally \*(C`form\*(C' supports that as well. If we specify a numeric field with a comma between the brackets:</p><p>    @les_nums = (1, 1.2, 1.23, 11.234, 111.235, 1.0001);</p><p>    print form &apos;Votre score est: {]]]],[[}&apos;,                                  &#92;@les_nums;</p><p>the call prints:</p><p>    Votre score est:     1,0     Votre score est:     1,2     Votre score est:     1,23     Votre score est:    11,234     Votre score est:   111,235     Votre score est:     1,000</p><p>In fact, \*(C`form\*(C' is extremely flexible about the characters we're allowed to use as a decimal marker: anything except an angle- or square bracket or a plus sign is acceptable.</p><p>As a bonus, \*(C`form\*(C' allows us to use the specified decimal marker in the <em>data</em> as well as in the format. So this works too:</p><p>    @les_nums = ("1", "1,2", "1,23", "11,234", "111,235", "1,0001");</p><p>    print form &apos;Vos score est: {]]]],[[}&apos;,                                &#92;@les_nums; Negative numbers work as expected, with the minus sign taking up one column of the field's allotted span:</p><p>    @nums = ( 1, -1.2,  1.23, -11.234,  111.235, -12345.67);</p><p>    print form &apos;Thy score be: {]]]].[[}&apos;,                               &#92;@nums;</p><p>This would print:</p><p>    Thy score be:     1.0     Thy score be:    -1.2     Thy score be:     1.23     Thy score be:   -11.234     Thy score be:   111.235     Thy score be: #####.###</p><p>However, \*(C`form\*(C' can also format numbers so that the minus sign <em>trails</em> the number. To do that we simple put an explicit minus sign inside the field specification, at the end:</p><p>    print form &apos;Thy score be: {]]]].[[-}&apos;,                               &#92;@nums;</p><p>which would then print:</p><p>    Thy score be:     1.0     Thy score be:     1.2-     Thy score be:     1.23     Thy score be:    11.234-     Thy score be:   111.235     Thy score be: 12345.67-</p><p>\*(C`form\*(C' also understands the common financial usage where negative numbers are represented as positive numbers in parentheses. Once again, we draw an abstract picture of what we want (by putting parens at either end of the field specification):</p><p>    print form &apos;Thy dividend be: {(]]]].[[)}&apos;,                                  &#92;@nums;</p><p>and \*(C`form\*(C' obliges:</p><p>    Thy dividend be:      1.0     Thy dividend be:     (1.2)     Thy dividend be:      1.23     Thy dividend be:    (11.234)     Thy dividend be:    111.235     Thy dividend be: (12345.67)</p><p>Note that the parens have to go <em>inside</em> the field's braces. Otherwise, they're just literal parts of the format string. If we add so-called \*(L"thousands separators\*(R" inside a numeric field at the usual places, \*(C`form\*(C' includes them appropriately in its output. It can handle the five major formatting conventions:</p><p>    my @nums = (0, 1, 1.1, 1.23, 4567.89, 34567.89, 234567.89, 1234567.89);</p><p>    print form         "Brittannic      Continental     Subcontinental   Tyrolean        Asiatic",         "_____________   _____________   ______________   _____________   _____________",         "{],]]],]]].[}   {].]]].]]],[}    {]],]],]]].[}   {]&apos;]]]&apos;]]],[}   {]]]],]]]].[}",          &#92;@nums,         &#92;@nums,          &#92;@nums,         &#92;@nums,         &#92;@nums;</p><p>to produce:</p><p>    Brittannic      Continental     Subcontinental   Tyrolean        Asiatic     _____________   _____________   ______________   _____________   _____________              0.0             0,0              0.0             0,0             0.0              1.0             1,0              1.0             1,0             1.0              1.1             1,1              1.1             1,1             1.1              1.23            1,23             1.23            1,23            1.23          4,567.89        4.567,89         4,567.89        4&apos;567,89         4567.89         34,567.89       34.567,89        34,567.89       34&apos;567,89       3,4567.89        234,567.89      234.567,89      2,34,567.89      234&apos;567,89      23,4567.89      1,234,567.89    1.234.567,89     12,34,567.89    1&apos;234&apos;567,89     123,4567.89</p><p>It also accepts a space character as a \*(L"thousands separator\*(R" (with, of course, any decimal marker we might like):</p><p>    print form         "Hyperspatial",         "_____________",         "{] ]]] ]]]:[}",          &#92;@nums;</p><p>to produce:</p><p>    Hyperspatial     _____________              0:0              1:0              1:1              1:23          4 567:89         34 567:89        234 567:89      1 234 567:89</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Locale-specific numeric formatting</h2>
        <div class="sectioncontent">
<p>Of course, sometimes we don't know ahead of time just where in the world our formatted numbers will be displayed. Locales were invented to address that very problem, and \*(C`form\*(C' supports them.</p><p>If we use the \*(C`locale\*(C' option, \*(C`form\*(C' detects the current locale and converts any numerical formats it finds to the appropriate layout. For example, if we wrote:</p><p>    @nums = ( 1, -1.2,  1.23, -11.234,  111.235, -12345.67);</p><p>    print form             "{],]]],]]].[[}",             &#92;@nums;</p><p>then we'd get:</p><p>          1.0          -1.2           1.23         -11.234         111.235     -12,345.67</p><p>wherever the program was run. But if we had written:</p><p>    print form             {locale=&gt;1},             "{],]]],]]].[[}",             &#92;@nums;</p><p>then we'd get:</p><p>          1.0          -1.2           1.23         -11.234         111.235     -12,345.67</p><p>or:</p><p>          1,0           1,2-           1,23          11,23-         111,235      12.345,67-</p><p>or:</p><p>          1,0          (1,2)           1,23         (11,23)         111,235     (12&apos;345,67)</p><p>or whatever else the current locale indicated was the correct local layout for numbers.</p><p>That is, when the \*(C`locale\*(C' option is specified, \*(C`form\*(C' ignores the actual decimal point, thousands separator, and negation sign we specified in the call, and instead uses the values for these markers that are returned by the \s-1POSIX\s0 \*(C`localeconv\*(C' function. That means that we can specify our numerical formatting in a style that seems natural to us, and at the same time allow the numbers to be formatted in a style that seems natural to the user.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Currency fields</h2>
        <div class="sectioncontent">
<p>Formatting numbers gets even trickier when those numbers represent money. But \*(C`form\*(C' simply lets us specify how the local currency looks E&lt;ndash&gt; including leading, trailing, or infix currency markers; leading, trailing, or circumfix negation markers; thousands separators; etc. E&lt;ndash&gt; and then it formats it that way. For example:</p><p>    my @amounts = (0, 1, 1.2345, 1234.56, -1234.56, 1234567.89);</p><p>    my %format = (         "Canadian (English)"    =&gt; q/   {-$],]]],]]].[}/,         "Canadian (French)"     =&gt; q/    {-] ]]] ]]],[ $}/,         "Dutch"                 =&gt; q/     {],]]],]]].[-EUR}/,         "German (pre-euro)"     =&gt; q/    {-].]]].]]],[DM}/,         "Indian"                =&gt; q/    {-]],]],]]].[ Rs}/,         "Norwegian"             =&gt; q/ {kr -].]]].]]],[}/,         "Portuguese (pre-euro)" =&gt; q/    {-].]]].]]]$[ Esc}/,         "Swiss"                 =&gt; q/{Sfr -]&apos;]]]&apos;]]].[}/,     );</p><p>    for my $nationality (keys %format) {                 my $layout = $format{$nationality};         print form "$nationality:",                    "    $layout",                         &#92;@amounts,                    "&#92;n";     }</p><p>produces:</p><p>    Swiss:                   Sfr 0.0                   Sfr 1.0                   Sfr 1.23               Sfr 1&apos;234.56              Sfr -1&apos;234.56           Sfr 1&apos;234&apos;567.89</p><p>    Canadian (French):                       0,0 $                       1,0 $                       1,23 $                   1 234,56 $                  -1 234,56 $               1 234 567,89 $</p><p>    Dutch:                       0.0EUR                       1.0EUR                       1.23EUR                   1,234.56EUR                   1,234.56-EUR               1,234,567.89EUR</p><p>    Norwegian:                    kr 0,0                    kr 1,0                    kr 1,23                kr 1.234,56               kr -1.234,56            kr 1.234.567,89</p><p>    German (pre-euro):                       0,0DM                       1,0DM                       1,23DM                   1.234,56DM                  -1.234,56DM               1.234.567,89DM</p><p>    Indian:                       0.0 Rs                       1.0 Rs                       1.23 Rs                   1,234.56 Rs                  -1,234.56 Rs               12,34,567.89 Rs</p><p>    Portuguese (pre-euro):                       0$0 Esc                       1$0 Esc                       1$23 Esc                   1.234$56 Esc                  -1.234$56 Esc               1.234.567$89 Esc</p><p>    Canadian (English):                      $0.0                      $1.0                      $1.23                  $1,234.56                 -$1,234.56              $1,234,567.89</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Verbatim fields</h2>
        <div class="sectioncontent">
<p>Sometimes all we want is an existing block of data laid out into columns E&lt;ndash&gt; without any fancy reformatting or rejustification. For example, suppose we have an interesting string like this:</p><p>    $diagram = &lt;&lt;EODNA;        G==C          A==T            T=A            A=T          T==A        G===C       T==A      C=G     TA     AT      A=T       T==A         G===C           T==A     EODNA</p><p>and we'd like to put beside some other text. Because it's already carefully formatted, we really don't want to interpolate it into a left-justified field:</p><p>    print form         &apos;{[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]}       {[[[[[[[[[[[[[[[}&apos;,          $diatribe,                                        $diagram;</p><p>Because that would squash our lovely helix:</p><p>    Men at  some  time  are  masters  of  their       G==C     fates: / the fault, dear Brutus, is not  in       A==T     our genes, / but in ourselves, that we  are       T=A     underlings.  /  Brutus  and  Caesar:   what       A=T     should be in that &apos;Caesar&apos;?  /  Why  should       T==A     that DNA be sequenced more  than  yours?  /       G===C     Extract them together, yours is as  fair  a       T==A     genome; / transcribe them, it  doth  become       C=G     mRNA as well; / recombine them,  it  is  as       TA     long; clone with &apos;em, / Brutus will start a       AT     twin as soon as Caesar. / Now, in the names       A=T     of all  the  gods  at  once,  /  upon  what       T==A     proteins doth our Caesar feed, / that he is       G===C     grown so great?                                   T==A</p><p>Nor would right-, full-, centre- or numeric- justification help in this instance. What we really need is \*(L"leave-it-the-hell-alone\*(R" justification E&lt;ndash&gt; a field specifier that lays out the data exactly as it is, leading whitespace included.</p><p>And that's the purpose of a <em>verbatim field</em>. A verbatim single-line field (\*(C`{'''''''''}\*(C') grabs the next line of data it's offered and inserts as much of it as will fit in the field's width, preserving whitespace \*(L"as is\*(R". Likewise a verbatim block field (\*(C`{"""""""""}\*(C') grabs every line of the data it's offered and interpolates it into the text without any reformatting or justification.</p><p>And that's precisely what we needed for our diagram:</p><p>    print form         &apos;{[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]}       {"""""""""""""""}&apos;,          $diatribe,                                        $diagram;</p><p>to produce:</p><p>    Men at  some  time  are  masters  of  their          G==C     fates: / the fault, dear Brutus, is not  in            A==T     our genes, / but in ourselves, that we  are              T=A     underlings.  /  Brutus  and  Caesar:   what              A=T     should be in that &apos;Caesar&apos;?  /  Why  should            T==A     that DNA be sequenced more  than  yours?  /          G===C     Extract them together, yours is as  fair  a         T==A     genome; / transcribe them, it  doth  become        C=G     mRNA as well; / recombine them,  it  is  as       TA     long; clone with &apos;em, / Brutus will start a       AT     twin as soon as Caesar. / Now, in the names        A=T     of all  the  gods  at  once,  /  upon  what         T==A     proteins doth our Caesar feed, / that he is           G===C     grown so great?                                         T==A</p><p>Note that, unlike other types of fields, verbatim fields don't break and wrap their data if that data doesn't fit on a single line. Instead, they truncate each line to the appropriate field width. So a too-short verbatim field:</p><p>    print form         &apos;{[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]}       {""""""}&apos;,          $diatribe,                                        $diagram;</p><p>results in gene slicing:</p><p>    Men at  some  time  are  masters  of  their          G==C     fates: / the fault, dear Brutus, is not  in            A==     our genes, / but in ourselves, that we  are              T     underlings.  /  Brutus  and  Caesar:   what              A     should be in that &apos;Caesar&apos;?  /  Why  should            T==     that DNA be sequenced more  than  yours?  /          G===C     Extract them together, yours is as  fair  a         T==A     genome; / transcribe them, it  doth  become        C=G     mRNA as well; / recombine them,  it  is  as       TA     long; clone with &apos;em, / Brutus will start a       AT     twin as soon as Caesar. / Now, in the names        A=T     of all  the  gods  at  once,  /  upon  what         T==A     proteins doth our Caesar feed, / that he is           G===     grown so great?                                         T=</p><p>rather than teratogenesis:</p><p>    Men at  some  time  are  masters  of  their          G==C     fates: / the fault, dear Brutus, is not  in            A=-     our genes, / but in ourselves, that we  are       =T     underlings.  /  Brutus  and  Caesar:   what              -     should be in that &apos;Caesar&apos;?  /  Why  should       T=A     that DNA be sequenced more  than  yours?  /              -     Extract them together, yours is as  fair  a       A=T     genome; / transcribe them, it  doth  become            T=-     mRNA as well; / recombine them,  it  is  as       =A     long; clone with &apos;em, / Brutus will start a          G===C     twin as soon as Caesar. / Now, in the names         T==A     of all  the  gods  at  once,  /  upon  what        C=G     proteins doth our Caesar feed, / that he is       TA     grown so great?                                  AT                                                    A=T                                                     T==A                                                       G==-                                                   =C                                                         T-                                                   ==A</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Overflow fields</h2>
        <div class="sectioncontent">
<p>It's not uncommon for a report to need a series of data fields in one column and then a second column with only single field, perhaps containing a summary or discussion of the other data. For example, we might want to produce recipes of the form:</p><p>    =================[  Hecate&apos;s Broth of Ambition  ]=================</p><p>      Preparation time:             Method:          66.6 minutes                  Remove the legs from the                                        lizard, the wings from the       Serves:                          owlet, and the tongue of the          2 doomed souls                adder. Set them aside.                                        Refrigerate the remains (they       Ingredients:                     can be used to make a lovely          2 snakes (1 fenny, 1          white-meat stock). Drain the          adder)                        newts&apos; eyes if using pickled.          2 lizards (1 legless,         Wrap the toad toes in the          1 regular)                    bat&apos;s wool and immerse in half          3 eyes of newt (fresh         a pint of vegan stock in          or pickled)                   bottom of a preheated          2 toad toes (canned           cauldron. (If you can&apos;t get a          are fine)                     fresh vegan for the stock, a          2 cups of bat&apos;s wool          cup of boiling water poured          1 dog tongue                  over a vegetarian holding a          1 common or spotted           sprouted onion will do). Toss          owlet                         in the fenny snake, then the                                        legless lizard. Puree the                                        tongues together and fold                                        gradually into the mixture,                                        stirring widdershins at all                                        times.  Allow to bubble for 45                                        minutes then decant into two                                        tarnished copper chalices.                                        Garnish each with an owlet                                        wing, and serve immediately.</p><p>There are several ways to achieve that effect. The most obvious is to format each column separately and then lay them out side-by-side with a pair of verbatim fields:</p><p>    my $prep = form &apos;Preparation time:        &apos;,                     &apos;   {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}&apos;, $prep_time,                     &apos;                         &apos;,                     &apos;Serves:                  &apos;,                     &apos;   {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}&apos;, $serves,                     &apos;                         &apos;,                     &apos;Ingredients:             &apos;,                     &apos;   {[[[[[[[[[[[[[[[[[[[[}&apos;, $ingredients;</p><p>    my $make = form &apos;Method:                          &apos;,                     &apos;   {[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&apos;,                         $method;</p><p>    print form         &apos;=================[ {||||||||||||||||||||||||||} ]=================&apos;,                                       $recipe,         &apos;                                                                  &apos;,         &apos;  {"""""""""""""""""""""""}     {"""""""""""""""""""""""""""""""} &apos;,            $prep,                        $make;</p><p>We could even chain the calls to \*(C`form\*(C' to eliminate the interim variables:</p><p>    print form         &apos;=================[ {||||||||||||||||||||||||||} ]=================&apos;,                                       $recipe,         &apos;                                                                  &apos;,         &apos;  {"""""""""""""""""""""""}     {"""""""""""""""""""""""""""""""} &apos;,            form(&apos;Preparation time:        &apos;,                 &apos;   {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}&apos;, $prep_time,                 &apos;                         &apos;,                 &apos;Serves:                  &apos;,                 &apos;   {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}&apos;, $serves                 &apos;                         &apos;,                 &apos;Ingredients:             &apos;,                 &apos;   {[[[[[[[[[[[[[[[[[[[[}&apos;, $ingredients,                ),            form(&apos;Method:                          &apos;,                 &apos;   {[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&apos;,                     $method,                );</p><p>While it's impressive to be able to do that kind of nested formatting (and highly useful in extreme formatting scenarios), it's also far too ungainly for regular use. A cleaner, more maintainable solution is use a single format and just build the method column up piecemeal, like so:</p><p>    print form         &apos;=================[ {||||||||||||||||||||||||||} ]=================&apos;,                                       $recipe,         &apos;                                                                  &apos;,         &apos;Preparation time:               Method:                           &apos;,         &apos;   {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}          {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;:} &apos;,             $prep_time,                     $method,         &apos;                                   {:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;:} &apos;,                                             $method,         &apos;Serves:                            {:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;:} &apos;,                                             $method,         &apos;   {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}          {:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;:} &apos;,             $serves,                        $method,         &apos;                                   {:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;:} &apos;,                                             $method,         &apos;Ingredients:                       {:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;:} &apos;,                                             $method,         &apos;   {[[[[[[[[[[[[[[[[[[[[}          {:[[[[[[[[[[[[[[[[[[[[[[[[[[[} &apos;,             $ingredients,                   $method;</p><p>That produces exactly the same result as the previous versions, because each follow-on \*(C`{:&lt;&lt;&lt;&lt;&lt;&lt;&lt;:}\*(C' field in the \*(L"Method\*(R" column grabs one extra line from $method, and then the final follow-on \*(C`{:[[[[[[}\*(C' field grabs as many more as are required to lay out the rest of the contents of the variable. The only down-side is that the resulting code is still downright ugly. With all those tedious repetitions of the same variable, there's far too much $method in our madness.</p><p>Having a series of follow-on fields like this E&lt;ndash&gt; vertically continuing a single column across subsequent format lines E&lt;ndash&gt; is so common that \*(C`form\*(C' provides a special shortcut: the \*(C`{VVVVVVVVV}\*(C' <em>overflow field</em>.</p><p>An overflow field automagically duplicates the field specification immediately above it. The important point being that, because that duplication includes copying the preceding field's data source, overflow fields don't require a separate data source of their own.</p><p>Using overflow fields, we could rewrite our quotation generator like this:</p><p>    print form         &apos;=================[ {||||||||||||||||||||||||||} ]=================&apos;,                                       $recipe,         &apos;                                                                  &apos;,         &apos;Preparation time:               Method:                           &apos;,         &apos;   {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}          {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;} &apos;,             $prep_time,                     $method,         &apos;                                   {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &apos;,         &apos;Serves:                            {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &apos;,         &apos;   {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}          {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &apos;,             $serves,         &apos;                                   {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &apos;,         &apos;Ingredients:                       {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &apos;,         &apos;   {[[[[[[[[[[[[[[[[[[[[}          {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &apos;,             $ingredients,         &apos;                                   {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &apos;;</p><p>Which would once again produce the recipe shown earlier.</p><p>Note that the overflow fields interact equally well in formats with single-line and block fields. That's because block overflow fields have one other special feature: they're non-greedy. Unless we specify otherwise, all types of block fields will consume their entire data source. For example, if we wrote:</p><p>    print form {layout=&gt;"across"},          &apos;{&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;:}&apos;,                                   $speech,          &apos;{:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;:}&apos;,                                   $speech,          &apos;{:[[[[[]]]]]:}   {="""""""""""""""""""=}   {:[[[[[]]]]]]:}&apos;,              $speech,             $advert,              $speech,          &apos;{:[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]}&apos;,                                   $speech;</p><p>we'd get:</p><p>    Now is the winter of our discontent / Made glorious summer     by this sun of York; / And all the clouds that lour&apos;d upon     our house / In                             the deep  bosom     of  the  ocean                             buried.  /  Now     are our  brows                             bound      with     victorious                                 wreaths; /  Our     bruised   arms                             hung   up   for     monuments;   /                             Our       stern     alarums          +---------------------+   changed      to     merry            |                     |   meetings, / Our     dreadful         | Eat at Mrs Miggins! |   marches      to     delightful       |                     |   measures. Grim-     visaged    war   +---------------------+   hath   smooth&apos;d     his   wrinkled                             front;  /   And     now,   instead                             of     mounting     barded  steeds                             / To fright the     souls       of                             fearful     adversaries, /                             He       capers     nimbly  in   a                             lady&apos;s chamber.</p><p>That's because the two \*(C`{:[[[[[]]]]]:}\*(C' block fields on either side of the verbatim advertisement field will eat all the data in $speech, leaving nothing for the final format. Then the advertisement will be centred on the two resulting columns of text.</p><p>But, block overflow fields are different. They only take as many lines as are required to fill the lines generated by the non-overflow fields in their format. So, if we changed our code to use overflows:</p><p>    print form {layout=&gt;"across"},          &apos;{&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;}&apos;, $speech,          &apos;{VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&apos;,          &apos;{VVVVVVVVVVVV}   {="""""""""""""""""""=}   {VVVVVVVVVVVVV}&apos;, $advert,          &apos;{VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&apos;;</p><p>we get both a cleaner specification and a more elegant result:</p><p>    Now is the winter of our discontent / Made glorious summer     by this sun of York; / And all the clouds that lour&apos;d upon     our house / In                             the deep  bosom     of  the  ocean   +---------------------+   buried.  /  Now     are our  brows   |                     |   bound      with     victorious       | Eat at Mrs Miggins! |   wreaths; /  Our     bruised   arms   |                     |   hung   up   for     monuments;   /   +---------------------+   Our       stern     alarums                                    changed      to     merry meetings,  /  Our  dreadful  marches  to  delightful     measures. Grim-visaged  war  hath  smooth&apos;d  his  wrinkled     front; / And now, instead of mounting barded steeds  /  To     fright the souls  of  fearful  adversaries,  /  He  capers     nimbly in a lady&apos;s chamber.</p><p>Notice that, in the third format line of the previous example, the two overflow fields on either side of the advertisement are each overflowing from the single field that's above both of them. This kind of multiple overflow is fine, but it does require that we specify <em>how</em> the various fields overflow (i.e. as two separate columns of text, or E&lt;ndash&gt; as in this case E&lt;ndash&gt; as a single, broken column across the page). That's the purpose of the \*(C`layout\*(C' option on the first line. This option is explained in detail below.</p><p>The \*(C`{VVVVVVVV}\*(C' fields only consumed as much data from $speech as was required to sandwich the output lines created by the verbatim advertisement. This feature is important, because it means we can lay out a series of block fields in one column and a single overflowed field in another column without introducing ugly gaps. For example, because the \*(C`{VVVVVVVVV}\*(C' fields in:</p><p>    print form         "Name:                                                  ",         "  {[[[[[[[[[[[[}                                       ", $name,         "                  Biography:                           ",         "Status:             {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}", $bio,         "  {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}", $status,         "                    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",         "Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",         "  {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}", $comments;</p><p>only consume as much of the overflowing $bio field as necessary, the result is something like:</p><p>    Name:       William       Shakespeare                       Biography:     Status:             William Shakespeare was born on       Deceased (1564    April 23, 1564 in Strathford-upon-       -1616)            Avon, England; he was third of                         eight children from Father John     Comments:           Shakespeare and Mother Mary Arden.       Theories          Shakespeare began his education at       abound as to      the age of seven when he probably       the true          attended the Strathford grammar       author of his     school. The school provided       plays. The        Shakespeare with his formal       prime             education. The students chiefly       alternative       studied Latin rhetoric, logic, and       candidates        literature. His knowledge and       being Sir         imagination may have come from his       Francis           reading of ancient authors and       Bacon,            poetry. In November 1582,       Christopher       Shakespeare received a license to       Marlowe, or       marry Anne Hathaway. At the time of       Edward de         their marriage, Shakespeare was 18       Vere              years old and Anne was 26. They had                         three children, the oldest Susanna,                         and twins- a boy, Hamneth, and a                         girl, Judith. Before his death on                         April 23 1616, William Shakespeare                         had written thirty-seven plays. He                         is generally considered the                         greatest playwright the world has                         ever known and has always been the                         world&apos;s most popular author.</p><p>If \*(C`{VVVVVVVVVVV}\*(C' fields ate their entire data E&lt;ndash&gt; the way \*(C`{[[[[[[[[[}\*(C' or \*(C`{IIIIIIIIII}\*(C' fields do E&lt;ndash&gt; then the output would be much less satisfactory. The first block overflow field for $bio would have to consume the entire biography, before the comments field was even reached. So our output would be something like:</p><p>    Name:       William       Shakespeare                       Biography:     Status:             William Shakespeare was born on       Deceased (1564    April 23, 1564 in Strathford-upon-       -1616)            Avon, England; he was third of                         eight children from Father John                         Shakespeare and Mother Mary Arden.                         Shakespeare began his education at                         the age of seven when he probably                         attended the Strathford grammar                         school. The school provided                         Shakespeare with his formal                         education. The students chiefly                         studied Latin rhetoric, logic, and                         literature. His knowledge and                         imagination may have come from his                         reading of ancient authors and                         poetry. In November 1582,                         Shakespeare received a license to                         marry Anne Hathaway. At the time of                         their marriage, Shakespeare was 18                         years old and Anne was 26. They had                         three children, the oldest Susanna,                         and twins- a boy, Hamneth, and a                         girl, Judith. Before his death on                         April 23 1616, William Shakespeare                         had written thirty-seven plays. He                         is generally considered the                         greatest playwright the world has                         ever known and has always been the                         world&apos;s most popular author.</p><p>    Comments:       Theories       abound as to       the true       author of his       plays. The       prime       alternative       candidates       being Sir       Francis       Bacon,       Christopher       Marlowe, or       Edward de       Vere</p><p>Which is precisely why \*(C`{VVVVVVVVVVV}\*(C' fields don't work that way. Whenever a field is passed more data than it can accommodate in a single line, \*(C`form\*(C' is forced to \*(L"break\*(R" that data somewhere.</p><p>If the field in question is <em>W</em> columns wide, \*(C`form\*(C' first squeezes any whitespace (as specified by the user's \*(C`ws\*(C' option) and then looks at the next <em>W</em> columns of the string.</p><p>\*(C`form\*(C''s breaking algorithm then searches for a newline, a carriage return, any other whitespace character, or a hyphen. If it finds a newline or carriage return within the first <em>W</em> columns, it immediately breaks the data string at that point. Otherwise it locates the <em>last</em> whitespace or hyphen in the first <em>W</em> columns and breaks the string immediately after that space or hyphen. If it can't find anywhere suitable to break the string, it breaks it at the (<em>W</em>-1)th column and appends a hyphen.</p><p>So, for example:</p><p>    $data = "You can play no part but Pyramus;&#92;nfor Pyramus is a sweet-faced man";</p><p>    print form "|{[[[[[}|",                  $data;</p><p>prints:</p><p>    |You can|     |play no|     |part   |     |but    |     |Pyramu-|     |s;     |     |for    |     |Pyramus|     |is a   |     |sweet- |     |faced  |     |man    |</p><p>Note the line-breaks after <em>can</em> (at a whitespace), <em>part</em> (after a whitespace), <em>sweet-</em> (after a hyphen), and <em>s;</em> (at a newline). Note too that <em>Pyramus;</em> doesn't fit in the field, so it has to be chopped in two and a hyphen inserted.</p><p>Of course, this particular style of line-breaking may not be suitable to all applications, and we might prefer that \*(C`form\*(C' use some other algorithm. For example, if \*(C`form\*(C' used the TeX breaking algorithm it would have broken <em>Pyramus;</em> less clumsily, yielding:</p><p>    |You can|     |play no|     |part   |     |but    |     |Pyra-  |     |mus;   |     |for    |     |Pyramus|     |is a   |     |sweet- |     |faced  |     |man    |</p><p>To support different line-breaking strategies \*(C`form\*(C' provides the \*(C`break\*(C' option.  The \*(C`break\*(C' option's value must be a closure/subroutine, which will then be called whenever a data string needs to be broken to fit a particular field width.</p><p>That subroutine is passed three arguments: a reference to the data string itself, an integer specifying how wide the field is, and a regex indicating which (if any) characters are to be squeezed. It is expected to return a list of two values: a string which is taken as the \*(L"broken\*(R" text for the field, and a boolean value indicating whether or not any data remains after the break (so \*(C`form\*(C' knows when to stop breaking the data string). The subroutine is also expected to update the \*(C`.pos\*(C' of the data string to point immediately after the break it has imposed.</p><p>For example, if we always wanted to break at the exact width of the field (with no hyphens), we could do that with:</p><p>    sub break_width {                 my ($data_ref, $width, $ws) = @_;         for ($$data_ref) {             # Treat any squeezed or vertical whitespace as a single character             # (since they&apos;ll subsequently be squeezed to a single space)             my $single_char = qr{ $ws | [&#92;n&#92;r]+ | . }</p><p>            # Give up if there are no more characters to grab...             return ("", 0) unless m/&#92;G (single_char{1,$width}) /gcx;</p><p>            # Squeeze the resultant substring...             (my $result = $1) =~ s/ $ws | [&#92;n&#92;r] / /gx;</p><p>            # Check for any more data still to come...             my $more = m/&#92;G (?= .* &#92;S) /gcx;</p><p>            # Return the squeezed substring and the "more" indicator...             return ($result, $more);         }     }</p><p>    print form         {break=&gt;&#92;&break_width},         "|{[[[[[}|",           $data;</p><p>producing:</p><p>    |You can|     |play no|     |part bu|     |t Pyram|     |us; for|     |Pyramus|     |is a sw|     |eet-fac|     |ed man |</p><p>Or we might prefer to break on every single whitespace-separated word:</p><p>    sub break_word {                 my ($data_ref, $width, $ws) = @_;         for ($$data_ref) {             # Locate the next word (no longer than $width cols)             my $found = m/&#92;G &#92;s* (&#92;S{1,$width}) /gcx;</p><p>            # Fail if no more words...             return ("", 0) unless $found;                         my $word = $1;</p><p>            # Check for any more data still to come...             my bool $more = m/&#92;G (?= .* &#92;S) /gcx;</p><p>            # Otherwise, return broken text and "more" flag...             return ($word, $more);         }     }</p><p>    print form         {break=&gt;&#92;&break_word},         "|{[[[[[}|",           $data;</p><p>producing:</p><p>    |You    |     |can    |     |play   |     |no     |     |part   |     |but    |     |Pyramus|     |;      |     |for    |     |Pyramus|     |is     |     |a      |     |sweet-f|     |aced   |     |man    |</p><p>We'll see yet another application of user-defined breaking when we discuss user-defined fields. There are (at least) three schools of thought when it comes to setting out a call to \*(C`form\*(C' that uses more than one format. The \*(L"traditional\*(R" way (i.e. the way Perl 5 formats do it) is to interleave each format string with a line containing the data it is to interpolate, with each datum aligned directly under the field into which it is to be fitted. Like so:</p><p>    print form         "Name:                                                  ",         "  {[[[[[[[[[[[[}                                       ",            $name,         "                  Biography:                           ",         "Status:             {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}",                              $bio,         "  {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",            $status,         "                    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",         "Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",         "  {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",            $comments;</p><p>This approach has the advantage that it self-documents: to know what a particular field is supposed to contain, we merely need to look down one line.</p><p>It does, however, break up the \*(L"abstract picture\*(R" that the formats portray, which can make it more difficult to envisage what the final formatted text will look like. So some people prefer to put all the data to the right of the formats:</p><p>    print form         "Name:                                                  ",         "  {[[[[[[[[[[[[}                                       ", $name,         "                  Biography:                           ",         "Status:             {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}", $bio,         "  {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}", $status,         "                    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",         "Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",         "  {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}", $comments;</p><p>And that's perfectly acceptable too.</p><p>Sometimes, however, the data to be interpolated doesn't come neatly pre-packaged in separate variables that are easy to intersperse between the formats. For example, the data might be a list returned by a subroutine call (\*(C`get_info($next_person)\*(C') or might be stored in a hash (&nbsp;@person{qw(&nbsp;name&nbsp;biog&nbsp;stat&nbsp;comm&nbsp;)}&nbsp;). In such cases it's a nuisance to have to tease that data out into separate variables (or hash accesses) and then sprinkle them through the formats:</p><p>    print form         "Name:                                                  ",         "  {[[[[[[[[[[[[}                                       ",$person{name},         "                  Biography:                           ",         "Status:             {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}",$person{biog},         "  {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",$person{stat},         "                    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",         "Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",         "  {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}",$person{comm};</p><p>So \*(C`form\*(C' has an option that lets us put a single, multi-line format at the start of the argument list, place all the data together after it, and have that data automatically interleaved as necessary. Not surprisingly, that option is: \*(C`interleave\*(C'. It's normally used in conjunction with a heredoc, since that's the easiest way to specify a multi-line string in Perl:</p><p>    print form {interleave=&gt;1}, &lt;&lt;&apos;EOFORMAT&apos;,         Name:           {[[[[[[[[[[[[}                                           Biography:         Status:             {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}           {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}                                             {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}           {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         EOFORMAT          @person{qw( name biog stat comm )};</p><p>When \*(C`interleave\*(C' is in effect, \*(C`form\*(C' grabs the first string argument it's passed and breaks that argument up into individual lines. It treats those individual lines as a series of distinct formats and grabs as many of the remaining arguments as are required to provide data for each format. It's important to point out that, even when we're using \*(C`form\*(C''s default <strong>non</strong>-interleaving behaviour, it's still okay to use a format that spans multiple lines. There <em>is</em> however a significant (and useful) difference in behaviour between the two alternatives.</p><p>The normal behaviour of \*(C`form\*(C' is to take each format string, fill in each field in the format with a substring from the corresponding data source, and then repeat that process until all the data sources have been exhausted. Which means that a multi-line format like this:</p><p>    print form          &lt;&lt;&apos;EOFORMAT&apos;,         Name:    {[[[[[[[[[[[[[[[}   Role: {[[[[[[[[[[}         Address: {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}         _______________________________________________         EOFORMAT          @names, @roles, @addresses;</p><p>would normally produce this:</p><p>    Name:    King Lear           Role: Protagonist     Address: The Cliffs, Dover     _______________________________________________     Name:    The Three Witches   Role: Plot devices     Address: Dismal Forest, Scotland     _______________________________________________     Name:    Iago                Role: Villain     Address: Casa d&apos;Otello, Venezia     _______________________________________________</p><p>because the entire three-line format is repeatedly filled in as a single unit, line-by-line and datum-by-datum.</p><p>On the other hand, if we tell \*(C`form\*(C' that it's supposed to automatically interleave the data coming after the format, like so:</p><p>    print form {interleave=&gt;1},          &lt;&lt;&apos;EOFORMAT&apos;,         Name:    {[[[[[[[[[[[[[[[}   Role: {[[[[[[[[[[}         Address: {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}         _______________________________________________         EOFORMAT          @names, @roles, @addresses;</p><p>then the call produces:</p><p>    Name:    King Lear           Role: Protagonist     Name:    The Three Witches   Role: Plot devices     Name:    Iago                Role: Villain     Address: The Cliffs, Dover     Address: Dismal Forest, Scotland     Address: Casa d&apos;Otello, Venezia     _______________________________________________</p><p>because that second version is really equivalent to:</p><p>    print form          "Name:    {[[[[[[[[[[[[[[[}   Role: {[[[[[[[[[[}",                    @names,                   @roles,          "Address: {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}",                    @addresses,          "_______________________________________________";</p><p>That's not much use in this particular example, but it was exactly what was needed for the biography example earlier. It's just a matter of choosing the right type of data placement to achieve the particular effect we want. As we saw earlier, with follow-on fields and overflow fields, \*(C`form\*(C' is perfectly happy to have several fields in a single format that are all fed by the same data source. For example:</p><p>    print form         "{[[[[[[[[]]]]]]]]]]:}   {:[[[[[[[]]]]]]]]]]:}   {:[[[[[[[[]]]]]]]]]]}",              $soliloquy,             $soliloquy,              $soliloquy;</p><p>In fact, that kind of format is particularly useful for creating multi-column outputs (like newspaper columns, for example).</p><p>But a small quandry arises. In what order should \*(C`form\*(C' fill in these fields? Should the data be formatted down the page, filling each column completely before starting the next (and therefore potentially leaving the last column \*(L"short\*(R"):</p><p>    Now is the winter  of   torious  wreaths;   /   front; / And now, in-     our discontent / Made   Our bruised arms hung   stead of mounting ba-     glorious  summer   by   up for  monuments;  /   rded steeds / To fri-     this sun of  York;  /   Our stern alarums ch-   ght the souls of fea-     And  all  the  clouds   anged to merry meeti-   rful  adversaries,  /     that lour&apos;d upon  our   ngs, /  Our  dreadful   He capers nimbly in a     house / In  the  deep   marches to delightful   lady&apos;s chamber.     bosom  of  the  ocean   measures.   /   Grim-     buried. / Now are our   visaged war hath smo-     brows bound with vic-   oth&apos;d  his   wrinkled</p><p>Or should the data be run line-by-line across all three columns (the way a Perl 5 \*(C`format\*(C' does it), filling one line completely before starting the next:</p><p>    Now is the winter  of   our discontent / Made   glorious  summer   by     this sun of  York;  /   And  all  the  clouds   that lour&apos;d upon  our     house / In  the  deep   bosom  of  the  ocean   buried. / Now are our     brows bound with vic-   torious  wreaths;   /   Our bruised arms hung     up for  monuments;  /   Our stern alarums ch-   anged to merry meeti-     ngs, /  Our  dreadful   marches to delightful   measures.   /   Grim-     visaged war hath smo-   oth&apos;d  his   wrinkled   front; / And now, in-     stead of mounting ba-   rded steeds / To fri-   ght the souls of fea-     rful  adversaries,  /   He capers nimbly in a   lady&apos;s chamber.</p><p>Or should the text run down the columns, but in such a way as to leave those columns as evenly balanced in length as possible:</p><p>    Now is the winter  of   brows bound with vic-   visaged war hath smo-     our discontent / Made   torious  wreaths;   /   oth&apos;d  his   wrinkled     glorious  summer   by   Our bruised arms hung   front; / And now, in-     this sun of  York;  /   up for  monuments;  /   stead of mounting ba-     And  all  the  clouds   Our stern alarums ch-   rded steeds / To fri-     that lour&apos;d upon  our   anged to merry meeti-   ght the souls of fea-     house / In  the  deep   ngs, /  Our  dreadful   rful  adversaries,  /     bosom  of  the  ocean   marches to delightful   He capers nimbly in a     buried. / Now are our   measures.   /   Grim-   lady&apos;s chamber.</p><p>Well, of course, there's no \*(L"right\*(R" answer to that; it depends entirely on what kind of effect we're trying to achieve.</p><p>The first approach (i.e. lay out the text down each column first) works well if we're formatting a news-column, or a report, or a description of some kind. The second (i.e. lay out the text across each line first), is excellent for putting diagrams or call-outs in the middle of a piece of text (as we did for Mrs Miggins). The third approach (i.e. lay out the data downwards but balance the columns) is best for presenting a single list of data in multiple columns E&lt;ndash&gt; like \*(C`ls\*(C' does.</p><p>So we need an option with which to tell \*(C`form\*(C' which of these useful alternatives we want for a particular format. That option is named \*(C`layout\*(C' and can take one of three string values: "down", "across", or "balanced". So, for example, to produce three versions of Richard \s-1III\s0's famous monologue in the order shown above, we'd use:</p><p>    print form {layout=&gt;"down"},         "{[[[[[[[[]]]]]]]]]]:}   {:[[[[[[[]]]]]]]]]]:}   {:[[[[[[[[]]]]]]]]]]}",              $soliloquy,             $soliloquy,              $soliloquy;</p><p>then:</p><p>    print form {layout=&gt;"across"},         "{[[[[[[[[]]]]]]]]]]:}   {:[[[[[[[]]]]]]]]]]:}   {:[[[[[[[[]]]]]]]]]]}",              $soliloquy,             $soliloquy,              $soliloquy;</p><p>then:</p><p>    print form {layout=&gt;"balanced"},         "{[[[[[[[[]]]]]]]]]]:}   {:[[[[[[[]]]]]]]]]]:}   {:[[[[[[[[]]]]]]]]]]}",              $soliloquy,             $soliloquy,              $soliloquy;</p><p>By the way, the default value for the \*(C`layout\*(C' option is "balanced" since formatting regular columns of data is more common than formatting news or advertising inserts. The \*(C`layout\*(C' option controls one other form of inter-column formatting: tabular layout.</p><p>So far, all the examples of tables we've created (for example, our normalized scores) lined up nicely. But that was only because each item in each row happened to take the same number of lines (typically just one). So, a table generator like this:</p><p>    my @play = map {"$_&#92;r"}  ( "Othello", "Richard III", "Hamlet"   );     my @name = map {"$_&#92;r"}  ( "Iago",    "Henry",       "Claudius" );</p><p>    print form          "Character       Appears in  ",          "____________    ____________",          "{[[[[[[[[[[}    {[[[[[[[[[[}",           &#92;@name,          &#92;@play;</p><p>correctly produces:</p><p>    Character       Appears in     ____________    ____________     Iago            Othello</p><p>    Henry           Richard III</p><p>    Claudius        Hamlet</p><p>Note that we appended "&#92;r" to each element to add an extra newline after each entry in the table. We can't use "&#92;n" to specify a line-break within an array element, because \*(C`form\*(C' uses "&#92;n" as an \*(L"end-of-element\*(R" marker. So, to allow line breaks within a single element of an array datum, \*(C`form\*(C' treats "&#92;r" as \*(L"end-of-line-but-not-end-of-element\*(R" (somewhat like Perl 5's \*(C`format\*(C' does).</p><p>However, if we were to use the full titles for each character and each play:</p><p>    my @play = map {"$_&#92;r"}  ( "Othello, The Moor of Venice",                                "The Life and Death of King Richard III",                                "Hamlet, Prince of Denmark",                              );</p><p>    my @name = map {"$_&#92;r"}  ( "Iago",                                "Henry,&#92;rEarl of Richmond",                                "Claudius,&#92;rKing of Denmark",                              );</p><p>the same formatter would produce:</p><p>    Character       Appears in     ____________    ____________     Iago            Othello, The                     Moor of     Henry,          Venice     Earl of     Richmond        The Life and                     Death of     Claudius,       King Richard     King of         III     Denmark                     Hamlet,                     Prince of                     Denmark</p><p>The problem is that the two block fields we're using just grab all the data from each array and format it independently into each column. Usually that's fine because the columns <em>are</em> independent (as we've previously seen).</p><p>But in a table, the data in each column specifically relates to data in other columns, so corresponding elements from the column's data arrays ought to remain vertically aligned. To achieve this, we simply tell \*(C`form\*(C' that the data in the various columns should be laid out like a table:</p><p>    print form {layout=&gt;"tabular"},          "Character       Appears in  ",          "____________    ____________",          "{[[[[[[[[[[}    {[[[[[[[[[[}",           &#92;@name,         &#92;@play;</p><p>which then produces the desired result:</p><p>    Character       Appears in     ____________    ____________     Iago            Othello, The                     Moor of                     Venice</p><p>    Henry,          The Life and     Earl of         Death of     Richmond        King Richard                     III</p><p>    Claudius,       Hamlet,     King of         Prince of     Denmark         Denmark</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Give him line and scope...</h2>
        <div class="sectioncontent">
<p>Sometimes we want to use a particular option or combination of options in every call we make to \*(C`form\*(C'. Or, more likely, in every call we make within a specific scope.  For example, we might wish to default to a different line-breaking algorithm everywhere, or we might want to make repeated use of a new type of field specifier, or we might want to reset the standard page length from a printable 60 to a screenable 24.</p><p>So the Perl6::Form module provides a mechanism by which options can be prebound. To use it, we (re-)load the module with an explicit argument list:</p><p>    use Form { layout=&gt;"down", locale=&gt;1, interleave=&gt;1 };</p><p>This causes the module to export a modified version of \*(C`form\*(C' in which the specified options are prebound.  That modified version of \*(C`form\*(C' takes effect from the line following the \*(C`use\*(C' statement, until the end of the current package (or another \*(C`use Perl6::Form\*(C' statement). The effect is <strong>not</strong> truly lexical (as it would be in Perl 6).</p><p>These default options are handy if we have a series of calls to \*(C`form\*(C' that all need some consistent non-standard behaviour. For example:</p><p>    use Form { layout=&gt;"across",                interleave=&gt;1,                page =&gt; { header =&gt; "Draft $(localtime)&#92;n&#92;n" },                          };</p><p>    print form $introduction_format, @introduction_data;</p><p>    while ($format, @data = get_next) {         print form $format, @data;     }</p><p>    print form $conclusion_format, @conclusion_data; When specific field widths are required (perhaps by some design document or data formatting protocol) laying out wide fields can be error-prone. For example, most people can't visually distinguish between a 52-column field and a 53-column field and are therefore forced to manually verify the width of the corresponding field specifier in some way.</p><p>To catch mistakes of this kind, fields can be specified with an embedded integer in parentheses (with optional whitespace inside the parens). For example:</p><p>    print form &apos;{[[[( 15 )[[[[} {&lt;&lt;&lt;&lt;&lt;(17)&lt;&lt;&lt;&lt;&lt;&lt;}  {]]](14)]]].[[}&apos;,                @data;</p><p>The integer in the parentheses acts like a checksum. Its value must be identical to the actual width of the field (including the delimiting braces and the embedded integer itself). Otherwise an exception is thrown. For instance, running the above example produces the error message:</p><p>    Inconsistent width for field 3.     Specified as &apos;{]]](14)]]].[[}&apos; but actual width is 15     in call to &form at demo.pl line 1</p><p>Numeric fields can be given a decimal checksum, which then also specifies their number of decimal places.</p><p>    print form         &apos;{[[[( 15 )[[[[} {&lt;&lt;&lt;&lt;&lt;(17)&lt;&lt;&lt;&lt;&lt;&lt;}  {]](14.2)]].[}&apos;,          @data;</p><p>Note that the digits before the decimal still indicate the total width of the field. So the \*(C`{]](14.2)]].[}\*(C' field in the above example means <em>must be 14 columns wide, including</em> 2 decimal places, in exactly the same way as a "%14.2f" specifier would in a \*(C`sprintf\*(C'. Of course, in some instances it would be much more convenient if we could simply <em>tell</em> \*(C`form\*(C' that we want a particular field to be a particular width, instead of having to explicitly <em>show</em> it.</p><p>So there's another type of integer field annotation that, instead of acting like a checksum, acts like an...err...\*(L"tellsum\*(R". That is, we can tell \*(C`form\*(C' to ignore a field's physical width and instead insist that it be magically expanded (or shrunk) to a nominated width. Such a field is said to have an <em>imperative width</em>. The integer specifying the imperative width is placed in curly braces instead of parens.</p><p>For example, the format in the previous example could be specified imperatively as:</p><p>    print form         &apos;{[{15}[} {&lt;{17}&lt;&lt;}  {]]]]{14.2}]]]].[[}&apos;,          @data;</p><p>Note that the actual width of any field becomes irrelevant if it contains an imperative width. The field will be condensed or expanded to the specified width, with subsequent fields pushed left or right accordingly. A special form of imperative width field is the <em>starred field</em>. A starred field is one that contains an imperative width specification in which the number is replaced by a single asterisk.</p><p>The width of a starred field is not fixed, but rather is <em>computed</em> during formatting. That width is whatever is required to cause the entire format to fill the current page width of the format (by default, 78 columns). Consider, for example:</p><p>    print form         &apos;{]]]]]]]]]]]]]]} {]]].[[}  {[[{*}[[}  &apos;,          &#92;@names,         &#92;@scores, &#92;@comments;</p><p>The width of the starred comment field in this case is 49 columns E&lt;ndash&gt; the default page width of 78 columns minus the 29 columns consumed by the fixed-width portions of the format (including the other two fields).</p><p>If a format contains two or more starred fields, the available space is shared equally between them. So, for example, to create two equal columns (say, to compare the contents of two files), we might use:</p><p>        use Perl6::Slurp;</p><p>    print form          "{[[[[{*}[[[[}   {[[[[{*}[[[[}",           slurp($file1),  slurp($file2);</p><p>(And, yes, Perl 6 does have a built-in \*(C`slurp\*(C' function that takes a filename, opens the file, reads in the entire contents, and returns them as a single string. For more details see the Perl6::Slurp module E&lt;ndash&gt; now on the \s-1CPAN\s0.)</p><p>There is one special case for starred fields: a starred verbatim field:</p><p>    {""""{*}""""}</p><p>It acts like any other starred field, growing according to the available space, except that it will never grow any wider than the widest line of the data it is formatting. For example, whereas a regular starred field:</p><p>    print form          &apos;| {[[{*}[[} |&apos;,             $monologue;</p><p>expands to the full page width:</p><p>    | Now is the winter of our discontent                           |     | Made glorious summer by this sun of York;                     |     | And all the clouds that lour&apos;d upon our house                 |     | In the deep bosom of the ocean buried.                        |     | Now are our brows bound with victorious wreaths               |     | Our bruised arms hung up for monuments;                       |     | Our stern alarums changed to merry meetings,                  |     | Our dreadful marches to delightful measures.                  |     | Grim-visaged war hath smooth&apos;d his wrinkled front;            |     | And now, instead of mounting barded steeds                    |     | To fright the souls of fearful adversaries,                   |     | He capers nimbly in a lady&apos;s chamber.                         |</p><p>a starred verbatim field:</p><p>    print form          &apos;| {""{*}""} |&apos;,             $monologue;</p><p>only expands as much as is strictly necessary to accommodate the data:</p><p>    | Now is the winter of our discontent                |     | Made glorious summer by this sun of York;          |     | And all the clouds that lour&apos;d upon our house      |     | In the deep bosom of the ocean buried.             |     | Now are our brows bound with victorious wreaths;   |     | Our bruised arms hung up for monuments;            |     | Our stern alarums changed to merry meetings,       |     | Our dreadful marches to delightful measures.       |     | Grim-visaged war hath smooth&apos;d his wrinkled front; |     | And now, instead of mounting barded steeds         |     | To fright the souls of fearful adversaries,        |     | He capers nimbly in a lady&apos;s chamber.              | By now you've probably noticed that there is quite a large overlap between the functionality of \*(C`form\*(C' and that of \*(C`(s)printf\*(C'. For example, the call:</p><p>    for (@procs) {         print form             "{&gt;&gt;&gt;}  {&lt;&lt;&lt;&lt;&lt;&lt;&lt;(20)&lt;&lt;&lt;&lt;&lt;&lt;&lt;}  {&gt;&gt;&gt;&gt;&gt;&gt;}  {&gt;&gt;.}%",             $_-&gt;{pid}, $_-&gt;{cmd},         $_-&gt;{time}, $_-&gt;{cpu};     }</p><p>has approximately the same effect as the call:</p><p>    for (@procs) {         printf "%5d  %-20s  %8s  %5.1f%%&#92;n",                $_-&gt;{pid}, $_-&gt;{cmd}, $_-&gt;{time}, $_-&gt;{cpu};     }</p><p>One is more \s-1WYSIWYG\s0, the other more concise, but (placed in a suitable loop), they would both print out lines like these:</p><p>     2461  vi -ii henry           0:55.83   11.6%      2395  ex cathedra            0:06.59    3.5%      2439  head anne.boleyn       0:00.18    0.1%      2581  dig -short grave       0:01.04    0.0%</p><p>There is, however, a crucial difference between these two formatting facilities; one that only shows up when one of our processes runs over 99 hours. For example, suppose our browser has been running continuously for a few months (or, more precisely, for 1214:23.75 hours). Then the calls to \*(C`printf\*(C' would print:</p><p>     2461  vi -ii henry           0:55.83   11.6%      2395  ex cathedra            0:06.59    3.5%     27384  lynx www.divorce.com  1214:23.75    0.8%      2439  head anne.boleyn       0:00.18    0.1%      2581  dig -short grave       0:01.04    0.0%</p><p>whilst the calls to \*(C`form\*(C' would print:</p><p>     2461  vi -ii henry           0:55.83   11.6%      2395  ex cathedra            0:06.59    3.5%     27384  lynx www.divorce.com  1214:23-    0.8%      2439  head anne.boleyn       0:00.18    0.1%      2581  dig -short grave       0:01.04    0.0%</p><p>In other words, field widths in a \*(C`printf\*(C' represent <em>minimal</em> spacing (even if that throws off the overall layout), whereas field widths in a \*(C`form\*(C' represent <em>guaranteed</em> spacing (even if that truncates some of the data).</p><p>Of course, in a situation like this E&lt;ndash&gt; where we knew that the data might not fit and we didn't want it truncated E&lt;ndash&gt; we could use a block field instead:</p><p>    for (@procs) {         print form             "{&gt;&gt;&gt;}  {&lt;&lt;&lt;&lt;&lt;&lt;&lt;(19)&lt;&lt;&lt;&lt;&lt;&lt;}  {]]]]]]}  {&gt;&gt;.%}",             $_-&gt;{pid}, $_-&gt;{cmd},        $_-&gt;{time},  $_-&gt;{cpu};     }</p><p>in which case we'd get:</p><p>     2461  vi -ii henry           0:55.83   11.6%      2395  ex cathedra            0:06.59    3.5%     27384  lynx www.divorce.com  1214:23-    0.8%                                       .75      2439  head anne.boleyn       0:00.18    0.1%      2581  dig -short grave       0:01.04    0.0%</p><p>That preserves the data, but the results are still ugly, and it also requires some fancy footwork E&lt;ndash&gt; making the percentage sign part of the field specification, as if it were a currency marker E&lt;ndash&gt; to make the last field work correctly. In other words: it's a kludge. The sad truth is that sometimes variable-width fields are a better solution.</p><p>So \*(C`form\*(C' provides them too. Any field specification may include a plus sign (\*(C`+\*(C') anywhere between its braces, in which case it specifies an <em>extensible field</em>: a field whose width is minimal, rather than absolute. So, in the above example, our call to \*(C`form\*(C' should actually look like this:</p><p>    for (@procs) {         print form             "{&gt;&gt;&gt;}  {&lt;&lt;&lt;&lt;&lt;&lt;&lt;(20)&lt;&lt;&lt;&lt;&lt;&lt;&lt;}  {&gt;&gt;&gt;&gt;&gt;+}  {&gt;&gt;.}%",             $_-&gt;{pid}, $_-&gt;{cmd},        $_-&gt;{time},  $_-&gt;{cpu};     }</p><p>and would produce this:</p><p>     2461  vi -ii henry           0:55.83   11.6%      2395  ex cathedra            0:06.59    3.5%     27384  lynx www.divorce.com  1214:23.75    0.8%      2439  head anne.boleyn       0:00.18    0.1%      2581  dig -short grave       0:01.04    0.0%</p><p>just like \*(C`printf\*(C' does.</p><p>Likewise, if we thought the command names might exceed 20 columns we could let that field stretch too:</p><p>    for (@procs) {         print form             "{&gt;&gt;&gt;}  {&lt;&lt;&lt;&lt;&lt;&lt;&lt;(20+)&lt;&lt;&lt;&lt;&lt;&lt;}  {&gt;&gt;&gt;&gt;&gt;+}  {&gt;&gt;.}%",             $_-&gt;{pid}, $_-&gt;{cmd},        $_-&gt;{time},  $_-&gt;{cpu};     }</p><p>Note that the field width specifier would still warn us if the field's \*(L"picture\*(R" was not exactly 20 columns wide, but the resulting field would nevertheless stretch as necessary to accommodate longer data. When a field is being filled in, whitespace is normally left as-is (except for justification, and wrapping of lines in block fields). However, this behaviour can be altered by specifying a <em>whitespace</em> squeezing strategy. Squeezing replaces those substrings of the data that match a specified pattern (for example: \*(C`/&#92;s+/\*(C'), substituting a single space character.</p><p>If we don't want the default (non-)squeezing strategy we can use the \*(C`ws\*(C' option specify the particular pattern that is to be used for squeezing:</p><p>    print form         {ws=&gt;qr/&#92;h+/},           # squeeze any horizontal whitespace         $format1, @data1,         {ws=&gt;qr/$comment|&#92;s+/},  # now squeeze comments or whitespace         $format2, @data2;</p><p>For example, suppose we have a eulogy generator:</p><p>    sub eulogize ($who, $to, $blaming) {...}</p><p>that (rather poorly) drops the appropriate names into a pre-formatted template, to produce strings like:</p><p>    Friends,   Romans  , countrymen, lend me your ears;     I come to bury    Caesar   , not to praise him.     The evil that men do lives after them;     The good is oft interred with their bones;     So let it be with    Caesar    . The noble    Brutus     Hath told you     Caesar     was ambitious:     If it were so, it was a grievous fault,     And grievously hath    Caesar    answer&apos;d it.</p><p>If we interpolate that string, with its extra spaces and its embedded newlines, into a \*(C`form\*(C' field:</p><p>    print form          "| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |",             eulogize(&apos;Caesar&apos;, &apos;Romans&apos;, &apos;Brutus&apos;);</p><p>we'd get:</p><p>    | Friends,   Romans  , countrymen, lend me   |     | your ears;                                 |     | I come to bury    Caesar   , not to praise |     | him.                                       |     | The evil that men do lives after them;     |     | The good is oft interred with their bones; |     | So let it be with    Caesar    . The noble |     | Brutus                                     |     | Hath told you     Caesar     was           |     | ambitious:                                 |     | If it were so, it was a grievous fault,    |     | And grievously hath    Caesar    answer&apos;d  |     | it.                                        |</p><p>Note that the extra spaces and the embedded newlines are preserved in the resulting text.</p><p>But, if we told \*(C`form\*(C' to squeeze all whitespaces:</p><p>    print form {ws =&gt; qr/&#92;s+/},          "| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |",             eulogize(&apos;Caesar&apos;, &apos;Romans&apos;, &apos;Brutus&apos;);</p><p>we'd get:</p><p>    | Friends, Romans , countrymen, lend me your |     | ears; I come to bury Caesar , not to       |     | praise him. The evil that men do lives     |     | after them; The good is oft interred with  |     | their bones; So let it be with Caesar .    |     | The noble Brutus Hath told you Caesar was  |     | ambitious: If it were so, it was a         |     | grievous fault, And grievously hath Caesar |     | answer&apos;d it.                               |</p><p>with each sequence of characters that match \*(C`/&#92;s+/\*(C' being reduced to a single space.</p><p>On the other hand, if we wanted to preserve the newlines and squeeze only horizontal whitespace, that would be:</p><p>    print form {ws =&gt; qr/[ &#92;t]+/},          "| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |",             eulogize(&apos;Caesar&apos;, &apos;Romans&apos;, &apos;Brutus&apos;);</p><p>which produces:</p><p>    | Friends, Romans , countrymen, lend me your |     | ears;                                      |     | I come to bury Caesar , not to praise him. |     | The evil that men do lives after them;     |     | The good is oft interred with their bones; |     | So let it be with Caesar . The noble       |     | Brutus                                     |     | Hath told you Caesar was ambitious:        |     | If it were so, it was a grievous fault,    |     | And grievously hath Caesar answer&apos;d it.    |</p><p>Of course, for this particular text, none of these solutions is entirely satisfactory since squeezing the whitespaces to a single space still leaves a single space in places like "Caesar ." and "Romans ,".</p><p>To remove those blemishes we need to take advantage of a more sophisticated aspect of \*(C`form\*(C''s whitespace squeezing behaviour. Namely that, when squeezing whitespace using a particular pattern, \*(C`form\*(C' detects if that pattern captures anything and <em>doesn't</em> squeeze the captured items.</p><p>More precisely, if the squeeze pattern matches but doesn't capture, \*(C`form\*(C' simply replaces the entire match with a single space character. But if the squeeze pattern <em>does</em> capture, \*(C`form\*(C' doesn't insert a space character, but instead replaces the entire match with the concatenation of the captured substrings.</p><p>That means we can completely eliminate any whitespace before a punctuation character with:</p><p>    print form {ws =&gt; qr/[ &#92;t]+ ([.!?,:;])?/},          "| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |",             eulogize(&apos;Caesar&apos;, &apos;Romans&apos;, &apos;Brutus&apos;);</p><p>which produces the desired:</p><p>    | Friends, Romans, countrymen, lend me your  |     | ears;                                      |     | I come to bury Caesar, not to praise him.  |     | The evil that men do lives after them;     |     | The good is oft interred with their bones; |     | So let it be with Caesar. The noble Brutus |     | Hath told you Caesar was ambitious:        |     | If it were so, it was a grievous fault,    |     | And grievously hath Caesar answer&apos;d it.    |</p><p>This works because, in those instances where the pattern matches some whitespace followed by one of the punctuation characters, the punctuation character is captured, and the captured character is then used to replace the entire whitespace-plus-punctuator. On the other hand, if the pattern matches whitespace but no punctuator (and it's allowed to do that because the punctuator is optional), then nothing is captured, so \*(C`form\*(C' falls back to replacing the whitespace with a single space. Fields are (almost) always of a fixed width. So, if there isn't enough data to fill a particular field, the unused portions of that field are filled in with spaces to preserve the vertical alignment of other columns of formatted data. However, spaces are only the default. The \*(C`hfill\*(C' (horizontal fill) option can be used to change fillers. For example:</p><p>    print form         {hfill=&gt;"=-"},                  # Fill next fields with "=-"         "{|{*}|}&#92;n",                    # Full width field for title         "[ Table of Contents ]",        # Title         {hfill=&gt;" ."},                  # Fill next fields with spaced dots         &apos;   {[[[[[{*}[[[[[}{]]]}   &apos;,   # Two indented block fields             @contents,     @page;       # Data for those blocks</p><p>This fills the empty space either side of the centred title with a repeated \*(C`=-=-=-\*(C' sequence. It then fills the gaps to the right of the left-justified the contents field, and to left of the right-justified pages field, with spaced dots. Which, rather prettily, produces something like:</p><p>    =-=-=-=-=-=-=-[ Table of Contents ]-=-=-=-=-=-=-=</p><p>       Foreword. . . . . . . . . . . . . . . . . .i        Preface . . . . . . . . . . . . . . . . .iii        Glossary. . . . . . . . . . . . . . . . . vi        Introduction. . . . . . . . . . . . . . . .1        The Tempest . . . . . . . . . . . . . . . .7        Two Gentlemen of Verona . . . . . . . . . 17        The Merry Wives of Winsor . . . . . . . . 27        Twelfh Night. . . . . . . . . . . . . . . 39        Measure for Measure . . . . . . . . . . . 50        Much Ado About Nothing. . . . . . . . . . 62        A Midsummer Night&apos;s Dream . . . . . . . . 73        Love&apos;s Labour&apos;s Lost. . . . . . . . . . . 82        The Merchant of Venice. . . . . . . . . . 94        As You Like It. . . . . . . . . . . . . .105</p><p>Note that the fill sequence doesn't have to be a single character and that the fill pattern is consistent across multiple fields and between adjacent lines. That is, it's as if every field is first filled with the same fill pattern, then the actual data written over the top. That's particularly handy in the above example, because it ensures that the fill pattern seamlessly bridges the boundary between the adjacent contents and pages fields.</p><p>It's also possible to specify separate fill sequences for the left- and right-hand gaps in a particular field, using the \*(C`lfill\*(C' and \*(C`rfill\*(C' options. This is particularly common for numerical fields. For example, this call to \*(C`form\*(C':</p><p>    print form       &apos;Name              Bribe (per dastardry)&apos;,       &apos;=============     =====================&apos;,       &apos;{[[[[[[[[[[[}         {]],]]].[[[}     &apos;,       &#92;@names,               &#92;@bribes;</p><p>would print something like:</p><p>    Name              Bribe (per dastardry)     =============     =====================     Crookback                  12.676     Iago                        1.62     Borachio               45,615.0     Shylock                    19.0003</p><p>with the numeric field padded with whitespace and only showing as many decimal places as there are in the data.</p><p>However, in order to prevent subsequent..err...creative calligraphy (they <em>are</em>, after all, villains and would presumably not hesitate to add a few digits to the front of each number), we might prefer to put stars before the numbers and show all decimal places. We could do that like so:</p><p>    print form       &apos;Name              Bribe (per dastardry)&apos;,       &apos;=============     =====================&apos;,       &apos;{[[[[[[[[[[[}         {]],]]].[[[}     &apos;,       &#92;@names,               {lfill=&gt;&apos;*&apos;, rfill=&gt;&apos;0&apos;},                              @bribes;</p><p>which would then print:</p><p>    Name              Bribe (per dastardry)     =============     =====================     Crookback             *****12.6760     Iago                  ******1.6200     Borachio              *45,615.0000     Shylock               *****19.0003</p><p>Note that the \*(C`lfill\*(C' and \*(C`rfill\*(C' options are specified <em>after</em> the format string and, more particularly, before the data for the second field. This means that those options only take effect for that particular field and the previous fill behaviour is then reasserted for subsequent fields. Many other \*(C`form\*(C' options E&lt;ndash&gt; for example \*(C`ws\*(C', \*(C`height\*(C', or \*(C`break\*(C' E&lt;ndash&gt; can be specified in this way, so as to apply them only to a particular field.</p><p>There is also a general \*(C`fill\*(C' option that sets the default sequence for any filling that isn't otherwise specified. Filling numeric fields with zeros is so common that \*(C`form\*(C' offers a shorthand notation for it. If the first character inside a numeric field specification is a zero, then the left-fill string for that field is set to "0". Likewise if the last character in the field is a zero, it is right-filled with zeros. For example:</p><p>    my @nums = (0, 1, -1.2345, 1234.56, -1234.56, 1234567.89);</p><p>    print form         "{]]]].[[}     {]]]].[0}     {0]]].[[}     {0]]].[0}",          &#92;@nums,       &#92;@nums,       &#92;@nums,       &#92;@nums;</p><p>prints:</p><p>        0.0           0.000     00000.0       00000.000         1.0           1.000     00001.0       00001.000        -1.234        -1.234     -0001.234     -0001.234      1234.56       1234.560     01234.56      01234.560     -1234.56      -1234.560     -1234.56      -1234.560     #####.###     #####.###     #####.###     #####.### Formatted text blocks are also filled vertically. Empty lines at the end of the block are normally filled with spaces (so as to preserve the alignment of any other fields on the same line). However, this too can be controlled, with the \*(C`vfill\*(C' option. Alternatively E&lt;ndash&gt; as with horizontal filling E&lt;ndash&gt; separate fill sequences can be specified for above and below the text using the \*(C`tfill\*(C' and \*(C`bfill\*(C' (\*(L"top\*(R" and \*(L"bottom\*(R" fill) options.</p><p>For example, if we had six elements in @task, but only four processors:</p><p>    print form         {bfill=&gt;&apos;[unallocated]&apos;},         &apos;Task                      Processor&apos;,         &apos;====                      =========&apos;,         &apos;{[[[[[[[[[[[[[[[[[[[[}  {]]]]]][[[[[}&apos;,          &#92;@task,                     [1..4];</p><p>we'd get:</p><p>    Task                      Processor     ====                      =========     Borrow story                  1     Rename characters             2     Subdivide into scenes         3     Write dialogue                4     Check rhythm and meter  [unallocated]     Insert puns and japes   [unallocated] It is possible to constrain the minimum and maximum number of lines that a particular format or block field must cover, regardless of how much data it contains. We do that using the \*(C`height\*(C' option. For example:</p><p>    print form         {height=&gt;3},         &apos;{[[[[}{IIII}{]]]]}&apos;,          $l,   $c,   $r;</p><p>This will cause the call to \*(C`form\*(C' to generate exactly three output lines, even if the contents of the data variables would normally fit in fewer lines or would actually require more.</p><p>To specify a range of heights we can use the \*(C`min\*(C' and \*(C`max\*(C' suboptions:</p><p>    print form         {height=&gt;{ min=&gt;3, max=&gt;20 }},         &apos;{[[[[}{IIII}{]]]]}&apos;,          $l,   $c,   $r;</p><p>This specifies that, no matter how much data is available, the output will be no less than three lines and no more than 20.</p><p>Note, however, that the \*(C`height\*(C' option refers to the height of individual fields, not of entire output pages. we'll see how to control the latter shortly. As we saw earlier, a block overflow field (\*(C`{VVVVVVVVV}\*(C') has the special property that it only overflows as much as necessary to fill the output lines generated by other block fields. That enabled us to create an overflowing column of text like so:</p><p>    print form         {interleave=&gt;1}, &lt;&lt;EOFORMAT,         Name:           {[[[[[[[[[[[[}                                           Biography:         Status:             {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}           {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}                                                 {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}           {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         EOFORMAT         $name,         $biography,         $status,         $comments;</p><p>without the first \*(C`{VVVVVVVVV}\*(C' field eating all the data out of $bio and leaving a large gap between the Status and the Comments.</p><p>That's a very handy feature, but restricting the \*(L"minimal height\*(R" feature to overflow fields turns out to be not good enough in the general case. For instance, suppose we had wanted the biography field to start at the first line of the output text:</p><p>    Name:             Biography:       William           William Shakespeare was born on       Shakespeare       April 23, 1564 in Strathford-upon-                         Avon, England; he was third of     Status:             eight children from Father John       Deceased (1564    Shakespeare and Mother Mary Arden.       -1616)            Shakespeare began his education at                         the age of seven when he probably     Comments:           attended the Strathford grammar       Theories          school. The school provided       abound as to      Shakespeare with his formal       the true          education. The students chiefly       author of his     studied Latin rhetoric, logic, and       plays. The        literature. His knowledge and       prime             imagination may have come from his       alternative       reading of ancient authors and       candidates        poetry. In November 1582,       being Sir         Shakespeare received a license to       Francis           marry Anne Hathaway. At the time of       Bacon,            their marriage, Shakespeare was 18       Christopher       years old and Anne was 26. They had       Marlowe, or       three children, the oldest Susanna,       Edward de         and twins- a boy, Hamneth, and a       Vere              girl, Judith. Before his death on                         April 23 1616, William Shakespeare                         had written thirty-seven plays. He                         is generally considered the greatest                         playwright the world has ever known                         and has always been the world&apos;s most                         popular author.</p><p>To do that, we would have required a call to \*(C`form\*(C' like this:</p><p>    print form         {interleave=&gt;1}, &lt;&lt;EOFORMAT,         Name:             Biography:           {[[[[[[[[[[[[}    {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}                                                 {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         Status:             {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}           {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}                                                 {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}           {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         EOFORMAT         $name,         $biography,         $status,         $comments;</p><p>Note that the first line of the Biography field now has to be a block field, not a single-line field (as in previous versions). It can't be a single-line, because the Name field is a block field and that would leave a gap in the Biography column:</p><p>    Name:             Biography:       William           William Shakespeare was born on       Shakespeare                         April 23, 1564 in Strathford-upon-     Status:             Avon, England; he was third of                         etc.</p><p>So it has to be a block field, to \*(L"keep up\*(R" with however much output the multi-line Name field produces. Unfortunately, starting the Biography column with a normal block field doesn't solve the problem either. In fact we get:</p><p>    Name:             Biography:       William           William Shakespeare was born on       Shakespeare       April 23, 1564 in Strathford-upon-                         Avon, England; he was third of                         eight children from Father John                         Shakespeare and Mother Mary Arden.                         Shakespeare began his education at                         the age of seven when he probably                         attended the Strathford grammar                         school. The school provided                         Shakespeare with his formal                         education. The students chiefly                         studied Latin rhetoric, logic, and                         literature. His knowledge and                         imagination may have come from his                         reading of ancient authors and                         poetry. In November 1582,                         Shakespeare received a license to                         marry Anne Hathaway. At the time of                         their marriage, Shakespeare was 18                         years old and Anne was 26. They had                         three children, the oldest Susanna,                         and twins- a boy, Hamneth, and a                         girl, Judith. Before his death on                         April 23 1616, William Shakespeare                         had written thirty-seven plays. He                         is generally considered the                         greatest playwright the world has                         ever known and has always been the                         world&apos;s most popular author.</p><p>    Status:       Deceased (1564       -1616)</p><p>    Comments:       Theories       abound as to       the true       author of his       plays. The       prime       alternative       candidates       being Sir       Francis       Bacon,       Christopher       Marlowe, or       Edward de       Vere</p><p>Normal block fields are remorseless in consuming all of their data. So the first Biography field absolutely will not stop formatting, ever, until your entire $biography string is gone.</p><p>What we really need here, is a kinder, gentler block field; a block field that formats minimally, like an overflow field. And we get that with yet another \*(C`height\*(C' option: \*(C`height=&gt;"minimal"\*(C'. Like so:</p><p>    print form         {interleave=&gt;1}, &lt;&lt;EOFORMAT,         Name:             Biography:           {[[[[[[[[[[[[}    {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}                                                 {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         Status:             {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}           {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}                                                 {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}           {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}         EOFORMAT          $name,          {height=&gt;"minimal"}, $biography,          $status,          $comments;</p><p>When this option is applied to a particular field (by placing it immediately before the field's data), that field only consumes as much of its data is is required to fill the output lines created by the other (non-minimal) fields in the same format. In this case, that means that the first Biography field only extracts as much data from $biography as is needed to fill the text lines created by the Name field.</p><p>Note that any kind of block field can be modified in this way: justified, numeric, currency, or verbatim. As some of the examples we've seen so far illustrate, formats frequently consist of a set of column titles, followed by the corresponding columns of data. And, typically, those column titles are underlined to make them stand out:</p><p>    print form       &apos;Name              Bribe (per dastardry)&apos;,       &apos;=============     =====================&apos;,       &apos;{[[[[[[[[[[[}         {]],]]].[[[}     &apos;,       @names,                @bribes;</p><p>So \*(C`form\*(C' has an option that automates that process. For example, the payments example above could also have been written:</p><p>    print form       &apos;Name              Bribe (per dastardry)&apos;,       {under=&gt;"="},       &apos;{[[[[[[[[[[[}         {]],]]].[[[}     &apos;,       @names,                @bribes;</p><p>The \*(C`under\*(C' option takes a string and uses it to underline the most recently formatted line. It does this by examining the formats immediately before and after the \*(C`under\*(C'. It then generates a series of underlines by repeating the specified underlining string as many times as required. The underlines are generated such that every field and every other non-whitespace literal in the preceding format has a underline under it and every field/non-whitespace in the next format has an \*(L"overline\*(R" above it.</p><p>For example, this call to \*(C`form\*(C':</p><p>    print form         &apos;      Rank Name         Serial Number&apos;,         {under=&gt;"_"},         &apos;{]]]]]]]]} {[[[[[[[[[}     {IIIII}&apos;,              @ranks,@names,          @nums;</p><p>prints:</p><p>          Rank Name         Serial Number     __________ ___________  _____________       Corporal Nym              CMXVII     Lieutenant Bardolph          CCIV        Captain Spurio           MMMCDX        General Pompey             XI</p><p>The usual effect is that the auto-generated underlines always extend to the edges of both the preceding title and the following field, whichever is wider.</p><p>Many people, of course, prefer to draw the underlines themselves, as the results are then much easier to visualize when looking at the code. The \*(C`under\*(C' option is most useful when we're constructing tables programmatically, with columns and column titles that are only known at run-time. The default fill-with-spaces behaviour of fields is useful to preserve the vertical alignment of columns within a formatted text, but it could also potentially increase the size of \*(C`form\*(C''s output unnecessarily. For example, the following:</p><p>    print form         &apos;To Do:&apos;,         &apos;   {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&apos;,             @todo;</p><p>might produce something like:</p><p>    To Do:        Dissemble        Deceive        Dispute        Defy        Duel        Defeat        Dispatch</p><p>That looks fine but, because each line is produced by the large left-justified field that is automatically filled with whitespace, the output contains several hundred more space characters than are strictly necessary (you probably didn't notice them, but they're all there E&lt;ndash&gt; hanging off the right sides of the individual To-Do items).</p><p>Fortunately, however, \*(C`form\*(C' is smarter than that. Extraneous trailing whitespace on the right-hand side of any output line is automatically trimmed. So the above example actually produces:</p><p>    To Do:        Dissemble        Deceive        Dispute        Defy        Duel        Defeat        Dispatch</p><p>Of course, if you really do need those \*(L"invisible\*(R" trailing whitespaces for some reason, \*(C`form\*(C' provides a way to keep them E&lt;ndash&gt; the \*(C`untrimmed\*(C' option:</p><p>    print form {untrimmed=&gt;1},         &apos;To Do:&apos;,         &apos;   {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&apos;,             @todo;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Page control</h2>
        <div class="sectioncontent">
<p>Normally, \*(C`form\*(C' assumes that whatever data it is formatting is supposed to produce a single, arbitrarily long, unbroken piece of text. But \*(C`form\*(C' can also format data into multiple pages of fixed length and width, inserting customized, page-specific headers, footers, and pagefeeds for each page.</p><p>All these features are controlled by the the \*(C`page\*(C' option (or more precisely, by its various suboptions):</p><p>    print form         { page =&gt; { length =&gt; $page_len,        # Default: 60 lines                     width  =&gt; $page_width,      # Default: 78 columns                     number =&gt; $first_page_num,  # Default: 1                     header =&gt; &#92;&make_header,    # Default: no header                     footer =&gt; &#92;&make_footer,    # Default: no footer                     feed   =&gt; &#92;&make_pagefeed,  # Default: no pagefeed                     body   =&gt; &#92;&adjust_body,    # Default: no chiropracty                                   }                 },         $format,         @args; The \*(C`page =&gt; { length =&gt; ... }\*(C' suboption determines the number of output lines per page (including headers and footers). Normally, this suboption is set to infinity, which produces that single, arbitrarily long, unbroken page of text. But the suboption can be set to any positive integer value, to cause \*(C`form\*(C' to generate distinct pages of that many lines each.</p><p>The value of the \*(C`page =&gt; { width =&gt; ... }\*(C' suboption is used to determine the width of distributive fields and in some page body postprocessors. By default, this suboption is set to 78 (columns), but it may be set to any positive integer value.</p><p>The \*(C`page =&gt; { number =&gt; ... }\*(C' suboption specifies the current page number. By default it starts at 1, but may be set to any numeric value. This suboption is generally only of use in headers and footers (see below). The \*(C`page =&gt; { header =&gt; ... }\*(C' suboption specifies a hash containing a set of strings or subroutines that are to be used to create page headers. Each key of the hash indicates a particular kind of page that the corresponding value will provide the header for. For example:</p><p>    header =&gt; { first =&gt; "           &apos;The Tempest&apos; by W. Shakespeare          ",                 last  =&gt; "                   -- The End --                    ",                 odd   =&gt; "Act $act, Scene $scene                              ",                 even  =&gt; "                                                    ",                 other =&gt; "          [Thys hedder intenshunally blanke]        ",               }</p><p>Given the above specification, \*(C`form\*(C' will:</p><ul>
<li><p>use the full title and author as the header of the first page,</p></li><li><p>write "-- The End --" across the top of the last page,</p></li><li><p>prepend the act and scene information to the start of any odd page (except, of course, the first or the last), and</p></li><li><p>provide an empty line as the header of any even page (except the last, if it happens to be even).</p></li>
</ul><p>Note that, in this case, since we've provided specific headers for every odd and even page, the "other" header will never be used. On the other hand, if we'd specified:</p><p>    header =&gt; { first =&gt; "           &apos;The Tempest&apos; by W. Shakespeare          ",                 other =&gt; "                                       &apos;The Tempest&apos;",               }</p><p>then every page except the first would have just a right-justified title at the top.</p><p>Of course, if we want every page to have the same header, we can just write:</p><p>    header =&gt; { other =&gt; "                                       &apos;The Tempest&apos;"}</p><p>But that's a little klunky, so \*(C`form\*(C' also accepts a single string instead of a hash, to specify a header to be used for every page:</p><p>    header  =&gt; "                                       &apos;The Tempest&apos;"</p><p>Headers don't all have to be the same size either. For example, we might prefer a more imposing first header:</p><p>    header =&gt; { first =&gt; "                  &apos;The Tempest&apos;                   &#92;n"                        . "                        by                        &#92;n"                        . "                  W. Shakespeare                  &#92;n"                        . "____________________________________________________",</p><p>                other =&gt; "                                       &apos;The Tempest&apos;",               }</p><p>\*(C`form\*(C' simply notes the number of lines each header requires and then reduces the available number of lines within the page accordingly, so as to preserve the exact overall page length.</p><p>Often we'll need headers that aren't fixed strings. For example, we might want each page to include the appropriate page number. So instead of a string, we're allowed to specify a particular header as a subroutine. That subroutine is then called each time that particular header is required, and its return value is used as the required header.</p><p>When the subroutine is called, the current set of active formatting options are passed to it as a list of pairs. Typically, then, the subroutine will specify one or more named-only parameters corresponding to the options it cares about, followed by a starred hash parameter to collect the rest. For example if every page should have its (left-justified) page number for a header:</p><p>    header =&gt; sub { return $_[0]{page}{number}; }</p><p>Footers work in exactly the same way in almost all respects; the obvious exception being that they're placed at the end of a page, rather than the start.</p><p>Pagefeeds work the same way too. A pagefeed is a string that is placed between the footer of one page and the header of the next. They're like formfeeds, except they can be any string we choose. They're called \*(L"pagefeeds\*(R" instead of \*(L"formfeeds\*(R" because they're placed between pages, not between calls to \*(C`form\*(C'. Sometimes it's useful to be able to grab the entire body of a page (i.e. the contents of the page between the header and footer) <em>after</em> it's been formatted together. For example, we might wish to centre those contents, or to crop them at a particular column.</p><p>To this end, the \*(C`page =&gt; { body =&gt; ... }\*(C' suboption allows us to specify a page body post-processor. That is, a subroutine or format that lays out the page's formatted text between the page's header and footer. Like the \*(C`header\*(C', \*(C`footer\*(C', and \*(C`feed\*(C' suboptions, the \*(C`body\*(C' suboption can take either a closure, a hash, or a string.</p><p>If the value of the \*(C`body\*(C' suboption is a string or a hash of pairs, the text of the body is (recursively) \*(C`form\*(C''ed using that string (or those string values) as its format. A very common usage is to arrange for the formatted text to be horizonally and vertically centred on each page:</p><p>    body =&gt; &apos;{=I{*}I=}&apos;</p><p>A more sophisticated variation on this is to use a hash to insert a left or right \*(L"gutter\*(R" for each page:</p><p>    $gutter = " " x $gutter_width;</p><p>    body =&gt; { odd   =&gt;  $gutter ~ &apos;{"""{*}"""}&apos;,               even  =&gt;  &apos;{"""{*}"""}&apos; ~ $gutter,             }</p><p>On the other hand, if the value of the \*(C`body\*(C' suboption is a subroutine, the body text is passed to that sub as a reference to an array of lines. A second array reference is also passed in, containing as many newlines as would be needed to pad out the body text to the correct number of lines for the page. Finally, the current formatting options are passed as a hash reference. As with the \*(C`header\*(C' etc. suboption, the closure is expected to return a single string (representing the final formatting of the page body).</p><p>For example, to add line numbers to the text each page (but <em>not</em> to the headers or footers or filler lines):</p><p>        my $linenum = 1;</p><p>    sub numerate {                 my @lines = @{$_[0]};                 my @fill  = @{$_[1]};                 my $page  = ${$_[2]}{page};</p><p>        # Compute range of line numbers         my @linenums = ($linenum .. $linenum+@lines-1);</p><p>        # Reformat body lines verbatim,         # with a left-justified line number before each...         my $body = form &apos;{[[[[} {"""{*}"""}&apos;,                          &#92;@linenums, &#92;@lines,                         @fill;</p><p>        # Update the final line number and return the new body text...         $linenum += @lines;         return $body;     }</p><p>    print form         page =&gt; { body   =&gt; &#92;&numerate,                   header =&gt; "&#92;n==========&#92;n&#92;n",                   length =&gt; 12,                 },         # Left-justify the Briton...         "{[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}",         $soliloquy{RichardIII},                          # Right-justify the Dane...         "                 {]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]}",                           $soliloquy{Hamlet};</p><p>which produces:</p><p>    ==========</p><p>    1      Now is the winter of our discontent /     2      Made glorious summer by this sun of     3      York; / And all the clouds that lour&apos;d     4      upon our house / In the deep bosom of     5      the ocean buried. / Now are our brows     6      bound with victorious wreaths; / Our     7      bruised arms hung up for monuments; /     8      Our stern alarums changed to merry     9      meetings, / Our dreadful marches to</p><p>    ==========</p><p>    10     delightful measures. Grim-visaged war     11     hath smooth&apos;d his wrinkled front; / And     12     now, instead of mounting barded steeds     13     / To fright the souls of fearful     14     adversaries, / He capers nimbly in a     15     lady&apos;s chamber.</p><p>    ==========</p><p>    16                      To be, or not to be -- that is the question: /     17                         Whether &apos;tis nobler in the mind to suffer /     18                       The slings and arrows of outrageous fortune /     19                         Or to take arms against a sea of troubles /     20                       And by opposing end them. To die, to sleep --     21                         / No more -- and by a sleep to say we end /     22                      The heartache, and the thousand natural shocks     23                      / That flesh is heir to. &apos;Tis a consummation /     24                        Devoutly to be wished. To die, to sleep -- /</p><p>    ==========</p><p>    25                         To sleep -- perchance to dream: ay, there&apos;s     26                          the rub, / For in that sleep of death what     27                         dreams may come / When we have shuffled off     28                             this mortal coil, / Must give us pause.     29                        There&apos;s the respect / That makes calamity of     30                                                       so long life.</p><p>                   E&lt;nbsp&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">User-defined fields</h2>
        <div class="sectioncontent">
<p>Perl6::Form provides a large variety of field types, but not every possible type. For example, suppose we want a field that masks its data in some way.  Perhaps a field that blanks out certain words by replacing them with the corresponding number of X's.</p><p>We could always do that by writing a subroutine that generates the appropriate filter:</p><p>    sub expurgate {                 my $hidewords = join "|", map quotemeta, @_;         return sub {             $_[0] =~ s/($hidewords)/ &apos;X&apos; x length $1 /gixe;             return $data;         }     }</p><p>We could then apply that subroutine to the data of any field that needed bowdlerization:</p><p>    my $censor = expurgate qw(villain plot libel treacherous murderer false deadly &apos;G&apos;);</p><p>    print form         "[Ye following tranfcript hath been cenfored by Order of ye King]&#92;n&#92;n",         "         {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}",                   $censor-&gt;($speech);</p><p>to produce:</p><p>    [Ye following tranfcript hath been cenfored by Order of ye King]</p><p>             And therefore, since I cannot prove a lover,              To entertain these fair well-spoken days,              I am determined to prove a XXXXXXX              And hate the idle pleasures of these days.              XXXXs have I laid, inductions dangerous,              By drunken prophecies, XXXXXs and dreams,              To set my brother Clarence and the king              In XXXXXX hate the one against the other:              And if King Edward be as true and just              As I am subtle, XXXXX and XXXXXXXXXXX,              This day should Clarence closely be mew&apos;d up,              About a prophecy, which says that XXX              Of Edward&apos;s heirs the XXXXXXXX shall be.</p><p>Of course, if this were Puritanism and not Perl, we might have a long list of proscribed words that we needed to excise from <em>every</em> formatted text. In that case, rather that explicitly running every data source through the same censorious subroutine, it would be handy if \*(C`form\*(C' had a built-in field that did that for us automatically.</p><p>Naturally, \*(C`form\*(C' doesn't have such a field built-in...but we can certainly give it one.</p><p>User-defined field specifiers can be declared using the \*(C`field\*(C' option, which takes as its value an array of pairs. The key of each pair is a string or a rule (i.e. regex) that specifies the syntax of the user-defined field. The value of each pair is a closure/subroutine that constructs a standard field specifier to replace the user-defined specifier. Alternatively, the value of a pair may be a string, which is taken as the (static) field specifier to be used instead of the user-defined field.</p><p>In other words, each pair is a macro that maps a user-defined field (specified by the pair's key) onto a standard \*(C`form\*(C' field (specified by the pair's value). For example:</p><p>    field =&gt; [ qr/&#92;{ X+ &#92;}/x =&gt; &#92;&censor_field ]</p><p>This tells \*(C`form\*(C' that whenever it finds a brace-delimited field consisting of one or more X's, it should call a subroutine named \*(C`censor_field\*(C' and use the return value of that call instead of the all-X field.</p><p>When the key of a \*(C`field\*(C' pair matches some part of a format, its corresponding subroutine is called. That subroutine is passed the Perl6ish result (i.e. $0) of the regex match, as well as a reference to the hash of active options for that field. Changes to the options hash will affect the subsequent formatting behaviour of that field.</p><p>So \*(C`censor_field\*(C' could be implemented like so:</p><p>        # Constructor subroutine for user-defined censor fields...         sub censor_field {                         my ($field_spec, $opts) = @_;</p><p>            # Set up the field&apos;s &apos;break&apos; option with a censorious break...             $opts-&gt;{break} = break_and_censor($-&gt;opts{break});</p><p>            # Construct a left-justified field with the appropriate width             # specified imperatively...             return &apos;{[[{&apos; . length($field_spec) . &apos;}[[}&apos;;         }</p><p>The \*(C`censor_field\*(C' subroutine has to change the field's \*(C`break\*(C' option, creating a new line breaker that also expurgates unsuitable words. To do this it calls \*(C`break_and_censor\*(C', which returns a new line breaker subroutine:</p><p>        # Create a new &apos;break&apos; sub...         sub break_and_censor {                         my $original_breaker = @_;             return sub {</p><p>                # Call the field&apos;s original &apos;break&apos; sub...                 my ($nextline, $more) = $original_breaker-&gt;(@_);</p><p>                # X out any doubleplus ungood words                 $nextline =~ s/($proscribed_words)/ &apos;X&apos; x length $1 /gixe;</p><p>                # Return the "corrected" version...                 return ($nextline, $more);             }         }</p><p>Having created a subroutine to translate censor fields and another to break-and-expurgate the data placed in them, we are now in a position to create a module that encapsulates the new formatting functionality:</p><p>    package Ministry::Of::Truth         use Perl6::Export;</p><p>        # Internal mechanism (as above)...         my $proscribed = "...";         sub break_and_censor (&original_breaker) {...}         sub censor_field ($field_spec, %opts) {...}</p><p>        # Make the new field type standard by default in this scope...         use Form { field =&gt; [ rx/&#92;{ X+ &#92;}/ =&gt; &#92;&censor_field ] };</p><p>        # Re-export the specialized &form that was imported above...         sub form is export(:DEFAULT) {...}</p><p>}</p><p>Okay, admittedly that's quite a lot of work. But the pay-off is huge: we can now trample on free speech <em>much</em> more easily:</p><p>    use Ministry::Of::Truth;</p><p>    print form         "[Ye following tranfcript hath been cenfored by Order of ye King]&#92;n&#92;n",         "        {XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}",                   $speech;</p><p>And we'd get the same carefully \s-1XXXX\s0'ed output as before. User-defined fields are also a handy way to create single-character markers for single-column fields (in order to preserve the one-to-one spacing of a format). For example:</p><p>    print form         {field =&gt; { &apos;^&apos; =&gt; &apos;{&lt;III{1}III}&apos;,   # 1-char-wide, top-justified block                     &apos;=&apos; =&gt; &apos;{&lt;=II{1}II=}&apos;,   # 1-char-wide, middle-justified block                     &apos;_&apos; =&gt; &apos;{&lt;_II{1}II_}&apos;,   # 1-char-wide, bottom-justified block                   }                 },         &apos;~~~~~~~~~&apos;,         &apos;^ _ = _ ^&apos;,   qw(like round and orient perls),         &apos;~~~~~~~~~&apos;;</p><p>prints:</p><p>    ~~~~~~~~~     l     o p     i r a r e     k o n i r     e u d e l       n   n s       d   t     ~~~~~~~~~</p><p>Single fields are particularly useful for labelling the vertical axes of a graph:</p><p>    use Form {field =&gt; [ &apos;=&apos; =&gt; &apos;{&lt;=II{1}II=}&apos; ] };</p><p>    @vert_label = qw(Villain&apos;s fortunes);     $hor_label  = "Time";</p><p>    print form        &apos;     ^                                        &apos;,        &apos; = = | {""""""""""""""""""""""""""""""""""""} &apos;, @vert_label, &#92;@data,        &apos;     +---------------------------------------&gt;&apos;,        &apos;      {|||||||||||||||||||||||||||||||||||||} &apos;, $hor_label;</p><p>which produces:</p><p>         ^          |      V   |       *      i f |     *   *      l o |    *     *      l r |      a t |   *       *      i u |      n n |  *         *      &apos; e |      s s |          |          | *           *          +---------------------------------------&gt;                            Time</p><p>Specifying these kinds of single-character block markers is perhaps the commonest use of user-defined fields. But the:</p><p>    field =&gt; [ &apos;=&apos; =&gt; &apos;{&lt;=II{1}II=}&apos; ]</p><p>syntax is uncomfortably verbose for that purpose. So calls to \*(C`form\*(C' can also accept a short-hand notation to define a single-character field:</p><p>    single =&gt; &apos;=&apos;</p><p>or to define several at once:</p><p>    single =&gt; [&apos;#&apos;, &apos;*&apos;, &apos;+&apos;]</p><p>The \*(C`single\*(C' option does exactly the same thing as the \*(C`field\*(C' options shown above. It takes a single-character string, or a reference to an array of such strings, as its value. It then turns each of those strings into a single-column field marker. If the character is '=' then the field is vertically \*(L"middled\*(R" within its block. If the character is '_' then the field is \*(L"bottomed\*(R" within its block. If the single character is anything else, the resulting block is top-justified. So our previous example could also have been written:</p><p>    print form         {single =&gt; "="},         &apos;     ^                                        &apos;,         &apos; = = | {""""""""""""""""""""""""""""""""""""} &apos;, @vert_label, &#92;@data,         &apos;     +---------------------------------------&gt;&apos;,         &apos;      {|||||||||||||||||||||||||||||||||||||} &apos;, $hor_label;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Bulleted lists</h2>
        <div class="sectioncontent">
<p>Suppose we want a list of items bulleted by \*(L"diamonds\*(R":</p><p>    &lt;&gt; A rubber sword (laminated with mylar to        look suitably shiny).     &lt;&gt; Cotton tights (summer performances).     &lt;&gt; Woolen tights (winter performances or        those actors who are willing to admit        to being over 65 years of age).     &lt;&gt; Talcum powder.     &lt;&gt; Codpieces (assorted sizes).     &lt;&gt; Singlet.     &lt;&gt; Double.     &lt;&gt; Triplet (Kings and Emperors only).     &lt;&gt; Supercilious attitude (optional).</p><p>Something like this works well enough:</p><p>    for my $item (@items) {         print form             &apos;&lt;&gt; {&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;}&apos;, $item;             &apos;   {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&apos;;     }</p><p>The first format produces the bullet plus the first line of text for the item, then the second format handles any overflow of the item data.</p><p>Alternatively, we could achieve the same result with a single format string by interpolating the bullet as well:</p><p>    my $bullet = "&lt;&gt;";</p><p>    for my $item (@items) {         print form             "{&apos;&apos;{*}&apos;&apos;} {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}",              $bullet,  $item;     }</p><p>Here we use a single-line starred verbatim field (\*(C`{''{*}''}\*(C'), so that the bullet is interpolated \*(L"as-is\*(R" and the field is only as wide as the bullet itself. Then for the item itself we use a block field, which will format the item data over as many lines as necessary. Meanwhile, because the bullet's field is single-line, after the first line the bullet field will be filled with spaces (instead of a \*(L"diamond\*(R"), leaving a bullet only on the first line.</p><p>This second approach also has the advantage that we could change the bullet string at run-time and the format would adapt automatically.</p><p>However, it's still a little irritating that we have to set up a loop and call \*(C`form\*(C' separately for each element of @items. After all, if we didn't need to bullet our list we could just write:</p><p>    print form         "{[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}",         &#92;@items;</p><p>and \*(C`form\*(C' would take care of iterating over the @items for us. It seems that things ought to be that easy for bulleted lists as well.</p><p>And, of course, things <em>are</em> that easy.</p><p>All we need to do is tell \*(C`form\*(C' that whenever the string "&lt;&gt;" appears in a format, it should be treated as a bullet. That is, it should appear only beside the <em>first</em> line of text produced when formatting each element of the adjacent field's data.</p><p>To tell \*(C`form\*(C' all that we use the \*(C`bullet\*(C' option:</p><p>    print form         {bullet =&gt; "&lt;&gt;"},         "&lt;&gt; {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}",             &#92;@items;</p><p>The presence of this \*(C`bullet\*(C' option causes \*(C`form\*(C' to treat the sequence "&lt;&gt;" as a special field. That special field interpolates the string "&lt;&gt;" when the field immediately to its right begins to format a new data element, but thereafter interpolates only spaces until the adjacent field finishes formatting that data element.</p><p>Or, to put it more simply, if we tell \*(C`form\*(C' that  "&lt;&gt;" is a bullet, \*(C`form\*(C' treats it like a bullet that's attached to the very next field.</p><p>So we could allow our Shakespearean roles example to handle multi-line character names, like so:</p><p>    print "The best Shakespearean roles are:&#92;n&#92;n";</p><p>    print form         {bullet =&gt; "* "},         "   * {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}   *{[[[[[[[[]]]]]]]]}*",               &#92;@roles,                                &#92;$disclaimer;</p><p>This could then produce something like:</p><p>   The best Shakespearean roles are:</p><p>      * Either of the &apos;two foolish             *WARNING:          *         officers&apos;: Dogberry and Verges         *This list of roles*       * That dour Scot, the Laird              *constitutes      a*         Macbeth                                *personal   opinion*       * The tragic Moor of Venice,             *only and is in  no*         Othello                                *way  endorsed   by*       * Rosencrantz&apos;s good buddy               *Shakespeare&apos;R&apos;Us. *         Guildenstern                           *It   may   contain*       * The hideous and malevolent             *nuts.             *         Richard III                            *                  *</p><p>Notice too that the asterisks on either side of the disclaimer <em>aren't</em> treated as bullets. That's because we defined a bullet to be "* ", and neither of the disclaimer asterisks has a space after it.</p><p>Bullets can be any string we like, and there can be more than one of them in a single format. For example:</p><p>    print form         {bullet =&gt; &apos;+&apos;},         "+ {[[[[[[[[[[[[[[[[[[[:}       + {:[[[[[[[[[[[[[[[[[[[}",             &#92;@items,                      &#92;@items;</p><p>would print:</p><p>    + A rubber sword,                65 years of age).       laminated with mylar         + Talcum powder.       to look suitably             + Codpieces (assorted       shiny.                         sizes).     + Cotton tights (summer        + Singlet.       performances).               + Double.     + Woolen tights (winter        + Triplet (Kings and       performances or those          Emperors only).       actors who are willing       + Supercilious attitude       to admit to being over         (optional).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WARNING</h2>
        <div class="sectioncontent">
<p>The syntax and semantics of Perl 6 is still being finalized and consequently is at any time subject to change. That means the same caveat applies to this module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEPENDENCIES</h2>
        <div class="sectioncontent">
<p>Requires: Perl 5.8.0, Perl6::Export, Scalar::Util, List::Util.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Damian Conway (damian@conway.org)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p> Copyright (c) 2003, Damian Conway. All Rights Reserved.  This module is free software. It may be used, redistributed     and/or modified under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Perl6::Export::Attrs.3pm.html"><span aria-hidden="true">&larr;</span> Perl6::Export::Attrs.3pm: The perl 6 'is export(...)' trait as a perl 5 attribute</a></li>
   <li class="next"><a href="Perl6::Say.3pm.html">Perl6::Say.3pm: \*(c`print\*(c' -- but no newline needed <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

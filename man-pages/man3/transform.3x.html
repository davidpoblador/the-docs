<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>transform: Transform- transformations available for asimages libafterimage/transform.h</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Transform- transformations available for asimages libafterimage/transform.h">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="transform (3x) manual">
  <meta name="twitter:description" content="Transform- transformations available for asimages libafterimage/transform.h">
  <meta name="twitter:image" content="https://www.carta.tech/images/libafterimage-dev-transform-3x.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3x/transform.3x.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="transform (3x) manual" />
  <meta property="og:description" content="Transform- transformations available for asimages libafterimage/transform.h" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libafterimage-dev-transform-3x.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">transform<small> (3x)</small></h1>
        <p class="lead">Transform- transformations available for asimages libafterimage/transform.h</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/transform.3x.html">
      <span itemprop="name">transform: Transform- transformations available for asimages libafterimage/transform.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libafterimage-dev/">
      <span itemprop="name">libafterimage-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/transform.3x.html">
      <span itemprop="name">transform: Transform- transformations available for asimages libafterimage/transform.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">NAMEtransform</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Defines transformations that could be performed on ASImage.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Transformations can be performed with different degree of quality. Internal engine uses 24.8 bits per channel per pixel. As the result there are no precision loss, while performing complex calculations. Error diffusion algorithms could be used to transform it back into 8 bit without quality loss.</p><p>Any Transformation could be performed with the result written directly into XImage, so that it could be displayed faster.</p><p>Complex interpolation algorithms are used to perform scaling operations, thus yielding very good quality. All the transformations are performed in integer math, with the result of greater speeds. Optional MMX inline assembly has been incorporated into some procedures, and allows one to achieve considerably better performance on compatible CPUs.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO transform&hellip;</h2>
        <div class="sectioncontent">
<p> Transformations :</p>
<pre>
         scale_asimage(), tile_asimage(), merge_layers(),
            make_gradient(), flip_asimage(), mirror_asimage(),
            pad_asimage(), blur_asimage_gauss(), fill_asimage(),
            adjust_asimage_hsv()
</pre>
<p> Other libAfterImage modules :</p>
<pre>
         ascmap.h asfont.h asimage.h asvisual.h blender.h export.h
         import.h transform.h ximage.h
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sasha Vasko &lt;sasha at aftercode dot net&gt; libAfterImage/transform/scale_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEscale_asimage()</h2>
        <div class="sectioncontent">
<p>- scales source ASImage into new image of requested dimensions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *scale_asimage( struct ASVisual *asv,</p>
<pre>
                        ASImage *src,
                        unsigned int to_width,
                        unsigned int to_height,
                        ASAltImFormats out_format,
                        unsigned int compression_out, int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- source ASImage</p>
  </dd>
  <dt>
    to_width
  </dt>
  <dd>
    <p>- desired width of the resulting image</p>
  </dd>
  <dt>
    to_height
  </dt>
  <dd>
    <p>- desired height of the resulting image</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out-
  </dt>
  <dd>
    <p>compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>If size has to be reduced - then several neighboring pixels will be averaged into single pixel. If size has to be increased then new pixels will be interpolated based on values of four neighboring pixels.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>ASScale libAfterImage/transform/tile_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEtile_asimage()</h2>
        <div class="sectioncontent">
<p>- tiles/crops ASImage to desired size, while optionaly tinting it at the same time.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *tile_asimage ( struct ASVisual *asv,</p>
<pre>
                        ASImage *src,
                        int offset_x,
                        int offset_y,
                        unsigned int to_width,
                        unsigned int to_height,
                        ARGB32 tint,
                        ASAltImFormats out_format,
                        unsigned int compression_out, int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- source ASImage</p>
  </dd>
  <dt>
    offset_x
  </dt>
  <dd>
    <p>- left clip margin</p>
  </dd>
  <dt>
    offset_y
  </dt>
  <dd>
    <p>- right clip margin</p>
  </dd>
  <dt>
    to_width
  </dt>
  <dd>
    <p>- desired width of the resulting image</p>
  </dd>
  <dt>
    to_height
  </dt>
  <dd>
    <p>- desired height of the resulting image</p>
  </dd>
  <dt>
    tint
  </dt>
  <dd>
    <p>- ARGB32 value describing tinting color.</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out-
  </dt>
  <dd>
    <p>compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Offset_x and offset_y define origin on source image from which tiling will start. If offset_x or offset_y is outside of the image boundaries, then it will be reduced by whole number of image sizes to fit inside the image. At the time of tiling image will be tinted unless tint == 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>ASTile libAfterImage/transform/merge_layers()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEmerge_layers()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *merge_layers  ( struct ASVisual *asv,</p>
<pre>
                         ASImageLayer *layers, int count,
                         unsigned int dst_width,
                         unsigned int dst_height,
                         ASAltImFormats out_format,
                         unsigned int compression_out, int quality);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    layers
  </dt>
  <dd>
    <p>- array of ASImageLayer structures that will be rendered one on top of another. First element corresponds to the bottommost layer.</p>
  </dd>
  <dt>
    dst_width
  </dt>
  <dd>
    <p>- desired width of the resulting image</p>
  </dd>
  <dt>
    dst_height
  </dt>
  <dd>
    <p>- desired height of the resulting image</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out
  </dt>
  <dd>
    <p>- compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>merge_layers() will create new ASImage of requested size. It will then go through all the layers, and fill image with composition. Bottommost layer will be used unchanged and above layers will be superimposed on it, using algorithm specified in ASImageLayer structure of the overlaying layer. Layers may have smaller size then destination image, and maybe placed in arbitrary locations. Each layer will be padded to fit width of the destination image with all 0 effectively making it transparent. libAfterImage/transform/make_gradient()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEmake_gradient()</h2>
        <div class="sectioncontent">
<p>- renders linear gradient into new ASImage</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *make_gradient ( struct ASVisual *asv,</p>
<pre>
                         struct ASGradient *grad,
                         unsigned int width,
                         unsigned int height,
                         ASFlagType filter,
                         ASAltImFormats out_format,
                         unsigned int compression_out, int quality);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    grad
  </dt>
  <dd>
    <p>- ASGradient structure defining how gradient should be drawn</p>
  </dd>
  <dt>
    width
  </dt>
  <dd>
    <p>- desired width of the resulting image</p>
  </dd>
  <dt>
    height
  </dt>
  <dd>
    <p>- desired height of the resulting image</p>
  </dd>
  <dt>
    filter
  </dt>
  <dd>
    <p>- only channels corresponding to set bits will be rendered.</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out-
  </dt>
  <dd>
    <p>compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>make_gradient() will create new image of requested size and it will fill it with gradient, described in structure pointed to by grad. Different dithering techniques will be applied to produce nicer looking gradients. libAfterImage/transform/flip_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEflip_asimage()</h2>
        <div class="sectioncontent">
<p>- rotates ASImage in 90 degree increments</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *flip_asimage ( struct ASVisual *asv,</p>
<pre>
                        ASImage *src,
                        int offset_x, int offset_y,
                        unsigned int to_width,
                        unsigned int to_height,
                        int flip, ASAltImFormats out_format,
                        unsigned int compression_out, int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- source ASImage</p>
  </dd>
  <dt>
    offset_x
  </dt>
  <dd>
    <p>- left clip margin</p>
  </dd>
  <dt>
    offset_y
  </dt>
  <dd>
    <p>- right clip margin</p>
  </dd>
  <dt>
    to_width
  </dt>
  <dd>
    <p>- desired width of the resulting image</p>
  </dd>
  <dt>
    to_height
  </dt>
  <dd>
    <p>- desired height of the resulting image</p>
  </dd>
  <dt>
    flip
  </dt>
  <dd>
    <p>- flip flags determining degree of rotation.</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out
  </dt>
  <dd>
    <p>- compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>flip_asimage() will create new image of requested size, it will then tile source image based on offset_x, offset_y, and destination size, and it will rotate it then based on flip value. Three rotation angles supported 90, 180 and 270 degrees. libAfterImage/transform/mirror_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEmirror_asimage()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *mirror_asimage ( struct ASVisual *asv,</p>
<pre>
                          ASImage *src,
                          int offset_x, int offset_y,
                          unsigned int to_width,
                          unsigned int to_height,
                          Bool vertical, ASAltImFormats out_format,
                          unsigned int compression_out, int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- source ASImage</p>
  </dd>
  <dt>
    offset_x
  </dt>
  <dd>
    <p>- left clip margin</p>
  </dd>
  <dt>
    offset_y
  </dt>
  <dd>
    <p>- right clip margin</p>
  </dd>
  <dt>
    to_width
  </dt>
  <dd>
    <p>- desired width of the resulting image</p>
  </dd>
  <dt>
    to_height
  </dt>
  <dd>
    <p>- desired height of the resulting image</p>
  </dd>
  <dt>
    vertical
  </dt>
  <dd>
    <p>- mirror in vertical direction.</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out
  </dt>
  <dd>
    <p>- compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>mirror_asimage() will create new image of requested size, it will then tile source image based on offset_x, offset_y, and destination size, and it will mirror it in vertical or horizontal direction. libAfterImage/transform/pad_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEpad_asimage()</h2>
        <div class="sectioncontent">
<p>enlarges ASImage, padding it with specified color on each side in accordance with requested geometry.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *pad_asimage( ASVisual *asv, ASImage *src,</p>
<pre>
                     int dst_x, int dst_y,
                     unsigned int to_width,
                     unsigned int to_height,
                     ARGB32 color,
                     ASAltImFormats out_format,
                     unsigned int compression_out, int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- source ASImage</p>
  </dd>
  <dt>
    dst_x,
  </dt>
  <dd>
    <p>dst_y - placement of the source image relative to the origin of destination image</p>
  </dd>
  <dt>
    to_width
  </dt>
  <dd>
    <p>- width of the destination image</p>
  </dd>
  <dt>
    to_height
  </dt>
  <dd>
    <p>- height of the destination image</p>
  </dd>
  <dt>
    color
  </dt>
  <dd>
    <p>- ARGB32 color value to pad with.</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out
  </dt>
  <dd>
    <p>- compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure. libAfterImage/transform/blur_asimage_gauss()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEblur_asimage_gauss()</h2>
        <div class="sectioncontent">
<p>Performs Gaussian blurr of the image ( useful for drop shadows and the likes ).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage* blur_asimage_gauss( ASVisual* asv, ASImage* src,</p>
<pre>
                             double horz, double vert,
                             ASAltImFormats out_format,
                             unsigned int compression_out,
                                int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- source ASImage</p>
  </dd>
  <dt>
    horz
  </dt>
  <dd>
    <p>- horizontal radius of the blurr</p>
  </dd>
  <dt>
    vert
  </dt>
  <dd>
    <p>- vertical radius of the blurr</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out
  </dt>
  <dd>
    <p>- compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure. libAfterImage/transform/fill_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEfill_asimage()</h2>
        <div class="sectioncontent">
<p>- Fills rectangle within the existing ASImage with specified color.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Bool fill_asimage( ASVisual *asv, ASImage *im,</p>
<pre>
                   int x, int y, int width, int height,
                   ARGB32 color );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    im
  </dt>
  <dd>
    <p>- ASImage to fill with the color</p>
  </dd>
  <dt>
    x,
  </dt>
  <dd>
    <p>y - left-top corner of the rectangle to fill.</p>
  </dd>
  <dt>
    width,
  </dt>
  <dd>
    <p>height - size of the rectangle to fill.</p>
  </dd>
  <dt>
    color
  </dt>
  <dd>
    <p>- ARGB32 color value to fill rectangle with.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>True on success, False on failure. libAfterImage/transform/adjust_asimage_hsv()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEadjust_asimage_hsv()</h2>
        <div class="sectioncontent">
<p>- adjusts image color properties in HSV colorspace</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *adjust_asimage_hsv( ASVisual *asv, ASImage *src,</p>
<pre>
                             int offset_x, int offset_y,
                             unsigned int to_width,
                             unsigned int to_height,
                             unsigned int affected_hue,
                             unsigned int affected_radius,
                             int hue_offset, int saturation_offset,
                             int value_offset,
                             ASAltImFormats out_format,
                             unsigned int compression_out, int quality);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- ASImage to adjust colors of.</p>
  </dd>
  <dt>
    offset_x,
  </dt>
  <dd>
    
  </dd>
  <dt>
    offset_y
  </dt>
  <dd>
    <p>- position on infinite surface tiled with original image, of the left-top corner of the area to be used for new image.</p>
  </dd>
  <dt>
    to_width,
  </dt>
  <dd>
    
  </dd>
  <dt>
    to_height
  </dt>
  <dd>
    <p>- size of the area of the original image to be used for new image.</p>
  </dd>
  <dt>
    affected_hue
  </dt>
  <dd>
    <p>- hue in degrees in range 0-360. This allows one to limit impact of color adjustment to affect only limited range of hues.</p>
  </dd>
  <dt>
    affected_radius
  </dt>
  <dd>
    <p>Sets the diapason of the range of affected hues.</p>
  </dd>
  <dt>
    hue_offset
  </dt>
  <dd>
    <p>- value by which to change hues in affected range.</p>
  </dd>
  <dt>
    saturation_offset
  </dt>
  <dd>
    <p>- value by which to change saturation of the pixels in affected hue range.</p>
  </dd>
  <dt>
    value_offset
  </dt>
  <dd>
    <p>- value by which to change Value(brightness) of pixels in affected hue range.</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out-
  </dt>
  <dd>
    <p>compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns newly created and encoded ASImage on success, NULL of failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This function will tile original image to specified size with offsets requested, and then it will go though it and adjust hue, saturation and value of those pixels that have specific hue, set by affected_hue/ affected_radius parameters. When affected_radius is greater then 180 entire image will be adjusted. Note that since grayscale colors have no hue - the will not get adjusted. Only saturation and value will be adjusted in gray pixels. Hue is measured as an angle on a 360 degree circle, The following is relationship of hue values to regular color names : red      - 0 yellow   - 60 green    - 120 cyan     - 180 blue     - 240 magenta  - 300 red      - 360</p><p>All the hue values in parameters will be adjusted to fall withing 0-360 range. libAfterImage/transform/colorize_asimage_vector()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcolorize_asimage_vector()</h2>
        <div class="sectioncontent">
<p>creates ASImage from double precision indexed image data - useful for scientific visualisation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Bool colorize_asimage_vector( ASVisual *asv, ASImage *im,</p>
<pre>
                                 ASVectorPalette *palette,
                              ASAltImFormats out_format,
                              int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    im
  </dt>
  <dd>
    <p>- ASImage to update.</p>
  </dd>
  <dt>
    palette
  </dt>
  <dd>
    <p>- palette to be used in conversion of double precision values into colors.</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>True on success, False on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This function will try to convert double precision indexed image data into actuall color image using palette. Original data should be attached to ASImage using vector member. Operation is relatively fast and allows representation of scientific data as color image with dynamically changing palette. libAfterImage/transform/create_asimage_from_vector()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_asimage_from_vector()</h2>
        <div class="sectioncontent">
<p>- convinience function allowing to create new ASImage, set its vector data and colorize it using palette - all in one step.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *create_asimage_from_vector( ASVisual *asv, double *vector,</p>
<pre>
                                     unsigned int width,
                                     unsigned int height,
                                     ASVectorPalette *palette,
                                     ASAltImFormats out_format,
                                     unsigned int compression,
                                     int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    vector
  </dt>
  <dd>
    <p>- data to be attached to new ASImage and used to generate RGB image</p>
  </dd>
  <dt>
    width,
  </dt>
  <dd>
    <p>height - size of the new image.</p>
  </dd>
  <dt>
    palette
  </dt>
  <dd>
    <p>- palette to be used in conversion of double precision values into colors.</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.</p>
  </dd>
  <dt>
    compression_out-
  </dt>
  <dd>
    <p>compression level of resulting image in range 0-100.</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>New ASImage  on success, NULL on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO transform&hellip;</h2>
        <div class="sectioncontent">
<p>colorize_asimage_vector(), create_asimage(), set_asimage_vector() libAfterImage/transform/slice_asimage2()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEslice_asimage2()</h2>
        <div class="sectioncontent">
<p>- slice ASImage leaving its corners intact, and scaling the middle part.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage* slice_asimage2( ASVisual *asv, ASImage *src,</p>
<pre>
            int slice_x_start, int slice_x_end,
            int slice_y_start, int slice_y_end,
            int to_width,
            int to_height,
            Bool scaled,
            ASAltImFormats out_format,
            unsigned int compression_out, int quality );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to valid ASVisual structure</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- source ASImage.</p>
  </dd>
  <dt>
    slice_x_start
  </dt>
  <dd>
    <p>- ending of the left corners</p>
  </dd>
  <dt>
    slice_x_end
  </dt>
  <dd>
    <p>- beginning of the right corners</p>
  </dd>
  <dt>
    slice_y_start
  </dt>
  <dd>
    <p>- ending of the top corners</p>
  </dd>
  <dt>
    slice_y_end
  </dt>
  <dd>
    <p>- beginning of the bottom corners</p>
  </dd>
  <dt>
    to_width
  </dt>
  <dd>
    <p>- width of the generated image;</p>
  </dd>
  <dt>
    to_height
  </dt>
  <dd>
    <p>- height of the generated image;</p>
  </dd>
  <dt>
    scaled
  </dt>
  <dd>
    <p>- if True - middle part of the image will be scaled, otherwise - tiled;</p>
  </dd>
  <dt>
    out_format
  </dt>
  <dd>
    <p>- optionally describes alternative ASImage format that should be produced as the result - XImage, ARGB32, etc.;</p>
  </dd>
  <dt>
    compression_out-
  </dt>
  <dd>
    <p>compression level of resulting image in range 0-100;</p>
  </dd>
  <dt>
    quality
  </dt>
  <dd>
    <p>- output quality.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>New ASImage  on success, NULL on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO transform&hellip;</h2>
        <div class="sectioncontent">
<p>scale_asimage(), tile_asimage()</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="import.3x.html"><span aria-hidden="true">&larr;</span> import.3x: Import- functionality for reading images from files libafterimage/import.h</a></li>
   <li class="next"><a href="ximage.3x.html">ximage.3x: Ximage- functionality for displaying asimages on x display libafterimage/ximage.h <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

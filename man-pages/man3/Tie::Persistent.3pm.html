<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tie::Persistent: Persistent data structures via tie made easy</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Persistent data structures via tie made easy">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Tie::Persistent (3pm) manual">
  <meta name="twitter:description" content="Persistent data structures via tie made easy">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtie-persistent-perl-Tie::Persistent-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Tie::Persistent.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Tie::Persistent (3pm) manual" />
  <meta property="og:description" content="Persistent data structures via tie made easy" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtie-persistent-perl-Tie::Persistent-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Tie::Persistent<small> (3pm)</small></h1>
        <p class="lead">Persistent data structures via tie made easy</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Tie::Persistent.3pm.html">
      <span itemprop="name">Tie::Persistent: Persistent data structures via tie made easy</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtie-persistent-perl/">
      <span itemprop="name">libtie-persistent-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Tie::Persistent.3pm.html">
      <span itemprop="name">Tie::Persistent: Persistent data structures via tie made easy</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>1.00</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Tie::Persistent;

 tie %DB, &apos;Tie::Persistent&apos;, &apos;file&apos;, &apos;rw&apos;; # read data from &apos;file&apos;

 (tied %DB)-&gt;<strong>autosync</strong>(1);       # turn on write back on every modify

 # now create/add/modify datastruct
 $DB{key} = "value";
 (tied %DB)-&gt;sync();            # can be called manually

 untie %DB;                     # stores data back into &apos;file&apos;

 # read stored data, no modification of file data
 tie %ReadOnly, &apos;Tie::Persistent&apos;, &apos;file&apos;;
 foreach (keys %ReadOnly) {
   print "$_ =&gt; $ReadOnly{$_}&#92;n";
 }
 untie %ReadOnly;               # modifications not stored back
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The Tie::Persistent package makes working with persistent data real easy by using the \*(C`tie\*(C' interface.</p><p>It works by storing data contained in a variable into a file (not unlike a database). The primary advantage is speed, as the whole datastructure is kept in memory (which is also a limitation), and, of course, that you can use arbitrary data structures inside the variable (unlike DB_File).</p><p>Note that it is most useful if the data structure fits into memory. For larger data structures I recommend \s-1MLDBM\s0.</p><p>If you want to make an arbitrary object persistent, just store its ref in a scalar tied to 'Tie::Persistent'.</p><p><strong>Beware</strong>: not every data structure or object can be made persistent. For example, it may not contain \s-1GLOB\s0 or \s-1CODE\s0 refs, as these are not really dumpable (yet?).</p><p>Also, it works only for variables, you cannot use it for file handles.</p><p>[A persistent file handle? Hmmm... Hmmm! I've got an idea: I could start a server and send the file descriptor to it via ioctl(\s-1FD_SEND\s0) or sendmsg.  Later, I could retrieve it back, so it's persistent as long as the server process keeps running.  But the whole file handle may contain more than just the file descriptor.  There may be an output routine associated with it that I'd somehow have to dump. Now let's see, there was some way to get the bytecode converted back into perl code... &lt;wanders off into the darkness mumbling&gt; ... ]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARAMETERS</h2>
        <div class="sectioncontent">
<p>\*(C`tie\*(C' %Hash,   'Tie::Persistent', <strong>file</strong>, <strong>mode</strong>, <em>other...</em>;</p><p>\*(C`tie\*(C' @Array,  'Tie::Persistent', <strong>file</strong>, <strong>mode</strong>, <em>other...</em>;</p><p>\*(C`tie\*(C' $Scalar, 'Tie::Persistent', <strong>file</strong>, <strong>mode</strong>, <em>other...</em>;</p>
<dl class='dl-vertical'>
  <dt>
    <strong>file</strong>
  </dt>
  <dd>
    <p>Filename to store the data in. No naming convention is enforced, but I personally use the suffix 'pd' for \*(L"Perl Data\*(R" (or \*(L"Persistent Data\*(R"?). No file locking is done; see the section on locking below.</p>
  </dd>
  <dt>
    <strong>mode</strong> (optional)
  </dt>
  <dd>
    <p>Same as mode for \s-1POSIX\s0 <em>fopen()</em> or IO::File::open. Basically a combination of 'r', 'w', 'a' and '+'. Semantics:  &apos;r&apos; .... read only. Modifications in the data are not stored back           into the file. A non-existing file gives an error. This is           the default if no mode is given.</p><p> &apos;rw&apos; ... read/write. Modifications are stored back, if the file does           not exist, it is created.</p><p> &apos;w&apos; .... write only. The file is not read, the variable starts out empty.</p><p> &apos;a&apos;, &apos;+&apos; ... append. Same as &apos;w&apos;, but creates numbered backup files.</p><p> &apos;ra&apos;, &apos;r+&apos; ... Same as &apos;rw&apos;, but creates numbered backup files. When some kind of write access is specified, a backup file of the old dataset is always created. [You'll thank me for that, believe me.] The reason is simple: when you tie a variable read-write (the contents get restored from the file), and your program isn't fully debugged yet, it may die in the middle of some modifications, but the data will still be written back to the file, possibly leaving them inconsistent. Then you always have at least the previous version that you can restore from. The default backup filenames follow the Emacs notation, i.e. a '~' is appended; for numbered backup files (specified as 'a' or '+'), an additional number and a '~' is appended. For a file 'data.pd', the normal backup file would be 'data.pd~' and the numbered backup files would be 'data.pd~1~', 'data.pd~2~' and so on. The latest backup file is the one with the highest number. The backup filename format can be overridden, see below.</p>
  </dd>
  <dt>
    <em>other</em> (optional, experimental)
  </dt>
  <dd>
    <p>This can be a reference to another (possibly tied) variable or a name of another tieable package. If a ref is given, it is used internally to store the variable data instead of an anonymous variable ref. This allows to make other tied datastructures persistent, e.g. you could first tie a hash to Tie::IxHash to make it order-preserving and then give it to Tie::Persistent to make it persistent. A plain name is used to create this tied variable internally. Trailing arguments are passed to the other tieable package. Example:  tie %h, &apos;Tie::Persistent&apos;, &apos;file&apos;, &apos;rw&apos;, &apos;Tie::IxHash&apos;; or  tie %ixh, &apos;Tie::IxHash&apos;;  tie %ph,  &apos;Tie::Persistent&apos;, &apos;file&apos;, &apos;w&apos;, &#92;%ixh;  # you can now use %ixh as an alias for %ph <strong>\s-1NOTE\s0</strong>: This is an experimental feature. It may or may not work with other Tie:: packages. I have only tested it with 'Tie::IxHash'. Please report success or failure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOCKING</h2>
        <div class="sectioncontent">
<p>The data file is not automatically locked. Locking has to be done outside of the package. I recommend using a module like 'Lockfile::Simple' for that.</p><p>There are typical two scenarios for locking: you either lock just the 'tie' and/or 'untie' calls, but not the data manipulation, or you lock the whole 'tie' - modify data - 'untie' sequence.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KEEPING DATA SYCHRONIZED</h2>
        <div class="sectioncontent">
<p>It often is useful to store snapshots of the tied data struct back to the file, e.g. to safeguard against program crashes.  You have two possibilities to do that:</p><ul>
<li><p>use <em>sync()</em> to do it manually or</p></li><li><p>set <em>autosync()</em> to do it on every modification.</p></li>
</ul><p>Note that <em>sync()</em> and <em>autosync()</em> are methods of the tied object, so you have to call them like this:</p><p> (tied %hash)-&gt;sync();</p><p>and</p><p> (tied @array)-&gt;<strong>autosync</strong>(1);  # or &apos;0&apos; to turn off autosync</p><p>There is a global variable $Autosync (see there) that you can set to change the behaviour on a global level for all subsequent ties.</p><p>Enabling autosync of course means a quite hefty performance penalty, so think carefully if and how you need it.  Maybe there are natural synchronisation points in your application where a manual sync is good enough.  Alternatively use \s-1MLDBM\s0 (if your top-level struct is a hash).</p><p>Note: autosync only works if the top-level element of the data structure is modified.  If you have more complex data structures and modify elements somewhere deep down, you have to synchronize manually. I therefore recommend the following approach, especially if the topmost structure is a hash:</p><ul>
<li><p>fetch the top-level element into a temporary variable</p></li><li><p>modify the datastructure</p></li><li><p>store back the top-level element, thus triggering a sync.</p></li>
</ul><p>E.g.</p><p>  my $ref = $Hash{$key};      # fetch substructure   $ref-&gt;{$subkey} = $newval;  # modify somewhere down under   $Hash{$key} = $ref;         # store back</p><p>This programming style has the added advantage that you can switch over to other database packages (for example the \s-1MLDBM\s0 package, in case your data structures outgrow your memory) quite easily by just changing the 'tie' line!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION VARIABLES</h2>
        <div class="sectioncontent">
<p><strong></strong><strong>$Tie::Persistent::Readable</strong><strong></strong> controls which format to use to store the data inside the file. 'false' means to use 'Storable', which is faster (and the default), 'true' means to use 'Data::Dumper', which is slower but much more readable and thus meant for debugging.  This only influences the way the datastructure is <em>written</em>, format detection on read is automatic.</p><p><strong></strong><strong>$Tie::Persistent::Autosync</strong><strong></strong> gives the default for all tied vars, so modifying it affects all subsequent ties.  It's set to 'false' by default.</p><p><strong></strong><strong>$Tie::Persistent::BackupFile</strong><strong></strong> points to a sub that determines the backup filename format. It gets the filename as $_[0] and returns the backup filename. The default is</p><p> sub { "$_[0]~"; }</p><p>which is the Emacs backup format. For \s-1NT\s0, you might want to change this to</p><p> sub { "$_[0].bak"; }</p><p>or something.</p><p><strong></strong><strong>$Tie::Persistent::NumberedBackupFile</strong><strong></strong> points to a sub that determines the numbered backup filename format. It gets the filename and a number as $_[0] and $_[1] respectively and returns the backup filename. The default is</p><p> sub { "$_[0]~$_[1]~"; }</p><p>which is the extended Emacs backup format.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<ul>
<li><p>'Tie::Persistent' uses 'Storable' and 'Data::Dumper' internally, so these must be installed (the \s-1CPAN\s0 module will do this for you automatically).  Actually, 'Storable' is optional but recommended for speed.</p></li><li><p>For testing, I use 'Tie::IxHash', but 'make test' still does some tests if it is not installed.</p></li><li><p>There are two mailing lists at SourceForge.net: http://lists.sourceforge.net/mailman/listinfo/persistent-announce for announcements of new releases. http://lists.sourceforge.net/mailman/listinfo/persistent-discuss for user feedback and feature discussions.</p></li><li><p>The package is available through \s-1CPAN\s0 and SourceForge.net http://sourceforge.net/projects/persistent/</p></li><li><p>There is an initiative at SourceForge.net to get authors of persistence-packages of any kind to talk to one another. See http://sourceforge.net/projects/POOP/</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Numbered backupfile creation might have problems if the filename (not the backup number) contains the first six digits of the speed of light (in m/s).</p><p>All other bugs, please tell me!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Original version by Roland Giersig &lt;RGiersig@cpan.org&gt;</p><p>Benjamin Liberman &lt;beanjamman@yahoo.com&gt; added autosyncing and fixed splice.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 1999-2002 Roland Giersig. All rights reserved.  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Tie::Persistent&hellip;</h2>
        <div class="sectioncontent">
<p>Storable, Data::Dumper, \s-1MLDBM\s0.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Tie::IxHash.3pm.html"><span aria-hidden="true">&larr;</span> Tie::IxHash.3pm: Ordered associative arrays for perl</a></li>
   <li class="next"><a href="Tie::RefHash::Weak.3pm.html">Tie::RefHash::Weak.3pm: A tie::refhash subclass with weakened references in the keys. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

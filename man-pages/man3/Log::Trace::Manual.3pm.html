<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Log::Trace::Manual: A guide to using log::trace</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A guide to using log::trace">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Log::Trace::Manual (3pm) manual">
  <meta name="twitter:description" content="A guide to using log::trace">
  <meta name="twitter:image" content="https://www.carta.tech/images/liblog-trace-perl-Log::Trace::Manual-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Log::Trace::Manual.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Log::Trace::Manual (3pm) manual" />
  <meta property="og:description" content="A guide to using log::trace" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/liblog-trace-perl-Log::Trace::Manual-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Log::Trace::Manual<small> (3pm)</small></h1>
        <p class="lead">A guide to using log::trace</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Log::Trace::Manual.3pm.html">
      <span itemprop="name">Log::Trace::Manual: A guide to using log::trace</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/liblog-trace-perl/">
      <span itemprop="name">liblog-trace-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Log::Trace::Manual.3pm.html">
      <span itemprop="name">Log::Trace::Manual: A guide to using log::trace</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is a brief guide to how you can use the Log::Trace module in your scripts and modules.  The \*(C`Log::Trace\*(C' documentation has a comprehensive list of options.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">The basics</h2>
        <div class="sectioncontent">
<p>You can enable tracing by specifying the tracing target via the '\*(C`use\*(C'' statement or at runtime via the \*(C`import()\*(C' method.  In most cases, you'll want to keep the code that enables tracing in a single point, usually the main script of your application.  In general, modules should avoid directly setting tracing options.</p><h3>using Log::Trace in your scripts</h3>
<p>Here's a slightly contrived example which demonstrates the \*(C`TRACE\*(C', \*(C`TRACEF\*(C', \*(C`DUMP\*(C' and \*(C`TRACE_HERE\*(C' functions:</p>
<pre>
        #!/usr/bin/perl -w
        use strict;
        use Another::Module;
        use Log::Trace log =&gt; &apos;/var/log/myapp.log&apos;;

        TRACE("-------- Starting archiver ---------");
        TRACEF("We are going to try to archive %d items", scalar @ARGV);
        DUMP("List of things to archive", &#92;@ARGV);
        archive_em($_) foreach(@ARGV);

        sub archive_em {
                TRACE_HERE();
                my $thing = shift;
                unless (Another::Module::check_safe($thing)) {
                        warn "bad chars in: $thing";
                        return;
                }
                rename $thing, $thing.".archive" or warn "Couldn&apos;t archive $thing: $!";
                TRACE("Tried to archive $thing");
        }
</pre>
<p>Note the way \*(C`Log::Trace\*(C' is imported.  The import list controls where the output of the four tracing functions goes.  Instead we could have done:</p><p>        use Log::Trace qw(warn);</p><p>and the trace output would have gone to \s-1STDERR\s0.</p>
<h3>Using Log::Trace with modules</h3>
<p>In the previous example, tracing was enabled only in the main script.  Now we'll see how to enable tracing in \*(C`Another::Module\*(C' at the same time.</p><p>First, \*(C`Another::Module\*(C' needs to define a \*(C`TRACE\*(C' subroutine.  It may also define \*(C`TRACEF\*(C', \*(C`TRACE_HERE\*(C' and \*(C`DUMP\*(C' stubs.  It can do that simply by using \*(C`Log::Trace\*(C'.  However, if \*(C`Another::Module\*(C' defines its own stub tracing functions, we can remove the dependency on \*(C`Log::Trace\*(C'.</p><p>        package Another::Module;</p><p>        sub check_safe {my_routine {                 my $filename = shift;                 TRACE("Checking that &apos;$filename&apos; has safe characters");                 return $filename =~ /^([&#92;w.&#92;-/]+)$/         }</p><p>        sub my_other_routine {                 TRACE_HERE();         }</p><p>        # tracing stubs         sub TRACE {}         sub TRACE_HERE {}</p><p>Now, in the main script, we can change the '\*(C`use\*(C'' statement so tracing will be enabled in \*(C`Another::Module\*(C':</p><p>        use Log::Trace log =&gt; &apos;/var/log/myapp.log&apos;, {Deep =&gt; 1};</p><p>By default, the \*(C`Deep\*(C' option will force \*(C`Log::Trace\*(C' to export tracing functions to any modules that define a \*(C`TRACE\*(C' subroutine.  That includes modules that are not directly used by the main script.  But this behaviour can be relaxed or tightened with other options.  See \*(L"Deep import\*(R" for examples.</p><p>Adding \*(C`TRACE\*(C' and other stub functions to your module is an <em>Interface Contract</em> between your module and Log::Trace (in some software circles this might be given a name such as ISupportsTracing).  Of course you can write other code that takes advantage of this interface completely independent of Log::Trace, e.g.</p><p>        use Another::Module;         if($ENV{DEBUG}) {                 *Another::Module::TRACE = sub {print "TRACE: ".join("&#92;t",@_)."&#92;n"};         }</p>
<h3>Error handling</h3>
<p>Since \*(C`Log::Trace\*(C' is designed with debugging in mind, all tracing failures are non-fatal, so allowing normal execution to continue.  However, Log::Trace will report to \s-1STDERR\s0 that a problem has occurred.</p><p>For example, this code:</p><p>        use Log::Trace file =&gt; &apos;/myapp.log&apos;;         TRACE(&apos;Running&apos;);         print "Hello World!&#92;n";</p><p>Will produce this output:</p><p>        Log::Trace: Cannot open /myapp.log : Permission denied at lib/Log/Trace.pm line &lt;nnn&gt;.         Hello World!</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Cookbook</h2>
        <div class="sectioncontent">
<h3>Enabling tracing on the command line</h3>
<p>You can invoke tracing on the command line:</p><p>        perl -MLog::Trace=print -e "TRACE(&apos;hello&apos;)"         perl -MLog::Trace=warn -e "TRACE(&apos;hello&apos;)"         perl -MLog::Trace=log,test.log -e "TRACE(&apos;hello&apos;)"</p><p>However you can't apply this approach to scripts that use \*(C`Log::Trace\*(C' or define a \*(C`TRACE\*(C' stub as these will clobber *main::TRACE set up by -M when they are compiled.  Fortunately it is straightforward to write your command-line scripts so you can, for example, get trace output with -t and deep trace output with -T:</p><p>        use Log::Trace;         use Getopt::Std;         use MyModule;</p><p>        use vars qw($opt_t $opt_T);         getopts("tT");</p><p>        # tracing         import Log::Trace &apos;print&apos; if $opt_t;         import Log::Trace &apos;print&apos; =&gt; {Deep =&gt; 1} if $opt_T;</p><p>        do_something_involving_tracing();</p>
<h3>Sending \s-1TRACE\s0 output to browser in \s-1CGI\s0</h3>
<p>Whilst tracing to a log file or \*(C`STDERR\*(C' is tolerable for CGIs, it's often far more convenient to return the tracing information back to the browser of the client-side developer.</p><p>        use CGI;</p><p>        use constant DEV_SERVER =&gt; 1;</p><p>        my $trace_buffer;         if(DEV_SERVER && CGI::param(&apos;Tracing&apos;)) {                 require Log::Trace;                 import Log::Trace buffer =&gt; &#92;$trace_buffer, {Deep =&gt; 1};         }</p><p>        my $output = do_everything();</p><p>        print CGI::header();         print $output;         if (DEV_SERVER && $trace_buffer)         {                 print "&#92;n&#92;n", "&lt;pre&gt;", CGI::escapeHTML($trace_buffer), "&lt;/pre&gt;";         }</p><p>You should remember to change the \*(C`DEV_SERVER\*(C' constant when releasing the \s-1CGI\s0 to a production environment.</p>
<h3>Log levels</h3>
<p>\*(C`Log::Trace\*(C' can filter the tracing output by referring to the logging level. The logging level is defined when you enable tracing.  \*(C`Log::Trace\*(C' doesn't impose any conventions on the levels.  The default levels implementation requires that the levels be numeric, but that can be overriden.</p><p>In the simplest case, you can specify the level as a threshold value:</p><p>        use Log::Trace print =&gt; {Level =&gt; 3};</p><p>In this example, all trace messages at level 3 or below will be output.</p><p>You can also specify a list of valid levels:</p><p>        use Log::Trace print =&gt; {Level =&gt; [0 .. 3, 7]};</p><p>All the tracing functions accept a hash as an optional first parameter where you can specify the level for that trace message.  E.g.:</p><p>        TRACE({Level =&gt; 4}, "This is a warning");         TRACEF({Level =&gt; 6}, "%d items found", scalar @items);         TRACE_HERE({Level =&gt; 10});         DUMP({Level =&gt; 8}, &apos;Retrieved data&apos;, &#92;%data);</p><p>\*(C`DUMP\*(C' is designed to accept a hash as its first parameter, but there may be cases where you wish to dump a hash that contains a \*(C`Level\*(C' key.  In those cases, you can take advantage of the return value of \*(C`DUMP()\*(C':</p><p>        my $dumped = DUMP({Level =&gt; 1, Health =&gt; &apos;0.68&apos;});         TRACE({Level =&gt; 8}, &apos;Game stats&apos;, $dumped);</p><p>If you specify a tracing level when you enable \*(C`Log::Trace\*(C', then tracing messages that do not specify a level will not be output, unless you include \*(C`undef\*(C' in the trace levels:</p><p>        use Log::Trace print =&gt; {Level =&gt; [3, undef]};         TRACE("This is level undef, and will be output");         TRACE({Level =&gt; 3}, "This will also be output");         TRACE({Level =&gt; 8}, "... but this won&apos;t");</p><p>Here are some sample tracing levels (borrowed from Log::Agent) which you can use as a guide:</p><p>        0       emergency         1       alert         2       critical         3       error         4       warning         6       notice         8       info         10      debug</p>
<h3>Fine-tuning deep import</h3>
<p>Occasionally you won't want to see the trace output from \s-1ALL\s0 your modules in your application.  For example your application may give a module a huge data structure or call it in a long loop.  The \*(C`Exclude\*(C' option allows you to mask out one or more modules.</p><p>        use Log::Trace warn =&gt; {&apos;Deep&apos; =&gt; 1, &apos;Exclude&apos; =&gt; &apos;MyVerboseModule&apos;};</p><p>or</p><p>        use Log::Trace warn =&gt; {&apos;Deep&apos; =&gt; 1, &apos;Exclude&apos; =&gt; [&apos;MyVerboseModule&apos;, &apos;Another::Module&apos;]};</p><p>Conversely you can use an opt-in approach rather than opt-out.  The \*(C`Match\*(C' option allows a regular expression to be used to select which packages are initialised by Log::Trace.  For example:</p><p>        use Log::Trace print =&gt; {&apos;Deep&apos; =&gt; 1, &apos;Match&apos; =&gt; qr/^MySubSystem::/};</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Advanced features</h2>
        <div class="sectioncontent">
<h3>Issues with the order of importing</h3>
<p>When the Deep or Everywhere options are used, Log::Trace is imported into all the packages which have been compiled so far.</p><p>        use Package::Foo;         use Log::Trace (&apos;print&apos; =&gt; {Deep =&gt; 1});         use Package::Bar; #Compiled after Log::Trace is imported</p><p>In this example, the \s-1TRACE\s0 function in Package::Bar won't be overridden.  It's trivial to swap the order in the example above so that Log::Trace is the last module used, but suppose you have a module (such as a factory) that loads others on demand:</p><p>        package MyApp::Reader;         sub new {                 my $package = shift;                 my $type = shift;                 die unless($type =~ /^MyApp::Reader::&#92;w+$/);                 eval "require $type";                 die($@) if($@);                 return $type-&gt;new(@_);         }</p><p>How do you ensure Log::Trace gets imported into the backend MyApp::Reader::* modules (without polluting all your modules with Log::Trace::import calls)?</p>
<dl class='dl-vertical'>
  <dt>
    Using the (experimental) AutoImport feature
  </dt>
  <dd>
    <p>The AutoImport feature will override \*(C`CORE::require\*(C' so that from now on any modules that are loaded will have the Log::Trace import run against them:         use Log::Trace(&apos;log&apos; =&gt; &apos;/var/log/myapp.log&apos;, {&apos;Deep&apos; =&gt; 1, &apos;AutoImport&apos; =&gt; 1}); This only works with recent versions of perl (see the \s-1ENVIRONMENT\s0 \s-1NOTES\s0 in Log::Trace).</p>
  </dd>
  <dt>
    Getting the factory to wire the components it produces
  </dt>
  <dd>
    <p>A more \*(L"low-tech\*(R" approach that works with all versions of perl is to get the factory to attach the stub functions of the modules it loads to whatever its own stub functions have been wired to by the caller.         package MyApp::Reader;         sub new {                 my $package = shift;                 my $type = shift;                 die unless($type =~ /^MyApp::Reader::&#92;w+$/);                 eval "require $type";                 die($@) if($@);</p><p>                # Wire the component we&apos;ve created into whatever                 # our TRACE etc function has been wired to                 *{"$type&#92;::TRACE"} = &#92;&MyApp::Reader::TRACE;                 *{"$type&#92;::DUMP"} = &#92;&MyApp::Reader::DUMP;</p><p>                return $type-&gt;new(@_);         }</p>
  </dd>

</dl>

<h3>Custom \s-1TRACE\s0 functions</h3>
<p>If \*(C`STDOUT\*(C', \*(C`STDERR\*(C', \*(C`syslog\*(C', a file, a file handle, or a buffer is not to your liking then the custom method is for you.</p><p>Suppose you want to send your Log::Trace output into a database:</p><p>        our $sth;         $sth = setup_logging_statement();</p><p>        use Log::Trace custom =&gt; &#92;&log_to_database;</p><p>        sub log_to_database {</p><p>                #TRACE can get any number of arguments                 my $message = join(",", @_);</p><p>                $sth-&gt;execute($message);</p><p>        }</p>
<h3>Controlling \s-1DUMP\s0 output</h3>
<p>By default, Data::Dumper is used with a fixed set of options for \s-1DUMP\s0 output. You can choose a different serialiser using the \*(C`Dumper\*(C' option:</p><p>        import Log::Trace(&apos;print&apos; =&gt; {Dumper =&gt; "YAML"}});</p><p>Where the string refers to a Data::Serializer::* backend. You can also control the options passed to the Data::Serializer backend (and thus customise the \s-1DUMP\s0 output) by passing a hashref of Data::Serializer contructor options:</p><p>        import Log::Trace(&apos;print&apos; =&gt; {Dumper =&gt; {                 serializer =&gt; &apos;XML::Dumper&apos;,                 options =&gt; {                         dtd =&gt; &apos;path/to/my.dtd&apos;                 }         }});</p><p>At the time of writing, not all the configuration options of the underlying serialisation modules are exposed via their Data::Serializer wrappers. If you find this a limitation, please contribute patches to extend these modules as this will benefit a number of other modules that make use of the Data::Serializer \s-1API\s0.</p>
<h3>Execution path vs. profiling</h3>
<p>You can use the \*(C`AllSubs\*(C' tracing option to trace the execution path through each subroutine.  By default \*(C`Log::Trace\*(C' only wraps each subroutine in packages with \*(C`TRACE\*(C' defined.  You can force it to do it to all modules using the \*(C`Everywhere\*(C' option.  The following:</p><p>        use Data::Dumper;         use Log::Trace print =&gt; {AllSubs =&gt; 1, Verbose =&gt; 1, Everywhere =&gt; 1, Exclude =&gt; &apos;Config&apos;};         Data::Dumper-&gt;Dumpperl([[4]]);</p><p>generates the output:</p><p>        main::_\|_ANON_\|_ (3) :: Data::Dumper::Dumpperl(  )         Data::Dumper::Dumpperl (3) :: Data::Dumper::new(  )         Data::Dumper::Dumpperl (3) :: Data::Dumper::_dump( Data::Dumper, ... )         Data::Dumper::_dump (205) :: overload::StrVal( ARRAY, ... )         overload::StrVal (239) :: overload::OverloadedStringify( ARRAY, ... )         overload::OverloadedStringify (92) :: overload::mycan(  )         overload::OverloadedStringify (92) :: overload::ov_method(      )         overload::OverloadedStringify (92) :: overload::mycan(  )         overload::OverloadedStringify (92) :: overload::ov_method(      )         overload::OverloadedStringify (92) :: overload::mycan(  )         overload::OverloadedStringify (92) :: overload::ov_method(      )         overload::OverloadedStringify (92) :: overload::mycan(  )         overload::OverloadedStringify (92) :: overload::ov_method(      )         Data::Dumper::_dump (205) :: Data::Dumper::_dump( Data::Dumper, ... )         (eval) (0) :: Data::Dumper::DESTROY( Data::Dumper, ... )</p>
<h3>Targeting one module</h3>
<p>You may wonder \*(L"How do I trace what's going on in module Acme::Foo I downloaded from \s-1CPAN\s0 that isn't Log::Trace enabled?\*(R". Assuming the module doesn't have any other kind of tracing that you can hook into, all you can do is use the \*(C`AllSubs\*(C' approach. Assuming that's \s-1OK\s0, you can restrict this to just the offending module with:</p><p>        use Log::Trace print =&gt; {AllSubs =&gt; 1, Everywhere =&gt; 1, Match =&gt; qr/^Acme:Foo$/};</p>
<h3>Avoiding performance penalty</h3>
<p>Although the trace stubs don't do anything, they do incur a small function call overhead.  If this performance hit is unacceptable, you can use a constant to enable/disable all the \*(C`Log::Trace\*(C' statements in your code.  The test for the constant value will be optimised out at compile time so no runtime overhead is incurred if the constant has a false value:</p><p>        package ThrashMe;</p><p>        use constant TRACING_ENABLED =&gt; 1; #Set to zero to optimise</p><p>        sub performance_critical {                 TRACE("this may slow things down") if(TRACING_ENABLED);                 do_stuff();         }</p><p>        sub TRACE{}</p><p>        1;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REVISION</h2>
        <div class="sectioncontent">
<p>$Revision: 1.9 $</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Log::Trace.3pm.html"><span aria-hidden="true">&larr;</span> Log::Trace.3pm: Provides a unified approach to tracing</a></li>
   <li class="next"><a href="Logfile::Rotate.3pm.html">Logfile::Rotate.3pm: Perl module to rotate logfiles. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

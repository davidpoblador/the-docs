<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ORLite: Extremely light weight sqlite-specific orm</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Extremely light weight sqlite-specific orm">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ORLite (3pm) manual">
  <meta name="twitter:description" content="Extremely light weight sqlite-specific orm">
  <meta name="twitter:image" content="https://www.carta.tech/images/liborlite-perl-ORLite-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/ORLite.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ORLite (3pm) manual" />
  <meta property="og:description" content="Extremely light weight sqlite-specific orm" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/liborlite-perl-ORLite-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ORLite<small> (3pm)</small></h1>
        <p class="lead">Extremely light weight sqlite-specific orm</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/ORLite.3pm.html">
      <span itemprop="name">ORLite: Extremely light weight sqlite-specific orm</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/liborlite-perl/">
      <span itemprop="name">liborlite-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/ORLite.3pm.html">
      <span itemprop="name">ORLite: Extremely light weight sqlite-specific orm</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  package Foo;

  # Simplest possible usage

  use strict;
  use ORLite &apos;data/sqlite.db&apos;;

  my @awesome = Foo::Person-&gt;select(
     &apos;where first_name = ?&apos;,
     &apos;Adam&apos;,
  );

  package Bar;

  # All available options enabled or specified.
  # Some options shown are mutually exclusive,
  # this code would not actually run.

  use ORLite {
      package      =&gt; &apos;My::ORM&apos;,
      file         =&gt; &apos;data/sqlite.db&apos;,
      user_version =&gt; 12,
      readonly     =&gt; 1,
      create       =&gt; sub {
          my $dbh = shift;
          $dbh-&gt;do(&apos;CREATE TABLE foo ( bar TEXT NOT NULL )&apos;);
      },
      tables       =&gt; [ &apos;table1&apos;, &apos;table2&apos; ],
      cleanup      =&gt; &apos;VACUUM&apos;,
      prune        =&gt; 1,
  };
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>SQLite is a light single file \s-1SQL\s0 database that provides an excellent platform for embedded storage of structured data.</p><p>However, while it is superficially similar to a regular server-side \s-1SQL\s0 database, SQLite has some significant attributes that make using it like a traditional database difficult.</p><p>For example, SQLite is extremely fast to connect to compared to server databases (1000 connections per second is not unknown) and is particularly bad at concurrency, as it can only lock transactions at a database-wide level.</p><p>This role as a superfast internal data store can clash with the roles and designs of traditional object-relational modules like Class::DBI or DBIx::Class.</p><p>What this situation would seem to need is an object-relation system that is designed specifically for SQLite and is aligned with its idiosyncracies.</p><p>ORLite is an object-relation system specifically tailored for SQLite that follows many of the same principles as the ::Tiny series of modules and has a design and feature set that aligns directly to the capabilities of SQLite.</p><p>Further documentation will be available at a later time, but the synopsis gives a pretty good idea of how it works.</p><h3>How ORLite Works</h3>
<p>ORLite discovers the schema of a SQLite database, and then generates the code for a complete set of classes that let you work with the objects stored in that database.</p><p>In the simplest form, your target root package \*(L"uses\*(R" ORLite, which will do the schema discovery and code generation at compile-time.</p><p>When called, ORLite generates two types of packages.</p><p>Firstly, it builds database connectivity, transaction support, and other purely database level functionality into your root namespace.</p><p>Secondly, it will create one sub-package underneath the namespace of the root module for each table or view it finds in the database.</p><p>Once the basic table support has been generated, it will also try to load an \*(L"overlay\*(R" module of the same name. Thus, by created a Foo::TableName module on disk containing \*(L"extra\*(R" code, you can extend the original and add additional functionality to it.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>ORLite takes a set of options for the class construction at compile time as a \s-1HASH\s0 parameter to the \*(L"use\*(R" line.</p><p>As a convenience, you can pass just the name of an existing SQLite file to load, and ORLite will apply defaults to all other options.</p><p>  # The following are equivalent</p><p>  use ORLite $filename;</p><p>  use ORLite {       file =&gt; $filename,   };</p><p>The behaviour of each of the options is as follows:</p><h3>package</h3>
<p>The optional \*(C`package\*(C' parameter is used to provide the Perl root namespace to generate the code for. This class does not need to exist as a module on disk, nor does it need to have anything loaded or in the namespace.</p><p>By default, the package used is the package that is calling ORLite's import method (typically via the \*(C`use ORLite { ... }\*(C' line).</p>
<h3>file</h3>
<p>The compulsory \*(C`file\*(C' parameter (the only compulsory parameter) provides the path to the SQLite file to use for the \s-1ORM\s0 class tree.</p><p>If the file already exists, it must be a valid SQLite file match that supported by the version of DBD::SQLite that is installed on your system.</p><p>ORLite will throw an exception if the file does not exist, <strong>unless</strong> you also provide the \*(C`create\*(C' option to signal that ORLite should create a new SQLite file on demand.</p><p>If the \*(C`create\*(C' option is provided, the path provided must be creatable. When creating the database, ORLite will also create any missing directories as needed.</p>
<h3>user_version</h3>
<p>When working with ORLite, the biggest risk to the stability of your code is often the reliability of the SQLite schema structure over time.</p><p>When the database schema changes the code generated by ORLite will also change. This can easily result in an unexpected change in the \s-1API\s0 of your class tree, breaking the code that sits on top of those generated APIs.</p><p>To resolve this, ORLite supports a feature called schema version-locking.</p><p>Via the \*(C`user_version\*(C' SQLite pragma, you can set a revision for your database schema, increasing the number each time to make a non-trivial chance to your schema.</p><p>  SQLite&gt; PRAGMA user_version = 7</p><p>When creating your ORLite package, you should specificy this schema version number via the \*(C`user_version\*(C' option.</p><p>  use ORLite {       file         =&gt; $filename,       user_version =&gt; 7,   };</p><p>When connecting to the SQLite database, the \*(C`user_version\*(C' you provide will be checked against the version in the schema. If the versions do not match, then the schema has unexpectedly changed, and the code that is generated by ORLite would be different to the expected \s-1API\s0.</p><p>Rather than risk potentially destructive errors caused by the changing code, ORLite will simply refuse to run and throw an exception.</p><p>Thus, using the \*(C`user_version\*(C' feature allows you to write code against a SQLite database with high-certainty that it will continue to work. Or at the very least, that should the SQLite schema change in the future your code fill fail quickly and safely instead of running away and causing unknown behaviour.</p><p>By default, the \*(C`user_version\*(C' option is false and the value of the SQLite \*(C`PRAGMA user_version\*(C' will <strong>not</strong> be checked.</p>
<h3>readonly</h3>
<p>To conserve memory and reduce complexity, ORLite will generate the \s-1API\s0 differently based on the writability of the SQLite database.</p><p>Features like transaction support and methods that result in \*(C`INSERT\*(C', \*(C`UPDATE\*(C' and \*(C`DELETE\*(C' queries will only be added if they can actually be run, resulting in an immediate \*(L"no such method\*(R" exception at the Perl level instead of letting the application do more work only to hit an inevitable SQLite error.</p><p>By default, the \*(C`readonly\*(C' option is based on the filesystem permissions of the SQLite database (which matches SQLite's own writability behaviour).</p><p>However the \*(C`readonly\*(C' option can be explicitly provided if you wish. Generally you would do this if you are working with a read-write database, but you only plan to read from it.</p><p>Forcing \*(C`readonly\*(C' to true will halve the size of the code that is generated to produce your \s-1ORM\s0, reducing the size of any auto-generated \s-1API\s0 documentation using ORLite::Pod by a similar amount.</p><p>It also ensures that this process will only take shared read locks on the database (preventing the chance of creating a dead-lock on the SQLite database).</p>
<h3>create</h3>
<p>The \*(C`create\*(C' option is used to expand ORLite beyond just consuming other people's databases to produce and operating on databases user the direct control of your code.</p><p>The \*(C`create\*(C' option supports two alternative forms.</p><p>If \*(C`create\*(C' is set to a simple true value, an empty SQLite file will be created if the location provided in the \*(C`file\*(C' option does not exist.</p><p>If \*(C`create\*(C' is set to a \*(C`CODE\*(C' reference, this function will be executed on the new database <strong>before</strong> ORLite attempts to scan the schema.</p><p>The \*(C`CODE\*(C' reference will be passed a plain \s-1DBI\s0 connection handle, which you should operate on normally. Note that because \*(C`create\*(C' is fired before the code generation phase, none of the functionality produced by the generated classes is available during the execution of the \*(C`create\*(C' code.</p><p>The use of \*(C`create\*(C' option is incompatible with the \*(C`readonly\*(C' option.</p>
<h3>tables</h3>
<p>The \*(C`tables\*(C' option should be a reference to an array containing a list of table names. For large or complex SQLite databases where you only need to make use of a fraction of the schema limiting the set of tables will reduce both the startup time needed to scan the structure of the SQLite schema, and reduce the memory cost of the class tree.</p><p>If the \*(C`tables\*(C' option is not provided, ORLite will attempt to produce a class for every table in the main schema that is not prefixed with with \*(C`sqlite_\*(C'.</p>
<h3>cache</h3>
<p>  use ORLite {       file         =&gt; &apos;dbi:SQLite:sqlite.db&apos;,       user_version =&gt; 2,       cache        =&gt; &apos;cache/directory&apos;,   };</p><p>The \*(C`cache\*(C' option is used to reduce the time needed to scan the SQLite database table structures and generate the code for them, by saving the generated code to a cache directory and loading from that file instead of generating it each time from scratch.</p>
<h3>cleanup</h3>
<p>When working with embedded SQLite databases containing rapidly changing state data, it is important for database performance and general health to make sure you \s-1VACUUM\s0 or \s-1ANALYZE\s0 the database regularly.</p><p>The \*(C`cleanup\*(C' option should be a single literal \s-1SQL\s0 statement.</p><p>If provided, this statement will be automatically run on the database during \*(C`END\*(C'-time, after the last transaction has been completed.</p><p>This will typically either by a full &apos;VACUUM ANALYZE&apos; or the more simple &apos;VACUUM&apos;.</p>
<h3>prune</h3>
<p>In some situation, such as during test scripts, an application will only need the created SQLite database temporarily. In these situations, the \*(C`prune\*(C' option can be provided to instruct ORLite to delete the SQLite database when the program ends.</p><p>If any directories were made in order to create the SQLite file, these directories will be cleaned up and removed as well.</p><p>If \*(C`prune\*(C' is enabled, you should generally not use \*(C`cleanup\*(C' as any cleanup operation will be made pointless when \*(C`prune\*(C' deletes the file.</p><p>By default, the \*(C`prune\*(C' option is set to false.</p>
<h3>shim</h3>
<p>In some situtations you may wish to make extensive changes to the behaviour of the classes and methods generated by ORLite. Under normal circumstances all code is generated into the table class directly, which can make overriding method difficult.</p><p>The \*(C`shim\*(C' option will make ORLite generate all of it's methods into a separate \*(C`Foo::TableName::Shim\*(C' class, and leave the main table class \*(C`Foo::TableName\*(C' as a transparent subclass of the shim.</p><p>This allows you to alter the behaviour of a table class without having to do nasty tricks with symbol tables in order to alter or replace methods.</p><p>  package My::Person;</p><p>  # Write a log message when we create a new object   sub create {       my $class = shift;       my $self  = SUPER::create(@_);       my $name  = $self-&gt;name;       print LOG "Created new person &apos;$name&apos;&#92;n";       return $self;   }</p><p>The \*(C`shim\*(C' option is global. It will alter the structure of all table classes at once. However, unless you are making alterations to a class the impact of this different class structure should be zero.</p>
<h3>unicode</h3>
<p>You can use this option to tell ORLite that your database uses unicode.</p><p>At the moment, it just enables the \*(C`sqlite_unicode\*(C' option while connecting to your database. There'll be more in the future.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ROOT PACKAGE METHODS</h2>
        <div class="sectioncontent">
<p>All ORLite root packages receive an identical set of methods for controlling connections to the database, transactions, and the issueing of queries of various types to the database.</p><p>The example root package Foo::Bar is used in any examples.</p><p>All methods are static, ORLite does not allow the creation of a Foo::Bar object (although you may wish to add this capability yourself).</p><h3>dsn</h3>
<p>  my $string = Foo::Bar-&gt;dsn;</p><p>The \*(C`dsn\*(C' accessor returns the dbi connection string used to connect to the SQLite database as a string.</p>
<h3>dbh</h3>
<p>  my $handle = Foo::Bar-&gt;dbh;</p><p>To reliably prevent potential SQLite deadlocks resulting from multiple connections in a single process, each ORLite package will only ever maintain a single connection to the database.</p><p>During a transaction, this will be the same (cached) database handle.</p><p>Although in most situations you should not need a direct \s-1DBI\s0 connection handle, the \*(C`dbh\*(C' method provides a method for getting a direct connection in a way that is compatible with ORLite's connection management.</p><p>Please note that these connections should be short-lived, you should never hold onto a connection beyond the immediate scope.</p><p>The transaction system in ORLite is specifically designed so that code using the database should never have to know whether or not it is in a transation.</p><p>Because of this, you should <strong>never</strong> call the -&gt;disconnect method on the database handles yourself, as the handle may be that of a currently running transaction.</p><p>Further, you should do your own transaction management on a handle provided by the &lt;dbh&gt; method.</p><p>In cases where there are extreme needs, and you <strong>absolutely</strong> have to violate these connection handling rules, you should create your own completely manual \s-1DBI-\s0&gt;connect call to the database, using the connect string provided by the \*(C`dsn\*(C' method.</p><p>The \*(C`dbh\*(C' method returns a DBI::db object, or throws an exception on error.</p>
<h3>connect</h3>
<p>  my $dbh = Foo::Bar-&gt;connect;</p><p>The \*(C`connect\*(C' method is provided for the (extremely rare) situation in which you need a raw connection to the database, evading the normal tracking and management provided of the \s-1ORM\s0.</p><p>The use of raw connections in this manner is strongly discouraged, as you can create fatal deadlocks in SQLite if either the core \s-1ORM\s0 or the raw connection uses a transaction at any time.</p><p>To summarise, do not use this method unless you <strong>\s-1REALLY\s0</strong> know what you are doing.</p><p><strong>\s-1YOU\s0 \s-1HAVE\s0 \s-1BEEN\s0 \s-1WARNED\s0!</strong></p>
<h3>connected</h3>
<p>  my $active = Foo::Bar-&gt;connected;</p><p>The \*(C`connected\*(C' method provides introspection of the connection status of the library. It returns true if there is any connection or transaction open to the database, or false otherwise.</p>
<h3>begin</h3>
<p>  Foo::Bar-&gt;begin;</p><p>The \*(C`begin\*(C' method indicates the start of a transaction.</p><p>In the same way that ORLite allows only a single connection, likewise it allows only a single application-wide transaction.</p><p>No indication is given as to whether you are currently in a transaction or not, all code should be written neutrally so that it works either way or doesn't need to care.</p><p>Returns true or throws an exception on error.</p><p>While transaction support is always built for every ORLite-generated class tree, if the database is opened \*(C`readonly\*(C' the \*(C`commit\*(C' method will not exist at all in the \s-1API\s0, and your only way of ending the transaction (and the resulting persistent connection) will be \*(C`rollback\*(C'.</p>
<h3>commit</h3>
<p>  Foo::Bar-&gt;commit;</p><p>The \*(C`commit\*(C' method commits the current transaction. If called outside of a current transaction, it is accepted and treated as a null operation.</p><p>Once the commit has been completed, the database connection falls back into auto-commit state. If you wish to immediately start another transaction, you will need to issue a separate -&gt;begin call.</p><p>Returns true or throws an exception on error.</p>
<h3>commit_begin</h3>
<p>  Foo::Bar-&gt;begin;</p><p>  # Code for the first transaction...</p><p>  Foo::Bar-&gt;commit_begin;</p><p>  # Code for the last transaction...</p><p>  Foo::Bar-&gt;commit;</p><p>By default, ORLite-generated code uses opportunistic connections.</p><p>Every &lt;select&gt; you call results in a fresh \s-1DBI\s0 \*(C`connect\*(C', and a \*(C`disconnect\*(C' occurs after query processing and before the data is returned. Connections are <strong>only</strong> held open indefinitely during a transaction, with an immediate \*(C`disconnect\*(C' after your \*(C`commit\*(C'.</p><p>This makes ORLite very easy to use in an ad-hoc manner, but can have performance implications.</p><p>While SQLite itself can handle 1000 connections per second, the repeated destruction and repopulation of SQLite's data page caches between your statements (or between transactions) can slow things down dramatically.</p><p>The \*(C`commit_begin\*(C' method is used to \*(C`commit\*(C' the current transaction and immediately start a new transaction, without disconnecting from the database.</p><p>Its exception behaviour and return value is identical to that of a plain \*(C`commit\*(C' call.</p>
<h3>rollback</h3>
<p>The \*(C`rollback\*(C' method rolls back the current transaction. If called outside of a current transaction, it is accepted and treated as a null operation.</p><p>Once the rollback has been completed, the database connection falls back into auto-commit state. If you wish to immediately start another transaction, you will need to issue a separate -&gt;begin call.</p><p>If a transaction exists at END-time as the process exits, it will be automatically rolled back.</p><p>Returns true or throws an exception on error.</p>
<h3>rollback_begin</h3>
<p>  Foo::Bar-&gt;begin;</p><p>  # Code for the first transaction...</p><p>  Foo::Bar-&gt;rollback_begin;</p><p>  # Code for the last transaction...</p><p>  Foo::Bar-&gt;commit;</p><p>By default, ORLite-generated code uses opportunistic connections.</p><p>Every &lt;select&gt; you call results in a fresh \s-1DBI\s0 \*(C`connect\*(C', and a \*(C`disconnect\*(C' occurs after query processing and before the data is returned. Connections are <strong>only</strong> held open indefinitely during a transaction, with an immediate \*(C`disconnect\*(C' after your \*(C`commit\*(C'.</p><p>This makes ORLite very easy to use in an ad-hoc manner, but can have performance implications.</p><p>While SQLite itself can handle 1000 connections per second, the repeated destruction and repopulation of SQLite's data page caches between your statements (or between transactions) can slow things down dramatically.</p><p>The \*(C`rollback_begin\*(C' method is used to \*(C`rollback\*(C' the current transaction and immediately start a new transaction, without disconnecting from the database.</p><p>Its exception behaviour and return value is identical to that of a plain \*(C`commit\*(C' call.</p>
<h3>do</h3>
<p>  Foo::Bar-&gt;do(       &apos;insert into table (foo, bar) values (?, ?)&apos;,       {},       $foo_value,       $bar_value,   );</p><p>The \*(C`do\*(C' method is a direct wrapper around the equivalent \s-1DBI\s0 method, but applied to the appropriate locally-provided connection or transaction.</p><p>It takes the same parameters and has the same return values and error behaviour.</p>
<h3>selectall_arrayref</h3>
<p>The \*(C`selectall_arrayref\*(C' method is a direct wrapper around the equivalent \s-1DBI\s0 method, but applied to the appropriate locally-provided connection or transaction.</p><p>It takes the same parameters and has the same return values and error behaviour.</p>
<h3>selectall_hashref</h3>
<p>The \*(C`selectall_hashref\*(C' method is a direct wrapper around the equivalent \s-1DBI\s0 method, but applied to the appropriate locally-provided connection or transaction.</p><p>It takes the same parameters and has the same return values and error behaviour.</p>
<h3>selectcol_arrayref</h3>
<p>The \*(C`selectcol_arrayref\*(C' method is a direct wrapper around the equivalent \s-1DBI\s0 method, but applied to the appropriate locally-provided connection or transaction.</p><p>It takes the same parameters and has the same return values and error behaviour.</p>
<h3>selectrow_array</h3>
<p>The \*(C`selectrow_array\*(C' method is a direct wrapper around the equivalent \s-1DBI\s0 method, but applied to the appropriate locally-provided connection or transaction.</p><p>It takes the same parameters and has the same return values and error behaviour.</p>
<h3>selectrow_arrayref</h3>
<p>The \*(C`selectrow_arrayref\*(C' method is a direct wrapper around the equivalent \s-1DBI\s0 method, but applied to the appropriate locally-provided connection or transaction.</p><p>It takes the same parameters and has the same return values and error behaviour.</p>
<h3>selectrow_hashref</h3>
<p>The \*(C`selectrow_hashref\*(C' method is a direct wrapper around the equivalent \s-1DBI\s0 method, but applied to the appropriate locally-provided connection or transaction.</p><p>It takes the same parameters and has the same return values and error behaviour.</p>
<h3>prepare</h3>
<p>The \*(C`prepare\*(C' method is a direct wrapper around the equivalent \s-1DBI\s0 method, but applied to the appropriate locally-provided connection or transaction</p><p>It takes the same parameters and has the same return values and error behaviour.</p><p>In general though, you should try to avoid the use of your own prepared statements if possible, although this is only a recommendation and by no means prohibited.</p>
<h3>pragma</h3>
<p>  # Get the user_version for the schema   my $version = Foo::Bar-&gt;pragma(&apos;user_version&apos;);</p><p>The \*(C`pragma\*(C' method provides a convenient method for fetching a pragma for a datase. See the SQLite documentation for more details.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TABLE PACKAGE METHODS</h2>
        <div class="sectioncontent">
<p>When you use ORLite, your database tables will be available as objects named in a camel-cased fashion. So, if your model name is Foo::Bar...</p><p>  use ORLite {       package =&gt; &apos;Foo::Bar&apos;,       file    =&gt; &apos;data/sqlite.db&apos;,   };</p><p>... then a table named 'user' would be accessed as \*(C`Foo::Bar::User\*(C', while a table named 'user_data' would become \*(C`Foo::Bar::UserData\*(C'.</p><h3>base</h3>
<p>  my $namespace = Foo::Bar::User-&gt;base; # Returns &apos;Foo::Bar&apos;</p><p>Normally you will only need to work directly with a table class, and only with one ORLite package.</p><p>However, if for some reason you need to work with multiple ORLite packages at the same time without hardcoding the root namespace all the time, you can determine the root namespace from an object or table class with the \*(C`base\*(C' method.</p>
<h3>table</h3>
<p>  print Foo::Bar::UserData-&gt;table; # &apos;user_data&apos;</p><p>While you should not need the name of table for any simple operations, from time to time you may need it programatically. If you do need it, you can use the \*(C`table\*(C' method to get the table name.</p>
<h3>table_info</h3>
<p>  # List the columns in the underlying table   my $columns = Foo::Bar::User-&gt;table_info;   foreach my $c ( @$columns ) {      print "Column $c-&gt;{name} $c-&gt;{type}";      print " not null" if $c-&gt;{notnull};      print " default $c-&gt;{dflt_value}" if defined $c-&gt;{dflt_value};      print " primary key" if $c-&gt;{pk};      print "&#92;n";   }</p><p>The \*(C`table_info\*(C' method is a wrapper around the SQLite \*(C`table_info\*(C' pragma, and provides simplified access to the column metadata for the underlying table should you need it for some advanced function that needs direct access to the column list.</p><p>Returns a reference to an \*(C`ARRAY\*(C' containing a list of columns, where each column is a reference to a \*(C`HASH\*(C' with the keys \*(C`cid\*(C', \*(C`dflt_value\*(C', \*(C`name\*(C', \*(C`notnull\*(C', \*(C`pk\*(C' and \*(C`type\*(C'.</p>
<h3>new</h3>
<p>  my $user = Foo::Bar::User-&gt;new(       name =&gt; &apos;Your Name&apos;,       age  =&gt; 23,   );</p><p>The \*(C`new\*(C' constructor creates an anonymous object, without reading or writing it to the database. It also won't do validation of any kind, since ORLite is designed for use with embedded databases and presumes that you know what you are doing.</p>
<h3>insert</h3>
<p>  my $user = Foo::Bar::User-&gt;new(       name =&gt; &apos;Your Name&apos;,       age  =&gt; 23,   )-&gt;insert;</p><p>The \*(C`insert\*(C' method takes an existing anonymous object and inserts it into the database, returning the object back as a convenience.</p><p>It provides the second half of the slower manual two-phase object construction process.</p><p>If the table has an auto-incrementing primary key (and you have not provided a value for it yourself) the identifier for the new record will be fetched back from the database and set in your object.</p><p>  my $object = Foo::Bar::User-&gt;new( name =&gt; &apos;Foo&apos; )-&gt;insert;</p><p>  print "Created new user with id " . $user-&gt;id . "&#92;n";</p>
<h3>create</h3>
<p>  my $user = Foo::Bar::User-&gt;create(       name =&gt; &apos;Your Name&apos;,       age  =&gt; 23,   );</p><p>While the \*(C`new\*(C' + \*(C`insert\*(C' methods are useful when you need to do interesting constructor mechanisms, for most situations you already have all the attributes ready and just want to create and insert the record in a single step.</p><p>The \*(C`create\*(C' method provides this shorthand mechanism and is just the functional equivalent of the following.</p><p>  sub create {       shift-&gt;new(@_)-&gt;insert;   }</p><p>It returns the newly created object after it has been inserted.</p>
<h3>load</h3>
<p>  my $user = Foo::Bar::User-&gt;load( $id );</p><p>If your table has single column primary key, a \*(C`load\*(C' method will be generated in the class. If there is no primary key, the method is not created.</p><p>The \*(C`load\*(C' method provides a shortcut mechanism for fetching a single object based on the value of the primary key. However it should only be used for cases where your code trusts the record to already exists.</p><p>It returns a \*(C`Foo::Bar::User\*(C' object, or throws an exception if the object does not exist.</p>
<h3>id</h3>
<p>The \*(C`id\*(C' accessor is a convenience method that is added to your table class to increase the readability of your code when ORLite detects certain patterns of column naming.</p><p>For example, take the following definition where convention is that all primary keys are the table name followed by \*(L"_id\*(R".</p><p>  create table foo_bar (       foo_bar_id integer not null primary key,       name string not null,   )</p><p>When ORLite detects the use of this pattern, and as long as the table does not have an \*(L"id\*(R" column, the additional \*(C`id\*(C' accessor will be added to your class, making these expressions equivalent both in function and performance.</p><p>  my $foo_bar = My::FooBar-&gt;create( name =&gt; &apos;Hello&apos; );</p><p>  # Column name accessor   $foo_bar-&gt;foo_bar_id;</p><p>  # Convenience id accessor   $foo_bar-&gt;id;</p><p>As you can see, the latter involves much less repetition and reads much more cleanly.</p>
<h3>select</h3>
<p>  my @users = Foo::Bar::User-&gt;select;</p><p>  my $users = Foo::Bar::User-&gt;select( &apos;where name = ?&apos;, @args );</p><p>The \*(C`select\*(C' method is used to retrieve objects from the database.</p><p>In list context, returns an array with all matching elements. In scalar context an array reference is returned with that same data.</p><p>You can filter the results or order them by passing \s-1SQL\s0 code to the method.</p><p>    my @users = DB::User-&gt;select( &apos;where name = ?&apos;, $name );</p><p>    my $users = DB::User-&gt;select( &apos;order by name&apos; );</p><p>Because \*(C`select\*(C' provides only the thinnest of layers around pure \s-1SQL\s0 (it merely generates the \*(L"\s-1SELECT\s0 ... \s-1FROM\s0 table_name\*(R") you are free to use anything you wish in your query, including subselects and function calls.</p><p>If called without any arguments, it will return all rows of the table in the natural sort order of SQLite.</p>
<h3>iterate</h3>
<p>  Foo::Bar::User-&gt;iterate( sub {       print $_-&gt;name . "&#92;n";   } );</p><p>The \*(C`iterate\*(C' method enables the processing of large tables one record at a time without loading having to them all into memory in advance.</p><p>This plays well to the strength of SQLite, allowing it to do the work of loading arbitrarily large stream of records from disk while retaining the full power of Perl when processing the records.</p><p>The last argument to \*(C`iterate\*(C' must be a subroutine reference that will be called for each element in the list, with the object provided in the topic variable $_.</p><p>This makes the \*(C`iterate\*(C' code fragment above functionally equivalent to the following, except with an O(1) memory cost instead of O(n).</p><p>    foreach ( Foo::Bar::User-&gt;select ) {         print $_-&gt;name . "&#92;n";     }</p><p>You can filter the list via \s-1SQL\s0 in the same way you can with \*(C`select\*(C'.</p><p>  Foo::Bar::User-&gt;iterate(       &apos;order by ?&apos;, &apos;name&apos;,       sub {           print $_-&gt;name . "&#92;n";       }   );</p><p>You can also use it in raw form from the root namespace for better control. Using this form also allows for the use of arbitrarily complex queries, including joins. Instead of being objects, rows are provided as \s-1ARRAY\s0 references when used in this form.</p><p>  Foo::Bar-&gt;iterate(       &apos;select name from user order by name&apos;,       sub {           print $_-&gt;[0] . "&#92;n";       }   );</p>
<h3>count</h3>
<p>  my $everyone = Foo::Bar::User-&gt;count;</p><p>  my $young = Foo::Bar::User-&gt;count( &apos;where age &lt;= ?&apos;, 13 );</p><p>You can count the total number of elements in a table by calling the \*(C`count\*(C' method with no arguments. You can also narrow your count by passing sql conditions to the method in the same manner as with the \*(C`select\*(C' method.</p>
<h3>delete</h3>
<p>  # Delete a single object from the database   $user-&gt;delete;</p><p>  # Delete a range of rows from the database   Foo::Bar::User-&gt;delete( &apos;where age &lt;= ?&apos;, 13 );</p><p>The \*(C`delete\*(C' method will delete the single row representing an object, based on the primary key or SQLite rowid of that object.</p><p>The object that you delete will be left intact and untouched, and you remain free to do with it whatever you wish.</p>
<h3>delete_where</h3>
<p>  # Delete a range of rows from the database   Foo::Bar::User-&gt;delete( &apos;age &lt;= ?&apos;, 13 );</p><p>The \*(C`delete_where\*(C' static method allows the delete of large numbers of rows from a database while protecting against accidentally doing a boundless delete (the \*(C`truncate\*(C' method is provided specifically for this purpose).</p><p>It takes the same parameters for deleting as the \*(C`select\*(C' method, with the exception that the \*(L"where\*(R" keyword is automatically provided for your and should not be passed in.</p><p>This ensures that providing an empty of null condition results in an invalid \s-1SQL\s0 query and the deletion will not occur.</p><p>Returns the number of rows deleted from the database (which may be zero).</p>
<h3>truncate</h3>
<p>  # Clear out all records from the table   Foo::Bar::User-&gt;truncate;</p><p>The \*(C`truncate\*(C' method takes no parameters and is used for only one purpose, to completely empty a table of all rows.</p><p>Having a separate method from \*(C`delete\*(C' not only prevents accidents, but will also do the deletion via the direct SQLite \*(C`TRUNCATE TABLE\*(C' query. This uses a different deletion mechanism, and is <strong>significantly</strong> faster than a plain \s-1SQL\s0 \*(C`DELETE\*(C'.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TO DO</h2>
        <div class="sectioncontent">
<p>- Support for intuiting reverse relations from foreign keys</p><p>- Document the 'create' and 'table' params</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>Bugs should be reported via the \s-1CPAN\s0 bug tracker at</p><p>&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=ORLite&gt;</p><p>For other issues, contact the author.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Adam Kennedy &lt;adamk@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO ORLite&hellip;</h2>
        <div class="sectioncontent">
<p>ORLite::Mirror, ORLite::Migrate, ORLite::Pod</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2008 - 2012 Adam Kennedy.</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>The full text of the license can be found in the \s-1LICENSE\s0 file included with this module.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="OLE::Storage_Lite.3pm.html"><span aria-hidden="true">&larr;</span> OLE::Storage_Lite.3pm: Simple class for ole document interface.</a></li>
   <li class="next"><a href="ORLite::Migrate.3pm.html">ORLite::Migrate.3pm: Extremely light weight sqlite-specific schema migration <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mapistore-documentation: </title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mapistore-documentation (3) manual">
  <meta name="twitter:description" content="">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmapi-dev-mapistore-documentation-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/mapistore-documentation.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mapistore-documentation (3) manual" />
  <meta property="og:description" content="" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmapi-dev-mapistore-documentation-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mapistore-documentation<small> (3)</small></h1>
        <p class="lead"></p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mapistore-documentation.3.html">
      <span itemprop="name">mapistore-documentation: </span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmapi-dev/">
      <span itemprop="name">libmapi-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mapistore-documentation.3.html">
      <span itemprop="name">mapistore-documentation: </span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Contents</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>Revision History </p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>1. Introduction </p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>1.1. Purpose and Scope</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>1.2. General Overview</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>2. Technical / MAPI Considerations</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>2.1. MAPI objects</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>2.2. MAPI tables</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>2.3. MAPI properties and mapping</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>2.4. Named properties vs known properties</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>3. MAPIStore architecture</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>3.1. INTERFACE layer</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>3.2. PROCESSING layer</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>3.3. BACKENDS layer</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>3.4. Relationship to OpenChange Dispatcher database</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>3.5. Object mapping</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>4. MAPIStore API</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>4.1. Initialization</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>4.2. Backend contexts</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>5. FSOCPF backend</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>5.1. Definition </p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>5.2. Namespace and Attributes </p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>5.3. Overview </p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>5.4. Documentation and References</p>
  </dd>

</dl>
<h3>Revision History</h3>
<p><strong>Date</strong> <strong>Revision Number</strong> <strong>Author</strong> <strong>Revision Content</strong>  21/05/10 <strong>0.3</strong> Julien Kerihuel Add API documentation for initialization, backend connection contexts and add programming samples  21/05/10 <strong>0.2</strong> Julien Kerihuel Merge initial Wiki document and add FSOCPF section  20/05/10 <strong>0.1</strong> Julien Kerihuel Draft document.</p>
<h3>1. Introduction</h3>

<h3>1.1. Purpose and Scope</h3>
<p>MAPIStore is the SAL component of OpenChange server. SAL stands for Storage Abstraction Layer. It is the component used by OpenChange Server to push/get information (messages, folders) to/from storage backends. The following document intends to describe the overall/theoretical SAL behavior and constraints we need to consider when dealing with MAPI/EMSMDB. It also describes the semantics and inner working of its storage backends.</p>
<h3>1.2. General overview</h3>
<p>The main objective of mapistore is to provide an interface layer with a common set of atomic functions (operations) used to trigger and dispatch data and commands to the appropriate backend. MAPIStore relies on a backend mechanism specifically designed to transparently handle some of the MAPI semantics required by any Exchange compatible server.</p><p>The initial idea was to provide to OpenChange a highly customizable storage backend mechanism which would fit in any situation and any environments. One of the greatest limitation we have found with existing groupware is the storage layer which is generally limited to a single solution, service or format and is neither scalable nor modifiable when user requirements evolve upon time.</p><p>MAPIStore solves this problem and go beyond classical limitations. It is not a revolutionary concept, but the way openchange uses it makes the whole difference and offer administrators an innovative way to customize storage.</p><p>MAPIStore allows you to:</p><ul>
<li><p><strong>use a different backend for any top-folder</strong></p></li><li><p><strong>transparently move/copy data across backends</strong></p></li><li><p>develop new backends quickly</p></li><li><p>access all the different backends through an unique API</p></li>
</ul><p>For example (assuming all associated backends were developed) a user could have the following storage organization for his mailbox:</p><ul>
<li><p>Mails stored using an IMAP backend (Cyrus-IMAP or dovecot)</p></li><li><p>Calendar items stored in CalDAV or pushed in Google calendar</p></li><li><p>Sent emails and archives/backup stored in a compression backend</p></li><li><p>Tasks stored in a MySQL database</p></li><li><p>Notes stored on the filesystem</p></li>
</ul><p>If the user is not satisfied with one of the backend's performance, they would just have to use an administration tool, change the backend, wait for the replication, synchronization to finish and there data will be available from the new backend.</p><p>Information can be completely decentralized, stored on one of several servers and still be accessible transparently from OpenChange server.</p>
<h3>2. Technical / MAPI Considerations</h3>

<h3>2.1. MAPI objects</h3>
<p>An object is a physical (message, folder) or temporary (table) but generic entity which can be represented as a 2 columns fixed array with <em>n</em> rows, where each row contains a property of that entity. One column repesents the property tags (names), and the other represents the property value (or values).</p><p>From a MAPI perspective (network layer), opening an object means:</p><ul>
<li><p>opening either a <strong>private mailbox</strong> or <strong>public folder store</strong>. These are referenced by <strong>EssDN and not IDs</strong></p></li><li><p>opening a <strong>message</strong> given its <strong>PR_MID</strong> (Message identifier)</p></li><li><p>opening a <strong>folder/container</strong> given its <strong>PR_FID</strong> (Folder identifier)</p></li>
</ul>
<h3>2.2. MAPI tables</h3>
<p>Another category of MAPI objects are tables (also known as <em>views</em>) created with MAPI ROPs such as <em>GetContentsTable</em>, <em>GetHierarchyTable</em>, <em>GetAttachmentTable</em> or <em>GetRulesTable</em>. Views are temporary representation of the elements that a container holds at a specific moment. It can be represented as a list of <em>n</em> rows (elements) with <em>n</em> columns (property values):</p><ul>
<li><p><em>GetContentsTables</em> creates a view listing all messages available within a container</p></li><li><p><em>GetHierarchyTable</em> creates a view listing all containers within a container</p></li><li><p><em>GetAttachmentTable</em> creates a view listing all the attachment of a message</p></li><li><p><em>GetRulesTable</em> creates a view listing all permissions associated to a container</p></li>
</ul><p>Tables are customized through the <em>SetColumns</em> MAPI ROP which will define the property identifiers to be retrieved. The <em>QueryRows</em> MAPI ROP can then be called to sequentially retrieve rows and associated property values. A table is similar to a MAPI object except it is virtual, created on demand to represent a list of objects rather than a unique object.</p>
<h3>2.3. MAPI properties and mapping</h3>
<p>There is a large set of fixed and known MAPI properties available. If appropriate backends are developed, there can be a 1-1 mapping between MAPI properties and backend properties for some of them. This mapping may even be enough for common purposes. However there will still be a set of MAPI properties which won't fit in this process.</p><p>There are different way to workaround this issue. For example, Kolab is using a Cyrus/IMAP backend and associate/store MAPI properties to the message using ANNOTATE-MORE within a XML file format.</p><p>OpenChange provides similar mechanism with its OCPF file format.</p>
<h3>2.4. Named properties vs known properties</h3>
<p>OpenChange server needs to support named properties. An initial set of named properties can be defined at provisioning time, but this list must not be static. Users must be able to add, delete, change new entries and create their own set of custom named properties as required.</p>
<h3>3. MAPIStore Architecture</h3>
<p>Given that objects representation are similar to SQL database records, an architecture like the sqlite one makes sense for our purpose:</p><p><strong>Component</strong> <strong>Brief description</strong>  INTERFACE convenient top-level functions (Public API) accessed through EMSMDB providers  PROCESSING set of atomic operations (open, read, write, close, mkdir, rmdir etc.)  BACKENDS The code which <em>does things</em> in the specified storage system (mysql, fsocpf, imap etc.)</p>
<h3>3.1. INTERFACE layer</h3>
<p>The interface layer doesn't have any knowledge about mapistore internals, how or where objects are stored. The interface uses MAPI data structure, supplies PR_FID and PR_MID values and assumes the interface layer will return a pack of data it can directly use without further or significant modifications. The interface layer functions should also have (as a parameter) a pointer to a mapistore context with private/opaque set of information (void *) about the object.</p>
<h3>3.2. PROCESSING layer</h3>
<p>The processing layer is responsible for:</p><ul>
<li><p>mapping OpenChange objects identifiers (PR_FID, PR_MID) to unique backends object identifiers (on purpose, depending on the kind of backend).</p></li><li><p>format input/output data: glue between INTERFACE and BACKENDS</p></li><li><p>relay input requests to the correct backend through atomic operations</p></li><li><p>maintain mapistore's integrity</p></li>
</ul>
<h3>3.3. BACKENDS layer</h3>
<p>The backends layer has a list of modules identified at mapistore initialization and available across user sessions, which means unique initialization at server start-up. Each module is a backend (fsocpf, sqlite, imap, etc.) and similarly to many other openchange components is loaded as a DSO object (dynamic shared object)</p>
<h3>3.4. Relationship to OpenChange Dispatcher database</h3>
<p>MAPIStore and the openchange 'dispatcher' database (openchange.ldb) are completely unrelated. MAPIStore is a standalone API and developers can use it independently from OpenChange server.</p><p>However, the mapistore API has initially been designed to be used by OpenChange server, and OpenChange server is using a tiny indexing database which describes user mailboxes top level containers. In openchange.ldb the mapistore_uri attribute is attached to top level containers and its value points to a valid mapistore URI (namespace + path). Note that a single user can have several different types of mapistore databases in use (one for each of the top level containers).</p><p>The is the only relationship between the database and the store: The database points to store locations.</p>
<h3>3.5. Object mapping</h3>
<p>MAPIStore needs to maintain a hash database linking unique OpenChange identifiers to unique backend identifiers. This hash table can be stored within a TDB database.</p><p>MAPIStore is responsible for managing IDs mapping between OpenChange objects and backend specific objects. It maintains a list of free identifiers which it reallocates on demand whenever a backend needs (mapistore_register_id()) one or where it wants to release one (mapistore_unregister_id()).</p>
<h3>4. MAPIStore API</h3>
<p>MAPIStore relies on the talloc library for memory allocation.</p>
<h3>4.1. Initialization</h3>
<p>If there was a 'hello mapistore' program, it would only require to make 2 calls:</p><ul>
<li><p><strong>mapistore_init</strong>:</p><p>The initialization routine initializes the mapistore general context used along all mapistore calls, the mapping context databases (described below) and finally load all the backends available (DSO). When this operation is successful, developers are ready to make mapistore calls.</p></li><li><p><strong>mapistore_release</strong>:</p><p>The release operation uninitializes the mapistore general context, closes connections to database and frees the remaining allocated memory.</p></li>
</ul><p><strong>mapistore_sample1.c</strong></p>
<pre>
#include &lt;mapistore/mapistore.h&gt;

int main(int ac, const char *av[])
{
        TALLOC_CTX                      *mem_ctx;
        struct mapistore_context        *mstore_ctx;
        int                             retval;

        /* Step 1. Create the talloc memory context */
        mem_ctx = talloc_named(NULL, 0, "mapistore_sample1");

        /* Step 2. Initialize mapistore system */
        mstore_ctx = mapistore_init(mem_ctx, NULL);
        if (!mstore_ctx) {
                exit (1);
        }

        /* Step 3. Uninitialize mapistore system */
        retval = mapistore_release(mstore_ctx);
        if (retval != MAPISTORE_SUCCESS) {
                exit (1);
        }

        return 0;
}

</pre>

<pre>
$ export PKG_CONFIG_PATH=/usr/local/samba/lib/pkgconfig
$ gcc mapistore_sample1.c -o mapistore_sample1 `pkg-config --cflags --libs libmapistore`
$ ./mapistore_sample1
$
</pre>

<h3>4.2. Backend contexts</h3>
<p>MAPIStore registers and loads its backends upon initialization. It means they are only instantiated/initialized one time during the whole server lifetime and the same code is used for all users and all mapistore folders.</p><p>These backend contexts (or connection contexts) are identified by a <strong>context id</strong>, which is an unsigned 32 bit integer which references the context during its lifetime. If OpenChange is used in a very large environment with many top folders (which implies the same number of mapistore contexts), or if OpenChange server has an incredibly long uptime, it would be possible to run out of available context identifiers.</p><p>In order to prevent this situation from happening, mapistore implements context databases where it stores available/free/used context identifiers:</p><ul>
<li><p><strong>mapistore_id_mapping_used.tdb</strong>: TDB database with used IDs</p></li><li><p><strong>mapistore_id_mapping_free.tdb</strong>: TDB database with available pool of IDs</p></li>
</ul><p>MAPIStore provides a convenient set of functions to manage backend contexts:</p><ul>
<li><p><strong>mapistore_set_mapping_path</strong>: Defines the path where context databases are stored. Call to this function is optional and default path would be used instead. However if a call to this function has to be made, it must be done before any call to mapistore (even mapistore_init).</p></li><li><p><strong>mapistore_add_context</strong>: Add a new connection context to mapistore</p></li><li><p><strong>mapistore_del_context</strong>: Delete a connection context from mapistore</p></li>
</ul><p><strong>mapistore_sample2.c</strong>:</p>
<pre>
#include &lt;mapistore/mapistore.h&gt;

int main(int ac, const char *av[])
{
        TALLOC_CTX                      *mem_ctx;
        struct mapistore_context        *mstore_ctx;
        int                             retval;
        uint32_t                        context_id = 0;
        uint32_t                        context_id2 = 0;

        /* Step 1. Create the talloc memory context */
        mem_ctx = talloc_named(NULL, 0, "mapistore_sample1");

        /* Step 2. Set the mapping path to /tmp */
        retval = mapistore_set_mapping_path("/tmp");
        if (retval != MAPISTORE_SUCCESS) {
                exit (1);
        }

        /* Step 3. Initialize mapistore system */
        mstore_ctx = mapistore_init(mem_ctx, NULL);
        if (!mstore_ctx) {
                exit (1);
        }

        /* Step 4. Add connection contexts */
        retval = mapistore_add_context(mstore_ctx, "fsocpf:///tmp/Inbox", &context_id);
        if (retval != MAPISTORE_SUCCESS) {
                exit (1);
        }

        retval = mapistore_add_context(mstore_ctx, "fsocpf:///tmp/Sent Items", &context_id2);
        if (retval != MAPISTORE_SUCCESS) {
                exit (1);
        }

        /* Step 5. Release connection contexts */
        retval = mapistore_del_context(mstore_ctx, context_id);
        retval = mapistore_del_context(mstore_ctx, context_id2);

        /* Step 6. Uninitialize mapistore system */
        retval = mapistore_release(mstore_ctx);
        if (retval != MAPISTORE_SUCCESS) {
                exit (1);
        }

        return 0;
}

</pre>

<pre>
$ ./mapistore_sample2
sqlite3 backend initialized
fsocpf backend initialized
namespace is fsocpf:// and backend_uri is '/tmp/Inbox'
[fsocpf_create_context:49]
namespace is fsocpf:// and backend_uri is '/tmp/Sent Items'
[fsocpf_create_context:49]
$
</pre>

<h3>5. FSOCPF Backend</h3>

<h3>5.1. Definition</h3>
<p>FSOCPF stands for FileSystem and OpenChange Property Files. It is a backend designed to help developers testing OpenChange server code easily. The main idea is to have a backend we can manipulate, analyze and modify from the Linux console without having to develop a specific tool. This backend uses the UNIX filesystem for folder semantics and the OCPF file format as a way to store MAPI objects easily.</p>
<h3>5.2. Namespace and Attributes</h3>
<p>The namespace for this backend is:</p>
<pre>
fsocpf://

</pre>
<p>The mapistore_uri attribute for the folder definition in openchange.ldb must be a valid path where the last part of the URI is the FSOCPF container folder to create on the filesystem.</p>
<h3>5.3. Overview</h3>

<pre>
[+] Private user storage space
 |
 +-[+] Top-MAPIStore folder (Inbox)
    |
    +-[+] 0xf1000001 (mapistore folder1)
    |  |
    |  +-[+] .properties (OCPF)
    |  |
    |  +-[+] 0xe10000001.ocpf (message - OCPF)
    |  |
    |  +-[+] 0xe10000001 (attachment folder)
    |     |
    |     +-[+] 1.ocpf (PR_ATTACH_NUM)
    |     |
    |     +-[+] 1.data (attachment / stream data)
    |
    +-[+] 0xf2000001 (mapistore folder2)
       |
       +-[+] .properties (OCPF)
</pre>
<p>The figure above exposes the storage architecture of the FSOCPF backend using a real-world example. In this use case, we have decided to associate the FSOCPF backend to the Inbox folder. It means that any folder created under Inbox or any message stored within Inbox at any level of depth is stored and retrieved from the path defined in openchange.ldb.</p><p>In openchange.ldb, the mapistore_uri attribute of the Inbox record points to:</p>
<pre>
fsocpf://Private user storage space/Inbox

</pre>
<p> where <em>Private user storage space</em> can for example be</p>
<pre>
/usr/local/samba/private/mapistore/$username

</pre>
<p>Under Inbox, we have created 2 folders:</p><ul>
<li><p>0xf1000001 folder1</p></li><li><p>0xf2000001 folder2</p></li>
</ul><p>These folders are identified/named using their FID. Since they are classical filesystem folders, we can't associate attributes to them such as a folder comment, or the container class. All these attributes with the displayable name are stored into the <strong>.properties</strong> file within the folder.</p><p>Inside 0xf1000001 folder, we have 1 message named 0xe10000001.ocpf stored in the OCPF file format (property/value pair). Any properties associated to the message (subject, recipient, body) are stored within this file.</p><p>This message also has attachments. Attachments are stored within a directory at the same level named 0xe10000001 (message name without OCPF extension). Within this directory, we find the attachments named using the PR_ATTACH_NUM property value and the OCPF file extension. The content of the attachment is stored in $PR_ATTACH_NUM.data - in this case 1.data.</p>
<h3>5.4. Documentation and References</h3>
<ul>
<li><p>OpenChange Property File format (OCPF) documentation</p></li>
</ul>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mapiproxy-documentation.3.html"><span aria-hidden="true">&larr;</span> mapiproxy-documentation.3: </a></li>
   <li class="next"><a href="mapistore.h.3.html">mapistore.h.3: Mapistore general api. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

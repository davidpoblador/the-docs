<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>IncomingDataQueue: Queue for incoming rtp data packets in an rtp session.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Queue for incoming rtp data packets in an rtp session.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="IncomingDataQueue (3) manual">
  <meta name="twitter:description" content="Queue for incoming rtp data packets in an rtp session.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libccrtp-doc-IncomingDataQueue-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/IncomingDataQueue.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="IncomingDataQueue (3) manual" />
  <meta property="og:description" content="Queue for incoming rtp data packets in an rtp session." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libccrtp-doc-IncomingDataQueue-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">IncomingDataQueue<small> (3)</small></h1>
        <p class="lead">Queue for incoming rtp data packets in an rtp session.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/IncomingDataQueue.3.html">
      <span itemprop="name">IncomingDataQueue: Queue for incoming rtp data packets in an rtp session.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libccrtp-doc/">
      <span itemprop="name">libccrtp-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/IncomingDataQueue.3.html">
      <span itemprop="name">IncomingDataQueue: Queue for incoming rtp data packets in an rtp session.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;iqueue.h&gt;</p><p>Inherits <strong>IncomingDataQueueBase</strong>, and <strong>MembershipBookkeeping</strong>.</p><p>Inherited by <strong>RTPDataQueue</strong>.</p><h3>Classes</h3>
<p>class <strong>SyncSourcesIterator</strong></p><p><em>iterator through the list of synchronizations sources in this session </em></p>
<h3>Public Member Functions</h3>
<p><strong>SyncSourcesIterator</strong> <strong>begin</strong> ()</p><p><strong>SyncSourcesIterator</strong> <strong>end</strong> ()</p><p>const <strong>AppDataUnit</strong> * <strong>getData</strong> (uint32 stamp, const <strong>SyncSource</strong> *src=NULL)</p><p><em>Retreive data from a specific timestamped packet if such a packet is currently available in the receive buffer. </em> bool <strong>isWaiting</strong> (const <strong>SyncSource</strong> *src=NULL) const </p><p><em>Determine if packets are waiting in the reception queue. </em> uint32 <strong>getFirstTimestamp</strong> (const <strong>SyncSource</strong> *src=NULL) const </p><p><em>Get timestamp of first packet waiting in the queue. </em> void <strong>setMinValidPacketSequence</strong> (uint8 packets)</p><p><em>When receiving packets from a new source, it may be convenient to reject a first few packets before we are really sure the source is valid. </em> uint8 <strong>getDefaultMinValidPacketSequence</strong> () const </p><p>uint8 <strong>getMinValidPacketSequence</strong> () const </p><p><em>Get the minimun number of consecutive packets that must be received from a source before accepting its data packets. </em> void <strong>setMaxPacketMisorder</strong> (uint16 packets)</p><p>uint16 <strong>getDefaultMaxPacketMisorder</strong> () const </p><p>uint16 <strong>getMaxPacketMisorder</strong> () const </p><p>void <strong>setMaxPacketDropout</strong> (uint16 packets)</p><p><em>It also prevents packets sent after a restart of the source being immediately accepted. </em> uint16 <strong>getDefaultMaxPacketDropout</strong> () const </p><p>uint16 <strong>getMaxPacketDropout</strong> () const </p><p>void <strong>setInQueueCryptoContext</strong> (<strong>CryptoContext</strong> *cc)</p><p><em>Set input queue </em><strong>CryptoContext</strong><em>. </em><strong></strong> void <strong>removeInQueueCryptoContext</strong> (<strong>CryptoContext</strong> *cc)</p><p><em>Remove input queue </em><strong>CryptoContext</strong><em>. </em><strong></strong> <strong>CryptoContext</strong> * <strong>getInQueueCryptoContext</strong> (uint32 ssrc)</p><p><em>Get an input queue </em><strong>CryptoContext</strong><em> identified by SSRC. </em><strong></strong></p>
<h3>Static Public Member Functions</h3>
<p>static size_t <strong>getDefaultMembersSize</strong> ()</p>
<h3>Protected Member Functions</h3>
<p><strong>IncomingDataQueue</strong> (uint32 size)</p><p>virtual <strong>~IncomingDataQueue</strong> ()</p><p>bool <strong>checkSSRCInIncomingRTPPkt</strong> (<strong>SyncSourceLink</strong> &sourceLink, bool is_new, InetAddress &na, tpport_t tp)</p><p><em>Apply collision and loop detection and correction algorithm when receiving RTP data packets. </em> void <strong>setSourceExpirationPeriod</strong> (uint8 intervals)</p><p><em>Set the number of RTCP intervals that the stack will wait to change the state of a source from stateActive to stateInactive, or to delete the source after being in stateInactive. </em> virtual size_t <strong>takeInDataPacket</strong> ()</p><p><em>This function is used by the service thread to process the next incoming packet and place it in the receive list. </em> void <strong>renewLocalSSRC</strong> ()</p><p><strong>IncomingDataQueue::IncomingRTPPktLink</strong> * <strong>getWaiting</strong> (uint32 timestamp, const <strong>SyncSource</strong> *src=NULL)</p><p><em>This is used to fetch a packet in the receive queue and to expire packets older than the current timestamp. </em> bool <strong>recordReception</strong> (<strong>SyncSourceLink</strong> &srcLink, const <strong>IncomingRTPPkt</strong> &pkt, const timeval recvtime)</p><p><em>Log reception of a new RTP packet from this source. </em> void <strong>recordExtraction</strong> (const <strong>IncomingRTPPkt</strong> &pkt)</p><p><em>Log extraction of a packet from this source from the scheduled reception queue. </em> void <strong>purgeIncomingQueue</strong> ()</p><p>virtual void <strong>onNewSyncSource</strong> (const <strong>SyncSource</strong> &)</p><p><em>Virtual called when a new synchronization source has joined the session. </em> virtual bool <strong>onRTPPacketRecv</strong> (<strong>IncomingRTPPkt</strong> &)</p><p><em>A virtual function to support parsing of arriving packets to determine if they should be kept in the queue and to dispatch events. </em> virtual void <strong>onExpireRecv</strong> (<strong>IncomingRTPPkt</strong> &)</p><p><em>A hook to filter packets in the receive queue that are being expired. </em> virtual bool <strong>onSRTPPacketError</strong> (<strong>IncomingRTPPkt</strong> &pkt, int32 errorCode)</p><p><em>A hook that gets called if the decoding of an incoming SRTP was erroneous. </em> virtual bool <strong>end2EndDelayed</strong> (IncomingRTPPktLink &)</p><p>bool <strong>insertRecvPacket</strong> (IncomingRTPPktLink *packetLink)</p><p><em>Insert a just received packet in the queue (both general and source specific queues). </em> virtual size_t <strong>recvData</strong> (unsigned char *buffer, size_t length, InetHostAddress &host, tpport_t &port)=0</p><p><em>This function performs the physical I/O for reading a packet from the source. </em> virtual size_t <strong>getNextDataPacketSize</strong> () const =0</p>
<h3>Protected Attributes</h3>
<p>ThreadLock <strong>recvLock</strong></p><p>IncomingRTPPktLink * <strong>recvFirst</strong></p><p>IncomingRTPPktLink * <strong>recvLast</strong></p><p>uint8 <strong>minValidPacketSequence</strong></p><p>uint16 <strong>maxPacketMisorder</strong></p><p>uint16 <strong>maxPacketDropout</strong></p><p>uint8 <strong>sourceExpirationPeriod</strong></p><p>Mutex <strong>cryptoMutex</strong></p><p>std::list&lt; <strong>CryptoContext</strong> * &gt; <strong>cryptoContexts</strong></p>
<h3>Static Protected Attributes</h3>
<p>static const uint8 <strong>defaultMinValidPacketSequence</strong></p><p>static const uint16 <strong>defaultMaxPacketMisorder</strong></p><p>static const uint16 <strong>defaultMaxPacketDropout</strong></p><p>static const size_t <strong>defaultMembersSize</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>Queue for incoming RTP data packets in an RTP session.</p><p><strong>Author:</strong></p><p>Federico Montesino Pouzols fedemp@altern.org</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>IncomingDataQueue::IncomingDataQueue (uint32size)\fC [protected]\fP</h3>
<p><strong>Parameters:</strong></p><p><em>size</em> initial size of the membership table.</p>
<h3>virtual IncomingDataQueue::~IncomingDataQueue ()\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSyncSourcesIterator\fP IncomingDataQueue::begin ()\fC [inline]\fP</h3>

<h3>bool IncomingDataQueue::checkSSRCInIncomingRTPPkt (\fBSyncSourceLink\fP &sourceLink, boolis_new, InetAddress &na, tpport_ttp)\fC [protected]\fP</h3>
<p>Apply collision and loop detection and correction algorithm when receiving RTP data packets. Follows section 8.2 in draft-ietf-avt-rtp-new.</p><p><strong>Parameters:</strong></p><p><em>sourceLink</em> link to the source object.</p><p><em>is_new</em> whether the source has been just recorded.</p><p><em>na</em> data packet network address.</p><p><em>tp</em> data packet source transport port.</p><p><strong>Returns:</strong></p><p>whether the packet must not be discarded.</p>
<h3>\fBSyncSourcesIterator\fP IncomingDataQueue::end ()\fC [inline]\fP</h3>

<h3>virtual bool IncomingDataQueue::end2EndDelayed (IncomingRTPPktLink &)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>

<h3>const \fBAppDataUnit\fP* IncomingDataQueue::getData (uint32stamp, const \fBSyncSource\fP *src = \fCNULL\fP)</h3>
<p>Retreive data from a specific timestamped packet if such a packet is currently available in the receive buffer.</p><p><strong>Parameters:</strong></p><p><em>stamp</em> Data unit timestamp.</p><p><em>src</em> Optional synchronization source selector.</p><p><strong>Returns:</strong></p><p>data retrieved from the reception buffer.</p><p><strong>Return values:</strong></p><p><em>null</em> pointer if no packet with such timestamp is available.</p>
<h3>uint16 IncomingDataQueue::getDefaultMaxPacketDropout () const\fC [inline]\fP</h3>

<h3>uint16 IncomingDataQueue::getDefaultMaxPacketMisorder () const\fC [inline]\fP</h3>

<h3>static size_t IncomingDataQueue::getDefaultMembersSize ()\fC [inline]\fP, \fC [static]\fP</h3>

<h3>uint8 IncomingDataQueue::getDefaultMinValidPacketSequence () const\fC [inline]\fP</h3>

<h3>uint32 IncomingDataQueue::getFirstTimestamp (const \fBSyncSource\fP *src = \fCNULL\fP) const</h3>
<p>Get timestamp of first packet waiting in the queue.</p><p><strong>Parameters:</strong></p><p><em>src</em> optional source selector.</p><p><strong>Returns:</strong></p><p>timestamp of first arrival packet.</p>
<h3>\fBCryptoContext\fP* IncomingDataQueue::getInQueueCryptoContext (uint32ssrc)</h3>
<p>Get an input queue <strong>CryptoContext</strong> identified by SSRC.</p><p><strong>Parameters:</strong></p><p><em>ssrc</em> Request <strong>CryptoContext</strong> for this incoming SSRC</p><p><strong>Returns:</strong></p><p>Pointer to <strong>CryptoContext</strong> of the SSRC of NULL if no context available for this SSRC.</p>
<h3>uint16 IncomingDataQueue::getMaxPacketDropout () const\fC [inline]\fP</h3>

<h3>uint16 IncomingDataQueue::getMaxPacketMisorder () const\fC [inline]\fP</h3>

<h3>uint8 IncomingDataQueue::getMinValidPacketSequence () const\fC [inline]\fP</h3>
<p>Get the minimun number of consecutive packets that must be received from a source before accepting its data packets.</p>
<h3>virtual size_t IncomingDataQueue::getNextDataPacketSize () const\fC [protected]\fP, \fC [pure virtual]\fP</h3>
<p>Implemented in <strong>RTPDuplex</strong>.</p>
<h3>\fBIncomingDataQueue::IncomingRTPPktLink\fP* IncomingDataQueue::getWaiting (uint32timestamp, const \fBSyncSource\fP *src = \fCNULL\fP)\fC [protected]\fP</h3>
<p>This is used to fetch a packet in the receive queue and to expire packets older than the current timestamp.</p><p><strong>Returns:</strong></p><p>packet buffer object for current timestamp if found.</p><p><strong>Parameters:</strong></p><p><em>timestamp</em> timestamp requested.</p><p><em>src</em> optional source selector</p><p><strong>Note:</strong></p><p>if found, the packet is removed from the reception queue</p>
<h3>bool IncomingDataQueue::insertRecvPacket (IncomingRTPPktLink *packetLink)\fC [protected]\fP</h3>
<p>Insert a just received packet in the queue (both general and source specific queues). If the packet was already in the queue (same SSRC and sequence number), it is not inserted but deleted.</p><p><strong>Parameters:</strong></p><p><em>packetLink</em> link to a packet just received and generally validated and processed by onRTPPacketRecv.</p><p><strong>Returns:</strong></p><p>whether the packet was successfully inserted.</p><p><strong>Return values:</strong></p><p><em>false</em> when the packet is duplicated (there is already a packet from the same source with the same timestamp).</p><p><em>true</em> when the packet is not duplicated.</p>
<h3>bool IncomingDataQueue::isWaiting (const \fBSyncSource\fP *src = \fCNULL\fP) const</h3>
<p>Determine if packets are waiting in the reception queue.</p><p><strong>Parameters:</strong></p><p><em>src</em> Optional synchronization source selector.</p><p><strong>Returns:</strong></p><p>True if packets are waiting.</p>
<h3>virtual void IncomingDataQueue::onExpireRecv (\fBIncomingRTPPkt\fP &)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>
<p>A hook to filter packets in the receive queue that are being expired. This hook may be used to do some application specific processing on expired packets before they are deleted.</p><p><strong>Parameters:</strong></p><p><em>-</em> packet expired from the recv queue.</p>
<h3>virtual void IncomingDataQueue::onNewSyncSource (const \fBSyncSource\fP &)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Virtual called when a new synchronization source has joined the session.</p><p><strong>Parameters:</strong></p><p><em>-</em> new synchronization source</p>
<h3>virtual bool IncomingDataQueue::onRTPPacketRecv (\fBIncomingRTPPkt\fP &)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>
<p>A virtual function to support parsing of arriving packets to determine if they should be kept in the queue and to dispatch events. A generic header validity check (as specified in RFC 1889) is performed on every incoming packet. If the generic check completes successfully, this method is called before the packet is actually inserted into the reception queue.</p><p>May be used to perform additional validity checks or to do some application specific processing.</p><p><strong>Parameters:</strong></p><p><em>-</em> packet just received.</p><p><strong>Returns:</strong></p><p>true if packet is kept in the incoming packets queue.</p>
<h3>virtual bool IncomingDataQueue::onSRTPPacketError (\fBIncomingRTPPkt\fP &pkt, int32errorCode)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>
<p>A hook that gets called if the decoding of an incoming SRTP was erroneous.</p><p><strong>Parameters:</strong></p><p><em>pkt</em> The SRTP packet with error.</p><p><em>errorCode</em> The error code: -1 - SRTP authentication failure, -2 - replay check failed</p><p><strong>Returns:</strong></p><p>True: put the packet in incoming queue for further processing by the applications; false: dismiss packet. The default implementation returns false.</p>
<h3>void IncomingDataQueue::purgeIncomingQueue ()\fC [protected]\fP</h3>

<h3>void IncomingDataQueue::recordExtraction (const \fBIncomingRTPPkt\fP &pkt)\fC [protected]\fP</h3>
<p>Log extraction of a packet from this source from the scheduled reception queue.</p><p><strong>Parameters:</strong></p><p><em>pkt</em> Packet extracted from the queue.</p>
<h3>bool IncomingDataQueue::recordReception (\fBSyncSourceLink\fP &srcLink, const \fBIncomingRTPPkt\fP &pkt, const timevalrecvtime)\fC [protected]\fP</h3>
<p>Log reception of a new RTP packet from this source. Usually updates data such as the packet counter, the expected sequence number for the next packet and the time the last packet was received at.</p><p><strong>Parameters:</strong></p><p><em>srcLink</em> Link structure for the synchronization source of this packet.</p><p><em>pkt</em> Packet just created and to be logged.</p><p><em>recvtime</em> Reception time.</p><p><strong>Returns:</strong></p><p>whether, according to the source state and statistics, the packet is considered valid and must be inserted in the incoming packets queue.</p>
<h3>virtual size_t IncomingDataQueue::recvData (unsigned char *buffer, size_tlength, InetHostAddress &host, tpport_t &port)\fC [protected]\fP, \fC [pure virtual]\fP</h3>
<p>This function performs the physical I/O for reading a packet from the source. It is a virtual that is overridden in the derived class.</p><p><strong>Returns:</strong></p><p>number of bytes read.</p><p><strong>Parameters:</strong></p><p><em>buffer</em> of read packet.</p><p><em>length</em> of data to read.</p><p><em>host</em> address of source.</p><p><em>port</em> number of source.</p><p>Implemented in <strong>RTPDuplex</strong>.</p>
<h3>void IncomingDataQueue::removeInQueueCryptoContext (\fBCryptoContext\fP *cc)</h3>
<p>Remove input queue <strong>CryptoContext</strong>. The endQueue method (provided by RTPQueue) also deletes all registered CryptoContexts.</p><p><strong>Parameters:</strong></p><p><em>cc</em> Pointer to initialized <strong>CryptoContext</strong> to remove. If pointer if NULL<strong> then delete the whole queue</strong></p>
<h3>void IncomingDataQueue::renewLocalSSRC ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Reimplemented from <strong>RTPQueueBase</strong>.</p>
<h3>void IncomingDataQueue::setInQueueCryptoContext (\fBCryptoContext\fP *cc)</h3>
<p>Set input queue <strong>CryptoContext</strong>. The endQueue method (provided by RTPQueue) deletes all registered CryptoContexts.</p><p><strong>Parameters:</strong></p><p><em>cc</em> Pointer to initialized <strong>CryptoContext</strong>.</p>
<h3>void IncomingDataQueue::setMaxPacketDropout (uint16packets)\fC [inline]\fP</h3>
<p>It also prevents packets sent after a restart of the source being immediately accepted.</p>
<h3>void IncomingDataQueue::setMaxPacketMisorder (uint16packets)\fC [inline]\fP</h3>

<h3>void IncomingDataQueue::setMinValidPacketSequence (uint8packets)\fC [inline]\fP</h3>
<p>When receiving packets from a new source, it may be convenient to reject a first few packets before we are really sure the source is valid. This method sets how many data packets must be received in sequence before the source is considered valid and the stack starts to accept its packets.</p><p><strong>Note:</strong></p><p>the default (see <strong>defaultMinValidPacketSequence()</strong>) value for this parameter is 0, so that no packets are rejected (data packets are accepted from the first one).</p><p>this validation is performed after the generic header validation and the additional validation done in <strong>onRTPPacketRecv()</strong>.</p><p>if any valid RTCP packet is received from this source, it will be immediatly considered valid regardless of the number of sequential data packets received.</p><p><strong>Parameters:</strong></p><p><em>packets</em> number of sequential packet required</p>
<h3>void IncomingDataQueue::setSourceExpirationPeriod (uint8intervals)\fC [inline]\fP, \fC [protected]\fP</h3>
<p>Set the number of RTCP intervals that the stack will wait to change the state of a source from stateActive to stateInactive, or to delete the source after being in stateInactive. Note that this value should be uniform accross all participants and SHOULD be fixed for a particular profile.</p><p><strong>Parameters:</strong></p><p><em>intervals</em> number of RTCP report intervals</p><p><strong>Note:</strong></p><p>If RTCP is not being used, the RTCP interval is assumed to be the default: 5 seconds.</p><p>The default for this value is, as RECOMMENDED, 5.</p>
<h3>virtual size_t IncomingDataQueue::takeInDataPacket ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This function is used by the service thread to process the next incoming packet and place it in the receive list.</p><p><strong>Returns:</strong></p><p>number of payload bytes received. &lt;0 if error.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>std::list&lt;\fBCryptoContext\fP *&gt; IncomingDataQueue::cryptoContexts\fC [protected]\fP</h3>

<h3>Mutex IncomingDataQueue::cryptoMutex\fC [mutable]\fP, \fC [protected]\fP</h3>

<h3>const uint16 IncomingDataQueue::defaultMaxPacketDropout\fC [static]\fP, \fC [protected]\fP</h3>

<h3>const uint16 IncomingDataQueue::defaultMaxPacketMisorder\fC [static]\fP, \fC [protected]\fP</h3>

<h3>const size_t IncomingDataQueue::defaultMembersSize\fC [static]\fP, \fC [protected]\fP</h3>

<h3>const uint8 IncomingDataQueue::defaultMinValidPacketSequence\fC [static]\fP, \fC [protected]\fP</h3>

<h3>uint16 IncomingDataQueue::maxPacketDropout\fC [protected]\fP</h3>

<h3>uint16 IncomingDataQueue::maxPacketMisorder\fC [protected]\fP</h3>

<h3>uint8 IncomingDataQueue::minValidPacketSequence\fC [protected]\fP</h3>

<h3>IncomingRTPPktLink* IncomingDataQueue::recvFirst\fC [protected]\fP</h3>

<h3>IncomingRTPPktLink * IncomingDataQueue::recvLast\fC [protected]\fP</h3>

<h3>ThreadLock IncomingDataQueue::recvLock\fC [mutable]\fP, \fC [protected]\fP</h3>

<h3>uint8 IncomingDataQueue::sourceExpirationPeriod\fC [protected]\fP</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for ccRTP from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Image.3.html"><span aria-hidden="true">&larr;</span> Image.3: Specify an image array</a></li>
   <li class="next"><a href="IncomingDataQueueBase.3.html">IncomingDataQueueBase.3: Incomingdataqueuebase - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>iv_examples: Ivykis examples</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Ivykis examples">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="iv_examples (3) manual">
  <meta name="twitter:description" content="Ivykis examples">
  <meta name="twitter:image" content="https://www.carta.tech/images/libivykis-dev-iv_examples-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/iv_examples.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="iv_examples (3) manual" />
  <meta property="og:description" content="Ivykis examples" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libivykis-dev-iv_examples-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">iv_examples<small> (3)</small></h1>
        <p class="lead">Ivykis examples</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/iv_examples.3.html">
      <span itemprop="name">iv_examples: Ivykis examples</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libivykis-dev/">
      <span itemprop="name">libivykis-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/iv_examples.3.html">
      <span itemprop="name">iv_examples: Ivykis examples</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>ivykis is initialised by calling <a href="../man3/iv_init.3.html"><strong>iv_init</strong>(3)</a>. This function is the first function to call when dealing with ivykis -- it has to be called before registering file descriptors or timers.</p><p>The ivykis main event loop is started by calling <a href="../man3/iv_main.3.html"><strong>iv_main</strong>(3)</a>. This function generally does not return, except when <a href="../man3/iv_quit.3.html"><strong>iv_quit</strong>(3)</a> is called somewhere during execution of the program.</p><p>An application asks ivykis to monitor a certain file descriptor by filling out a structure of type 'struct iv_fd' with a file descriptor number and a callback function, and calling the function iv_fd_register.</p><p>The first example program waits for data from standard input, and writes a message to standard out whenever something is received:</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iv.h&gt;

struct iv_fd fd_stdin;

static void callback(void *dummy)
{
        char buf[1024];
        int len;

        len = read(fd_stdin.fd, buf, sizeof(buf));
        if (len &lt;= 0) {
                if (len &lt; 0) {
                        if (errno == EAGAIN)
                                return;
                        perror("read");
                }
                <strong>exit</strong>(1);
        }

        printf("read %d bytes of data from stdin&#92;n", len);
}

int main()
{
        iv_init();

        IV_FD_INIT(&fd_stdin);
        fd_stdin.fd = 0;
        fd_stdin.handler_in = callback;
        iv_fd_register(&fd_stdin);

        iv_main();

        iv_deinit();

        return 0;
}
</pre>
<p>The application is responsible for memory management of 'struct iv_fd's passed to ivykis.  For example, it should not free memory that contains such structures that are still registered with ivykis (i.e. haven't had iv_fd_unregister called on them).</p><p>iv_fd_register transparently sets the passed file descriptor to nonblocking mode, in anticipation of its future usage.</p><p>File descriptor callbacks are called in a level-triggered fashion. Therefore, the way of dealing with fd_stdin in the example callback function is safe.  In case there arrives data between read and detecting EAGAIN, ivykis will re-call the callback function after it returns.  Also, if there are more than 1024 bytes waiting in the input buffer, ivykis will re-call the callback function until all data from stdin have been drained.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE 2</h2>
        <div class="sectioncontent">
<p>The second example accepts connections on TCP port 6667, and waits on each of the connections for data.  When data is received on any connection, a message is printed to standard out.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iv.h&gt;
#include &lt;netinet/in.h&gt;

struct connection
{
        struct iv_fd            fd;
        /* other per-connection data goes here */
};

struct listening_socket
{
        struct iv_fd            fd;
        /* other per-listening socket data goes here */
};


static void connection_handler(void *_conn)
{
        struct connection *conn = (struct connection *)_conn;
        char buf[1024];
        int len;

        len = read(conn-&gt;fd.fd, buf, sizeof(buf));
        if (len &lt;= 0) {
                if (len &lt; 0 && errno == EAGAIN)
                        return;
                iv_fd_unregister(&conn-&gt;fd);
                close(conn-&gt;fd.fd);
                free(conn);
                return;
        }

        printf("got %d bytes of data from %p&#92;n", len, conn);
}

static void listening_socket_handler(void *_sock)
{
        struct listening_socket *sock = (struct listening_socket *)_sock;
        struct sockaddr_in addr;
        socklen_t addrlen;
        struct connection *conn;
        int fd;

        addrlen = sizeof(addr);
        fd = accept(sock-&gt;fd.fd, (struct sockaddr *)&addr, &addrlen);
        if (fd &lt; 0) {
                if (errno == EAGAIN)
                        return;
                perror("accept");
                <strong>exit</strong>(1);
        }

        conn = malloc(sizeof(*conn));
        if (conn == NULL) {
                fprintf(stderr, "listening_socket_handler: memory allocation error, dropping connection");
                close(fd);
                return;
        }

        IV_FD_INIT(&conn-&gt;fd);
        conn-&gt;fd.fd = fd;
        conn-&gt;fd.cookie = (void *)conn;
        conn-&gt;fd.handler_in = connection_handler;
        iv_fd_register(&conn-&gt;fd);
}

int main()
{
        struct listening_socket s;
        struct sockaddr_in addr;
        int fd;

        fd = socket(AF_INET, SOCK_STREAM, 0);
        if (fd &lt; 0) {
                perror("socket");
                <strong>exit</strong>(1);
        }

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port = htons(6667);
        if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) &lt; 0) {
                perror("bind");
                <strong>exit</strong>(1);
        }

        if (listen(fd, 4) &lt; 0) {
                perror("listen");
                <strong>exit</strong>(1);
        }

        iv_init();

        IV_FD_INIT(&s.fd);
        s.fd.fd = fd;
        s.fd.cookie = (void *)&s;
        s.fd.handler_in = listening_socket_handler;
        iv_fd_register(&s.fd);

        iv_main();

        iv_deinit();

        return 0;
}
</pre>
<p>As illustrated, it is possible to pass cookies into callback functions.  This is useful for conveying information on which higher-level entity (such as 'connection' or 'listening socket') generated the event for which the callback was called.</p><p>Note how it is possible to unregister and even free a 'struct iv_fd' in its own callback function.  There is logic in ivykis to deal with this case.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE 3</h2>
        <div class="sectioncontent">
<p>This example extends the previous example by a per-connection timer that disconnects the client after too long a period of inactivity.  Lines not present in example 2 or different than in example 2 are indicated by '//XXXX' in the right-hand margin.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iv.h&gt;
#include &lt;netinet/in.h&gt;

#define CONNECTION_TIMEOUT      (10)

struct connection
{
        struct iv_fd            fd;
        struct iv_timer         disconnect_timeout;              //XXXX
        /* other per-connection data goes here */
};

struct listening_socket
{
        struct iv_fd            fd;
        /* other per-listening socket data goes here */
};


static void connection_handler(void *_conn)
{
        struct connection *conn = (struct connection *)_conn;
        char buf[1024];
        int len;

        len = read(conn-&gt;fd.fd, buf, sizeof(buf));
        if (len &lt;= 0) {
                if (len &lt; 0 && errno == EAGAIN)
                        return;
                iv_timer_unregister(&conn-&gt;disconnect_timeout);  //XXXX
                iv_fd_unregister(&conn-&gt;fd);
                close(conn-&gt;fd.fd);
                free(conn);
                return;
        }

        printf("got %d bytes of data from %p&#92;n", len, conn);

        iv_timer_unregister(&conn-&gt;disconnect_timeout);          //XXXX
        iv_validate_now();                                       //XXXX
        conn-&gt;disconnect_timeout.expires = iv_now;               //XXXX
        conn-&gt;disconnect_timeout.expires.tv_sec += CONNECTION_TIMEOUT;//XXXX
        iv_timer_register(&conn-&gt;disconnect_timeout);            //XXXX
}

static void disconnect_timeout_expired(void *_conn)              //XXXX
{                                                                //XXXX
        struct connection *conn = (struct connection *)_conn;    //XXXX
        iv_fd_unregister(&conn-&gt;fd);                             //XXXX
        close(conn-&gt;fd.fd);                                      //XXXX
        free(conn);                                              //XXXX
}                                                                //XXXX

static void listening_socket_handler(void *_sock)
{
        struct listening_socket *sock = (struct listening_socket *)_sock;
        struct sockaddr_in addr;
        socklen_t addrlen;
        struct connection *conn;
        int fd;

        addrlen = sizeof(addr);
        fd = accept(sock-&gt;fd.fd, (struct sockaddr *)&addr, &addrlen);
        if (fd &lt; 0) {
                if (errno == EAGAIN)
                        return;
                perror("accept");
                <strong>exit</strong>(1);
        }

        conn = malloc(sizeof(*conn));
        if (conn == NULL) {
                fprintf(stderr, "listening_socket_handler: memory allocation error, dropping connection");
                close(fd);
                return;
        }

        IV_FD_INIT(&conn-&gt;fd);
        conn-&gt;fd.fd = fd;
        conn-&gt;fd.cookie = (void *)conn;
        conn-&gt;fd.handler_in = connection_handler;
        iv_fd_register(&conn-&gt;fd);

        IV_TIMER_INIT(&conn-&gt;disconnect_timeout);                //XXXX
        iv_validate_now();                                       //XXXX
        conn-&gt;disconnect_timeout.cookie = (void *)conn;          //XXXX
        conn-&gt;disconnect_timeout.handler = disconnect_timeout_expired;//XXXX
        conn-&gt;disconnect_timeout.expires = iv_now;               //XXXX
        conn-&gt;disconnect_timeout.expires.tv_sec += CONNECTION_TIMEOUT;//XXXX
        iv_timer_register(&conn-&gt;disconnect_timeout);            //XXXX
}

int main()
{
        struct listening_socket s;
        struct sockaddr_in addr;
        int fd;

        fd = socket(AF_INET, SOCK_STREAM, 0);
        if (fd &lt; 0) {
                perror("socket");
                <strong>exit</strong>(1);
        }

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port = htons(6667);
        if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) &lt; 0) {
                perror("bind");
                <strong>exit</strong>(1);
        }

        if (listen(fd, 4) &lt; 0) {
                perror("listen");
                <strong>exit</strong>(1);
        }

        iv_init();

        IV_FD_INIT(&s.fd);
        s.fd.fd = fd;
        s.fd.cookie = (void *)&s;
        s.fd.handler_in = listening_socket_handler;
        iv_fd_register(&s.fd);

        iv_main();

        iv_deinit();

        return 0;
}
</pre>
<p>The global variable 'iv_now' contains the current time-of-day. However, it is updated lazily, and its contents might be stale at any given time.  Before using it, <a href="../man3/iv_validate_now.3.html"><strong>iv_validate_now</strong>(3)</a> must be called.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE 4</h2>
        <div class="sectioncontent">
<p>The fourth example demonstrates how to use a custom fatal error handler that does not write the message to syslog.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;iv.h&gt;

static void fatal_error(const char *msg)
{
        fprintf(stderr, "ivykis: FATAL ERROR: %s&#92;n", msg);
}

int main()
{
        iv_init();
        iv_set_fatal_msg_handler(fatal_error);

        iv_fatal("Programmatically triggered fatal error %d.", 42);
        printf("This code is never reached.&#92;n");

        iv_deinit();

        return 0;
}
</pre>
<p>This program will abort immediately, with the error message printed to the standard error stream.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO iv_examples&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/ivykis.3.html"><strong>ivykis</strong>(3)</a>, <a href="../man3/iv_fatal.3.html"><strong>iv_fatal</strong>(3)</a>, <a href="../man3/iv_fd.3.html"><strong>iv_fd</strong>(3)</a>, <a href="../man3/iv_timer.3.html"><strong>iv_timer</strong>(3)</a>, <a href="../man3/iv_task.3.html"><strong>iv_task</strong>(3)</a>, <a href="../man3/iv_init.3.html"><strong>iv_init</strong>(3)</a>, <a href="../man3/iv_time.3.html"><strong>iv_time</strong>(3)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="iv_event_unregister.3.html"><span aria-hidden="true">&larr;</span> iv_event_unregister.3: Manage ivykis objects for event notification</a></li>
   <li class="next"><a href="iv_fatal.3.html">iv_fatal.3: Ivykis fatal error condition handling <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

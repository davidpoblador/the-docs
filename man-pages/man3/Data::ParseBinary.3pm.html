<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Data::ParseBinary: Yet another parser for binary structures</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Yet another parser for binary structures">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Data::ParseBinary (3pm) manual">
  <meta name="twitter:description" content="Yet another parser for binary structures">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdata-parsebinary-perl-Data::ParseBinary-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Data::ParseBinary.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Data::ParseBinary (3pm) manual" />
  <meta property="og:description" content="Yet another parser for binary structures" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdata-parsebinary-perl-Data::ParseBinary-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Data::ParseBinary<small> (3pm)</small></h1>
        <p class="lead">Yet another parser for binary structures</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::ParseBinary.3pm.html">
      <span itemprop="name">Data::ParseBinary: Yet another parser for binary structures</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdata-parsebinary-perl/">
      <span itemprop="name">libdata-parsebinary-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::ParseBinary.3pm.html">
      <span itemprop="name">Data::ParseBinary: Yet another parser for binary structures</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    $s =
    Struct("Construct",
        Struct("Header",
            Magic("MZ"),
            Byte("Version"),
            UBInt32("Expire Date"),
            Enum(UBInt32("Data Type"),
                Array =&gt; 0,
                String =&gt; 1,
                Various =&gt; 2,
            ),
            Byte("Have Extended Header"),
            If ( sub { $_-&gt;ctx-&gt;{"Have Extended Header"} },
                CString("Author")
            ),
        ),
        Switch("data", sub { $_-&gt;ctx-&gt;{Header}-&gt;{"Data Type"} },
            {
                Array =&gt; Array(4, SBInt32("Signed Int 32")),
                String =&gt; PascalString("Name"),
                Various =&gt;
                    Struct("Various data",
                        NoneOf(Byte("value"), [4, 9]),
                        <strong>Padding</strong>(1), # byte
                        BitStruct("Mini Values",
                            Flag("done"),
                            Nibble("Short"),
                            <strong>Padding</strong>(1), #bit
                            SBInt16("something"),
                        ),
                    ),
            }
        ),
    );
    my $data = $s-&gt;parse("MZabcde&#92;0&#92;0&#92;0&#92;1&#92;1semuel&#92;0&#92;x05fghij");
    # $data contains:
    #    {
    #        &apos;Header&apos; =&gt;
    #        {
    #            &apos;Version&apos; =&gt; 97,
    #            &apos;Expire Date&apos; =&gt; 1650680933
    #            &apos;Data Type&apos; =&gt; &apos;String&apos;,
    #            &apos;Have Extended Header&apos; =&gt; 1,
    #            &apos;Author&apos; =&gt; &apos;semuel&apos;,
    #        }
    #        &apos;data&apos; =&gt; &apos;fghij&apos;,
    #    }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is a Perl Port for PyConstructs http://construct.wikispaces.com/</p><p>This module enables writing declarations for simple and complex binary structures, parsing binary to hash/array data structure, and building binary data from hash/array data structure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Reference Code</h2>
        <div class="sectioncontent">
<h3>Struct</h3>
<p>    $s = Struct("foo",         UBInt8("a"),         UBInt16("b"),         Struct("bar",             UBInt8("a"),             UBInt16("b"),         )     );     $data = $s-&gt;parse("ABBabb");     # $data is { a =&gt; 65, b =&gt; 16962, bar =&gt; { a =&gt; 97, b =&gt; 25186 } }</p><p>This is the main building block of the module - the struct. Whenever there is the need to bind a few varibles together, use Struct. Many constructs receive only one sub-construct as parameter, (for example, all the conditional constructs) so use Struct.</p>
<h3>Primitives</h3>
<p><em>Byte-Primitives</em></p><p>But this Struct is just an empy shell. we need to fill it with data types. So here is a list of primitive elements:</p><p>    Byte, UBInt8, ULInt8 (All three are aliases to the same things)     SBInt8, SLInt8     UBInt16     ULInt16     SBInt16     SLInt16     UBInt32     ULInt32     SBInt32     SLInt32     BFloat32     LFloat32     UBInt64     ULInt64     SBInt64     SLInt64     BFloat64     LFloat64</p><p>S - Signed, U - Unsigned, L - Little endian, B - Big Endian Samples:</p><p>    UBInt16("foo")-&gt;parse("&#92;x01&#92;x02") == 258     ULInt16("foo")-&gt;parse("&#92;x01&#92;x02") == 513     UBInt16("foo")-&gt;build(31337) eq &apos;zi&apos;     SBInt16("foo")-&gt;build(-31337) eq "&#92;x85&#92;x97"     SLInt16("foo")-&gt;build(-31337) eq "&#92;x97&#92;x85"</p><p>And of course, see Struct above to how bundle a few primitives together.</p><p>Be aware that the Float data type is not portable between platforms. So it is advisable not to use it when there is an alternative.</p><p><em>Bit-Primitives</em></p><p>    Flag, Bit (1 bit)     Nibble (4 bits)     Octet (8 bits, equal to "Byte")     BitField (variable length)</p><p>These primitive are bit-wide. however, unless using BitStruct, they take a whole byte from the input stream. Take for example this struct:</p><p>    $s = Struct("bits",         Flag("a"),         Nibble("b"),     );     $data = $s-&gt;parse("&#92;x25&#92;x27");     # data is { a =&gt; 1, b =&gt; 7 }</p><p>\*(L"&#92;x25&#92;x27\*(R" is 0010010100100111 in binary. The Flag is first, and it takes one byte from the stream (00100101) use the last bit (1) and discard the rest. After it comes the Mibble, that takes a byte too, (00100111) use the last four bits (0111) and discard the rest.</p><p>If you need these bits to be packed tight together, see BitStruct.</p><p>Examples for the rest of the bit constructs:</p><p>    $s = Struct("bits",         Octet("a"),         BitField("b", 5),     );     $data = $s-&gt;parse("&#92;x25&#92;x27");     # data is { a =&gt; 37, b =&gt; 7 }</p>
<h3>Meta-Constructs</h3>
<p>Life isn't always simple. If you only have a rigid structure with constance types, then you can use other modules, that are far simplier. hack, use pack/unpack.</p><p>So if you have more complicate requirements, welcome to the meta-constructs. Basically, you pass a code ref to the meta-construct, which will be used while parsing and building.</p><p>For every data that the code ref needs, the $_ variable is loaded with all the data that you need. $_-&gt;ctx is equal to $_-&gt;<em>ctx</em>\|(0), that returns hash-ref containing all the data that the current struct parsed. Is you want to go another level up, just request $_-&gt;<em>ctx</em>\|(1).</p><p>Also avialble are $_-&gt;obj, when need to inspect the current object, (see RepeatUntil) and $_-&gt;stream, which gives the current stream. (mostly used as $_-&gt;stream-&gt;tell to get the current location)</p><p>As a rule, everywhere a code-ref is used, a simple number can be used too. If it doesn't - it's a bug. please report it.</p>
<h3>Meta-Primitives</h3>
<p><em>Field (Bytes)</em></p><p>The first on is the field. a Field is a chunk of bytes, with variable length:</p><p>    $s = Struct("foo",         Byte("length"),         Field("data", sub { $_-&gt;ctx-&gt;{length} }),     );</p><p>(it can be also in constent length, by replacing the code section with, for example, 4) So we have struct, that the first byte is the length of the field, and after that the field itself. An example:</p><p>    $data = $s-&gt;parse("&#92;x03ABC");     # $data is {length =&gt; 3, data =&gt; "ABC"}     $data = $s-&gt;parse("&#92;x04ABCD");     # $data is {length =&gt; 4, data =&gt; "ABCD"}</p><p>And so on.</p><p>Field is also called Bytes.</p><p><em>Value</em></p><p>A calculated value - not in the stream. It is calculated on both parse and build.</p><p>    $s = Struct("foo",         UBInt8("width"),         UBInt8("height"),         Value("total_pixels", sub { $_-&gt;ctx-&gt;{width} * $_-&gt;ctx-&gt;{height}}),     );</p><p><em>Alias</em></p><p>Copies \*(L"a\*(R" to \*(L"b\*(R".</p><p>    $s = Struct("foo",         Byte("a"),         Alias("b", "a"),     );     $data = $s-&gt;parse("&#92;x25");     # $data is { a =&gt; 37, b =&gt; 37 }</p>
<h3>Conditionals</h3>
<p><em>If / IfThenElse</em></p><p>Basic branching:</p><p>    $s = Struct("foo",         Flag("has_options"),         If(sub { $_-&gt;ctx-&gt;{has_options} },             Bytes("options", 5)         )     );</p><p>The If statment takes it's name from the contained construct, and return undef of the condition is not met.</p><p>    $s = Struct("foo",         Flag("long_options"),         IfThenElse("options", sub { $_-&gt;ctx-&gt;{long_options} },             Bytes("Long Options", 5),             Bytes("Short Options", 3),         ),     );</p><p>The IfThenElse discard the name of the contained consturct, and use its own.</p><p><em>Switch</em></p><p>Multi branching. Can operate on numbers or strings. In the first example used with Enum to convert a value to string.</p><p>The Switch discard the name of the contained consturcts, and use its own. return undef if $DefaultPass is used.</p><p>    $s = Struct("foo",         Enum(Byte("type"),             INT1 =&gt; 1,             INT2 =&gt; 2,             INT4 =&gt; 3,             STRING =&gt; 4,         ),         Switch("data", sub { $_-&gt;ctx-&gt;{type} },             {                 INT1 =&gt; UBInt8("spam"),                 INT2 =&gt; UBInt16("spam"),                 INT4 =&gt; UBInt32("spam"),                 STRING =&gt; String("spam", 6),             }         )     );     $data = $s-&gt;parse("&#92;x01&#92;x12");     # $data is {type =&gt; "INT1", data =&gt; 18}     $data = $s-&gt;parse("&#92;x02&#92;x12&#92;x34");     # $data is {type =&gt; "INT2", data =&gt; 4660}     $data = $s-&gt;parse("&#92;x04abcdef");     # $data is {type =&gt; "STRING", data =&gt; &apos;abcdef&apos;}</p><p>And so on. Switch also have a default option:</p><p>    $s = Struct("foo",         Byte("type"),         Switch("data", sub { $_-&gt;ctx-&gt;{type} },             {                 1 =&gt; UBInt8("spam"),                 2 =&gt; UBInt16("spam"),             },             default =&gt; UBInt8("spam")         )     );</p><p>And can use $DefaultPass that make it to no-op.</p><p>    $s = Struct("foo",         Byte("type"),         Switch("data", sub { $_-&gt;ctx-&gt;{type} },             {                 1 =&gt; UBInt8("spam"),                 2 =&gt; UBInt16("spam"),             },             default =&gt; $DefaultPass,         )     );     $data = $s-&gt;parse("&#92;x01&#92;x27");     # $data is { type =&gt; 1, data =&gt; 37 }</p><p>$DefaultPass is valid also as one of the options:</p><p>    $s = Struct("foo",         Byte("type"),         Switch("data", sub { $_-&gt;ctx-&gt;{type} },             {                 1 =&gt; $DefaultPass,                 2 =&gt; UBInt16("spam"),             },             default =&gt; UBInt8("spam"),         )     );     $data = $s-&gt;parse("&#92;x01&#92;x27");     # $data is { type =&gt; 1, data =&gt; undef }</p>
<h3>Loops</h3>
<p><em>Array</em></p><p>Array, as any meta construct, and have constant length or variable lenght.</p><p>    # This is an Array of four bytes     $s = Array(4, UBInt8("foo"));     $data = $s-&gt;parse("&#92;x01&#92;x02&#92;x03&#92;x04");     # $data is [1, 2, 3, 4]</p><p>    # Array with variable length     $s = Struct("foo",         Byte("length"),         Array(sub { $_-&gt;ctx-&gt;{length}}, UBInt16("data")),     );     $data = $s-&gt;parse("&#92;x03&#92;x00&#92;x01&#92;x00&#92;x02&#92;x00&#92;x03");     # $data is {length =&gt; 3, data =&gt; [1, 2, 3]}</p><p><em>RepeatUntil</em></p><p>RepeatUntil gets for every round to inspect data on $_-&gt;obj:</p><p>    $s = RepeatUntil(sub {$_-&gt;obj eq "&#92;x00"}, Field("data", 1));     $data = $s-&gt;parse("abcdef&#92;x00this is another string");     # $data is [qw{a b c d e f}, "&#92;0"]</p>
<h3>Adapters</h3>
<p>Adapters are constructs that transform the data that they work on. It wraps some underlining structure, and present the data in a new, easier to use, way. There are some built-in adapters for general use, but it is easy to write one of your own.</p><p>This is actually the easiest way to extend the framework. For creating an adapter, the class should inherent from the Data::ParseBinary::Adapter class. For example, we will take the \s-1IP\s0 address. An \s-1IP\s0 address can be viewed as four bytes, or one unsigned long integer, but humans like to see it as dotted numbers. (\*(L"1.2.3.4\*(R") Here is how I would have done it. First, I'll write an adapter class:</p><p>    package IpAddressAdapter;     our @ISA = qw{Data::ParseBinary::Adapter};     sub _encode {         my ($self, $tvalue) = @_;         return [split &apos;&#92;.&apos;, $tvalue];     }     sub _decode {         my ($self, $value) = @_;         return join &apos;.&apos;, @$value;     }</p><p>This adapter transforms dotted \s-1IP\s0 address (\*(L"1.2.3.4\*(R") to four numbers. Each number size is \*(L"byte\*(R", so we will use an array of four bytes. For actually creating one we should write:</p><p>    my $ipAdapter = IpAddressAdapter-&gt;create(Array(4, Byte("foo")));</p><p>(An adapter inherits its name from the underlying data construct)</p><p>Or we can create a little function:</p><p>    sub IpAddressAdapterFunc {         my $name = shift;         IpAddressAdapter-&gt;create(Array(4, Byte($name)));     }</p><p>And then:</p><p>    IpAddressAdapterFunc("foo")-&gt;parse("&#92;x01&#92;x02&#92;x03&#92;x04");     # will return "1.2.3.4"</p><p>On additional note, it is possible to declare an \*(L"init\*(R" sub inside IpAddressAdapter, that will receive any extra parameter that \*(L"create\*(R" recieved.</p><p><em>Enum</em></p><p>One of the built-in Adapters is Enum:</p><p>    $s = Enum(Byte("protocol"),         TCP =&gt; 6,         UDP =&gt; 17,     );     $s-&gt;parse("&#92;x06") # return &apos;TCP&apos;     $s-&gt;parse("&#92;x11") # return &apos;UDP&apos;     $s-&gt;build("TCP") # returns "&#92;x06"</p><p>It is also possible to have a default:</p><p>    $s = Enum(Byte("protocol"),         TCP =&gt; 6,         UDP =&gt; 17,         _default_ =&gt; blah =&gt; 99,     );     $s-&gt;parse("&#92;x12") # returns &apos;blah&apos;</p><p>Please note that the default tag must not be one of the supplied pairs. And finally:</p><p>    $s = Enum(Byte("protocol"),         TCP =&gt; 6,         UDP =&gt; 17,         _default_ =&gt; $DefaultPass,     );     $s-&gt;parse("&#92;x12") # returns 18</p><p>$DefaultPass tells Enum that if it isn't familiar with the value, pass it alone.</p><p><em>FlagsEnum</em></p><p>If the field represent a set of flags, then the library provide a construct just for that:</p><p>    $s = FlagsEnum(ULInt16("characteristics"),         RELOCS_STRIPPED =&gt; 0x0001,         EXECUTABLE_IMAGE =&gt; 0x0002,         LINE_NUMS_STRIPPED =&gt; 0x0004,         REMOVABLE_RUN_FROM_SWAP =&gt; 0x0400,         BIG_ENDIAN_MACHINE =&gt; 0x8000,     );     $data = $s-&gt;parse("&#92;2&#92;4");     # $data is { EXECUTABLE_IMAGE =&gt; 1, REMOVABLE_RUN_FROM_SWAP =&gt; 1 };</p><p>Of course, this is equvalent to creating a BitStruct, and specifing Flag-s in the correct positions, and so on. but this is an easier way.</p>
<h3>Validators</h3>
<p>Validator... validate. they validate that the value on the stream is an expected one, and they validate that the value that need to be written to the stream is a correct one. otherwise, throws an exception.</p><p><em>OneOf / NoneOf</em></p><p>    OneOf(UBInt8("foo"), [4,5,6,7])-&gt;parse("&#92;x05") # return 5     OneOf(UBInt8("foo"), [4,5,6,7])-&gt;parse("&#92;x08") # dies.     NoneOf(UBInt8("foo"), [4,5,6,7])-&gt;parse("&#92;x08") # returns 8     NoneOf(UBInt8("foo"), [4,5,6,7])-&gt;parse("&#92;x05") # dies</p><p><em>Const</em></p><p>    $s = Const(Bytes("magic", 6), "FOOBAR");</p><p>On parsing: verify that the correct value is being read, and return it.</p><p>On building: if value is supplied, verify that it is the correct one. if the value is not supplied, insert the correct one.</p><p><em>Magic</em></p><p>    Magic("&#92;x89PNG&#92;r&#92;n&#92;x1a&#92;n")</p><p>A constant string that is written / read and verified to / from the stream. For example, every \s-1PNG\s0 file starts with eight pre-defined bytes. this construct handle them, transparant to the calling program. (you don't need to supply a value, nor you will see the parsed value)</p>
<h3>BitStruct</h3>
<p>As said in the section about Bit-Primitives, these primitives are not packed tightly, and each will take complete bytes from the stream. If you need to pack them tightly, use BitStruct:</p><p>    $s = BitStruct("foo",         BitField("a", 3), # three bit int         Flag("b"),  # one bit         Nibble("c"),  # four bit int         BitField("d", 5), # five bit int     );     $data = $s-&gt;parse("&#92;xe1&#92;xf2");     # $data is { a =&gt; 7, b =&gt; 0, c =&gt; 1, d =&gt; 30 }</p><p>As can be seen, we start with 1110000111110010. The it is being splitted as a=111, b=0, c=0001, d=11110 and the rest (010) is discard.</p><p>BitStruct can be inside other BitStruct. Inside BitStruct, Struct and BitStruct are equivalents.</p><p>    $s = BitStruct("foo",         BitField("a", 3),         Flag("b"),         Nibble("c"),         Struct("bar",             Nibble("d"),             Bit("e"),             Octet("f"),         )     );     $data = $s-&gt;parse("&#92;xe1&#92;xf2&#92;x34");     # $data is { a =&gt; 7, b =&gt; 0, c =&gt; 1, bar =&gt; { d =&gt; 15, e =&gt; 0, f =&gt; 70 } }</p><p>It is possible to mix a byte-primitives inside a BitStruct:</p><p>    $s = BitStruct("foo",         BitField("a", 3),         UBInt16("int data"),         Nibble("b"),     );     $data = $s-&gt;parse("&#92;xe1&#92;xf2&#92;x34");     # $data is { a =&gt; 7, "int data" =&gt; 3985, b =&gt; 10 }</p><p>Just be aware that this UBInt16 starts from the middle of the first byte, and ends in the middle of the third.</p><p>BitStruct is based on a BitStream (see Stream) that is not seekable. So it can't contain any construct that require seekability.</p><p><em>Bitwise</em></p><p>Use Bitwise when you are not under a BitStream, and you have single construct that need to be packed by bits, and you don't want to create another hash for just this construct. Here is an example from \s-1BMP:\s0</p><p>    Bitwise(Array(sub { $_-&gt;<strong>ctx</strong>(2)-&gt;{width} }, Nibble("index")));</p><p>We have an array of Nibble, that need to be packed together.</p>
<h3>ReversedBitStruct and ReversedBitField</h3>
<p>BitStruct assumes that each byte is arranged, bit-wise, from the most significante bit (\s-1MSB\s0) to the least significante bit. (\s-1LSB\s0) However, it is not always true.</p><p>Lets say that you bytes are:</p><p>          MSB             LSB     Byte 1: A B C D E F G H     Byte 2: I J K M L N O P</p><p>And suppose that you have a bit-struct with three fields. \s-1AF1\s0 is three bits, \s-1AF2\s0 is one bit, and \s-1AF3\s0 is eight bits. so if:</p><p>    AF1=ABC, AF2=D, AF3=EFGHIJKM     use: BitStruct with BitField     AF1=CBA, AF2=D, AF3=MKJIHGFE     use: BitStruct with ReversedBitField     AF1=HGF, AF2=E, AF3=DCBAPONL     use: ReversedBitStruct with BitField     AF1=FGH, AF2=E, AF3=LNOPABCD     use: ReversedBitStruct with ReversedBitField</p>
<h3>Padding</h3>
<p>Padding remove bytes from the stream</p><p>    $s = Struct("foo",         <strong>Padding</strong>(2),         Flag("myflag"),         <strong>Padding</strong>(5),     );     $data = $s-&gt;parse("&#92;x00&#92;x00&#92;x01&#92;x00&#92;x00&#92;x00&#92;x00&#92;x00");     # $data is { myflag =&gt; 1 }</p><p>However, if woring on Bit Stream, then Padding takes bits and not bytes</p><p>    $s = BitStruct("foo",         <strong>Padding</strong>(2),         Flag("myflag"),         <strong>Padding</strong>(5),     );     $data = $s-&gt;parse("&#92;x20");     # $data is { myflag =&gt; 1 }</p><p>Padding is a meta-construct, can take code ref instead of a number</p><p>    $s = Struct("foo",         Byte("count"),         Padding( sub { $_-&gt;ctx-&gt;{count} } ),         Flag("myflag"),     );     $data = $s-&gt;parse("&#92;x02&#92;0&#92;0&#92;1");     # $data is { count =&gt; 2, muflag =&gt; 1 }</p>
<h3>Peeking and Jumping</h3>
<p>Not all parsing is linear. sometimes you need to peek ahead to see if a certain value exists ahead, or maybe you know where the data is, it's just that it is some arbitary number of bytes ahead. or before.</p><p><em>Pointer and Anchor</em></p><p>Pointers are another animal of meta-struct. For example:</p><p>    $s = Struct("foo",         Pointer(sub { 4 }, Byte("data1")),   # &lt;-- data1 is at (absolute) position 4         Pointer(sub { 7 }, Byte("data2")),   # &lt;-- data2 is at (absolute) position 7     );     $data = $s-&gt;parse("&#92;x00&#92;x00&#92;x00&#92;x00&#92;x01&#92;x00&#92;x00&#92;x02");     # $data is {data1=&gt; 1 data2=&gt;2 }</p><p>Literaly is says: jump to position 4, read byte, return to the beginning, jump to position 7, read byte, return to the beginning.</p><p>Anchor can help a Pointer to find it's target:</p><p>    $s = Struct("foo",         Byte("padding_length"),         Padding(sub { $_-&gt;ctx-&gt;{padding_length} } ),         Byte("relative_offset"),         Anchor("absolute_position"),         Pointer(sub { $_-&gt;ctx-&gt;{absolute_position} + $_-&gt;ctx-&gt;{relative_offset} }, Byte("data")),     );     $data = $s-&gt;parse("&#92;x05&#92;x00&#92;x00&#92;x00&#92;x00&#92;x00&#92;x03&#92;x00&#92;x00&#92;x00&#92;xff");     # $data is { absolute_position=&gt; 7, relative_offset =&gt; 3, data =&gt; 255, padding_length =&gt; 5 }</p><p>Anchor saves the current location in the stream, enable the Pointer to jump to location relative to it.</p><p>Also, $_-&gt;stream-&gt;tell will point you to the current location, giving the ability for relative location without using Anchor. The above construct is quevalent to:</p><p>    $s = Struct("foo",         Byte("padding_length"),         Padding(sub { $_-&gt;ctx-&gt;{padding_length} } ),         Byte("relative_offset"),         Pointer(sub { $_-&gt;stream-&gt;tell + $_-&gt;ctx-&gt;{relative_offset} }, Byte("data")),     );</p><p><em>Peek</em></p><p>    $s = Struct("foo",         Byte("a"),         Peek(Byte("b")),         Byte("c"),     );</p><p>Peek is like Pointer with two differences: one that it is no-op on build. second the location is calculated relative to the current location, while with Pointer it's absolute position.</p><p>If no distance is supplied, zero is assumed. it is posible to supply constant distance, (i.e. 5) or code ref. Examples:</p><p>    Peek(UBInt16("b"), 5) # Peek 5 bytes ahead     Peek(UBInt16("b"), sub { $_-&gt;ctx-&gt;{this_far} }) # calculated number of bytes ahead</p>
<h3>Strings</h3>
<p><em>Char</em></p><p>The Char construct represent a single character. This can mean one byte, or if it have encoding attached, a multi-byte character.</p><p>    $s = Char("c", "utf8");     $s-&gt;build("&#92;x{1abcd}");     # returns "&#92;xf0&#92;x9a&#92;xaf&#92;x8d"</p><p>The allowded encodings are:</p><p>    UTF-32LE     UTF-32BE     UTF-16LE     UTF-16BE     UTF-8     utf8     or any single-byte encoding supported by the Encode module     for example: iso-8859-8</p><p>If you don't know if your unicode string is \s-1BE\s0 or \s-1LE\s0, then it's probably \s-1BE\s0.</p><p><em>String (constant length / meta)</em></p><p>A string with constant length:</p><p>    String("foo", 5)-&gt;parse("hello")     # returns "hello"</p><p>A string with variable length, and encoding:</p><p>    String("description", sub { $_-&gt;ctx-&gt;{description_size} }, encoding =&gt; &apos;UTF-16LE&apos; )</p><p>The string length is specified in *characters*, not bytes.</p><p><em>PaddedString</em></p><p>A Padded string with constant length:</p><p>    $s = PaddedString("foo", 10, padchar =&gt; "X", paddir =&gt; "right");     $s-&gt;parse("helloXXXXX") # return "hello"     $s-&gt;build("hello") # return &apos;helloXXXXX&apos;</p><p>I think that it speaks for itself. only that paddir can be one of qw{right left center}, and there can be also trimdir that can be \*(L"right\*(R" or \*(L"left\*(R".</p><p>When encoding is supplied, for example:</p><p>    $s = PaddedString("foo", 10, encoding =&gt; "utf8");</p><p>The String length is still specified in *bytes*, not characters. If anyone ever encouter a padded constant length string with multi byte encoding that it's length is specified in characters, please send me an email.</p><p><em>PascalString</em></p><p>PascalString - String with a length marker in the beginning:</p><p>    $s = PascalString("foo");     $s-&gt;build("hello world") # returns "&#92;x0bhello world"</p><p>The marker can be of any kind:</p><p>    $s = PascalString("foo", &#92;&UBInt16);     $s-&gt;build("hello") # returns "&#92;x00&#92;x05hello"</p><p>(the marker can be pointer to any function that get a name and return construct. And on parse that construct should return a value. like the built-in primitives for example)</p><p>With encoding:</p><p>    $s = PascalString("foo", undef, "utf8");</p><p>The string length is specified in *characters*, not bytes.</p><p><em>CString</em></p><p>And finally, CString:</p><p>    $s = CString("foo");     $s-&gt;parse("hello&#92;x00") # returns &apos;hello&apos;</p><p>Can have many optional terminators:</p><p>    $s = CString("foo", terminators =&gt; "XYZ");     $s-&gt;parse("helloY") # returns &apos;hello&apos;</p><p>With encoding:</p><p>    $s = CString("foo", encoding =&gt; "utf8");</p>
<h3>Union / RoughUnion</h3>
<p>    $s = Union("foo",         UBInt32("a"),         UBInt16("b")     );     $data = $s-&gt;parse("&#92;xaa&#92;xbb&#92;xcc&#92;xdd");     # $data is { a =&gt; 2864434397, b =&gt; 43707 }</p><p>A Union. currently work only with constant-size constructs, (like primitives, Struct and such) but not on bit-stream.</p><p>    $s = Struct("records",         ULInt32("record_size"),         RoughUnion("params",             Field("raw", sub { $_-&gt;<strong>ctx</strong>(1)-&gt;{record_size} - 8 }),             Array(sub { int(($_-&gt;<strong>ctx</strong>(1)-&gt;{record_size} - 8) / 4) }, ULInt32("params")),         ),     );</p><p>RoughUnion is a type of Union, that doesn't check the size of it's sub-constructs. it is used when we don't know before-hand the size of the sub-constructs, and the size of the union as a whole. In the above example, we assume that if the union target is the array of integers, then it probably record_size % 4 = 0.</p><p>If it's not, and we build this construct from the array, then we will be a few bytes short.</p>
<h3>Aligned</h3>
<p>    $s = Struct("bmp",         ULInt32("width"),         ULInt32("height"),         Array(             sub { $_-&gt;ctx-&gt;{height} },             Aligned(                 Array(                     sub { $_-&gt;<strong>ctx</strong>(2)-&gt;{width} },                     Byte("index")                 ),             4),         ),     );</p><p>Aligned make sure that the contained construct's size if dividable by $modulo. the syntex is:</p><p>    Aligned($subcon, $modulo);</p><p>In the above example, we have an excert from the \s-1BMP\s0 parser. each pixel is a byte. There is an array of lines (height) that each line is an array of pixels. each line is aligned to a four bytes boundary.</p><p>The modulo can be any number. 2, 4, 8, 7, 23.</p>
<h3>Terminator</h3>
<p>    Terminator()-&gt;parse("")</p><p>verify that we reached the end of the stream. Not very useful, unless you are processing a file and need to verify that you have reached the end</p>
<h3>LasyBound</h3>
<p>This construct is estinental for recoursive constructs.</p><p>    $s = Struct("foo",         Flag("has_next"),         If(sub { $_-&gt;ctx-&gt;{has_next} }, LazyBound("next", sub { $s })),     );     $data = $s-&gt;parse("&#92;x01&#92;x01&#92;x01&#92;x00");     # $data is:     #    {     #        has_next =&gt; 1,     #        next =&gt; {     #            has_next =&gt; 1,     #            next =&gt; {     #                has_next =&gt; 1,     #                next =&gt; {     #                    has_next =&gt; 0,     #                    next =&gt; undef     #                }     #            }     #        }     #    }</p>
<h3>Sequence</h3>
<p>Similar to Struct, just return an arrat reference instead of hash ref</p><p>    $s = Sequence("foo",         UBInt8("a"),         UBInt16("b"),         Sequence("bar",             UBInt8("a"),             UBInt16("b"),         )     );     $data = $s-&gt;parse("ABBabb");     # $data is [ 65, 16962, [ 97, 25186 ] ]</p><p>Be aware that not every construct works well under Sequence. For example, Value will have problems on building. Using Struct is prefered.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Depricated Constructs</h2>
        <div class="sectioncontent">
<p>A few construct are being depricated - for the reason that while parsing a binary stream, you should know before-hand what are you going to get. If needed, it is possible to use Peek or Pointer to look ahead.</p><p>These will be exported only by request, or by using the :all tag</p><p>        use Data::ParseBinary qw{:all};         use Data::ParseBinary qw{UNInt64 OptionalGreedyRange};</p><h3>Primitives</h3>
<p>The following primitives are depricated, because I don't think it's good practice to declare a structure with native-order byte order. What if someone will run your program in a machine with the oposite byte order?</p><p>N stand for Platform natural</p><p>    UNInt8     SNInt8     UNInt16     SNInt16     UNInt32     SNInt32     UNInt64     SNInt64     NFloat32     NFloat64</p><p>These will be exported only by request, or by using the :NATURALS tag</p><p>        use Data::ParseBinary qw{:NATURALS};</p>
<h3>Ranges</h3>
<p>Please use Array, with constant or dynamic number of elements</p><p>    # This is an array for 3 to 7 bytes     $s = Range(3, 7, UBInt8("foo"));     $data = $s-&gt;parse("&#92;x01&#92;x02&#92;x03");     $data = $s-&gt;parse("&#92;x01&#92;x02&#92;x03&#92;x04&#92;x05&#92;x06&#92;x07&#92;x08&#92;x09");     # in the last example, will take only 7 bytes from the stream</p><p>    # A range with at least one byte, unlimited     $s = GreedyRange(UBInt8("foo"));</p><p>    # A range with zero to unlimited bytes     $s = OptionalGreedyRange(UBInt8("foo"));</p>
<h3>Optional</h3>
<p>Optional construct may or may not be in the stream. Of course, it need a seekable stream. The optional section usually have a Const in them, that indicates is this section exists.</p><p>    my $wmf_file = Struct("wmf_file",         Optional(             Struct("placeable_header",                 Const(ULInt32("key"), 0x9AC6CDD7),                 ULInt16("handle"),             ),         ),         ULInt16("version"),         ULInt32("size"), # file size is in words     );</p><p>A better way is to Peek ahead, and decide if this part exists:</p><p>    my $wmf_file = Struct("wmf_file",         Peek(ULInt32("header_key")),         If(sub { $_-&gt;ctx-&gt;{header_key} == 0x9AC6CDD7 },             Struct("placeable_header",                 Const(ULInt32("key"), 0x9AC6CDD7),                 ULInt16("handle"),             ),         ),         ULInt16("version"),         ULInt32("size"), # file size is in words     );</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Streams</h2>
        <div class="sectioncontent">
<p>Until now, everything worked in single-action. build built one construct, and parse parsed one construct from one string. But suppose the string have more then one construct in it? Suppose we want to write two constructs into one string? (and if these constructs are in bit-mode, we can't create and just join them)</p><p>So, anyway, we have streams. A stream is an object that let a construct read and parse bytes from, or build and write bytes to.</p><p>Please note, that some constructs can only work on seekable streams.</p><h3>String</h3>
<p>is seekable, not bit-stream</p><p>This is the most basic stream.</p><p>    $data = $s-&gt;parse("aabb");     # is equivalent to:     $stream = CreateStreamReader("aabb");     $data = $s-&gt;parse($stream);     # also equivalent to:     $stream = CreateStreamReader(String =&gt; "aabb");     $data = $s-&gt;parse($stream);</p><p>Being that String is the default stream type, it is not needed to specify it. So, if there is a string contains two or more structs, that the following code is possible:</p><p>    $stream = CreateStreamReader(String =&gt; $my_string);     $data1 = $s1-&gt;parse($stream);     $data2 = $s2-&gt;parse($stream);</p><p>The other way is equally possible:</p><p>    $stream = CreateStreamWriter(String =&gt; undef);     $s1-&gt;build($data1);     $s2-&gt;build($data2);     $my_string = $stream-&gt;Flush();</p><p>The Flush command in Writer Stream says: finish doing whatever you do, and return your internal object. For string writer it is simply return the string that it built. Wrapping streams (like Bit, StringBuffer) finish whatever they are doing, flush the data to the internal stream, and call Flush on that internal stream.</p><p>The special case here is Wrap, that does not call Flush on the internal stream. usefull for some configurations. a Flush operation happens in the end of every build operation automatically, and when a stream being destroyed.</p><p>In creation, the following lines are equvalent:</p><p>    $stream = CreateStreamWriter(undef);     $stream = CreateStreamWriter(&apos;&apos;);     $stream = CreateStreamWriter(String =&gt; undef);     $stream = CreateStreamWriter(String =&gt; &apos;&apos;);</p><p>Of course, it is possible to create String Stream with inital string to append to:</p><p>    $stream = CreateStreamWriter(String =&gt; "aabb");</p><p>And any sequencal build operation will append to the \*(L"aabb\*(R" string.</p>
<h3>StringRef</h3>
<p>is seekable, not bit-stream</p><p>Mainly for cases when the string is to big to play around with. Writer:</p><p>    my $string = &apos;&apos;;     $stream = CreateStreamWriter(StringRef =&gt; &#92;$string);     ... do build operations ...     # and now the data in $string.     # or refer to: ${ $stream-&gt;Flush() }</p><p>Because Flush returns what's inside the stream - in this case a reference to a string. For Reader:</p><p>    my $string = &apos;MBs of data...&apos;;     $stream = CreateStreamReader(StringRef =&gt; &#92;$string);     ... parse operations ...</p>
<h3>Bit</h3>
<p>not seekable, is bit-stream</p><p>While every stream support bit-fields, when requesting 2 bits in non-bit-streams you get these two bits, but a whole byte is consumed from the stream. In bit stream, only two bits are consumed.</p><p>When you use BitStruct construct, it actually wraps the current stream with a bit stream. If the stream is already bit-stream, it continues as usual.</p><p>What does it all have to do with you? great question. Support you have a string containing a few bit structs, and each struct is aligned to a byte border. Then you can use the example under the BitStruct section.</p><p>However, if the bit structs are not aligned, but compressed one against the other, then you should use:</p><p>    $s = BitStruct("foo",         <strong>Padding</strong>(1),         Flag("myflag"),         <strong>Padding</strong>(3),     );     $inner = "&#92;x42&#92;0";     $stream1 = CreateStreamReader(Bit =&gt; String =&gt; $inner);     $data1 = $s-&gt;parse($stream1);     # data1 is { myflag =&gt; 1 }     $data2 = $s-&gt;parse($stream1);     # data2 is { myflag =&gt; 1 }     $data3 = $s-&gt;parse($stream1);     # data3 is { myflag =&gt; 0 }</p><p>Note that the Padding constructs detects that it work on bit stream, and pad in bits instead of bytes.</p><p>On Flush the bit stream write the reminding bits (up to a byte border) as 0, write the last byte to the contained stream, and call Flush on the said contained stream. so, if we use the $s from the previous code section:</p><p>    $stream1 = CreateStreamWriter(Bit =&gt; String =&gt; undef);     $s-&gt;build({ myflag =&gt; 1 }, $stream1);     $s-&gt;build({ myflag =&gt; 1 }, $stream1);     $s-&gt;build({ myflag =&gt; 0 }, $stream1);     my $result = $stream1-&gt;Flush();     # $result eq "&#92;x40&#92;x40&#92;0"</p><p>In this case each build operation did Flush on the bit stream, closing the last (and only) byte. so we get three bytes, each contain one record. But if we want that our constructs will be compressed each against the other, then we need to protect the bit stream from the Flush command:</p><p>    $stream1 = CreateStreamWriter(Wrap =&gt; Bit =&gt; String =&gt; undef);     $s-&gt;build($data1, $stream1);     $s-&gt;build($data1, $stream1);     $s-&gt;build($data2, $stream1);     my $result = $stream1-&gt;Flush()-&gt;Flush();     # $result eq "&#92;x42&#92;0";</p><p>Ohh. Two Flushs. one for the Wrap, one for the Bit and the String. However, as you can see, the structs are packed together. The Wrap stream protects the Bit stream from the Flush command in the end of every build.</p>
<h3>StringBuffer</h3>
<p>is seekable, not bit-stream</p><p>Suppose that you have some non-seekable stream. like socket. and suppose that your struct do use construct that need seekable stream. What can you do?</p><p>Enter StringBuffer. It reads from the warped stream exactly the number of bytes that the struct needs, giving the struct the option to seek inside the read section. and if the struct seeks ahead - it will just read enough bytes to seek to this place.</p><p>In writer stream, the StringBuffer will pospone writing the data to the actual stream, until the Flush command.</p><p>This warper stream is usefull only when the struct seek inside it's borders, and not sporadically reads data from 30 bytes ahead / back.</p><p>    # suppose we have unseekable reader stream names $s_stream     # (for example, TCP connection)     $stream1 = CreateStreamReader(StringBuffer =&gt; $s_stream);     # $s is some struct that uses seek. (using Peek, for example)     $data = $s-&gt;parse($stream1);     # the data were read, you can either drop $stream1 or continue use     # it for future parses.</p><p>    # now suppose we have a unseekable writer strea name $w_stream     $stream1 = CreateStreamWriter(StringBuffer =&gt; $w_stream);     # $s is some struct that uses seek. (using Peek, for example)     $s-&gt;build($data1, $stream1);     # data is written into $stream1, flushed to $w_stream, and sent.</p><p>Note that in StringBuffer, the Flush operation writes the data to the underlining stream, and then Flushes that stream.</p>
<h3>Wrap</h3>
<p>A simple wraping stream, whose only function is to protect the contained stream from Flush commands. Usable only for writer streams, and can be used to:</p><p>1. Protect a Bit stream, so it will compress multiple structs without byte alignment (see the Bit stream documentation for example)</p><p>2. Protect a StringBuffer, so it will aggregate some structs before you will Flush them all as one to the socket/file/whatever.</p>
<h3>File</h3>
<p>is seekable, not bit-stream</p><p>Reads from / Writes to a file. it is your responsebility to open the file and binmode it.</p><p>    open my $fh, "&lt;", "bin_data.xdf" or die "oh sh...";     binmode $fh;     $stream1 = CreateStreamReader(File =&gt; $fh);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Format Library</h2>
        <div class="sectioncontent">
<p>The Data::ParseBinary arrive with ever-expanding set of pre-defined parsers for popular formats. Each of these parsers is in it's own module. And if you have a file-format, then this is how it's done:</p><p>    use Data::ParseBinary::Graphics::BMP qw{$bmp_parser};     open my $fh2, "&lt;", $filename or die "can not open $filename";     binmode $fh2;     $data = $bmp_parser-&gt;parse(CreateStreamReader(File =&gt; $fh2));</p><p>And $data will contain the parsed file. In the same way, it is possible to build a \s-1BMP\s0 file.</p><p>Please look for the documentation inside each module, as it highlights various issues with the various libraries.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Debugging</h2>
        <div class="sectioncontent">
<h3>Output on failure</h3>
<p>The first line of defence is the output on error. Where did it happend? in which construct? In which byte of the input?</p><p>On error, you get the following \*(L"die\*(R" messege:</p><p>    Got Exception not enought bytes in stream</p><p>    Streams location:     1: Stream BitReader in byte #Bit 5     2: Stream StringReader in byte #2     Constructs Stack:     1: BitField f     2: Struct bar     3: BitStruct foo</p><p>It tells me that I was inside \*(L"f\*(R" under \*(L"bar\*(R" under \*(L"foo\*(R", that it's the second byte in stream, and because I was inside a BitStuct I get another line for the stream, pointing me to the exact bit. What we miss in the \*(L"die\*(R" messege above, is knowing how did I got there. If it's inside Array, how many times it happen, and what decissions taken along the way. But fear not. just set $print_debug_info:</p><p>    $Data::ParseBinary::print_debug_info = 1;</p><p>This will trigger a print every time the parsing process enter or exit a construct. So if a parsing dies, you can follow where it did.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>The following elements were not implemented:</p><p>    OnDemand     Reconfig and a macro Rename     AlignedStruct     Probe     Embed     Tunnel (TunnelAdapter is already implemented)</p><p>Add documentation to: ExtractingAdapter</p><p>Move the insertion of the parsed value to the context from the Struct/Sequence constructs to each indevidual construct?</p><p>Streams: SocketStream</p><p>FileStreamWriter::Flush : improve.</p><p>Ability to give the CreateStreamReader/CreateStreamWriter function an ability to reconginze socket / filehandle / pointer to string.</p><p>Union need to be extended to bit-structs?</p><p>use some nice exception system</p><p>Fix the Graphics-EMF library : Find out if the \s-1EMF\s0 file should work or not. it fails on the statment: Const(ULInt32(\*(L"signature\*(R"), 0x464D4520) And complain that it gets \*(L"0\*(R".</p><p>Make BitField a meta construct?</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Thread Safety</h2>
        <div class="sectioncontent">
<p>This is a pure perl module. there should be not problems.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Currently L/BFloat64 does not work if you don't have 64 bit numbers support compiled in your Perl</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Data::ParseBinary&hellip;</h2>
        <div class="sectioncontent">
<p>Original PyConstructs homepage: http://construct.wikispaces.com/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Fomberg Shmuel, &lt;owner@semuel.co.il&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright 2008 by Shmuel Fomberg.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Data::Pageset.3pm.html"><span aria-hidden="true">&larr;</span> Data::Pageset.3pm: Page numbering and page sets</a></li>
   <li class="next"><a href="Data::ParseBinary::Data::Cap.3pm.html">Data::ParseBinary::Data::Cap.3pm: Parsing "tcpdump capture file" <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTML::Template::Compiled: Template system compiles html::template files to perl code</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Template system compiles html::template files to perl code">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="HTML::Template::Compiled (3pm) manual">
  <meta name="twitter:description" content="Template system compiles html::template files to perl code">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhtml-template-compiled-perl-HTML::Template::Compiled-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/HTML::Template::Compiled.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HTML::Template::Compiled (3pm) manual" />
  <meta property="og:description" content="Template system compiles html::template files to perl code" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhtml-template-compiled-perl-HTML::Template::Compiled-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">HTML::Template::Compiled<small> (3pm)</small></h1>
        <p class="lead">Template system compiles html::template files to perl code</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::Template::Compiled.3pm.html">
      <span itemprop="name">HTML::Template::Compiled: Template system compiles html::template files to perl code</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhtml-template-compiled-perl/">
      <span itemprop="name">libhtml-template-compiled-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::Template::Compiled.3pm.html">
      <span itemprop="name">HTML::Template::Compiled: Template system compiles html::template files to perl code</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>$VERSION = \*(L"1.001\*(R"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use HTML::Template::Compiled;
  # recommended options:
  # case_sensitive =&gt; 1
  # search_path_on_include =&gt; 1
  # use_query =&gt; 0
  # default_escape =&gt; &apos;HTML&apos; # &lt;-- HIGHLY RECOMMENDED

  # note that the following
  # use HTML::Template::Compiled speed =&gt; 1
  # is deprecated (can be problematic under persistent environments)

  # or for the biggest compatibility with HTML::Template
  # case_sensitive =&gt; 0
  # search_path_on_include =&gt; 0
  # use_query =&gt; 1
  # note that the following
  # use HTML::Template::Compiled compatible =&gt; 1;
  # is deprecated (can be problematic under persistent environments)

  # or use HTML::Template::Compiled::Classic

    my $htc = HTML::Template::Compiled-&gt;new(
        filename            =&gt; &apos;test.tmpl&apos;,
        case_sensitive      =&gt; 1,
        default_escape      =&gt; &apos;HTML&apos;,
    );
    $htc-&gt;param(
        BAND =&gt; $name,
        ALBUMS =&gt; [
            { TITLE =&gt; $t1, YEAR =&gt; $y1 },
            { TITLE =&gt; $t2, YEAR =&gt; $y2 },
        ],
    );
    print $htc-&gt;output;

  test.tmpl:
  Band: &lt;TMPL_VAR BAND&gt;
  &lt;TMPL_LOOP ALBUMS&gt;
  Title: &lt;TMPL_VAR TITLE&gt; (&lt;TMPL_VAR YEAR&gt;)
  &lt;/TMPL_LOOP&gt;

  Or use different tag styles:
  Band: &lt;%= BAND %&gt;
  &lt;%loop ALBUMS %&gt;
  Title: &lt;%= TITLE %&gt; (&lt;%= YEAR %&gt;)
  &lt;%/loop %&gt;
  Band: [%= BAND %]
  [%loop ALBUMS %]
  Title: [%= TITLE %] ([%= YEAR %])
  [%/loop %]
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>HTML::Template::Compiled is a template system which can be used for HTML::Template templates with almost the same \s-1API\s0. It offers more flexible template delimiters, additional tags and features, and by compiling the template into perl code it can run significantly faster in persistent environments such as FastCGI or mod_perl.</p><p>The goal is to offer more features for flexibility but keep the basic syntax as easy as it is.</p><p>Features at a glance:</p>
<dl class='dl-vertical'>
  <dt>
    Dot notation for objects, hashes and arrays
  </dt>
  <dd>
    
  </dd>
  <dt>
    Use expressions without any disadvantages like those in HTML::Template::Expr
  </dt>
  <dd>
    
  </dd>
  <dt>
    Write escaping plugins and plugins for new tags
  </dt>
  <dd>
    
  </dd>
  <dt>
    Tags \s-1ELSIF\s0, \s-1EACH\s0, \s-1WHILE\s0, \s-1COMMENT\s0, \s-1WRAPPER\s0, \s-1SWITCH/CASE\s0, \s-1INCLUDE_VAR\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    Chomp newlines/whitespace
  </dt>
  <dd>
    
  </dd>

</dl>
<p>For a quick reference, see HTML::Template::Compiled::Reference.</p><p>As the basic features work like in HTML::Template, please get familiar with its documentation before.</p><p>HTML::Template::Compiled (\s-1HTC\s0) does not implement all features of HTML::Template (see \*(L"\s-1COMPATIBILITY\s0\*(R"), and it has got some additional features which are explained below: \*(L"\s-1ADDITIONAL\s0 \s-1FEATURES\s0\*(R"</p><p>See \*(L"\s-1BENCHMARKS\s0\*(R" for some examples on the performance. Since it depends highly on the options used and on the template size there can be no general statement on its performance.</p><p>You might want to use HTML::Template::Compiled::Lazy for \s-1CGI\s0 environments as it doesn't parse the template before calling output. But note that HTC::Lazy isn't much tested, and I don't use it myself, so there's a lack of experience. If you use it and have problems, please report.</p><p>\s-1HTC\s0 will use a lot of memory because it keeps all template objects in memory. If you are on mod_perl, and have a lot of templates, you should preload them at server startup to be sure that it is in shared memory. At the moment \s-1HTC\s0 is not fully tested for keeping all data in shared memory (e.g. when a copy-on-write occurs), but it seems like it's behaving well. For preloading you can use</p>
<pre>
  HTML::Template::Compiled-&gt;preload($cache_dir).
</pre>
<p>Generating code, writing it on disk and later <em>eval()</em> it can open security holes, for example if you have more users on the same machine that can access the same files (usually an http server running as 'www' or 'nobody'). See \*(L"\s-1SECURITY\s0\*(R" for details what you can do to safe yourself.</p><p>\s-1NOTE:\s0 If you don't need any of the additional features listed below and if you don't need the speed (in many cases it's probably not worth trading speed for memory), then you might be better off with just using HTML::Template.</p><p>\s-1NOTE2:\s0 If you have any questions, bug reports, send them to me and not to Sam Tregar. This module is developed by me at the moment, independently from HTML::Template, although I try to get most of the tests from it passing for \s-1HTC\s0. See \*(L"\s-1RESOURCES\s0\*(R" for current information.</p><h3>\s-1FEATURES\s0 \s-1FROM\s0 \s-1HTML::TEMPLATE\s0</h3>

<dl class='dl-vertical'>
  <dt>
    \s-1TMPL_VAR\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1TMPL_LOOP\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1TMPL_\s0(IF|UNLESS|ELSE)
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1TMPL_INCLUDE\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1HTML_TEMPLATE_ROOT\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    ESCAPE=(HTML|URL|JS|0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    DEFAULT=...
  </dt>
  <dd>
    
  </dd>
  <dt>
    &lt;!-- \s-1TMPL_VAR\s0 NAME=PARAM1 --&gt;
  </dt>
  <dd>
    
  </dd>
  <dt>
    case insensitive var names
  </dt>
  <dd>
    <p>use option case_sensitive =&gt; 0 to use this feature (slow down)</p>
  </dd>
  <dt>
    filters
  </dt>
  <dd>
    
  </dd>
  <dt>
    vars that are subrefs - not implemented, only in HTML::Template::Compiled::Classic
  </dt>
  <dd>
    
  </dd>
  <dt>
    scalarref, arrayref, filehandle
  </dt>
  <dd>
    <p>Has a bug (doesn't return parameters in included files of included files). I'm working on that.</p>
  </dd>

</dl>

<h3>\s-1ADDITIONAL\s0 \s-1FEATURES\s0</h3>
<p>What can \s-1HTC\s0 do for you additionally to HTML::Template?</p>
<dl class='dl-vertical'>
  <dt>
    tag \s-1TMPL_ELSIF\s0
  </dt>
  <dd>
    <p>No need to have cascading \*(L"if-else-if-else\*(R"s</p>
  </dd>
  <dt>
    tag \s-1TMPL_EACH\s0
  </dt>
  <dd>
    <p>Iterate over a hash. See \*(L"\s-1TMPL_EACH\s0\*(R"</p>
  </dd>
  <dt>
    tag \s-1TMPL_WITH\s0
  </dt>
  <dd>
    <p>see \*(L"\s-1TMPL_WITH\s0\*(R"</p>
  </dd>
  <dt>
    tag \s-1TMPL_WHILE\s0
  </dt>
  <dd>
    <p>see \*(L"\s-1TMPL_WHILE\s0\*(R"</p>
  </dd>
  <dt>
    tag \s-1TMPL_SET_VAR\s0
  </dt>
  <dd>
    <p>see \*(L"\s-1SET_VAR\s0\*(R"</p>
  </dd>
  <dt>
    tag \s-1TMPL_USE_VARS\s0
  </dt>
  <dd>
    <p>see \*(L"\s-1USE_VARS\s0\*(R"</p>
  </dd>
  <dt>
    tags \s-1TMPL_COMMENT\s0, \s-1TMPL_NOPARSE\s0, \s-1TMPL_VERBATIM\s0
  </dt>
  <dd>
    <p>see \*(L"\s-1TMPL_COMMENT\s0\*(R", \*(L"\s-1TMPL_NOPARSE\s0\*(R", \*(L"\s-1TMPL_VERBATIM\s0\*(R"</p>
  </dd>
  <dt>
    tag \s-1TMPL_WRAPPER\s0
  </dt>
  <dd>
    <p>see \*(L"\s-1WRAPPER\s0\*(R" Additional loop variable (\*(C`_\|_counter_\|_ -1\*(C') Additional loop variable (see \*(L"\s-1TMPL_LOOP\s0\*(R") Insert the template filename for debugging:     &lt;%= _\|_filename_\|_ %&gt;     &lt;%= _\|_filenameshort_\|_ %&gt; will turn out as:</p>
<pre>
    templates/path/file.html
    path/file.html
</pre>
<p>See also option debug_file in \*(L"\s-1OPTIONS\s0\*(R" for adding the filename globally.</p>
  </dd>
  <dt>
    tags \s-1TMPL_SWITCH\s0, \s-1TMPL_CASE\s0
  </dt>
  <dd>
    <p>see \*(L"\s-1TMPL_SWITCH\s0\*(R" Include perl code in your template. See \*(L"\s-1RUNNING\s0 \s-1PERL\s0 \s-1WITH\s0 \s-1TMPL_PERL\s0\*(R"</p>
  </dd>
  <dt>
    \s-1CHOMP\s0
  </dt>
  <dd>
    <p>New in version 0.96_001, please report any bugs and send me suggestions. You can set global chomp options in the constructor. These work like in Template-Toolkit:     my $htc = HTML::Template::Compiled-&gt;new(         pre_chomp  =&gt; 0, # 0, 1, 2, 3, default 0         post_chomp =&gt; 1, # 0, 1, 2, 3, default 0     ); Meaning of the values: 0: Don't chomp 1: remove only spaces in the line before or after the tag 2: remove all whitespaces before or after the tag, and replace with one space 3: remove all whitespaces before or after the tag In the template you can change that feature by using \s-1PRE_CHOMP\s0 and \s-1POST_CHOMP\s0 attributes:     &lt;%= foo PRE_CHOMP=3 POST_CHOMP=1 %&gt; The experimental tags +..._chomp have been removed.</p>
  </dd>
  <dt>
    Generating perl code
  </dt>
  <dd>
    <p>See \*(L"\s-1IMPLEMENTATION\s0\*(R"</p>
  </dd>
  <dt>
    better variable access
  </dt>
  <dd>
    <p>dot-notation for accessing hash values. See \*(L"\s-1EXTENDED\s0 \s-1VARIABLE\s0 \s-1ACCESS\s0\*(R"</p>
  </dd>
  <dt>
    rendering objects
  </dt>
  <dd>
    <p>dot-notation for accessing object methods. See \*(L"\s-1RENDERING\s0 \s-1OBJECTS\s0\*(R"</p>
  </dd>
  <dt>
    output to filehandle
  </dt>
  <dd>
    <p>See \*(L"\s-1OPTIONS\s0\*(R"</p>
  </dd>
  <dt>
    Dynamic includes
  </dt>
  <dd>
    <p>\*(C`INCLUDE_VAR\*(C', \*(C`INCLUDE_STRING\*(C'. See \*(L"\s-1INCLUDE\s0\*(R"</p>
  </dd>
  <dt>
    tag \s-1TMPL_IF_DEFINED\s0
  </dt>
  <dd>
    <p>Check for definedness instead of truth:</p>
<pre>
  &lt;\s-1TMPL_IF_DEFINED\s0 NAME=\*(L"var\*(R"&gt;
</pre>

  </dd>
  <dt>
    \s-1ALIAS\s0
  </dt>
  <dd>
    <p>Set an alias for a loop variable. You can use the alias then with $alias. The syntax without the \*(C`$\*(C' is also possible but not recommended any more. For example, these two loops are functionally equivalent:  &lt;tmpl_loop foo&gt;    &lt;tmpl_var _&gt;  &lt;/tmpl_loop foo&gt;  &lt;tmpl_loop foo alias=current&gt;    &lt;tmpl_var $current&gt;  &lt;/tmpl_loop foo&gt; This works with \*(C`TMPL_LOOP\*(C' and \*(C`TMPL_WHILE\*(C' at the moment. You can also set aliases with the \*(C`SET_VAR\*(C' tag. See \*(L"\s-1SET_VAR\s0\*(R" To use template parameters with a \*(C`$\*(C' at the beginning (which is not officially supported, but some are obviously using it), you can set:     local $HTML::Template::Compiled::Compiler::DISABLE_NEW_ALIAS = 1; This is only a temporary workaround and will be removed some day! Note that you are also able to access variables with dollar signs like this:     &lt;tmpl_var _.$foo &gt; since underscore means current position in the parameter stash, and aliases are only recognized at the beginning of a template var. But note that dollar signs are still not officially supported.</p>
  </dd>
  <dt>
    Chained escaping
  </dt>
  <dd>
    <p>See \*(L"\s-1ESCAPING\s0\*(R"</p>
  </dd>
  <dt>
    tagstyles
  </dt>
  <dd>
    <p>For those who like it (i like it because it is shorter than \s-1TMPL_\s0), you can use &lt;% %&gt; tags and the &lt;%= tag instead of &lt;%VAR (which will work, too):  &lt;%IF blah%&gt;  &lt;%= VARIABLE%&gt;  &lt;%/IF%&gt; Define your own tagstyles and/or deactivate predefined ones. See \*(L"\s-1OPTIONS\s0\*(R" tagstyle.</p>
  </dd>
  <dt>
    pre_chomp, post_chomp
  </dt>
  <dd>
    <p>See \*(L"\s-1CHOMP\s0\*(R"</p>
  </dd>

</dl>

<h3>\s-1MISSING\s0 \s-1AND\s0 \s-1DIFFERENT\s0 \s-1FEATURES\s0</h3>
<p>There are some features of H::T that are missing or behaving different. I'll try to list them here.</p><p><em>\s-1MISSING\s0 \s-1FEATURES\s0</em></p>
<dl class='dl-vertical'>
  <dt>
    die_on_bad_params
  </dt>
  <dd>
    <p>I don't think I'll implement that.</p>
  </dd>
  <dt>
    force_untaint
  </dt>
  <dd>
    <p>Not planned at the moment</p>
  </dd>
  <dt>
    vanguard_compatibility_mode
  </dt>
  <dd>
    <p>Not planned.</p>
  </dd>
  <dt>
    shared_cache, double_cache
  </dt>
  <dd>
    <p>Not planned at the moment</p>
  </dd>
  <dt>
    blind_cache
  </dt>
  <dd>
    <p>Not sure if I should implement. In \s-1HTC\s0 you have the possibility to set the expire time of the templates (after that time in memory the template file is rechecked if it has changed), so setting a very high value for expire_time would have the same effect as blind_cache. See \*(L"\s-1CACHING\s0\*(R" \*(C`expire_time\*(C'</p>
  </dd>
  <dt>
    double_file_cache
  </dt>
  <dd>
    <p>If I understand correctly, in \s-1HT\s0, this enables memory and file cache at the same time. In \s-1HTC\s0, this is not needed. If you use file_cache and cache, both are used.</p>
  </dd>
  <dt>
    file_cache_dir_mode
  </dt>
  <dd>
    <p>Not planned. The cache dir must exist, and subdirectories are not created at the moment.</p>
  </dd>
  <dt>
    cache_lazy_vars, cache_lazy_loops
  </dt>
  <dd>
    <p>Not planned at the moment (This would be for HTML::Template::Compiled::Classic, since it implements code refs).</p>
  </dd>
  <dt>
    utf8
  </dt>
  <dd>
    <p>Might be added in the future, \s-1HTC\s0 already has \*(C`open_mode\*(C'</p>
  </dd>
  <dt>
    various debug options
  </dt>
  <dd>
    <p>Might be implemented in the future</p>
  </dd>
  <dt>
    associate
  </dt>
  <dd>
    <p>Not planned.</p>
  </dd>
  <dt>
    max_includes
  </dt>
  <dd>
    <p>Not planned</p>
  </dd>
  <dt>
    die_on_missing_include
  </dt>
  <dd>
    <p>Maybe</p>
  </dd>

</dl>
<p><em>\s-1DIFFERENT\s0 \s-1FEATURES\s0</em></p>
<dl class='dl-vertical'>
  <dt>
    case_sensitive
  </dt>
  <dd>
    <p>default is 1 (on). Deactivate by passing option case_sensitive 0. Note (again): this will slow down templating a lot (50%). Explanation: This has nothing to do with \*(C`TMPL_IF\*(C' or \*(C`tmpl_if\*(C'. It's about the variable names. With case_sensitive set to 1, the following tags are different:     &lt;tmpl_var Foo&gt; prints the value of hash key &apos;Foo&apos;     &lt;tmpl_var fOO&gt; prints the value of hash key &apos;fOO&apos; With case_sensitive set to 0, all your parameters passed to \*(C`param()\*(C' are converted to lowercase, and the following tags are the same:     &lt;tmpl_var Foo&gt; prints the value of hash key &apos;foo&apos;     &lt;tmpl_var fOO&gt; prints the value of hash key &apos;foo&apos;</p>
  </dd>
  <dt>
    subref variables
  </dt>
  <dd>
    <p>As of version 0.69, subref variables are not supported any more with HTML::Template::Compiled. Use HTML::Template::Compiled::Classic (contained in this distribution) instead. It provides most features of \s-1HTC\s0.</p>
  </dd>
  <dt>
    search_path_on_include
  </dt>
  <dd>
    <p>Default: 0 In the HTML::Template documentation it says, if search_path_on_include is set to 1, the paths of the path option are searched, while the default behaviour is to look \*(L"only\*(R" in the current template directory. It's not clear if it still searches in the current directory if set to 1. I found out that it is not, so you cannot have both. In HTML::Template::Compiled, search_path_on_include can have three values:</p>
<pre>
    0: search current template directory
    1: search paths specified
    2: search paths and current template directory.
</pre>

  </dd>
  <dt>
    open_mode
  </dt>
  <dd>
    <p>In \s-1HTC\s0 you should leave out the \*(C`&lt;\*(C' at the beginning. If you want to have your templates read in utf-8, use     open_mode =&gt; &apos;:encoding(utf-8)&apos;, as an option.</p>
  </dd>
  <dt>
    use_query
  </dt>
  <dd>
    <p>default is 0 (off). Set it via the option \*(C`use_query\*(C'</p>
  </dd>
  <dt>
    Arrayrefs
  </dt>
  <dd>
    <p>At the moment this snippet   &lt;tmpl_if arrayref&gt;true&lt;tmpl_else&gt;false&lt;/tmpl_if arrayref&gt; with this code:     $htc-&gt;param(arrayref =&gt; []); will print true in \s-1HTC\s0 and false in HTML::Template. In HTML::Template an array is true if it has content, in \s-1HTC\s0 it's true if it (the reference) is defined. I'll try to find a way to change that behaviour, though that might be for the cost of speed. As of HTML::Template::Compiled 0.85 you can use this syntax:     &lt;tmpl_if arrayref# &gt;true&lt;tmpl_else&gt;false&lt;/tmpl_if &gt; In HTML::Template::Compiled::Classic 0.04 it works as in HTML::Template.</p>
  </dd>
  <dt>
    debug_cache
  </dt>
  <dd>
    <p>Additional to 0 or 1 it can take an array ref for debugging only specific cache operations.</p>
  </dd>

</dl>
<p>Note: the following is deprecated:</p><p>    To be compatible in all of the above options all use:</p><p>      use HTML::Template::Compiled compatible =&gt; 1;</p><p>    If you don&apos;t care about these options you should use</p><p>      use HTML::Template::Compiled speed =&gt; 1;</p><p> which is the default but depending on user wishes that might change.</p>
<h3>\s-1DEPRECATED\s0</h3>

<dl class='dl-vertical'>
  <dt>
    class methods ExpireTime, EnableSub, CaseSensitive, SearchPathOnInclude, UseQuery
  </dt>
  <dd>
    
  </dd>
  <dt>
    option formatter_path
  </dt>
  <dd>
    
  </dd>
  <dt>
    tag \s-1USE_VARS\s0, not needed anymore
  </dt>
  <dd>
    
  </dd>
  <dt>
    option cache_dir (replaced by file_cache_dir)
  </dt>
  <dd>
    
  </dd>
  <dt>
    options method_call, deref, default_path, dumper
  </dt>
  <dd>
    
  </dd>
  <dt>
    import tags short, compatible, speed
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>\s-1ESCAPING\s0</h3>
<p>Like in HTML::Template, you have \*(C`ESCAPE=HTML\*(C', \*(C`ESCAPE=URL\*(C' and \*(C`ESCAPE_JS\*(C'. \*(C`ESCAPE=HTML\*(C' will only escape '"&&lt;&gt;. If you want to escape more, use \*(C`ESCAPE=HTML_ALL\*(C'. Additionally you have \*(C`ESCAPE=DUMP\*(C', which by default will generate a Data::Dumper output.</p><p>You can also chain different escapings, like \*(C`ESCAPE=DUMP|HTML\*(C'.</p><p>Additionally to ESCAPE=JS you have ESCAPE=IJSON which does not escape the single quote.</p>
<h3>\s-1INCLUDE\s0</h3>
<p>Additionally to</p><p>  &lt;TMPL_INCLUDE NAME="file.htc"&gt;</p><p>you can do an include of a template variable:</p><p>  &lt;TMPL_INCLUDE_VAR NAME="file_include_var"&gt;   $htc-&gt;param(file_include_var =&gt; "file.htc");</p><p>Using \*(C`INCLUDE VAR="..."\*(C' is deprecated.</p><p>You can also include strings:</p><p>    template:     inc: &lt;%include_string foo %&gt;</p><p>    code:     $htc-&gt;param(         foo =&gt; &apos;included=&lt;%= bar%&gt;&apos;,         bar =&gt; &apos;real&apos;,     );</p><p>    output:     inc: included=real</p><p>Note that included strings are not cached and cannot include files or strings themselves.</p>
<h3>\s-1EXTENDED\s0 \s-1VARIABLE\s0 \s-1ACCESS\s0</h3>
<p>With \s-1HTC\s0, you have more control over how you access your template parameters. An example:</p><p>  my %hash = (     SELF =&gt; &apos;/path/to/script.pl&apos;,     LANGUAGE =&gt; &apos;de&apos;,     BAND =&gt; &apos;Bauhaus&apos;,     ALBUMS =&gt; [     {       NAME =&gt; &apos;Mask&apos;,       SONGS =&gt; [ { NAME =&gt; &apos;Hair of the Dog&apos; }, ... ],     },     ],     INFO =&gt; {       BIOGRAPHY =&gt; &apos;...&apos;,       LINK =&gt; &apos;...&apos;     },     NAME =&gt; "Cool script",   );</p><p>Now in the \s-1TMPL_LOOP\s0 \*(C`ALBUMS\*(C' you would like to access the path to your script, stored in $hash{\s-1SELF\s0}. in HTML::Template you have to set the option \*(C`global_vars\*(C', so you can access $hash{SELF} from everywhere. Unfortunately, now \*(C`NAME\*(C' is also global, which might not a problem in this simple example, but in a more complicated template this is impossible. With \s-1HTC\s0, you wouldn't use \*(C`global_vars\*(C' here, but you can say:</p><p>  &lt;TMPL_VAR .SELF&gt;</p><p>to access the root element, and you could even say \*(C`.INFO.BIOGRAPHY\*(C' or \*(C`ALBUMS[0].SONGS[0].NAME\*(C' (the latter has changed since version 0.79)</p>
<h3>\s-1RENDERING\s0 \s-1OBJECTS\s0</h3>
<p>This is still in development, so I might change the \s-1API\s0 here.</p><p>Additionally to feeding a simple hash to \s-1HTC\s0, you can feed it objects. To do method calls you can also use '.' in the template.</p><p>  my $htc = HTML::Template::Compiled-&gt;new(     ...   );</p><p>  $htc-&gt;param(     VAR =&gt; "blah",     OBJECT =&gt; bless({...}, "Your::Class"),   );</p><p>  &lt;TMPL_VAR NAME="OBJECT.fullname"&gt;   &lt;TMPL_WITH OBJECT&gt;   Name: &lt;TMPL_VAR fullname&gt;   &lt;/TMPL_WITH&gt;</p><p>\*(C`fullname\*(C' will call the fullname method of your Your::Class object.</p><p>It's recommended to just use the default . value for methods and dereferencing.</p><p>I might stop supporting that you can set the values for method calls by setting an option. Ideally I would like to have that behaviour changed only by inheriting.</p>
<h3>\s-1RUNNING\s0 \s-1PERL\s0 \s-1WITH\s0 \s-1TMPL_PERL\s0</h3>
<p>Yes, templating systems are for separating code and templates. But as it turned out to be implemented much easier than expressions i decided to implement it. But expressions are also available with the option \*(C`use_expressions\*(C'.</p><p>Note: If you have templates that can be edited by untrustworthy persons then you don't want them to include perl code.</p><p>So, how do you use the perl-tag? First, you have to set the option \*(C`use_perl\*(C' to 1 when creating a template object.</p><p>Important note: don't use \*(C`print\*(C' in the included code. Usually the template code is concatenated and returned to your perl script. To 'print' something out use</p><p>    _\|_OUT_\|_ 2**3;</p><p>This will be turned into something like</p><p>    $OUT .= 2**3;     # or     print $fh 2**3;</p><p>Important note 2: \s-1HTC\s0 does not parse Perl. if you use the classic tag-delimiters like this:</p><p>    &lt;tmpl_perl if (_\|_CURRENT_\|_-&gt;count &gt; 42) { &gt;</p><p>this will not work as it might seem. Use other delimiters instead:</p><p>    &lt;%perl if (_\|_CURRENT_\|_-&gt;count &gt; 42) { %&gt;</p><p>Example:</p><p>    &lt;tmpl_loop list&gt;     &lt;tmpl_perl unless (_\|_INDEX_\|_ % 3) { &gt;       &lt;/tr&gt;&lt;tr&gt;     &lt;tmpl_perl } &gt;     &lt;/tmpl_loop list&gt;</p><p>    # takes the current position of the parameter     # hash, key &apos;foo&apos; and multiplies it with 3     &lt;%perl _\|_OUT_\|_ _\|_CURRENT_\|_-&gt;{foo} * 3; %&gt;</p><p>List of special keywords inside a perl-tag:</p>
<dl class='dl-vertical'>
  <dt>
    _\|_OUT_\|_
  </dt>
  <dd>
    <p>Is turned into \*(C`$OUT .=\*(C' or \*(C`print $fh\*(C'</p>
  </dd>
  <dt>
    _\|_HTC_\|_
  </dt>
  <dd>
    <p>Is turned into the variable containing the current template object.</p>
  </dd>
  <dt>
    _\|_CURRENT_\|_
  </dt>
  <dd>
    <p>Turned into the variable containing the current position in the parameter hash.</p>
  </dd>
  <dt>
    _\|_ROOT_\|_
  </dt>
  <dd>
    <p>Turned into the variable containig the parameter hash.</p>
  </dd>
  <dt>
    _\|_INDEX_\|_
  </dt>
  <dd>
    <p>Turned into the current index of a loop (starting with 0).</p>
  </dd>

</dl>

<h3>\s-1INHERITANCE\s0</h3>
<p>It's possible since version 0.69 to inherit from HTML::Template::Compiled. It's just not documented, and internal method names might change in the near future. I'll try to fix the \s-1API\s0 and document which methods you can inherit.</p><p><em>\s-1METHODS\s0 \s-1TO\s0 \s-1INHERIT\s0</em></p>
<dl class='dl-vertical'>
  <dt>
    method_call
  </dt>
  <dd>
    <p>Default is \*(C`sub method_call { &apos;.&apos; }\*(C'</p>
  </dd>
  <dt>
    deref
  </dt>
  <dd>
    <p>Default is \*(C`sub deref { &apos;.&apos; }\*(C'</p>
  </dd>
  <dt>
    formatter_path
  </dt>
  <dd>
    <p>Deprecated, see HTML::Template::Compiled::Formatter please.</p>
  </dd>
  <dt>
    compile_early
  </dt>
  <dd>
    <p>Define if every included file should be checked and parsed at compile time of the including template or later when it is really used. Default is \*(C`sub compile_early { 1 }\*(C'</p>
  </dd>
  <dt>
    parser_class
  </dt>
  <dd>
    <p>Default is \*(C`sub parser_class { &apos;HTML::Template::Compiled::Parser&apos; }\*(C' You can write your own parser class (which must inherit from HTML::Template::Compiled::Parser) and use this. HTML::Template::Compiled::Lazy uses this.</p>
  </dd>

</dl>

<h3>\s-1DEBUGGING\s0</h3>
<p>For printing out the contents of all the parameters you can do:</p><p>  &lt;TMPL_LOOP ALBUMS&gt;   Dump: &lt;TMPL_VAR _ ESCAPE=DUMP|HTML&gt;   &lt;/TMPL_LOOP&gt;</p><p>The special name \*(C`_\*(C' gives you the current parameter and \*(C`ESCAPE=DUMP\*(C' will by default generate a Data::Dumper output of the current variable, in this case it will dump out the contents of every album in a loop. To correctly display that in html \*(C`|HTML\*(C' will escape html entities.</p>
<h3>\s-1TMPL_WITH\s0</h3>
<p>If you have a deep leveled hash you might not want to always write \s-1THE\s0.FULL.PATH.TO.YOUR.VAR. Jump to your desired level once and then you need only one level. Compare:</p><p>  &lt;TMPL_WITH DEEP.PATH.TO.HASH&gt;   &lt;TMPL_VAR NAME&gt;: &lt;TMPL_VAR AGE&gt;   &lt;/TMPL_WITH&gt;</p><p>  &lt;TMPL_VAR DEEP.PATH.TO.HASH.NAME&gt;: &lt;TMPL_VAR DEEP.PATH.TO.HASH.AGE&gt;</p><p>Inside \s-1TMPL_WITH\s0 you can't reference parent nodes unless you're using global_vars.</p>
<h3>\s-1TMPL_LOOP\s0</h3>
<p>The special name \*(C`_\*(C' gives you the current parameter. In loops you can use it like this:</p><p> &lt;tmpl_loop foo&gt;   Current item: &lt;tmpl_var _ &gt;  &lt;/tmpl_loop&gt;</p><p>Also you can give the current item an alias. See \*(L"\s-1ALIAS\s0\*(R".</p><p>The \s-1LOOP\s0 tag allows you to define a \s-1JOIN\s0 attribute:</p><p> &lt;tmpl_loop favourite_colors join=", "&gt;   &lt;tmpl_var _ &gt;  &lt;/tmpl_loop&gt;</p><p>This will output something like \*(C`blue, pink, yellow\*(C'. This is easier than doing:</p><p> &lt;tmpl_loop favourite_colors&gt;  &lt;tmpl_unless _\|_first_\|_&gt;, &lt;/tmpl_unless&gt;   &lt;tmpl_var _ &gt;  &lt;/tmpl_loop&gt;</p><p>The \*(C`LOOP\*(C', \*(C`WHILE\*(C' and \*(C`EACH\*(C' tags allow you to define a \s-1BREAK\s0 attribute:</p><p> &lt;tmpl_loop bingo break="3"&gt; &lt;tmpl_var _ &gt;&lt;if _\|_break_\|_&gt;&#92;n&lt;/if&gt;&lt;/tmpl_loop&gt;</p><p>    $htc-&gt;param(bingo =&gt; [qw(X 0 _ _ X 0 _ _ X)]);</p><p>outputs</p><p>    X 0 _     _ X 0     _ _ X</p><p>So specifying BREAK=3 sets _\|_break_\|_ to 1 every 3rd loop iteration.</p><p>\s-1TMPL_LOOP\s0 expects an array reference, also if it is a method call. If you want to iterate with \s-1TMPL_LOOP\s0 over a list from a method call, set the attribute \*(C`context=list\*(C':</p><p>    &lt;tmpl_loop object.list_method context=list&gt;         &lt;tmpl_var _ &gt;     &lt;/tmpl_loop&gt;</p>
<h3>\s-1TMPL_WHILE\s0</h3>
<p>Useful for iterating, for example over database resultsets. The directive</p><p>  &lt;tmpl_while resultset.fetchrow&gt;     &lt;tmpl_var _.0&gt;   &lt;/tmpl_while&gt;</p><p>will work like:</p>
<pre>
  while (my $row = $resultset-&gt;fetchrow) {
    print $row-&gt;[0];
  }
</pre>
<p>So the special variable name _ is set to the current item returned by the iterator.</p><p>You also can use \*(L"\s-1ALIAS\s0\*(R" here.</p>
<h3>\s-1TMPL_EACH\s0</h3>
<p>Iterating over a hash. Internally it is not implemented as an each, so you can also sort the output:</p><p>    Sorted alphanumerically by default (since 0.93):         &lt;tmpl_each letters &gt;             &lt;tmpl_var _\|_key_\|_ &gt;:&lt;tmpl_var _\|_value_\|_&gt;         &lt;/tmpl_each letters &gt;     Sorted numerically:         &lt;tmpl_each numbers sort=num &gt;             &lt;tmpl_var _\|_key_\|_ &gt;:&lt;tmpl_var _\|_value_\|_&gt;         &lt;/tmpl_each numbers &gt;     Not sorted:         &lt;tmpl_each numbers sort=0 &gt;             &lt;tmpl_var _\|_key_\|_ &gt;:&lt;tmpl_var _\|_value_\|_&gt;         &lt;/tmpl_each numbers &gt;     Sorted alphanumerically:         &lt;tmpl_each letters sort=alpha &gt;             &lt;tmpl_var _\|_key_\|_ &gt;:&lt;tmpl_var _\|_value_\|_&gt;         &lt;/tmpl_each letters &gt;</p><p>You have to set the option \*(C`loop_context_vars\*(C' to true to use the special vars \*(C`_\|_key_\|_\*(C' and \*(C`_\|_value_\|_\*(C'.</p><p>If you want to iterate over a hash instead of a hashref (some methods might return plain hashes instead of references and \s-1TMPL_EACH\s0 expects a ref), then you can set \*(C`context=list\*(C':</p><p>    &lt;tmpl_each object.hash_method context=list&gt;     &lt;tmpl_var _\|_key_\|_ &gt;     &lt;/tmpl_each&gt;</p><p>Since 1.000_001 you can also define by which variable you want to sort. If you have a hash with hashes as values:</p><p>    $htc-&gt;param(         letters =&gt; {             1 =&gt; { letter =&gt;&apos;b&apos; },             2 =&gt; { letter =&gt;&apos;a&apos; },             3 =&gt; { letter =&gt;&apos;c&apos; },         },     );     &lt;%each letters sort=alpha sortby="letter" %&gt;     &lt;%set_var val value=_\|_value_\|_ %&gt;     &lt;%= _\|_key_\|_ %&gt; = &lt;%= $val.letter %&gt;     &lt;%/each%&gt;</p>
<h3>\s-1SET_VAR\s0</h3>
<p>Since 0.96_002</p><p>Sets a local variable to the value given in \*(C`value\*(C' or \*(C`expr\*(C'</p><p>    &lt;tmpl_set foo expr=23&gt;     &lt;tmpl_set name=bar expr=23&gt;     &lt;tmpl_set boo value=var.boo&gt;     &lt;tmpl_set oof expr="21*2"&gt;     &lt;tmpl_var $foo&gt;     &lt;tmpl_var $bar&gt;     ...</p><p>\*(C`value=..\*(C' behaves like a variable name from the parameter stash. The variable name to set must match /[0-9a-z_]+/i</p><p>You can refer to an alias via $alias or simply \*(C`alias\*(C'. Note that the latter syntax is not recommeded any more since it can conflict with parameters from the stash.</p><p>If you want to use aliases in includes, you need to use the $alias syntax.</p>
<h3>\s-1USE_VARS\s0</h3>
<p>deprecated. Was added in 0.96_004 to make it possible to use aliases set with \*(C`alias=...\*(C' or \*(C`SET_VAR\*(C' in includes. Now you should rather use the &lt;$alias&gt; syntax.</p><p>The following explanation is just there for history and will be removed some time in the future. For now it still works.</p><p>Necessary if you want vars like \s-1SET_VAR\s0 and loop aliases from outside in includes. Before the first use in the include, add:</p><p>    &lt;tmpl_use_vars foo,bar,boo &gt;</p><p>so that the compiler recognizes them as user defined vars and not parameters from the stash. This statement is valid until the end of the template so you cannot \*(L"overwrite\*(R" parameters of the stash locally.</p>
<h3>\s-1WRAPPER\s0</h3>
<p>Since 0.97_005. Experimental. Please test.</p><p>Needs option \*(C`loop_context_vars\*(C'.</p><p>Works similar to \s-1WRAPPER\s0 in Template-Toolkit.</p><p>Is similar to \s-1TMPL_INCLUDE\s0, just that the included wrapper is wrapped around the content. It can be used to avoid including head and foot separately.</p><p>    &lt;tmpl_wrapper wrapper.html &gt;     content: some var: &lt;tmpl_var foo &gt;     &lt;/tmpl_wrapper&gt;</p><p>In wrapper.html the special loop context var \*(C`_\|_wrapper_\|_\*(C' is used for the included content:</p><p>    wrapper.html:     &lt;some&gt;&lt;layout&gt;     &lt;tmpl_var _\|_wrapped_\|_ &gt;     &lt;/layout&gt;&lt;/some&gt;</p><p>Important notes:</p><p>If you are using \*(C`out_fh\*(C' to print directly to a filehandle instead of returning to a string, this feature might not be useful, since it is appending the content inside of the wrapper to a string and prints it when it comes to the end of the wrapper tag. So if you are using \*(C`out_fh\*(C' to avoid generating long strings in memory, you should rather use \s-1TMPL_INCLUDE\s0 instead.</p><p>Also you need perl 5.8 or higher to use it in combination with out_fh.</p>
<h3>\s-1TMPL_COMMENT\s0</h3>
<p>For debugging purposes you can temporarily comment out regions:</p><p>  Wanted: &lt;tmpl_var wanted&gt;     &lt;tmpl_comment outer&gt;     this won&apos;t be printed       &lt;tmpl_comment inner&gt;         &lt;tmpl_var unwanted&gt;       &lt;/tmpl_comment inner&gt;       &lt;tmpl_var unwanted&gt;   &lt;/tmpl_comment outer&gt;</p><p>  $htc-&gt;param(unwanted =&gt; "no thanks", wanted =&gt; "we want this");</p><p>The output is (whitespaces stripped):</p><p>  Wanted: we want this</p><p>\s-1HTC\s0 will ignore anything between \s-1COMMENT\s0 directives. This is useful for debugging, and also for documentation inside the template which should not be outputted.</p>
<h3>\s-1TMPL_NOPARSE\s0</h3>
<p>Anything between</p><p>  &lt;tmpl_noparse&gt;...&lt;/tmpl_noparse&gt;</p><p>will not be recognized as template directives. Same syntax as \s-1TMPL_COMMENT\s0. It will output the content, though.</p>
<h3>\s-1TMPL_VERBATIM\s0</h3>
<p>Anything between</p><p>  &lt;tmpl_verbatim&gt;...&lt;/tmpl_verbatim&gt;</p><p>will not be recognized as template directives. Same syntax as \*(L"\s-1TMPL_NOPARSE\s0\*(R", but it will be HTML-Escaped. This can be useful for debugging.</p>
<h3>\s-1TMPL_SWITCH\s0</h3>
<p>The \s-1SWITCH\s0 directive has the same syntax as \s-1VAR\s0, \s-1IF\s0 etc. The \s-1CASE\s0 directive takes a simple string or a comma separated list of strings. Yes, without quotes. This will probably change! I just don't know yet how it should look like. Suggestions?</p><p>With that directive you can do simple string comparisons.</p><p> &lt;tmpl_switch language&gt;(or &lt;tmpl_switch name=language&gt;)   &lt;tmpl_case de&gt;echt cool   &lt;tmpl_case en&gt;very cool   &lt;tmpl_case es&gt;superculo   &lt;tmpl_case fr,se&gt;don&apos;t speak french or swedish   &lt;tmpl_case default&gt;sorry, no translation for cool in language &lt;%=language%&gt; available   &lt;tmpl_case&gt;(same as default)  &lt;/tmpl_switch&gt;</p><p>It's also possible to specify the default with a list of other strings:</p><p> &lt;tmpl_case fr,default&gt;</p><p>Note that the default case should always be the last statement before the closing switch.</p>
<h3>\s-1OPTIONS\s0</h3>
<p>As you can cache the generated perl code in files, some of the options are fixed; that means for example if you set the option case_sensitive to 0 and the next time you call the same template with case_sensitive 1 then this will be ignored. The options below will be marked as (fixed).</p>
<dl class='dl-vertical'>
  <dt>
    path
  </dt>
  <dd>
    <p>Path to template files</p>
  </dd>
  <dt>
    search_path_on_include
  </dt>
  <dd>
    <p>Search the list of paths specified with \*(C`path\*(C' when including a template. Default is 0 See \*(L"\s-1DIFFERENT\s0 \s-1FEATURES\s0\*(R" for the additional possible value 2.</p>
  </dd>
  <dt>
    file_cache
  </dt>
  <dd>
    <p>Set to 1 if you want to use file caching and specify the path with file_cache_dir.</p>
  </dd>
  <dt>
    file_cache_dir
  </dt>
  <dd>
    <p>Path to caching directory (you have to create it before)</p>
  </dd>
  <dt>
    cache_dir
  </dt>
  <dd>
    <p>Replaced by file_cache_dir like in HTML::Template. Will be deprecated in future versions.</p>
  </dd>
  <dt>
    cache
  </dt>
  <dd>
    <p>Is 1 by default. If set to 0, no memory cacheing is done. Only recommendable if you have a dynamic template content (with scalarref, arrayre for example).</p>
  </dd>
  <dt>
    expire_time
  </dt>
  <dd>
    <p>Recheck template files on disk after \*(C`expire_time\*(C' seconds. See \*(L"\s-1CACHING\s0\*(R"</p>
  </dd>
  <dt>
    filename
  </dt>
  <dd>
    <p>Template to parse</p>
  </dd>
  <dt>
    scalarref
  </dt>
  <dd>
    <p>Reference to a scalar with your template content. It's possible to cache scalarrefs, too, if you have Digest::MD5 installed. Note that your cache directory might get filled with files from earlier versions. Clean the cache regularly. Don't cache scalarrefs if you have dynamic strings. Your memory might get filled up fast! Use the option   cache =&gt; 0 to disable memory caching.</p>
  </dd>
  <dt>
    arrayref
  </dt>
  <dd>
    <p>Reference to array containing lines of the template content (newlines have to be included)</p>
  </dd>
  <dt>
    filehandle
  </dt>
  <dd>
    <p>Filehandle which contains the template content. Note that \s-1HTC\s0 will not cache templates created like this.</p>
  </dd>
  <dt>
    loop_context_vars (fixed)
  </dt>
  <dd>
    <p>Vars like \*(C`_\|_first_\|_\*(C', \*(C`_\|_last_\|_\*(C', \*(C`_\|_inner_\|_\*(C', \*(C`_\|_odd_\|_\*(C', \*(C`_\|_counter_\|_\*(C', \*(C`_\|_index_\|_\*(C', \*(C`_\|_outer_\|_\*(C', \*(C`_\|_even_\|_\*(C' The variable \*(C`_\|_index_\|_\*(C' works just like \*(C`_\|_counter_\|_\*(C', only that it starts at 0 instead of 1.</p>
  </dd>
  <dt>
    global_vars (fixed)
  </dt>
  <dd>
    <p>If set to 1, every outer variable can be accessed from anywhere in the enclosing scope. Default is 0. Note that I don't recommend using global_vars. For referring to parameters up in the stash you can use aliases via \*(C`alias=...\*(C' or \*(C`SET_VAR\*(C'. See \*(L"\s-1ALIAS\s0\*(R" and \*(L"\s-1SET_VAR\s0\*(R". If yoy still would like to be able to navigate up the parameter stash, you have the following option: If set to 2, you don't have global vars, but have the possibility to go up the stack one level. Example:  &lt;tmpl_var ...key&gt; This will get you up 2 levels (remember: one dot means root in \s-1HTC\s0) and access the 'key' element. If set to 3 (\*(C`3 == 1|2\*(C') you have both, global vars and explicitly going up the stack. So setting global_vars to 2 can save you from global vars but still allows you to browse through the stack.</p>
  </dd>
  <dt>
    default_escape
  </dt>
  <dd>
    <p>  my $htc = HTML::Template::Compiled-&gt;new(     ...     default_escape =&gt; &apos;HTML&apos;, # or URL   ); Now everything will be escaped for \s-1HTML\s0 unless you explicitly specify \*(C`ESCAPE=0\*(C' (no escaping) or \*(C`ESCAPE=URL\*(C'.</p>
  </dd>
  <dt>
    strict (since 0.97_001)
  </dt>
  <dd>
    <p>Default: 1 If set to 0 unknown tags will be ignored and output verbatim:     &lt;TMPL_FOOBAR anything ... &lt;TMPL_VAR valid&gt;</p>
  </dd>
  <dt>
    line_info (fixed) (since 1.000_004)
  </dt>
  <dd>
    <p>Default: 0   my $htc = HTML::Template::Compiled-&gt;new(       ...       line_info =&gt; 1, # default 0   ); If any runtime errors occur, line information will output the template filename and line (instead of \*(L"eval\*(R" and the generated perl code line)</p>
  </dd>
  <dt>
    warnings (fixed) (since 1.000_004)
  </dt>
  <dd>
    <p>Default: 0 If set to 1, runtime warnings (like use of uninitialized value) will be output to stderr. If set to 'fatal', any runtime warning will cause the script to die.</p>
  </dd>
  <dt>
    no_includes (since 0.92)
  </dt>
  <dd>
    <p>Default is 0. If set to 1, the tags \s-1INCLUDE\s0, \s-1INCLUDE_VAR\s0 and \s-1INCLUDE_STRING\s0 will cause a template syntax error when creating. This can be useful when opening untrusted templates, otherwise any file in the filesystem could be opened.</p>
  </dd>
  <dt>
    debug_file (fixed) (since 0.91_001)
  </dt>
  <dd>
    <p>Additionally to the context_vars _\|_filename_\|_ and _\|_filenameshort_\|_ you can enable filename debugging globally. If the option is set to 'start', at the start of every template will be added:</p>
<pre>
    &lt;!-- start templates/path/filename.html --&gt;
</pre>
<p>If set to 'end', at the end will be added:</p>
<pre>
    &lt;!-- end templates/path/filename.html --&gt;
</pre>
<p>If set to 'start,end', both coments will be added. If set to 'start,short', 'end,short' or 'start,end,short' the path to the templates will be stripped:</p>
<pre>
    &lt;!-- start path/filename.html --&gt;
    &lt;!-- end path/filename.html --&gt;
</pre>

  </dd>
  <dt>
    objects (fixed) (since 0.91_001)
  </dt>
  <dd>
    <p>if set to true, you can use method calls like</p>
<pre>
    &lt;%= object.method %&gt;
</pre>
<p>Default is 'strict' (true). If set to 'strict', the method will be called if we have an object, otherwise it's treated as a hash lookup. If the method doesn't exist, it dies. If set to 'nostrict', the method will be called only if the object 'can' do the method, otherwise it will return undef (this will need Scalar::Util). If set to 0, no method calls are allowed.</p>
  </dd>
  <dt>
    deref (fixed)
  </dt>
  <dd>
    <p>Deprecated. Please inherit and overwrite method 'deref'. See \*(L"\s-1INHERITANCE\s0\*(R" Define the string you want to use for dereferencing, default is \*(C`.\*(C' at the moment:  &lt;TMPL_VAR hash.key&gt;</p>
  </dd>
  <dt>
    method_call (fixed)
  </dt>
  <dd>
    <p>Deprecated. Please inherit and overwrite method 'method_call'. See \*(L"\s-1INHERITANCE\s0\*(R" Define the string you want to use for method calls, default is . at the moment:  &lt;TMPL_VAR object.method&gt; Don't use -&gt;, though, like you could in earlier version. Var names can contain: Numbers, letters, '.', '/', '+', '-' and '_', just like HTML::Template. Note that if your var names contain dots, though, they will be treated as hash dereferences. If you want literal dots, use HTML::Template::Compiled::Classic instead.</p>
  </dd>
  <dt>
    default_path (fixed)
  </dt>
  <dd>
    <p>Deprecated, see HTML::Template::Compiled::Formatter please.   my $htc = HTML::Template::Compiled-&gt;new(     ...     default_path          # default is PATH_DEREF       =&gt; HTML::Template::Compiled::Utils::PATH_FORMATTER,   ); Is needed if you have an unqualified tmpl_var that should be resolved as a call to your formatter, for example. Otherwise you have to call it fully qualified. If your formatter_path is '/', you'd say tmpl_var \*(C`_/method\*(C'. With the option default_path you can make that the default, so you don't need the \*(C`_/\*(C': \*(C`tmpl_var method\*(C'. If you don't use formatters, don't care about this option.</p>
  </dd>
  <dt>
    line_numbers
  </dt>
  <dd>
    <p>\s-1NOTE:\s0 This option does not exist any more; line numbers will alway be reported. For debugging: prints the line number of the wrong tag, e.g. if you have a /TMPL_IF that does not have an opening tag.</p>
  </dd>
  <dt>
    case_sensitive (fixed)
  </dt>
  <dd>
    <p>default is 1, set it to 0 to use this feature like in HTML::Template. Note that this can slow down your program a lot (50%).</p>
  </dd>
  <dt>
    dumper
  </dt>
  <dd>
    <p>This option is deprecated as of version 0.76. You must now use a plugin instead, like HTML::Template::Compiled::Plugin::DHTML, for examle.   my $t = HTML::Template::Compiled-&gt;new(     ...     dumper = sub { my_cool_dumper($_[0]) },   );   ---   &lt;TMPL_VAR var ESCAPE=DUMP&gt; This will call \*(C`my_cool_dumper()\*(C' on \*(C`var\*(C'. Alternatively you can use the \s-1DHTML\s0 plugin which is using \*(C`Data::TreeDumper\*(C' and \*(C`Data::TreeDumper::Renderer::DHTML\*(C'. You'll get a  dumper like output which you can collapse and expand, for example. See Data::TreeDumper and Data::TreeDumper::Renderer::DHTML for more information. Example:   my $t = HTML::Template::Compiled-&gt;new(     ...     dumper = &apos;DHTML&apos;,   ); For an example see \*(C`examples/dhtml.html\*(C'.</p>
  </dd>
  <dt>
    out_fh (fixed)
  </dt>
  <dd>
    <p>  my $t = HTML::Template::Compiled-&gt;new(     ...     out_fh =&gt; 1,   );   ...   $t-&gt;output($fh); # or output(&#92;*STDOUT) or even output() This option is fixed, so if you create a template with \*(C`out_fh\*(C', every output of this template will print to a specified (or default \*(C`STDOUT\*(C') filehandle.</p>
  </dd>
  <dt>
    filter
  </dt>
  <dd>
    <p>Filter template code before parsing.   my $t = HTML::Template::Compiled-&gt;new(     ...     filter =&gt; sub { myfilter( ${$_[0]} ) },     # or     filter =&gt; [ {         sub =&gt; sub { myfilter( ${$_[0]} ) },         format =&gt; &apos;scalar&apos;, # or array       },       ...     ],   );</p>
  </dd>
  <dt>
    tagstyle (fixed)
  </dt>
  <dd>
    <p>Specify which styles you want to use. This option takes an arrayref with strings of named tagstyles or your own regexes. At the moment there are the following named tagstyles builtin:     # classic (active by default)     &lt;TMPL_IF foo&gt;&lt;tmpl_var bar&gt;&lt;/TMPL_IF&gt;</p><p>    # comment (active by default)     &lt;!-- TMPL_IF foo --&gt;&lt;!-- TMPL_VAR bar --&gt;&lt;!-- /TMPL_IF --&gt;</p><p>    # asp (active by default)     &lt;%if foo%&gt;&lt;%VAR bar%&gt;&lt;%/if%&gt;</p><p>    # php (not active by default)     &lt;?if foo?&gt;&lt;?var bar?&gt;&lt;?/if foo?&gt;</p><p>    # tt (not active by default)     [%if foo%][%var bar%][%/if foo%] You deactive a style by saying -stylename. You activate by saying +stylename. Define your own tagstyle by specifyin regexes. For example you want to use {\*(C`{if foo}}{{var bar}}{{/if foo}}\*(C', then your definition should be:     [         qr({{), # start of opening tag         qr(}}), # end of opening tag         qr({{/), # start of closing tag         qr(}}), # end of closing tag     ] \s-1NOTE:\s0 do not specify capturing parentheses in you regexes. If you need parentheses, use \*(C`(?:foo|bar)\*(C' instead of \*(C`(foo|bar)\*(C'. Say you want to deactivate asp-style, comment-style, activate php- and tt-style and your own \*(C`{{}} \*(C' style, then say:     my $htc = HTML::Template::Compiled-&gt;new(         ...         tagstyle =&gt; [             qw(-asp -comment +php +tt),             [ qr({{), qr(}}), qr({{/), qr(}})],         ],     );</p>
  </dd>
  <dt>
    use_expressions (since 0.91_003)
  </dt>
  <dd>
    <p>Set to 1 if you want to use expressions. The basic expressions work more or less like in HTML::Template::Expr - I took the parsing code from it and used it with some minor changes - thanks to Sam Tregar.     &lt;%if expr="some.var &gt; 3" %&gt;It&apos;s grater than 3&lt;%/if %&gt; But with expressions you can also use more complex navigation through the template stash: You can use object methods with parameters. While a normal method call can only be called without parameters, like     &lt;%= object.name %&gt; with expressions you can give it parameters:     &lt;%= expr="object.create_link(&apos;navi&apos;)" %&gt; Inside function and method calls, hash keys you also can use template vars (array indices and hash keys since 0.96_003).     &lt;%= expr=".path.to.hash{var}" %&gt;     &lt;%= expr=".path.to.hash{.another.var[123]}{&apos;literal key&apos;}" %&gt; It is only minimally tested yet, so use with care and please report any bugs you find. A useful example: Output a number of items with their prices formatted.     my $nf = Number::Format-&gt;new(...);     my $htc = HTML::Template::Compiled-&gt;new(         filename =&gt; &apos;items.html&apos;,         use_expressions =&gt; 1,     );     $htc-&gt;param(         items =&gt; [             { size =&gt;  50 * 1024 * 1024 * 1024, price =&gt; 49.95 },             { size =&gt; 250 * 1024 * 1024 * 1024, price =&gt; 110.99 },         ],         nf =&gt; $nf,     ); items.html:     &lt;%loop .items %&gt;     Size: &lt;%= expr=".nf.format_bytes(size)" %&gt;     Price: &lt;%= expr=".nf.format_price(price)" %&gt;     &lt;%/loop %&gt; Output:</p>
<pre>
    Size: 50G
    Price: 49,95 \s-1EUR\s0
</pre>
<p>    Size: 250G     Price: 110,99 EUR</p>
  </dd>
  <dt>
    formatter
  </dt>
  <dd>
    <p>Deprecated, see HTML::Template::Compiled::Formatter please. With formatter you can specify how an object should be rendered. This is useful if you don't want object methods to be called, but only a given subset of methods.   my $htc = HTML::Template::Compiled-&gt;new(   ...   formatter =&gt; {     &apos;Your::Class&apos; =&gt; {       fullname =&gt; sub {         $_[0]-&gt;first . &apos; &apos; . $_[0]-&gt;last       },       first =&gt; Your::Class-&gt;can(&apos;first&apos;),       last =&gt; Your::Class-&gt;can(&apos;last&apos;),       },     },   );   # $obj is a Your::Class object   $htc-&gt;param(obj =&gt; $obj);   # Template:   # Fullname: &lt;tmpl_var obj/fullname&gt;</p>
  </dd>
  <dt>
    formatter_path (fixed)
  </dt>
  <dd>
    <p>Deprecated, see HTML::Template::Compiled::Formatter please.</p>
  </dd>
  <dt>
    debug
  </dt>
  <dd>
    <p>If set to 1 you will get the generated perl code on standard error</p>
  </dd>
  <dt>
    use_query
  </dt>
  <dd>
    <p>Set it to 1 if you plan to use the <em>query()</em> method. Default is 0. Explanation: If you want to use <em>query()</em> to collect information on the template \s-1HTC\s0 has to do extra-work while compiling and uses extra-memory, so you can choose to save \s-1HTC\s0 work by setting use_query to 0 (default) or letting \s-1HTC\s0 do the extra work by setting it to 1. If you would like 1 to be the default, write me. If enough people write me, I'll think abou it =)</p>
  </dd>
  <dt>
    use_perl
  </dt>
  <dd>
    <p>Set to 1 if you want to use the perl-tag. See \*(L"\s-1TMPL_PERL\s0\*(R". Default is 0.</p>
  </dd>
  <dt>
    cache_debug
  </dt>
  <dd>
    <p>Default: 0 You can debug hits and misses for file cache and memory cache:     # debug all cache     my $htc = HTML::Template::Compiled-&gt;new(         cache_debug =&gt; 1,         ...     );     # only debug misses     my $htc = HTML::Template::Compiled-&gt;new(         cache_debug =&gt; [qw/ file_miss mem_miss /],         ...     ); Possible values when passing an array ref: file_miss file_hit mem_miss mem_hit Output looks similar to HTML::Template cache_debug and will be output to \s-1STDERR\s0 via <em>warn()</em>.</p>
  </dd>

</dl>

<h3>\s-1METHODS\s0</h3>

<dl class='dl-vertical'>
  <dt>
    clear_cache ([\s-1DIR\s0])
  </dt>
  <dd>
    <p>Class method. It will clear the memory cache either of a specified cache directory:   HTML::Template::Compiled-&gt;clear_cache($cache_dir); or all memory caches:   HTML::Template::Compiled-&gt;clear_cache();</p>
  </dd>
  <dt>
    clear_filecache
  </dt>
  <dd>
    <p>Class- or object-method. Removes all generated perl files from a given directory.   # clear a directory   HTML::Template::Compiled-&gt;clear_filecache(&apos;cache_directory&apos;);   # clear this template&apos;s cache directory (and not one template file only!)   $htc-&gt;clear_filecache();</p>
  </dd>
  <dt>
    param
  </dt>
  <dd>
    <p>Works like in HTML::Template.</p>
  </dd>
  <dt>
    query
  </dt>
  <dd>
    <p>Works like in HTML::Template. But it is not activated by default. If you want to use it, specify the use_query option.</p>
  </dd>
  <dt>
    preload
  </dt>
  <dd>
    <p>Class method. Will preload all template files from a given cachedir into memory. Should be done, for example in a mod_perl environment, at server startup, so all templates go into \*(L"shared memory\*(R"   HTML::Template::Compiled-&gt;preload($cache_dir); If you don't do preloading in mod_perl, memory usage might go up if you have a lot of templates. Note: the directory is *not* the template directory. It should be the directory which you give as the file_cache_dir option.</p>
  </dd>
  <dt>
    precompile
  </dt>
  <dd>
    <p>Class method. It will precompile a list of template files into the specified cache directory. See \*(L"\s-1PRECOMPILE\s0\*(R".</p>
  </dd>
  <dt>
    clear_params
  </dt>
  <dd>
    <p>Empty all parameters.</p>
  </dd>
  <dt>
    debug_code (since 0.91_003)
  </dt>
  <dd>
    <p>If you get an error from the generated template, you might want to debug the executed code. You can now call \*(C`debug_code\*(C' to get the compiled code and the line the error occurred. Note that the reported line might not be the exact line where the error occurred, also look around the line. The template filename reported does currently only report the main template, not the name of an included template. I'll try to fix that.     local $HTML::Template::Compiled::DEBUG = 1;     my $htc = HTML::Template::Compiled-&gt;new(         filename =&gt; &apos;some_file_with_runtime_error.html&apos;,     );     eval {         print $htc-&gt;output;     };     if ($@) {         # reports as text         my $msg = $htc-&gt;debug_code;         # reports as a html table         my $msg_html = $htc-&gt;debug_code(&apos;html&apos;);     }</p>
  </dd>
  <dt>
    get_plugin
  </dt>
  <dd>
    <p>    my $plugin = $htc-&gt;get_plugin(&apos;Name::of::plugin&apos;); Returns the plugin object of that classname. If the plugin is only a string (the classname itself), it returns this string, so this method is only useful for plugin objects.</p>
  </dd>
  <dt>
    var2expression
  </dt>
  <dd>
    <p>Useful for plugins. Parses a template var (\*(C`name="foo.bar.baz"\*(C' and returns the perl expression for the compiler.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORT</h2>
        <div class="sectioncontent">
<p>None.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CACHING</h2>
        <div class="sectioncontent">
<p>You create a template almost like in HTML::Template:</p><p>  my $t = HTML::Template::Compiled-&gt;new(     path                =&gt; &apos;templates&apos;,     loop_context_vars   =&gt; 1,     filename            =&gt; &apos;test.html&apos;,     # for testing without cache comment out     file_cache          =&gt; 1,     file_cache_dir      =&gt; "cache",   );</p><p>The next time you start your application and create a new template, \s-1HTC\s0 will read all generated perl files, and a call to the constructor like above won't parse the template, but just use the loaded code. If your template file has changed, though, then it will be parsed again.</p><p>You can set the expire time of a template by passing the option</p><p>    expire_time =&gt; $seconds</p><p>Note that</p><p>    HTML::Template::Compiled-&gt;ExpireTime($seconds);     C&lt;$HTML::Template::Compiled::NEW_CHECK&gt;</p><p>are deprecated since they change a global variable which is then visible in the whole process, so in persistent environments other apps might be affected.</p><p>So an expire time of 600 seconds (default) will check after 10 minutes if the tmpl file was modified. Set it to a very high value will then ignore any changes, until you delete the generated code. For development you should set it to 0, for a pre-production server you can set it to 60 seconds, for example. It can make quite a difference.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PLUGINS</h2>
        <div class="sectioncontent">
<p>At the moment you can use and write plugins for the \*(C`ESCAPE\*(C' attribute. See HTML::Template::Compiled::Plugin::XMLEscape for an example how to use it; and have a look at the source code if you want to know how to write a plugin yourself.</p><p>Using Plugins:</p><p>    my $htc = HTML::Template::Compiled-&gt;new(         ...         plugin =&gt; [&apos;HTML::Template::Compiled::Foo::Bar&apos;],         # oor shorter:         plugin =&gt; [&apos;::Foo::Bar&apos;],     );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LAZY LOADING</h2>
        <div class="sectioncontent">
<p>Let's say you're in a \s-1CGI\s0 environment and have a lot of includes in your template, but only few of them are actually used. HTML::Template::Compiled will (as HTML::Template does) parse all of your includes at once. Just like the \*(C`use\*(C' function does in perl. To get a behaviour like require, use HTML::Template::Compiled::Lazy.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>associate, methods with simple parameters, expressions, pluggable, ...</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTATION</h2>
        <div class="sectioncontent">
<p>\s-1HTC\s0 generates a perl subroutine out of every template. Each included template is a subroutine for itself. You can look at the generated code by activating file caching and looking into the cache directory. When you call \*(C`output()\*(C', the subroutine is called. The subroutine either creates a string and adds each template text or the results of the tags to the string, or it prints it directly to a filehandle. Because of the implementation you have to know at creation time of the module if you want to get a string back or if you want to print to a filehandle.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SECURITY</h2>
        <div class="sectioncontent">
<p>HTML::Template::Compiled uses basically the same file caching model as, for example, Template- Toolkit does: The compiled Perl code is written to disk and later reread via \*(C`do\*(C' or by reading the file and \*(C`eval\*(C' the content.</p><p>If you are sharing a read/write environment with untrusted users (for example on a machine with a webserver, like many webhosters offer, and all scripts are running as the same httpd user), realize that there is possibility of modifying the Perl code that is cached and then executed. The best solution is to not be in such an environment!</p><p>In this case it is the safest option to generate your compiled templates on a local machine and just put the compiled templates onto the server, with no write access for the http server. Set the \*(C`expire_time\*(C' option to a high value so that \s-1HTC\s0 never attempts to check the template timestamp to force a regenerating of the code.</p><p>If you are alone on the machine, but you are running under taint mode (see perlsec) then you have to explicitly set the $UNTAINT variable to 1. \s-1HTC\s0 will then untaint the code for you and treat it as if it were safe (it hopefully is =).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PRECOMPILE</h2>
        <div class="sectioncontent">
<p>I think there is no way to provide an easy function for precompiling, because every template can have different options. If you have all your templates with the same options, then you can use the precompile class method. It works like this:</p><p>  HTML::Template::Compiled-&gt;precompile(     # usual options like path, default_escape, global_vars, file_cache_dir, ...     filenames =&gt; [ list of template-filenames ],   );</p><p>This will then pre-compile all templates into file_cache_dir. Now you would just put this directory onto the server, and it doesn't need any write-permissions, as it will be never changed (until you update it because templates have changed).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BENCHMARKS</h2>
        <div class="sectioncontent">
<p>The options \*(C`case_sensitive\*(C', \*(C`loop_context_vars\*(C' and \*(C`global_vars\*(C' can have the biggest influence on speed.</p><p>Setting case_sensitive to 1, loop_context_vars to 0 and global_vars to 0 saves time.</p><p>On the other hand, compared to HTML::Template, you have a large speed gain under mod_perl if you use case_sensitive = 1, loop_context_vars = 0, With \s-1CGI\s0 \s-1HTC\s0 is slower.</p><p>See the \*(C`examples/bench.pl\*(C' contained in this distribution.</p><p>Here are some examples from the benchmark script. I'm showing only Template::AutoFilter, Template::HTML, HTML::Template and \s-1HTC\s0. These four modules allow to set automatic \s-1HTML\s0 escaping ('filter') for all variables.</p><p> loop_context_vars 1  global_vars 0  case_sensitive 1  default_escape HTML (respectively Template::AutoFilter and Template::HTML)</p><p> ht: HTML::Template 2.10  htc: HTML::Template::Compiled 0.95  ttaf: Template::AutoFilter 0.112350 with Template 2.22  tth: Template::HTML 0.02 with Template 2.22</p><p>First test is with the test.(htc|tt) from the examples directory, about 900 bytes.</p><p>Test without file cache and without memory cache.</p><p>              all_ht:  1 wallclock secs ( 0.40 usr +  0.00 sys =  0.40 CPU) @ 250.00/s (n=100)              all_htc:  1 wallclock secs ( 1.74 usr +  0.01 sys =  1.75 CPU) @ 57.14/s (n=100)  all_ttaf_new_object:  1 wallclock secs ( 1.69 usr +  0.01 sys =  1.70 CPU) @ 58.82/s (n=100)   all_tth_new_object:  1 wallclock secs ( 1.44 usr +  0.00 sys =  1.44 CPU) @ 69.44/s (n=100)</p><p>With file cache:</p><p>              all_ht:  1 wallclock secs ( 1.03 usr +  0.01 sys =  1.04 CPU) @ 379.81/s (n=395)              all_htc:  1 wallclock secs ( 1.07 usr +  0.00 sys =  1.07 CPU) @ 260.75/s (n=279)  all_ttaf_new_object:  1 wallclock secs ( 1.07 usr +  0.04 sys =  1.11 CPU) @ 251.35/s (n=279)   all_tth_new_object:  1 wallclock secs ( 1.01 usr +  0.04 sys =  1.05 CPU) @ 227.62/s (n=239)</p><p>With memory cache:</p><p>       all_ht:  1 wallclock secs ( 1.04 usr +  0.00 sys =  1.04 CPU) @ 461.54/s (n=480)       all_htc:  1 wallclock secs ( 1.05 usr +  0.01 sys =  1.06 CPU) @ 3168.87/s (n=3359)  process_ttaf:  1 wallclock secs ( 1.04 usr +  0.00 sys =  1.04 CPU) @ 679.81/s (n=707)   process_tth:  1 wallclock secs ( 1.05 usr +  0.00 sys =  1.05 CPU) @ 609.52/s (n=640)</p><p>Now I'm using a template with about 18Kb by multiplying the example template 20 times. You can see that everything is running slower but some run more slower than others.</p><p>Test without file cache and without memory cache.</p><p>              all_ht:  8 wallclock secs ( 7.57 usr +  0.04 sys =  7.61 CPU) @ 13.14/s (n=100)              all_htc: 32 wallclock secs (32.08 usr +  0.06 sys = 32.14 CPU) @  3.11/s (n=100)  all_ttaf_new_object: 36 wallclock secs (36.21 usr +  0.04 sys = 36.25 CPU) @  2.76/s (n=100)   all_tth_new_object: 29 wallclock secs (28.92 usr +  0.05 sys = 28.97 CPU) @  3.45/s (n=100)</p><p>With file cache:</p><p>              all_ht:  8 wallclock secs ( 7.22 usr +  0.00 sys =  7.22 CPU) @ 13.85/s (n=100)              all_htc:  5 wallclock secs ( 5.32 usr +  0.00 sys =  5.32 CPU) @ 18.80/s (n=100)  all_ttaf_new_object:  8 wallclock secs ( 7.59 usr +  0.15 sys =  7.74 CPU) @ 12.92/s (n=100)   all_tth_new_object:  9 wallclock secs ( 8.74 usr +  0.19 sys =  8.93 CPU) @ 11.20/s (n=100)</p><p>With memory cache:</p><p>       all_ht:  1 wallclock secs ( 1.04 usr +  0.01 sys =  1.05 CPU) @ 15.24/s (n=16)       all_htc:  1 wallclock secs ( 1.12 usr +  0.00 sys =  1.12 CPU) @ 272.32/s (n=305)  process_ttaf:  1 wallclock secs ( 1.07 usr +  0.00 sys =  1.07 CPU) @ 39.25/s (n=42)   process_tth:  1 wallclock secs ( 1.05 usr +  0.00 sys =  1.05 CPU) @ 34.29/s (n=36)</p><p>So the performance difference highly depends on the size of the template and on the various options. You can see that using the 900byte template \s-1HTC\s0 is slower with file cache than HTML::Template, but with the 18Kb template it's faster.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>See \*(L"objects.html\*(R" in examples (and \*(C`examples/objects.pl\*(C') for an example how to feed objects to \s-1HTC\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Probably many bugs I don't know yet =)</p><p>Use the bugtracking system to report a bug: http://rt.cpan.org/NoAuth/Bugs.html?Dist=HTML-Template-Compiled</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Why another Template System?</h2>
        <div class="sectioncontent">
<p>You might ask why I implement yet another templating system. There are so many to choose from. Well, there are several reasons.</p><p>I like the syntax of HTML::Template *because* it is very restricted. It's also easy to use (template syntax and \s-1API\s0). However, there are some things I miss I try to implement here.</p><p>I think while HTML::Template is quite good, the implementation can be made more efficient (and still pure Perl). That's what I'm trying to achieve.</p><p>I use it in my web applications, so I first write it for myself =) If I can efficiently use it, it was worth it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESOURCES</h2>
        <div class="sectioncontent">
<p>See http://htcompiled.sf.net/ for svn access.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO HTML::Template::Compiled&hellip;</h2>
        <div class="sectioncontent">
<p>HTML::Template</p><p>HTML::Template::JIT</p><p>Template - Toolkit</p><p>http://www.tinita.de/projects/perl/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Tina Mueller</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREDITS</h2>
        <div class="sectioncontent">
<p>Sam Tregar big thanks for ideas and letting me use his HTML::Template test suite</p><p>Bjoern Kriews for original idea and contributions</p><p>Special Thanks to Sascha Kiefer - he finds all the bugs!</p><p>Ronnie Neumann, Martin Fabiani, Kai Sengpiel, Jan Willamowius, Justin Day, Steffen Winkler, Henrik Tougaard for ideas, beta-testing and patches</p><p>&lt;http://www.perlmonks.org/&gt; and http://www.perl-community.de/&gt; for everyday learning</p><p>Corion, Limbic~Region, tye, runrig and others from perlmonks.org</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2005-2012 by Tina Mueller</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.3 or, at your option, any later version of Perl 5 you may have available.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="HTML::Tagset.3pm.html"><span aria-hidden="true">&larr;</span> HTML::Tagset.3pm: Data tables useful in parsing html</a></li>
   <li class="next"><a href="HTML::Template::Compiled::Classic.3pm.html">HTML::Template::Compiled::Classic.3pm: Provide the classic functionality like html::template <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

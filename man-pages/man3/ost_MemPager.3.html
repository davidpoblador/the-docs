<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ost_MemPager: The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ost_MemPager (3) manual">
  <meta name="twitter:description" content="The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_MemPager-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/ost_MemPager.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ost_MemPager (3) manual" />
  <meta property="og:description" content="The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_MemPager-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ost_MemPager<small> (3)</small></h1>
        <p class="lead">The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_MemPager.3.html">
      <span itemprop="name">ost_MemPager: The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcommoncpp2-doc/">
      <span itemprop="name">libcommoncpp2-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_MemPager.3.html">
      <span itemprop="name">ost_MemPager: The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;misc.h&gt;</p><p>Inherited by <strong>ost::Keydata</strong> [protected]<strong>, </strong><strong>ost::SharedMemPager</strong><strong>, and </strong><strong>ost::StackPager</strong><strong> [protected]</strong><strong>.</strong></p><h3>Public Member Functions</h3>
<p>int <strong>getPages</strong> (void)</p><p><em>Return the total number of pages that have been allocated for this memory pool. </em></p>
<h3>Protected Member Functions</h3>
<p>virtual void * <strong>first</strong> (size_t size)</p><p><em>Allocate first workspace from paged memory. </em> virtual void * <strong>alloc</strong> (size_t size)</p><p><em>Allocate memory from either the currently active page, or allocate a new page for the object. </em> char * <strong>first</strong> (char *str)</p><p><em>Allocate a string from the memory pager pool and copy the string into it's new memory area. </em> char * <strong>alloc</strong> (const char *str)</p><p><em>Allocate a string from the memory pager pool and copy the string inti it's new memory area. </em> <strong>MemPager</strong> (size_t pagesize=4096)</p><p><em>Create a paged memory pool for cumulative storage. </em> void <strong>purge</strong> (void)</p><p><em>purge the current memory pool. </em> void <strong>clean</strong> (void)</p><p><em>Clean for memory cleanup before exiting. </em> virtual <strong>~MemPager</strong> ()</p><p><em>Delete the memory pool and all allocated memory. </em></p>
<h3>Friends</h3>
<p>class <strong>String</strong></p><p>class <strong>MemPagerObject</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object.</p><p>When the object is destroyed, all accumulated data is automatically purged.</p><p>There are a number of odd and specialized utility classes found in Common C++. The most common of these is the 'MemPager' class. This is basically a class to enable page-grouped 'cumulative' memory allocation; all accumulated allocations are dropped during the destructor. This class has found it's way in a lot of other utility classes in Common C++.</p><p><strong>Author:</strong></p><p>David Sugar dyfet@ostel.com Accumulative object memory allocator.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>ost::MemPager::MemPager (size_tpagesize = \fC4096\fP)\fC [protected]\fP</h3>
<p>Create a paged memory pool for cumulative storage. This pool allocates memory in fixed 'pagesize' chunks. Ideal performance is achived when the pool size matches the system page size. This pool can only exist in derived objects.</p><p><strong>Parameters:</strong></p><p><em>pagesize</em> page size to allocate chunks.</p>
<h3>virtual ost::MemPager::~MemPager ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Delete the memory pool and all allocated memory.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>virtual void* ost::MemPager::alloc (size_tsize)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Allocate memory from either the currently active page, or allocate a new page for the object.</p><p><strong>Parameters:</strong></p><p><em>size</em> size of memory to allocate.</p><p><strong>Returns:</strong></p><p>pointer to allocated memory.</p><p>Reimplemented in <strong>ost::SharedMemPager</strong>.</p>
<h3>char* ost::MemPager::alloc (const char *str)\fC [protected]\fP</h3>
<p>Allocate a string from the memory pager pool and copy the string inti it's new memory area. This checks only the last active page for available space before allocating a new page.</p><p><strong>Parameters:</strong></p><p><em>str</em> string to allocate and copy into paged memory pool.</p><p><strong>Returns:</strong></p><p>copy of string from allocated memory.</p>
<h3>void ost::MemPager::clean (void)\fC [protected]\fP</h3>
<p>Clean for memory cleanup before exiting.</p>
<h3>virtual void* ost::MemPager::first (size_tsize)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Allocate first workspace from paged memory. This method scans all currently allocated blocks for available space before adding new pages and hence is both slower and more efficient.</p><p><strong>Parameters:</strong></p><p><em>size</em> size of memory to allocate.</p><p><strong>Returns:</strong></p><p>pointer to allocated memory.</p><p>Reimplemented in <strong>ost::SharedMemPager</strong>.</p>
<h3>char* ost::MemPager::first (char *str)\fC [protected]\fP</h3>
<p>Allocate a string from the memory pager pool and copy the string into it's new memory area. This method allocates memory by first searching for an available page, and then allocating a new page if no space is found.</p><p><strong>Parameters:</strong></p><p><em>str</em> string to allocate and copy into paged memory pool.</p><p><strong>Returns:</strong></p><p>copy of string from allocated memory.</p>
<h3>int ost::MemPager::getPages (void)\fC [inline]\fP</h3>
<p>Return the total number of pages that have been allocated for this memory pool.</p><p><strong>Returns:</strong></p><p>number of pages allocated.</p>
<h3>void ost::MemPager::purge (void)\fC [protected]\fP</h3>
<p>purge the current memory pool.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Friends And Related Function Documentation</h2>
        <div class="sectioncontent">
<h3>friend class \fBMemPagerObject\fP\fC [friend]\fP</h3>

<h3>friend class \fBString\fP\fC [friend]\fP</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for GNU CommonC++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ost_MappedFile.3.html"><span aria-hidden="true">&larr;</span> ost_MappedFile.3: Create and map a disk file into memory.</a></li>
   <li class="next"><a href="ost_MemPagerObject.3.html">ost_MemPagerObject.3: This class is used to create derived classes which are constructed within a memory pager pool. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

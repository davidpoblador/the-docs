<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>std::unordered_map: Std::unordered_map _key, _tp, _hash, _pred, _alloc  -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Std::unordered_map _key, _tp, _hash, _pred, _alloc  -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="std::unordered_map (3cxx) manual">
  <meta name="twitter:description" content="Std::unordered_map _key, _tp, _hash, _pred, _alloc  -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libstdc++-4.9-doc-std::unordered_map-3cxx.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3cxx/libstdc++-4.9-doc-std::unordered_map.3cxx.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="std::unordered_map (3cxx) manual" />
  <meta property="og:description" content="Std::unordered_map _key, _tp, _hash, _pred, _alloc  -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libstdc++-4.9-doc-std::unordered_map-3cxx.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">std::unordered_map<small> (3cxx)</small></h1>
        <p class="lead">Std::unordered_map _key, _tp, _hash, _pred, _alloc  -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::unordered_map.3cxx.html">
      <span itemprop="name">std::unordered_map: Std::unordered_map _key, _tp, _hash, _pred, _alloc  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libstdc++-4.9-doc/">
      <span itemprop="name">libstdc++-4.9-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::unordered_map.3cxx.html">
      <span itemprop="name">std::unordered_map: Std::unordered_map _key, _tp, _hash, _pred, _alloc  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<h3>Public Types</h3>
<p><strong></strong></p><p>typedef _Hashtable::key_type <strong>key_type</strong></p><p>typedef _Hashtable::value_type <strong>value_type</strong></p><p>typedef _Hashtable::mapped_type <strong>mapped_type</strong></p><p>typedef _Hashtable::hasher <strong>hasher</strong></p><p>typedef _Hashtable::key_equal <strong>key_equal</strong></p><p>typedef _Hashtable::allocator_type <strong>allocator_type</strong></p><p><strong></strong></p><p>typedef _Hashtable::pointer <strong>pointer</strong></p><p>typedef _Hashtable::const_pointer <strong>const_pointer</strong></p><p>typedef _Hashtable::reference <strong>reference</strong></p><p>typedef _Hashtable::const_reference <strong>const_reference</strong></p><p>typedef <strong>_Hashtable::iterator</strong> <strong>iterator</strong></p><p>typedef <strong>_Hashtable::const_iterator</strong> <strong>const_iterator</strong></p><p>typedef <strong>_Hashtable::local_iterator</strong> <strong>local_iterator</strong></p><p>typedef</p><p><strong>_Hashtable::const_local_iterator</strong> <strong>const_local_iterator</strong>"</p><p>typedef _Hashtable::size_type <strong>size_type</strong></p><p>typedef _Hashtable::difference_type <strong>difference_type</strong></p>
<h3>Public Member Functions</h3>
<p><strong>unordered_map</strong> (<strong>size_type</strong> __n=10, const <strong>hasher</strong> &__hf=<strong>hasher</strong>(), const <strong>key_equal</strong> &__eql=<strong>key_equal</strong>(), const <strong>allocator_type</strong> &__a=<strong>allocator_type</strong>())</p><p>template&lt;typename _InputIterator &gt; <strong>unordered_map</strong> (_InputIterator __f, _InputIterator __l, <strong>size_type</strong> __n=0, const <strong>hasher</strong> &__hf=<strong>hasher</strong>(), const <strong>key_equal</strong> &__eql=<strong>key_equal</strong>(), const <strong>allocator_type</strong> &__a=<strong>allocator_type</strong>())</p><p><strong>unordered_map</strong> (const <strong>unordered_map</strong> &)=default</p><p><strong>unordered_map</strong> (<strong>unordered_map</strong> &&)=default</p><p><strong>unordered_map</strong> (const <strong>allocator_type</strong> &__a)</p><p><strong>unordered_map</strong> (const <strong>unordered_map</strong> &__umap, const <strong>allocator_type</strong> &__a)</p><p><strong>unordered_map</strong> (<strong>unordered_map</strong> &&__umap, const <strong>allocator_type</strong> &__a)</p><p><strong>unordered_map</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l, <strong>size_type</strong> __n=0, const <strong>hasher</strong> &__hf=<strong>hasher</strong>(), const <strong>key_equal</strong> &__eql=<strong>key_equal</strong>(), const <strong>allocator_type</strong> &__a=<strong>allocator_type</strong>())</p><p><strong>iterator</strong> <strong>begin</strong> () noexcept</p><p><strong>local_iterator</strong> <strong>begin</strong> (<strong>size_type</strong> __n)</p><p><strong>size_type</strong> <strong>bucket</strong> (const <strong>key_type</strong> &__key) const </p><p><strong>size_type</strong> <strong>bucket_count</strong> () const noexcept</p><p><strong>size_type</strong> <strong>bucket_size</strong> (<strong>size_type</strong> __n) const </p><p>void <strong>clear</strong> () noexcept</p><p><strong>size_type</strong> <strong>count</strong> (const <strong>key_type</strong> &__x) const </p><p>template&lt;typename... _Args&gt; <strong>std::pair</strong>&lt; <strong>iterator</strong>, bool &gt; <strong>emplace</strong> (_Args &&...__args)</p><p>template&lt;typename... _Args&gt; <strong>iterator</strong> <strong>emplace_hint</strong> (<strong>const_iterator</strong> __pos, _Args &&...__args)</p><p>bool <strong>empty</strong> () const noexcept</p><p><strong>iterator</strong> <strong>end</strong> () noexcept</p><p><strong>local_iterator</strong> <strong>end</strong> (<strong>size_type</strong> __n)</p><p><strong>size_type</strong> <strong>erase</strong> (const <strong>key_type</strong> &__x)</p><p><strong>iterator</strong> <strong>erase</strong> (<strong>const_iterator</strong> __first, <strong>const_iterator</strong> __last)</p><p><strong>allocator_type</strong> <strong>get_allocator</strong> () const noexcept</p><p><strong>hasher</strong> <strong>hash_function</strong> () const </p><p>template&lt;typename _InputIterator &gt; void <strong>insert</strong> (_InputIterator __first, _InputIterator __last)</p><p>void <strong>insert</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l)</p><p><strong>key_equal</strong> <strong>key_eq</strong> () const </p><p>float <strong>load_factor</strong> () const noexcept</p><p><strong>size_type</strong> <strong>max_bucket_count</strong> () const noexcept</p><p>float <strong>max_load_factor</strong> () const noexcept</p><p>void <strong>max_load_factor</strong> (float __z)</p><p><strong>size_type</strong> <strong>max_size</strong> () const noexcept</p><p><strong>unordered_map</strong> & <strong>operator=</strong> (const <strong>unordered_map</strong> &)=default</p><p><strong>unordered_map</strong> & <strong>operator=</strong> (<strong>unordered_map</strong> &&)=default</p><p><strong>unordered_map</strong> & <strong>operator=</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l)</p><p>void <strong>rehash</strong> (<strong>size_type</strong> __n)</p><p>void <strong>reserve</strong> (<strong>size_type</strong> __n)</p><p><strong>size_type</strong> <strong>size</strong> () const noexcept</p><p>void <strong>swap</strong> (<strong>unordered_map</strong> &__x) noexcept(noexcept(_M_h.swap(__x._M_h)))</p><p><strong></strong></p><p><strong>const_iterator</strong> <strong>begin</strong> () const noexcept</p><p><strong>const_iterator</strong> <strong>cbegin</strong> () const noexcept</p><p><strong></strong></p><p><strong>const_iterator</strong> <strong>end</strong> () const noexcept</p><p><strong>const_iterator</strong> <strong>cend</strong> () const noexcept</p><p><strong></strong></p><p><strong>std::pair</strong>&lt; <strong>iterator</strong>, bool &gt; <strong>insert</strong> (const <strong>value_type</strong> &__x)</p><p>template&lt;typename _Pair , typename  = typename std::enable_if&lt;std::is_constructible&lt;value_type,						    _Pair&&&gt;::value&gt;::type&gt; <strong>std::pair</strong>&lt; <strong>iterator</strong>, bool &gt; <strong>insert</strong> (_Pair &&__x)</p><p><strong></strong></p><p><strong>iterator</strong> <strong>insert</strong> (<strong>const_iterator</strong> __hint, const <strong>value_type</strong> &__x)</p><p>template&lt;typename _Pair , typename  = typename std::enable_if&lt;std::is_constructible&lt;value_type,						    _Pair&&&gt;::value&gt;::type&gt; <strong>iterator</strong> <strong>insert</strong> (<strong>const_iterator</strong> __hint, _Pair &&__x)</p><p><strong></strong></p><p><strong>iterator</strong> <strong>erase</strong> (<strong>const_iterator</strong> __position)</p><p><strong>iterator</strong> <strong>erase</strong> (<strong>iterator</strong> __it)</p><p><strong></strong></p><p><strong>iterator</strong> <strong>find</strong> (const <strong>key_type</strong> &__x)</p><p><strong>const_iterator</strong> <strong>find</strong> (const <strong>key_type</strong> &__x) const </p><p><strong></strong></p><p><strong>std::pair</strong>&lt; <strong>iterator</strong>, <strong>iterator</strong> &gt; <strong>equal_range</strong> (const <strong>key_type</strong> &__x)</p><p><strong>std::pair</strong>&lt; <strong>const_iterator</strong>,</p><p><strong>const_iterator</strong> &gt; <strong>equal_range</strong> (const <strong>key_type</strong> &__x) const "</p><p><strong></strong></p><p><strong>mapped_type</strong> & <strong>operator[]</strong> (const <strong>key_type</strong> &__k)</p><p><strong>mapped_type</strong> & <strong>operator[]</strong> (<strong>key_type</strong> &&__k)</p><p><strong></strong></p><p><strong>mapped_type</strong> & <strong>at</strong> (const <strong>key_type</strong> &__k)</p><p>const <strong>mapped_type</strong> & <strong>at</strong> (const <strong>key_type</strong> &__k) const </p><p><strong></strong></p><p><strong>const_local_iterator</strong> <strong>begin</strong> (<strong>size_type</strong> __n) const </p><p><strong>const_local_iterator</strong> <strong>cbegin</strong> (<strong>size_type</strong> __n) const </p><p><strong></strong></p><p><strong>const_local_iterator</strong> <strong>end</strong> (<strong>size_type</strong> __n) const </p><p><strong>const_local_iterator</strong> <strong>cend</strong> (<strong>size_type</strong> __n) const </p>
<h3>Friends</h3>
<p>template&lt;typename _Key1 , typename _Tp1 , typename _Hash1 , typename _Pred1 , typename _Alloc1 &gt; bool <strong>operator==</strong> (const <strong>unordered_map</strong>&lt; _Key1, _Tp1, _Hash1, _Pred1, _Alloc1 &gt; &, const <strong>unordered_map</strong>&lt; _Key1, _Tp1, _Hash1, _Pred1, _Alloc1 &gt; &)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<h3>template&lt;class _Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred = std::equal_to&lt;_Key&gt;, class _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;class std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;</h3>
<p>A standard container composed of unique keys (containing at most one of each key value) that associates values of another type with the keys.</p><p><strong>Template Parameters:</strong></p><p><em>_Key</em> Type of key objects.</p><p><em>_Tp</em> Type of mapped objects.</p><p><em>_Hash</em> Hashing function object type, defaults to hash&lt;_Value&gt;.</p><p><em>_Pred</em> Predicate function object type, defaults to equal_to&lt;_Value&gt;.</p><p><em>_Alloc</em> Allocator type, defaults to std::allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;.</p><p>Meets the requirements of a container, and unordered associative container</p><p>The resulting value type of the container is std::pair&lt;const _Key, _Tp&gt;.</p><p>Base is _Hashtable, dispatched at compile time via template alias __umap_hashtable.</p><p>Definition at line 98 of file unordered_map.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::allocator_type \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBallocator_type\fP</h3>
<p>Public typedefs.</p><p>Definition at line 112 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef \fB_Hashtable::const_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBconst_iterator\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 122 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef \fB_Hashtable::const_local_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBconst_local_iterator\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 124 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::const_pointer \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBconst_pointer\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 118 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::const_reference \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBconst_reference\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 120 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::difference_type \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBdifference_type\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 126 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::hasher \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBhasher\fP</h3>
<p>Public typedefs.</p><p>Definition at line 110 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef \fB_Hashtable::iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBiterator\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 121 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::key_equal \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBkey_equal\fP</h3>
<p>Public typedefs.</p><p>Definition at line 111 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::key_type \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBkey_type\fP</h3>
<p>Public typedefs.</p><p>Definition at line 107 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef \fB_Hashtable::local_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBlocal_iterator\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 123 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::mapped_type \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBmapped_type\fP</h3>
<p>Public typedefs.</p><p>Definition at line 109 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::pointer \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBpointer\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 117 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::reference \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBreference\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 119 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::size_type \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBsize_type\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 125 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; typedef _Hashtable::value_type \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBvalue_type\fP</h3>
<p>Public typedefs.</p><p>Definition at line 108 of file unordered_map.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBunordered_map\fP (\fBsize_type\fP__n = \fC10\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP, \fC [explicit]\fP</h3>
<p>Default constructor creates no elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> Initial number of buckets.</p><p><em>__hf</em> A hash functor.</p><p><em>__eql</em> A key equality functor.</p><p><em>__a</em> An allocator object.</p><p>Definition at line 139 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename _InputIterator &gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBunordered_map\fP (_InputIterator__f, _InputIterator__l, \fBsize_type\fP__n = \fC0\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP</h3>
<p>Builds an unordered_map from a range.</p><p><strong>Parameters:</strong></p><p><em>__first</em> An input iterator.</p><p><em>__last</em> An input iterator.</p><p><em>__n</em> Minimal initial number of buckets.</p><p><em>__hf</em> A hash functor.</p><p><em>__eql</em> A key equality functor.</p><p><em>__a</em> An allocator object.</p><p>Create an unordered_map consisting of copies of the elements from [__first,__last). This is linear in N (where N is distance(__first,__last)).</p><p>Definition at line 160 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBunordered_map\fP (const \fBunordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &)\fC [default]\fP</h3>
<p>Copy constructor.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBunordered_map\fP (\fBunordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &&)\fC [default]\fP</h3>
<p>Move constructor.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBunordered_map\fP (const \fBallocator_type\fP &__a)\fC [inline]\fP, \fC [explicit]\fP</h3>
<p>Creates an unordered_map with no elements.</p><p><strong>Parameters:</strong></p><p><em>__a</em> An allocator object.</p><p>Definition at line 179 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::\fBunordered_map\fP (initializer_list&lt; \fBvalue_type\fP &gt;__l, \fBsize_type\fP__n = \fC0\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP</h3>
<p>Builds an unordered_map from an initializer_list.</p><p><strong>Parameters:</strong></p><p><em>__l</em> An initializer_list.</p><p><em>__n</em> Minimal initial number of buckets.</p><p><em>__hf</em> A hash functor.</p><p><em>__eql</em> A key equality functor.</p><p><em>__a</em> An allocator object.</p><p>Create an unordered_map consisting of copies of the elements in the list. This is linear in N (where N is <em>__l.size()</em>).</p><p>Definition at line 214 of file unordered_map.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBmapped_type\fP& \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::at (const \fBkey_type\fP &__k)\fC [inline]\fP</h3>
<p>Access to unordered_map data.</p><p><strong>Parameters:</strong></p><p><em>__k</em> The key for which data should be retrieved.</p><p><strong>Returns:</strong></p><p>A reference to the data whose key is equal to <em>__k</em>, if such a data is present in the unordered_map.</p><p><strong>Exceptions:</strong></p><p><em>std::out_of_range</em> If no such data is present.</p><p>Definition at line 643 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; const \fBmapped_type\fP& \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::at (const \fBkey_type\fP &__k) const\fC [inline]\fP</h3>
<p>Access to unordered_map data.</p><p><strong>Parameters:</strong></p><p><em>__k</em> The key for which data should be retrieved.</p><p><strong>Returns:</strong></p><p>A reference to the data whose key is equal to <em>__k</em>, if such a data is present in the unordered_map.</p><p><strong>Exceptions:</strong></p><p><em>std::out_of_range</em> If no such data is present.</p><p>Definition at line 647 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::begin ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read/write iterator that points to the first element in the unordered_map.</p><p>Definition at line 278 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::begin () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_map.</p><p>Definition at line 287 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBlocal_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::begin (\fBsize_type\fP__n)\fC [inline]\fP</h3>
<p>Returns a read/write iterator pointing to the first bucket element.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read/write local iterator.</p><p>Definition at line 688 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_local_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::begin (\fBsize_type\fP__n) const\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to the first bucket element.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 699 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBsize_type\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::bucket_count () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the number of buckets of the unordered_map.</p><p>Definition at line 655 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_map.</p><p>Definition at line 291 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_local_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cbegin (\fBsize_type\fP__n) const\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to the first bucket element.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 703 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cend () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_map.</p><p>Definition at line 313 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_local_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cend (\fBsize_type\fP__n) const\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 729 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::clear ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Erases all elements in an unordered_map. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 527 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBsize_type\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::count (const \fBkey_type\fP &__x) const\fC [inline]\fP</h3>
<p>Finds the number of elements.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key to count.</p><p><strong>Returns:</strong></p><p>Number of elements with specified key.</p><p>This function only makes sense for unordered_multimap; for unordered_map the result will either be 0 (not present) or 1 (present).</p><p>Definition at line 591 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename... _Args&gt; \fBstd::pair\fP&lt;\fBiterator\fP, bool&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::emplace (_Args &&...__args)\fC [inline]\fP</h3>
<p>Attempts to build and insert a std::pair into the unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__args</em> Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor).</p><p><strong>Returns:</strong></p><p>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</p><p>This function attempts to build and insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 340 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename... _Args&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::emplace_hint (\fBconst_iterator\fP__pos, _Args &&...__args)\fC [inline]\fP</h3>
<p>Attempts to build and insert a std::pair into the unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__pos</em> An iterator that serves as a hint as to where the pair should be inserted.</p><p><em>__args</em> Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor).</p><p><strong>Returns:</strong></p><p>An iterator that points to the element with key of the std::pair built from <em>__args</em> (may or may not be that std::pair).</p><p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument emplace() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p><p>See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html for more on <em>hinting</em>.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 370 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; bool \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::empty () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns true if the unordered_map is empty.</p><p>Definition at line 258 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read/write iterator that points one past the last element in the unordered_map.</p><p>Definition at line 300 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_map.</p><p>Definition at line 309 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBlocal_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end (\fBsize_type\fP__n)\fC [inline]\fP</h3>
<p>Returns a read/write iterator pointing to one past the last bucket elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read/write local iterator.</p><p>Definition at line 714 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_local_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end (\fBsize_type\fP__n) const\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 725 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::pair\fP&lt;\fBiterator\fP, \fBiterator\fP&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range (const \fBkey_type\fP &__x)\fC [inline]\fP</h3>
<p>Finds a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key to be located.</p><p><strong>Returns:</strong></p><p>Pair of iterators that possibly points to the subsequence matching given key.</p><p>This function probably only makes sense for unordered_multimap.</p><p>Definition at line 604 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::pair\fP&lt;\fBconst_iterator\fP, \fBconst_iterator\fP&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range (const \fBkey_type\fP &__x) const\fC [inline]\fP</h3>
<p>Finds a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key to be located.</p><p><strong>Returns:</strong></p><p>Pair of iterators that possibly points to the subsequence matching given key.</p><p>This function probably only makes sense for unordered_multimap.</p><p>Definition at line 608 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::erase (\fBconst_iterator\fP__position)\fC [inline]\fP</h3>
<p>Erases an element from an unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator pointing to the element to be erased.</p><p><strong>Returns:</strong></p><p>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</p><p>This function erases an element, pointed to by the given iterator, from an unordered_map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 477 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::erase (\fBiterator\fP__it)\fC [inline]\fP</h3>
<p>Erases an element from an unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator pointing to the element to be erased.</p><p><strong>Returns:</strong></p><p>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</p><p>This function erases an element, pointed to by the given iterator, from an unordered_map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 482 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBsize_type\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::erase (const \fBkey_type\fP &__x)\fC [inline]\fP</h3>
<p>Erases elements according to the provided key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of element to be erased.</p><p><strong>Returns:</strong></p><p>The number of elements erased.</p><p>This function erases all the elements located by the given key from an unordered_map. For an unordered_map the result of this function can only be 0 (not present) or 1 (present). Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 499 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::erase (\fBconst_iterator\fP__first, \fBconst_iterator\fP__last)\fC [inline]\fP</h3>
<p>Erases a [__first,__last) range of elements from an unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__first</em> Iterator pointing to the start of the range to be erased.</p><p><em>__last</em> Iterator pointing to the end of the range to be erased.</p><p><strong>Returns:</strong></p><p>The iterator <em>__last</em>.</p><p>This function erases a sequence of elements from an unordered_map. Note that this function only erases the elements, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 517 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::find (const \fBkey_type\fP &__x)\fC [inline]\fP</h3>
<p>Tries to locate an element in an unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key to be located.</p><p><strong>Returns:</strong></p><p>Iterator pointing to sought-after element, or end() if not found.</p><p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( end() ) iterator.</p><p>Definition at line 573 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBconst_iterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::find (const \fBkey_type\fP &__x) const\fC [inline]\fP</h3>
<p>Tries to locate an element in an unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key to be located.</p><p><strong>Returns:</strong></p><p>Iterator pointing to sought-after element, or end() if not found.</p><p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( end() ) iterator.</p><p>Definition at line 577 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBallocator_type\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::get_allocator () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the allocator object with which the unordered_map was constructed.</p><p>Definition at line 251 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBhasher\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::hash_function () const\fC [inline]\fP</h3>
<p>Returns the hash functor object with which the unordered_map was constructed.</p><p>Definition at line 549 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBstd::pair\fP&lt;\fBiterator\fP, bool&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert (const \fBvalue_type\fP &__x)\fC [inline]\fP</h3>
<p>Attempts to insert a std::pair into the unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Pair to be inserted (see std::make_pair for easy creation of pairs).</p><p><strong>Returns:</strong></p><p>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</p><p>This function attempts to insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 392 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename _Pair , typename  = typename std::enable_if&lt;std::is_constructible&lt;value_type,						    _Pair&&&gt;::value&gt;::type&gt; \fBstd::pair\fP&lt;\fBiterator\fP, bool&gt; \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert (_Pair &&__x)\fC [inline]\fP</h3>
<p>Attempts to insert a std::pair into the unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Pair to be inserted (see std::make_pair for easy creation of pairs).</p><p><strong>Returns:</strong></p><p>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</p><p>This function attempts to insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 399 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert (\fBconst_iterator\fP__hint, const \fBvalue_type\fP &__x)\fC [inline]\fP</h3>
<p>Attempts to insert a std::pair into the unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__hint</em> An iterator that serves as a hint as to where the pair should be inserted.</p><p><em>__x</em> Pair to be inserted (see std::make_pair for easy creation of pairs).</p><p><strong>Returns:</strong></p><p>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</p><p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p><p>See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html for more on <em>hinting</em>.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 426 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename _Pair , typename  = typename std::enable_if&lt;std::is_constructible&lt;value_type,						    _Pair&&&gt;::value&gt;::type&gt; \fBiterator\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert (\fBconst_iterator\fP__hint, _Pair &&__x)\fC [inline]\fP</h3>
<p>Attempts to insert a std::pair into the unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__hint</em> An iterator that serves as a hint as to where the pair should be inserted.</p><p><em>__x</em> Pair to be inserted (see std::make_pair for easy creation of pairs).</p><p><strong>Returns:</strong></p><p>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</p><p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p><p>See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html for more on <em>hinting</em>.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 433 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; template&lt;typename _InputIterator &gt; void \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert (_InputIterator__first, _InputIterator__last)\fC [inline]\fP</h3>
<p>A template function that attempts to insert a range of elements.</p><p><strong>Parameters:</strong></p><p><em>__first</em> Iterator pointing to the start of the range to be inserted.</p><p><em>__last</em> Iterator pointing to the end of the range.</p><p>Complexity similar to that of the range constructor.</p><p>Definition at line 448 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert (initializer_list&lt; \fBvalue_type\fP &gt;__l)\fC [inline]\fP</h3>
<p>Attempts to insert a list of elements into the unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__l</em> A std::initializer_list&lt;value_type&gt; of elements to be inserted.</p><p>Complexity similar to that of the range constructor.</p><p>Definition at line 459 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBkey_equal\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::key_eq () const\fC [inline]\fP</h3>
<p>Returns the key comparison object with which the unordered_map was constructed.</p><p>Definition at line 555 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; float \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::load_factor () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the average number of elements per bucket.</p><p>Definition at line 737 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBsize_type\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::max_bucket_count () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the maximum number of buckets of the unordered_map.</p><p>Definition at line 660 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; float \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::max_load_factor () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a positive number that the unordered_map tries to keep the load factor less than or equal to.</p><p>Definition at line 743 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::max_load_factor (float__z)\fC [inline]\fP</h3>
<p>Change the unordered_map maximum load factor.</p><p><strong>Parameters:</strong></p><p><em>__z</em> The new maximum load factor.</p><p>Definition at line 751 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBsize_type\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::max_size () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the maximum size of the unordered_map.</p><p>Definition at line 268 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBunordered_map\fP& \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator= (const \fBunordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &)\fC [default]\fP</h3>
<p>Copy assignment operator.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBunordered_map\fP& \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator= (\fBunordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &&)\fC [default]\fP</h3>
<p>Move assignment operator.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBunordered_map\fP& \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator= (initializer_list&lt; \fBvalue_type\fP &gt;__l)\fC [inline]\fP</h3>
<p>Unordered_map list assignment operator.</p><p><strong>Parameters:</strong></p><p><em>__l</em> An initializer_list.</p><p>This function fills an unordered_map with copies of the elements in the initializer list <em>__l</em>.</p><p>Note that the assignment completely changes the unordered_map and that the resulting unordered_map's size is the same as the number of elements assigned. Old data may be lost.</p><p>Definition at line 242 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBmapped_type\fP& \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator[] (const \fBkey_type\fP &__k)\fC [inline]\fP</h3>
<p>Subscript ( [] ) access to unordered_map data.</p><p><strong>Parameters:</strong></p><p><em>__k</em> The key for which data should be retrieved.</p><p><strong>Returns:</strong></p><p>A reference to the data of the (key,data) pair.</p><p>Allows for easy lookup with the subscript ( [] )operator. Returns data associated with the key specified in subscript. If the key does not exist, a pair with that key is created using default values, which is then returned.</p><p>Lookup requires constant time.</p><p>Definition at line 626 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBmapped_type\fP& \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator[] (\fBkey_type\fP &&__k)\fC [inline]\fP</h3>
<p>Subscript ( [] ) access to unordered_map data.</p><p><strong>Parameters:</strong></p><p><em>__k</em> The key for which data should be retrieved.</p><p><strong>Returns:</strong></p><p>A reference to the data of the (key,data) pair.</p><p>Allows for easy lookup with the subscript ( [] )operator. Returns data associated with the key specified in subscript. If the key does not exist, a pair with that key is created using default values, which is then returned.</p><p>Lookup requires constant time.</p><p>Definition at line 630 of file unordered_map.h.</p><p>References std::move().</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::rehash (\fBsize_type\fP__n)\fC [inline]\fP</h3>
<p>May rehash the unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The new number of buckets.</p><p>Rehash will occur only if the new number of buckets respect the unordered_map maximum load factor.</p><p>Definition at line 762 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::reserve (\fBsize_type\fP__n)\fC [inline]\fP</h3>
<p>Prepare the unordered_map for a specified number of elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> Number of elements required.</p><p>Same as rehash(ceil(n / max_load_factor())).</p><p>Definition at line 773 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; \fBsize_type\fP \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::size () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the size of the unordered_map.</p><p>Definition at line 263 of file unordered_map.h.</p>
<h3>template&lt;class _Key , class _Tp , class _Hash  = hash&lt;_Key&gt;, class _Pred  = std::equal_to&lt;_Key&gt;, class _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; void \fBstd::unordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::swap (\fBunordered_map\fP&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &__x)\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Swaps data with another unordered_map.</p><p><strong>Parameters:</strong></p><p><em>__x</em> An unordered_map of the same element and allocator types.</p><p>This exchanges the elements between two unordered_map in constant time. Note that the global std::swap() function is specialized such that std::swap(m1,m2) will feed to this function.</p><p>Definition at line 540 of file unordered_map.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for libstdc++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libstdc++-4.8-doc-std::unordered_map.3cxx.html"><span aria-hidden="true">&larr;</span> std::unordered_map.3cxx: Std::unordered_map _key, _tp, _hash, _pred, _alloc  -</a></li>
   <li class="next"><a href="libstdc++-4.8-doc-std::unordered_multimap.3cxx.html">std::unordered_multimap.3cxx: Std::unordered_multimap _key, _tp, _hash, _pred, _alloc  - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

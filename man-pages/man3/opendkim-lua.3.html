<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>opendkim-lua: Programming the opendkim filter using lua scripts</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Programming the opendkim filter using lua scripts">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="opendkim-lua (3) manual">
  <meta name="twitter:description" content="Programming the opendkim filter using lua scripts">
  <meta name="twitter:image" content="https://www.carta.tech/images/opendkim-opendkim-lua-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/opendkim-lua.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="opendkim-lua (3) manual" />
  <meta property="og:description" content="Programming the opendkim filter using lua scripts" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/opendkim-opendkim-lua-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">opendkim-lua<small> (3)</small></h1>
        <p class="lead">Programming the opendkim filter using lua scripts</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/opendkim-lua.3.html">
      <span itemprop="name">opendkim-lua: Programming the opendkim filter using lua scripts</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/opendkim/">
      <span itemprop="name">opendkim</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/opendkim-lua.3.html">
      <span itemprop="name">opendkim-lua: Programming the opendkim filter using lua scripts</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The OpenDKIM filter has hooks to run user-provided scripts for making policy decisions regarding signatures to add on outbound messages or verification and acceptance of messages inbound.  The hooks take the form of multiple Lua scripts which, if defined, are run at important points during processing of a message.</p><p>For a full description of the Lua language, consult Lua programming references (see below for a starting point).  This man page only describes the use of Lua in the context of OpenDKIM, specifically the functions and global variables OpenDKIM provides for use in user-constructed scripts beyond what Lua provides by default.</p><p>Unless otherwise noted, all functions described below return a single result; on success they return the requested data, and on error they return the Lua constant "nil".</p><p>Four scripting hooks are provided.  They are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>setup</em></p>
  </dt>
  <dd>
    <p>The setup script is run after all headers for the message have been received but before any DKIM operations have started.  At this point the user can examine the available header fields to decide whether the message should be signed or verified (or both) and, if signing, which key(s) should be used to add signatures and which signature features are desired.</p>
  </dd>
  <dt>
    <p><em>screen</em></p>
  </dt>
  <dd>
    <p>The screen script is run after the DKIM verification context has been established.  The main purpose of this script is to give the user an opportunity to examine the message header fields compared to the available DKIM signatures and determine which, if any, should be ignored during verification.  For example, the user might decide only signatures added by domains exactly matching that in the From: domain are acceptable, and the rest should be ignored.</p>
  </dd>
  <dt>
    <p><em>statistics</em></p>
  </dt>
  <dd>
    <p>The statistics script is run after all of the DKIM verification and signing work has been completed but before any final message handling is done. The main purpose of this script is to give the user an opportunity to examine the message or its signatures and make arbitrary additional statistical observations that should be recorded by the statistics module. (Experimental feature not enabled for this installation.)</p>
  </dd>
  <dt>
    <p><em>final</em></p>
  </dt>
  <dd>
    <p>The final script is run after all of the DKIM verification and signing work has been completed.  The user has an opportunity to examine the results of all of the signature evaluations and make a decision about whether or not the message should be accepted, rejected, discarded, quarantined, etc. If the message is accepted, any signatures requested earlier will be added to the messages before it is released.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GLOBAL VARIABLES</h2>
        <div class="sectioncontent">
<p>The following global variable(s) are provided for all user scripts:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>ctx</em></p>
  </dt>
  <dd>
    <p>This is a generic context pointer referring to the context in which the filtering operation is being performed.  It represents a single message in progress, and the connection that accepted it.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SETUP SCRIPT FUNCTIONS</h2>
        <div class="sectioncontent">
<p>These functions are made available to Lua for processing a message through the setup script:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>odkim.check_popauth(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns 1 if the SMTP client represented by <em>ctx</em> is coming from an IP address found in the POPAUTH database (if enabled and configured), and 0 otherwise.  Returns the Lua constant "nil" if the POPAUTH database is not enabled or not configured.</p>
  </dd>
  <dt>
    <p><strong>odkim.db_check(db, string)</strong></p>
  </dt>
  <dd>
    <p>Returns 1 if <em>db</em> refers to a valid database handle (see <strong>odkim.get_dbhandle()</strong> below) and <em>string</em> is found in that database, and 0 otherwise.  If an error occurs, the Lua constant "nil" is returned.</p>
  </dd>
  <dt>
    <p><strong>odkim.db_close(db)</strong></p>
  </dt>
  <dd>
    <p>Closes the specified data set.  Returns 1.  The current implementation will conduct data set garbage collection when the script terminates, so this is not strictly necessary, but is recommended.</p>
  </dd>
  <dt>
    <p><strong>odkim.db_open(name[, icase])</strong></p>
  </dt>
  <dd>
    <p>Opens the data set specified by <em>name.</em> If <em>icase</em> is provided and is "true", then queries into the database will be case-insensitive.  See the <a href="../man8/opendkim.8.html"><strong>opendkim</strong>(8)</a></em> man page for information on specifying a data set.  On success, returns a handle that can be passed to <strong>odkim.db_check();</strong> raises an exception on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.export(ctx, name, value[, name2, value2[, ...]])</strong></p>
  </dt>
  <dd>
    <p>Exports variables named with their corresponding values so that they will be available to later scripts.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_clienthost(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns the name of the host on the other end of the SMTP connection sending the current message.  This is usually a hostname, but might be an IP address in square brackets if the SMTP client's IP address does not have a name associated with it.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_clientip(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns the IP address of the client on the other end of the SMTP connection sending the current message as a string.  Both IPv4 and IPv6 addresses are supported.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_dbhandle(ctx, db)</strong></p>
  </dt>
  <dd>
    <p>Returns a handle for the requested database that can be used in later queries.  The value of <em>db</em> should be one of <em>DB_MTAS</em> (database of MTA names whose mail should be signed), <em>DB_MACROS</em> (database of MTA macro checks to be done when determining signing), <em>DB_DOMAINS</em> (database of domains to be signed), <em>DB_LOCALADSP</em> (database of local ADSP overrides), <em>DB_SIGNINGTABLE</em> (database of signing table entries), <em>DB_THIRDPARTY</em> (database of third party signatures to be trusted) and <em>DB_DONTSIGNTO</em> (database of recipients whose mail should not be signed).  If the requested database is not set in the current configuration file, a Lua "nil" is returned.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_envfrom(ctx)</strong></p>
  </dt>
  <dd>
    <p>Retrieves the SMTP envelope sender address for the message represented by <em>ctx.</em></p>
  </dd>
  <dt>
    <p><strong>odkim.get_fromdomain(ctx)</strong></p>
  </dt>
  <dd>
    <p>Retrieves the domain name of the sender of the message represented by <em>ctx.</em></p>
  </dd>
  <dt>
    <p><strong>odkim.get_header(ctx, name, n)</strong></p>
  </dt>
  <dd>
    <p>Retrieves the string contained in instance <em>n</em> of the header field called <em>name</em> from the message represented by <em>ctx,</em> or the Lua constant "nil" if there was no such header field. Header field numbering starts at 0, so use 0 for the first instance, 1 for the second, etc.  For example:</p><p>fromaddr = odkim.get_header(ctx, "From", 0)</p><p>This will return the value of the first (and hopefully only) "From" header field.  Negative values of <em>n</em> count backwards from the end of the set of header fields, so:</p><p>rcvd = odkim.get_header(ctx, "Received", -2)</p><p>will retrieve the second-last Received: header field on the message.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_mtasymbol(ctx, name)</strong></p>
  </dt>
  <dd>
    <p>Retrieves the value of the symbol called <em>name</em> from the MTA connection represented by <em>ctx,</em> or the Lua constant "nil" if the requested symbol was not available at the time of the request.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_rcpt(ctx, n)</strong></p>
  </dt>
  <dd>
    <p>Returns the <em>nth</em> envelope recipient for the message represented by <em>ctx.</em> Recipient numbering starts at 0, so for the first recipient, use 0 for <em>n.</em> If <em>n</em> references an out-of-range value, the Lua constant "nil" is returned.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_rcptarray(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns the envelope recipients for the message represented by <em>ctx</em> in a single Lua array.</p>
  </dd>
  <dt>
    <p><strong>odkim.internal_ip(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns 1 if the SMTP client is coming from an internal IP address, and 0 otherwise.</p>
  </dd>
  <dt>
    <p><strong>odkim.log(ctx, log)</strong></p>
  </dt>
  <dd>
    <p>Logs the string <em>log</em> if the current configuration requested logging.  (Checking current configuration is why the <em>ctx</em> parameter is required.)</p>
  </dd>
  <dt>
    <p><strong>odkim.rcpt_count(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns the count of envelope recipients on the message.</p>
  </dd>
  <dt>
    <p><strong>odkim.replace_header(ctx, name, n, newval)</strong></p>
  </dt>
  <dd>
    <p>Retrieves the value of in instance <em>n</em> of header field <em>name</em> in the message referenced by <em>ctx</em> and replaces it with the string in <em>newval.</em> See <em>odkim.get_header()</em> above for more information about possible parameter values for <em>n.</em> Note that this only changes the content of the header field used when generating or verifying the signature; the actual delivered message is not modified.  This can be used to anticipate how an intermediate mail transfer agent might alter the message, thus correcting an avoidable signature invalidation.</p>
  </dd>
  <dt>
    <p><strong>odkim.resign(ctx)</strong></p>
  </dt>
  <dd>
    <p>Arranges that the arriving message will be verified and then re-signed in a single operation.  Returns 1 on success or the Lua constant "nil" on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.set_result(ctx, result)</strong></p>
  </dt>
  <dd>
    <p>Arranges to have the MTA return a specific result code in response to the message represented by <em>ctx.</em> The value of <em>result</em> must be one of <em>SMFIS_TEMPFAIL</em> (temporary failure/rejection), <em>SMFIS_ACCEPT</em> (accept without further processing), <em>SMFIS_DISCARD</em> (accept but discard the message) and <em>SMFIS_REJECT</em> (permanent failure/rejection).  Returns 1 on success or the Lua constant "nil" on failure.  Note that returning any of these codes indicates a final message disposition; the MTA will be told immediately to take the specified action, and no further filter processing will occur.</p>
  </dd>
  <dt>
    <p><strong>odkim.sign(ctx[, keyname[, signer[, signlen]]])</strong></p>
  </dt>
  <dd>
    <p>Requests that the filter sign the message represented by <em>ctx</em> using the specified <em>keyname.</em> The key name will be translated into an actual domain, selector and private key via a query to the KeyTable (see the <a href="../man5/opendkim.conf.5.html"><strong>opendkim.conf</strong>(5)</a></em> page for details).  The <em>keyname</em> may be omitted if the KeyTable is not defined, meaning the single signing domain, selector and key should be used to sign.  Returns 1 on success and 0 on failure.  If a <em>signer</em> is specified, the string there will be included in the generated signature's "i=" tag.  If a <em>signlen</em> is specified, the signature will cover that many bytes of the message body. The order of these last two parameters is interchangeable.</p>
  </dd>
  <dt>
    <p><strong>odkim.signfor(ctx, address[, multi])</strong></p>
  </dt>
  <dd>
    <p>Applies whatever signatures would be applied by default if the candidate message had the specified <em>address</em> in the message's From: field.  The <em>multi</em> parameter, if "true" (default is "false"), allows the application of multiple signatures.  Returns the number of signatures applied, which may be zero.</p>
  </dd>
  <dt>
    <p><strong>odkim.spam(ctx)</strong></p>
  </dt>
  <dd>
    <p>Tags the message as spam, for use in developing reputation about domains that signed the message.  Returns nothing. (Experimental feature not enabled for this installation.)</p>
  </dd>
  <dt>
    <p><strong>odkim.use_ltag(ctx)</strong></p>
  </dt>
  <dd>
    <p>Requests that all signatures added to the message represented by <em>ctx</em> include "l=" (body length) tags.  Always returns the Lua constant "nil".</p>
  </dd>
  <dt>
    <p><strong>odkim.verify(ctx)</strong></p>
  </dt>
  <dd>
    <p>Requests that the message represented by <em>ctx</em> be subjected to DKIM signature verification.  Returns the Lua constant "nil" on success, or an error string on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.xtag(ctx, tag, value)</strong></p>
  </dt>
  <dd>
    <p>Requests that all signatures added to the message represented by <em>ctx</em> include the named extension <em>tag</em> and <em>value.</em> Returns the number of signatures successfully modified, or -1 on error. An error can occur if the named tag is one already explicitly supported by the DKIM library, or if there is a syntax error in the tag or value.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SCREEN SCRIPT FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The screen script has the following functions available to it, whose descriptions can be found above: <strong>odkim.db_check,</strong> <strong>odkim.db_close,</strong> <strong>odkim.db_open,</strong> <strong>odkim.export,</strong> <strong>odkim.get_dbhandle,</strong> <strong>odkim.get_envfrom,</strong> <strong>odkim.get_fromdomain,</strong> <strong>odkim.get_header,</strong> <strong>odkim.get_mtasymbol,</strong> <strong>odkim.get_rcpt,</strong> <strong>odkim.get_rcptarray,</strong> <strong>odkim.log,</strong> <strong>odkim.rcpt_count,</strong> and <strong>odkim.spam.</strong></p><p>The following additional functions are provided for this script:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>odkim.get_sigarray(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns the complete set of signature handles found in the message represented by <em>ctx,</em> as a Lua array, or the Lua constant "nil" in case of an error.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_sigcount(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns the number of signatures found in the message represented by <em>ctx,</em> or the Lua constant "nil" in case of an error.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_sighandle(ctx, n)</strong></p>
  </dt>
  <dd>
    <p>Returns a handle representing an internal copy of the <em>nth</em> signature found on the message represented by <em>ctx.</em> <em>n</em> must be a number greater than or equal to zero (representing the first signature) and less than the number of signatures on the message, which can be determined using <strong>odkim.get_sigcount</strong> above.  The requested handle is returned on success, or the Lua constant "nil" is returned on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.parse_field(string)</strong></p>
  </dt>
  <dd>
    <p>Parses the contents of a header field, provided as <em>string,</em> into user and domain parts, discarding whitespace and comment components. Returns two strings, the user part and the domain part, or the Lua constant "nil" in case of a parsing error.</p>
  </dd>
  <dt>
    <p><strong>odkim.sig_getdomain(sig)</strong></p>
  </dt>
  <dd>
    <p>Returns the name of the domain in the signature handle specified by <em>sig,</em> previously returned by a call to <strong>odkim.get_sighandle().</strong> This is taken from the signature's "d=" tag.</p>
  </dd>
  <dt>
    <p><strong>odkim.sig_getidentity(sig)</strong></p>
  </dt>
  <dd>
    <p>Returns the identity of the agent adding the signature handle specified by <em>sig,</em> previously returned by a call to <strong>odkim.get_sighandle().</strong> This is taken from the signature's "i=" tag.  This may be a default value and not one that was explicitly part of the signature.  If the identity could not be determined, the Lua constant "nil" is returned.</p>
  </dd>
  <dt>
    <p><strong>odkim.sig_ignore(sig)</strong></p>
  </dt>
  <dd>
    <p>Instructs the verification code to ignore completely the signature specified by <em>sig,</em> previously returned by a call to <strong>odkim.get_sighandle().</strong> Any pending verification of the message will act as if that signature was not present on the message.  Always returns the Lua constant "nil".</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STATISTICS SCRIPT FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The statistics script has the following functions available to it, whose descriptions can be found above: <strong>odkim.export,</strong> <strong>odkim.get_envfrom,</strong> <strong>odkim.get_header,</strong> <strong>odkim.get_mtasymbol,</strong> <strong>odkim.get_rcpt,</strong> <strong>odkim.get_rcptarray,</strong> <strong>odkim.get_sigarray,</strong> <strong>odkim.get_sigcount,</strong> <strong>odkim.get_sighandle,</strong> <strong>odkim.log,</strong> <strong>odkim.parse_field,</strong> <strong>odkim.rcpt_count,</strong> <strong>odkim.sig_getdomain,</strong> <strong>odkim.sig_getidentity,</strong> and <strong>odkim.spam.</strong></p><p>The following functions are also available, defined in the next section: <strong>odkim.get_policy,</strong> <strong>odkim.rbl_check,</strong> <strong>odkim.rcpt_count,</strong> <strong>odkim.sig_bhresult,</strong> <strong>odkim.sig_bodylength,</strong> <strong>odkim.sig_canonlength,</strong> and <strong>odkim.sig_result.</strong></p><p>The following additional function is provided for this script:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>odkim.stats(ctx, name, value)</strong></p>
  </dt>
  <dd>
    <p>Records the additional statistic called <em>name</em> with its associated <em>value</em> for the message represented by <em>ctx.</em></p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FINAL SCRIPT FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The final script has the following functions available to it, whose descriptions can be found above: <strong>odkim.get_clienthost,</strong> <strong>odkim.get_clientip,</strong> <strong>odkim.get_envfrom,</strong> <strong>odkim.get_fromdomain,</strong> <strong>odkim.get_header,</strong> <strong>odkim.get_mtasymbol,</strong> <strong>odkim.get_rcpt,</strong> <strong>odkim.get_rcptarray,</strong> <strong>odkim.get_sigarray,</strong> <strong>odkim.get_sigcount,</strong> <strong>odkim.get_sighandle,</strong> <strong>odkim.log,</strong> <strong>odkim.parse_field,</strong> <strong>odkim.rcpt_count,</strong> <strong>odkim.set_result,</strong> <strong>odkim.sig_getdomain,</strong> <strong>odkim.sig_getidentity,</strong> <strong>odkim.spam,</strong> and <strong>odkim.xtags.</strong></p><p>The following additional functions are provided for this script:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>odkim.add_header(ctx, name, value)</strong></p>
  </dt>
  <dd>
    <p>Adds a new header field called <em>name</em> with the specified <em>value</em> to the message represented by <em>ctx.</em> Returns 1 on success, or the Lua constant "nil" on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.add_rcpt(ctx, addr)</strong></p>
  </dt>
  <dd>
    <p>Adds <em>addr</em> as an envelope recipient to the message represented by <em>ctx.</em> Returns 1 on success, or the Lua constant "nil" on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.del_header(ctx, name, n)</strong></p>
  </dt>
  <dd>
    <p>Deletes the <em>nth</em> instance (starting from 0) of the header field called <em>name</em> from the message represented by <em>ctx.</em> Returns 1 on success, or the Lua constant "nil" on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.del_rcpt(ctx, addr)</strong></p>
  </dt>
  <dd>
    <p>Deletes <em>addr</em> from the list of envelope recipients on the message represented by <em>ctx,</em> and adds a new X-Original-Recipient: header field containing the deleted address.  Returns 1 on success, or the Lua constant "nil" on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.get_policy(ctx)</strong></p>
  </dt>
  <dd>
    <p>Returns the discovered Author Domain Signing Practices (ADSP) policy, if one was published and could be retrieved, or a code indicating what other result was observed.  The value will be one of <em>DKIMF_POLICY_UNKNOWN,</em> <em>DKIMF_POLICY_ALL</em> and <em>DKIMF_POLICY_DISCARDABLE,</em> representing the corresponding ADSP result when a query was made and a result returned, or <em>DKIMF_POLICY_NXDOMAIN</em> if the author domain (based on the "From:" header field) does not appear to exist, or <em>DKIMF_POLICY_NONE</em> if no query was done because a valid author domain signature was found on the message, or the Lua constant "nil" in case of some other error.</p>
  </dd>
  <dt>
    <p><strong>odkim.quarantine(ctx, reason)</strong></p>
  </dt>
  <dd>
    <p>Asks the MTA to quarantine the message represented by <em>ctx</em> using <em>reason</em> as a text string indicating the reason for the request.  Returns 1 on success or the Lua constant "nil" on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.rbl_check(ctx, query, qroot[, timeout])</strong></p>
  </dt>
  <dd>
    <p>Makes an RBL query.  The root of the RBL is assumed to be at <em>qroot</em> and the subject of the query is <em>query,</em> so the query performed will be <em>query.qroot .</em> The context handle <em>ctx</em> must also be provided as it contains a handle to the established DNS service. The optional <em>timeout</em> parameter is the timeout to use, in seconds.  Returns "nil" on error, no values if the requested record was not present in the RBL, or the four octets of the RBL entry if it was.  The octets are returned in big-endian order. (Note: Feature is experimental.)</p>
  </dd>
  <dt>
    <p><strong>odkim.set_reply(ctx, rcode, xcode, message)</strong></p>
  </dt>
  <dd>
    <p>Instructs the MTA to return the specified SMTP reply to the client sending the message represented by <em>ctx.</em> <em>rcode</em> must be a three-digit SMTP reply code starting with 4 or 5 (for temporary or permanent failures, respectively); <em>xcode</em> must be the empty string or a valid extended reply code (see RFC2034) matching <em>rcode;</em> and <em>message</em> must be the text portion of the SMTP reply to be sent.  Returns 1 on success or the Lua constant "nil" on failure.</p>
  </dd>
  <dt>
    <p><strong>odkim.sig_bhresult(sig)</strong></p>
  </dt>
  <dd>
    <p>Returns the result code corresponding to the body hash evaluation of the signature handled specified by <em>sig,</em> previously returned by a call to <strong>odkim.get_sighandle().</strong> Valid values are the DKIM_SIGBH_* constants defined in the <strong>libopendkim</strong> header file <em>dkim.h.</em></p>
  </dd>
  <dt>
    <p><strong>odkim.sig_bodylength(sig)</strong></p>
  </dt>
  <dd>
    <p>Returns the total length of the message signed by <em>sig,</em> previously returned by a call to <strong>odkim.get_sighandle(),</strong> or the Lua constant "nil" if this value could not be determined.</p>
  </dd>
  <dt>
    <p><strong>odkim.sig_canonlength(sig)</strong></p>
  </dt>
  <dd>
    <p>Returns the canonicalized length of the message signed by <em>sig,</em> previously returned by a call to <strong>odkim.get_sighandle(),</strong> or the Lua constant "nil" if this value could not be determined. Note that this may be less than the value returned by <strong>odkim.get_bodylength()</strong> if the signature only covered part of the message.</p>
  </dd>
  <dt>
    <p><strong>odkim.sig_result(sig)</strong></p>
  </dt>
  <dd>
    <p>Returns the result code corresponding to the signature handled specified by <em>sig,</em> previously returned by a call to <strong>odkim.get_sighandle().</strong> Valid values are the constants with DKIM_SIGERROR_ prefixes as defined in the <strong>libopendkim</strong> header file <em>dkim.h.</em></p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This man page covers version 2.9.2 of <em>OpenDKIM.</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2009-2013, The Trusted Domain Project.  All rights reserved.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO opendkim-lua&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man8/opendkim.8.html"><strong>opendkim</strong>(8)</a>,</em> <a href="../man5/opendkim.conf.5.html"><strong>opendkim.conf</strong>(5)</a></em></p><p>Lua -- http://www.lua.org</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="opendir.3.html"><span aria-hidden="true">&larr;</span> opendir.3: Open a directory</a></li>
   <li class="next"><a href="openlog.3.html">openlog.3: Send messages to the system logger <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Math::Combinatorics: Perform combinations and permutations on lists</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perform combinations and permutations on lists">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Math::Combinatorics (3pm) manual">
  <meta name="twitter:description" content="Perform combinations and permutations on lists">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmath-combinatorics-perl-Math::Combinatorics-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Math::Combinatorics.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Math::Combinatorics (3pm) manual" />
  <meta property="og:description" content="Perform combinations and permutations on lists" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmath-combinatorics-perl-Math::Combinatorics-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Math::Combinatorics<small> (3pm)</small></h1>
        <p class="lead">Perform combinations and permutations on lists</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Math::Combinatorics.3pm.html">
      <span itemprop="name">Math::Combinatorics: Perform combinations and permutations on lists</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmath-combinatorics-perl/">
      <span itemprop="name">libmath-combinatorics-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Math::Combinatorics.3pm.html">
      <span itemprop="name">Math::Combinatorics: Perform combinations and permutations on lists</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Available as an object oriented \s-1API\s0.</p>
<pre>
  use Math::Combinatorics;

  my @n = qw(a b c);
  my $combinat = Math::Combinatorics-&gt;new(count =&gt; 2,
                                          data =&gt; [@n],
                                         );

  print "combinations of 2 from: ".join(" ",@n)."&#92;n";
  print "------------------------".("--" x scalar(@n))."&#92;n";
  while(my @combo = $combinat-&gt;next_combination){
    print join(&apos; &apos;, @combo)."&#92;n";
  }

  print "&#92;n";

  print "permutations of 3 from: ".join(" ",@n)."&#92;n";
  print "------------------------".("--" x scalar(@n))."&#92;n";
  while(my @permu = $combinat-&gt;next_permutation){
    print join(&apos; &apos;, @permu)."&#92;n";
  }

  output:
</pre>
<p>Or available via exported functions 'permute', 'combine', and 'factorial'.</p><p>  use Math::Combinatorics;</p><p>  my @n = qw(a b c);   print "combinations of 2 from: ".join(" ",@n)."&#92;n";   print "------------------------".("--" x scalar(@n))."&#92;n";   print join("&#92;n", map { join " ", @$_ } combine(2,@n)),"&#92;n";   print "&#92;n";   print "permutations of 3 from: ".join(" ",@n)."&#92;n";   print "------------------------".("--" x scalar(@n))."&#92;n";   print join("&#92;n", map { join " ", @$_ } permute(@n)),"&#92;n";</p><p>Output:</p><p>  combinations of 2 from: a b c   ------------------------------   a b   a c   b c</p><p>  permutations of 3 from: a b c   ------------------------------   a b c   a c b   b a c   b c a   c a b   c b a</p><p>Output from both types of calls is the same, but the object-oriented approach consumes much less memory for large sets.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Combinatorics is the branch of mathematics studying the enumeration, combination, and permutation of sets of elements and the mathematical relations that characterize their properties.  As a jumping off point, refer to:</p><p> http://mathworld.wolfram.com/Combinatorics.html</p><p>This module provides a pure-perl implementation of nCk, nCRk, nPk, nPRk, !n and n! (combination, multiset, permutation, string, derangement, and factorial, respectively). Functional and object-oriented usages allow problems such as the following to be solved:</p>
<dl class='dl-vertical'>
  <dt>
    combine - nCk
  </dt>
  <dd>
    <p> http://mathworld.wolfram.com/Combination.html \*(L"Fun questions to ask the pizza parlor wait staff: how many possible combinations of 2 toppings can I get on my pizza?\*(R".</p>
  </dd>
  <dt>
    derange - !n
  </dt>
  <dd>
    <p> http://mathworld.wolfram.com/Derangement.html \*(L"A derangement of n ordered objects, denoted !n, is a permutation in which none of the objects appear in their \*(R"natural\*(L" (i.e., ordered) place.\*(R"</p>
  </dd>
  <dt>
    permute - nPk
  </dt>
  <dd>
    <p> http://mathworld.wolfram.com/Permutation.html \*(L"Master Mind Game: ways to arrange pieces of different colors in a certain number of positions, without repetition of a color\*(R".</p>
  </dd>

</dl>
<p>Object-oriented usage additionally allows solving these problems by calling \*(L"<em>new()</em>\*(R" with a <strong>frequency</strong> vector:</p>
<dl class='dl-vertical'>
  <dt>
    string - nPRk
  </dt>
  <dd>
    <p> http://mathworld.wolfram.com/String.html \*(L"Morse signals: diferent signals of 3 positions using the two symbols - and .\*(R".  $o = Math::Combinatorics-&gt;new( count=&gt;3 , data=&gt;[qw(. -)] , frequency=&gt;[3,3] );  while ( my @x = $o-&gt;next_multiset ) {    my $p = Math::Combinatorics-&gt;new( data=&gt;&#92;@x , frequency=&gt;[map{1} @x] );    while ( my @y = $p-&gt;next_string ) {      #do something    }  }</p>
  </dd>
  <dt>
    multiset/multichoose - nCRk
  </dt>
  <dd>
    <p> http://mathworld.wolfram.com/Multiset.html \*(L"ways to extract 3 balls at once of a bag with 3 black and 3 white balls\*(R".  $o = Math::Combinatorics-&gt;new( count=&gt;3 , data=&gt;[qw(white black)] , frequency=&gt;[3,3] );  while ( my @x = $o-&gt;next_multiset ) {    #do something  }</p>
  </dd>

</dl>
<h3>\s-1EXPORT\s0</h3>
<p>the following export tags will bring a single method into the caller's namespace.  no symbols are exported by default.  see pod documentation below for method descriptions.</p><p>  combine   derange   multiset   permute   string   factorial</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Allen Day &lt;allenday@ucla.edu&gt;, with algorithmic contributions from Christopher Eltschka and Tye.</p><p>Copyright (c) 2004-2005 Allen Day. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>A sincere thanks to everyone for helping to make this a better module.  After initial development I've only had time to accept patches and improvements.  Math::Combinatorics continues to be developed and improved by the community.  Contributors of note include:</p><p>For adding new features: Carlos Rica, David Coppit, Carlos Segre, Lyon Lemmens</p><p>For bug reports: Ying Yang, Joerg Beyer, Marc Logghe, Yunheng Wang, Torsten Seemann, Gerrit Haase, Joern Behre, Lyon Lemmens, Federico Lucifredi</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS / TODO</h2>
        <div class="sectioncontent">
<p>Report them to the author.</p><p> * Need more extensive unit tests.</p><p>   * tests for new()&apos;s frequency argment</p><p> * A known bug (more of a missing feature, actually) does not allow parameterization of k  for nPk in permute().  it is assumed k == n.  L&lt;/permute()&gt; for details.  You can work  around this by making calls to both L&lt;/permute()&gt; and L&lt;/combine()&gt;</p><p> * Lots of really interesting stuff from Mathworld.Wolfram.com.  MathWorld rocks!  Expect  to see implementation of more concepts from their site, e.g.:</p><p>   http://mathworld.wolfram.com/BellNumber.html    http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html    http://mathworld.wolfram.com/Word.html</p><p> * Other combinatorics stuff    http://en.wikipedia.org/wiki/Catalan_number    http://en.wikipedia.org/wiki/Stirling_number</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Math::Combinatorics&hellip;</h2>
        <div class="sectioncontent">
<p>Set::Scalar</p><p>Set::Bag</p><p>String::Combination (alas misnamed, it actually returns permutations on a string).</p><p> http://perlmonks.thepen.com/29374.html</p><p> http://groups.google.com/groups?selm=38568F79.13680B86%40physik.tu-muenchen.de&output=gplain</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTED FUNCTIONS</h2>
        <div class="sectioncontent">
<h3>\fIcombine()\fP</h3>
<p> Usage   : my @combinations = combine($k,@n);  Function: implements nCk (n choose k), or n!/(k!*(n-k!)).            returns all unique unorderd combinations of k items from set n.            items in n are assumed to be character data, and are            copied into the return data structure (see "Returns" below).  Example : my @n = qw(a b c);            my @c = combine(2,@n);            print join "&#92;n", map { join " ", @$_ } @c;            # prints:            # b c            # a c            # a b  Returns : a list of arrays, where each array contains a unique combination            of k items from n  Args    : a list of items to be combined  Notes   : data is internally assumed to be alphanumeric.  this is necessary            to efficiently generate combinations of large sets.  if you need            combinations of non-alphanumeric data, or on data            C&lt;sort {$a cmp $b}&gt; would not be appropriate, use the            object-oriented API.  See L&lt;/new()&gt; and the B&lt;compare&gt; option.</p><p>           Identical items are assumed to be non-unique.  That is, calling            C&lt;combine(1,&apos;a&apos;,&apos;a&apos;) yields two sets: {a}, and {a}.  See            L&lt;/next_multiset() if this is not the desired behavior.</p>
<h3>\fIderange()\fP</h3>
<p> Usage   : my @deranges = derange(@n);  Function: implements !n, a derangement of n items in which none of the            items appear in their originally ordered place.  Example : my @n = qw(a b c);            my @d = derange(@n);            print join "&#92;n", map { join " ", @$_ } @d;            # prints:            # a c b            # b a c            # b c a            # c a b            # c b a  Returns : a list of arrays, where each array contains a derangement of            k items from n (where k == n).  Args    : a list of items to be deranged.  Note    : k should really be parameterizable.  this will happen            in a later version of the module.  send me a patch to            make that version come out sooner.  Notes   : data is internally assumed to be alphanumeric.  this is necessary            to efficiently generate combinations of large sets.  if you need            combinations of non-alphanumeric data, or on data            C&lt;sort {$a cmp $b}&gt; would not be appropriate, use the            object-oriented API.  See L&lt;/new()&gt;, and the B&lt;compare&gt; option.</p>
<h3>\fInext_derangement()\fP</h3>
<p> Usage   : my @derangement = $c-&gt;next_derangement();  Function: get derangements for @data.  Returns : returns a permutation of items from @data (see L&lt;/new()&gt;),            where none of the items appear in their natural order.  repeated calls            retrieve all unique derangements of @data elements.  a returned empty            list signifies all derangements have been iterated.  Args    : none.</p>
<h3>\fIfactorial()\fP</h3>
<p> Usage   : my $f = <strong>factorial</strong>(4); #returns 24, or 4*3*2*1  Function: calculates n! (n factorial).  Returns : undef if n is non-integer or n &lt; 0  Args    : a positive, non-zero integer  Note    : this function is used internally by combine() and permute()</p>
<h3>\fIpermute()\fP</h3>
<p> Usage   : my @permutations = permute(@n);  Function: implements nPk (n permute k) (where k == n), or n!/(n-k)!             returns all unique permutations of k items from set n            (where n == k, see "Note" below).  items in n are assumed to            be character data, and are copied into the return data            structure.  Example : my @n = qw(a b c);            my @p = permute(@n);            print join "&#92;n", map { join " ", @$_ } @p;            # prints:            # b a c            # b c a            # c b a            # c a b            # a c b            # a b c  Returns : a list of arrays, where each array contains a permutation of            k items from n (where k == n).  Args    : a list of items to be permuted.  Note    : k should really be parameterizable.  this will happen            in a later version of the module.  send me a patch to            make that version come out sooner.  Notes   : data is internally assumed to be alphanumeric.  this is necessary            to efficiently generate combinations of large sets.  if you need            combinations of non-alphanumeric data, or on data            C&lt;sort {$a cmp $b}&gt; would not be appropriate, use the            object-oriented API.  See L&lt;/new()&gt;, and the B&lt;compare&gt; option.</p><p>           Identical items are assumed to be non-unique.  That is, calling            C&lt;permute(&apos;a&apos;,&apos;a&apos;) yields two sets: {a,a}, and {a,a}.  See            L&lt;/next_string() if this is not the desired behavior.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTOR</h2>
        <div class="sectioncontent">
<h3>\fInew()\fP</h3>
<p> Usage   : my $c = Math::Combinatorics-&gt;new( count =&gt; 2,       #treated as int                                              data =&gt; [1,2,3,4] #arrayref or anonymous array                                            );  Function: build a new Math::Combinatorics object.  Returns : a Math::Combinatorics object  Args    : count     - required for combinatoric functions/methods.  number of elements to be                        present in returned set(s).            data      - required for combinatoric B&lt;AND&gt; permutagenic functions/methods.  this is the                        set elements are chosen from.  B&lt;NOTE&gt;: this array is modified in place; make                        a copy of your array if the order matters in the caller&apos;s space.            frequency - optional vector of data frequencies.  must be the same length as the B&lt;data&gt;                        constructor argument.  These two constructor calls here are equivalent:</p><p>                         $a = &apos;a&apos;;                          $b = &apos;b&apos;;</p><p>                         Math::Combinatorics-&gt;new( count=&gt;2, data=&gt;[&#92;$a,&#92;$a,&#92;$a,&#92;$a,&#92;$a,&#92;$b,&#92;$b] );                          Math::Combinatorics-&gt;new( count=&gt;2, data=&gt;[&#92;$a,&#92;$b], frequency=&gt;[5,2] );</p><p>                       so why use this?  sometimes it&apos;s useful to have multiple identical entities in                        a set (in set theory jargon, this is called a "bag", See L&lt;Set::Bag&gt;).            compare   - optional subroutine reference used in sorting elements of the set.  examples:</p><p>                       #appropriate for character elements                        compare =&gt; sub { $_[0] cmp $_[1] }                        #appropriate for numeric elements                        compare =&gt; sub { $_[0] &lt;=&gt; $_[1] }                        #appropriate for object elements, perhaps                        compare =&gt; sub { $_[0]-&gt;value &lt;=&gt; $_[1]-&gt;value }</p><p>                     The default sort mechanism is based on references, and cannot be predicted.                      Improvements for a more flexible compare() mechanism are most welcome.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT METHODS</h2>
        <div class="sectioncontent">
<h3>\fInext_combination()\fP</h3>
<p> Usage   : my @combo = $c-&gt;next_combination();  Function: get combinations of size $count from @data.  Returns : returns a combination of $count items from @data (see L&lt;/new()&gt;).            repeated calls retrieve all unique combinations of $count elements.            a returned empty list signifies all combinations have been iterated.  Note    : this method may only be used if a B&lt;frequency&gt; argument is B&lt;NOT&gt;            given to L&lt;/new()&gt;, otherwise use L&lt;/next_multiset()&gt;.  Args    : none.</p>
<h3>\fInext_multiset()\fP</h3>
<p> Usage   : my @multiset = $c-&gt;next_multiset();  Function: get multisets for @data.  Returns : returns a multiset of items from @data (see L&lt;/new()&gt;).            a multiset is a special type of combination where the set from which            combinations are drawn contains items that are indistinguishable.  use            L&lt;/next_multiset()&gt; when a B&lt;frequency&gt; argument is passed to L&lt;/new()&gt;.            repeated calls retrieve all unique multisets of @data elements.  a            returned empty list signifies all multisets have been iterated.  Note    : this method may only be used if a B&lt;frequency&gt; argument is given to            L&lt;/new()&gt;, otherwise use L&lt;/next_combination()&gt;.  Args    : none.</p>
<h3>\fInext_permutation()\fP</h3>
<p> Usage   : my @permu = $c-&gt;next_permutation();  Function: get permutations of elements in @data.  Returns : returns a permutation of items from @data (see L&lt;/new()&gt;).            repeated calls retrieve all unique permutations of @data elements.            a returned empty list signifies all permutations have been iterated.  Note    : this method may only be used if a B&lt;frequency&gt; argument is B&lt;NOT&gt;            given to L&lt;/new()&gt;, otherwise use L&lt;/next_string()&gt;.  Args    : none.</p>
<h3>\fInext_string()\fP</h3>
<p> Usage   : my @string = $c-&gt;next_string();  Function: get strings for @data.  Returns : returns a multiset of items from @data (see L&lt;/new()&gt;).            a multiset is a special type of permutation where the set from which            combinations are drawn contains items that are indistinguishable.  use            L&lt;/next_permutation()&gt; when a B&lt;frequency&gt; argument is passed to L&lt;/new()&gt;.            repeated calls retrieve all unique multisets of @data elements.  a            returned empty list signifies all strings have been iterated.  Note    : this method may only be used if a B&lt;frequency&gt; argument is given to            L&lt;/new()&gt;, otherwise use L&lt;/next_permutation()&gt;.  Args    : none.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNAL FUNCTIONS AND METHODS</h2>
        <div class="sectioncontent">
<h3>\fIsum()\fP</h3>
<p> Usage   : my $sum = sum(1,2,3); # returns 6  Function: sums a list of integers.  non-integer list elements are ignored  Returns : sum of integer items in arguments passed in  Args    : a list of integers  Note    : this function is used internally by combine()</p>
<h3>\fIcompare()\fP</h3>
<p> Usage   : $obj-&gt;compare()  Function: internal, undocumented.  holds a comparison coderef.  Returns : value of compare (a coderef)</p>
<h3>\fIcount()\fP</h3>
<p> Usage   : $obj-&gt;count()  Function: internal, undocumented.  holds the "k" in nCk or nPk.  Returns : value of count (an int)</p>
<h3>\fIdata()\fP</h3>
<p> Usage   : $obj-&gt;data()  Function: internal, undocumented.  holds the set "n" in nCk or nPk.  Returns : value of data (an arrayref)</p>
<h3>\fIswap()\fP</h3>
<p>internal, undocumented.</p>
<h3>\fIreverse()\fP</h3>
<p>internal, undocumented.</p>
<h3>\fIrotate()\fP</h3>
<p>internal, undocumented.</p>
<h3>\fIupper_bound()\fP</h3>
<p>internal, undocumented.</p>
<h3>\fIlower_bound()\fP</h3>
<p>internal, undocumented.</p>
<h3>\fI_permutation_cursor()\fP</h3>
<p> Usage   : $obj-&gt;_permutation_cursor()  Function: internal method.  cursor on permutation iterator order.  Returns : value of _permutation_cursor (an arrayref)  Args    : none</p>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Math::Calculus::NewtonRaphson.3pm.html"><span aria-hidden="true">&larr;</span> Math::Calculus::NewtonRaphson.3pm: Algebraic newton raphson implementation</a></li>
   <li class="next"><a href="Math::Complex.3pm.html">Math::Complex.3pm: Complex numbers and associated mathematical functions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

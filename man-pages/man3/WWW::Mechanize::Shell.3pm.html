<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>WWW::Mechanize::Shell: An interactive shell for www::mechanize</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="An interactive shell for www::mechanize">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="WWW::Mechanize::Shell (3pm) manual">
  <meta name="twitter:description" content="An interactive shell for www::mechanize">
  <meta name="twitter:image" content="https://www.carta.tech/images/libwww-mechanize-shell-perl-WWW::Mechanize::Shell-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/WWW::Mechanize::Shell.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="WWW::Mechanize::Shell (3pm) manual" />
  <meta property="og:description" content="An interactive shell for www::mechanize" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libwww-mechanize-shell-perl-WWW::Mechanize::Shell-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">WWW::Mechanize::Shell<small> (3pm)</small></h1>
        <p class="lead">An interactive shell for www::mechanize</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/WWW::Mechanize::Shell.3pm.html">
      <span itemprop="name">WWW::Mechanize::Shell: An interactive shell for www::mechanize</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libwww-mechanize-shell-perl/">
      <span itemprop="name">libwww-mechanize-shell-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/WWW::Mechanize::Shell.3pm.html">
      <span itemprop="name">WWW::Mechanize::Shell: An interactive shell for www::mechanize</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>From the command line as</p>
<pre>
  perl -MWWW::Mechanize::Shell -eshell
</pre>
<p>or alternatively as a custom shell program via :</p><p>  #!/usr/bin/perl -w   use strict;   use WWW::Mechanize::Shell;</p><p>  my $shell = WWW::Mechanize::Shell-&gt;new("shell");</p><p>  if (@ARGV) {     $shell-&gt;source_file( @ARGV );   } else {     $shell-&gt;cmdloop;   };</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module implements a www-like shell above WWW::Mechanize and also has the capability to output crude Perl code that recreates the recorded session. Its main use is as an interactive starting point for automating a session through WWW::Mechanize.</p><p>The cookie support is there, but no cookies are read from your existing browser sessions. See HTTP::Cookies on how to implement reading/writing your current browsers cookies. This is the constructor for a new shell instance. Some of the options can be passed to the constructor as parameters.</p><p>By default, a file \*(C`.mechanizerc\*(C' (respectively \*(C`mechanizerc\*(C' under Windows) in the users home directory is executed before the interactive shell loop is entered. This can be used to set some defaults. If you want to supply a different filename for the rcfile, the \*(C`rcfile\*(C' parameter can be passed to the constructor :</p><p>  rcfile =&gt; &apos;.myapprc&apos;, Since the shell stores a reference back to itself within the WWW::Mechanize instance, it is necessary to break this circular reference. This method does this. The \*(C`source_file\*(C' method executes the lines of \s-1FILENAME\s0 as if they were typed in.</p><p>  $shell-&gt;source_file( $filename ); All user warnings are routed through this routine so they can be rerouted / disabled easily. Prints the text in \s-1LIST\s0 using $ENV{PAGER}. If $ENV{PAGER} is empty, prints directly to \*(C`STDOUT\*(C'. Most of this routine comes from the \*(C`perldoc\*(C' utility. Returns a meaningful text from a WWW::Mechanize::Link object. This is (in order of precedence) :</p><p>    $link-&gt;text     $link-&gt;name     $link-&gt;url Returns the (relevant) shell history, that is, all commands that were not solely for the information of the user. The lines are returned as a list.</p><p>  print join "&#92;n", $shell-&gt;history; Returns the shell history as a Perl program. The lines are returned as a list. The lines do not have a one-by-one correspondence to the lines in the history.</p><p>  print join "&#92;n", $shell-&gt;script; \*(C`status\*(C' is called for status updates. \*(C`display\*(C' is called to output listings, currently from the \*(C`history\*(C' and \*(C`script\*(C' commands. If the second parameter is defined, it is the name of the file to be written, otherwise the lines are displayed to the user.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMANDS</h2>
        <div class="sectioncontent">
<p>The shell implements various commands :</p><h3>exit</h3>
<p>Leaves the shell.</p>
<h3>restart</h3>
<p>Restart the shell.</p><p>This is mostly useful when you are modifying the shell itself. It dosen't work if you use the shell in oneliner mode with \*(C`-e\*(C'.</p>
<h3>get</h3>
<p>Download a specific \s-1URL\s0.</p><p>This is used as the entry point in all sessions</p><p>Syntax:</p><p>  get URL</p>
<h3>save</h3>
<p>Download a link into a file.</p><p>If more than one link matches the \s-1RE\s0, all matching links are saved. The filename is taken from the last part of the \s-1URL\s0. Alternatively, the number of a link may also be given.</p><p>Syntax:</p><p>  save RE</p>
<h3>content</h3>
<p>Display the content for the current page.</p><p>Syntax: content [\s-1FILENAME\s0]</p><p>If the \s-1FILENAME\s0 argument is provided, save the content to the file.</p><p>A trailing \*(L"&#92;n\*(R" is added to the end of the content when using the shell, so this might not be ideally suited to save binary files without manual editing of the produced script.</p>
<h3>title</h3>
<p>Display the current page title as found in the \*(C`&lt;TITLE&gt;\*(C' tag.</p>
<h3>headers</h3>
<p>Prints all \*(C`&lt;H1&gt;\*(C' through \*(C`&lt;H5&gt;\*(C' strings found in the content, indented accordingly.  With an argument, prints only those levels; e.g., \*(C`headers 145\*(C' prints H1,H4,H5 strings only.</p>
<h3>ua</h3>
<p>Get/set the current user agent</p><p>Syntax:</p><p>  # fake Internet Explorer   ua "Mozilla/4.0 (compatible; MSIE 4.01; Windows 98)"</p><p>  # fake QuickTime v5   ua "QuickTime (qtver=5.0.2;os=Windows NT 5.0Service Pack 2)"</p><p>  # fake Mozilla/Gecko based   ua "Mozilla/5.001 (windows; U; NT4.0; en-us) Gecko/25250101"</p><p>  # set empty user agent :   ua ""</p>
<h3>links</h3>
<p>Display all links on a page</p><p>The links numbers displayed can used by \*(C`open\*(C' to directly select a link to follow.</p>
<h3>parse</h3>
<p>Dump the output of HTML::TokeParser of the current content</p>
<h3>forms</h3>
<p>Display all forms on the current page.</p>
<h3>form</h3>
<p>Select the form named \s-1NAME\s0</p><p>If \s-1NAME\s0 matches \*(C`/^&#92;d+$/\*(C', it is assumed to be the (1-based) index of the form to select. There is no way of selecting a numerically named form by its name.</p>
<h3>dump</h3>
<p>Dump the values of the current form</p>
<h3>value</h3>
<p>Set a form value</p><p>Syntax:</p><p>  value NAME [VALUE]</p>
<h3>tick</h3>
<p>Set checkbox marks</p><p>Syntax:</p><p>  tick NAME VALUE(s)</p><p>If no value is given, all boxes are checked.</p>
<h3>untick</h3>
<p>Remove checkbox marks</p><p>Syntax:</p><p>  untick NAME VALUE(s)</p><p>If no value is given, all marks are removed.</p>
<h3>submit</h3>
<p>submits the form without clicking on any button</p>
<h3>click</h3>
<p>Clicks on the button named \s-1NAME\s0.</p><p>No regular expression expansion is done on \s-1NAME\s0.</p><p>Syntax:</p><p>  click NAME</p><p>If you have a button that has no name (displayed as \s-1NONAME\s0), use</p><p>  click ""</p><p>to click on it.</p>
<h3>open</h3>
<p>&lt;open&gt; accepts one argument, which can be a regular expression or the number of a link on the page, starting at zero. These numbers are displayed by the \*(C`links\*(C' function. It goes directly to the page if a number is used or if the \s-1RE\s0 has one match. Otherwise, a list of links matching the regular expression is displayed.</p><p>The regular expression should start and end with \*(L"/\*(R".</p><p>Syntax:</p><p>  open  [ RE | # ]</p>
<h3>back</h3>
<p>Go back one page in the browser page history.</p>
<h3>reload</h3>
<p>Repeat the last request, thus reloading the current page.</p><p>Note that also \s-1POST\s0 requests are blindly repeated, as this command is mostly intended to be used when testing server side code.</p>
<h3>browse</h3>
<p>Open the web browser with the current page</p><p>Displays the current page in the browser.</p>
<h3>set</h3>
<p>Set a shell option</p><p>Syntax:</p><p>   set OPTION [value]</p><p>The command lists all valid options. Here is a short overview over the different options available :</p><p>    autosync      - automatically synchronize the browser window     autorestart   - restart the shell when any required module changes                     This does not work with C&lt;-e&gt; oneliners.     watchfiles    - watch all required modules for changes     cookiefile    - the file where to store all cookies     dumprequests  - dump all requests to STDOUT     dumpresponses - dump the headers of the responses to STDOUT     verbose       - print commands to STDERR as they are run,                     when sourcing from a file</p>
<h3>history</h3>
<p>Display your current session history as the relevant commands.</p><p>Syntax:</p><p>  history [FILENAME]</p><p>Commands that have no influence on the browser state are not added to the history. If a parameter is given to the \*(C`history\*(C' command, the history is saved to that file instead of displayed onscreen.</p>
<h3>script</h3>
<p>Display your current session history as a Perl script using WWW::Mechanize.</p><p>Syntax:</p><p>  script [FILENAME]</p><p>If a parameter is given to the \*(C`script\*(C' command, the script is saved to that file instead of displayed on the console.</p><p>This command was formerly known as \*(C`history\*(C'.</p>
<h3>comment</h3>
<p>Adds a comment to the script and the history. The comment is prepended with a &#92;n to increase readability.</p>
<h3>fillout</h3>
<p>Fill out the current form</p><p>Interactively asks the values hat have no preset value via the autofill command.</p>
<h3>auth</h3>
<p>Set basic authentication credentials.</p><p>Syntax:</p><p>  auth user password</p><p>If you know the authority and the realm in advance, you can presupply the credentials, for example at the start of the script :</p><p>        &gt;auth corion secret         &gt;get http://www.example.com         Retrieving http://www.example.com(200)         http://www.example.com&gt;</p>
<h3>table</h3>
<p>Display a table described by the columns \s-1COLUMNS\s0.</p><p>Syntax:</p><p>  table COLUMNS</p><p>Example:</p><p>  table Product Price Description</p><p>If there is a table on the current page that has in its first row the three columns \*(C`Product\*(C', \*(C`Price\*(C' and \*(C`Description\*(C' (not necessarily in that order), the script will display these columns of the whole table.</p><p>The \*(C`HTML::TableExtract\*(C' module is needed for this feature.</p>
<h3>tables</h3>
<p>Display a list of tables.</p><p>Syntax:</p><p>  tables</p><p>This command will display the top row for every table on the current page. This is convenient if you want to find out what the exact spellings for each column are.</p><p>The command does not always work nice, for example if a site uses tables for layout, it will be harder to guess what tables are irrelevant and what tables are relevant.</p><p>HTML::TableExtract is needed for this feature.</p>
<h3>cookies</h3>
<p>Set the cookie file name</p><p>Syntax:</p><p>  cookies FILENAME</p>
<h3>autofill</h3>
<p>Define an automatic value</p><p>Sets a form value to be filled automatically. The \s-1NAME\s0 parameter is the WWW::Mechanize::FormFiller::Value subclass you want to use. For session fields, \*(C`Keep\*(C' is a good candidate, for interactive stuff, \*(C`Ask\*(C' is a value implemented by the shell.</p><p>A field name starting and ending with a slash (\*(C`/\*(C') is taken to be a regular expression and will be applied to all fields with their name matching the expression. A field with a matching name still takes precedence over the regular expression.</p><p>Syntax:</p><p>  autofill NAME [PARAMETERS]</p><p>Examples:</p><p>  autofill login Fixed corion   autofill password Ask   autofill selection Random red green orange   autofill session Keep   autofill "/date$/" Random::Date string "%m/%d/%Y"</p>
<h3>eval</h3>
<p>Evaluate Perl code and print the result</p><p>Syntax:</p><p>  eval CODE</p><p>For the generated scripts, anything matching the regular expression \*(C`/&#92;$self-&gt;agent&#92;b/\*(C' is automatically replaced by $agent in your eval code, to do the Right Thing.</p><p>Examples:</p><p>  # Say hello   eval "Hello World"</p><p>  # And take a look at the current content type   eval $self-&gt;agent-&gt;ct</p>
<h3>source</h3>
<p>Execute a batch of commands from a file</p><p>Syntax:</p><p>  source FILENAME</p>
<h3>versions</h3>
<p>Print the version numbers of important modules</p><p>Syntax:</p><p>  versions</p>
<h3>timeout</h3>
<p>Set new timeout value for the agent. Effects all subsequent requests. \s-1VALUE\s0 is in seconds.</p><p>Syntax:</p><p>  timeout VALUE</p>
<h3>ct</h3>
<p>prints the content type of the most current response.</p><p>Syntax:</p><p>  ct</p>
<h3>referrer</h3>
<p>set the value of the Referer: header</p><p>Syntax:</p><p>  referer URL   referrer URL</p>
<h3>referer</h3>
<p>Alias for referrer</p>
<h3>response</h3>
<p>display the last server response Munges a coderef to become code fit for output independent of WWW::Mechanize::Shell. This subroutine is exported by default as a convenience method so that the following oneliner invocation works:</p><p>    perl -MWWW::Mechanize::Shell -eshell</p><p>You can pass constructor arguments to this routine as well. Any scripts given in @ARGV will be run. If @ARGV is empty, an interactive loop will be started.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SAMPLE SESSIONS</h2>
        <div class="sectioncontent">
<h3>Entering values</h3>
<p>  # Search for a term on Google   get http://www.google.com   value q "Corions Homepage"   click btnG   script   # (yes, this is a bad example of automating, as Google   #  already has a Perl API. But other sites don&apos;t)</p>
<h3>Retrieving a table</h3>
<p>  get http://www.perlmonks.org   open "/Saints in/"   table User Experience Level   script   # now you have a program that gives you a csv file of   # that table.</p>
<h3>Uploading a file</h3>
<p>  get http://aliens:xxxxx/   value f path/to/file   click "upload"</p>
<h3>Batch download</h3>
<p>  # download prerelease versions of my modules   get http://www.corion.net/perl-dev   save /.tar.gz$/</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REGULAR EXPRESSION SYNTAX</h2>
        <div class="sectioncontent">
<p>Some commands take regular expressions as parameters. A regular expression <strong>must</strong> be a single parameter matching \*(C`^/.*/([isxm]+)?$\*(C', so you have to use quotes around it if the expression contains spaces :</p><p>  /link_foo/       # will match as (?-xims:link_foo)   "/link foo/"     # will match as (?-xims:link foo)</p><p>Slashes do not need to be escaped, as the shell knows that a \s-1RE\s0 starts and ends with a slash :</p><p>  /link/foo/       # will match as (?-xims:link/foo)   "/link/ /foo/"   # will match as (?-xims:link/&#92;s/foo)</p><p>The \*(C`/i\*(C' modifier works as expected. If you desire more power over the regular expressions, consider dropping to Perl or recommend me a good parser module for regular expressions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISPLAYING HTML</h2>
        <div class="sectioncontent">
<p>WWW::Mechanize::Shell now uses the module HTML::Display to display the \s-1HTML\s0 of the current page in your browser. Have a look at the documentation of HTML::Display how to make it use your browser of choice in the case it does not already guess it correctly.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILLING FORMS VIA CUSTOM CODE</h2>
        <div class="sectioncontent">
<p>If you want to stay within the confines of the shell, but still want to fill out forms using custom Perl code, here is a recipe how to achieve this :</p><p>Code passed to the \*(C`eval\*(C' command gets evalutated in the WWW::Mechanize::Shell namespace. You can inject new subroutines there and these get picked up by the Callback class of WWW::Mechanize::FormFiller :</p><p>  # Fill in the "date" field with the current date/time as string   eval sub &::custom_today { scalar localtime };   autofill date Callback WWW::Mechanize::Shell::custom_today   fillout</p><p>This method can also be used to retrieve data from shell scripts :</p><p>  # Fill in the "date" field with the current date/time as string   # works only if there is a program "date"   eval sub &::custom_today { chomp &#96;date&#96; };   autofill date Callback WWW::Mechanize::Shell::custom_today   fillout</p><p>As the namespace is different between the shell and the generated script, make sure you always fully qualify your subroutine names, either in your own namespace or in the main namespace.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GENERATED SCRIPTS</h2>
        <div class="sectioncontent">
<p>The \*(C`script\*(C' command outputs a skeleton script that reproduces your actions as done in the current session. It pulls in \*(C`WWW::Mechanize::FormFiller\*(C', which is possibly not needed. You should add some error and connection checking afterwards.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADDING FIELDS TO HTML</h2>
        <div class="sectioncontent">
<p>If you are automating a JavaScript dependent site, you will encounter JavaScript like this :</p><p>    &lt;script&gt;       document.write( "&lt;input type=submit name=submit&gt;" );     &lt;/script&gt;</p><p>HTML::Form will not know about this and will not have provided a submit button for you (understandably). If you want to create such a submit button from within your automation script, use the following code :</p><p>  $agent-&gt;current_form-&gt;push_input( submit =&gt; { name =&gt; "submit", value =&gt;"submit" } );</p><p>This also works for other dynamically generated input fields.</p><p>To fake an input field from within a shell session, use the \*(C`eval\*(C' command :</p><p>  eval $self-&gt;agent-&gt;current_form-&gt;push_input(submit=&gt;{name=&gt;"submit",value=&gt;"submit"});</p><p>And yes, the generated script should do the Right Thing for this eval as well.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOCAL FILES</h2>
        <div class="sectioncontent">
<p>If you want to use the shell on a local file without setting up a \*(C`http\*(C' server to serve the file, you can use the \*(C`file:\*(C' \s-1URI\s0 scheme to load it into the \*(L"browser\*(R":</p><p>  get file:local.html   forms</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROXY SUPPORT</h2>
        <div class="sectioncontent">
<p>Currently, the proxy support is realized via a call to the \*(C`env_proxy\*(C' method of the WWW::Mechanize object, which loads the proxies from the environment. There is no provision made to prevent using proxies (yet). The generated scripts also load their proxies from the environment.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ONLINE HELP</h2>
        <div class="sectioncontent">
<p>The online help feature is currently a bit broken in \*(C`Term::Shell\*(C', but a fix is in the works. Until then, you can re-enable the dynamic online help by patching \*(C`Term::Shell\*(C' :</p><p>Remove the three lines</p><p>      my $smry = exists $o-&gt;{handlers}{$h}{smry}     ? $o-&gt;summary($h)     : "undocumented";</p><p>in \*(C`sub run_help\*(C' and replace them by</p><p>      my $smry = $o-&gt;summary($h);</p><p>The shell works without this patch and the online help is still available through \*(C`perldoc WWW::Mechanize::Shell\*(C'</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Bug reports are very welcome - please use the \s-1RT\s0 interface at https://rt.cpan.org/NoAuth/Bugs.html?Dist=WWW-Mechanize-Shell or send a descriptive mail to bug-WWW-Mechanize-Shell@rt.cpan.org . Please try to include as much (relevant) information as possible - a test script that replicates the undesired behaviour is welcome every time!</p><ul>
<li><p>The two parameter version of the \*(C`auth\*(C' command guesses the realm from the last received response. Currently a \s-1RE\s0 is used to extract the realm, but this fails with some servers resp. in some cases. Use the four parameter version of \*(C`auth\*(C', or if not possible, code the extraction in Perl, either in the final script or through \*(C`eval\*(C' commands.</p></li><li><p>The shell currently detects when you want to follow a JavaScript link and tells you that this is not supported. It would be nicer if there was some callback mechanism to (automatically?) extract URLs from JavaScript-infected links.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<ul>
<li><p>Add XPath expressions (by moving \*(C`WWW::Mechanize\*(C' from HTML::Parser to XML::XMLlib or maybe easier, by tacking Class::XPath onto an \s-1HTML\s0 tree)</p></li><li><p>Add \*(C`head\*(C' as a command ?</p></li><li><p>Optionally silence the HTML::Parser / HTML::Forms warnings about invalid \s-1HTML\s0.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORT</h2>
        <div class="sectioncontent">
<p>The routine \*(C`shell\*(C' is exported into the importing namespace. This is mainly for convenience so you can use the following commandline invocation of the shell like with \s-1CPAN\s0 :</p><p>  perl -MWWW::Mechanize::Shell -e"shell"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REPOSITORY</h2>
        <div class="sectioncontent">
<p>The public repository of this module is &lt;http://github.com/Corion/WWW-Mechanize-Shell&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>The public support forum of this module is &lt;http://perlmonks.org/&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>Copyright (C) 2002,2010 Max Maischein</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Max Maischein, &lt;corion@cpan.org&gt;</p><p>Please contact me if you find bugs or otherwise improve the module. More tests are also very welcome !</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO WWW::Mechanize::Shell&hellip;</h2>
        <div class="sectioncontent">
<p>WWW::Mechanize,WWW::Mechanize::FormFiller,WWW::Mechanize::Firefox</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="WWW::Mechanize::GZip.3pm.html"><span aria-hidden="true">&larr;</span> WWW::Mechanize::GZip.3pm: Tries to fetch webpages with gzip-compression</a></li>
   <li class="next"><a href="WWW::Mediawiki::Client.3pm.html">WWW::Mediawiki::Client.3pm: Module providing a vcs like to mediawiki <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

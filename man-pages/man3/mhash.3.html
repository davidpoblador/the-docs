<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mhash: Hash library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Hash library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mhash (3) manual">
  <meta name="twitter:description" content="Hash library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmhash-dev-mhash-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/mhash.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mhash (3) manual" />
  <meta property="og:description" content="Hash library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmhash-dev-mhash-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mhash<small> (3)</small></h1>
        <p class="lead">Hash library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mhash.3.html">
      <span itemprop="name">mhash: Hash library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmhash-dev/">
      <span itemprop="name">libmhash-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mhash.3.html">
      <span itemprop="name">mhash: Hash library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>mhash \s-10.9.2\s0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 #include "mhash.h"
</pre>
<p><strong> Informative Functions </strong></p><p> size_t   mhash_count(void);  size_t   mhash_get_block_size(hashid type);  char    *mhash_get_hash_name(hashid type);  size_t   mhash_get_hash_pblock(hashid type);  hashid   mhash_get_mhash_algo( MHASH);</p><p><strong> Key Generation Functions </strong></p><p> int      mhash_keygen_ext(keygenid algorithm, KEYGEN algorithm_data,                 void* keyword, int keysize,                 unsigned char* password, int passwordlen);</p><p><strong> Initializing Functions </strong></p><p> MHASH    mhash_init(hashid type);  MHASH    mhash_hmac_init(const hashid type, void *key, int keysize, int block);  MHASH    mhash_cp( MHASH);</p><p><strong> Update Functions </strong></p><p> int      mhash(MHASH thread, const void *plaintext, size_t size);</p><p><strong> Save/Restore Functions </strong></p><p> int      mhash_save_state_mem(MHASH thread, void *mem, int* mem_size );  MHASH    mhash_restore_state_mem(void* mem);</p><p><strong> Finalizing Functions </strong></p><p> void    mhash_deinit(MHASH thread, void *result);  void    *mhash_end(MHASH thread);  void    *mhash_end_m(MHASH thread, void* (*hash_malloc)(size_t));</p><p> void    *mhash_hmac_end(MHASH thread);  void    *mhash_hmac_end_m(MHASH thread, void* (*hash_malloc)(size_t));  int     mhash_hmac_deinit(MHASH thread, void *result);</p><p><strong> Available Hashes </strong></p><p><em>\s-1CRC32\s0</em>: The crc32 algorithm is used to compute checksums. The two variants used in mhash are: <strong>\s-1MHASH_CRC32\s0</strong> (like the one used in ethernet) and <strong>\s-1MHASH_CRC32B\s0</strong> (like the one used in \s-1ZIP\s0 programs).</p><p><em>\s-1ADLER32\s0</em>: The adler32 algorithm is used to compute checksums. It is faster than \s-1CRC32\s0 and it is considered to be as reliable as \s-1CRC32\s0. This algorithm is defined as <strong>\s-1MHASH_ADLER32\s0</strong>.</p><p><em>\s-1MD5\s0</em>: The \s-1MD5\s0 algorithm by Ron Rivest and \s-1RSA\s0. In mhash this algorithm is defined as <strong>\s-1MHASH_MD5\s0</strong>.</p><p><em>\s-1MD4\s0</em>: The \s-1MD4\s0 algorithm by Ron Rivest and \s-1RSA\s0. This algorithm is considered broken, so don't use it. In mhash this algorithm is defined as <strong>\s-1MHASH_MD4\s0</strong>.</p><p><em>\s-1SHA1\s0</em>/<em>\s-1SHA256\s0</em>: The \s-1SHA\s0 algorithm by \s-1US\s0. \s-1NIST/NSA\s0. This algorithm is specified for use in the \s-1NIST\s0's Digital Signature Standard. In mhash these algorithm are defined as <strong>\s-1MHASH_SHA1\s0</strong> and <strong>\s-1MHASH_SHA256\s0</strong>.</p><p><em>\s-1HAVAL\s0</em>: \s-1HAVAL\s0 is a one-way hashing algorithm with variable length of output. \s-1HAVAL\s0 is a modification of \s-1MD5\s0. Defined in mhash as: <strong>\s-1MHASH_HAVAL256\s0, \s-1MHASH_HAVAL192\s0, \s-1MHASH_HAVAL160\s0, \s-1MHASH_HAVAL128\s0</strong>.</p><p><em>\s-1RIPEMD160\s0</em>: \s-1RIPEMD-160\s0 is a 160-bit cryptographic hash function, designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel. It is intended to be used as a secure replacement for the 128-bit hash functions \s-1MD4\s0, \s-1MD5\s0, and \s-1RIPEMD\s0. \s-1MD4\s0 and \s-1MD5\s0 were developed by Ron Rivest for \s-1RSA\s0 Data Security, while \s-1RIPEMD\s0 was developed in the framework of the \s-1EU\s0 project \s-1RIPE\s0 (\s-1RACE\s0 Integrity Primitives Evaluation, 1988-1992). In mhash this algorithm is defined as <strong>\s-1MHASH_RIPEMD160\s0</strong>.</p><p><em>\s-1TIGER\s0</em>: Tiger is a fast hash function, by Eli Biham and Ross Anderson. Tiger was designed to be very fast on modern computers, and in particular on the state-of-the-art 64-bit computers, while it is still not slower than other suggested hash functions on 32-bit machines. In mhash this algorithm is defined as: <strong>\s-1MHASH_TIGER\s0, \s-1MHASH_TIGER160\s0, \s-1MHASH_TIGER128\s0</strong>.</p><p><em>\s-1GOST\s0</em>: \s-1GOST\s0 algorithm is a russian standard and it uses the \s-1GOST\s0 encryption algorithm to produce a 256 bit hash value. This algorithm is specified for use in the Russian Digital Signature Standard. In mhash this algorithm is defined as <strong>\s-1MHASH_GOST\s0</strong>.</p><p><strong> Available Key Generation algorithms </strong></p><p><em>\s-1KEYGEN_MCRYPT\s0</em>: The key generator used in mcrypt.</p><p><em>\s-1KEYGEN_ASIS\s0</em>: Just returns the password as binary key.</p><p><em>\s-1KEYGEN_HEX\s0</em>: Just converts a hex key into a binary one.</p><p><em>\s-1KEYGEN_PKDES\s0</em>: The transformation used in Phil Karn's \s-1DES\s0 encryption program.</p><p><em>\s-1KEYGEN_S2K_SIMPLE\s0</em>: The OpenPGP (rfc2440) Simple S2K.</p><p><em>\s-1KEYGEN_S2K_SALTED\s0</em>: The OpenPGP Salted S2K.</p><p><em>\s-1KEYGEN_S2K_ISALTED\s0</em>: The OpenPGP Iterated Salted S2K.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>mhash</strong> library provides an easy to use C interface for several <em>hash</em> algorithms (also known as \*(L"one-way\*(R" algorithms). These can be used to create checksums, message digests and more. Currently, \s-1MD5\s0, \s-1SHA1\s0, \s-1GOST\s0, \s-1TIGER\s0, \s-1RIPE-MD160\s0, \s-1HAVAL\s0 and several other algorithms are supported. <strong>mhash</strong> support <em>\s-1HMAC\s0 generation</em> (a mechanism for message authentication using cryptographic hash functions, and is described in rfc2104). \s-1HMAC\s0 can be used to create message digests using a secret key, so that these message digests cannot be regenerated (or replaced) by someone else. A key generation mechanism was added to <strong>mhash</strong> since <em>key generation</em> algorithms usually involve hash algorithms.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API FUNCTIONS</h2>
        <div class="sectioncontent">
<p>We will describe the \s-1API\s0 of <strong>mhash</strong> in detail now. The order follows the one in the \s-1SYNOPSIS\s0 directly.</p>
<dl class='dl-vertical'>
  <dt>
    size_t <strong>mhash_count</strong>(void);
  </dt>
  <dd>
    <p>This returns the \*(C`hashid\*(C' of the last available hash. Hashes are numbered from 0 to \*(C`mhash_count()\*(C'.</p>
  </dd>
  <dt>
    size_t <strong>mhash_get_block_size</strong>(hashid <em>type</em>);
  </dt>
  <dd>
    <p>If <em>type</em> exists, this returns the used blocksize of the hash <em>type</em> in bytes. Otherwise, it returns 0.</p>
  </dd>
  <dt>
    char *<strong>mhash_get_hash_name</strong>(hashid <em>type</em>);
  </dt>
  <dd>
    <p>If <em>type</em> exists, this returns the name of the hash <em>type</em>. Otherwise, a \*(C`NULL\*(C' pointer is returned. The string is allocated with <em>malloc</em>\|(3) separately, so do not forget to <em>free</em>\|(3) it.</p>
  </dd>
  <dt>
    const char *<strong>mhash_get_hash_name_static</strong>(hashid <em>type</em>);
  </dt>
  <dd>
    <p>If <em>type</em> exists, this returns the name of the hash <em>type</em>. Otherwise, a \*(C`NULL\*(C' pointer is returned.</p>
  </dd>
  <dt>
    size_t <strong>mhash_get_hash_pblock</strong>(hashid <em>type</em>);
  </dt>
  <dd>
    <p>It returns the block size that the algorithm operates. This is used in mhash_hmac_init. If the return value is 0 you shouldn't use that algorithm in \s-1HMAC\s0.</p>
  </dd>
  <dt>
    hashid <strong>mhash_get_mhash_algo</strong>(\s-1MHASH\s0 <em>src</em>);
  </dt>
  <dd>
    <p>Returns the algorithm used in the state of <em>src</em>.</p>
  </dd>
  <dt>
    \s-1MHASH\s0 <strong>mhash_init</strong>(hashid <em>type</em>);
  </dt>
  <dd>
    <p>This setups a context to begin hashing using the algorithm <em>type</em>. It returns a descriptor to that context which will result in leaking memory, if you do not call <em>mhash_deinit</em>\|(3) later. Returns \*(C`MHASH_FAILED\*(C' on failure.</p>
  </dd>
  <dt>
    \s-1MHASH\s0 <strong>mhash_hmac_init</strong>(const hashid <em>type</em>, void *<em>key</em>, int <em>keysize</em>, int <em>block</em>);
  </dt>
  <dd>
    <p>This setups a context to begin hashing using the algorithm type in \s-1HMAC\s0 mode. <em>key</em> should be a pointer to the key and <em>keysize</em> its len. The <em>block</em> is the block size (in bytes) that the algorithm operates. It should be obtained by <em>mhash_get_hash_pblock()</em>. If its 0 it defaults to 64. After calling it you should use <em>mhash()</em> to update the context. It returns a descriptor to that context which will result in leaking memory, if you do not call <em>mhash_hmac_deinit</em>\|(3) later. Returns \*(C`MHASH_FAILED\*(C' on failure.</p>
  </dd>
  <dt>
    \s-1MHASH\s0 <strong>mhash_cp</strong>(\s-1MHASH\s0 <em>src</em>);
  </dt>
  <dd>
    <p>This setups a new context using the state of <em>src</em>.</p>
  </dd>
  <dt>
    int <strong>mhash</strong>(\s-1MHASH\s0 <em>thread</em>, const void *<em>plaintext</em>, size_t <em>size</em>);
  </dt>
  <dd>
    <p>This updates the context described by <em>thread</em> with <em>plaintext</em>. <em>size</em> is the length of <em>plaintext</em> which may be binary data.</p>
  </dd>
  <dt>
    int <strong>mhash_save_state_mem</strong>( \s-1MHASH\s0 <em>thread</em>, void *<em>mem</em>, int* <em>mem_size</em>);
  </dt>
  <dd>
    <p>Saves the state of a hashing algorithm such that it can be restored at some later point in time using <strong>mhash_restore_state_mem</strong>(). <em>mem_size</em> should contain the size of the given <em>mem</em> pointer. If it is not enough to hold the buffer the required value will be copied there.</p>
  </dd>
  <dt>
    \s-1MHASH\s0 <strong>mhash_restore_state_mem</strong>(void* <em>mem</em>);
  </dt>
  <dd>
    <p>Restores the state of a hashing algorithm that was saved using <strong>mhash_save_state_mem</strong>(). Use like <strong>mhash_init</strong>().</p>
  </dd>
  <dt>
    void *<strong>mhash_end</strong>(\s-1MHASH\s0 <em>thread</em>);
  </dt>
  <dd>
    <p>This frees all resources associated with <em>thread</em> and returns the result of the whole hashing operation (the ``<em>digest</em>'').</p>
  </dd>
  <dt>
    void <strong>mhash_deinit</strong>(\s-1MHASH\s0 <em>thread</em>, void* digest);
  </dt>
  <dd>
    <p>This frees all resources associated with <em>thread</em> and stores the result of the whole hashing operation in memory pointed by <em>digest</em>. <em>digest</em> may be null.</p>
  </dd>
  <dt>
    void *<strong>mhash_hmac_end</strong>(\s-1MHASH\s0 <em>thread</em>);
  </dt>
  <dd>
    <p>This frees all resources associated with thread and returns the result of the whole hashing operation (the ``<em>mac</em>'').</p>
  </dd>
  <dt>
    int <strong>mhash_hmac_deinit</strong>(\s-1MHASH\s0 <em>thread</em>, void* digest);
  </dt>
  <dd>
    <p>This frees all resources associated with <em>thread</em> and stores the result of the whole hashing operation in memory pointed by digest. Digest may be null. Returns non-zero in case of an error.</p>
  </dd>
  <dt>
    void *<strong>mhash_end_m</strong>(\s-1MHASH\s0 <em>thread</em>, void* (*hash_malloc)(size_t));
  </dt>
  <dd>
    <p>This frees all resources associated with <em>thread</em> and returns the result of the whole hashing operation (the ``<em>digest</em>''). The result will be allocated by using the <em>hash_malloc()</em> function provided.</p>
  </dd>
  <dt>
    void *<strong>mhash_hmac_end</strong>(\s-1MHASH\s0 <em>thread</em>, void* (*hash_malloc)(size_t));
  </dt>
  <dd>
    <p>This frees all resources associated with thread and returns the result of the whole hashing operation (the ``<em>mac</em>''). The result will be allocated by using the <em>hash_malloc()</em> function provided.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KEYGEN API FUNCTIONS</h2>
        <div class="sectioncontent">
<p>We will now describe the Key Generation \s-1API\s0 of <strong>mhash</strong> in detail.</p>
<dl class='dl-vertical'>
  <dt>
    int <strong>mhash_keygen_ext</strong>(keygenid <em>algorithm</em>, \s-1KEYGEN\s0 <em>algorithm_data</em>, void* <em>keyword</em>, int <em>keysize</em>, unsigned char* <em>password</em>, int <em>passwordlen</em>);
  </dt>
  <dd>
    <p>This function, generates a key from a password. The password is read from <em>password</em> and it's len should be in <em>passwordlen</em>. The key generation algorithm is specified in <em>algorithm</em>, and that algorithm may (internally) use the \s-1KEYGEN\s0 structure. The \s-1KEYGEN\s0 structure consists of:  typedef struct keygen {</p>
<pre>
        hashid          hash_algorithm[2];
        unsigned int    count;
        void*           salt;
        int             salt_size;
</pre>
<p> } \s-1KEYGEN\s0; The algorithm(s) specified in <em>algorithm_data.hash_algorithm</em>, should be hash algorithms and may be used by the key generation algorithm. Some key generation algorithms may use more than one hash algorithms (view also <em>mhash_keygen_uses_hash_algorithm()</em>). If it is desirable (and supported by the algorithm, eg. \s-1KEYGEN_S2K_SALTED\s0) a salt may be specified in <em>algorithm_data.salt</em> of size <em>algorithm_data.salt_size</em> or may be \s-1NULL\s0. The algorithm may use the <em>algorithm_data.count</em> internally (eg. \s-1KEYGEN_S2K_ISALTED\s0). The generated keyword is stored in <em>keyword</em>, which should be (at least) <em>keysize</em> bytes long. The generated keyword is a binary one. Returns a negative number on failure.</p>
  </dd>
  <dt>
    int <strong>mhash_keygen_uses_salt</strong>( keygenid <em>algorithm</em>);
  </dt>
  <dd>
    <p>This function returns 1 if the specified key generation algorithm needs a salt to be specified.</p>
  </dd>
  <dt>
    int <strong>mhash_keygen_uses_count</strong>( keygenid <em>algorithm</em>);
  </dt>
  <dd>
    <p>This function returns 1 if the specified key generation algorithm needs the algorithm_data.count field in <em>mhash_keygen_ext()</em>. The count field tells the algorithm to hash repeatedly the password and to stop when <strong>count</strong> bytes have been processed.</p>
  </dd>
  <dt>
    int <strong>mhash_get_keygen_salt_size</strong>( keygenid <em>algorithm</em>);
  </dt>
  <dd>
    <p>This function returns the size of the salt size, that the specific <em>algorithm</em> will use. If it returns 0, then there is no limitation in the size.</p>
  </dd>
  <dt>
    int <strong>mhash_get_keygen_max_key_size</strong>( keygenid <em>algorithm</em>);
  </dt>
  <dd>
    <p>This function returns the maximum size of the key, that the key generation algorithm may produce. If it returns 0, then there is no limitation in the size.</p>
  </dd>
  <dt>
    int <strong>mhash_keygen_uses_hash_algorithm</strong>( keygenid <em>algorithm</em>);
  </dt>
  <dd>
    <p>This function returns the number of the hash algorithms the key generation algorithm will use. If it is 0 then no hash algorithm is used by the key generation algorithm. This is for the <em>algorithm_data.hash_algorithm</em> field in <em>mhash_keygen_ext()</em>. If</p>
  </dd>
  <dt>
    size_t <strong>mhash_keygen_count</strong>(void);
  </dt>
  <dd>
    <p>This returns the \*(C`keygenid\*(C' of the last available key generation algorithm. Algorithms are numbered from 0 to \*(C`mhash_keygen_count()\*(C'.</p>
  </dd>
  <dt>
    char *<strong>mhash_get_keygen_name</strong>(keygenid <em>type</em>);
  </dt>
  <dd>
    <p>If <em>type</em> exists, this returns the name of the keygen <em>type</em>. Otherwise, a \*(C`NULL\*(C' pointer is returned. The string is allocated with <em>malloc</em>\|(3) separately, so do not forget to <em>free</em>\|(3) it.</p>
  </dd>
  <dt>
    const char *<strong>mhash_get_keygen_name_static</strong>(keygenid <em>type</em>);
  </dt>
  <dd>
    <p>If <em>type</em> exists, this returns the name of the keygen <em>type</em>. Otherwise, a \*(C`NULL\*(C' pointer is returned.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>Hashing \s-1STDIN\s0 until \s-1EOF\s0.</p><p> #include &lt;mhash.h&gt;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;</p><p> int main(void)  {         int i;         MHASH td;         unsigned char buffer;         unsigned char hash[16]; /* enough size for MD5 */</p><p>        td = mhash_init(MHASH_MD5);</p><p>        if (td == MHASH_FAILED) <strong>exit</strong>(1);</p><p>        while (fread(&buffer, 1, 1, stdin) == 1) {                 mhash(td, &buffer, 1);         }</p><p>        mhash_deinit(td, hash);</p><p>        printf("Hash:");         for (i = 0; i &lt; mhash_get_block_size(MHASH_MD5); i++) {                 printf("%.2x", hash[i]);         }         printf("&#92;n");</p><p>        <strong>exit</strong>(0);  }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>An example program using \s-1HMAC:\s0</p><p> #include &lt;mhash.h&gt;  #include &lt;stdio.h&gt;</p><p> int main()  {</p><p>        char password[] = "Jefe";         int keylen = 4;         char data[] = "what do ya want for nothing?";         int datalen = 28;         MHASH td;         unsigned char mac[16];         int j;</p><p>        td = mhash_hmac_init(MHASH_MD5, password, keylen,                             mhash_get_hash_pblock(MHASH_MD5));</p><p>        mhash(td, data, datalen);         mhash_hmac_deinit(td, mac);</p><p> /*   * The output should be 0x750c783e6ab0b503eaa86e310a5db738   * according to RFC 2104.   */</p><p>        printf("0x");         for (j = 0; j &lt; mhash_get_block_size(MHASH_MD5); j++) {                 printf("%.2x", mac[j]);         }         printf("&#92;n");</p><p>        <strong>exit</strong>(0);  }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p>This library was originally written by <em>Nikos Mavroyanopoulos</em> &lt;nmav@hellug.gr&gt; who passed the project over to <em>Sascha Schumann</em> &lt;sascha@schumann.cx&gt; in May 1999. Sascha maintained it until March 2000. The library is now maintained by <em>Nikos Mavroyanopoulos</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>If you find any, please send a bug report (preferrably together with a patch) to the maintainer with a detailed description on how to reproduce the bug.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Sascha Schumann &lt;sascha@schumann.cx&gt; Nikos Mavroyanopoulos &lt;nmav@hellug.gr&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="memset.3.html"><span aria-hidden="true">&larr;</span> memset.3: Fill memory with a constant byte</a></li>
   <li class="next"><a href="midl.c.3.html">midl.c.3: Ldap bdb back-end id list functions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

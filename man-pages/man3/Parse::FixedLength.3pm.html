<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Parse::FixedLength: Parse an ascii string containing fixed length fields into component parts</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parse an ascii string containing fixed length fields into component parts">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Parse::FixedLength (3pm) manual">
  <meta name="twitter:description" content="Parse an ascii string containing fixed length fields into component parts">
  <meta name="twitter:image" content="https://www.carta.tech/images/libparse-fixedlength-perl-Parse::FixedLength-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Parse::FixedLength.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Parse::FixedLength (3pm) manual" />
  <meta property="og:description" content="Parse an ascii string containing fixed length fields into component parts" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libparse-fixedlength-perl-Parse::FixedLength-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Parse::FixedLength<small> (3pm)</small></h1>
        <p class="lead">Parse an ascii string containing fixed length fields into component parts</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Parse::FixedLength.3pm.html">
      <span itemprop="name">Parse::FixedLength: Parse an ascii string containing fixed length fields into component parts</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libparse-fixedlength-perl/">
      <span itemprop="name">libparse-fixedlength-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Parse::FixedLength.3pm.html">
      <span itemprop="name">Parse::FixedLength: Parse an ascii string containing fixed length fields into component parts</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use Parse::FixedLength qw(subclassed parsers);

    $parser = Parse::FixedLength-&gt;new(&#92;@format);
    $parser = Parse::FixedLength-&gt;new(&#92;@format, &#92;%parameters);
    $parser = Parse::FixedLength-&gt;new($format);
    $parser = Parse::FixedLength-&gt;new($format, &#92;%parameters);

    $hash_ref = $parser-&gt;parse($data);
    $data = $parser-&gt;pack($hash_ref);

    $converter = $parser1-&gt;converter($parser2);
    $converter = $parser1-&gt;converter($parser2, &#92;%mappings);
    $converter = $parser1-&gt;converter($parser2, &#92;@mappings);
    $converter = $parser1-&gt;converter($parser2, &#92;%mappings, &#92;%defaults);
    $converter = $parser1-&gt;converter($parser2, &#92;@maps, &#92;%dflts, &#92;%parms);

    $data_out = $converter-&gt;convert($data_in);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The \*(C`Parse::FixedLength\*(C' module facilitates the process of breaking a string into its fixed-length components. Sure, it's a glorified (and in some ways more limited) substitute for the perl functions pack and unpack, but it's my belief that this module helps in the maintainability of working with fixed length formats as the number of fields in a format grows.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARSING METHODS</h2>
        <div class="sectioncontent">
<h3>\fInew()\fP</h3>
<p> $parser = Parse::FixedLength-&gt;new(&#92;@format)  $parser = Parse::FixedLength-&gt;new(&#92;@format, &#92;%parameters)  $parser = Parse::FixedLength-&gt;new($format)  $parser = Parse::FixedLength-&gt;new($format, &#92;%parameters)</p><p>If the format argument is a string, then new will attempt to return the result of calling the new method for \*(L"Parse::FixedLength::$format\*(R". You can include the '$format' in the import list of the 'use Parse::FixedLength' statement if you want to require the format at compile time (See \s-1EXAMPLES\s0).</p><p>You can use ':all' as an argument in the import list, e.g., 'use Parse::Length qw(:all)', to require all available Parse::FixedLength::* modules, but obviously you can't use ':all' as a format argument in <em>new()</em>.</p><p>Otherwise the format must be an array reference of field names and lengths as either alternating elements, or delimited args in the same field, e.g.:</p><p>    my $parser = Parse::FixedLength-&gt;new([         first_name =&gt; 10,         last_name  =&gt; 10,         address    =&gt; 20,     ]);</p><p>    or:</p><p>    my $parser = Parse::FixedLength-&gt;new([qw(         first_name:10         last_name:10         address:20     )]);</p><p>If the first format is chosen, then no delimiter characters may appear in the field names (see delim option below).</p><p>To right justify a field (during the 'pack' method), an \*(L"R\*(R" may be appended to the length of the field followed by (optionally) the character to pad the string with (if no character follows the \*(L"R\*(R", then a space is assumed). This is somewhat inefficient, so its only recommended if actually necessary to preserve the format during operations such as math or converting format lengths. If its not needed but you'd like to specify it anyway for documentation purposes, you can use the no_justify option below. Also, it does change the data in the hash ref argument.</p><p>New (and barely tested): The length of the field may also be any valid format string for the perl functions pack/unpack which would return a single element.  E.g., this is valid:</p><p>    my $parser = Parse::FixedLength-&gt;new([qw(         first_name:10:1:10         last_name:10:11:20         address:20:21:40         flags:B16:41:42     )]);</p><p>But this is not valid since 'flags' would return 2 elements:</p><p>    my $parser = Parse::FixedLength-&gt;new([qw(         first_name:10:1:10         last_name:10:11:20         address:20:21:40         flags:C2:41:42     )]);</p><p>If a format without a known fixed length is used, then the length method, and start and end positions in the format should not be used.</p><p>The optional second argument to new is a hash ref which may contain any of the following keys:</p>
<dl class='dl-vertical'>
  <dt>
    delim
  </dt>
  <dd>
    <p>The delimiter used to separate the name and length in the format array. If another delimiter follows the length then the next two fields are assumed to be start and end position, and after that any 'extra' fields are ignored.  The package variable \s-1DELIM\s0 may also be used. (default: \*(L":\*(R")</p>
  </dd>
  <dt>
    href
  </dt>
  <dd>
    <p>A hash reference to parse the data into. Also, if no argument is passed to the pack method, the default hash reference used to pack the data into a fixed length string.</p>
  </dd>
  <dt>
    no_bless
  </dt>
  <dd>
    <p>Do not bless the hash ref returned from the parse method into a Hash-As-Object package. (default: false)</p>
  </dd>
  <dt>
    all_lengths
  </dt>
  <dd>
    <p>This option ignores any lengths supplied in the format argument (or allows having no length args in the format), and sets the lengths for all the fields to this value. As well as the obvious case where all formats are the same length, this can help facilitate converting from a non-fixed length format (where you just have field names) to a fixed-length format. (default: false)</p>
  </dd>
  <dt>
    autonum
  </dt>
  <dd>
    <p>This option controls the behavior of <em>new()</em> when duplicate field names are found. By default a fatal error will be generated if duplicate field names are found. If you have, e.g., some unused filler fields, then as the value to this option, you can either supply an arrayref containing valid duplicate names or a simple true value to accept all duplicate values. If there is more than one duplicate field, then when parsed, they will be renamed '&lt;name&gt;_1', '&lt;name&gt;_2', etc. (default: false)</p>
  </dd>
  <dt>
    spaces
  </dt>
  <dd>
    <p>If true, preserve trailing spaces during parse. (default: false)</p>
  </dd>
  <dt>
    no_justify
  </dt>
  <dd>
    <p>If true, ignore the \*(L"R\*(R" format option during pack. (default: false)</p>
  </dd>
  <dt>
    no_validate
  </dt>
  <dd>
    <p>By default, if two fields exist after the length argument in the format (delimited by whatever delimiter is set), then they are assumed to be the start and end position (starting at 1), of the field, and these fields are validated to be correct, and a fatal error will be generated if they are not correct.  If this option is true, then the start and end are not validated. (default: false)</p>
  </dd>
  <dt>
    trim
  </dt>
  <dd>
    <p>If true, trim leading pad characters from fields during parse. (default: false)</p>
  </dd>
  <dt>
    debug
  </dt>
  <dd>
    <p>If true, print field names and values during parsing and packing (as a quick format validation check). The package variable \s-1DEBUG\s0 may also be used. If a non-reference argument is given, output is sent to \s-1STDOUT\s0, otherwise we assume we have a filehandle open for writing. (default: false)</p>
  </dd>

</dl>

<h3>\fIparse()\fP</h3>
<p> $hash_ref = $parser-&gt;parse($string)  @ary      = $parser-&gt;parse($string)</p><p>This method takes a string and returns a hash reference of field names and values if called in scalar context, or just a list of the values if called in list context. The hash reference returned is an object, so you can either get/set values the normal way:</p><p>    $href-&gt;{key} = "value";     print "$href-&gt;{key}&#92;n";</p><p>or you can use methods:</p><p>    $href-&gt;key = "value";     print $href-&gt;key,"&#92;n";</p><p>For efficiency, the same hash reference is returned on each parse. If this is not acceptable, look into \*(L"parse_newref\*(R" or \*(L"parse_hash\*(R". See \s-1CAVEATS\s0.</p>
<h3>\fIparse_hash()\fP</h3>
<p> %hash = $parser-&gt;parse_hash($string)</p><p>Same as parse, but returns a hash array instead of a hash reference.</p>
<h3>\fIparse_newref()\fP</h3>
<p> $hash_ref = $parser-&gt;parse_newref($string)</p><p>Same as parse, but returns a different hash reference on every call, and the reference returned is not an object, just a plain old hashref.</p>
<h3>\fIpack()\fP</h3>
<p> $data = $parser-&gt;pack(&#92;%data_to_pack);</p><p>This method takes a hash reference of field names and values and returns a fixed length format output string.</p><p>If no argument is passed, then the hash reference used in the href option of the constructor is used.</p>
<h3>\fIhash_to_obj()\fP</h3>
<p> Parse::FixedLength-&gt;hash_to_obj($href);  $parser-&gt;hash_to_obj($href);</p><p>This turns a hash reference into an object where the keys of the hash can be used as methods for accessing or setting the values of the hash. This turns the hash into a semi-secure hash which is a sort of combination of Hash::AsObject and Tie::SecureHash in that no new keys will be added to the hash if only methods are used to access the hash. Hashes with the same set of keys are blessed into the same package, so adding keys to one hash may affect the methods allowed on another hash.</p>
<h3>\fItrim()\fP</h3>
<p> $parser-&gt;trim(@data);  $parser-&gt;trim(&#92;%data);</p><p>This method trims leading pad characters from the data. It is the method implicitly called during the parse method when the 'trim' option is set in <em>new()</em>. The data passed is modified, so there is no return value.</p>
<h3>\fInames()\fP</h3>
<p> $ary_ref = $parser-&gt;names;</p><p>Return an ordered arrayref of the field names.</p>
<h3>\fIformat_str()\fP</h3>
<p> $fmt_str = $parser-&gt;format_str;</p><p>Return the format string used for unpacking.</p>
<h3>\fIlength()\fP</h3>
<p> $tot_length   = $parser-&gt;length;  $field_length = $parser-&gt;length($name);</p><p>Returns the total length of all the fields, or of just one field name. E.g.:</p><p> # If there are no line feeds  while (read FH, $data, $parser-&gt;length) {   $parser-&gt;parse($data);   ...  }</p>
<h3>\fIdumper()\fP</h3>
<p> $parser-&gt;dumper($pos_as_comments);</p><p>Returns the parser's format layout information in a format suitable for cutting and pasting into the format array argument of a Parse::FixedFormat-&gt;<em>new()</em> call, and includes the start and end positions of all the fields (starting with position 1). If a true argument is supplied then it will include the start and ending positions as comments. E.g.:</p><p> # Assume the parser is from the ones defined in the new() example:  print $parser-&gt;<strong>dumper</strong>(1);</p><p> produces for first example:  first_name =&gt; 10, # 1-10  last_name =&gt; 10, # 11-20  address =&gt; 20, # 21-40</p><p> or for the second example:  print $parser-&gt;dumper;</p><p> first_name:10:1:10  last_name:10:11:20  address:20:21:40</p>
<h3>\fIconverter()\fP</h3>
<p> $converter = $parser1-&gt;converter($parser2, &#92;@maps, &#92;%dflts, &#92;%parms);</p><p>Returns a format converting object. $parser1 is the parsing object to convert from, $parser2 is the parsing object to convert to.</p><p>By default, common field names will be mapped from one format to the other. Fields with different names can be mapped from the first format to the other (or you can override the default) using the second argument. The keys are the source field names and the corresponding values are the target field names. This argument can be a hash ref or an array ref since you may want to map one source field to more than one target field.</p><p>Defaults for any field in the target format can be supplied using the third argument, where the keys are the field names of the target format, and the value can be a scalar constant, or a subroutine reference where the first argument is simply the mapped value (or the empty string if there was no mapping), and the second argument is the entire hash reference that results from parsing the data with the 'from' parser object. E.g. if you were mapping from a separate 'zip' and 'plus_4' field to a 'zip_plus_4' field, you could map 'zip' to 'zip_plus_4' and then supply as one of the key/value pairs in the 'defaults' hash ref the following:</p><p> zip_plus_4 =&gt; sub { shift() . $_[0]{plus_4} }</p><p>The fourth argument is an optional hash ref may which may contain the following:</p>
<dl class='dl-vertical'>
  <dt>
    no_pack
  </dt>
  <dd>
    <p>If true, the <em>convert()</em> method will return a hash reference instead of packing the data into an ascii string (Default: false).</p>
  </dd>

</dl>

<h3>\fIconvert()\fP</h3>
<p> $data_out = $converter-&gt;convert($data_in);  $data_out = $converter-&gt;convert($data_in, $no_pack);  $data_out = $converter-&gt;convert(&#92;%hash);  $data_out = $converter-&gt;convert(&#92;%hash, $no_pack);</p><p>Converts a string or a hash reference from one fixed length format to another. If a second argument is supplied, it will override the converter's no_pack option setting.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>    use Parse::FixedLength;</p><p>    # Include start and end position for extra check     # of format integrity     my $parser = Parse::FixedLength-&gt;new([         first_name =&gt; &apos;10:1:10&apos;,         last_name  =&gt; &apos;10:11:20&apos;,         widgets_this_month =&gt; &apos;5R0:21:25&apos;,     ]);</p><p>    # Do a simple name casing of names     # and print widgets projected for the year for each person     while (&lt;DATA&gt;) {         warn "No record terminator found!&#92;n" unless chomp;         warn "Short Record!&#92;n" unless $parser-&gt;length == length;         my $data = $parser-&gt;parse($_);         # See Lingua::EN::NameCase for a real attempt at name casing         s/(&#92;w+)/&#92;u&#92;L$1/g for @$data{qw(first_name last_name)};         $data-&gt;{widgets_this_month} *= 12;         print $parser-&gt;pack($data), "&#92;n";     }     _\|_DATA_\|_     BOB       JONES     00024     JOHN      SMITH     00005     JANE      DOE       00007</p><p>    Another way if we&apos;re converting formats:</p><p>    my $parser1 = Parse::FixedLength-&gt;new([         first_name =&gt; 10,         last_name  =&gt; 10,         widgets_this_month =&gt; &apos;5R0&apos;,     ]);</p><p>    my $parser2 = Parse::FixedLength-&gt;new([qw(         seq_id:10         first_name:10         last_name:10         country:3         widgets_this_year:10R0     )]);</p><p>    my $converter = $parser1-&gt;converter($parser2, {         widgets_this_month =&gt; "widgets_this_year",     },{         seq_id =&gt; do { my $cnt = &apos;0&apos; x $parser2-&gt;length(&apos;seq_id&apos;);                        sub { ++$cnt };                      },         widgets_this_year =&gt; sub { 12 * shift },         country =&gt; &apos;USA&apos;,     });</p><p>    while (&lt;DATA&gt;) {         warn "No record terminator found!&#92;n" unless chomp;         warn "Short Record!&#92;n" unless $parser1-&gt;length == length;         print $converter-&gt;convert($_), "&#92;n";     }</p><h3>Subclassing Example</h3>
<p>    # Must be installed as Parse/FixedLength/DrugCo100.pm     # somewhere in @INC path.     package Parse::FixedLength::DrugCo100;</p><p>    use Parse::FixedLength;     our @ISA = qw(Parse::FixedLength);</p><p>    sub new {         my $proto = shift;         my $class = ref($proto) || $proto;         $flags = shift || {};         die "Options arg not a hash ref"             unless UNIVERSAL::isa($flags,&apos;HASH&apos;);         $$flags{autonum} = [&apos;filler&apos;];         bless $class-&gt;SUPER::new([qw(             stuff:40             filler:10             more_stuff:40             filler:10         )], $flags), $class;     }</p><p>    Then in main script:</p><p>    # Import list on use statement is optional, but     # will cause require at compile time rather than run time.     use Parse::FixedLength qw(DrugCo100);     my $parser = Parse::FixedLength-&gt;new(&apos;DrugCo100&apos;);     etc...</p><p>    # Or of course you could just:     use Parse::FixedLength::DrugCo100;     my $parser = Parse::FixedLength::Drugco100-&gt;new;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>Mentioned in the documentation for \*(L"parse\*(R", repeated here:</p><p>For efficiency, a parser object will return the same hash reference on every call to parse. Therefore, any code such as this which tries to save every record will not work:</p><p>    while (&lt;&gt;) {         my $href = $parser-&gt;parse($_);         push @array, $href; # Refers to same hash every time     }</p><p>and should be changed to this:</p><p>    while (&lt;&gt;) {         my $href = $parser-&gt;parse_newref($_);         push @array, $href;     }</p><p>or this:</p><p>    while (&lt;&gt;) {         my $href = $parser-&gt;parse($_);         push @array, { %$href };     }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p> Douglas Wilson &lt;dougw@cpan.org&gt;  original by Terrence Brannon &lt;tbone@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p> This module is free software; you can redistribute it and/or  modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Parse::FixedLength&hellip;</h2>
        <div class="sectioncontent">
<p>Other glorified substitutes for pack/unpack: Text::FixedLength, Data::FixedFormat, AnyData::Format::Fixed (although the AnyData module is part of a larger collection of modules which facilitates converting data between many different kinds of formats, and using \s-1SQL\s0 to query those data sources via DBD::AnyData).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Parse::DebControl::Patch.3pm.html"><span aria-hidden="true">&larr;</span> Parse::DebControl::Patch.3pm: Easy oo parsing of debian patch file metadata (dep3) data</a></li>
   <li class="next"><a href="Parse::MediaWikiDump.3pm.html">Parse::MediaWikiDump.3pm: Tools to process mediawiki dump files <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

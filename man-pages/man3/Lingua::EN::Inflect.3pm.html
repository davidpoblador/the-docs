<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Lingua::EN::Inflect: Convert singular to plural. select "a" or "an".</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Convert singular to plural. select "a" or "an".">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Lingua::EN::Inflect (3pm) manual">
  <meta name="twitter:description" content="Convert singular to plural. select "a" or "an".">
  <meta name="twitter:image" content="https://www.carta.tech/images/liblingua-en-inflect-perl-Lingua::EN::Inflect-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Lingua::EN::Inflect.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Lingua::EN::Inflect (3pm) manual" />
  <meta property="og:description" content="Convert singular to plural. select "a" or "an"." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/liblingua-en-inflect-perl-Lingua::EN::Inflect-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Lingua::EN::Inflect<small> (3pm)</small></h1>
        <p class="lead">Convert singular to plural. select "a" or "an".</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Lingua::EN::Inflect.3pm.html">
      <span itemprop="name">Lingua::EN::Inflect: Convert singular to plural. select "a" or "an".</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/liblingua-en-inflect-perl/">
      <span itemprop="name">liblingua-en-inflect-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Lingua::EN::Inflect.3pm.html">
      <span itemprop="name">Lingua::EN::Inflect: Convert singular to plural. select "a" or "an".</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes version 1.895 of Lingua::EN::Inflect</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Lingua::EN::Inflect qw ( PL PL_N PL_V PL_ADJ NO NUM
                  PL_eq PL_N_eq PL_V_eq PL_ADJ_eq
                  A AN
                  PART_PRES
                  ORD NUMWORDS
                  WORDLIST
                  inflect classical
                  def_noun def_verb def_adj def_a def_an );


 # UNCONDITIONALLY FORM THE PLURAL

      print "The plural of ", $word, " is ", PL($word), "&#92;n";


 # CONDITIONALLY FORM THE PLURAL

      print "I saw $cat_count ", PL("cat",$cat_count), "&#92;n";


 # FORM PLURALS FOR SPECIFIC PARTS OF SPEECH

      print PL_N("I",$N1), PL_V("saw",$N1),
        PL_ADJ("my",$N2), PL_N("saw",$N2), "&#92;n";


 # DEAL WITH "0/1/N" -&gt; "no/1/N" TRANSLATION:

      print "There ", PL_V("was",$errors), NO(" error",$errors), "&#92;n";


 # USE DEFAULT COUNTS:

      print NUM($N1,""), PL("I"), PL_V(" saw"), NUM($N2), PL_N(" saw");
      print "There ", NUM($errors,&apos;&apos;), PL_V("was"), NO(" error"), "&#92;n";


 # COMPARE TWO WORDS "NUMBER-INSENSITIVELY":

      print "same&#92;n"      if PL_eq($word1, $word2);
      print "same noun&#92;n" if PL_N_eq($word1, $word2);
      print "same verb&#92;n" if PL_V_eq($word1, $word2);
      print "same adj.&#92;n" if PL_ADJ_eq($word1, $word2);


 # ADD CORRECT "a" OR "an" FOR A GIVEN WORD:

      print "Did you want ", A($thing), " or ", AN($idea), "&#92;n";


 # CONVERT NUMERALS INTO ORDINALS (i.e. 1-&gt;1st, 2-&gt;2nd, 3-&gt;3rd, etc.)

      print "It was", ORD($position), " from the left&#92;n";

 # CONVERT NUMERALS TO WORDS (i.e. 1-&gt;"one", 101-&gt;"one hundred and one", etc.)
 # IN A SCALAR CONTEXT: GET BACK A SINGLE STRING...

    $words = NUMWORDS(1234);      # "one thousand, two hundred and thirty-four"
    $words = NUMWORDS(ORD(1234)); # "one thousand, two hundred and thirty-fourth"


 # IN A LIST CONTEXT: GET BACK A LIST OF STRINGSi, ONE FOR EACH "CHUNK"...

    @words = NUMWORDS(1234);    # ("one thousand","two hundred and thirty-four")


 # OPTIONAL PARAMETERS CHANGE TRANSLATION:

    $words = NUMWORDS(12345, group=&gt;1);
                # "one, two, three, four, five"

    $words = NUMWORDS(12345, group=&gt;2);
                # "twelve, thirty-four, five"

    $words = NUMWORDS(12345, group=&gt;3);
                # "one twenty-three, forty-five"

    $words = NUMWORDS(1234, &apos;and&apos;=&gt;&apos;&apos;);
                # "one thousand, two hundred thirty-four"

    $words = NUMWORDS(1234, &apos;and&apos;=&gt;&apos;, plus&apos;);
                # "one thousand, two hundred, plus thirty-four"

    $words = NUMWORDS(555_1202, group=&gt;1, zero=&gt;&apos;oh&apos;);
                # "five, five, five, one, two, oh, two"

    $words = NUMWORDS(555_1202, group=&gt;1, one=&gt;&apos;unity&apos;);
                # "five, five, five, unity, two, oh, two"

    $words = NUMWORDS(123.456, group=&gt;1, decimal=&gt;&apos;mark&apos;);
                # "one two three mark four five six"
</pre>
<p># \s-1LITERAL\s0 \s-1STYLE\s0 \s-1ONLY\s0 \s-1NAMES\s0 \s-1NUMBERS\s0 \s-1LESS\s0 \s-1THAN\s0 A \s-1CERTAIN\s0 \s-1THRESHOLD\s0...</p><p>    $words = NUMWORDS(   9, threshold=&gt;10);    # "nine"     $words = NUMWORDS(  10, threshold=&gt;10);    # "ten"     $words = NUMWORDS(  11, threshold=&gt;10);    # "11"     $words = NUMWORDS(1000, threshold=&gt;10);    # "1,000"</p><p> # JOIN WORDS INTO A LIST:</p><p>    $list = WORDLIST("apple", "banana", "carrot");                 # "apple, banana, and carrot"</p><p>    $list = WORDLIST("apple", "banana");                 # "apple and banana"</p><p>    $list = WORDLIST("apple", "banana", "carrot", {final_sep=&gt;""});                 # "apple, banana and carrot"</p><p> # REQUIRE "CLASSICAL" PLURALS (EG: "focus"-&gt;"foci", "cherub"-&gt;"cherubim")</p><p>      classical;          # USE ALL CLASSICAL PLURALS</p><p>      classical 1;           #  USE ALL CLASSICAL PLURALS       classical 0;           #  USE ALL MODERN PLURALS (DEFAULT)</p><p>      classical &apos;zero&apos;;      #  "no error" INSTEAD OF "no errors"       classical zero=&gt;1;     #  "no error" INSTEAD OF "no errors"       classical zero=&gt;0;     #  "no errors" INSTEAD OF "no error"</p><p>      classical &apos;herd&apos;;      #  "2 buffalo" INSTEAD OF "2 buffalos"       classical herd=&gt;1;     #  "2 buffalo" INSTEAD OF "2 buffalos"       classical herd=&gt;0;     #  "2 buffalos" INSTEAD OF "2 buffalo"</p><p>      classical &apos;persons&apos;;   # "2 chairpersons" INSTEAD OF "2 chairpeople"       classical persons=&gt;1;  # "2 chairpersons" INSTEAD OF "2 chairpeople"       classical persons=&gt;0;  # "2 chairpeople" INSTEAD OF "2 chairpersons"</p><p>      classical &apos;ancient&apos;;   # "2 formulae" INSTEAD OF "2 formulas"       classical ancient=&gt;1;  # "2 formulae" INSTEAD OF "2 formulas"       classical ancient=&gt;0;  # "2 formulas" INSTEAD OF "2 formulae"</p><p> # INTERPOLATE "PL()", "PL_N()", "PL_V()", "PL_ADJ()", A()", "AN()"  # "NUM()" AND "ORD()" WITHIN STRINGS:</p><p>      print inflect("The plural of $word is PL($word)&#92;n");       print inflect("I saw $cat_count PL("cat",$cat_count)&#92;n");       print inflect("PL(I,$N1) PL_V(saw,$N1) PL(a,$N2) PL_N(saw,$N2)");       print inflect("NUM($N1,)PL(I) PL_V(saw) NUM($N2,)PL(a) PL_N(saw)");       print inflect("I saw NUM($cat_count) PL("cat")&#92;nNUM()");       print inflect("There PL_V(was,$errors) NO(error,$errors)&#92;n");       print inflect("There NUM($errors,) PL_V(was) NO(error)&#92;n";       print inflect("Did you want A($thing) or AN($idea)&#92;n");       print inflect("It was ORD($position) from the left&#92;n");</p><p> # ADD USER-DEFINED INFLECTIONS (OVERRIDING INBUILT RULES):</p><p>      def_noun  "VAX"  =&gt; "VAXen";  # SINGULAR =&gt; PLURAL</p><p>      def_verb  "will" =&gt; "shall",  # 1ST PERSON SINGULAR =&gt; PLURAL                 "will" =&gt; "will",   # 2ND PERSON SINGULAR =&gt; PLURAL                 "will" =&gt; "will",   # 3RD PERSON SINGULAR =&gt; PLURAL</p><p>      def_adj   "hir"  =&gt; "their",  # SINGULAR =&gt; PLURAL</p><p>      def_a "h"         # "AY HALWAYS SEZ &apos;HAITCH&apos;!"</p><p>      def_an    "horrendous.*"      # "AN HORRENDOUS AFFECTATION"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The exportable subroutines of Lingua::EN::Inflect provide plural inflections, \*(L"a\*(R"/\*(L"an\*(R" selection for English words, and manipulation of numbers as words</p><p>Plural forms of all nouns, most verbs, and some adjectives are provided. Where appropriate, \*(L"classical\*(R" variants (for example: \*(L"brother\*(R" -&gt; \*(L"brethren\*(R", \*(L"dogma\*(R" -&gt; \*(L"dogmata\*(R", etc.) are also provided.</p><p>Pronunciation-based \*(L"a\*(R"/\*(L"an\*(R" selection is provided for all English words, and most initialisms.</p><p>It is also possible to inflect numerals (1,2,3) to ordinals (1st, 2nd, 3rd) and to English words (\*(L"one\*(R", \*(L"two\*(R", "three).</p><p>In generating these inflections, Lingua::EN::Inflect follows the Oxford English Dictionary and the guidelines in Fowler's Modern English Usage, preferring the former where the two disagree.</p><p>The module is built around standard British spelling, but is designed to cope with common American variants as well. Slang, jargon, and other English dialects are <em>not</em> explicitly catered for.</p><p>Where two or more inflected forms exist for a single word (typically a \*(L"classical\*(R" form and a \*(L"modern\*(R" form), Lingua::EN::Inflect prefers the more common form (typically the \*(L"modern\*(R" one), unless \*(L"classical\*(R" processing has been specified (see \*(L"\s-1MODERN\s0 \s-1VS\s0 \s-1CLASSICAL\s0 \s-1INFLECTIONS\s0\*(R").</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FORMING PLURALS</h2>
        <div class="sectioncontent">
<h3>Inflecting Plurals</h3>
<p>All of the \*(C`PL_...\*(C' plural inflection subroutines take the word to be inflected as their first argument and return the corresponding inflection. Note that all such subroutines expect the <em>singular</em> form of the word. The results of passing a plural form are undefined (and unlikely to be correct).</p><p>The \*(C`PL_...\*(C' subroutines also take an optional second argument, which indicates the grammatical \*(L"number\*(R" of the word (or of another word with which the word being inflected must agree). If the \*(L"number\*(R" argument is supplied and is not 1 (or "one" or "a", or some other adjective that implies the singular), the plural form of the word is returned. If the \*(L"number\*(R" argument <em>does</em> indicate singularity, the (uninflected) word itself is returned. If the number argument is omitted, the plural form is returned unconditionally.</p><p>The various subroutines are: The exportable subroutine \*(C`PL_N()\*(C' takes a <em>singular</em> English noun or pronoun and returns its plural. Pronouns in the nominative (\*(L"I\*(R" -&gt; \*(L"we\*(R") and accusative (\*(L"me\*(R" -&gt; \*(L"us\*(R") cases are handled, as are possessive pronouns (\*(L"mine\*(R" -&gt; \*(L"ours\*(R"). The exportable subroutine \*(C`PL_V()\*(C' takes the <em>singular</em> form of a conjugated verb (that is, one which is already in the correct \*(L"person\*(R" and \*(L"mood\*(R") and returns the corresponding plural conjugation. The exportable subroutine \*(C`PL_ADJ()\*(C' takes the <em>singular</em> form of certain types of adjectives and returns the corresponding plural form. Adjectives that are correctly handled include: \*(L"numerical\*(R" adjectives (\*(L"a\*(R" -&gt; \*(L"some\*(R"), demonstrative adjectives (\*(L"this\*(R" -&gt; \*(L"these\*(R", \*(L"that\*(R" -&gt; \*(L"those\*(R"), and possessives (\*(L"my\*(R" -&gt; \*(L"our\*(R", \*(L"cat's\*(R" -&gt; \*(L"cats'\*(R", \*(L"child's\*(R" -&gt; \*(L"childrens'\*(R", etc.) The exportable subroutine \*(C`PL()\*(C' takes a <em>singular</em> English noun, pronoun, verb, or adjective and returns its plural form. Where a word has more than one inflection depending on its part of speech (for example, the noun \*(L"thought\*(R" inflects to \*(L"thoughts\*(R", the verb \*(L"thought\*(R" to \*(L"thought\*(R"), the (singular) noun sense is preferred to the (singular) verb sense. Hence \*(C`PL("knife")\*(C' will return \*(L"knives\*(R" (\*(L"knife\*(R" having been treated as a singular noun), whereas \*(C`PL("knifes")\*(C' will return \*(L"knife\*(R" (\*(L"knifes\*(R" having been treated as a 3rd person singular verb). The inherent ambiguity of such cases suggests that, where the part of speech is known, \*(C`PL_N\*(C', \*(C`PL_V\*(C', and \*(C`PL_ADJ\*(C' should be used in preference to \*(C`PL\*(C'.</p><p>Note that all these subroutines ignore any whitespace surrounding the word being inflected, but preserve that whitespace when the result is returned. For example, \*(C`PL("&nbsp;cat&nbsp;&nbsp;")\*(C' returns \*(L"&nbsp;cats&nbsp;&nbsp;\*(R".</p>
<h3>Numbered plurals</h3>
<p>The \*(C`PL_...\*(C' subroutines return only the inflected word, not the count that was used to inflect it. Thus, in order to produce \*(L"I saw 3 ducks\*(R", it is necessary to use:</p><p>    print "I saw $N ", PL_N($animal,$N), "&#92;n";</p><p>Since the usual purpose of producing a plural is to make it agree with a preceding count, Lingua::EN::Inflect provides an exportable subroutine (\*(C`NO($;$)\*(C') which, given a word and a(n optional) count, returns the count followed by the correctly inflected word. Hence the previous example can be rewritten:</p><p>    print "I saw ", NO($animal,$N), "&#92;n";</p><p>In addition, if the count is zero (or some other term which implies zero, such as "zero", "nil", etc.) the count is replaced by the word \*(L"no\*(R". Hence, if $N had the value zero, the previous example would print the somewhat more elegant:</p><p>    I saw no animals</p><p>rather than:</p><p>    I saw 0 animals</p><p>Note that the name of the subroutine is a pun: the subroutine returns either a number (a <em>No.</em>) or a "no", in front of the inflected word.</p><p><em>Wordy and comma'd plurals</em></p><p>The \*(C`NO()\*(C' subroutine takes an optional third argument: a hash of named options that configure its behaviour.</p><p>The &apos;words_below&apos; option informs \*(C`NO()\*(C' what other numbers (i.e. apart from zero) it should convert to words. For example:S</p><p>    for my $count (0..12) {         print NO(&apos;cat&apos;, $count, {words_below =&gt; 10}), "&#92;n";     }</p><p>would print:</p><p>    no cats     one cat     two cats     three cats     four cats     five cats     six cats     seven cats     eight cats     nine cats     10 cats     11 cats     12 cats</p><p>The &apos;comma&apos; and &apos;comma_every&apos; options determine whether or not the numbers produced by \*(C`NO()\*(C' have commas in them. That is:</p><p>    2001 space odysseys</p><p>versus:</p><p>    2,001 space odysseys</p><p>Normally, numbers are produced without commas, but if &apos;comma&apos; or &apos;comma_every&apos; is specified, then commas are added as requested.</p><p>The &apos;comma&apos; option specifies which character to use as a comma. It defaults to &apos;,&apos;, but may be set to anything convenient:</p><p>    print NO(&apos;Euro&apos;, $amount, {comma=&gt;&apos;.&apos;});</p><p>    # prints:  1.000.000 Euros</p><p>The &apos;comma_every&apos; option specifies how many characters between commas. It defaults to 3, but may be set to any positive number:</p><p>    print NO(&apos;Euro&apos;, $amount, {comma_every=&gt;4});</p><p>    # prints:  100,0000 Euros</p><p>Note that you can set both options at once, if you wish:</p><p>    print NO(&apos;Euro&apos;, $amount, {comma_every=&gt;2, comma=&gt;&apos;_&apos;});</p><p>    # prints:  1_00_00_00 Euros</p>
<h3>Reducing the number of counts required</h3>
<p>In some contexts, the need to supply an explicit count to the various \*(C`PL_...\*(C' subroutines makes for tiresome repetition. For example:</p><p>    print PL_ADJ("This",$errors), PL_N(" error",$errors),           PL_V(" was",$errors), " fatal.&#92;n";</p><p>Lingua::EN::Inflect therefore provides an exportable subroutine (\*(C`NUM($;$)\*(C') which may be used to set a persistent \*(L"default number\*(R" value. If such a value is set, it is subsequently used whenever an optional second \*(L"number\*(R" argument is omitted. The default value thus set can subsequently be removed by calling \*(C`NUM()\*(C' with no arguments. Hence we could rewrite the previous example:</p><p>    NUM($errors);     print PL_ADJ("This"), PL_N(" error"), PL_V(" was"), "fatal.&#92;n";     NUM();</p><p>Normally, \*(C`NUM()\*(C' returns its first argument, so that it may also be \*(L"inlined\*(R" in contexts like:</p><p>    print NUM($errors), PL_N(" error"), PL_V(" was"), " detected.&#92;n"     print PL_ADJ("This"), PL_N(" error"), PL_V(" was"), "fatal.&#92;n"         if $severity &gt; 1;</p><p>However, in certain contexts (see \*(L"\s-1INTERPOLATING\s0 \s-1INFLECTIONS\s0 \s-1IN\s0 \s-1STRINGS\s0\*(R") it is preferable that \*(C`NUM()\*(C' return an empty string. Hence \*(C`NUM()\*(C' provides an optional second argument. If that argument is supplied (that is, if it is defined) and evaluates to false, \*(C`NUM\*(C' returns an empty string instead of its first argument. For example:</p><p>    print NUM($errors,0), NO("error"), PL_V(" was"), " detected.&#92;n";     print PL_ADJ("This"), PL_N(" error"), PL_V(" was"), "fatal.&#92;n"         if $severity &gt; 1;</p>
<h3>Number-insensitive equality</h3>
<p>Lingua::EN::Inflect also provides a solution to the problem of comparing words of differing plurality through the exportable subroutines \*(C`PL_eq($$)\*(C', \*(C`PL_N_eq($$)\*(C', \*(C`PL_V_eq($$)\*(C', and \*(C`PL_ADJ_eq($$)\*(C'. Each  of these subroutines takes two strings, and  compares them using the corresponding plural-inflection subroutine (\*(C`PL()\*(C', \*(C`PL_N()\*(C', \*(C`PL_V()\*(C', and \*(C`PL_ADJ()\*(C' respectively).</p><p>The comparison returns true if:</p><ul>
<li><p>the strings are \*(C`eq\*(C'-equal, or</p></li><li><p>one string is \*(C`eq\*(C'-equal to a plural form of the other, or</p></li><li><p>the strings are two different plural forms of the one word.</p></li>
</ul><p>Hence all of the following return true:</p><p>    PL_eq("index","index")      # RETURNS "eq"     PL_eq("index","indexes")    # RETURNS "s:p"     PL_eq("index","indices")    # RETURNS "s:p"     PL_eq("indexes","index")    # RETURNS "p:s"     PL_eq("indices","index")    # RETURNS "p:s"     PL_eq("indices","indexes")  # RETURNS "p:p"     PL_eq("indexes","indices")  # RETURNS "p:p"     PL_eq("indices","indices")  # RETURNS "eq"</p><p>As indicated by the comments in the previous example, the actual value returned by the various \*(C`PL_eq\*(C' subroutines encodes which of the three equality rules succeeded: \*(L"eq\*(R" is returned if the strings were identical, \*(L"s:p\*(R" if the strings were singular and plural respectively, \*(L"p:s\*(R" for plural and singular, and \*(L"p:p\*(R" for two distinct plurals. Inequality is indicated by returning an empty string.</p><p>It should be noted that two distinct singular words which happen to take the same plural form are <em>not</em> considered equal, nor are cases where one (singular) word's plural is the other (plural) word's singular. Hence all of the following return false:</p><p>    PL_eq("base","basis")       # ALTHOUGH BOTH -&gt; "bases"     PL_eq("syrinx","syringe")   # ALTHOUGH BOTH -&gt; "syringes"     PL_eq("she","he")       # ALTHOUGH BOTH -&gt; "they"</p><p>    PL_eq("opus","operas")      # ALTHOUGH "opus" -&gt; "opera" -&gt; "operas"     PL_eq("taxi","taxes")       # ALTHOUGH "taxi" -&gt; "taxis" -&gt; "taxes"</p><p>Note too that, although the comparison is \*(L"number-insensitive\*(R" it is <em>not</em> case-insensitive (that is, \*(C`PL("time","Times")\*(C' returns false. To obtain both number and case insensitivity, prefix both arguments with \*(C`lc\*(C' (that is, \*(C`PL(lc "time", lc "Times")\*(C' returns true).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER VERB FORMS</h2>
        <div class="sectioncontent">
<h3>Present participles</h3>
<p>\*(C`Lingua::EN::Inflect\*(C' also provides the \*(C`PART_PRES\*(C' subroutine, which can take a 3rd person singular verb and correctly inflect it to its present participle:</p><p>    PART_PRES("runs")   # "running"     PART_PRES("loves")  # "loving"     PART_PRES("eats")   # "eating"     PART_PRES("bats")   # "batting"     PART_PRES("spies")  # "spying"</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROVIDING INDEFINITE ARTICLES</h2>
        <div class="sectioncontent">
<h3>Selecting indefinite articles</h3>
<p>Lingua::EN::Inflect provides two exportable subroutines (\*(C`A($;$)\*(C' and \*(C`AN($;$)\*(C') which will correctly prepend the appropriate indefinite article to a word, depending on its pronunciation. For example:</p><p>    A("cat")        # -&gt; "a cat"     AN("cat")       # -&gt; "a cat"     A("euphemism")      # -&gt; "a euphemism"     A("Euler number")   # -&gt; "an Euler number"     A("hour")       # -&gt; "an hour"     A("houri")      # -&gt; "a houri"</p><p>The two subroutines are <em>identical</em> in function and may be used interchangeably. The only reason that two versions are provided is to enhance the readability of code such as:</p><p>    print "That is ", AN($errortype), " error&#92;n;     print "That is ", A($fataltype), " fatal error&#92;n;</p><p>Note that in both cases the actual article provided depends <em>only</em> on the pronunciation of the first argument, <em>not</em> on the name of the subroutine.</p><p>\*(C`A()\*(C' and \*(C`AN()\*(C' will ignore any indefinite article that already exists at the start of the string. Thus:</p><p>    @half_arked = (         "a elephant",         "a giraffe",         "an ewe",         "a orangutan",     );</p><p>    print A($_), "&#92;n" for @half_arked;</p><p>    # prints:     #     an elephant     #     a giraffe     #     a ewe     #     an orangutan</p><p>\*(C`A()\*(C' and \*(C`AN()\*(C' both take an optional second argument. As with the \*(C`PL_...\*(C' subroutines, this second argument is a \*(L"number\*(R" specifier. If its value is 1 (or some other value implying singularity), \*(C`A()\*(C' and \*(C`AN()\*(C' insert \*(L"a\*(R" or \*(L"an\*(R" as appropriate. If the number specifier implies plurality, (\*(C`A()\*(C' and \*(C`AN()\*(C' insert the actual second argument instead. For example:</p><p>    A("cat",1)      # -&gt; "a cat"     A("cat",2)      # -&gt; "2 cat"     A("cat","one")      # -&gt; "one cat"     A("cat","no")       # -&gt; "no cat"</p><p>Note that, as implied by the previous examples, \*(C`A()\*(C' and \*(C`AN()\*(C' both assume that their job is merely to provide the correct qualifier for a word (that is: \*(L"a\*(R", \*(L"an\*(R", or the specified count). In other words, they assume that the word they are given has already been correctly inflected for plurality. Hence, if $N has the value 2, then:</p><p>      print A("cat",$N);</p><p>prints \*(L"2 cat\*(R", instead of \*(L"2 cats\*(R". The correct approach is to use:</p><p>      print A(PL("cat",$N),$N);</p><p>or, better still:</p><p>      print NO("cat",$N);</p><p>Note too that, like the various \*(C`PL_...\*(C' subroutines, whenever \*(C`A()\*(C' and \*(C`AN()\*(C' are called with only one argument they are subject to the effects of any preceding call to \*(C`NUM()\*(C'. Hence, another possible solution is:</p><p>      NUM($N);       print A(PL("cat"));</p>
<h3>Indefinite articles and initialisms</h3>
<p>\*(L"Initialisms\*(R" (sometimes inaccurately called \*(L"acronyms\*(R") are terms which have been formed from the initial letters of words in a phrase (for example, \*(L"\s-1NATO\s0\*(R", \*(L"\s-1NBL\s0\*(R", \*(L"S.O.S.\*(R", \*(L"\s-1SCUBA\s0\*(R", etc.)</p><p>Such terms present a particular challenge when selecting between \*(L"a\*(R" and \*(L"an\*(R", since they are sometimes pronounced as if they were a single word (\*(L"nay-tow\*(R", \*(L"sku-ba\*(R") and sometimes as a series of letter names (\*(L"en-eff-ell\*(R", \*(L"ess-oh-ess\*(R").</p><p>\*(C`A()\*(C' and \*(C`AN()\*(C' cope with this dichotomy using a series of inbuilt rules, which may be summarized as:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>If the word starts with a single letter, followed by a period or dash (for example, \*(L"R.I.P.\*(R", \*(L"C.O.D.\*(R", \*(L"e-mail\*(R", \*(L"X-ray\*(R", \*(L"T-square\*(R"), then choose the appropriate article for the <em>sound</em> of the first letter (\*(L"an R.I.P.\*(R", \*(L"a C.O.D.\*(R", \*(L"an e-mail\*(R", \*(L"an X-ray\*(R", \*(L"a T-square\*(R").</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>If the first two letters of the word are capitals, consonants, and do not appear at the start of any known English word, (for example, \*(L"\s-1LCD\s0\*(R", \*(L"\s-1XML\s0\*(R", \*(L"\s-1YWCA\s0\*(R"), then once again choose \*(L"a\*(R" or \*(L"an\*(R" depending on the <em>sound</em> of the first letter (\*(L"an \s-1LCD\s0\*(R", \*(L"an \s-1XML\s0\*(R", \*(L"a \s-1YWCA\s0\*(R").</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Otherwise, assume the string is a capitalized word or a pronounceable initialism (for example, \*(L"\s-1LED\s0\*(R", \*(L"\s-1OPEC\s0\*(R", \*(L"\s-1FAQ\s0\*(R", \*(L"\s-1UNESCO\s0\*(R"), and therefore takes \*(L"a\*(R" or \*(L"an\*(R" according to the (apparent) pronunciation of the entire word (\*(L"a \s-1LED\s0\*(R", \*(L"an \s-1OPEC\s0\*(R", \*(L"a \s-1FAQ\s0\*(R", \*(L"a \s-1UNESCO\s0\*(R").</p>
  </dd>

</dl>
<p>Note that rules 1 and 3 together imply that the presence or absence of punctuation may change the selection of indefinite article for a particular initialism (for example, \*(L"a \s-1FAQ\s0\*(R" but \*(L"an F.A.Q.\*(R"). Words beginning in the letter 'H' present another type of difficulty when selecting a suitable indefinite article. In a few such words (for example, \*(L"hour\*(R", \*(L"honour\*(R", \*(L"heir\*(R") the 'H' is not voiced at all, and so such words inflect with \*(L"an\*(R". The remaining cases (\*(L"voiced H's\*(R") may be divided into two categories: \*(L"hard H's\*(R" (such as \*(L"hangman\*(R", \*(L"holograph\*(R", \*(L"hat\*(R", etc.) and \*(L"soft H's\*(R" (such as \*(L"hysterical\*(R", \*(L"horrendous\*(R", \*(L"holy\*(R", etc.)</p><p>Hard H's always take \*(L"a\*(R" as their indefinite article, and soft H's normally do so as well. But <em>some</em> English speakers prefer \*(L"an\*(R" for soft H's (although the practice is now generally considered an affectation, rather than a legitimate grammatical alternative).</p><p>At present, the \*(C`A()\*(C' and \*(C`AN()\*(C' subroutines ignore soft H's and use \*(L"a\*(R" for any voiced 'H'. The author would, however, welcome feedback on this decision (envisaging a possible future \*(L"soft H\*(R" mode).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INFLECTING ORDINALS</h2>
        <div class="sectioncontent">
<p>Occasionally it is useful to present an integer value as an ordinal rather than as a numeral. For example:</p><p>    Enter password (1st attempt): ********     Enter password (2nd attempt): *********     Enter password (3rd attempt): *********     No 4th attempt. Access denied.</p><p>To this end, Lingua::EN::Inflect provides the \*(C`ORD()\*(C' subroutine. &lt;\s-1<em>ORD\s0()</em>&gt; takes a single argument and forms its ordinal equivalent. If the argument isn't a numerical integer, it just adds \*(L"-th\*(R".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONVERTING NUMBERS TO WORDS</h2>
        <div class="sectioncontent">
<p>The exportable subroutine \*(C`NUMWORDS\*(C' takes a number (cardinal or ordinal) and returns an English representation of that number. In a scalar context a string is returned. Hence:</p><p>    use Lingua::EN::Inflect qw( NUMWORDS );</p><p>    $words = NUMWORDS(1234567);</p><p>puts the string:</p><p>    "one million, two hundred and thirty-four thousand, five hundred and sixty-seven"</p><p>into $words.</p><p>In a list context each comma-separated chunk is returned as a separate element. Hence:</p><p>    @words = NUMWORDS(1234567);</p><p>puts the list:</p><p>    ("one million",      "two hundred and thirty-four thousand",      "five hundred and sixty-seven")</p><p>into @words.</p><p>Non-digits (apart from an optional leading plus or minus sign, any decimal points, and ordinal suffixes \*(-- see below) are silently ignored, so the following all produce identical results:</p><p>        NUMWORDS(5551202);         NUMWORDS(5_551_202);         NUMWORDS("5,551,202");         NUMWORDS("555-1202");</p><p>That last case is a little awkward since it's almost certainly a phone number, and \*(L"five million, five hundred and fifty-one thousand, two hundred and two\*(R" probably isn't what's wanted.</p><p>To overcome this, \*(C`NUMWORDS()\*(C' takes an optional named argument, 'group', which changes how numbers are translated. The argument must be a positive integer less than four, which indicated how the digits of the number are to be grouped. If the argument is 1, then each digit is translated separately. If the argument is 2, pairs of digits (starting from the <em>left</em>) are grouped together. If the argument is 3, triples of numbers (again, from the <em>left</em>) are grouped. Hence:</p><p>        NUMWORDS("555-1202", group=&gt;1)</p><p>returns "five, five, five, one, two, zero, two", whilst:</p><p>        NUMWORDS("555-1202", group=&gt;2)</p><p>returns "fifty-five, fifty-one, twenty, two", and:</p><p>        NUMWORDS("555-1202", group=&gt;3)</p><p>returns "five fifty-five, one twenty, two".</p><p>Phone numbers are often written in words as "five..five..five..one..two..zero..two", which is also easy to achieve:</p><p>        join &apos;..&apos;, NUMWORDS("555-1202", group=&gt;1)</p><p>\*(C`NUMWORDS\*(C' also handles decimal fractions. Hence:</p><p>        NUMWORDS("1.2345")</p><p>returns "one point two three four five" in a scalar context and \*(C`("one","point","two","three","four","five")\*(C') in an array context. Exponent form ("1.234e56") is not yet handled.</p><p>Multiple decimal points are only translated in one of the \*(L"grouping\*(R" modes. Hence:</p><p>        NUMWORDS(101.202.303)</p><p>returns "one hundred and one point two zero two three zero three", whereas:</p><p>        NUMWORDS(101.202.303, group=&gt;1)</p><p>returns "one zero one point two zero two point three zero three".</p><p>The digit &apos;0&apos; is unusual in that in may be translated to English as \*(L"zero\*(R", \*(L"oh\*(R", or \*(L"nought\*(R". To cater for this diversity, \*(C`NUMWORDS\*(C' may be passed a named argument, 'zero', which may be set to the desired translation of &apos;0&apos;. For example:</p><p>        print join "..", NUMWORDS("555-1202", group=&gt;3, zero=&gt;&apos;oh&apos;)</p><p>prints "five..five..five..one..two..oh..two". By default, zero is rendered as \*(L"zero\*(R".</p><p>Likewise, the digit &apos;1&apos; may be rendered as \*(L"one\*(R" or \*(L"a/an\*(R" (or very occasionally other variants), depending on the context. So there is a &apos;one&apos; argument as well:</p><p>        print NUMWORDS($_, one=&gt;&apos;a solitary&apos;, zero=&gt;&apos;no more&apos;),               PL(" bottle of beer on the wall&#92;n", $_)                    for (3,2,1,0);</p><p>        # prints:         #     three bottles of beer on the wall         #     two bottles of beer on the wall         #     a solitary bottle of beer on the wall         #     no more bottles of beer on the wall</p><p>Care is needed if the word \*(L"a/an\*(R" is to be used as a &apos;one&apos; value. Unless the next word is known in advance, it's almost always necessary to use the \*(C`A\*(C' function as well:</p><p>        print A( NUMWORDS(1, one=&gt;&apos;a&apos;) . " $_&#92;n")          for qw(cat aardvark ewe hour);</p><p>    # prints:     #     a cat     #     an aardvark     #     a ewe     #     an hour</p><p>Another major regional variation in number translation is the use of \*(L"and\*(R" in certain contexts. The named argument 'and' allows the programmer to specify how \*(L"and\*(R" should be handled. Hence:</p><p>        print scalar NUMWORDS("765", &apos;and&apos;=&gt;&apos;&apos;)</p><p>prints \*(L"seven hundred sixty-five\*(R", instead of \*(L"seven hundred and sixty-five\*(R". By default, the \*(L"and\*(R" is included.</p><p>The translation of the decimal point is also subject to variation (with \*(L"point\*(R", \*(L"dot\*(R", and \*(L"decimal\*(R" being the favorites). The named argument 'decimal' allows the programmer to how the decimal point should be rendered. Hence:</p><p>        print scalar NUMWORDS("666.124.64.101", group=&gt;3, decimal=&gt;&apos;dot&apos;)</p><p>prints \*(L"six sixty-six, dot, one twenty-four, dot, sixty-four, dot, one zero one\*(R" By default, the decimal point is rendered as \*(L"point\*(R".</p><p>\*(C`NUMWORDS\*(C' also handles the ordinal forms of numbers. So:</p><p>        print scalar NUMWORDS(&apos;1st&apos;);         print scalar NUMWORDS(&apos;3rd&apos;);         print scalar NUMWORDS(&apos;202nd&apos;);         print scalar NUMWORDS(&apos;1000000th&apos;);</p><p>print:</p><p>        first         third         two hundred and twenty-second         one millionth</p><p>Two common idioms in this regard are:</p><p>        print scalar NUMWORDS(ORD($number));</p><p>and:</p><p>        print scalar ORD(NUMWORDS($number));</p><p>These are identical in effect, except when $number contains a decimal:</p><p>        $number = 99.09;         print scalar NUMWORDS(ORD($number));    # ninety-ninth point zero nine         print scalar ORD(NUMWORDS($number));    # ninety-nine point zero ninth</p><p>Use whichever you feel is most appropriate.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONVERTING LISTS OF WORDS TO PHRASES</h2>
        <div class="sectioncontent">
<p>When creating a list of words, commas are used between adjacent items, except if the items contain commas, in which case semicolons are used. But if there are less than two items, the commas/semicolons are omitted entirely. The final item also has a conjunction (usually \*(L"and\*(R" or \*(L"or\*(R") before it. And although it's technically incorrect (and sometimes misleading), some people prefer to omit the comma before that final conjunction, even when there are more than two items.</p><p>That's complicated enough to warrant its own subroutine: \*(C`WORDLIST()\*(C'. This subroutine expects a list of words, possibly with one or more hash references containing options. It returns a string that joins the list together in the normal English usage. For example:</p><p>    print "You chose ", WORDLIST(@selected_items), "&#92;n";     # You chose barley soup, roast beef, and Yorkshire pudding</p><p>    print "You chose ", WORDLIST(@selected_items, {final_sep=&gt;""}), "&#92;n";     # You chose barley soup, roast beef and Yorkshire pudding</p><p>    print "Please chose ", WORDLIST(@side_orders, {conj=&gt;"or"}), "&#92;n";     # Please chose salad, vegetables, or ice-cream</p><p>The available options are:</p><p>    Option named    Specifies                Default value</p><p>    conj            Final conjunction        "and"     sep             Inter-item separator     ","     last_sep        Final separator          value of &apos;sep&apos; option</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERPOLATING INFLECTIONS IN STRINGS</h2>
        <div class="sectioncontent">
<p>By far the commonest use of the inflection subroutines is to produce message strings for various purposes. For example:</p><p>        print NUM($errors), PL_N(" error"), PL_V(" was"), " detected.&#92;n";         print PL_ADJ("This"), PL_N(" error"), PL_V(" was"), "fatal.&#92;n"                 if $severity &gt; 1;</p><p>Unfortunately the need to separate each subroutine call detracts significantly from the readability of the resulting code. To ameliorate this problem, Lingua::EN::Inflect provides an exportable string-interpolating subroutine (inflect($)), which recognizes calls to the various inflection subroutines within a string and interpolates them appropriately.</p><p>Using \*(C`inflect\*(C' the previous example could be rewritten:</p><p>        print inflect "NUM($errors) PL_N(error) PL_V(was) detected.&#92;n";         print inflect "PL_ADJ(This) PL_N(error) PL_V(was) fatal.&#92;n"                 if $severity &gt; 1;</p><p>Note that \*(C`inflect\*(C' also correctly handles calls to the \*(C`NUM()\*(C' subroutine (whether interpolated or antecedent). The \*(C`inflect()\*(C' subroutine has a related extra feature, in that it <em>automatically</em> cancels any \*(L"default number\*(R" value before it returns its interpolated string. This means that calls to \*(C`NUM()\*(C' which are embedded in an \*(C`inflect()\*(C'-interpolated string do not \*(L"escape\*(R" and interfere with subsequent inflections.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MODERN VS CLASSICAL INFLECTIONS</h2>
        <div class="sectioncontent">
<p>Certain words, mainly of Latin or Ancient Greek origin, can form plurals either using the standard English \*(L"-s\*(R" suffix, or with their original Latin or Greek inflections. For example:</p><p>        PL("stigma")            # -&gt; "stigmas" or "stigmata"         PL("torus")             # -&gt; "toruses" or "tori"         PL("index")             # -&gt; "indexes" or "indices"         PL("millennium")        # -&gt; "millenniums" or "millennia"         PL("ganglion")          # -&gt; "ganglions" or "ganglia"         PL("octopus")           # -&gt; "octopuses" or "octopodes"</p><p>Lingua::EN::Inflect caters to such words by providing an \*(L"alternate state\*(R" of inflection known as \*(L"classical mode\*(R". By default, words are inflected using their contemporary English plurals, but if classical mode is invoked, the more traditional plural forms are returned instead.</p><p>The exportable subroutine \*(C`classical()\*(C' controls this feature. If \*(C`classical()\*(C' is called with no arguments, it unconditionally invokes classical mode. If it is called with a single argument, it turns all classical inflects on or off (depending on whether the argument is true or false). If called with two or more arguments, those arguments specify which aspects of classical behaviour are to be used.</p><p>Thus:</p><p>        classical;                  # SWITCH ON CLASSICAL MODE         print PL("formula");        # -&gt; "formulae"</p><p>        classical 0;                # SWITCH OFF CLASSICAL MODE         print PL("formula");        # -&gt; "formulas"</p><p>        classical $cmode;           # CLASSICAL MODE IFF $cmode         print PL("formula");        # -&gt; "formulae" (IF $cmode)                                     # -&gt; "formulas" (OTHERWISE)</p><p>        classical herd=&gt;1;          # SWITCH ON CLASSICAL MODE FOR "HERD" NOUNS         print PL("wilderbeest");    # -&gt; "wilderbeest"</p><p>        classical names=&gt;1;         # SWITCH ON CLASSICAL MODE FOR NAMES         print PL("sally");          # -&gt; "sallies"         print PL("Sally");          # -&gt; "Sallys"</p><p>Note however that \*(C`classical()\*(C' has no effect on the inflection of words which are now fully assimilated. Hence:</p><p>        PL("forum")             # ALWAYS -&gt; "forums"         PL("criterion")         # ALWAYS -&gt; "criteria"</p><p>\s-1LEI\s0 assumes that a capitalized word is a person's name. So it forms the plural according to the rules for names (which is that you don't inflect, you just add -s or -es). You can choose to turn that behaviour off (it's on by the default, even when the module isn't in classical mode) by calling \*(C`classical(names=&gt;0)\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USER-DEFINED INFLECTIONS</h2>
        <div class="sectioncontent">
<h3>Adding plurals at run-time</h3>
<p>Lingua::EN::Inflect provides five exportable subroutines which allow the programmer to override the module's behaviour for specific cases: The \*(C`def_noun\*(C' subroutine takes a pair of string arguments: the singular and plural forms of the noun being specified. The singular form specifies a pattern to be interpolated (as \*(C`m/^(?:$first_arg)$/i\*(C'). Any noun matching this pattern is then replaced by the string in the second argument. The second argument specifies a string which is interpolated after the match succeeds, and is then used as the plural form. For example:       def_noun  &apos;cow&apos;        =&gt; &apos;kine&apos;;       def_noun  &apos;(.+i)o&apos;     =&gt; &apos;$1i&apos;;       def_noun  &apos;spam(mer)?&apos; =&gt; &apos;&#92;&#92;$&#92;&#92;%&#92;&#92;@#&#92;&#92;$&#92;&#92;@#!!&apos;; Note that both arguments should usually be specified in single quotes, so that they are not interpolated when they are specified, but later (when words are compared to them). As indicated by the last example, care also needs to be taken with certain characters in the second argument, to ensure that they are not unintentionally interpolated during comparison. The second argument string may also specify a second variant of the plural form, to be used when \*(L"classical\*(R" plurals have been requested. The beginning of the second variant is marked by a '|' character:       def_noun  &apos;cow&apos;        =&gt; &apos;cows|kine&apos;;       def_noun  &apos;(.+i)o&apos;     =&gt; &apos;$1os|$1i&apos;;       def_noun  &apos;spam(mer)?&apos; =&gt; &apos;&#92;&#92;$&#92;&#92;%&#92;&#92;@#&#92;&#92;$&#92;&#92;@#!!|varmints&apos;; If no classical variant is given, the specified plural form is used in both normal and \*(L"classical\*(R" modes. If the second argument is \*(C`undef\*(C' instead of a string, then the current user definition for the first argument is removed, and the standard plural inflection(s) restored. Note that in all cases, later plural definitions for a particular singular form replace earlier definitions of the same form. For example:       # FIRST, HIDE THE MODERN FORM....       def_noun  &apos;aviatrix&apos; =&gt; &apos;aviatrices&apos;;</p><p>      # LATER, HIDE THE CLASSICAL FORM...       def_noun  &apos;aviatrix&apos; =&gt; &apos;aviatrixes&apos;;</p><p>      # FINALLY, RESTORE THE DEFAULT BEHAVIOUR...       def_noun  &apos;aviatrix&apos; =&gt; undef; Special care is also required when defining general patterns and associated specific exceptions: put the more specific cases <em>after</em> the general pattern. For example:       def_noun  &apos;(.+)us&apos; =&gt; &apos;$1i&apos;;      # EVERY "-us" TO "-i"       def_noun  &apos;bus&apos;    =&gt; &apos;buses&apos;;    # EXCEPT FOR "bus" This \*(L"try-most-recently-defined-first\*(R" approach to matching user-defined words is also used by \*(C`def_verb\*(C', \*(C`def_a\*(C' and \*(C`def_an\*(C'. The \*(C`def_verb\*(C' subroutine takes three pairs of string arguments (that is, six arguments in total), specifying the singular and plural forms of the three \*(L"persons\*(R" of verb. As with \*(C`def_noun\*(C', the singular forms are specifications of run-time-interpolated patterns, whilst the plural forms are specifications of (up to two) run-time-interpolated strings:        def_verb &apos;am&apos;       =&gt; &apos;are&apos;,                 &apos;are&apos;      =&gt; &apos;are|art",                 &apos;is&apos;       =&gt; &apos;are&apos;;</p><p>       def_verb &apos;have&apos;     =&gt; &apos;have&apos;,                 &apos;have&apos;     =&gt; &apos;have",                 &apos;ha(s|th)&apos; =&gt; &apos;have&apos;; Note that as with \*(C`def_noun\*(C', modern/classical variants of plurals may be separately specified, subsequent definitions replace previous ones, and \*(C`undef\*(C''ed plural forms revert to the standard behaviour. The \*(C`def_adj\*(C' subroutine takes a pair of string arguments, which specify the singular and plural forms of the adjective being defined. As with \*(C`def_noun\*(C' and \*(C`def_adj\*(C', the singular forms are specifications of run-time-interpolated patterns, whilst the plural forms are specifications of (up to two) run-time-interpolated strings:        def_adj  &apos;this&apos;     =&gt; &apos;these&apos;,        def_adj  &apos;red&apos;      =&gt; &apos;red|gules&apos;, As previously, modern/classical variants of plurals may be separately specified, subsequent definitions replace previous ones, and \*(C`undef\*(C''ed plural forms revert to the standard behaviour. The \*(C`def_a\*(C' and \*(C`def_an\*(C' subroutines each take a single argument, which specifies a pattern. If a word passed to \*(C`A()\*(C' or \*(C`AN()\*(C' matches this pattern, it will be prefixed (unconditionally) with the corresponding indefinite article. For example:       def_a  &apos;error&apos;;       def_a  &apos;in.+&apos;;</p><p>      def_an &apos;mistake&apos;;       def_an &apos;error&apos;; As with the other \*(C`def_...\*(C' subroutines, such redefinitions are sequential in effect so that, after the above example, \*(L"error\*(R" will be inflected with \*(L"an\*(R". When it is imported, Lingua::EN::Inflect executes (as Perl code) the contents of any file named <em>.inflectrc</em> which it finds in the in the directory where <em>Lingua/EN/Inflect.pm</em> is installed, or in the current home directory ($ENV{HOME}), or in both. Note that the code is executed within the Lingua::EN::Inflect namespace.</p><p>Hence the user or the local Perl guru can make appropriate calls to \*(C`def_noun\*(C', \*(C`def_verb\*(C', etc. in one of these <em>.inflectrc</em> files, to permanently and universally modify the behaviour of the module. For example</p><p>      &gt; cat /usr/local/lib/perl5/Text/Inflect/.inflectrc</p><p>      def_noun  "UNIX"  =&gt; "UN*X|UNICES";</p><p>      def_verb  "teco"  =&gt; "teco",      # LITERALLY: "to edit with TECO"                 "teco"  =&gt; "teco",                 "tecos" =&gt; "teco";</p><p>      def_a     "Euler.*";              # "Yewler" TURNS IN HIS GRAVE</p><p>Note that calls to the \*(C`def_...\*(C' subroutines from within a program will take precedence over the contents of the home directory <em>.inflectrc</em> file, which in turn takes precedence over the system-wide <em>.inflectrc</em> file.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>On loading, if the Perl code in a <em>.inflectrc</em> file is invalid (syntactically or otherwise), an appropriate fatal error is issued. A common problem is not ending the file with something that evaluates to true (as the five \*(C`def_...\*(C' subroutines do).</p><p>Using the five \*(C`def_...\*(C' subroutines directly in a program may also result in fatal diagnostics, if a (singular) pattern or an interpolated (plural) string is somehow invalid.</p><p>Specific diagnostics related to user-defined inflections are: The singular form of a user-defined noun or verb (as defined by a call to \*(C`def_noun\*(C', \*(C`def_verb\*(C', \*(C`def_adj\*(C', \*(C`def_a\*(C' or \*(C`def_an\*(C') is not a valid Perl regular expression. The actual Perl error message is also given. The plural form(s) of a user-defined noun or verb (as defined by a call to \*(C`def_noun\*(C', \*(C`def_verb\*(C' or \*(C`def_adj\*(C') is not a valid Perl interpolated string (usually because it interpolates some undefined variable). Some other problem occurred in loading the named local or global <em>.inflectrc</em> file. The Perl error message (including the line number) is also given.</p><p>There are <em>no</em> diagnosable run-time error conditions for the actual inflection subroutines, except \*(C`NUMWORDS\*(C' and hence no run-time diagnostics. If the inflection subroutines are unable to form a plural via a user-definition or an inbuilt rule, they just \*(L"guess\*(R" the commonest English inflection: adding \*(L"-s\*(R" for nouns, removing \*(L"-s\*(R" for verbs, and no inflection for adjectives.</p><p>\*(C`Lingua::EN::Inflect::NUMWORDS()\*(C' can \*(C`die\*(C' with the following messages: The optional argument to \*(C`NUMWORDS()\*(C' wasn't 1, 2 or 3. \*(C`NUMWORDS()\*(C' was passed a number larger than 999,999,999,999,999,999,999,999,999,999,999,999 (that is: nine hundred and ninety-nine decillion, nine hundred and ninety-nine nonillion, nine hundred and ninety-nine octillion, nine hundred and ninety-nine septillion, nine hundred and ninety-nine sextillion, nine hundred and ninety-nine quintillion, nine hundred and ninety-nine quadrillion, nine hundred and ninety-nine trillion, nine hundred and ninety-nine billion, nine hundred and ninety-nine million, nine hundred and ninety-nine thousand, nine hundred and ninety-nine :-) The problem is that \*(C`NUMWORDS\*(C' doesn't know any words for number components bigger than \*(L"decillion\*(R".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER ISSUES</h2>
        <div class="sectioncontent">
<h3>2nd Person precedence</h3>
<p>If a verb has identical 1st and 2nd person singular forms, but different 1st and 2nd person plural forms, then when its plural is constructed, the 2nd person plural form is always preferred.</p><p>The author is not currently aware of any such verbs in English, but is not quite arrogant enough to assume <em>ipso facto</em> that none exist.</p>
<h3>Nominative precedence</h3>
<p>The singular pronoun \*(L"it\*(R" presents a special problem because its plural form can vary, depending on its \*(L"case\*(R". For example:</p><p>        It ate my homework       -&gt;  They ate my homework         It ate it                -&gt;  They ate them         I fed my homework to it  -&gt;  I fed my homework to them</p><p>As a consequence of this ambiguity, \*(C`PL()\*(C' or \*(C`PL_N\*(C' have been implemented so that they always return the <em>nominative</em> plural (that is, \*(L"they\*(R").</p><p>However, when asked for the plural of an unambiguously <em>accusative</em> \*(L"it\*(R" (namely, \*(C`PL("to it")\*(C', \*(C`PL_N("from it")\*(C', \*(C`PL("with it")\*(C', etc.), both subroutines will correctly return the accusative plural (\*(L"to them\*(R", \*(L"from them\*(R", \*(L"with them\*(R", etc.)</p>
<h3>The plurality of zero</h3>
<p>The rules governing the choice between:</p><p>      There were no errors.</p><p>and</p><p>      There was no error.</p><p>are complex and often depend more on <em>intent</em> rather than <em>content</em>. Hence it is infeasible to specify such rules algorithmically.</p><p>Therefore, Lingua::EN::Text contents itself with the following compromise: If the governing number is zero, inflections always return the plural form unless the appropriate \*(L"classical\*(R" inflection is in effect, in which case the singular form is always returned.</p><p>Thus, the sequence:</p><p>      <strong>NUM</strong>(0);       print inflect "There PL(was) NO(choice)";</p><p>produces \*(L"There were no choices\*(R", whereas:</p><p>      classical &apos;zero&apos;;     # or: classical(zero=&gt;1);       <strong>NUM</strong>(0);       print inflect "There PL(was) NO(choice)";</p><p>it will print \*(L"There was no choice\*(R".</p>
<h3>Homographs with heterogeneous plurals</h3>
<p>Another context in which intent (and not content) sometimes determines plurality is where two distinct meanings of a word require different plurals. For example:</p><p>      Three basses were stolen from the band&apos;s equipment trailer.       Three bass were stolen from the band&apos;s aquarium.</p><p>      I put the mice next to the cheese.       I put the mouses next to the computers.</p><p>      Several thoughts about leaving crossed my mind.       Several thought about leaving across my lawn.</p><p>Lingua::EN::Inflect handles such words in two ways:</p><ul>
<li><p>If both meanings of the word are the <em>same</em> part of speech (for example, \*(L"bass\*(R" is a noun in both sentences above), then one meaning is chosen as the \*(L"usual\*(R" meaning, and only that meaning's plural is ever returned by any of the inflection subroutines.</p></li><li><p>If each meaning of the word is a different part of speech (for example, \*(L"thought\*(R" is both a noun and a verb), then the noun's plural is returned by \*(C`PL()\*(C' and \*(C`PL_N()\*(C' and the verb's plural is returned only by \*(C`PL_V()\*(C'.</p></li>
</ul><p>Such contexts are, fortunately, uncommon (particularly \*(L"same-part-of-speech\*(R" examples). An informal study of nearly 600 \*(L"difficult plurals\*(R" indicates that \*(C`PL()\*(C' can be relied upon to \*(L"get it right\*(R" about 98% of the time (although, of course, ichthyophilic guitarists or cyber-behaviouralists may experience higher rates of confusion).</p><p>If the choice of a particular \*(L"usual inflection\*(R" is considered inappropriate, it can always be reversed with a preliminary call to the corresponding \*(C`def_...\*(C' subroutine.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTE</h2>
        <div class="sectioncontent">
<p>I'm not taking any further correspondence on: Despite the populist pandering of certain New World dictionaries, the plural is \*(L"octopuses\*(R" or (for the pedantic classicist) \*(L"octopodes\*(R". The suffix \*(L"-pus\*(R" is Greek, not Latin, so the plural is \*(L"-podes\*(R", not \*(L"pi\*(R". Had no plural in Latin (possibly because it was a mass noun). The only plural is the Anglicized \*(L"viruses\*(R".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Damian Conway (damian@conway.org) Matthew Persico (\s-1ORD\s0 inflection)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS AND IRRITATIONS</h2>
        <div class="sectioncontent">
<p>The endless inconsistencies of English.</p><p>(<em>Please</em> report words for which the correct plural or indefinite article is not formed, so that the reliability of Lingua::EN::Inflect can be improved.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p> Copyright (c) 1997-2009, Damian Conway. All Rights Reserved.  This module is free software. It may be used, redistributed      and/or modified under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Libravatar::URL.3pm.html"><span aria-hidden="true">&larr;</span> Libravatar::URL.3pm: Make urls for libravatars from an email address</a></li>
   <li class="next"><a href="Lingua::EN::Inflect::Phrase.3pm.html">Lingua::EN::Inflect::Phrase.3pm: Inflect short english phrases <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

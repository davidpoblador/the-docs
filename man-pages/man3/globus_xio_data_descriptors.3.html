<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>globus_xio_data_descriptors: Globus_xio uses data descriptors to associate meta data with the data being written or the data read.  data descriptors flow into the drivers read and write interface functions by way of the operation structure. if the driver is interested in viewing the data descriptor it can request it from the operation structure via a call to globus_xio_driver_operation_get_data_descriptor() and it can view any driver specific data descriptor via a call to globus_xio_driver_data_descriptor_get_specific(). the driver can modify values in the data descriptor by setting values before passing the request down the stack. several functions are available to modify the data descriptors. there is no need to 'set()' the data descriptors back into the operation. the functions for manipulating the values in a dd affect the values xio has directly.  data descriptors flow back to the driver in the callbacks for the data operations. when calling finished operation on a data operation the driver must pass in a data descriptor. it should get this data descriptor from the io operation callback.  life cycle:  passing in a data descriptor: a data descriptor is first created by the globus_xio user. the user can add driver specific data descriptors to it. once the user has created and set the attributes on its data descriptor to their liking they pass it into a globus_xio data operation (either read or write). when the data descriptor is passed on globus_xio will make an internal copy of it. it does this by first coping the user the level data descriptor and then walking through the list of driver specific data descriptor contained in to and requesting the driver make a copy of the driver specific data descriptor. if ever a driver specific data descriptor is null globus_xio need not call into its drivers dd_copy function. if ever the user level data descriptor is null globus_xio need not deal with the data descriptor functionality at all.  a data descriptor coming back up the stack once an io operation reaches the transport driver (the bottom of the stack) it takes on a slightly different role. on the way in it is describing what is requested to be done with the data, on the way out it is describing what has actually been done. once the transport driver performs the operation it should adjust the data descriptor to reflect what has actually happened (few drivers will need to worry about this). each driver on the way up can adjust the data descriptor and its driver specific data descriptor. when xio reaches the top of the stack it calls a user callback. when that callback returns all memory associated with the data descriptor is cleaned up. the interface function globus_xio_driver_data_descriptor_free() is used for this.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Globus_xio uses data descriptors to associate meta data with the data being written or the data read.  data descriptors flow into the drivers read and write interface functions by way of the operation structure. if the driver is interested in viewing the data descriptor it can request it from the operation structure via a call to globus_xio_driver_operation_get_data_descriptor() and it can view any driver specific data descriptor via a call to globus_xio_driver_data_descriptor_get_specific(). the driver can modify values in the data descriptor by setting values before passing the request down the stack. several functions are available to modify the data descriptors. there is no need to 'set()' the data descriptors back into the operation. the functions for manipulating the values in a dd affect the values xio has directly.  data descriptors flow back to the driver in the callbacks for the data operations. when calling finished operation on a data operation the driver must pass in a data descriptor. it should get this data descriptor from the io operation callback.  life cycle:  passing in a data descriptor: a data descriptor is first created by the globus_xio user. the user can add driver specific data descriptors to it. once the user has created and set the attributes on its data descriptor to their liking they pass it into a globus_xio data operation (either read or write). when the data descriptor is passed on globus_xio will make an internal copy of it. it does this by first coping the user the level data descriptor and then walking through the list of driver specific data descriptor contained in to and requesting the driver make a copy of the driver specific data descriptor. if ever a driver specific data descriptor is null globus_xio need not call into its drivers dd_copy function. if ever the user level data descriptor is null globus_xio need not deal with the data descriptor functionality at all.  a data descriptor coming back up the stack once an io operation reaches the transport driver (the bottom of the stack) it takes on a slightly different role. on the way in it is describing what is requested to be done with the data, on the way out it is describing what has actually been done. once the transport driver performs the operation it should adjust the data descriptor to reflect what has actually happened (few drivers will need to worry about this). each driver on the way up can adjust the data descriptor and its driver specific data descriptor. when xio reaches the top of the stack it calls a user callback. when that callback returns all memory associated with the data descriptor is cleaned up. the interface function globus_xio_driver_data_descriptor_free() is used for this.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="globus_xio_data_descriptors (3) manual">
  <meta name="twitter:description" content="Globus_xio uses data descriptors to associate meta data with the data being written or the data read.  data descriptors flow into the drivers read and write interface functions by way of the operation structure. if the driver is interested in viewing the data descriptor it can request it from the operation structure via a call to globus_xio_driver_operation_get_data_descriptor() and it can view any driver specific data descriptor via a call to globus_xio_driver_data_descriptor_get_specific(). the driver can modify values in the data descriptor by setting values before passing the request down the stack. several functions are available to modify the data descriptors. there is no need to 'set()' the data descriptors back into the operation. the functions for manipulating the values in a dd affect the values xio has directly.  data descriptors flow back to the driver in the callbacks for the data operations. when calling finished operation on a data operation the driver must pass in a data descriptor. it should get this data descriptor from the io operation callback.  life cycle:  passing in a data descriptor: a data descriptor is first created by the globus_xio user. the user can add driver specific data descriptors to it. once the user has created and set the attributes on its data descriptor to their liking they pass it into a globus_xio data operation (either read or write). when the data descriptor is passed on globus_xio will make an internal copy of it. it does this by first coping the user the level data descriptor and then walking through the list of driver specific data descriptor contained in to and requesting the driver make a copy of the driver specific data descriptor. if ever a driver specific data descriptor is null globus_xio need not call into its drivers dd_copy function. if ever the user level data descriptor is null globus_xio need not deal with the data descriptor functionality at all.  a data descriptor coming back up the stack once an io operation reaches the transport driver (the bottom of the stack) it takes on a slightly different role. on the way in it is describing what is requested to be done with the data, on the way out it is describing what has actually been done. once the transport driver performs the operation it should adjust the data descriptor to reflect what has actually happened (few drivers will need to worry about this). each driver on the way up can adjust the data descriptor and its driver specific data descriptor. when xio reaches the top of the stack it calls a user callback. when that callback returns all memory associated with the data descriptor is cleaned up. the interface function globus_xio_driver_data_descriptor_free() is used for this.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libglobus-xio-doc-globus_xio_data_descriptors-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/globus_xio_data_descriptors.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="globus_xio_data_descriptors (3) manual" />
  <meta property="og:description" content="Globus_xio uses data descriptors to associate meta data with the data being written or the data read.  data descriptors flow into the drivers read and write interface functions by way of the operation structure. if the driver is interested in viewing the data descriptor it can request it from the operation structure via a call to globus_xio_driver_operation_get_data_descriptor() and it can view any driver specific data descriptor via a call to globus_xio_driver_data_descriptor_get_specific(). the driver can modify values in the data descriptor by setting values before passing the request down the stack. several functions are available to modify the data descriptors. there is no need to 'set()' the data descriptors back into the operation. the functions for manipulating the values in a dd affect the values xio has directly.  data descriptors flow back to the driver in the callbacks for the data operations. when calling finished operation on a data operation the driver must pass in a data descriptor. it should get this data descriptor from the io operation callback.  life cycle:  passing in a data descriptor: a data descriptor is first created by the globus_xio user. the user can add driver specific data descriptors to it. once the user has created and set the attributes on its data descriptor to their liking they pass it into a globus_xio data operation (either read or write). when the data descriptor is passed on globus_xio will make an internal copy of it. it does this by first coping the user the level data descriptor and then walking through the list of driver specific data descriptor contained in to and requesting the driver make a copy of the driver specific data descriptor. if ever a driver specific data descriptor is null globus_xio need not call into its drivers dd_copy function. if ever the user level data descriptor is null globus_xio need not deal with the data descriptor functionality at all.  a data descriptor coming back up the stack once an io operation reaches the transport driver (the bottom of the stack) it takes on a slightly different role. on the way in it is describing what is requested to be done with the data, on the way out it is describing what has actually been done. once the transport driver performs the operation it should adjust the data descriptor to reflect what has actually happened (few drivers will need to worry about this). each driver on the way up can adjust the data descriptor and its driver specific data descriptor. when xio reaches the top of the stack it calls a user callback. when that callback returns all memory associated with the data descriptor is cleaned up. the interface function globus_xio_driver_data_descriptor_free() is used for this." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libglobus-xio-doc-globus_xio_data_descriptors-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">globus_xio_data_descriptors<small> (3)</small></h1>
        <p class="lead">Globus_xio uses data descriptors to associate meta data with the data being written or the data read.  data descriptors flow into the drivers read and write interface functions by way of the operation structure. if the driver is interested in viewing the data descriptor it can request it from the operation structure via a call to globus_xio_driver_operation_get_data_descriptor() and it can view any driver specific data descriptor via a call to globus_xio_driver_data_descriptor_get_specific(). the driver can modify values in the data descriptor by setting values before passing the request down the stack. several functions are available to modify the data descriptors. there is no need to 'set()' the data descriptors back into the operation. the functions for manipulating the values in a dd affect the values xio has directly.  data descriptors flow back to the driver in the callbacks for the data operations. when calling finished operation on a data operation the driver must pass in a data descriptor. it should get this data descriptor from the io operation callback.  life cycle:  passing in a data descriptor: a data descriptor is first created by the globus_xio user. the user can add driver specific data descriptors to it. once the user has created and set the attributes on its data descriptor to their liking they pass it into a globus_xio data operation (either read or write). when the data descriptor is passed on globus_xio will make an internal copy of it. it does this by first coping the user the level data descriptor and then walking through the list of driver specific data descriptor contained in to and requesting the driver make a copy of the driver specific data descriptor. if ever a driver specific data descriptor is null globus_xio need not call into its drivers dd_copy function. if ever the user level data descriptor is null globus_xio need not deal with the data descriptor functionality at all.  a data descriptor coming back up the stack once an io operation reaches the transport driver (the bottom of the stack) it takes on a slightly different role. on the way in it is describing what is requested to be done with the data, on the way out it is describing what has actually been done. once the transport driver performs the operation it should adjust the data descriptor to reflect what has actually happened (few drivers will need to worry about this). each driver on the way up can adjust the data descriptor and its driver specific data descriptor. when xio reaches the top of the stack it calls a user callback. when that callback returns all memory associated with the data descriptor is cleaned up. the interface function globus_xio_driver_data_descriptor_free() is used for this.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/globus_xio_data_descriptors.3.html">
      <span itemprop="name">globus_xio_data_descriptors: Globus_xio uses data descriptors to associate meta data with the data being written or the data read.  data descriptors flow into the drivers read and write interface functions by way of the operation structure. if the driver is interested in viewing the data descriptor it can request it from the operation structure via a call to globus_xio_driver_operation_get_data_descriptor() and it can view any driver specific data descriptor via a call to globus_xio_driver_data_descriptor_get_specific(). the driver can modify values in the data descriptor by setting values before passing the request down the stack. several functions are available to modify the data descriptors. there is no need to 'set()' the data descriptors back into the operation. the functions for manipulating the values in a dd affect the values xio has directly.  data descriptors flow back to the driver in the callbacks for the data operations. when calling finished operation on a data operation the driver must pass in a data descriptor. it should get this data descriptor from the io operation callback.  life cycle:  passing in a data descriptor: a data descriptor is first created by the globus_xio user. the user can add driver specific data descriptors to it. once the user has created and set the attributes on its data descriptor to their liking they pass it into a globus_xio data operation (either read or write). when the data descriptor is passed on globus_xio will make an internal copy of it. it does this by first coping the user the level data descriptor and then walking through the list of driver specific data descriptor contained in to and requesting the driver make a copy of the driver specific data descriptor. if ever a driver specific data descriptor is null globus_xio need not call into its drivers dd_copy function. if ever the user level data descriptor is null globus_xio need not deal with the data descriptor functionality at all.  a data descriptor coming back up the stack once an io operation reaches the transport driver (the bottom of the stack) it takes on a slightly different role. on the way in it is describing what is requested to be done with the data, on the way out it is describing what has actually been done. once the transport driver performs the operation it should adjust the data descriptor to reflect what has actually happened (few drivers will need to worry about this). each driver on the way up can adjust the data descriptor and its driver specific data descriptor. when xio reaches the top of the stack it calls a user callback. when that callback returns all memory associated with the data descriptor is cleaned up. the interface function globus_xio_driver_data_descriptor_free() is used for this.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libglobus-xio-doc/">
      <span itemprop="name">libglobus-xio-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/globus_xio_data_descriptors.3.html">
      <span itemprop="name">globus_xio_data_descriptors: Globus_xio uses data descriptors to associate meta data with the data being written or the data read.  data descriptors flow into the drivers read and write interface functions by way of the operation structure. if the driver is interested in viewing the data descriptor it can request it from the operation structure via a call to globus_xio_driver_operation_get_data_descriptor() and it can view any driver specific data descriptor via a call to globus_xio_driver_data_descriptor_get_specific(). the driver can modify values in the data descriptor by setting values before passing the request down the stack. several functions are available to modify the data descriptors. there is no need to 'set()' the data descriptors back into the operation. the functions for manipulating the values in a dd affect the values xio has directly.  data descriptors flow back to the driver in the callbacks for the data operations. when calling finished operation on a data operation the driver must pass in a data descriptor. it should get this data descriptor from the io operation callback.  life cycle:  passing in a data descriptor: a data descriptor is first created by the globus_xio user. the user can add driver specific data descriptors to it. once the user has created and set the attributes on its data descriptor to their liking they pass it into a globus_xio data operation (either read or write). when the data descriptor is passed on globus_xio will make an internal copy of it. it does this by first coping the user the level data descriptor and then walking through the list of driver specific data descriptor contained in to and requesting the driver make a copy of the driver specific data descriptor. if ever a driver specific data descriptor is null globus_xio need not call into its drivers dd_copy function. if ever the user level data descriptor is null globus_xio need not deal with the data descriptor functionality at all.  a data descriptor coming back up the stack once an io operation reaches the transport driver (the bottom of the stack) it takes on a slightly different role. on the way in it is describing what is requested to be done with the data, on the way out it is describing what has actually been done. once the transport driver performs the operation it should adjust the data descriptor to reflect what has actually happened (few drivers will need to worry about this). each driver on the way up can adjust the data descriptor and its driver specific data descriptor. when xio reaches the top of the stack it calls a user callback. when that callback returns all memory associated with the data descriptor is cleaned up. the interface function globus_xio_driver_data_descriptor_free() is used for this.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for globus_xio from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="globus_xio_data_descriptor_init.3.html"><span aria-hidden="true">&larr;</span> globus_xio_data_descriptor_init.3: Globus xio api -</a></li>
   <li class="next"><a href="globus_xio_driver.3.html">globus_xio_driver.3: Globus xio driver - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SPI_execute: Execute a command</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Execute a command">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SPI_execute (3) manual">
  <meta name="twitter:description" content="Execute a command">
  <meta name="twitter:image" content="https://www.carta.tech/images/postgresql-doc-9.4-SPI_execute-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SPI_execute.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SPI_execute (3) manual" />
  <meta property="og:description" content="Execute a command" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/postgresql-doc-9.4-SPI_execute-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SPI_execute<small> (3)</small></h1>
        <p class="lead">Execute a command</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SPI_execute.3.html">
      <span itemprop="name">SPI_execute: Execute a command</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/postgresql-doc-9.4/">
      <span itemprop="name">postgresql-doc-9.4</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SPI_execute.3.html">
      <span itemprop="name">SPI_execute: Execute a command</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
int SPI_execute(const char * <em>command</em>, bool <em>read_only</em>, long <em>count</em>)
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>SPI_execute</strong> executes the specified SQL command for <em>count</em> rows. If <em>read_only</em> is true, the command must be read-only, and execution overhead is somewhat reduced.</p><p>This function can only be called from a connected procedure.</p><p>If <em>count</em> is zero then the command is executed for all rows that it applies to. If <em>count</em> is greater than zero, then no more than <em>count</em> rows will be retrieved; execution stops when the count is reached, much like adding a LIMIT clause to the query. For example,</p>
<pre>
SPI_execute("SELECT * FROM foo", true, 5);
</pre>
<p>will retrieve at most 5 rows from the table. Note that such a limit is only effective when the command actually returns rows. For example,</p>
<pre>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</pre>
<p>inserts all rows from bar, ignoring the <em>count</em> parameter. However, with</p>
<pre>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</pre>
<p>at most 5 rows would be inserted, since execution would stop after the fifth RETURNING result row is retrieved.</p><p>You can pass multiple commands in one string; <strong>SPI_execute</strong> returns the result for the command executed last. The <em>count</em> limit applies to each command separately (even though only the last result will actually be returned). The limit is not applied to any hidden commands generated by rules.</p><p>When <em>read_only</em> is false, <strong>SPI_execute</strong> increments the command counter and computes a new snapshot before executing each command in the string. The snapshot does not actually change if the current transaction isolation level is SERIALIZABLE or REPEATABLE READ, but in READ COMMITTED mode the snapshot update allows each command to see the results of newly committed transactions from other sessions. This is essential for consistent behavior when the commands are modifying the database.</p><p>When <em>read_only</em> is true, <strong>SPI_execute</strong> does not update either the snapshot or the command counter, and it allows only plain <strong>SELECT</strong> commands to appear in the command string. The commands are executed using the snapshot previously established for the surrounding query. This execution mode is somewhat faster than the read/write mode due to eliminating per-command overhead. It also allows genuinely stable functions to be built: since successive executions will all use the same snapshot, there will be no change in the results.</p><p>It is generally unwise to mix read-only and read-write commands within a single function using SPI; that could result in very confusing behavior, since the read-only queries would not see the results of any database updates done by the read-write queries.</p><p>The actual number of rows for which the (last) command was executed is returned in the global variable <em>SPI_processed</em>. If the return value of the function is SPI_OK_SELECT, SPI_OK_INSERT_RETURNING, SPI_OK_DELETE_RETURNING, or SPI_OK_UPDATE_RETURNING, then you can use the global pointer SPITupleTable *SPI_tuptable to access the result rows. Some utility commands (such as <strong>EXPLAIN</strong>) also return row sets, and SPI_tuptable will contain the result in these cases too. Some utility commands (<strong>COPY</strong>, <strong>CREATE TABLE AS</strong>) don&apos;t return a row set, so SPI_tuptable is NULL, but they still return the number of rows processed in <em>SPI_processed</em>.</p><p>The structure SPITupleTable is defined thus:</p>
<pre>
typedef struct
{
    MemoryContext tuptabcxt;    /* memory context of result table */
    uint32      alloced;        /* number of alloced vals */
    uint32      free;           /* number of free vals */
    TupleDesc   tupdesc;        /* row descriptor */
    HeapTuple  *vals;           /* rows */
} SPITupleTable;
</pre>
<p>vals is an array of pointers to rows. (The number of valid entries is given by <em>SPI_processed</em>.) tupdesc is a row descriptor which you can pass to SPI functions dealing with rows. tuptabcxt, alloced, and free are internal fields not intended for use by SPI callers.</p><p><strong>SPI_finish</strong> frees all SPITupleTables allocated during the current procedure. You can free a particular result table earlier, if you are done with it, by calling <strong>SPI_freetuptable</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ARGUMENTS</h2>
        <div class="sectioncontent">
<p>const char * <em>command</em></p><p>string containing command to execute</p><p>bool <em>read_only</em></p><p>true for read-only execution</p><p>long <em>count</em></p><p>maximum number of rows to return, or 0 for no limit</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>If the execution of the command was successful then one of the following (nonnegative) values will be returned:</p><p>SPI_OK_SELECT</p><p>if a <strong>SELECT</strong> (but not <strong>SELECT INTO</strong>) was executed</p><p>SPI_OK_SELINTO</p><p>if a <strong>SELECT INTO</strong> was executed</p><p>SPI_OK_INSERT</p><p>if an <strong>INSERT</strong> was executed</p><p>SPI_OK_DELETE</p><p>if a <strong>DELETE</strong> was executed</p><p>SPI_OK_UPDATE</p><p>if an <strong>UPDATE</strong> was executed</p><p>SPI_OK_INSERT_RETURNING</p><p>if an <strong>INSERT RETURNING</strong> was executed</p><p>SPI_OK_DELETE_RETURNING</p><p>if a <strong>DELETE RETURNING</strong> was executed</p><p>SPI_OK_UPDATE_RETURNING</p><p>if an <strong>UPDATE RETURNING</strong> was executed</p><p>SPI_OK_UTILITY</p><p>if a utility command (e.g., <strong>CREATE TABLE</strong>) was executed</p><p>SPI_OK_REWRITTEN</p><p>if the command was rewritten into another kind of command (e.g., <strong>UPDATE</strong> became an <strong>INSERT</strong>) by a rule.</p><p>On error, one of the following negative values is returned:</p><p>SPI_ERROR_ARGUMENT</p><p>if <em>command</em> is NULL or <em>count</em> is less than 0</p><p>SPI_ERROR_COPY</p><p>if <strong>COPY TO stdout</strong> or <strong>COPY FROM stdin</strong> was attempted</p><p>SPI_ERROR_TRANSACTION</p><p>if a transaction manipulation command was attempted (<strong>BEGIN</strong>, <strong>COMMIT</strong>, <strong>ROLLBACK</strong>, <strong>SAVEPOINT</strong>, <strong>PREPARE TRANSACTION</strong>, <strong>COMMIT PREPARED</strong>, <strong>ROLLBACK PREPARED</strong>, or any variant thereof)</p><p>SPI_ERROR_OPUNKNOWN</p><p>if the command type is unknown (shouldn&apos;t happen)</p><p>SPI_ERROR_UNCONNECTED</p><p>if called from an unconnected procedure</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>All SPI query-execution functions set both <em>SPI_processed</em> and <em>SPI_tuptable</em> (just the pointer, not the contents of the structure). Save these two global variables into local procedure variables if you need to access the result table of <strong>SPI_execute</strong> or another query-execution function across later calls.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SPI_execp.3.html"><span aria-hidden="true">&larr;</span> SPI_execp.3: Execute a statement in read/write mode</a></li>
   <li class="next"><a href="SPI_execute_plan.3.html">SPI_execute_plan.3: Execute a statement prepared by spi_prepare <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTTP::Daemon: A simple http server class</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A simple http server class">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="HTTP::Daemon (3pm) manual">
  <meta name="twitter:description" content="A simple http server class">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhttp-daemon-perl-HTTP::Daemon-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/HTTP::Daemon.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HTTP::Daemon (3pm) manual" />
  <meta property="og:description" content="A simple http server class" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhttp-daemon-perl-HTTP::Daemon-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">HTTP::Daemon<small> (3pm)</small></h1>
        <p class="lead">A simple http server class</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTTP::Daemon.3pm.html">
      <span itemprop="name">HTTP::Daemon: A simple http server class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhttp-daemon-perl/">
      <span itemprop="name">libhttp-daemon-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTTP::Daemon.3pm.html">
      <span itemprop="name">HTTP::Daemon: A simple http server class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use HTTP::Daemon;
  use HTTP::Status;

  my $d = HTTP::Daemon-&gt;new || die;
  print "Please contact me at: &lt;URL:", $d-&gt;url, "&gt;&#92;n";
  while (my $c = $d-&gt;accept) {
      while (my $r = $c-&gt;get_request) {
          if ($r-&gt;method eq &apos;GET&apos; and $r-&gt;uri-&gt;path eq "/xyzzy") {
              # remember, this is *not* recommended practice :-)
              $c-&gt;send_file_response("/etc/passwd");
          }
          else {
              $c-&gt;send_error(RC_FORBIDDEN)
          }
      }
      $c-&gt;close;
      undef($c);
  }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Instances of the \*(C`HTTP::Daemon\*(C' class are \s-1HTTP/1\s0.1 servers that listen on a socket for incoming requests. The \*(C`HTTP::Daemon\*(C' is a subclass of \*(C`IO::Socket::INET\*(C', so you can perform socket operations directly on it too.</p><p>The <em>accept()</em> method will return when a connection from a client is available.  The returned value will be an \*(C`HTTP::Daemon::ClientConn\*(C' object which is another \*(C`IO::Socket::INET\*(C' subclass.  Calling the <em>get_request()</em> method on this object will read data from the client and return an \*(C`HTTP::Request\*(C' object.  The ClientConn object also provide methods to send back various responses.</p><p>This \s-1HTTP\s0 daemon does not <em>fork</em>\|(2) for you.  Your application, i.e. the user of the \*(C`HTTP::Daemon\*(C' is responsible for forking if that is desirable.  Also note that the user is responsible for generating responses that conform to the \s-1HTTP/1\s0.1 protocol.</p><p>The following methods of \*(C`HTTP::Daemon\*(C' are new (or enhanced) relative to the \*(C`IO::Socket::INET\*(C' base class: The constructor method takes the same arguments as the \*(C`IO::Socket::INET\*(C' constructor, but unlike its base class it can also be called without any arguments.  The daemon will then set up a listen queue of 5 connections and allocate some random port number. A server that wants to bind to some specific address on the standard \s-1HTTP\s0 port will be constructed like this:   $d = HTTP::Daemon-&gt;new(            LocalAddr =&gt; &apos;www.thisplace.com&apos;,            LocalPort =&gt; 80,        ); See IO::Socket::INET for a description of other arguments that can be used configure the daemon during construction. This method works the same the one provided by the base class, but it returns an \*(C`HTTP::Daemon::ClientConn\*(C' reference by default.  If a package name is provided as argument, then the returned object will be blessed into the given class.  It is probably a good idea to make that class a subclass of \*(C`HTTP::Daemon::ClientConn\*(C'. The accept method will return \*(C`undef\*(C' if timeouts have been enabled and no connection is made within the given time.  The <em>timeout()</em> method is described in IO::Socket. In list context both the client object and the peer address will be returned; see the description of the accept method IO::Socket for details. Returns a \s-1URL\s0 string that can be used to access the server root. Returns the name that this server will use to identify itself.  This is the string that is sent with the \*(C`Server\*(C' response header.  The main reason to have this method is that subclasses can override it if they want to use another product name. The default is the string \*(L"libwww-perl-daemon/#.##\*(R" where \*(L"#.##\*(R" is replaced with the version number of this module.</p><p>The \*(C`HTTP::Daemon::ClientConn\*(C' is a \*(C`IO::Socket::INET\*(C' subclass. Instances of this class are returned by the <em>accept()</em> method of \*(C`HTTP::Daemon\*(C'.  The following methods are provided: This method reads data from the client and turns it into an \*(C`HTTP::Request\*(C' object which is returned.  It returns \*(C`undef\*(C' if reading fails.  If it fails, then the \*(C`HTTP::Daemon::ClientConn\*(C' object ($c) should be discarded, and you should not try call this method again on it.  The $c-&gt;reason method might give you some information about why $c-&gt;get_request failed. The <em>get_request()</em> method will normally not return until the whole request has been received from the client.  This might not be what you want if the request is an upload of a large file (and with chunked transfer encoding \s-1HTTP\s0 can even support infinite request messages - uploading live audio for instance).  If you pass a \s-1TRUE\s0 value as the $headers_only argument, then <em>get_request()</em> will return immediately after parsing the request headers and you are responsible for reading the rest of the request content.  If you are going to call $c-&gt;get_request again on the same connection you better read the correct number of bytes. Bytes read by $c-&gt;get_request, but not used are placed in the <em>read</em> buffer.  The next time $c-&gt;get_request is called it will consume the bytes in this buffer before reading more data from the network connection itself.  The read buffer is invalid after $c-&gt;get_request has failed. If you handle the reading of the request content yourself you need to empty this buffer before you read more and you need to place unconsumed bytes here.  You also need this buffer if you implement services like <em>101 Switching Protocols</em>. This method always returns the old buffer content and can optionally replace the buffer content if you pass it an argument. When $c-&gt;get_request returns \*(C`undef\*(C' you can obtain a short string describing why it happened by calling $c-&gt;reason. Return \s-1TRUE\s0 if the client announced a protocol with version number greater or equal to the given argument.  The $proto argument can be a string like \*(L"\s-1HTTP/1\s0.1\*(R" or just \*(L"1.1\*(R". Return \s-1TRUE\s0 if the client speaks the \s-1HTTP/0\s0.9 protocol.  No status code and no headers should be returned to such a client.  This should be the same as !$c-&gt;proto_ge(\*(L"\s-1HTTP/1\s0.0\*(R"). Return \s-1TRUE\s0 if the last request was a \*(C`HEAD\*(C' request.  No content body must be generated for these requests. Make sure that $c-&gt;get_request will not try to read more requests off this connection.  If you generate a response that is not self delimiting, then you should signal this fact by calling this method. This attribute is turned on automatically if the client announces protocol \s-1HTTP/1\s0.0 or worse and does not include a \*(L"Connection: Keep-Alive\*(R" header.  It is also turned on automatically when \s-1HTTP/1\s0.1 or better clients send the \*(L"Connection: close\*(R" request header. Send the status line back to the client.  If $code is omitted 200 is assumed.  If $mess is omitted, then a message corresponding to $code is inserted.  If $proto is missing the content of the $HTTP::Daemon::PROTO variable is used. Send the \s-1CRLF\s0 sequence to the client. Send the status line and the \*(L"Date:\*(R" and \*(L"Server:\*(R" headers back to the client.  This header is assumed to be continued and does not end with an empty \s-1CRLF\s0 line. See the description of <em>send_status_line()</em> for the description of the accepted arguments. Send one or more header lines. Write a \*(C`HTTP::Response\*(C' object to the client as a response.  We try hard to make sure that the response is self delimiting so that the connection can stay persistent for further request/response exchanges. The content attribute of the \*(C`HTTP::Response\*(C' object can be a normal string or a subroutine reference.  If it is a subroutine, then whatever this callback routine returns is written back to the client as the response content.  The routine will be called until it return an undefined or empty value.  If the client is \s-1HTTP/1\s0.1 aware then we will use chunked transfer encoding for the response. Send a redirect response back to the client.  The location ($loc) can be an absolute or relative \s-1URL\s0. The $code must be one the redirect status codes, and defaults to \*(L"301 Moved Permanently\*(R" Send an error response back to the client.  If the $code is missing a \*(L"Bad Request\*(R" error is reported.  The $error_message is a string that is incorporated in the body of the \s-1HTML\s0 entity body. Send back a response with the specified $filename as content.  If the file is a directory we try to generate an \s-1HTML\s0 index of it. Copy the file to the client.  The file can be a string (which will be interpreted as a filename) or a reference to an \*(C`IO::Handle\*(C' or glob. Return a reference to the corresponding \*(C`HTTP::Daemon\*(C' object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO HTTP::Daemon&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1RFC\s0 2616</p><p>IO::Socket::INET, IO::Socket</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 1996-2003, Gisle Aas</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="HTTP::DAV::Response.3pm.html"><span aria-hidden="true">&larr;</span> HTTP::DAV::Response.3pm: Represents a webdav http response (ala http::response)</a></li>
   <li class="next"><a href="HTTP::Date.3pm.html">HTTP::Date.3pm: Date conversion routines <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

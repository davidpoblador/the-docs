<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Parse::PlainConfig: Parser for plain-text configuration files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parser for plain-text configuration files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Parse::PlainConfig (3pm) manual">
  <meta name="twitter:description" content="Parser for plain-text configuration files">
  <meta name="twitter:image" content="https://www.carta.tech/images/libparse-plainconfig-perl-Parse::PlainConfig-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Parse::PlainConfig.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Parse::PlainConfig (3pm) manual" />
  <meta property="og:description" content="Parser for plain-text configuration files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libparse-plainconfig-perl-Parse::PlainConfig-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Parse::PlainConfig<small> (3pm)</small></h1>
        <p class="lead">Parser for plain-text configuration files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Parse::PlainConfig.3pm.html">
      <span itemprop="name">Parse::PlainConfig: Parser for plain-text configuration files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libparse-plainconfig-perl/">
      <span itemprop="name">libparse-plainconfig-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Parse::PlainConfig.3pm.html">
      <span itemprop="name">Parse::PlainConfig: Parser for plain-text configuration files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">MODULE VERSION</h2>
        <div class="sectioncontent">
<p>$Id: PlainConfig.pm,v 2.06 2008/07/07 22:59:35 acorliss Exp $</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Parse::PlainConfig;

  $conf = new Parse::PlainConfig;
  $conf = Parse::PlainConfig-&gt;new(
    &apos;PARAM_DELIM&apos; =&gt; &apos;=&apos;,
    &apos;FILE&apos;        =&gt; &apos;.myrc&apos;,
    &apos;MAX_BYTES&apos;   =&gt; 65536,
    &apos;SMART_PARSER =&gt; 1,
    );

  $conf-&gt;property(PARAM_DELIM =&gt; &apos;=&apos;);

  $rv = $conf-&gt;read(&apos;myconf.conf&apos;);
  $rv = $conf-&gt;read;
  $rv = $conf-&gt;readIfNewer;
  $conf-&gt;write(&apos;.myrc&apos;, 2);

  $conf-&gt;purge;

  @parameters = $conf-&gt;parameters;
  $conf-&gt;parameter(FOO =&gt; "bar");
  $value = $conf-&gt;parameter(FOO);
  $conf-&gt;describe(FOO =&gt; &apos;This is foo&apos;);
  $conf-&gt;coerce("string", qw(FOO BAR));

  @order = $conf-&gt;order;
  $conf-&gt;order(@new_order);

  $errstr = Parse::PlainConfig::ERROR;

  $rv = $conf-&gt;hasParameter(&apos;FOO&apos;);
</pre>
<p>The following methods are only supported for backwards compatibility reasons. They will likely be removed at some point in the future.</p><p>  # Use of the tags DELIM and PURGE are deprecated in favour of   # PARAM_DELIM, LIST_DELIM, HASH_DELIM, and AUTOPURGE   $conf = Parse::PlainConfig-&gt;new(     &apos;DELIM&apos; =&gt; &apos;=&apos;,     &apos;PURGE&apos; =&gt; 1,     );</p><p>  # As is the delim method since it works only on the tag delimiter   $conf-&gt;delim(&apos;=&apos;);</p><p>  # Auto-purge should be enabled/disabled via the property method   $conf-&gt;<strong>purge</strong>(1);</p><p>  # directives is replaced with parameters   @directives = $conf-&gt;directives;</p><p>  # get/set methods are replaced with a unifed parameter method   $field = $conf-&gt;get(&apos;KEY1&apos;);   ($field1, $field2) = $conf-&gt;get(qw(KEY1 KEY2));   $conf-&gt;set(KEY1 =&gt; &apos;foo&apos;, KEY2 =&gt; &apos;bar&apos;);</p><p>  # This was just a really bad idea to begin with, plus it&apos;s   # effective broken at this point (only returns a copy of the   # internal hash now, so it&apos;s effectively read-only)   $hashref = $conf-&gt;getRef;</p><p>  # This is just a wrapper for the class function   $errstr = $conf-&gt;error</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REQUIREMENTS</h2>
        <div class="sectioncontent">
<ul>
<li><p>Paranoid</p></li><li><p>Text::ParseWords</p></li><li><p>Text::Tabs</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Parse::PlainConfig provides \s-1OO\s0 objects which can parse and generate human-readable configuration files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILE SYNTAX</h2>
        <div class="sectioncontent">
<h3>\s-1TRADITIONAL\s0 \s-1USAGE\s0</h3>
<p>The plain parser supports the reconstructions of relatively simple data structures.  Simple string assignments and one-dimensional arrays and hashes are possible.  Below are are various examples of constructs:</p><p>  # Scalar assignment   FIRST_NAME: Joe   LAST_NAME: Blow</p><p>  # Array assignment   FAVOURITE_COLOURS: red, yellow, green   ACCOUNT_NUMBERS:  9956-234-9943211, &#92;                     2343232-421231445, &#92;                     004422-03430-0343</p><p>  # Hash assignment   CARS:  crown_vic =&gt; 1982, &#92;          geo       =&gt; 1993</p><p>As the example above demonstrates, all lines that begin with a '#' (leading whitespace is allowed) are ignored as comments.  if '#" occurs in any other position, it is accepted as part of the passed value.  This means that you <strong>cannot</strong> place comments on the same lines as values.</p><p>All directives and associated values will have both leading and trailing whitespace stripped from them before being stored in the configuration hash. Whitespace is allowed within both.</p><p>In traditional mode (meaning no parameters are set to be coerced into a specific datatype) one must encapsulate list and hash delimiters with quotation marks in order to prevent the string from being split and stored as a list or hash.  Quotation marks that are a literal part of the string must be backslashed.</p>
<h3>\s-1SMART\s0 \s-1PARSER\s0</h3>
<p>The new parser now provides some options to make the file syntax more convenient.  You can activate the smart parser by setting <strong>\s-1SMART_PARSER\s0</strong> to a true value during object instantiation or via the <strong>property</strong> method.</p><p>With the traditional parser you had to backslach the end of all preceding lines if you wanted to split a value into more than one line:</p><p>  FOO:  This line starts here &#92;         and ends here...</p><p>With the smart parser enabled that is no longer necessary as long as the following lines are indented further than the first line:</p><p>  FOO:  This line starts here         and ends here...</p><p><strong>Note:</strong>  The indentation is compared by byte count with no recognition of tab stops.  That means if you indent with spaces on the first line and indent with tabs on the following it may not concantenate those values.</p><p>Another benefit of the smart parser is found when you specify a parameter to be of a specific datatype via the <strong>\s-1COERCE\s0</strong> hash during object instantiation or the <strong>coerce</strong> method.  For instance, the traditional parser requires you to encapsulate strings with quotation marks if they contain list or hash delimiters:</p><p>  Quote:  "&#92;"It can&apos;t be that easy,&#92;" he said."</p><p>Also note how you had to escape quotation marks if they were to be a literal part of the string.  With this parameter set to be coerced to a scalar you can simply write:</p><p>  Quote:  "It can&apos;t be that easy," he said.</p><p>Similarly, you don't have to quote hash delimiters in parameters set to be coerced into lists.  Quotation marks as part of an element value must be escaped, though, since unescaped quotation marks are assumed to encapsulate strings containing list delimiters you don't want to split on.</p><p><strong>Note:</strong> The previous versions of Parse::PlainConfig did not allow the user to set keys like:</p><p>  FOO: &#92;       bar</p><p>or save empty assignments like</p><p>  FOO:</p><p>This is no longer the case.  Both are now valid and honoured.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SECURITY</h2>
        <div class="sectioncontent">
<p><strong>\s-1WARNING:\s0</strong> This parser will attempt to open what ever you pass to it for a filename as is.  If this object is to be used in programs that run with permissions other than the calling user, make sure you sanitize any user-supplied filename strings before passing them to this object.</p><p>This also uses a blocking b&lt;flock&gt; call to open the file for reading and writing.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<h3>Parse::PlainConfig::ERROR</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>new</h3>
<p>  $conf = new Parse::PlainConfig;   $conf = Parse::PlainConfig-&gt;new(     &apos;PARAM_DELIM&apos; =&gt; &apos;=&apos;,     &apos;FILE&apos;        =&gt; &apos;.myrc&apos;,     &apos;MAX_BYTES&apos;   =&gt; 65536,     &apos;SMART_PARSER =&gt; 1,     );</p><p>The object constructor can be called with or without arguments.  Arguments available for use include:</p><p>  Argument        Default    Purpose   =============================================================   ORDER           []         Specifies specific order of                              fields to be used while writing   FILE            undef      Filename for read/write ops   PARAM_DELIM       &apos;:&apos;        Field/value delimiter   LIST_DELIM      &apos;,&apos;        List delimiter within field values   HASH_DELIM      &apos;=&gt;&apos;       Hash key/value delimiter within                              field values   AUTOPURGE       0          Autopurge enabled/disabled   COERCE          {}         Field coercion hash   DEFAULTS        {}         Default field values   SMART_PARSER    0          Smart parser enabled/disabled   MAX_BYTES       16384      Integer denoting maximum bytes                              to read in any given file</p><p><strong>\s-1DELIM\s0</strong>, <strong>\s-1PURGE\s0</strong>, and  <strong>\s-1FORCE_SCALAR\s0</strong> are still available for backwards compatibility, but may be removed in the future.  One should use <strong>\s-1PARAM_DELIM\s0</strong> <strong>\s-1AUTOPURGE\s0</strong>, and <strong>\s-1COERCE\s0</strong> instead.</p><p><strong>\s-1COERCE\s0</strong> is a hash of field name/data type pairs.  If a field is listed in this hash then their values will always be returned in the requested format of either string, list, or hash.  Any field coerced to string, for instance, will ignore list and hash delimiters and assume the entire value will always be string value.</p><p><strong>\s-1DEFAULTS\s0</strong> is a hash of field name/value pairs.  This ensures that even if a field is not explicitly set (either in a conf file or programmatically) a default value can still be retrieved.</p><p><strong>\s-1SMART_PARSER\s0</strong> removes the need to backslash end-of-lines to continue the value onto the next.  If the following line is indented further than the tag was it will automatically assume that the next line is a continuation of the previous.  It also affects the need to encapsulate coerced datatypes with quotation marks for irrelevant delimiters.</p><p><strong>\s-1AUTOPURGE\s0</strong> erases all stored parameters and values before reading a file. This does not, however, erase any values set for <strong>\s-1ORDER\s0</strong>.</p>
<h3>property</h3>
<p>  $conf-&gt;property(PARAM_DELIM =&gt; &apos;=&apos;);</p><p>This method sets or retrieves the specified property.  Please note that this <strong>overwrites</strong> the current value, even for those properties that are references to lists and hashes.</p><p>If you're using this to set a property it will return a boolean true or false depending on the success of the operation.  If you're just retrieving a property it will return the value of the property.  If you ask for a nonexistent property it will <strong>croak</strong>.</p>
<h3>purge</h3>
<p>  $conf-&gt;<strong>purge</strong>(1);   $conf-&gt;purge;</p><p><strong>\s-1NOTE:\s0</strong>  Use of this method to set the purge mode is deprecated and will be removed in the future.  For that please use the <strong>property</strong> method instead.</p><p>This method either (re)sets the auto-purge mode, or performs an immediate manual purge.  Auto-purge mode clears the configuration hash each time a configuration file is read, so that the internal configuration data consists solely of what is in that file.  If you wanted to combine the settings of multiple files that each may exclusively hold some directives, setting this to 'off' will load the combined configuration as you read each file.</p><p>You can still clobber configuration values, of course, if the same directive is defined in multiple files.  In that case, the last file's value will be the one stored in the hash.</p><p>This does not clear the <strong>order</strong> or <strong>coerce</strong> properties.</p><p>Autopurge mode is disabled by default.</p>
<h3>read</h3>
<p>  $rv = $conf-&gt;read(&apos;myconf.conf&apos;);   $rv = $conf-&gt;read;</p><p>The read method is called initially with a filename as the only argument. This causes the parser to read the file and extract all of the configuration directives from it.</p><p>You'll notice that you can also call the read method without an argument. The name of the file read is stored internally, and if already set to a valid value (either by a previous call to <strong>read</strong> with a filename argument or by setting the <strong>\s-1FILE\s0</strong> property) this will read that file's contents.</p><p>The return value will be one if the file was successfully read and parsed, or zero otherwise.  The reason for failure can be read via <strong>Parse::PlainConfig::ERROR</strong>.</p><p>This function will cause the program to croak if called without a filename ever being defined.</p>
<h3>readIfNewer</h3>
<p>  $rv = $conf-&gt;readIfNewer;</p><p>This method is used to reread & parse the file only if the mtime appears newer than when last read.  If the file was successfully reread or appears to be the same it will return true.  Any errors will be stored in <strong>Parse::PlainConfig::ERROR</strong> and it will return a false value.</p><p>You can determine whether or not the file was read by the true value.  If it was re-read it will return 1.  If the file appears to be the same age it will return a 2.</p>
<h3>write</h3>
<p>  $conf-&gt;write(&apos;.myrc&apos;, 2);</p><p>This method writes the current configuration stored in memory to the specified file, either specified as the first argument, or as stored from an explicit or implicit <strong>read</strong> call.</p><p>The second argument specifies what kind of whitespace padding, if any, to use with the directive/value delimiter.  The following values are recognised:</p><p>  Value    Meaning   ================================================   0        No padding (i.e., written as KEY:VALUE)   1        Left padding (i.e., written as KEY :VALUE)   2        Right padding (i.e., written as KEY: VALUE)   3        Full padding (i.e., written as KEY : VALUE)</p><p>Both arguments are optional.</p>
<h3>parameters</h3>
<p>  @parameters = $conf-&gt;parameters;</p><p>This method returns a list of all the names of the directives currently stored in the configuration hash in no particular order.</p>
<h3>parameter</h3>
<p>  $value = $conf-&gt;parameter(&apos;SCALAR1&apos;);   @values = $conf-&gt;parameter(&apos;LIST1&apos;);   %values = $conf-&gt;parameter(&apos;HASH1&apos;);   $conf-&gt;parameter(&apos;SCALAR1&apos;, "foo");   $conf-&gt;parameter(&apos;LIST1&apos;, [qw(foo bar)]);   $conf-&gt;parameter(&apos;HASH1&apos;, { foo =&gt; &apos;bar&apos; });</p><p>This method sets or retrieves the specified parameter.  Hash and list values are copied and returned as a list.  If the specified parameter is set to be coerced into a specific data type the specified value will be converted to that datatype.   This means you can do something like:</p><p>  # SCALAR1 will equal "foo , bar , roo" assuming LIST_DELIM is set to &apos;,&apos;   $conf-&gt;coerce(qw(string SCALAR1));   $conf-&gt;parameter(&apos;SCALAR1&apos;, [qw(foo bar roo)]);</p><p>  # SCALAR1 will equal "foo =&gt; bar : roo =&gt; &apos;&apos;" assuming HASH_DELIM is set   # to &apos;=&gt;&apos; and LIST_DELIM is set to &apos;:&apos;   $conf-&gt;parameter(&apos;SCALAR1&apos;, { &apos;foo&apos; =&gt; &apos;bar&apos;, &apos;roo&apos; =&gt; &apos;&apos; });</p><p>In order for conversions to be somewhat predictable (in the case of hashes coerced into other values) hash key/value pairs will be assigned to string or list portions according to the alphabetic sort order of the keys.</p>
<h3>coerce</h3>
<p>  $conf-&gt;coerce("string", "FOO", "BAR");</p><p>This method configures the parser to coerce values into the specified datatype (either string, list, or hash) and immediately convert any existing values and store them into that datatype as well.</p>
<h3>describe</h3>
<p>  $conf-&gt;describe(KEY1 =&gt; &apos;This is foo&apos;, KEY2 =&gt; &apos;This is bar&apos;);</p><p>The describe method takes any number of key/description pairs which will be used as comments preceding the directives in any newly written conf file.  You are responsible for prepending a comment character to each line, as well as splitting along your desired text width.</p>
<h3>order</h3>
<p>  @order = $conf-&gt;order;   $conf-&gt;order(@new_order);</p><p>This method returns the current order of the configuration directives as read from the file.   If called with a list as an argument, it will set the directive order with that list.  This method is probably of limited use except when you wish to control the order in which directives are written in new conf files.</p><p>Please note that if there are more directives than are present in this list, those extra keys will still be included in the new file, but will appear in alphabetically sorted order at the end, after all of the keys present in the list.</p>
<h3>hasParameter</h3>
<p>  $rv = $conf-&gt;hasParameter(&apos;FOO&apos;);</p><p>This function allows you to see if a parameter has been defined or has a default set for it.  Returns a boolean value.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEPRECATED METHODS</h2>
        <div class="sectioncontent">
<h3>delim</h3>
<p>  $conf-&gt;delim(&apos;=&apos;);</p><p>This method gets and/or sets the parameter name/value delimiter to be used in the conf files.  The default delimiter is ':'.  This can be multiple characters.</p>
<h3>directives</h3>
<p>  @directives = $conf-&gt;directives;</p><p>This method returns a list of all the names of the directives currently stored in the configuration hash in no particular order.</p>
<h3>get</h3>
<p>  $field = $conf-&gt;get(&apos;KEY1&apos;);   ($field1, $field2) = $conf-&gt;get(qw(KEY1 KEY2));</p><p>The get method takes any number of directives to retrieve, and returns them. Please note that both hash and list values are passed by reference.  In order to protect the internal state information, the contents of either reference is merely a copy of what is in the configuration object's hash.  This will <strong>not</strong> pass you a reference to data stored internally in the object.  Because of this, it's perfectly safe for you to shift off values from a list as you process it, and so on.</p>
<h3>set</h3>
<p>  $conf-&gt;set(KEY1 =&gt; &apos;foo&apos;, KEY2 =&gt; &apos;bar&apos;);</p><p>The set method takes any number of directive/value pairs and copies them into the internal configuration hash.</p>
<h3>get_ref</h3>
<p>  $href = $conf-&gt;get_ref</p><p><strong>Note</strong>:  This used to give you a reference to the internal configuration hash so you could manipulate it directly.  It now only gives you a <strong>copy</strong> of the internal hash (actually, it's reconstructed has to make it look like the old data structure).  In short, any changes you make to this hash <strong>will be lost</strong>.</p>
<h3>error</h3>
<p>  warn $conf-&gt;error;</p><p>This method returns a zero-length string if no errors were registered with the last operation, or a text message describing the error.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>Through the use of <strong>Paranoid::Debug</strong> this module will produce internal diagnostic output to \s-1STDERR\s0.  It begins logging at log level 7.  To enable debugging output please see the pod for Paranoid::Debug.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p>  2002/01/18:  Original public release (v1.1)   2006/05/26:  Complete rewrite (v2.0)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR/COPYRIGHT</h2>
        <div class="sectioncontent">
<p>(c) 2002 Arthur Corliss (corliss@digitalmages.com)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Parse::MediaWikiDump::page.3pm.html"><span aria-hidden="true">&larr;</span> Parse::MediaWikiDump::page.3pm: Object representing a specific revision of a mediawiki page</a></li>
   <li class="next"><a href="Parse::RecDescent.3pm.html">Parse::RecDescent.3pm: Generate recursive-descent parsers <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

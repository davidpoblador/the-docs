<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MP3::Tag::ID3v2: Read / write id3v2.x.y tags from mp3 audio files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Read / write id3v2.x.y tags from mp3 audio files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="MP3::Tag::ID3v2 (3pm) manual">
  <meta name="twitter:description" content="Read / write id3v2.x.y tags from mp3 audio files">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmp3-tag-perl-MP3::Tag::ID3v2-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/MP3::Tag::ID3v2.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="MP3::Tag::ID3v2 (3pm) manual" />
  <meta property="og:description" content="Read / write id3v2.x.y tags from mp3 audio files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmp3-tag-perl-MP3::Tag::ID3v2-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">MP3::Tag::ID3v2<small> (3pm)</small></h1>
        <p class="lead">Read / write id3v2.x.y tags from mp3 audio files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/MP3::Tag::ID3v2.3pm.html">
      <span itemprop="name">MP3::Tag::ID3v2: Read / write id3v2.x.y tags from mp3 audio files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmp3-tag-perl/">
      <span itemprop="name">libmp3-tag-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/MP3::Tag::ID3v2.3pm.html">
      <span itemprop="name">MP3::Tag::ID3v2: Read / write id3v2.x.y tags from mp3 audio files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>MP3::Tag::ID3v2 supports</p>
<pre>
  * Reading of ID3v2.2.0 and ID3v2.3.0 tags (some ID3v2.4.0 frames too)
  * Writing of ID3v2.3.0 tags
</pre>
<p>MP3::Tag::ID3v2 is designed to be called from the MP3::Tag module.  If you want to make calls from user code, please consider using highest-level wrapper code in MP3::Tag, such as <em>update_tags()</em> and <em>select_id3v2_frame_by_descr()</em>.</p><p>Low-level creation code:</p>
<pre>
  use MP3::Tag;
  $mp3 = MP3::Tag-&gt;new($filename);

  # read an existing tag
  $mp3-&gt;get_tags();
  $id3v2 = $mp3-&gt;{ID3v2} if exists $mp3-&gt;{ID3v2};

  # or create a new tag
  $id3v2 = $mp3-&gt;new_tag("ID3v2");
</pre>
<p>See MP3::Tag for information on the above used functions.</p><p>* Reading a tag, very low-level:</p><p>  $frameIDs_hash = $id3v2-&gt;get_frame_ids(&apos;truename&apos;);</p><p>  foreach my $frame (keys %$frameIDs_hash) {       my ($name, @info) = $id3v2-&gt;get_frames($frame);       for my $info (@info) {           if (ref $info) {               print "$name ($frame):&#92;n";               while(my ($key,$val)=each %$info) {                   print " * $key =&gt; $val&#92;n";              }           } else {               print "$name: $info&#92;n";           }       }   }</p><p>* Adding / Changing / Removing a frame in memory (higher-level)</p><p>  $t = $id3v2-&gt;frame_select("TIT2", undef, undef); # Very flexible</p><p>  $c = $id3v2-&gt;frame_select_by_descr("COMM(fre,fra,eng,#0)[]");   $t = $id3v2-&gt;frame_select_by_descr("TIT2");        $id3v2-&gt;frame_select_by_descr("TIT2", "MyT"); # Set/Change        $id3v2-&gt;frame_select_by_descr("RBUF", $n1, $n2, $n3); # Set/Change        $id3v2-&gt;frame_select_by_descr("RBUF", "$n1;$n2;$n3"); # Set/Change        $id3v2-&gt;frame_select_by_descr("TIT2", undef); # Remove</p><p>* Adding / Changing / Removing a frame in memory (low-level)</p><p>  $id3v2-&gt;add_frame("TIT2", "Title of the audio");   $id3v2-&gt;change_frame("TALB","Greatest Album");   $id3v2-&gt;remove_frame("TLAN");</p><p>* Output the modified-in-memory version of the tag:</p><p>  $id3v2-&gt;write_tag();</p><p>* Removing the whole tag from the file</p><p>  $id3v2-&gt;remove_tag();</p><p>* Get information about supported frames</p><p>  %tags = $id3v2-&gt;supported_frames();   while (($fname, $longname) = each %tags) {       print "$fname $longname: ",             join(", ", @{$id3v2-&gt;what_data($fname)}), "&#92;n";   }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Thomas Geffert, thg@users.sourceforge.net Ilya Zakharevich, ilyaz@cpan.org</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>get_frame_ids()</em>
  </dt>
  <dd>
    <p>  $frameIDs = $tag-&gt;get_frame_ids;   $frameIDs = $tag-&gt;get_frame_ids(&apos;truename&apos;);</p><p>  [old name: getFrameIDs() . The old name is still available, but you should use the new name] get_frame_ids loops through all frames, which exist in the tag. It returns a hash reference with a list of all available Frame IDs. The keys of the returned hash are 4-character-codes (short names), the internal names of the frames, the according value is the english (long) name of the frame. You can use this list to iterate over all frames to get their data, or to check if a specific frame is included in the tag. If there are multiple occurences of a frame in one tag, the first frame is returned with its normal short name, following frames of this type get a '01', '02', '03', ... appended to this name.  These names can then used with \*(C`get_frame\*(C' to get the information of these frames.  These fake frames are not returned if &apos;truename&apos; argument is set; one can still use \*(C`get_frames()\*(C' to extract the info for all of the frames with the given short name.</p>
  </dd>
  <dt>
    <em>get_frame()</em>
  </dt>
  <dd>
    <p>  ($info, $name, @rest) = $tag-&gt;get_frame($ID);   ($info, $name, @rest) = $tag-&gt;get_frame($ID, &apos;raw&apos;);</p><p>  [old name: getFrame() . The old name is still available, but you should use the new name] get_frame gets the contents of a specific frame, which must be specified by the 4-character-ID (aka short name). You can use \*(C`get_frame_ids\*(C' to get the IDs of the tag, or use IDs which you hope to find in the tag. If the \s-1ID\s0 is not found, \*(C`get_frame\*(C' returns empty list, so $info and $name become undefined. Otherwise it extracts the contents of the frame. Frames in ID3v2 tags can be very small, or complex and huge. That is the reason, that \*(C`get_frame\*(C' returns the frame data in two ways, depending on the tag. If it is a simple tag, with only one piece of data, these data is returned directly as ($info, $name), where $info is the text string, and $name is the long (english) name of the frame. If the frame consist of different pieces of data, $info is a hash reference, $name is again the long name of the frame. The hash, to which $info points, contains key/value pairs, where the key is always the name of the data, and the value is the data itself. If the name starts with a underscore (as eg '_code'), the data is probably binary data and not printable. If the name starts without an underscore, it should be a text string and printable. If the second parameter is given as &apos;raw&apos;, the whole frame data is returned, but not the frame header.  If the second parameter is &apos;intact&apos;, no mangling of embedded "&#92;0" and trailing spaces is performed.  If the second parameter is &apos;hash&apos;, then, additionally, the result is always in the hash format; likewise, if it is &apos;array&apos;, the result is an array reference (with \*(C`key =&gt; value\*(C' pairs same as with &apos;hash&apos;, but ordered as in the frame). If it is &apos;array_nokey&apos;, only the \*(L"value\*(R" parts are returned (in particular, the result is suitable to give to <em>add_frame()</em>, <em>change_frame()</em>); in addition, if it is &apos;array_nodecode&apos;, then keys are not returned, and the setting of \*(C`decode_encoding_v2\*(C' is ignored.  (The \*(L"return array\*(R" flavors don't massage the fields for better consumption by humans, so the fields should be in format suitable for <em>frame_add()</em>.) If the data was stored compressed, it is uncompressed before it is returned (even in raw mode). Then $info contains a string with all data (which might be binary), and $name the long frame name. See also MP3::Tag::ID3v2_Data for a list of all supported frames, and some other explanations of the returned data structure. If more than one frame with name $ID is present, @rest contains $info fields for all consequent frames with the same name.  Note that after removal of frames there may be holes in the list of frame names (as in \*(C`FRAM FRAM01 FRAM02\*(C') in the case when multiple frames of the given type were present; the removed frames are returned as \*(C`undef\*(C'. ! Encrypted frames are not supported yet ! ! Some frames are not supported yet, but the most common ones are supported !</p>
  </dd>
  <dt>
    <em>get_frame_descr()</em>
  </dt>
  <dd>
    <p>  $long_name = $self-&gt;get_frame_descr($fname); returns a \*(L"long name\*(R" for the frame (such as \*(C`COMM(eng)[lyricist birthdate]\*(C'), appropriate for interpolation, or for <em>frame_select_by_descr()</em>.</p>
  </dd>
  <dt>
    <em>get_frame_descriptors()</em>
  </dt>
  <dd>
    <p>  @long_names = $self-&gt;get_frame_descriptors(); return \*(L"long names\*(R" for the frames in the tag (see \*(C`get_frame_descr\*(C').</p>
  </dd>
  <dt>
    <em>get_frame_option()</em>
  </dt>
  <dd>
    <p>  $options = get_frame_option($ID);</p><p>  Option is a hash reference, the hash contains all possible options.   The value for each option is 0 or 1.</p><p>  groupid    -- not supported yet   encryption -- not supported yet   compression -- Compresses frame before writing tag;                  compression/uncompression is done automatically   read_only   -- Ignored by this library, should be obeyed by application   file_preserv -- Ignored by this library, should be obeyed by application   tag_preserv -- Ignored by this library, should be obeyed by application</p>
  </dd>
  <dt>
    <em>set_frame_option()</em>
  </dt>
  <dd>
    <p>  $options = set_frame_option($ID, $option, $value);</p><p>  Set $option to $value (0 or 1). If successfull the new set of   options is returned, undef otherwise.</p><p>  groupid    -- not supported yet   encryption -- not supported yet   compression -- Compresses frame before writing tag;                  compression/uncompression is done automatically   read_only   -- Ignored by this library, should be obeyed by application   file_preserv -- Ignored by this library, should be obeyed by application   tag_preserv -- Ignored by this library, should be obeyed by application</p>
  </dd>
  <dt>
    <em>get_frames()</em>
  </dt>
  <dd>
    <p>  ($name, @info) = get_frames($ID);   ($name, @info) = get_frames($ID, &apos;raw&apos;); Same as <em>get_frame()</em> with different order of the returned values. $name and elements of the array @info have the same semantic as for <em>get_frame()</em>; each frame with id $ID produces one elements of array @info.</p>
  </dd>
  <dt>
    <em>as_bin()</em>
  </dt>
  <dd>
    <p>  $tag2 = $id3v2-&gt;as_bin($ignore_error, $update_file, $raw_ok); Returns the the current content of the ID3v2 tag as a string good to write to a file; it contains all the necessary footers and headers. If $ignore_error is \s-1TRUE\s0, the frames the module does not know how to write are skipped; otherwise it is an error to have such a frame. Returns undef on error. If the optional argument $update_file is \s-1TRUE\s0, an additional action is performed: if the audio file does not contain an ID3v2 tag, or the tag in the file is smaller than the built ID3v2 tag, the necessary 0-padding is inserted before the audio content of the file so that it is able to accommodate the build tag (and the \*(C`tagsize\*(C' field of $id3v2 is updated correspondingly); in any case the header length of $tag2 is set to reflect the space in the beginning of the audio file. Unless $update_file has &apos;padding&apos; as a substring, the actual length of the string $tag2 is not modified, so if it is smaller than the reserved space in the file, one needs to add some 0 padding at the end.  Note that if the size of reserved space can shrink (as with \*(C`id3v2_shrink\*(C' configuration option), then without this option it would be hard to calculate necessary padding by hand. If $raw_ok option is given, but not $update_file, the original contents is returned for unmodified tags.</p>
  </dd>
  <dt>
    <em>as_bin_raw()</em>
  </dt>
  <dd>
    <p>  $tag2 = $id3v2-&gt;as_bin_raw($ignore_error, $update_file); same as <em>as_bin()</em> with $raw_ok flag.</p>
  </dd>
  <dt>
    <em>write_tag()</em>
  </dt>
  <dd>
    <p>  $id3v2-&gt;write_tag($ignore_error); Saves all frames to the file. It tries to update the file in place, when the space of the old tag is big enough for the new tag. Otherwise it creates a temp file with a new tag (i.e. copies the whole mp3 file) and renames/moves it to the original file name. An extended header with \s-1CRC\s0 checksum is not supported yet. Encryption of frames and group ids are not supported. If $ignore_error is set, these options are ignored and the frames are saved without these options. If $ignore_error is not set and a tag with an unsupported option should be save, the tag is not written and a 0 is returned. If a tag with an encrypted frame is read, and the frame is not changed it can be saved encrypted again. ID3v2.2 tags are converted automatically to ID3v2.3 tags during writing. If a frame cannot be converted automatically (\s-1PIC\s0; \s-1CMR\s0), writing aborts and returns a 0. If $ignore_error is true, only not convertable frames are ignored and not written, but the rest of the tag is saved as ID3v2.3. At the moment the tag is automatically unsynchronized. If the tag is written successfully, 1 is returned.</p>
  </dd>
  <dt>
    <em>remove_tag()</em>
  </dt>
  <dd>
    <p>  $id3v2-&gt;remove_tag(); Removes the whole tag from the file by copying the whole mp3-file to a temp-file and renaming/moving that to the original filename. Do not use <em>remove_tag()</em> if you only want to change a header, as otherwise the file is copied unnecessarily. Use <em>write_tag()</em> directly, which will override an old tag.</p>
  </dd>
  <dt>
    <em>add_frame()</em>
  </dt>
  <dd>
    <p>  $fn = $id3v2-&gt;add_frame($fname, @data); Add a new frame, identified by the short name $fname.  The number of elements of array @data should be as described in the ID3v2.3 standard.  (See also MP3::Tag::ID3v2_Data.)  There are two exceptions: if @data is empty, it is filled with necessary number of ""); if one of required elements is \*(C`encoding\*(C', it may be omitted or be \*(C`undef\*(C', meaning the arguments are in \*(L"Plain Perl (=ISOLatin-1 or Unicode) encoding\*(R". It returns the the short name $fn (which can differ from $fname, when an $fname frame already exists). If no other frame of this kind is allowed, an empty string is returned. Otherwise the name of the newly created frame is returned (which can have a 01 or 02 or ... appended). You have to call <em>write_tag()</em> to save the changes to the file. Examples (with \*(C`$id3v2-&gt;\*(C' omitted):  $f = add_frame(&apos;TIT2&apos;, 0, &apos;Abba&apos;);   # $f=&apos;TIT2&apos;  $f = add_frame(&apos;TIT2&apos;, &apos;Abba&apos;);      # $f=&apos;TIT201&apos;, encoding=0 implicit</p><p> $f = add_frame(&apos;COMM&apos;, &apos;ENG&apos;, &apos;Short text&apos;, &apos;This is a comment&apos;);</p><p> $f = add_frame(&apos;COMM&apos;);              # creates an empty frame</p><p> $f = add_frame(&apos;COMM&apos;, &apos;ENG&apos;);       # ! wrong ! $f=undef, becaues number                                       # of arguments is wrong</p><p> $f = add_frame(&apos;RBUF&apos;, $n1, $n2, $n3);  $f = add_frame(&apos;RBUF&apos;, $n1, $n2);      # last field of RBUF is optional If a frame has optional fields <em>and</em> \*(C`encoding\*(C' (only \*(C`COMR\*(C' frame as of ID3v2.4), there may be an ambiguity which fields are omitted. It is resolved this way: the \*(C`encoding\*(C' field can be omitted only if all other optional frames are omitted too (set it to \*(C`undef\*(C' instead).</p>
  </dd>
  <dt>
    <em>add_frame_split()</em>
  </dt>
  <dd>
    <p>The same as <em>add_frame()</em>, but if the number of arguments is unsufficient, would <em>split()</em> the last argument on \*(C`;\*(C' to obtain the needed number of arguments.  Should be avoided unless it is known that the fields do not contain \*(C`;\*(C' (except for \*(C`POPM RBUF RVRB SYTC\*(C', where splitting may be done non-ambiguously).   # No ambiguity, since numbers do not contain ";":   $f = add_frame_split(&apos;RBUF&apos;, "$n1;$n2;$n3"); For \*(C`COMR\*(C' frame, in case when the fields are \*(C`join()\*(C'ed by &apos;;&apos;, \*(C`encoding\*(C' field may be present only if all the other fields are present.</p>
  </dd>
  <dt>
    <em>change_frame()</em>
  </dt>
  <dd>
    <p>  $id3v2-&gt;change_frame($fname, @data); Change an existing frame, which is identified by its short name $fname eg as returned by <em>get_frame_ids()</em>. @data must be same as in <em>add_frame()</em>. If the frame $fname does not exist, undef is returned. You have to call <em>write_tag()</em> to save the changes to the file.</p>
  </dd>
  <dt>
    <em>remove_frame()</em>
  </dt>
  <dd>
    <p>  $id3v2-&gt;remove_frame($fname); Remove an existing frame. $fname is the short name of a frame, eg as returned by <em>get_frame_ids()</em>. You have to call <em>write_tag()</em> to save the changes to the file. Copies specified frames between \*(C`MP3::Tag::ID3v2\*(C' objects $from, $to.  Unless $keep_flags, the copied frames have their flags cleared. If the array reference $f_ids is not specified, all the frames (but \*(C`GRID\*(C' and \*(C`TLEN\*(C') are considered (subject to $overwrite), otherwise $f_ids should contain short frame ids to consider. Group \s-1ID\s0 flag is always cleared. If $overwrite is &apos;delete&apos;, frames with the same descriptors (as returned by <em>get_frame_descr()</em>) in $to are deleted first, then all the specified frames are copied.  If $overwrite is \s-1FALSE\s0, only frames with descriptors not present in $to are copied.  (If one of these two conditions is not met, the result may be not conformant to standards.) Returns count of copied frames.</p>
  </dd>
  <dt>
    <em>is_modified()</em>
  </dt>
  <dd>
    <p>  $id3v2-&gt;is_modified; Returns true if the tag was modified after it was created.</p>
  </dd>
  <dt>
    <em>supported_frames()</em>
  </dt>
  <dd>
    <p>  $frames = $id3v2-&gt;supported_frames(); Returns a hash reference with all supported frames. The keys of the hash are the short names of the supported frames, the according values are the long (english) names of the frames.</p>
  </dd>
  <dt>
    <em>what_data()</em>
  </dt>
  <dd>
    <p>  ($data, $res_inp, $data_map) = $id3v2-&gt;what_data($fname); Returns an array reference with the needed data fields for a given frame. At this moment only the internal field names are returned, without any additional information about the data format of this field. Names beginning with an underscore (normally '_data') can contain binary data.  (The \*(C`_encoding\*(C' field is skipped in this list, since it is usually auto-deduced by this module.) $resp_inp is a reference to a hash (keyed by the field name) describing restrictions for the content of the data field. If the entry is undef, no restriction exists. Otherwise it is a hash. The keys of the hash are the allowed input, the correspodending value is the value which is actually stored in this field. If the value is undef then the key itself is valid for saving. If the hash contains an entry with \*(L"_FREE\*(R", the hash contains only suggestions for the input, but other input is also allowed. $data_map contains values of $resp_inp in the order of fields of a frame (including \*(C`_encoding\*(C'). Example for picture types of the \s-1APIC\s0 frame:   {"Other"                               =&gt; "&#92;x00",    "32x32 pixels &apos;file icon&apos; (PNG only)" =&gt; "&#92;x01",    "Other file icon"                     =&gt; "&#92;x02",    ...}</p>
  </dd>
  <dt>
    title( [@new_title] )
  </dt>
  <dd>
    <p>Returns the title composed of the tags configured via \*(C`MP3::Tag-&gt;config(&apos;v2title&apos;)\*(C' call (with default 'Title/Songname/Content description' (\s-1TIT2\s0)) from the tag. (For backward compatibility may be called by deprecated name <em>song()</em> as well.) Sets \s-1TIT2\s0 frame if given the optional arguments @new_title.  If this is an empty string, the frame is removed.</p>
  </dd>
  <dt>
    _comment([$language])
  </dt>
  <dd>
    <p>Returns the file comment (\s-1COMM\s0 with an empty 'Description') from the tag, or \*(L"Subtitle/Description refinement\*(R" (\s-1TIT3\s0) frame (unless it is considered a part of the title).</p>
  </dd>
  <dt>
    <em>comment()</em>
  </dt>
  <dd>
    <p>   $val = $id3v2-&gt;comment();    $newframe = $id3v2-&gt;comment(&apos;Just a comment for freddy&apos;, &apos;personal&apos;, &apos;eng&apos;); Returns the file comment (\s-1COMM\s0 frame with the 'Description' field in \*(C`default_descr_c\*(C' configuration variable, defalting to &apos;&apos;) from the tag, or \*(L"Subtitle/Description refinement\*(R" (\s-1TIT3\s0) frame (unless it is considered a part of the title). If optional arguments ($comment, $short, $language) are present, sets the comment frame.  If $language is omited, uses the \*(C`default_language\*(C' configuration variable (default is \*(C`XXX\*(C').  If not \*(C`XXX\*(C', this should be lowercase 3-letter abbreviation according to \s-1ISO-639-2\s0). If $short is not defined, uses the \*(C`default_descr_c\*(C' configuration variable.  If $comment is an empty string, the frame is removed. Used to get/set/delete frames which may be not necessarily unique in a tag.    # Select short-description=&apos;&apos;, prefere language &apos;eng&apos;, then &apos;rus&apos;, then    # the third COMM frame, then any (in this case, the first or the second)    # COMM frame    $val = $id3v2-&gt;frame_select(&apos;COMM&apos;, &apos;&apos;, [&apos;eng&apos;, &apos;rus&apos;, &apos;#2&apos;, &apos;&apos;]); # Read    $new = $id3v2-&gt;frame_select(&apos;COMM&apos;, &apos;&apos;, [&apos;eng&apos;, &apos;rus&apos;, &apos;#2&apos;],      # Write                                &apos;Comment with empty "Description" and "eng"&apos;);    $new = $id3v2-&gt;frame_select(&apos;COMM&apos;, &apos;&apos;, [&apos;eng&apos;, &apos;rus&apos;, &apos;#2&apos;],      # Delete                                undef); Returns the contents of the first frame named $fname with a 'Description' field in the specified array reference $descrs and the language in the list of specified languages $languages; empty return otherwise.  If the frame is a \*(L"simple frame\*(R", the frame is returned as a string, otherwise as a hash reference; a \*(L"simple frame\*(R" should consist of one of Text/URL/_Data fields, with possible addition of Language and Description fields (if the corresponding arguments were defined). The lists $descrs and $languages of one element can be flattened to become this element (as with &apos;&apos; above).  If the lists are not defined, no restriction is applied; to get the same effect with defined arguments, use $languages of &apos;&apos;, and/or $descrs a hash reference.  Language of the form &apos;#NUMBER&apos; selects the \s-1NUMBER\s0's (0-based) frame with frame name $fname. If optional arguments \*(C`$newval1...\*(C' are given, <strong>\s-1ALL\s0</strong> the found frames are removed;  if only one such argument \*(C`undef\*(C' is given, this is the only action. Otherwise, a new frame is created afterwards (the first elements of $descrs and $languages are used as the short description and the language, defaulting to &apos;&apos; and the \*(C`default_language\*(C' configuration variable (which, in turn, defaults to \*(C`XXX\*(C'; if not \*(C`XXX\*(C', this should be lowercase 3-letter abbreviation according to \s-1ISO-639-2\s0). If new frame is created, the frame's name is returned; otherwise the count of removed frames is returned. As a generalization, \s-1APIC\s0 frames are handled too, using \*(C`Picture Type\*(C' instead of \*(C`Language\*(C', and auto-calculating \*(C`MIME type\*(C' for (currently) \s-1TIFF/JPEG/GIF/PNG/BMP\s0 and octet-stream.  Only frames with \*(C`MIME type\*(C' coinciding with the auto-calculated value are considered as \*(L"simple frames\*(R".  One can use both the 1-byte format for \*(C`Picture Type\*(C', and the long names used in the ID3v2 documentation; the default value is &apos;Cover (front)&apos;.    # Choose APIC with empty description, picture_type=&apos;Leaflet page&apos;    my $data = $id3v2-&gt;frame_select(&apos;APIC&apos;, &apos;&apos;, &apos;Leaflet page&apos;)        or die "no expected APIC frame found";    my $format = ( ref $data ? $data-&gt;{&apos;MIME type&apos;}                             : $id3v2-&gt;_Data_to_MIME($data) );    # I know what to do with application/pdf only (sp?) and &apos;image/gif&apos;    die "Do not know what to do with this APIC format: &#96;$format&apos;"        unless $format eq &apos;application/pdf&apos; or $format eq &apos;image/gif&apos;;    $data = $data-&gt;{_Data} if ref $data;         # handle non-simple frame</p><p>   # Set APIC frame with empty description (front cover if no other present)    # from content of file.gif    my $data = do { open my $f, &apos;&lt;&apos;, &apos;file.gif&apos; and binmode $f or die;                    undef $/; &lt;$f&gt;};    my $new_frame = $id3v2-&gt;frame_select(&apos;APIC&apos;, &apos;&apos;, undef, $data); Frames with multiple \*(L"content\*(R" fields may be set by providing multiple values to set.  Alternatively, one can also \*(C`join()\*(C' the values with &apos;;&apos; if the splitting is not ambiguous, e.g., for \*(C`POPM RBUF RVRB SYTC\*(C'.  (For frames \*(C`GEOD\*(C' and \*(C`COMR\*(C', which have a \*(C`Description\*(C' field, it should be specified among these values.)    $id3v2-&gt;frame_select("RBUF", undef, undef, $n1, $n2, $n3);    $id3v2-&gt;frame_select("RBUF", undef, undef, "$n1;$n2;$n3"); (By the way: consider using the method <em>select_id3v2_frame()</em> on the \*(L"parent\*(R" MP3::Tag object instead [see \*(L"select_id3v2_frame\*(R" in MP3::Tag], or <em>frame_select_by_descr()</em>.)</p>
  </dd>
  <dt>
    _Data_to_MIME
  </dt>
  <dd>
    <p>Internal method to extract \s-1MIME\s0 type from a string the image file content.  Returns \*(C`application/octet-stream\*(C' for unrecognized data (unless extra \s-1TRUE\s0 argument is given).   $format = $id3v2-&gt;_Data_to_MIME($data); Currently, only the first 4 bytes of the string are inspected.</p>
  </dd>
  <dt>
    <em>frame_list()</em>
  </dt>
  <dd>
    <p>Same as <em>frame_select()</em>, but returns the list of found frames, each an array reference \*(C`[$N, $f]\*(C' with $N the 0-based ordinal (among frames with the given short name), and $f the contents of a frame.</p>
  </dd>
  <dt>
    <em>frame_have()</em>
  </dt>
  <dd>
    <p>Same as <em>frame_select()</em>, but returns the count of found frames.</p>
  </dd>
  <dt>
    <em>frame_select_by_descr()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>frame_have_by_descr()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>frame_list_by_descr()</em>
  </dt>
  <dd>
    <p>  $c = $id3v2-&gt;frame_select_by_descr("COMM(fre,fra,eng,#0)[]");   $t = $id3v2-&gt;frame_select_by_descr("TIT2");        $id3v2-&gt;frame_select_by_descr("TIT2", "MyT"); # Set/Change        $id3v2-&gt;frame_select_by_descr("RBUF", $n1, $n2, $n3); # Set/Change        $id3v2-&gt;frame_select_by_descr("RBUF", "$n1;$n2;$n3"); # Set/Change        $id3v2-&gt;frame_select_by_descr("TIT2", undef); # Remove Same as <em>frame_select()</em>, <em>frame_have()</em>, <em>frame_list()</em>, but take one string argument instead of $fname, $descrs, $languages.  The argument should be of the form   NAME(langs)[descr] Both \*(C`(langs)\*(C' and \*(C`[descr]\*(C' parts may be omitted; <em>langs</em> should contain comma-separated list of needed languages; no protection by backslashes is needed in <em>descr</em>.  <em>frame_select_by_descr()</em> will return a hash if \*(C`(lang)\*(C' is omited, but the frame has a language field; likewise for \*(C`[descr]\*(C'; see below for alternatives. Remember that when <em>frame_select_by_descr()</em> is used for modification, <strong>\s-1ALL\s0</strong> found frames are deleted before a new one is added. (By the way: consider using the method <em>select_id3v2_frame_by_descr()</em> on the \*(L"parent\*(R" MP3::Tag object instead; see \*(L"select_id3v2_frame_by_descr\*(R" in MP3::Tag.)</p>
  </dd>
  <dt>
    <em>frame_select_by_descr_simple()</em>
  </dt>
  <dd>
    <p>Same as <em>frame_select_by_descr()</em>, but if no language is given, will not consider the frame as \*(L"complicated\*(R" frame even if it contains a language field.</p>
  </dd>
  <dt>
    <em>frame_select_by_descr_simpler()</em>
  </dt>
  <dd>
    <p>Same as <em>frame_select_by_descr_simple()</em>, but if no \*(C`Description\*(C' is given, will not consider the frame as \*(L"complicated\*(R" frame even if it contains a \*(C`Description\*(C' field.</p>
  </dd>
  <dt>
    year( [@new_year] )
  </dt>
  <dd>
    <p>Returns the year (\s-1TYER/TDRC\s0) from the tag. Sets \s-1TYER\s0 and \s-1TDRC\s0 frames if given the optional arguments @new_year.  If this is an empty string, the frame is removed. The format is similar to timestamps of IDv2.4.0, but ranges can be separated by \*(C`-\*(C' or \*(C`--\*(C', and non-contiguous dates are separated by \*(C`,\*(C' (comma).  If periods need to be specified via duration, then one needs to use the \s-1ISO\s0 8601 \*(C`/\*(C'-notation  (e.g., see   http://www.mcs.vuw.ac.nz/technical/software/SGML/doc/iso8601/ISO8601.html ); the \*(C`duration/end_timestamp\*(C' is not supported. On output, ranges of timestamps are converted to \*(C`-\*(C' or \*(C`--\*(C' separated format depending on whether the timestamps are years, or have additional fields. If configuration variable \*(C`year_is_timestamp\*(C' is false, the return value is always the year only (of the first timestamp of a composite timestamp). Recall that ID3v2.4.0 timestamp has format yyyy-MM-ddTHH:mm:ss (year, \*(L"-\*(R", month, \*(L"-\*(R", day, \*(L"T\*(R", hour (out of 24), \*(L":\*(R", minutes, \*(L":\*(R", seconds), but the precision may be reduced by removing as many time indicators as wanted. Hence valid timestamps are yyyy, yyyy-MM, yyyy-MM-dd, yyyy-MM-ddTHH, yyyy-MM-ddTHH:mm and yyyy-MM-ddTHH:mm:ss. All time stamps are \s-1UTC\s0. For durations, use the slash character as described in 8601, and for multiple noncontiguous dates, use multiple strings, if allowed by the frame definition.</p>
  </dd>
  <dt>
    track( [$new_track] )
  </dt>
  <dd>
    <p>Returns the track number (\s-1TRCK\s0) from the tag. Sets \s-1TRCK\s0 frame if given the optional arguments @new_track.  If this is an empty string or 0, the frame is removed. Returns the artist name; it is the first existing frame from the list of   TPE1      Lead artist/Lead performer/Soloist/Performing group   TPE2      Band/Orchestra/Accompaniment   TCOM      Composer   TPE3      Conductor   TEXT      Lyricist/Text writer Sets \s-1TPE1\s0 frame if given the optional arguments @new_artist.  If this is an empty string, the frame is removed. Returns the album name (\s-1TALB\s0) from the tag.  If none is found, returns the \*(L"Content group description\*(R" (\s-1TIT1\s0) frame (unless it is considered a part of the title). Sets \s-1TALB\s0 frame if given the optional arguments @new_album.  If this is an empty string, the frame is removed. Returns the genre string from \s-1TCON\s0 frame of the tag. Sets \s-1TCON\s0 frame if given the optional arguments @new_genre.  If this is an empty string, the frame is removed.</p>
  </dd>
  <dt>
    <em>version()</em>
  </dt>
  <dd>
    <p>  $version = $id3v2-&gt;version();   ($major, $revision) = $id3v2-&gt;version(); Returns the version of the ID3v2 tag. It returns a formatted string like \*(L"3.0\*(R" or an array containing the major part (eg. 3) and revision part (eg. 0) of the version number.</p>
  </dd>
  <dt>
    <em>new()</em>
  </dt>
  <dd>
    <p>  $tag = new($mp3fileobj); \*(C`new()\*(C' needs as parameter a mp3fileobj, as created by \*(C`MP3::Tag::File\*(C'. \*(C`new\*(C' tries to find a ID3v2 tag in the mp3fileobj. If it does not find a tag it returns undef.  Otherwise it reads the tag header, as well as an extended header, if available. It reads the rest of the tag in a buffer, does unsynchronizing if necessary, and returns a ID3v2-object.  At this moment only ID3v2.3 is supported. Any extended header with \s-1CRC\s0 data is ignored, so no \s-1CRC\s0 check is done at the moment.  The ID3v2-object can be used to extract information from the tag. Please use    $mp3 = MP3::Tag-&gt;new($filename);    $mp3-&gt;get_tags();                 ## to find an existing tag, or    $id3v2 = $mp3-&gt;new_tag("ID3v2");  ## to create a new tag instead of using this function directly</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Writing \*(C`v2.4\*(C'-layout tags is not supported.</p><p>Additionally, one should keep in mind that \*(C`v2.3\*(C' and \*(C`v2.4\*(C' have differences in two areas:</p><ul>
<li><p>layout of information in the byte stream (in other words, in a file considered as a string) is different;</p></li><li><p>semantic of frames is extended in \*(C`v2.4\*(C' - more frames are defined, and more frame flags are defined too.</p></li>
</ul><p>MP3::Tag does not even try to <em>write</em> frames in \*(C`v2.4\*(C'-layout.  However, when <em>reading</em> the frames, MP3::Tag does not assume any restriction on the semantic of frames - it allows all the semantical extensions defined in \*(C`v2.4\*(C' even for \*(C`v2.3\*(C' (and, probably, for \*(C`v2.2\*(C') layout.</p><p>\*(C`[*]\*(C' (I expect, any sane program would do the same...)</p><p>Likewise, when writing frames, there is no restriction imposed on semantic. If user specifies a frame the meaning of which is defined only in \*(C`v2.4\*(C', we would happily write it even when we use \*(C`v2.3\*(C' layout.  Same for frame flags.  (And given the assumption \*(C`[*]\*(C', this is a correct thing to do...)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO MP3::Tag::ID3v2&hellip;</h2>
        <div class="sectioncontent">
<p>MP3::Tag, MP3::Tag::ID3v1, MP3::Tag::ID3v2_Data</p><p>ID3v2 standard - http://www.id3.org http://www.id3.org/id3v2-00 &lt;http://www.id3.org/id3v2-00&gt;, &lt;http://www.id3.org/d3v2.3.0&gt;, http://www.id3.org/id3v2.4.0-structure &lt;http://www.id3.org/id3v2.4.0-structure&gt;, http://www.id3.org/id3v2.4.0-frames &lt;http://www.id3.org/id3v2.4.0-frames&gt;, http://id3lib.sourceforge.net/id3/id3v2.4.0-changes.txt &lt;http://id3lib.sourceforge.net/id3/id3v2.4.0-changes.txt&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2000-2008 Thomas Geffert, Ilya Zakharevich.  All rights reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the terms of the Artistic License, distributed with Perl.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="MP3::Tag::ID3v1.3pm.html"><span aria-hidden="true">&larr;</span> MP3::Tag::ID3v1.3pm: Module for reading / writing id3v1 tags of mp3 audio files</a></li>
   <li class="next"><a href="MP3::Tag::ID3v2_Data.3pm.html">MP3::Tag::ID3v2_Data.3pm: Get_frame() data format and supported frames <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

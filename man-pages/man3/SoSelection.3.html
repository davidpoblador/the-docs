<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoSelection: The soselection class manages a list of selected nodes.  inserting an soselection node in your scene graph enables you to let the user 'pick' with the left mousebutton to select/deselect objects below the soselection node.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soselection class manages a list of selected nodes.  inserting an soselection node in your scene graph enables you to let the user 'pick' with the left mousebutton to select/deselect objects below the soselection node.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoSelection (3) manual">
  <meta name="twitter:description" content="The soselection class manages a list of selected nodes.  inserting an soselection node in your scene graph enables you to let the user 'pick' with the left mousebutton to select/deselect objects below the soselection node.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoSelection-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoSelection.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoSelection (3) manual" />
  <meta property="og:description" content="The soselection class manages a list of selected nodes.  inserting an soselection node in your scene graph enables you to let the user 'pick' with the left mousebutton to select/deselect objects below the soselection node." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoSelection-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoSelection<small> (3)</small></h1>
        <p class="lead">The soselection class manages a list of selected nodes.  inserting an soselection node in your scene graph enables you to let the user 'pick' with the left mousebutton to select/deselect objects below the soselection node.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoSelection.3.html">
      <span itemprop="name">SoSelection: The soselection class manages a list of selected nodes.  inserting an soselection node in your scene graph enables you to let the user 'pick' with the left mousebutton to select/deselect objects below the soselection node.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoSelection.3.html">
      <span itemprop="name">SoSelection: The soselection class manages a list of selected nodes.  inserting an soselection node in your scene graph enables you to let the user 'pick' with the left mousebutton to select/deselect objects below the soselection node.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/nodes/SoSelection.h&gt;</p><p>Inherits <strong>SoSeparator</strong>.</p><p>Inherited by <strong>SoExtSelection</strong>.</p><h3>Public Types</h3>
<p>enum <strong>Policy</strong> { <strong>SINGLE</strong>, <strong>TOGGLE</strong>, <strong>SHIFT</strong> }</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> <strong>SoSelection</strong> (void)</p><p><strong>SoSelection</strong> (const int nChildren)</p><p>void <strong>select</strong> (const <strong>SoPath</strong> *path)</p><p>void <strong>select</strong> (<strong>SoNode</strong> *node)</p><p>void <strong>deselect</strong> (const <strong>SoPath</strong> *path)</p><p>void <strong>deselect</strong> (const int which)</p><p>void <strong>deselect</strong> (<strong>SoNode</strong> *node)</p><p>void <strong>toggle</strong> (const <strong>SoPath</strong> *path)</p><p>void <strong>toggle</strong> (<strong>SoNode</strong> *node)</p><p>SbBool <strong>isSelected</strong> (const <strong>SoPath</strong> *path) const </p><p>SbBool <strong>isSelected</strong> (<strong>SoNode</strong> *node) const </p><p>void <strong>deselectAll</strong> (void)</p><p>int <strong>getNumSelected</strong> (void) const </p><p>const <strong>SoPathList</strong> * <strong>getList</strong> (void) const </p><p><strong>SoPath</strong> * <strong>getPath</strong> (const int index) const </p><p><strong>SoPath</strong> * <strong>operator[]</strong> (const int i) const </p><p>void <strong>addSelectionCallback</strong> (SoSelectionPathCB *f, void *userData=NULL)</p><p>void <strong>removeSelectionCallback</strong> (SoSelectionPathCB *f, void *userData=NULL)</p><p>void <strong>addDeselectionCallback</strong> (SoSelectionPathCB *f, void *userData=NULL)</p><p>void <strong>removeDeselectionCallback</strong> (SoSelectionPathCB *f, void *userData=NULL)</p><p>void <strong>addStartCallback</strong> (SoSelectionClassCB *f, void *userData=NULL)</p><p>void <strong>removeStartCallback</strong> (SoSelectionClassCB *f, void *userData=NULL)</p><p>void <strong>addFinishCallback</strong> (SoSelectionClassCB *f, void *userData=NULL)</p><p>void <strong>removeFinishCallback</strong> (SoSelectionClassCB *f, void *userData=NULL)</p><p>void <strong>setPickFilterCallback</strong> (<strong>SoSelectionPickCB</strong> *f, void *userData=NULL, const SbBool callOnlyIfSelectable=TRUE)</p><p>void <strong>setPickMatching</strong> (const SbBool <strong>pickMatching</strong>)</p><p>SbBool <strong>isPickMatching</strong> (void) const </p><p>SbBool <strong>getPickMatching</strong> (void) const </p><p>void <strong>addChangeCallback</strong> (SoSelectionClassCB *f, void *userData=NULL)</p><p>void <strong>removeChangeCallback</strong> (SoSelectionClassCB *f, void *userData=NULL)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p>
<h3>Public Attributes</h3>
<p><strong>SoSFEnum</strong> <strong>policy</strong></p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual <strong>~SoSelection</strong> ()</p><p>void <strong>invokeSelectionPolicy</strong> (<strong>SoPath</strong> *path, SbBool shiftDown)</p><p>void <strong>performSingleSelection</strong> (<strong>SoPath</strong> *path)</p><p>void <strong>performToggleSelection</strong> (<strong>SoPath</strong> *path)</p><p><strong>SoPath</strong> * <strong>copyFromThis</strong> (const <strong>SoPath</strong> *path) const </p><p>void <strong>addPath</strong> (<strong>SoPath</strong> *path)</p><p>void <strong>removePath</strong> (const int which)</p><p>int <strong>findPath</strong> (const <strong>SoPath</strong> *path) const </p><p>virtual void <strong>handleEvent</strong> (<strong>SoHandleEventAction</strong> *action)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p>
<h3>Protected Attributes</h3>
<p><strong>SoPathList</strong> <strong>selectionList</strong></p><p><strong>SoCallbackList</strong> * <strong>selCBList</strong></p><p><strong>SoCallbackList</strong> * <strong>deselCBList</strong></p><p><strong>SoCallbackList</strong> * <strong>startCBList</strong></p><p><strong>SoCallbackList</strong> * <strong>finishCBList</strong></p><p><strong>SoSelectionPickCB</strong> * <strong>pickCBFunc</strong></p><p>void * <strong>pickCBData</strong></p><p>SbBool <strong>callPickCBOnlyIfSelectable</strong></p><p><strong>SoCallbackList</strong> * <strong>changeCBList</strong></p><p><strong>SoPath</strong> * <strong>mouseDownPickPath</strong></p><p>SbBool <strong>pickMatching</strong></p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoSelection</strong> class manages a list of selected nodes.</p><p>Inserting an <strong>SoSelection</strong> node in your scene graph enables you to let the user 'pick' with the left mousebutton to select/deselect objects below the <strong>SoSelection</strong> node.</p><p>Using an <strong>SoBoxHighlightRenderAction</strong> or an <strong>SoLineHighlightRenderAction</strong> to render scenegraphs containing <strong>SoSelection</strong> nodes provides a convenient way of providing visual feedback about the selections to the application user.</p><p>Beware that one common faulty assumption which is made about the node is that the scene will automatically be re-rendered whenever the user pick objects. This is not the case, the application programmer must himself schedule a redraw. A straightforward way to accomplish this is to <strong>SoNode::touch()</strong> the <strong>SoSelection</strong> node in the selection / deselection callback.</p><p>A 'skeleton' for basic use of <strong>SoSelection</strong> nodes is given below:</p>
<pre>
extern SoSeparator * make_scenegraph( void );
static SoSelection * selection = NULL;

// Callback function triggered for selection / deselection.
void made_selection( void * userdata, SoPath * path )
{
  (void)fprintf( stdout, "%sselected %s\n",
                 userdata == (void *)1L ? "" : "de",
                 path-&gt;getTail()-&gt;getTypeId().getName().getString() );

  selection-&gt;touch(); // to redraw
}

// *************************************************************************

// Print a quick instructions notice on stdout.
void show_instructions( void )
{
  (void)fprintf( stdout, "\nThis example program demonstrates the use of the SoSelection node type.\n" );
  (void)fprintf( stdout, "\nQuick instructions:\n\n" );
  (void)fprintf( stdout, "  * pick with left mouse button\n" );
  (void)fprintf( stdout, "  * hold SHIFT to select multiple objects\n" );
  (void)fprintf( stdout, "  * hit ESC to toggle back and forth to view mode\n" );
  (void)fprintf( stdout, "\n" );
}

// *************************************************************************

int main( int argc, char ** argv )
{
  QWidget * window = SoQt::init( argv[0] );
  show_instructions();

  selection = new SoSelection;
  selection-&gt;policy = SoSelection::SHIFT;
  selection-&gt;ref();

  selection-&gt;addChild( make_scenegraph() );
  selection-&gt;addSelectionCallback( made_selection, (void *)1L );
  selection-&gt;addDeselectionCallback( made_selection, (void *)0L );

  SoQtExaminerViewer * examinerviewer = new SoQtExaminerViewer( window );
  examinerviewer-&gt;setSceneGraph( selection );
  examinerviewer-&gt;setGLRenderAction( new SoBoxHighlightRenderAction );
  examinerviewer-&gt;setViewing( FALSE );
  examinerviewer-&gt;show();

  SoQt::show( window );
  SoQt::mainLoop();

  delete examinerviewer;
  selection-&gt;unref();

  return 0;
}
</pre>
<p>This node is not initialized in <strong>SoDB::init()</strong>, since it is part of the interaction kit 'add-on'. Before using this node, you should therefore call <strong>SoInteraction::init()</strong>. If you're using one of the standard GUI-toolkits (SoXt / SoQt / SoWin) <strong>SoInteraction::init()</strong> will be called for you from the So[Xt|Qt|Win]::init() method and you don't have to worry about it.</p><p>With regard to using multiple <strong>SoSelection</strong> nodes at the same time in the same scene graph: this is possible, but it is not straightforward. The standard viewers provided by SoQt, SoWin, et al, will only snoop on one <strong>SoSelection</strong> node (part of the the legacy API from SGI's InventorXt), so selection changes on the others doesn't trigger redraws. You don't necessarily see what's happening in other words. You'll have to hook up manually and trigger redraws yourself.</p><p>Also be aware that when having multiple <strong>SoSelection</strong> nodes in the scene graph active at the same time, the <strong>SoHandleEventAction</strong> traversals that you intend for selection-change on one <strong>SoSelection</strong> node will also affect all the other <strong>SoSelection</strong> nodes in the scene -- usually delesecting everything below them since you will be clicking outside the selectable objects. You'll therefore also have to manually override that behaviour, if you want selection change on one <strong>SoSelection</strong> node to not affect the others.</p><p><strong>FILE FORMAT/DEFAULTS:</strong></p>
<pre>
Selection {
    renderCaching AUTO
    boundingBoxCaching AUTO
    renderCulling AUTO
    pickCulling AUTO
    policy SHIFT
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoSelection::Policy\fP</h3>
<p>Enum for different pick policies.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SINGLE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Only one object can be selected at any time. When the user picks a new object, the previous selection will be unselected. If the user picks on nothing, the current selection will be unselected.</p>
  </dd>

</dl>
<p>Note that if a new selection matches one already present in the selection list, neither a deselect nor a select notification callback will be made about that selection path.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>TOGGLE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Picking an object toggles its selection state.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SHIFT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Same as SINGLE, but when shift key is pressed the selection policy will be changed to TOGGLE.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoSelection::SoSelection (void)</h3>
<p>Default constructor.</p>
<h3>SoSelection::SoSelection (const intnChildren)</h3>
<p>Constructor.</p><p>The argument should be the approximate number of children which is expected to be inserted below this node. The number need not be exact, as it is only used as a hint for better memory resource allocation.</p>
<h3>SoSelection::~SoSelection ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoSelection::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Reimplemented from <strong>SoSeparator</strong>.</p><p>Reimplemented in <strong>SoExtSelection</strong>.</p>
<h3>const \fBSoFieldData\fP * SoSelection::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoSeparator</strong>.</p><p>Reimplemented in <strong>SoExtSelection</strong>.</p>
<h3>void SoSelection::select (const \fBSoPath\fP *path)</h3>
<p>Adds <em>path</em> to the list of selected objects.</p>
<h3>void SoSelection::select (\fBSoNode\fP *node)</h3>
<p>Adds <em>node</em> to the list of selected objects. The scene graph below the Selection node will be searched, and the path to <em>node</em> will be added if found.</p>
<h3>void SoSelection::deselect (const \fBSoPath\fP *path)</h3>
<p>Remove <em>path</em> from the list of selected objects.</p>
<h3>void SoSelection::deselect (const intwhich)</h3>
<p>Remove objects <em>which</em> from the list of selected objects.</p>
<h3>void SoSelection::deselect (\fBSoNode\fP *node)</h3>
<p>Remove <em>node</em> from the list of selected objects. The scene graph below the Selection node will be searched, and the path to <em>node</em> will be removed if found.</p>
<h3>void SoSelection::toggle (const \fBSoPath\fP *path)</h3>
<p>If <em>path</em> is not already selected, add <em>path</em> to the list of selected objects. Otherwise remove <em>path</em> from the list of selected objects.</p>
<h3>void SoSelection::toggle (\fBSoNode\fP *node)</h3>
<p>If <em>node</em> is not already selected, add <em>path</em> to the list of selected objects. Otherwise remove <em>node</em> from the list of selected objects.</p>
<h3>SbBool SoSelection::isSelected (const \fBSoPath\fP *path) const</h3>
<p>Return <em>TRUE</em> if <em>path</em> is in the list of selected objects.</p>
<h3>SbBool SoSelection::isSelected (\fBSoNode\fP *node) const</h3>
<p>Return <em>TRUE</em> if the path to <em>node</em> is in the list of selected objects.</p>
<h3>void SoSelection::deselectAll (void)</h3>
<p>Clears the selection list.</p>
<h3>int SoSelection::getNumSelected (void) const</h3>
<p>Returns the number of selected objects.</p>
<h3>const \fBSoPathList\fP * SoSelection::getList (void) const</h3>
<p>Returns the list of selected objects.</p>
<h3>\fBSoPath\fP * SoSelection::getPath (const intindex) const</h3>
<p>Returns the <em>index'th</em> selected objects.</p>
<h3>\fBSoPath\fP * SoSelection::operator[] (const inti) const</h3>
<p>Operator for accessing selected objects.</p>
<h3>void SoSelection::addSelectionCallback (SoSelectionPathCB *f, void *userData = \fCNULL\fP)</h3>
<p>Adds a callback which will be called every time an object is selected.</p><p><strong>See also:</strong></p><p><strong>removeSelectionCallback()</strong></p>
<h3>void SoSelection::removeSelectionCallback (SoSelectionPathCB *f, void *userData = \fCNULL\fP)</h3>
<p>Removes one of the selection callbacks.</p><p><strong>See also:</strong></p><p><strong>addSelectionCallback()</strong></p>
<h3>void SoSelection::addDeselectionCallback (SoSelectionPathCB *f, void *userData = \fCNULL\fP)</h3>
<p>Adds a callback which will be called every time an object is deselected.</p><p><strong>See also:</strong></p><p><strong>removeDeselectionCallback()</strong></p>
<h3>void SoSelection::removeDeselectionCallback (SoSelectionPathCB *f, void *userData = \fCNULL\fP)</h3>
<p>Removes one of the deselection callbacks.</p><p><strong>See also:</strong></p><p>addDeselctionCallback()</p>
<h3>void SoSelection::addStartCallback (SoSelectionClassCB *f, void *userData = \fCNULL\fP)</h3>
<p>Adds a callback which will be invoked when the user start an interactive change to the list of selected objects.</p><p>This callback is useful for storing the old selection list for undo/redo functionality.</p><p><strong>See also:</strong></p><p><strong>addFinishCallback()</strong></p>
<h3>void SoSelection::removeStartCallback (SoSelectionClassCB *f, void *userData = \fCNULL\fP)</h3>
<p>Removes <em>f</em> from the list of start callbacks.</p><p><strong>See also:</strong></p><p><strong>addStartCallback()</strong></p>
<h3>void SoSelection::addFinishCallback (SoSelectionClassCB *f, void *userData = \fCNULL\fP)</h3>
<p>Adds a callback which will be invoked when the user has finished an interactive change to the list of selected objects.</p><p><strong>See also:</strong></p><p><strong>addStartCallback()</strong></p>
<h3>void SoSelection::removeFinishCallback (SoSelectionClassCB *f, void *userData = \fCNULL\fP)</h3>
<p>Removes <em>f</em> from the list og finish callbacks.</p><p><strong>See also:</strong></p><p><strong>addFinishCallback()</strong></p>
<h3>void SoSelection::setPickFilterCallback (\fBSoSelectionPickCB\fP *f, void *userData = \fCNULL\fP, const SbBoolcallOnlyIfSelectable = \fCTRUE\fP)</h3>
<p>Sets the pick filter callback. This callback will be called when a path is about to be added to or removed from the list of selected objects. The callback function should return a replacement path that should be used instead of the picked path. The returned path will be ref'ed, copied, and then unref'ed again by the <strong>SoSelection</strong> node.</p><p>If no callback is set (the default), the picked path will be used for selecting/deselecting.</p><p>Possible return values from the callback:</p><ul>
<li><p>NULL: simulate that nothing was picked. This will clear the selection for the SINGLE policy. The handle event action will be halted.</p></li><li><p>A path: the path will be selected/deselected. The handle event action will be halted.</p></li><li><p>A path containing only the Selection node: as NULL, but action will not be halted.</p></li><li><p>An empty path or a path not containing the Selection node: the pick will be ignored.</p></li>
</ul><p>if <em>callOnlyIfSelectable</em> is TRUE<em>, the callback will only be called if the Selection node is in the picked path.</em></p>
<h3>void SoSelection::setPickMatching (const SbBoolpickmatchflag)</h3>
<p>When <em>pickmatchflag</em> is TRUE<em> (the default), the mouse button release pick must match the mouse button press pick before object is selected/deselected.</em></p><p>This flag should normally not be of interest to application programmers.</p>
<h3>SbBool SoSelection::isPickMatching (void) const</h3>
<p>Returns <em>TRUE</em> if pick matching is enabled.</p><p><strong>See also:</strong></p><p><strong>setPickMatching()</strong></p>
<h3>SbBool SoSelection::getPickMatching (void) const</h3>
<p>Returns <em>TRUE</em> if pick matching is enabled.</p><p><strong>See also:</strong></p><p><strong>setPickMatching()</strong></p>
<h3>void SoSelection::addChangeCallback (SoSelectionClassCB *f, void *userData = \fCNULL\fP)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em>Used by render area to receive notification when the selection list changes.</p>
<h3>void SoSelection::removeChangeCallback (SoSelectionClassCB *f, void *userData = \fCNULL\fP)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em> Used by render area to receive notification when the selection list changes.</p>
<h3>void SoSelection::invokeSelectionPolicy (\fBSoPath\fP *path, SbBoolshiftdown)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoSelection::performSingleSelection (\fBSoPath\fP *path)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoSelection::performToggleSelection (\fBSoPath\fP *path)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoPath\fP * SoSelection::copyFromThis (const \fBSoPath\fP *path) const\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoSelection::addPath (\fBSoPath\fP *path)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoSelection::removePath (const intwhich)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>int SoSelection::findPath (const \fBSoPath\fP *path) const\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoSelection::handleEvent (\fBSoHandleEventAction\fP *action)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Action method for <strong>SoHandleEventAction</strong>.</p><p>Inspects the event data from <em>action</em>, and processes it if it is something which this node should react to.</p><p>Nodes influencing relevant state variables for how event handling is done also overrides this method.</p><p>Reimplemented from <strong>SoSeparator</strong>.</p><p>Reimplemented in <strong>SoExtSelection</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoSFEnum\fP SoSelection::policy</h3>
<p>Field for selection policy. Default value is SHIFT.</p>
<h3>\fBSoPathList\fP SoSelection::selectionList\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoCallbackList\fP * SoSelection::selCBList\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoCallbackList\fP * SoSelection::deselCBList\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoCallbackList\fP * SoSelection::startCBList\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoCallbackList\fP * SoSelection::finishCBList\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoSelectionPickCB\fP * SoSelection::pickCBFunc\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void * SoSelection::pickCBData\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoSelection::callPickCBOnlyIfSelectable\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoCallbackList\fP * SoSelection::changeCBList\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoPath\fP * SoSelection::mouseDownPickPath\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoSelection::pickMatching\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoSelectOne.3.html"><span aria-hidden="true">&larr;</span> SoSelectOne.3: The soselectone class is used to select one value from a set of values.  the output field will be the index'th value of the input multivalue field.</a></li>
   <li class="next"><a href="SoSelection.h.3.html">SoSelection.h.3: Soselection.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>stapprobes: Systemtap probe points</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Systemtap probe points">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="stapprobes (3stap) manual">
  <meta name="twitter:description" content="Systemtap probe points">
  <meta name="twitter:image" content="https://www.carta.tech/images/systemtap-doc-stapprobes-3stap.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3stap/stapprobes.3stap.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="stapprobes (3stap) manual" />
  <meta property="og:description" content="Systemtap probe points" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/systemtap-doc-stapprobes-3stap.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">stapprobes<small> (3stap)</small></h1>
        <p class="lead">Systemtap probe points</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3stap/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3stap/stapprobes.3stap.html">
      <span itemprop="name">stapprobes: Systemtap probe points</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/systemtap-doc/">
      <span itemprop="name">systemtap-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3stap/stapprobes.3stap.html">
      <span itemprop="name">stapprobes: Systemtap probe points</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The following sections enumerate the variety of probe points supported by the systemtap translator, and some of the additional aliases defined by standard tapset scripts.  Many are individually documented in the <em>3stap</em> manual section, with the <em>probe::</em> prefix.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNTAX</h2>
        <div class="sectioncontent">

<pre>
<strong>probe</strong> PROBEPOINT [<strong>,</strong> PROBEPOINT] <strong>{</strong> [STMT ...] <strong>}</strong>
</pre>
<p>A probe declaration may list multiple comma-separated probe points in order to attach a handler to all of the named events.  Normally, the handler statements are run whenever any of events occur.</p><p>The syntax of a single probe point is a general dotted-symbol sequence.  This allows a breakdown of the event namespace into parts, somewhat like the Domain Name System does on the Internet.  Each component identifier may be parametrized by a string or number literal, with a syntax like a function call.  A component may include a "*" character, to expand to a set of matching probe points.  It may also include "**" to match multiple sequential components at once. Probe aliases likewise expand to other probe points.</p><p>Probe aliases can be given on their own, or with a suffix. The suffix attaches to the underlying probe point that the alias is expanded to. For example, syscall.read.return.maxactive(10) expands to kernel.function("sys_read").return.maxactive(10) with the component <em>maxactive(10)</em> being recognized as a suffix.</p><p>Normally, each and every probe point resulting from wildcard- and alias-expansion must be resolved to some low-level system instrumentation facility (e.g., a kprobe address, marker, or a timer configuration), otherwise the elaboration phase will fail.</p><p>However, a probe point may be followed by a "?" character, to indicate that it is optional, and that no error should result if it fails to resolve.  Optionalness passes down through all levels of alias/wildcard expansion.  Alternately, a probe point may be followed by a "!" character, to indicate that it is both optional and sufficient.  (Think vaguely of the Prolog cut operator.) If it does resolve, then no further probe points in the same comma-separated list will be resolved.  Therefore, the "!"  sufficiency mark only makes sense in a list of probe point alternatives.</p><p>Additionally, a probe point may be followed by a "if (expr)" statement, in order to enable/disable the probe point on-the-fly. With the "if" statement, if the "expr" is false when the probe point is hit, the whole probe body including alias's body is skipped. The condition is stacked up through all levels of alias/wildcard expansion. So the final condition becomes the logical-and of conditions of all expanded alias/wildcard.  The expressions are necessarily restricted to global variables.</p><p>These are all <strong>syntactically</strong> valid probe points.  (They are generally <strong>semantically</strong> invalid, depending on the contents of the tapsets, and the versions of kernel/user software installed.)</p><p>kernel.function("foo").return process("/bin/vi").statement(0x2222) end syscall.* syscall.*.return.maxactive(10) sys**open kernel.function("no_such_function") ? module("awol").function("no_such_function") ! signal.*? if (switch) kprobe.function("foo")</p><p>Probes may be broadly classified into "synchronous" and "asynchronous".  A "synchronous" event is deemed to occur when any processor executes an instruction matched by the specification.  This gives these probes a reference point (instruction address) from which more contextual data may be available.  Other families of probe points refer to "asynchronous" events such as timers/counters rolling over, where there is no fixed reference point that is related.  Each probe point specification may match multiple locations (for example, using wildcards or aliases), and all them are then probed.  A probe declaration may also contain several comma-separated specifications, all of which are probed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DWARF DEBUGINFO</h2>
        <div class="sectioncontent">
<p>Resolving some probe points requires DWARF debuginfo or "debug symbols" for the specific part being instrumented.  For some others, DWARF is automatically synthesized on the fly from source code header files.  For others, it is not needed at all.  Since a systemtap script may use any mixture of probe points together, the union of their DWARF requirements has to be met on the computer where script compilation occurs.  (See the <em>--use-server</em> option and the <strong>stap-server (8)</strong> man page for information about the remote compilation facility, which allows these requirements to be met on a different machine.)</p><p>The following point lists many of the available probe point families, to classify them with respect to their need for DWARF debuginfo.</p><table class="table table-striped">
<tr>
<th><strong>DWARF</th>
<th>NON-DWARF</strong></th>
<th></th></tr>

<tr>
<td></td>
<td></td>
<td></td></tr>

<tr>
<td>kernel.function, .statement</td>
<td>kernel.mark</td>
<td></td></tr>

<tr>
<td>module.function, .statement</td>
<td>process.mark, process.plt</td>
<td></td></tr>

<tr>
<td>process.function, .statement</td>
<td>begin, end, error, never</td>
<td></td></tr>

<tr>
<td>process.mark <em>(backup)</em></td>
<td>timer</td>
<td></td></tr>

<tr>
<td></td>
<td>perf</td>
<td></td></tr>

<tr>
<td></td>
<td>procfs</td>
<td></td></tr>

<tr>
<td><strong>AUTO-GENERATED-DWARF</strong></td>
<td>kernel.statement.absolute</td>
<td></td></tr>

<tr>
<td></td>
<td>kernel.data</td>
<td></td></tr>

<tr>
<td>kernel.trace</td>
<td>kprobe.function</td>
<td></td></tr>

<tr>
<td></td>
<td>process.statement.absolute</td>
<td></td></tr>

<tr>
<td></td>
<td>process.begin, .end</td>
<td></td></tr>

<tr>
<td></td>
<td>netfilter</td>
<td></td></tr>

<tr>
<td></td>
<td>java</td>
<td></td></tr>
</table>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ON-THE-FLY ARMING</h2>
        <div class="sectioncontent">
<p>The following types of probe points may be armed/disarmed on-the-fly to save overheads during uninteresting times.  Arming conditions may also be added to other types of probes, but will be treated as a wrapping conditional and won't benefit from overhead savings.</p><table class="table table-striped">
<tr>
<th><strong>DISARMABLE</th>
<th>exceptions</strong></th></tr>

<tr>
<td>kernel.function, kernel.statement</td>
<td></td></tr>

<tr>
<td>module.function, module.statement</td>
<td></td></tr>

<tr>
<td>process.*.function, process.*.statement</td>
<td></td></tr>

<tr>
<td>process.*.plt, process.*.mark</td>
<td></td></tr>

<tr>
<td>timer.</td>
<td>timer.profile</td></tr>

<tr>
<td>java</td>
<td></td></tr>
</table>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROBE POINT FAMILIES</h2>
        <div class="sectioncontent">
<h3>BEGIN/END/ERROR</h3>
<p>The probe points <em>begin</em> and <em>end</em> are defined by the translator to refer to the time of session startup and shutdown.  All "begin" probe handlers are run, in some sequence, during the startup of the session.  All global variables will have been initialized prior to this point.  All "end" probes are run, in some sequence, during the <em>normal</em> shutdown of a session, such as in the aftermath of an <em>exit ()</em> function call, or an interruption from the user.  In the case of an error-triggered shutdown, "end" probes are not run.  There are no target variables available in either context.</p><p>If the order of execution among "begin" or "end" probes is significant, then an optional sequence number may be provided:</p><p>begin(N) end(N)</p><p>The number N may be positive or negative.  The probe handlers are run in increasing order, and the order between handlers with the same sequence number is unspecified.  When "begin" or "end" are given without a sequence, they are effectively sequence zero.</p><p>The <em>error</em> probe point is similar to the <em>end</em> probe, except that each such probe handler run when the session ends after errors have occurred.  In such cases, "end" probes are skipped, but each "error" probe is still attempted.  This kind of probe can be used to clean up or emit a "final gasp".  It may also be numerically parametrized to set a sequence.</p>
<h3>NEVER</h3>
<p>The probe point <em>never</em> is specially defined by the translator to mean "never".  Its probe handler is never run, though its statements are analyzed for symbol / type correctness as usual.  This probe point may be useful in conjunction with optional probes.</p>
<h3>SYSCALL and ND_SYSCALL</h3>
<p>The <em>syscall.*</em> and <em>nd_syscall.*</em> aliases define several hundred probes, too many to detail here.  They are of the general form:</p><p>syscall.NAME</p><p>nd_syscall.NAME</p><p>syscall.NAME.return</p><p>nd_syscall.NAME.return</p><p>Generally, a pair of probes are defined for each normal system call as listed in the <a href="../man2/syscalls.2.html"><strong>syscalls</strong>(2)</a></em> manual page, one for entry and one for return.  Those system calls that never return do not have a corresponding <em>.return</em> probe.  The nd_* family of probes are about the same, except it uses <strong>non-DWARF</strong> based searching mechanisms, which may result in a lower quality of symbolic context data (parameters), and may miss some system calls.  You may want to try them first, in case kernel debugging information is not immediately available.</p><p>Each probe alias provides a variety of variables. Looking at the tapset source code is the most reliable way.  Generally, each variable listed in the standard manual page is made available as a script-level variable, so <em>syscall.open</em> exposes <em>filename</em>, <em>flags</em>, and <em>mode</em>. In addition, a standard suite of variables is available at most aliases:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>argstr</em></p>
  </dt>
  <dd>
    <p>A pretty-printed form of the entire argument list, without parentheses.</p>
  </dd>
  <dt>
    <p><em>name</em></p>
  </dt>
  <dd>
    <p>The name of the system call.</p>
  </dd>
  <dt>
    <p><em>retstr</em></p>
  </dt>
  <dd>
    <p>For return probes, a pretty-printed form of the system-call result.</p>
  </dd>

</dl>
<p>As usual for probe aliases, these variables are all simply initialized once from the underlying $context variables, so that later changes to $context variables are not automatically reflected.  Not all probe aliases obey all of these general guidelines.  Please report any bothersome ones you encounter as a bug.</p><p>If debuginfo availability is a problem, you may try using the non-DWARF syscall probe aliases instead.  Use the <em>nd_syscall.</em> prefix instead of <em>syscall.</em> The same context variables are available, as far as possible.</p>
<h3>TIMERS</h3>
<p>Intervals defined by the standard kernel "jiffies" timer may be used to trigger probe handlers asynchronously.  Two probe point variants are supported by the translator:</p><p>timer.jiffies(N) timer.jiffies(N).randomize(M)</p><p>The probe handler is run every N jiffies (a kernel-defined unit of time, typically between 1 and 60 ms).  If the "randomize" component is given, a linearly distributed random value in the range [-M..+M] is added to N every time the handler is run.  N is restricted to a reasonable range (1 to around a million), and M is restricted to be smaller than N.  There are no target variables provided in either context.  It is possible for such probes to be run concurrently on a multi-processor computer.</p><p>Alternatively, intervals may be specified in units of time. There are two probe point variants similar to the jiffies timer:</p><p>timer.ms(N) timer.ms(N).randomize(M)</p><p>Here, N and M are specified in milliseconds, but the full options for units are seconds (s/sec), milliseconds (ms/msec), microseconds (us/usec), nanoseconds (ns/nsec), and hertz (hz).  Randomization is not supported for hertz timers.</p><p>The actual resolution of the timers depends on the target kernel.  For kernels prior to 2.6.17, timers are limited to jiffies resolution, so intervals are rounded up to the nearest jiffies interval.  After 2.6.17, the implementation uses hrtimers for tighter precision, though the actual resolution will be arch-dependent.  In either case, if the "randomize" component is given, then the random value will be added to the interval before any rounding occurs.</p><p>Profiling timers are also available to provide probes that execute on all CPUs at the rate of the system tick (CONFIG_HZ).  This probe takes no parameters.  On some kernels, this is a one-concurrent-user-only or disabled facility, resulting in error -16 (EBUSY) during probe registration.</p><p>timer.profile.tick</p><p>Full context information of the interrupted process is available, making this probe suitable for a time-based sampling profiler.</p><p>It is recommended to use the tapset probe <em>timer.profile</em> rather than timer.profile.tick. This probe point behaves identically to timer.profile.tick when the underlying functionality is available, and falls back to using perf.sw.cpu_clock on some recent kernels which lack the corresponding profile timer facility.</p>
<h3>DWARF</h3>
<p>This family of probe points uses symbolic debugging information for the target kernel/module/program, as may be found in unstripped executables, or the separate <em>debuginfo</em> packages.  They allow placement of probes logically into the execution path of the target program, by specifying a set of points in the source or object code.  When a matching statement executes on any processor, the probe handler is run in that context.</p><p>Probe points in the DWARF family can be identified by the target kernel module (or user process), source file, line number, function name, or some combination of these.</p><p>Here is a list of DWARF probe points currently supported: kernel.function(PATTERN) kernel.function(PATTERN).call kernel.function(PATTERN).callee(PATTERN) kernel.function(PATTERN).callees(DEPTH) kernel.function(PATTERN).return kernel.function(PATTERN).inline kernel.function(PATTERN).label(LPATTERN) module(MPATTERN).function(PATTERN) module(MPATTERN).function(PATTERN).call module(MPATTERN).function(PATTERN).callee(PATTERN) module(MPATTERN).function(PATTERN).callees(DEPTH) module(MPATTERN).function(PATTERN).return module(MPATTERN).function(PATTERN).inline module(MPATTERN).function(PATTERN).label(LPATTERN) kernel.statement(PATTERN) kernel.statement(PATTERN).nearest kernel.statement(ADDRESS).absolute module(MPATTERN).statement(PATTERN) process("PATH").function("NAME") process("PATH").statement("*@FILE.c:123") process("PATH").library("PATH").function("NAME") process("PATH").library("PATH").statement("*@FILE.c:123") process("PATH").library("PATH").statement("*@FILE.c:123").nearest process("PATH").function("*").return process("PATH").function("myfun").label("foo") process("PATH").function("foo").callee("bar") process("PATH").function("foo").callees(DEPTH) process(PID).function("NAME") process(PID).function("myfun").label("foo") process(PID).plt("NAME") process(PID).plt("NAME").return process(PID).statement("*@FILE.c:123") process(PID).statement("*@FILE.c:123").nearest process(PID).statement(ADDRESS).absolute (See the USER-SPACE section below for more information on the process probes.)</p><p>The list above includes multiple variants and modifiers which provide additional functionality or filters. They are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>.function</strong></p>
  </dt>
  <dd>
    <p>Places a probe near the beginning of the named function, so that parameters are available as context variables.</p>
  </dd>
  <dt>
    <p><strong>.return</strong></p>
  </dt>
  <dd>
    <p>Places a probe at the moment <strong>after</strong> the return from the named function, so the return value is available as the "$return" context variable.</p>
  </dd>
  <dt>
    <p><strong>.inline</strong></p>
  </dt>
  <dd>
    <p>Filters the results to include only instances of inlined functions. Note that inlined functions do not have an identifiable return point, so <strong>.return</strong> is not supported on <strong>.inline</strong> probes.</p>
  </dd>
  <dt>
    <p><strong>.call</strong></p>
  </dt>
  <dd>
    <p>Filters the results to include only non-inlined functions (the opposite set of <strong>.inline</strong>)</p>
  </dd>
  <dt>
    <p><strong>.exported</strong></p>
  </dt>
  <dd>
    <p>Filters the results to include only exported functions.</p>
  </dd>
  <dt>
    <p><strong>.statement</strong></p>
  </dt>
  <dd>
    <p>Places a probe at the exact spot, exposing those local variables that are visible there.</p>
  </dd>
  <dt>
    <p><strong>.statement.nearest</strong></p>
  </dt>
  <dd>
    <p>Places a probe at the nearest available spot to the given statement.</p>
  </dd>
  <dt>
    <p><strong>.callee</strong></p>
  </dt>
  <dd>
    <p>Places a probe on the callee function given in the <strong>.callee</strong> modifier, where the callee must be a function called by the target function given in <strong>.function</strong>. The advantage of doing this over directly probing the callee function is that this probe point is run only when the callee is called from the target function (add the -DSTAP_CALLEE_MATCHALL directive to override this when calling <a href="../man1/stap.1.html"><strong>stap</strong>(1)</a>).</p><p>Note that only callees that can be statically determined are available. For example, calls through function pointers are not available. Additionally, calls to functions located in other objects (e.g. libraries) are not available (instead use another probe point). This feature will only work for code compiled with GCC 4.7+.</p>
  </dd>
  <dt>
    <p><strong>.callees</strong></p>
  </dt>
  <dd>
    <p>Shortcut for <strong>.callee("*")</strong>, which places a probe on all callees of the function.</p>
  </dd>
  <dt>
    <p><strong>.callees</strong>(DEPTH)</p>
  </dt>
  <dd>
    <p>Recursively places probes on callees. For example, <strong>.<strong>callees</strong>(2)</strong> will probe both callees of the target function, as well as callees of those callees. And <strong>.<strong>callees</strong>(3)</strong> goes one level deeper, etc... A callee probe at depth N is only triggered when the N callers in the callstack match those that were statically determined during analysis (this also may be overriden using -DSTAP_CALLEE_MATCHALL).</p>
  </dd>

</dl>
<p>In the above list of probe points, MPATTERN stands for a string literal that aims to identify the loaded kernel module of interest. For in-tree kernel modules, the name suffices (e.g. "btrfs"). The name may also include the "*", "[]", and "?" wildcards to match multiple in-tree modules. Out-of-tree modules are also supported by specifying the full path to the ko file. Wildcards are not supported. The file must follow the convention of being named &lt;module_name&gt;.ko (characters ',' and '-' are replaced by '_').</p><p>LPATTERN stands for a source program label. It may also contain "*", "[]", and "?" wildcards. PATTERN stands for a string literal that aims to identify a point in the program.  It is made up of three parts:</p><ul>
<li><p>The first part is the name of a function, as would appear in the <em>nm</em> program's output.  This part may use the "*" and "?" wildcarding operators to match multiple names.</p></li><li><p>The second part is optional and begins with the "@" character. It is followed by the path to the source file containing the function, which may include a wildcard pattern, such as mm/slab*. If it does not match as is, an implicit "*/" is optionally added <em>before</em> the pattern, so that a script need only name the last few components of a possibly long source directory path.</p></li><li><p>Finally, the third part is optional if the file name part was given, and identifies the line number in the source file preceded by a ":" or a "+".  The line number is assumed to be an absolute line number if preceded by a ":", or relative to the declaration line of the function if preceded by a "+". All the lines in the function can be matched with ":*". A range of lines x through y can be matched with ":x-y". Ranges and specific lines can be mixed using commas, e.g. ":x,y-z".</p></li>
</ul><p>As an alternative, PATTERN may be a numeric constant, indicating an address.  Such an address may be found from symbol tables of the appropriate kernel / module object file.  It is verified against known statement code boundaries, and will be relocated for use at run time.</p><p>In guru mode only, absolute kernel-space addresses may be specified with the ".absolute" suffix.  Such an address is considered already relocated, as if it came from <strong>/proc/kallsyms</strong>, so it cannot be checked against statement/instruction boundaries.</p>
<h3>CONTEXT VARIABLES</h3>
<p>Many of the source-level context variables, such as function parameters, locals, globals visible in the compilation unit, may be visible to probe handlers.  They may refer to these variables by prefixing their name with "$" within the scripts.  In addition, a special syntax allows limited traversal of structures, pointers, and arrays.  More syntax allows pretty-printing of individual variables or their groups. See also <strong>@cast</strong>. Note that variables may be inaccessible due to them being paged out, or for a few other reasons.  See also man <em>error::fault</em>(7stap).</p>
<dl class='dl-vertical'>
  <dt>
    <p>$var</p>
  </dt>
  <dd>
    <p>refers to an in-scope variable "var".  If it's an integer-like type, it will be cast to a 64-bit int for systemtap script use.  String-like pointers (char *) may be copied to systemtap string values using the <em>kernel_string</em> or <em>user_string</em> functions.</p>
  </dd>
  <dt>
    <p>@var("varname")</p>
  </dt>
  <dd>
    <p>an alternative syntax for <em>$varname</em></p>
  </dd>
  <dt>
    <p>@var("varname@src/file.c")</p>
  </dt>
  <dd>
    <p>refers to the global (either file local or external) variable <em>varname</em> defined when the file <em>src/file.c</em> was compiled. The CU in which the variable is resolved is the first CU in the module of the probe point which matches the given file name at the end and has the shortest file name path (e.g. given <em>@var("foo@bar/baz.c")</em> and CUs with file name paths <em>src/sub/module/bar/baz.c</em> and <em>src/bar/baz.c</em> the second CU will be chosen to resolve the (file) global variable <em>foo</em></p>
  </dd>
  <dt>
    <p>$var-&gt;field traversal via a structure's or a pointer's field.  This</p>
  </dt>
  <dd>
    <p>generalized indirection operator may be repeated to follow more levels.  Note that the <em>.</em> operator is not used for plain structure members, only <em>-&gt;</em> for both purposes.  (This is because "." is reserved for string concatenation.)</p>
  </dd>
  <dt>
    <p>$return</p>
  </dt>
  <dd>
    <p>is available in return probes only for functions that are declared with a return value, which can be determined using @defined($return).</p>
  </dd>
  <dt>
    <p>$var[N]</p>
  </dt>
  <dd>
    <p>indexes into an array.  The index given with a literal number or even an arbitrary numeric expression.</p>
  </dd>

</dl>
<p>A number of operators exist for such basic context variable expressions:</p>
<dl class='dl-vertical'>
  <dt>
    <p>$$vars</p>
  </dt>
  <dd>
    <p>expands to a character string that is equivalent to sprintf("parm1=%x ... parmN=%x var1=%x ... varN=%x",</p>
<pre>
        parm1, ..., parmN, var1, ..., varN)
</pre>
<p>for each variable in scope at the probe point.  Some values may be printed as <em>=?</em> if their run-time location cannot be found.</p>
  </dd>
  <dt>
    <p>$$locals</p>
  </dt>
  <dd>
    <p>expands to a subset of $$vars for only local variables.</p>
  </dd>
  <dt>
    <p>$$parms</p>
  </dt>
  <dd>
    <p>expands to a subset of $$vars for only function parameters.</p>
  </dd>
  <dt>
    <p>$$return</p>
  </dt>
  <dd>
    <p>is available in return probes only.  It expands to a string that is equivalent to sprintf("return=%x", $return) if the probed function has a return value, or else an empty string.</p>
  </dd>
  <dt>
    <p>& $EXPR</p>
  </dt>
  <dd>
    <p>expands to the address of the given context variable expression, if it is addressable.</p>
  </dd>
  <dt>
    <p>@defined($EXPR)</p>
  </dt>
  <dd>
    <p>expands to 1 or 0 iff the given context variable expression is resolvable, for use in conditionals such as @defined($foo-&gt;bar) ? $foo-&gt;bar : 0</p>
  </dd>
  <dt>
    <p>$EXPR$</p>
  </dt>
  <dd>
    <p>expands to a string with all of $EXPR's members, equivalent to sprintf("{.a=%i, .b=%u, .c={...}, .d=[...]}",</p>
<pre>
         $EXPR-&gt;a, $EXPR-&gt;b)
</pre>

  </dd>
  <dt>
    <p>$EXPR$$</p>
  </dt>
  <dd>
    <p>expands to a string with all of $var's members and submembers, equivalent to sprintf("{.a=%i, .b=%u, .c={.x=%p, .y=%c}, .d=[%i, ...]}",</p>
<pre>
        $EXPR-&gt;a, $EXPR-&gt;b, $EXPR-&gt;c-&gt;x, $EXPR-&gt;c-&gt;y, $EXPR-&gt;d[0])
</pre>

  </dd>

</dl>

<h3>MORE ON RETURN PROBES</h3>
<p>For the kernel ".return" probes, only a certain fixed number of returns may be outstanding.  The default is a relatively small number, on the order of a few times the number of physical CPUs.  If many different threads concurrently call the same blocking function, such as <a href="../man2/futex.2.html"><strong>futex</strong>(2)</a> or <a href="../man2/read.2.html"><strong>read</strong>(2)</a>, this limit could be exceeded, and skipped "kretprobes" would be reported by "stap -t".  To work around this, specify a probe FOO.return.maxactive(NNN) suffix, with a large enough NNN to cover all expected concurrently blocked threads.  Alternately, use the stap -DKRETACTIVE=NNNN stap command line macro setting to override the default for all ".return" probes.</p><p>For ".return" probes, context variables other than the "$return" may be accessible, as a convenience for a script programmer wishing to access function parameters.  These values are <strong>snapshots</strong> taken at the time of function entry.  Local variables within the function are <strong>not</strong> generally accessible, since those variables did not exist in allocated/initialized form at the snapshot moment.</p><p>In addition, arbitrary entry-time expressions can also be saved for ".return" probes using the <em>@entry(expr)</em> operator.  For example, one can compute the elapsed time of a function: probe kernel.function("do_filp_open").return {</p>
<pre>
    println( get_timeofday_us() - @entry(get_timeofday_us()) )
</pre>
<p>}</p><p>The following table summarizes how values related to a function parameter context variable, a pointer named <strong>addr</strong>, may be accessed from a <em>.return</em> probe.</p><table class="table table-striped">
<tr>
<th><strong>at-entry value</th>
<th>past-exit value</strong></th>
<th></th></tr>

<tr>
<td></td>
<td></td>
<td></td></tr>

<tr>
<td>$addr</td>
<td><em>not available</em></td>
<td></td></tr>

<tr>
<td>$addr-&gt;x-&gt;y</td>
<td>@cast(@entry($addr),"struct zz")-&gt;x-&gt;y</td>
<td></td></tr>

<tr>
<td>$addr[0]</td>
<td>{kernel,user}_{char,int,...}(& $addr[0])</td>
<td></td></tr>
</table>
<h3>DWARFLESS</h3>
<p>In absence of debugging information, entry & exit points of kernel & module functions can be probed using the "kprobe" family of probes. However, these do not permit looking up the arguments / local variables of the function. Following constructs are supported : kprobe.function(FUNCTION) kprobe.function(FUNCTION).call kprobe.function(FUNCTION).return kprobe.module(NAME).function(FUNCTION) kprobe.module(NAME).function(FUNCTION).call kprobe.module(NAME).function(FUNCTION).return kprobe.statement.(ADDRESS).absolute</p><p>Probes of type <strong>function</strong> are recommended for kernel functions, whereas probes of type <strong>module</strong> are recommended for probing functions of the specified module. In case the absolute address of a kernel or module function is known, <strong>statement</strong> probes can be utilized.</p><p>Note that <em>FUNCTION</em> and <em>MODULE</em> names <strong>must not</strong> contain wildcards, or the probe will not be registered. Also, statement probes must be run under guru-mode only.</p>
<h3>USER-SPACE</h3>
<p>Support for user-space probing is available for kernels that are configured with the utrace extensions, or have the uprobes facility in linux 3.5.  (Various kernel build configuration options need to be enabled; systemtap will advise if these are missing.)</p><p>There are several forms.  First, a non-symbolic probe point: process(PID).statement(ADDRESS).absolute is analogous to</p><p>kernel.statement(ADDRESS).absolute in that both use raw (unverified) virtual addresses and provide no $variables.  The target PID parameter must identify a running process, and ADDRESS should identify a valid instruction address. All threads of that process will be probed.</p><p>Second, non-symbolic user-kernel interface events handled by utrace may be probed: process(PID).begin process("FULLPATH").begin process.begin process(PID).thread.begin process("FULLPATH").thread.begin process.thread.begin process(PID).end process("FULLPATH").end process.end process(PID).thread.end process("FULLPATH").thread.end process.thread.end process(PID).syscall process("FULLPATH").syscall process.syscall process(PID).syscall.return process("FULLPATH").syscall.return process.syscall.return process(PID).insn process("FULLPATH").insn process(PID).insn.block process("FULLPATH").insn.block</p><p>A <strong>.begin</strong> probe gets called when new process described by PID or FULLPATH gets created. A <strong>.thread.begin</strong> probe gets called when a new thread described by PID or FULLPATH gets created. A <strong>.end</strong> probe gets called when process described by PID or FULLPATH dies. A <strong>.thread.end</strong> probe gets called when a thread described by PID or FULLPATH dies. A <strong>.syscall</strong> probe gets called when a thread described by PID or FULLPATH makes a system call.  The system call number is available in the <strong>$syscall</strong> context variable, and the first 6 arguments of the system call are available in the <strong>$argN</strong> (ex. $arg1, $arg2, ...) context variable. A <strong>.syscall.return</strong> probe gets called when a thread described by PID or FULLPATH returns from a system call.  The system call number is available in the <strong>$syscall</strong> context variable, and the return value of the system call is available in the <strong>$return</strong> context variable. A <strong>.insn</strong> probe gets called for every single-stepped instruction of the process described by PID or FULLPATH. A <strong>.insn.block</strong> probe gets called for every block-stepped instruction of the process described by PID or FULLPATH.</p><p>If a process probe is specified without a PID or FULLPATH, all user threads will be probed.  However, if systemtap was invoked with the <em>-c</em> or <em>-x</em> options, then process probes are restricted to the process hierarchy associated with the target process.  If a process probe is unspecified (i.e. without a PID or FULLPATH), but with the <em>-c</em> option, the PATH of the <em>-c</em> cmd will be heuristically filled into the process PATH. In that case, only command parameters are allowed in the <em>-c</em> command (i.e. no command substitution allowed and no occurrences of any of these characters: '|&;&lt;&gt;(){}').</p><p>Third, symbolic static instrumentation compiled into programs and shared libraries may be probed: process("PATH").mark("LABEL") process("PATH").provider("PROVIDER").mark("LABEL") process(PID).mark("LABEL") process(PID).provider("PROVIDER").mark("LABEL")</p><p>A <strong>.mark</strong> probe gets called via a static probe which is defined in the application by STAP_PROBE1(PROVIDER,LABEL,arg1), which are macros defined in <strong>sys/sdt.h</strong>. The PROVIDER is an arbitrary application identifier, LABEL is the marker site identifier, and arg1 is the integer-typed argument. STAP_PROBE1 is used for probes with 1 argument, STAP_PROBE2 is used for probes with 2 arguments, and so on.  The arguments of the probe are available in the context variables $arg1, $arg2, ...  An alternative to using the STAP_PROBE macros is to use the dtrace script to create custom macros.  Additionally, the variables $$name and $$provider are available as parts of the probe point name.  The <strong>sys/sdt.h</strong> macro names DTRACE_PROBE* are available as aliases for STAP_PROBE*.</p><p>Finally, full symbolic source-level probes in user-space programs and shared libraries are supported.  These are exactly analogous to the symbolic DWARF-based kernel/module probes described above.  They expose the same sorts of context $variables for function parameters, local variables, and so on. process("PATH").function("NAME") process("PATH").statement("*@FILE.c:123") process("PATH").plt("NAME") process("PATH").library("PATH").plt("NAME") process("PATH").library("PATH").function("NAME") process("PATH").library("PATH").statement("*@FILE.c:123") process("PATH").function("*").return process("PATH").function("myfun").label("foo") process("PATH").function("foo").callee("bar") process("PATH").plt("NAME").return process(PID).function("NAME") process(PID).statement("*@FILE.c:123") process(PID).plt("NAME")</p><p>Note that for all process probes, <em>PATH</em> names refer to executables that are searched the same way shells do: relative to the working directory if they contain a "/" character, otherwise in <strong>$PATH</strong>. If PATH names refer to scripts, the actual interpreters (specified in the script in the first line after the #! characters) are probed.</p><p>If PATH is a process component parameter referring to shared libraries then all processes that map it at runtime would be selected for probing. If PATH is a library component parameter referring to shared libraries then the process specified by the process component would be selected. Note that the PATH pattern in a library component will always apply to libraries statically determined to be in use by the process. However, you may also specify the full path to any library file even if not statically needed by the process.</p><p>A .plt probe will probe functions in the program linkage table corresponding to the rest of the probe point.  .plt can be specified as a shorthand for .plt("*").  The symbol name is available as a $$name context variable; function arguments are not available, since PLTs are processed without debuginfo.  A .plt.return probe places a probe at the moment <strong>after</strong> the return from the named function.</p><p>If the PATH string contains wildcards as in the MPATTERN case, then standard globbing is performed to find all matching paths.  In this case, the <strong>$PATH</strong> environment variable is not used.</p><p>If systemtap was invoked with the <em>-c</em> or <em>-x</em> options, then process probes are restricted to the process hierarchy associated with the target process.</p>
<h3>JAVA</h3>
<p>Support for probing Java methods is available using Byteman as a backend. Byteman is an instrumentation tool from the JBoss project which systemtap can use to monitor invocations for a specific method or line in a Java program.</p><p>Systemtap does so by generating a Byteman script listing the probes to instrument and then invoking the Byteman <em>bminstall</em> utility.</p><p>This Java instrumentation support is currently a prototype feature with major limitations.  Moreover, Java probing currently does not work across users; the stap script must run (with appropriate permissions) under the same user that the Java process being probed. (Thus a stap script under root currently cannot probe Java methods in a non-root-user Java process.)</p><p>The first probe type refers to Java processes by the name of the Java process: java("PNAME").class("CLASSNAME").method("PATTERN") java("PNAME").class("CLASSNAME").method("PATTERN").return The PNAME argument must be a pre-existing jvm pid, and be identifiable via a jps listing.</p><p>The PATTERN parameter specifies the signature of the Java method to probe. The signature must consist of the exact name of the method, followed by a bracketed list of the types of the arguments, for instance "myMethod(int,double,Foo)". Wildcards are not supported.</p><p>The probe can be set to trigger at a specific line within the method by appending a line number with colon, just as in other types of probes: "myMethod(int,double,Foo):245".</p><p>The CLASSNAME parameter identifies the Java class the method belongs to, either with or without the package qualification. By default, the probe only triggers on descendants of the class that do not override the method definition of the original class. However, CLASSNAME can take an optional caret prefix, as in <em>^org.my.MyClass,</em> which specifies that the probe should also trigger on all descendants of MyClass that override the original method. For instance, every method with signature foo(int) in program org.my.MyApp can be probed at once using java("org.my.MyApp").class("^java.lang.Object").method("foo(int)")</p><p>The second probe type works analogously, but refers to Java processes by PID: java(PID).class("CLASSNAME").method("PATTERN") java(PID).class("CLASSNAME").method("PATTERN").return (PIDs for an already running process can be obtained using the <strong>jps</strong>(1) utility.)</p><p>Context variables defined within java probes include <em>$arg1</em> through <em>$arg10</em> (for up to the first 10 arguments of a method), represented as integers or strings.</p>
<h3>PROCFS</h3>
<p>These probe points allow procfs "files" in /proc/systemtap/MODNAME to be created, read and written using a permission that may be modified using the proper umask value. Default permissions are 0400 for read probes, and 0200 for write probes. If both a read and write probe are being used on the same file, a default permission of 0600 will be used. Using procfs.umask(0040).read would result in a 0404 permission set for the file. (<em>MODNAME</em> is the name of the systemtap module). The <em>proc</em> filesystem is a pseudo-filesystem which is used as an interface to kernel data structures. There are several probe point variants supported by the translator:</p><p>procfs("PATH").read procfs("PATH").umask(UMASK).read procfs("PATH").read.maxsize(MAXSIZE) procfs("PATH").umask(UMASK).maxsize(MAXSIZE) procfs("PATH").write procfs("PATH").umask(UMASK).write procfs.read procfs.umask(UMASK).read procfs.read.maxsize(MAXSIZE) procfs.umask(UMASK).read.maxsize(MAXSIZE) procfs.write procfs.umask(UMASK).write</p><p><em>PATH</em> is the file name (relative to /proc/systemtap/MODNAME) to be created. If no <em>PATH</em> is specified (as in the last two variants above), <em>PATH</em> defaults to "command".</p><p>When a user reads /proc/systemtap/MODNAME/PATH, the corresponding procfs <em>read</em> probe is triggered.  The string data to be read should be assigned to a variable named <em>$value</em>, like this:</p><p>procfs("PATH").read { $value = "100&#92;n" }</p><p>When a user writes into /proc/systemtap/MODNAME/PATH, the corresponding procfs <em>write</em> probe is triggered.  The data the user wrote is available in the string variable named <em>$value</em>, like this:</p><p>procfs("PATH").write { printf("user wrote: %s", $value) }</p><p><em>MAXSIZE</em> is the size of the procfs read buffer.  Specifying <em>MAXSIZE</em> allows larger procfs output.  If no <em>MAXSIZE</em> is specified, the procfs read buffer defaults to <em>STP_PROCFS_BUFSIZE</em> (which defaults to <em>MAXSTRINGLEN</em>, the maximum length of a string). If setting the procfs read buffers for more than one file is needed, it may be easiest to override the <em>STP_PROCFS_BUFSIZE</em> definition. Here's an example of using <em>MAXSIZE</em>:</p><p>procfs.read.maxsize(1024) {</p>
<pre>
    $value = "long string..."
    $value .= "another long string..."
    $value .= "another long string..."
    $value .= "another long string..."
</pre>
<p>}</p>
<h3>NETFILTER HOOKS</h3>
<p>These probe points allow observation of network packets using the netfilter mechanism. A netfilter probe in systemtap corresponds to a netfilter hook function in the original netfilter probes API. It is probably more convenient to use <em>tapset::netfilter</em>(3stap), which wraps the primitive netfilter hooks and does the work of extracting useful information from the context variables.</p><p>There are several probe point variants supported by the translator:</p><p>netfilter.hook("HOOKNAME").pf("PROTOCOL_F") netfilter.pf("PROTOCOL_F").hook("HOOKNAME") netfilter.hook("HOOKNAME").pf("PROTOCOL_F").priority("PRIORITY") netfilter.pf("PROTOCOL_F").hook("HOOKNAME").priority("PRIORITY")</p><p><em>PROTOCOL_F</em> is the protocol family to listen for, currently one of <em>NFPROTO_IPV4,</em> <em>NFPROTO_IPV6,</em> <em>NFPROTO_ARP,</em> or <em>NFPROTO_BRIDGE.</em></p><p><em>HOOKNAME</em> is the point, or 'hook', in the protocol stack at which to intercept the packet. The available hook names for each protocol family are taken from the kernel header files &lt;linux/netfilter_ipv4.h&gt;, &lt;linux/netfilter_ipv6.h&gt;, &lt;linux/netfilter_arp.h&gt; and &lt;linux/netfilter_bridge.h&gt;. For instance, allowable hook names for <em>NFPROTO_IPV4</em> are <em>NF_INET_PRE_ROUTING,</em> <em>NF_INET_LOCAL_IN,</em> <em>NF_INET_FORWARD,</em> <em>NF_INET_LOCAL_OUT,</em> and <em>NF_INET_POST_ROUTING.</em></p><p><em>PRIORITY</em> is an integer priority giving the order in which the probe point should be triggered relative to any other netfilter hook functions which trigger on the same packet. Hook functions execute on each packet in order from smallest priority number to largest priority number. If no <em>PRIORITY</em> is specified (as in the first two probe point variants above), <em>PRIORITY</em> defaults to "0".</p><p>There are a number of predefined priority names of the form <em>NF_IP_PRI_*</em> and <em>NF_IP6_PRI_*</em> which are defined in the kernel header files &lt;linux/netfilter_ipv4.h&gt; and &lt;linux/netfilter_ipv6.h&gt; respectively. The script is permitted to use these instead of specifying an integer priority. (The probe points for <em>NFPROTO_ARP</em> and <em>NFPROTO_BRIDGE</em> currently do not expose any named hook priorities to the script writer.) Thus, allowable ways to specify the priority include:</p><p>priority("255") priority("NF_IP_PRI_SELINUX_LAST")</p><p>A script using guru mode is permitted to specify any identifier or number as the parameter for hook, pf, and priority. This feature should be used with caution, as the parameter is inserted verbatim into the C code generated by systemtap.</p><p>The netfilter probe points define the following context variables:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>$hooknum</em></p>
  </dt>
  <dd>
    <p>The hook number.</p>
  </dd>
  <dt>
    <p><em>$skb</em></p>
  </dt>
  <dd>
    <p>The address of the sk_buff struct representing the packet. See &lt;linux/skbuff.h&gt; for details on how to use this struct, or alternatively use the tapset <em>tapset::netfilter</em>(3stap) for easy access to key information.</p>
  </dd>
  <dt>
    <p><em>$in</em></p>
  </dt>
  <dd>
    <p>The address of the net_device struct representing the network device on which the packet was received (if any). May be 0 if the device is unknown or undefined at that stage in the protocol stack.</p>
  </dd>
  <dt>
    <p><em>$out</em></p>
  </dt>
  <dd>
    <p>The address of the net_device struct representing the network device on which the packet will be sent (if any). May be 0 if the device is unknown or undefined at that stage in the protocol stack.</p>
  </dd>
  <dt>
    <p><em>$verdict</em></p>
  </dt>
  <dd>
    <p>(Guru mode only.) Assigning one of the verdict values defined in &lt;linux/netfilter.h&gt; to this variable alters the further progress of the packet through the protocol stack. For instance, the following guru mode script forces all ipv6 network packets to be dropped:</p><p>probe netfilter.pf("NFPROTO_IPV6").hook("NF_IP6_PRE_ROUTING") {</p>
<pre>
  $verdict = 0 /* nf_drop */
</pre>
<p>}</p><p>For convenience, unlike the primitive probe points discussed here, the probes defined in <em>tapset::netfilter</em>(3stap) export the lowercase names of the verdict constants (e.g. NF_DROP becomes nf_drop) as local variables.</p>
  </dd>

</dl>

<h3>KERNEL TRACEPOINTS</h3>
<p>This family of probe points hooks up to static probing tracepoints inserted into the kernel or modules.  As with markers, these tracepoints are special macro calls inserted by kernel developers to make probing faster and more reliable than with DWARF-based probes, and DWARF debugging information is not required to probe tracepoints. Tracepoints have an extra advantage of more strongly-typed parameters than markers.</p><p>Tracepoint probes look like: <strong>kernel.trace("name")</strong>. The tracepoint name string, which may contain the usual wildcard characters, is matched against the names defined by the kernel developers in the tracepoint header files.</p><p>The handler associated with a tracepoint-based probe may read the optional parameters specified at the macro call site.  These are named according to the declaration by the tracepoint author.  For example, the tracepoint probe <strong>kernel.trace("sched_switch")</strong> provides the parameters <strong>$rq</strong>, <strong>$prev</strong>, and <strong>$next</strong>. If the parameter is a complex type, as in a struct pointer, then a script can access fields with the same syntax as DWARF $target variables.  Also, tracepoint parameters cannot be modified, but in guru-mode a script may modify fields of parameters.</p><p>The name of the tracepoint is available in <strong>$$name</strong>, and a string of name=value pairs for all parameters of the tracepoint is available in <strong>$$vars</strong> or <strong>$$parms</strong>.</p>
<h3>KERNEL MARKERS (OBSOLETE)</h3>
<p>This family of probe points hooks up to an older style of static probing markers inserted into older kernels or modules.  These markers are special STAP_MARK macro calls inserted by kernel developers to make probing faster and more reliable than with DWARF-based probes. Further, DWARF debugging information is <em>not</em> required to probe markers.</p><p>Marker probe points begin with <strong>kernel</strong>. The next part names the marker itself: <strong>mark("name")</strong>. The marker name string, which may contain the usual wildcard characters, is matched against the names given to the marker macros when the kernel and/or module was compiled.    Optionally, you can specify <strong>format("format")</strong>. Specifying the marker format string allows differentiation between two markers with the same name but different marker format strings.</p><p>The handler associated with a marker-based probe may read the optional parameters specified at the macro call site.  These are named <strong>$arg1</strong> through <strong>$argNN</strong>, where NN is the number of parameters supplied by the macro.  Number and string parameters are passed in a type-safe manner.</p><p>The marker format string associated with a marker is available in <strong>$format</strong>. And also the marker name string is available in <strong>$name</strong>.</p>
<h3>HARDWARE BREAKPOINTS</h3>
<p>This family of probes is used to set hardware watchpoints for a given  (global) kernel symbol. The probes take three components as inputs :</p><p>1. The <strong>virtual</strong>address<strong>/</strong>name of the kernel symbol to be traced is supplied as argument to this class of probes. ( Probes for only data segment variables are supported. Probing local variables of a function cannot be done.)</p><p>2. Nature of access to be probed : a. <em>.write</em> probe gets triggered when a write happens at the specified address/symbol name. b. <em>rw</em> probe is triggered when either a read or write happens.</p><p>3. <strong>.length</strong> (optional) Users have the option of specifying the address interval to be probed using "length" constructs. The user-specified length gets approximated to the closest possible address length that the architecture can support. If the specified length exceeds the limits imposed by architecture, an error message is flagged and probe registration fails. Wherever 'length' is not specified, the translator requests a hardware breakpoint probe of length 1. It should be noted that the "length" construct is not valid with symbol names.</p><p>Following constructs are supported : probe kernel.data(ADDRESS).write probe kernel.data(ADDRESS).rw probe kernel.data(ADDRESS).length(LEN).write probe kernel.data(ADDRESS).length(LEN).rw probe kernel.data("SYMBOL_NAME").write probe kernel.data("SYMBOL_NAME").rw</p><p>This set of probes make use of the debug registers of the processor, which is a scarce resource. (4 on x86 , 1 on powerpc ) The script translation flags a warning if a user requests more hardware breakpoint probes than the limits set by architecture. For example,a pass-2 warning is flashed when an input script requests 5 hardware breakpoint probes on an x86 system while x86 architecture supports a maximum of 4 breakpoints. Users are cautioned to set probes judiciously.</p>
<h3>PERF</h3>
<p>This family of probe points interfaces to the kernel "perf event" infrastructure for controlling hardware performance counters. The events being attached to are described by the "type", "config" fields of the <em>perf_event_attr</em> structure, and are sampled at an interval governed by the "sample_period" field.</p><p>These fields are made available to systemtap scripts using the following syntax: probe perf.type(NN).config(MM).sample(XX) probe perf.type(NN).config(MM) probe perf.type(NN).config(MM).process("PROC") probe perf.type(NN).config(MM).counter("COUNTER") probe perf.type(NN).config(MM).process("PROC").counter("COUNTER") The systemtap probe handler is called once per XX increments of the underlying performance counter.  The default sampling count is 1000000. The range of valid type/config is described by the <a href="../man2/perf_event_open.2.html"><strong>perf_event_open</strong>(2)</a> system call, and/or the <em>linux/perf_event.h</em> file.  Invalid combinations or exhausted hardware counter resources result in errors during systemtap script startup.  Systemtap does not sanity-check the values: it merely passes them through to the kernel for error- and safety-checking.  By default the perf event probe is systemwide unless .process is specified, which will bind the probe to a specific task.  If the name is omitted then it is inferred from the stap -c argument.   A perf event can be read on demand using .counter.  The body of the perf probe handler will not be invoked for a .counter probe; instead, the counter is read in a user space probe via:</p>
<dl class='dl-vertical'>
  <dt>
    
<pre>
   process("PROCESS").statement("func@file") {stat &lt;&lt;&lt; @perf("NAME")}
</pre>

  </dt>
  <dd>
    
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Here are some example probe points, defining the associated events.</p>
<dl class='dl-vertical'>
  <dt>
    <p>begin, end, end</p>
  </dt>
  <dd>
    <p>refers to the startup and normal shutdown of the session.  In this case, the handler would run once during startup and twice during shutdown.</p>
  </dd>
  <dt>
    <p>timer.jiffies(1000).randomize(200)</p>
  </dt>
  <dd>
    <p>refers to a periodic interrupt, every 1000 +/- 200 jiffies.</p>
  </dd>
  <dt>
    <p>kernel.function("*init*"), kernel.function("*exit*")</p>
  </dt>
  <dd>
    <p>refers to all kernel functions with "init" or "exit" in the name.</p>
  </dd>
  <dt>
    <p>kernel.function("*@kernel/time.c:240")</p>
  </dt>
  <dd>
    <p>refers to any functions within the "kernel/time.c" file that span line 240.</p><p>Note that this is <strong>not</strong> a probe at the statement at that line number.  Use the</p><p>kernel.statement probe instead.</p>
  </dd>
  <dt>
    <p>kernel.trace("sched_*")</p>
  </dt>
  <dd>
    <p>refers to all scheduler-related (really, prefixed) tracepoints in the kernel.</p>
  </dd>
  <dt>
    <p>kernel.mark("getuid")</p>
  </dt>
  <dd>
    <p>refers to an obsolete STAP_MARK(getuid, ...) macro call in the kernel.</p>
  </dd>
  <dt>
    <p>module("usb*").function("*sync*").return</p>
  </dt>
  <dd>
    <p>refers to the moment of return from all functions with "sync" in the name in any of the USB drivers.</p>
  </dd>
  <dt>
    <p>kernel.statement(0xc0044852)</p>
  </dt>
  <dd>
    <p>refers to the first byte of the statement whose compiled instructions include the given address in the kernel.</p>
  </dd>
  <dt>
    <p>kernel.statement("*@kernel/time.c:296")</p>
  </dt>
  <dd>
    <p>refers to the statement of line 296 within "kernel/time.c".</p>
  </dd>
  <dt>
    <p>kernel.statement("bio_init@fs/bio.c+3")</p>
  </dt>
  <dd>
    <p>refers to the statement at line bio_init+3 within "fs/bio.c".</p>
  </dd>
  <dt>
    <p>kernel.data("pid_max").write</p>
  </dt>
  <dd>
    <p>refers to a hardware breakpoint of type "write" set on pid_max</p>
  </dd>
  <dt>
    <p>syscall.*.return</p>
  </dt>
  <dd>
    <p>refers to the group of probe aliases with any name in the third position</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO stapprobes&hellip;</h2>
        <div class="sectioncontent">

<pre>
<a href="../man1/stap.1.html"><strong>stap</strong>(1)</a>,
<em>probe::*</em>(3stap),
<em>tapset::*</em>(3stap)

</pre>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="stapfuncs.3stap.html"><span aria-hidden="true">&larr;</span> stapfuncs.3stap: Systemtap functions</a></li>
   <li class="next"><a href="stapvars.3stap.html">stapvars.3stap: Systemtap variables <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

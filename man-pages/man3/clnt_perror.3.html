<!DOCTYPE html>
<html lang="en">
<head>
  <link href='https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction|shadow-multiple' rel='stylesheet' type='text/css'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>rpc - library routines for remote procedure calls</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="${metadescription}">
  
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">clnt_perror<small> (3)</small></h1>
        <p class="lead">library routines for remote procedure calls</p>
      </div>

    <ol class="breadcrumb">
	<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_section">
		<a itemprop="url" href=".."><span itemprop="title">Linux Man Pages</span></a>
	</li>
	<li id="breadcrumb_section" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_page" itemprop="child">
		<a itemprop="url" href="../man3"><span itemprop="title">Library calls</span></a>
	</li>
	<li id="breadcrumb_page" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemprop="child" class="active">
		<a itemprop="url" href=""><span itemprop="title">clnt_perror</span></a>
	</li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple" id="$section">SYNOPSIS AND DESCRIPTION</h2>
        <div class="sectioncontent">

<p>These routines allow C programs to make procedure calls on other machines across the network. First, the client calls a procedure to send a data packet to the server. Upon receipt of the packet, the server calls a dispatch routine to perform the requested service, and then sends back a reply. Finally, the procedure call returns to the client.</p>
<p class='spacer'>

<p>To take use of these routines, include the header file <em>&lt;rpc/rpc.h&gt;</em>.</p>
<p class='spacer'>

  <p>The prototypes below make use of the following types:</p>
<pre>
<strong>typedef int </strong><em>bool_t</em><strong>;</strong>

<strong>typedef bool_t (*</strong><em>xdrproc_t</em><strong>) (XDR *, void *, ...);</strong>

<strong>typedef bool_t (*</strong><em>resultproc_t</em><strong>) (caddr_t </strong><em>resp</em><strong>,</strong>
<strong>                                struct sockaddr_in *</strong><em>raddr</em><strong>);</strong></pre>

<p class='spacer'>

<p>See the header files for the declarations of the <em>AUTH</em>, <em>CLIENT</em>, <em>SVCXPRT</em>, and <em>XDR</em> types.</p>
<p class='spacer'>

<pre><strong>void auth_destroy(AUTH *</strong><em>auth</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro that destroys the authentication information associated with <em>auth</em>. Destruction usually involves deallocation of private data structures. The use of <em>auth</em> is undefined after calling <strong>auth_destroy</strong>().</p>
<p class='spacer'>

<pre><strong>AUTH *authnone_create(void);</strong></pre>

<p class='spacer'>

<p>Create and return an RPC authentication handle that passes nonusable authentication information with each remote procedure call. This is the default authentication used by RPC.</p>
<p class='spacer'>

<pre><strong>AUTH *authunix_create(char *</strong><em>host</em><strong>, int </strong><em>uid</em><strong>, int </strong><em>gid</em><strong>,</strong>
<strong>                      int </strong><em>len</em><strong>, int *</strong><em>aup_gids</em><strong>);</strong></pre>

<p class='spacer'>

<p>Create and return an RPC authentication handle that contains authentication information. The parameter <em>host</em> is the name of the machine on which the information was created; <em>uid</em> is the user's user ID; <em>gid</em> is the user's current group ID; <em>len</em> and <em>aup_gids</em> refer to a counted array of groups to which the user belongs. It is easy to impersonate a user.</p>
<p class='spacer'>

<pre><strong>AUTH *authunix_create_default(void);</strong></pre>

<p class='spacer'>

<p>Calls <strong>authunix_create</strong>() with the appropriate parameters.</p>
<p class='spacer'>

<pre><strong>int callrpc(char *</strong><em>host</em><strong>, unsigned long </strong><em>prognum</em><strong>,</strong>
<strong>            unsigned long </strong><em>versnum</em><strong>, unsigned long </strong><em>procnum</em><strong>,</strong>
<strong>            xdrproc_t </strong><em>inproc</em><strong>, char *</strong><em>in</em><strong>,</strong>
<strong>            xdrproc_t </strong><em>outproc</em><strong>, char *</strong><em>out</em><strong>);</strong></pre>

<p class='spacer'>

<p>Call the remote procedure associated with <em>prognum</em>, <em>versnum</em>, and <em>procnum</em> on the machine, <em>host</em>. The parameter <em>in</em> is the address of the procedure's argument(s), and <em>out</em> is the address of where to place the result(s); <em>inproc</em> is used to encode the procedure's parameters, and <em>outproc</em> is used to decode the procedure's results. This routine returns zero if it succeeds, or the value of <strong>"enum clnt_stat"</strong> cast to an integer if it fails. The routine <strong>clnt_perrno</strong>() is handy for translating failure statuses into messages.</p>
<p class='spacer'>

<p>Warning: calling remote procedures with this routine uses UDP/IP as a transport; see <strong>clntudp_create</strong>() for restrictions. You do not have control of timeouts or authentication using this routine.</p>
<p class='spacer'>

<pre><strong>enum clnt_stat clnt_broadcast(unsigned long </strong><em>prognum</em><strong>,</strong>
<strong>                     unsigned long </strong><em>versnum</em><strong>, unsigned long </strong><em>procnum</em><strong>,</strong>
<strong>                     xdrproc_t </strong><em>inproc</em><strong>, char *</strong><em>in</em><strong>,</strong>
<strong>                     xdrproc_t </strong><em>outproc</em><strong>, char *</strong><em>out</em><strong>,</strong>
<strong>                     resultproc_t </strong><em>eachresult</em><strong>);</strong></pre>

<p class='spacer'>

<p>Like <strong>callrpc</strong>(), except the call message is broadcast to all locally connected broadcast nets. Each time it receives a response, this routine calls <strong>eachresult</strong>(), whose form is:</p>
<p class='spacer'>

<pre><strong>eachresult(char *</strong><em>out</em><strong>, struct sockaddr_in *</strong><em>addr</em><strong>);</strong></pre>

<p class='spacer'>

<p>where <em>out</em> is the same as <em>out</em> passed to <strong>clnt_broadcast</strong>(), except that the remote procedure's output is decoded there; <em>addr</em> points to the address of the machine that sent the results. If <strong>eachresult</strong>() returns zero, <strong>clnt_broadcast</strong>() waits for more replies; otherwise it returns with appropriate status.</p>
<p class='spacer'>

<p>Warning: broadcast sockets are limited in size to the maximum transfer unit of the data link. For ethernet, this value is 1500 bytes.</p>
<p class='spacer'>

<pre><strong>enum clnt_stat clnt_call(CLIENT *</strong><em>clnt</em><strong>, unsigned long </strong><em>procnum</em><strong>,</strong>
<strong>                    xdrproc_t </strong><em>inproc</em><strong>, char *</strong><em>in</em><strong>,</strong>
<strong>                    xdrproc_t </strong><em>outproc</em><strong>, char *</strong><em>out</em><strong>,</strong>
<strong>                    struct timeval </strong><em>tout</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro that calls the remote procedure <em>procnum</em> associated with the client handle, <em>clnt</em>, which is obtained with an RPC client creation routine such as <strong>clnt_create</strong>(). The parameter <em>in</em> is the address of the procedure's argument(s), and <em>out</em> is the address of where to place the result(s); <em>inproc</em> is used to encode the procedure's parameters, and <em>outproc</em> is used to decode the procedure's results; <em>tout</em> is the time allowed for results to come back.</p>
<p class='spacer'>

<pre><strong>clnt_destroy(CLIENT *</strong><em>clnt</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro that destroys the client's RPC handle. Destruction usually involves deallocation of private data structures, including <em>clnt</em> itself. Use of <em>clnt</em> is undefined after calling <strong>clnt_destroy</strong>(). If the RPC library opened the associated socket, it will close it also. Otherwise, the socket remains open.</p>
<p class='spacer'>

<pre><strong>CLIENT *clnt_create(char *</strong><em>host</em><strong>, unsigned long </strong><em>prog</em><strong>,</strong>
<strong>                    unsigned long </strong><em>vers</em><strong>, char *</strong><em>proto</em><strong>);</strong></pre>

<p class='spacer'>

<p>Generic client creation routine. <em>host</em> identifies the name of the remote host where the server is located. <em>proto</em> indicates which kind of transport protocol to use. The currently supported values for this field are &ldquo;udp&rdquo; and &ldquo;tcp&rdquo;. Default timeouts are set, but can be modified using <strong>clnt_control</strong>().</p>
<p class='spacer'>

<p>Warning: Using UDP has its shortcomings. Since UDP-based RPC messages can hold only up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.</p>
<p class='spacer'>

<pre><strong>bool_t clnt_control(CLIENT *</strong><em>cl</em><strong>, int </strong><em>req</em><strong>, char *</strong><em>info</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro used to change or retrieve various information about a client object. <em>req</em> indicates the type of operation, and <em>info</em> is a pointer to the information. For both UDP and TCP, the supported values of <em>req</em> and their argument types and what they do are:</p>
<p class='spacer'>

<pre><strong>CLSET_TIMEOUT</strong>  <em>struct timeval</em> // set total timeout
<strong>CLGET_TIMEOUT</strong>  <em>struct timeval</em> // get total timeout</pre>

<p class='spacer'>

<p>Note: if you set the timeout using <strong>clnt_control</strong>(), the timeout parameter passed to <strong>clnt_call</strong>() will be ignored in all future calls.</p>
<p class='spacer'>

<pre><strong>CLGET_SERVER_ADDR</strong>  <em>struct sockaddr_in </em> // get server's address</pre>

<p class='spacer'>

<p>The following operations are valid for UDP only:</p>
<p class='spacer'>

<pre><strong>CLSET_RETRY_TIMEOUT</strong>  <em>struct timeval</em> // set the retry timeout
<strong>CLGET_RETRY_TIMEOUT</strong>  <em>struct timeval</em> // get the retry timeout</pre>

<p class='spacer'>

<p>The retry timeout is the time that "UDP RPC" waits for the server to reply before retransmitting the request.</p>
<p class='spacer'>

<pre><strong>clnt_freeres(CLIENT * </strong><em>clnt</em><strong>, xdrproc_t </strong><em>outproc</em><strong>, char *</strong><em>out</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro that frees any data allocated by the RPC/XDR system when it decoded the results of an RPC call. The parameter <em>out</em> is the address of the results, and <em>outproc</em> is the XDR routine describing the results. This routine returns one if the results were successfully freed, and zero otherwise.</p>
<p class='spacer'>

<pre><strong>void clnt_geterr(CLIENT *</strong><em>clnt</em><strong>, struct rpc_err *</strong><em>errp</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro that copies the error structure out of the client handle to the structure at address <em>errp</em>.</p>
<p class='spacer'>

<pre><strong>void clnt_pcreateerror(char *</strong><em>s</em><strong>);</strong></pre>

<p class='spacer'>

<p>Print a message to standard error indicating why a client RPC handle could not be created. The message is prepended with string <em>s</em> and a colon. Used when a <strong>clnt_create</strong>(), <strong>clntraw_create</strong>(), <strong>clnttcp_create</strong>(), or <strong>clntudp_create</strong>() call fails.</p>
<p class='spacer'>

<pre><strong>void clnt_perrno(enum clnt_stat </strong><em>stat</em><strong>);</strong></pre>

<p class='spacer'>

<p>Print a message to standard error corresponding to the condition indicated by <em>stat</em>. Used after <strong>callrpc</strong>().</p>
<p class='spacer'>

<pre><strong>clnt_perror(CLIENT *</strong><em>clnt</em><strong>, char *</strong><em>s</em><strong>);</strong></pre>

<p class='spacer'>

<p>Print a message to standard error indicating why an RPC call failed; <em>clnt</em> is the handle used to do the call. The message is prepended with string <em>s</em> and a colon. Used after <strong>clnt_call</strong>().</p>
<p class='spacer'>

<pre><strong>char *clnt_spcreateerror(char *</strong><em>s</em><strong>);</strong></pre>

<p class='spacer'>

<p>Like <strong>clnt_pcreateerror</strong>(), except that it returns a string instead of printing to the standard error.</p>
<p class='spacer'>

<p>Bugs: returns pointer to static data that is overwritten on each call.</p>
<p class='spacer'>

<pre><strong>char *clnt_sperrno(enum clnt_stat </strong><em>stat</em><strong>);</strong></pre>

<p class='spacer'>

<p>Take the same arguments as <strong>clnt_perrno</strong>(), but instead of sending a message to the standard error indicating why an RPC call failed, return a pointer to a string which contains the message. The string ends with a NEWLINE.</p>
<p class='spacer'>

<p><strong>clnt_sperrno</strong>() is used instead of <strong>clnt_perrno</strong>() if the program does not have a standard error (as a program running as a server quite likely does not), or if the programmer does not want the message to be output with <a href="../man3/printf.3.html"><strong>printf</strong>(3)</a>, or if a message format different than that supported by <strong>clnt_perrno</strong>() is to be used. Note: unlike <strong>clnt_sperror</strong>() and <strong>clnt_spcreateerror</strong>(), <strong>clnt_sperrno</strong>() returns pointer to static data, but the result will not get overwritten on each call.</p>
<p class='spacer'>

<pre><strong>char *clnt_sperror(CLIENT *</strong><em>rpch</em><strong>, char *</strong><em>s</em><strong>);</strong></pre>

<p class='spacer'>

<p>Like <strong>clnt_perror</strong>(), except that (like <strong>clnt_sperrno</strong>()) it returns a string instead of printing to standard error.</p>
<p class='spacer'>

<p>Bugs: returns pointer to static data that is overwritten on each call.</p>
<p class='spacer'>

<pre><strong>CLIENT *clntraw_create(unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>);</strong></pre>

<p class='spacer'>

<p>This routine creates a toy RPC client for the remote program <em>prognum</em>, version <em>versnum</em>. The transport used to pass messages to the service is actually a buffer within the process's address space, so the corresponding RPC server should live in the same address space; see <strong>svcraw_create</strong>(). This allows simulation of RPC and acquisition of RPC overheads, such as round trip times, without any kernel interference. This routine returns NULL if it fails.</p>
<p class='spacer'>

<pre><strong>CLIENT *clnttcp_create(struct sockaddr_in *</strong><em>addr</em><strong>,</strong>
<strong>                unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>,</strong>
<strong>                int *</strong><em>sockp</em><strong>, unsigned int </strong><em>sendsz</em><strong>, unsigned int </strong><em>recvsz</em><strong>);</strong></pre>

<p class='spacer'>

<p>This routine creates an RPC client for the remote program <em>prognum</em>, version <em>versnum</em>; the client uses TCP/IP as a transport. The remote program is located at Internet address <em>*addr</em>. If <em>addr-&gt;sin_port</em> is zero, then it is set to the actual port that the remote program is listening on (the remote <strong>portmap</strong> service is consulted for this information). The parameter <em>sockp</em> is a socket; if it is <strong>RPC_ANYSOCK</strong>, then this routine opens a new one and sets <em>sockp</em>. Since TCP-based RPC uses buffered I/O, the user may specify the size of the send and receive buffers with the parameters <em>sendsz</em> and <em>recvsz</em>; values of zero choose suitable defaults. This routine returns NULL if it fails.</p>
<p class='spacer'>

<pre><strong>CLIENT *clntudp_create(struct sockaddr_in *</strong><em>addr</em><strong>,</strong>
<strong>                unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>,</strong>
<strong>                struct timeval </strong><em>wait</em><strong>, int *</strong><em>sockp</em><strong>);</strong></pre>

<p class='spacer'>

<p>This routine creates an RPC client for the remote program <em>prognum</em>, version <em>versnum</em>; the client uses use UDP/IP as a transport. The remote program is located at Internet address <em>addr</em>. If <em>addr-&gt;sin_port</em> is zero, then it is set to actual port that the remote program is listening on (the remote <strong>portmap</strong> service is consulted for this information). The parameter <em>sockp</em> is a socket; if it is <strong>RPC_ANYSOCK</strong>, then this routine opens a new one and sets <em>sockp</em>. The UDP transport resends the call message in intervals of <em>wait</em> time until a response is received or until the call times out. The total time for the call to time out is specified by <strong>clnt_call</strong>().</p>
<p class='spacer'>

<p>Warning: since UDP-based RPC messages can hold only up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.</p>
<p class='spacer'>

<pre><strong>CLIENT *clntudp_bufcreate(struct sockaddr_in *</strong><em>addr</em><strong>,</strong>
<strong>            unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>,</strong>
<strong>            struct timeval </strong><em>wait</em><strong>, int *</strong><em>sockp</em><strong>,</strong>
<strong>            unsigned int </strong><em>sendsize</em><strong>, unsigned int recosize</strong><em>);</em></pre>

<p class='spacer'>

<p>This routine creates an RPC client for the remote program <em>prognum</em>, on <em>versnum</em>; the client uses use UDP/IP as a transport. The remote program is located at Internet address <em>addr</em>. If <em>addr-&gt;sin_port</em> is zero, then it is set to actual port that the remote program is listening on (the remote <strong>portmap</strong> service is consulted for this information). The parameter <em>sockp</em> is a socket; if it is <strong>RPC_ANYSOCK</strong>, then this routine opens a new one and sets <em>sockp</em>. The UDP transport resends the call message in intervals of <em>wait</em> time until a response is received or until the call times out. The total time for the call to time out is specified by <strong>clnt_call</strong>().</p>
<p class='spacer'>

<p>This allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages.</p>
<p class='spacer'>

<pre><strong>void get_myaddress(struct sockaddr_in *</strong><em>addr</em><strong>);</strong></pre>

<p class='spacer'>

<p>Stuff the machine's IP address into <em>*addr</em>, without consulting the library routines that deal with <em>/etc/hosts</em>. The port number is always set to <strong>htons(PMAPPORT)</strong>.</p>
<p class='spacer'>

<pre><strong>struct pmaplist *pmap_getmaps(struct sockaddr_in *</strong><em>addr</em><strong>);</strong></pre>

<p class='spacer'>

<p>A user interface to the <strong>portmap</strong> service, which returns a list of the current RPC program-to-port mappings on the host located at IP address <em>*addr</em>. This routine can return NULL. The command <em>"rpcinfo&nbsp;-p"</em> uses this routine.</p>
<p class='spacer'>

<pre><strong>unsigned short pmap_getport(struct sockaddr_in *</strong><em>addr</em><strong>,</strong>
<strong>                    unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>,</strong>
<strong>                    unsigned int </strong><em>protocol</em><strong>);</strong></pre>

<p class='spacer'>

<p>A user interface to the <strong>portmap</strong> service, which returns the port number on which waits a service that supports program number <em>prognum</em>, version <em>versnum</em>, and speaks the transport protocol associated with <em>protocol</em>. The value of <em>protocol</em> is most likely <strong>IPPROTO_UDP</strong> or <strong>IPPROTO_TCP</strong>. A return value of zero means that the mapping does not exist or that the RPC system failed to contact the remote <strong>portmap</strong> service. In the latter case, the global variable <em>rpc_createerr</em> contains the RPC status.</p>
<p class='spacer'>

<pre><strong>enum clnt_stat pmap_rmtcall(struct sockaddr_in *</strong><em>addr</em><strong>,</strong>
<strong>                    unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>,</strong>
<strong>                    unsigned long </strong><em>procnum</em><strong>,</strong>
<strong>                    xdrproc_t </strong><em>inproc</em><strong>, char *</strong><em>in</em><strong>,</strong>
<strong>                    xdrproc_t </strong><em>outproc</em><strong>, char *</strong><em>out</em><strong>,</strong>
<strong>                    struct timeval </strong><em>tout</em><strong>, unsigned long *</strong><em>portp</em><strong>);</strong></pre>

<p class='spacer'>

<p>A user interface to the <strong>portmap</strong> service, which instructs <strong>portmap</strong> on the host at IP address <em>*addr</em> to make an RPC call on your behalf to a procedure on that host. The parameter <em>*portp</em> will be modified to the program's port number if the procedure succeeds. The definitions of other parameters are discussed in <strong>callrpc</strong>() and <strong>clnt_call</strong>(). This procedure should be used for a &ldquo;ping&rdquo; and nothing else. See also <strong>clnt_broadcast</strong>().</p>
<p class='spacer'>

<pre><strong>bool_t pmap_set(unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>,</strong>
<strong>                unsigned int </strong><em>protocol</em><strong>, unsigned short </strong><em>port</em><strong>);</strong></pre>

<p class='spacer'>

<p>A user interface to the <strong>portmap</strong> service, which establishes a mapping between the triple [<em>prognum</em>,<em>versnum</em>,<em>protocol</em>] and <em>port</em> on the machine's <strong>portmap</strong> service. The value of <em>protocol</em> is most likely <strong>IPPROTO_UDP</strong> or <strong>IPPROTO_TCP</strong>. This routine returns one if it succeeds, zero otherwise. Automatically done by <strong>svc_register</strong>().</p>
<p class='spacer'>

<pre><strong>bool_t pmap_unset(unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>);</strong></pre>

<p class='spacer'>

<p>A user interface to the <strong>portmap</strong> service, which destroys all mapping between the triple [<em>prognum</em>,<em>versnum</em>,<em>*</em>] and <strong>ports</strong> on the machine's <strong>portmap</strong> service. This routine returns one if it succeeds, zero otherwise.</p>
<p class='spacer'>

<pre><strong>int registerrpc(unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>,</strong>
<strong>                unsigned long </strong><em>procnum</em><strong>, char *(*</strong><em>procname</em><strong>)(char *),</strong>
<strong>                xdrproc_t </strong><em>inproc</em><strong>, xdrproc_t </strong><em>outproc</em><strong>);</strong></pre>

<p class='spacer'>

<p>Register procedure <em>procname</em> with the RPC service package. If a request arrives for program <em>prognum</em>, version <em>versnum</em>, and procedure <em>procnum</em>, <em>procname</em> is called with a pointer to its parameter(s); <em>procname</em> should return a pointer to its static result(s); <em>inproc</em> is used to decode the parameters while <em>outproc</em> is used to encode the results. This routine returns zero if the registration succeeded, -1 otherwise.</p>
<p class='spacer'>

<p>Warning: remote procedures registered in this form are accessed using the UDP/IP transport; see <strong>svcudp_create</strong>() for restrictions.</p>
<p class='spacer'>

<pre><strong>struct rpc_createerr </strong><em>rpc_createerr</em><strong>;</strong></pre>

<p class='spacer'>

<p>A global variable whose value is set by any RPC client creation routine that does not succeed. Use the routine <strong>clnt_pcreateerror</strong>() to print the reason why.</p>
<p class='spacer'>

<pre><strong>void svc_destroy(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro that destroys the RPC service transport handle, <em>xprt</em>. Destruction usually involves deallocation of private data structures, including <em>xprt</em> itself. Use of <em>xprt</em> is undefined after calling this routine.</p>
<p class='spacer'>

<pre><strong>fd_set </strong><em>svc_fdset</em><strong>;</strong></pre>

<p class='spacer'>

<p>A global variable reflecting the RPC service side's read file descriptor bit mask; it is suitable as a parameter to the <a href="../man2/select.2.html"><strong>select</strong>(2)</a> system call. This is of interest only if a service implementor does their own asynchronous event processing, instead of calling <strong>svc_run</strong>(). This variable is read-only (do not pass its address to <a href="../man2/select.2.html"><strong>select</strong>(2)</a>!), yet it may change after calls to <strong>svc_getreqset</strong>() or any creation routines.</p>
<p class='spacer'>

<pre><strong>int </strong><em>svc_fds</em><strong>;</strong></pre>

<p class='spacer'>

<p>Similar to <strong>svc_fdset</strong>, but limited to 32 file descriptors. This interface is obsoleted by <strong>svc_fdset</strong>.</p>
<p class='spacer'>

<pre><strong>svc_freeargs(SVCXPRT *</strong><em>xprt</em><strong>, xdrproc_t </strong><em>inproc</em><strong>, char *</strong><em>in</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro that frees any data allocated by the RPC/XDR system when it decoded the arguments to a service procedure using <strong>svc_getargs</strong>(). This routine returns 1 if the results were successfully freed, and zero otherwise.</p>
<p class='spacer'>

<pre><strong>svc_getargs(SVCXPRT *</strong><em>xprt</em><strong>, xdrproc_t </strong><em>inproc</em><strong>, char *</strong><em>in</em><strong>);</strong></pre>

<p class='spacer'>

<p>A macro that decodes the arguments of an RPC request associated with the RPC service transport handle, <em>xprt</em>. The parameter <em>in</em> is the address where the arguments will be placed; <em>inproc</em> is the XDR routine used to decode the arguments. This routine returns one if decoding succeeds, and zero otherwise.</p>
<p class='spacer'>

<pre><strong>struct sockaddr_in *svc_getcaller(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>The approved way of getting the network address of the caller of a procedure associated with the RPC service transport handle, <em>xprt</em>.</p>
<p class='spacer'>

<pre><strong>void svc_getreqset(fd_set *</strong><em>rdfds</em><strong>);</strong></pre>

<p class='spacer'>

<p>This routine is of interest only if a service implementor does not call <strong>svc_run</strong>(), but instead implements custom asynchronous event processing. It is called when the <a href="../man2/select.2.html"><strong>select</strong>(2)</a> system call has determined that an RPC request has arrived on some RPC socket(s); <em>rdfds</em> is the resultant read file descriptor bit mask. The routine returns when all sockets associated with the value of <em>rdfds</em> have been serviced.</p>
<p class='spacer'>

<pre><strong>void svc_getreq(int </strong><em>rdfds</em><strong>);</strong></pre>

<p class='spacer'>

<p>Similar to <strong>svc_getreqset</strong>(), but limited to 32 file descriptors. This interface is obsoleted by <strong>svc_getreqset</strong>().</p>
<p class='spacer'>

<pre><strong>bool_t svc_register(SVCXPRT *</strong><em>xprt</em><strong>, unsigned long </strong><em>prognum</em><strong>,</strong>
<strong>                    unsigned long </strong><em>versnum</em><strong>,</strong>
<strong>                    void (*</strong><em>dispatch</em><strong>)(svc_req *, SVCXPRT *),</strong>
<strong>                    unsigned long </strong><em>protocol</em><strong>);</strong></pre>

<p class='spacer'>

  <p>Associates <em>prognum</em> and <em>versnum</em> with the service dispatch procedure, <em>dispatch</em>. If <em>protocol</em> is zero, the service is not registered with the <strong>portmap</strong> service. If <em>protocol</em> is nonzero, then a mapping of the triple [<em>prognum</em>,<em>versnum</em>,<em>protocol</em>] to <em>xprt-&gt;xp_port</em> is established with the local <strong>portmap</strong> service (generally <em>protocol</em> is zero, <strong>IPPROTO_UDP</strong> or <strong>IPPROTO_TCP</strong>). The procedure <em>dispatch</em> has the following form:</p>
<pre>
dispatch(struct svc_req *request, SVCXPRT *xprt);</pre>

<p class='spacer'>

<p>The <strong>svc_register</strong>() routine returns one if it succeeds, and zero otherwise.</p>
<p class='spacer'>

<pre><strong>"void svc_run(void);"</strong></pre>

<p class='spacer'>

<p>This routine never returns. It waits for RPC requests to arrive, and calls the appropriate service procedure using <strong>svc_getreq</strong>() when one arrives. This procedure is usually waiting for a <a href="../man2/select.2.html"><strong>select</strong>(2)</a> system call to return.</p>
<p class='spacer'>

<pre><strong>bool_t svc_sendreply(SVCXPRT *</strong><em>xprt</em><strong>, xdrproc_t </strong><em>outproc</em><strong>, char *</strong><em>out</em><strong>);</strong></pre>

<p class='spacer'>

<p>Called by an RPC service's dispatch routine to send the results of a remote procedure call. The parameter <em>xprt</em> is the request's associated transport handle; <em>outproc</em> is the XDR routine which is used to encode the results; and <em>out</em> is the address of the results. This routine returns one if it succeeds, zero otherwise.</p>
<p class='spacer'>

<pre><strong>void svc_unregister(unsigned long </strong><em>prognum</em><strong>, unsigned long </strong><em>versnum</em><strong>);</strong></pre>

<p class='spacer'>

<p>Remove all mapping of the double [<em>prognum</em>,<em>versnum</em>] to dispatch routines, and of the triple [<em>prognum</em>,<em>versnum</em>,<em>*</em>] to port number.</p>
<p class='spacer'>

<pre><strong>void svcerr_auth(SVCXPRT *</strong><em>xprt</em><strong>, enum auth_stat </strong><em>why</em><strong>);</strong></pre>

<p class='spacer'>

<p>Called by a service dispatch routine that refuses to perform a remote procedure call due to an authentication error.</p>
<p class='spacer'>

<pre><strong>void svcerr_decode(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>Called by a service dispatch routine that cannot successfully decode its parameters. See also <strong>svc_getargs</strong>().</p>
<p class='spacer'>

<pre><strong>void svcerr_noproc(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>Called by a service dispatch routine that does not implement the procedure number that the caller requests.</p>
<p class='spacer'>

<pre><strong>void svcerr_noprog(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>Called when the desired program is not registered with the RPC package. Service implementors usually do not need this routine.</p>
<p class='spacer'>

<pre><strong>void svcerr_progvers(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>Called when the desired version of a program is not registered with the RPC package. Service implementors usually do not need this routine.</p>
<p class='spacer'>

<pre><strong>void svcerr_systemerr(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>Called by a service dispatch routine when it detects a system error not covered by any particular protocol. For example, if a service can no longer allocate storage, it may call this routine.</p>
<p class='spacer'>

<pre><strong>void svcerr_weakauth(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>Called by a service dispatch routine that refuses to perform a remote procedure call due to insufficient authentication parameters. The routine calls <strong>svcerr_auth(xprt, AUTH_TOOWEAK)</strong>.</p>
<p class='spacer'>

<pre><strong>SVCXPRT *svcfd_create(int </strong><em>fd</em><strong>, unsigned int </strong><em>sendsize</em><strong>,</strong>
<strong>                      unsigned int </strong><em>recvsize</em><strong>);</strong></pre>

<p class='spacer'>

<p>Create a service on top of any open file descriptor. Typically, this file descriptor is a connected socket for a stream protocol such as TCP. <em>sendsize</em> and <em>recvsize</em> indicate sizes for the send and receive buffers. If they are zero, a reasonable default is chosen.</p>
<p class='spacer'>

<pre><strong>SVCXPRT *svcraw_create(void);</strong></pre>

<p class='spacer'>

<p>This routine creates a toy RPC service transport, to which it returns a pointer. The transport is really a buffer within the process's address space, so the corresponding RPC client should live in the same address space; see <strong>clntraw_create</strong>(). This routine allows simulation of RPC and acquisition of RPC overheads (such as round trip times), without any kernel interference. This routine returns NULL if it fails.</p>
<p class='spacer'>

<pre><strong>SVCXPRT *svctcp_create(int </strong><em>sock</em><strong>, unsigned int </strong><em>send_buf_size</em><strong>,</strong>
<strong>                       unsigned int </strong><em>recv_buf_size</em><strong>);</strong></pre>

<p class='spacer'>

<p>This routine creates a TCP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <em>sock</em>, which may be <strong>RPC_ANYSOCK</strong>, in which case a new socket is created. If the socket is not bound to a local TCP port, then this routine binds it to an arbitrary port. Upon completion, <em>xprt-&gt;xp_sock</em> is the transport's socket descriptor, and <em>xprt-&gt;xp_port</em> is the transport's port number. This routine returns NULL if it fails. Since TCP-based RPC uses buffered I/O, users may specify the size of buffers; values of zero choose suitable defaults.</p>
<p class='spacer'>

<pre><strong>SVCXPRT *svcudp_bufcreate(int </strong><em>sock</em><strong>, unsigned int </strong><em>sendsize</em><strong>,</strong>
<strong>                          unsigned int </strong><em>recosize</em><strong>);</strong></pre>

<p class='spacer'>

<p>This routine creates a UDP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <em>sock</em>, which may be <strong>RPC_ANYSOCK</strong>, in which case a new socket is created. If the socket is not bound to a local UDP port, then this routine binds it to an arbitrary port. Upon completion, <em>xprt-&gt;xp_sock</em> is the transport's socket descriptor, and <em>xprt-&gt;xp_port</em> is the transport's port number. This routine returns NULL if it fails.</p>
<p class='spacer'>

<p>This allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages.</p>
<p class='spacer'>

<pre><strong>SVCXPRT *svcudp_create(int </strong><em>sock</em><strong>);</strong></pre>

<p class='spacer'>

<p>This call is equivalent to <em>svcudp_bufcreate(sock,SZ,SZ)</em> for some default size <em>SZ</em>.</p>
<p class='spacer'>

<pre><strong>bool_t xdr_accepted_reply(XDR *</strong><em>xdrs</em><strong>, struct accepted_reply *</strong><em>ar</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for encoding RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p>
<p class='spacer'>

<pre><strong>bool_t xdr_authunix_parms(XDR *</strong><em>xdrs</em><strong>, struct authunix_parms *</strong><em>aupp</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for describing UNIX credentials. This routine is useful for users who wish to generate these credentials without using the RPC authentication package.</p>
<p class='spacer'>

<pre><strong>void xdr_callhdr(XDR *</strong><em>xdrs</em><strong>, struct rpc_msg *</strong><em>chdr</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for describing RPC call header messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p>
<p class='spacer'>

<pre><strong>bool_t xdr_callmsg(XDR *</strong><em>xdrs</em><strong>, struct rpc_msg *</strong><em>cmsg</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for describing RPC call messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p>
<p class='spacer'>

<pre><strong>bool_t xdr_opaque_auth(XDR *</strong><em>xdrs</em><strong>, struct opaque_auth *</strong><em>ap</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for describing RPC authentication information messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p>
<p class='spacer'>

<pre><strong>bool_t xdr_pmap(XDR *</strong><em>xdrs</em><strong>, struct pmap *</strong><em>regs</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for describing parameters to various <strong>portmap</strong> procedures, externally. This routine is useful for users who wish to generate these parameters without using the <strong>pmap</strong> interface.</p>
<p class='spacer'>

<pre><strong>bool_t xdr_pmaplist(XDR *</strong><em>xdrs</em><strong>, struct pmaplist **</strong><em>rp</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for describing a list of port mappings, externally. This routine is useful for users who wish to generate these parameters without using the <strong>pmap</strong> interface.</p>
<p class='spacer'>

<pre><strong>bool_t xdr_rejected_reply(XDR *</strong><em>xdrs</em><strong>, struct rejected_reply *</strong><em>rr</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for describing RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</p>
<p class='spacer'>

<pre><strong>bool_t xdr_replymsg(XDR *</strong><em>xdrs</em><strong>, struct rpc_msg *</strong><em>rmsg</em><strong>);</strong></pre>

<p class='spacer'>

<p>Used for describing RPC reply messages. This routine is useful for users who wish to generate RPC style messages without using the RPC package.</p>
<p class='spacer'>

<pre><strong>void xprt_register(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>After RPC service transport handles are created, they should register themselves with the RPC service package. This routine modifies the global variable <em>svc_fds</em>. Service implementors usually do not need this routine.</p>
<p class='spacer'>

<pre><strong>void xprt_unregister(SVCXPRT *</strong><em>xprt</em><strong>);</strong></pre>

<p class='spacer'>

<p>Before an RPC service transport handle is destroyed, it should unregister itself with the RPC service package. This routine modifies the global variable <em>svc_fds</em>. Service implementors usually do not need this routine.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple" id="$section">ATTRIBUTES</h2>
        <div class="sectioncontent">

<p>For an explanation of the terms used in this section, see <a href="../man7/attributes.7.html"><strong>attributes</strong>(7)</a>.</p>
<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<p class='spacer'>

<table class="table table-striped">
<tr>
<th>Interface</th>
<th>Attribute</th>
<th>Value</th></tr>

<tr>
<td><strong>auth_destroy</strong>(),   <strong>authnone_create</strong>(),   <strong>authunix_create</strong>(),   <strong>authunix_create_default</strong>(),   <strong>callrpc</strong>(),   <strong>clnt_broadcast</strong>(),   <strong>clnt_call</strong>(),   <strong>clnt_destroy</strong>(),   <strong>clnt_create</strong>(),   <strong>clnt_control</strong>(),   <strong>clnt_freeres</strong>(),   <strong>clnt_geterr</strong>(),   <strong>clnt_pcreateerror</strong>(),   <strong>clnt_perrno</strong>(),   <strong>clnt_perror</strong>(),   <strong>clnt_spcreateerror</strong>(),   <strong>clnt_sperrno</strong>(),   <strong>clnt_sperror</strong>(),   <strong>clntraw_create</strong>(),   <strong>clnttcp_create</strong>(),   <strong>clntudp_create</strong>(),   <strong>clntudp_bufcreate</strong>(),   <strong>get_myaddress</strong>(),   <strong>pmap_getmaps</strong>(),   <strong>pmap_getport</strong>(),   <strong>pmap_rmtcall</strong>(),   <strong>pmap_set</strong>(),   <strong>pmap_unset</strong>(),   <strong>registerrpc</strong>(),   <strong>svc_destroy</strong>(),   <strong>svc_freeargs</strong>(),   <strong>svc_getargs</strong>(),   <strong>svc_getcaller</strong>(),   <strong>svc_getreqset</strong>(),   <strong>svc_getreq</strong>(),   <strong>svc_register</strong>(),   <strong>svc_run</strong>(),   <strong>svc_sendreply</strong>(),   <strong>svc_unregister</strong>(),   <strong>svcerr_auth</strong>(),   <strong>svcerr_decode</strong>(),   <strong>svcerr_noproc</strong>(),   <strong>svcerr_noprog</strong>(),   <strong>svcerr_progvers</strong>(),   <strong>svcerr_systemerr</strong>(),   <strong>svcerr_weakauth</strong>(),   <strong>svcfd_create</strong>(),   <strong>svcraw_create</strong>(),   <strong>svctcp_create</strong>(),   <strong>svcudp_bufcreate</strong>(),   <strong>svcudp_create</strong>(),   <strong>xdr_accepted_reply</strong>(),   <strong>xdr_authunix_parms</strong>(),   <strong>xdr_callhdr</strong>(),   <strong>xdr_callmsg</strong>(),   <strong>xdr_opaque_auth</strong>(),   <strong>xdr_pmap</strong>(),   <strong>xdr_pmaplist</strong>(),   <strong>xdr_rejected_reply</strong>(),   <strong>xdr_replymsg</strong>(),   <strong>xprt_register</strong>(),   <strong>xprt_unregister</strong>()  </td>
<td>Thread safety</td>
<td>MT-Safe</td></tr>
</table>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple" id="$section">SEE ALSO</h2>
        <div class="sectioncontent">

<p><a href="../man3/xdr.3.html"><strong>xdr</strong>(3)</a></p>
<p class='spacer'>

  <p>The following manuals: Remote Procedure Calls: Protocol Specification</p>
<p class='spacer'>

  <p>Remote Procedure Call Programming Guide</p>
<p class='spacer'>

  <p>rpcgen Programming Guide</p>
<p class='spacer'>

<p class='spacer'>

<p><em>RPC: Remote Procedure Call Protocol Specification</em>, RFC&nbsp;1050, Sun Microsystems, Inc., USC-ISI.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
  <li class="previous"><a href="clnt_perrno.3.html"><span aria-hidden="true">&larr;</span> clnt_perrno.3: library routines for remote procedure calls</a></li><li class="next"><a href="clnt_spcreateerror.3.html">clnt_spcreateerror.3: library routines for remote procedure calls <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>
  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

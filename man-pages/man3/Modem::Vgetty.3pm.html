<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Modem::Vgetty: Interface to vgetty(8)</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Interface to vgetty(8)">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Modem::Vgetty (3pm) manual">
  <meta name="twitter:description" content="Interface to vgetty(8)">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmodem-vgetty-perl-Modem::Vgetty-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Modem::Vgetty.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Modem::Vgetty (3pm) manual" />
  <meta property="og:description" content="Interface to vgetty(8)" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmodem-vgetty-perl-Modem::Vgetty-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Modem::Vgetty<small> (3pm)</small></h1>
        <p class="lead">Interface to vgetty(8)</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Modem::Vgetty.3pm.html">
      <span itemprop="name">Modem::Vgetty: Interface to vgetty(8)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmodem-vgetty-perl/">
      <span itemprop="name">libmodem-vgetty-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Modem::Vgetty.3pm.html">
      <span itemprop="name">Modem::Vgetty: Interface to vgetty(8)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        use Modem::Vgetty;
        $v = new Modem::Vgetty;

        $string = $v-&gt;receive;
        $v-&gt;send($string);
        $string = $v-&gt;expect($str1, $str2, ...);
        $v-&gt;waitfor($string);
        $rv = $v-&gt;chat($expect1, $send1, $expect2, $send2, ...);

        $ttyname = $v-&gt;getty;
        $rv = $v-&gt;device($dev_type);
        $rv = $v-&gt;autostop($bool);
        $rv = $v-&gt;modem_type; # !!! see the docs below.

        $rv = $v-&gt;beep($freq, $len);
        $rv = $v-&gt;dial($number);
        $rv = $v-&gt;play($filename);
        $rv = $v-&gt;record($filename);
        $rv = $v-&gt;wait($seconds);
        $rv = $v-&gt;play_and_wait($filename);
        $v-&gt;stop;

        $v-&gt;add_handler($event, $handler_name, $handler);
        $v-&gt;del_handler($event, $handler_name);
        $v-&gt;enable_events;
        $v-&gt;disable_events;

        $number = $v-&gt;readnum($message, $tmout, $repeat);

        $v-&gt;shutdown;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>\*(C`Modem::Vgetty\*(C' is an encapsulation object for writing applications for voice modems using the <strong></strong><strong>vgetty</strong><strong>\|(8)</strong> or <strong></strong><strong>vm</strong><strong>\|(8)</strong> package. The answering machines and sofisticated voice applications can be written using this module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p><em>Voice modem</em> is a special kind of modem, which (besides the normal data and/or fax mode) can communicate also in voice mode. It means it can record sounds it hears from the phone line to the file, Play-back recorded files, it can beep to the line, and it can detect various standard sounds coming from the line (busy tone, silence, dual tone modulation frequency (\s-1DTMF\s0) keypad tones, etc). An example of the voice modem can be the ZyXEL U1496, \s-1US\s0 Robotics Sportster (not Courier), etc.</p><p>To use this software with the voice modem you need to have the <strong></strong><strong>vgetty</strong><strong>\|(8)</strong> package installed. <strong>Vgetty</strong> is distributed as a part of <strong>mgetty</strong> package. In fact, <strong>vgetty</strong> is a <strong></strong><strong>mgetty</strong><strong>\|(8)</strong> with the voice extensions. Vgetty has some support for scripting - when it receives an incoming call, it runs a voice shell (it is program specified in the <strong>voice.conf</strong> file) as its child process, establishes the read and write pipes to it, and tells it the number of the appropriate descriptors in the environment variables. Voice shell can now communicate with <strong>vgetty</strong>. It can tell <strong>vgetty</strong> \*(L"Play this file\*(R", or \*(L"Record anything you hear to that file\*(R", or \*(L"Notify me when user hangs up\*(R", etc. Sophisticated voice systems and answering machines can be build on top of <strong>vgetty</strong>.</p><p><strong>mgetty</strong> (including the <strong>vgetty</strong>) is available at the following \s-1URL:\s0</p><p>        ftp://alpha.greenie.net/pub/mgetty/</p><p>Originally there was a (Bourne) shell interface to <strong>vgetty</strong> only. The <strong>Modem::Vgetty</strong> module allows user to write the voice shell in Perl. The typical use is to write a script and point the <strong>vgetty</strong> to it (in <strong>voice.conf</strong> file). The script will be run when somebody calls in. Another use is running voice shell from the <strong></strong><strong>vm</strong><strong>\|(8)</strong> program, which can for example dial somewhere and say something.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUICK START</h2>
        <div class="sectioncontent">
<p>        #!/usr/bin/perl         use Modem::Vgetty;         my $v = new Modem::Vgetty;         $v-&gt;add_handler(&apos;BUSY_TONE&apos;, &apos;endh&apos;, sub { $v-&gt;stop; <strong>exit</strong>(0); });         local $SIG{ALRM} = sub { $v-&gt;stop; };         $v-&gt;enable_events;         $v-&gt;record(&apos;/tmp/hello.rmd&apos;);         alarm(20);         $v-&gt;waitfor(&apos;READY&apos;);         $v-&gt;shutdown;</p><p>The above example installs the simple `exit now'-style handler for the <strong>\s-1BUSY_TONE\s0</strong> event (which is sent by <strong>vgetty</strong> when user hangs up) and then records the <strong>hello.rmd</strong> file. Put this text into a file and then point <strong>vgetty</strong> to it in the <strong>voice.conf</strong>. After you dial into your voice modem, you can record a 20-seconds of some message. Verify that <strong>/tmp/hello.rmd</strong> exists. Now delete the line contaning the word \*(L"record\*(R" and two subsequent lines and insert to the file the following line instead of them:</p><p>        $v-&gt;play_and_wait(&apos;/tmp/hello.rmd&apos;);</p><p>Now call the voice modem and listen to the sounds you have just recorded.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>Begin and end of communication</h3>
<p>The <strong>Modem::Vgetty</strong> object will initialize the communication pipes to the <strong>vgetty</strong> at the creation time - in the constructor. The closing of the communication is done via the <strong>shutdown</strong> method:</p><p>        $v-&gt;shutdown;</p><p>The module will call this method itself from the destructor, if you do not call it explicitly.</p>
<h3>Low-level communication</h3>
<p>Users probably don't want to use these methods directly. Use the higher-level functions instead.</p>
<dl class='dl-vertical'>
  <dt>
    receive
  </dt>
  <dd>
    <p>This method returns a string received from the <strong>vgetty</strong>. It parses the string for the event types and runs appropriate event handlers. If event handler is run it waits for another string.</p>
  </dd>
  <dt>
    send($string)
  </dt>
  <dd>
    <p>This method sends the string <strong></strong><strong>$string</strong><strong></strong> to the <strong>vgetty</strong> process. Receives a string from <strong>vgetty</strong> (using the <strong>receive</strong> method described above) and returns it iff it is equal to one of the strings in the argument list. When something different is received, this method returns <strong>undef</strong>.</p>
  </dd>
  <dt>
    waitfor($string)
  </dt>
  <dd>
    <p>Waits until the string <strong></strong><strong>$sring</strong><strong></strong> is received from <strong>vgetty</strong> (using the <strong>receive</strong> method described above). =item chat($expect1, $sent1, $expect2, $sent2, ...) A chat-script with <strong>vgetty</strong>. Arguments are interpreted as the received-sent string pairs. A received string equals to the empty string means that no <strong>receive</strong> method will be called at that place. This can be used for constructing chat scripts beginning with the sent string instead of the received one.</p>
  </dd>

</dl>

<h3>Vgetty control methods</h3>
<p>There are miscellaneous methods for controllig <strong>vgetty</strong> and querying its status.</p>
<dl class='dl-vertical'>
  <dt>
    getty
  </dt>
  <dd>
    <p>Returns the name of the modem special file (e.g. <strong>/dev/ttyC4</strong>).</p>
  </dd>
  <dt>
    device($name)
  </dt>
  <dd>
    <p>Sets the port of the voice modem input and output is done to. Possible values are qw(\s-1NO_DEVICE\s0 \s-1DIALUP_LINE\s0 \s-1EXTERNAL_MICROPHONE\s0 \s-1INTERNAL_SPEAKER\s0 \s-1LOCAL_HANDSET\s0).</p>
  </dd>
  <dt>
    autostop($bool)
  </dt>
  <dd>
    <p>With autostop on, the voicelib will automatically abort a play in progress and return \s-1READY\s0. This is useful for faster reaction times for voice menus. Possible arguments are qw(\s-1ON\s0 \s-1OFF\s0). <strong>Note:</strong> The interface should probably be changed to accept the Perl boolean arguments (undef, something else). Returns defined value on success, undef on failure.</p>
  </dd>
  <dt>
    modem_type
  </dt>
  <dd>
    <p><strong>vgetty</strong> currently has no way of telling voice shell the type of the current modem. This method is a proposed interface for determining this type. Currently returns <strong>undef</strong>. The appropriate low-level interface has to be implemented in <strong>vgetty</strong> first.</p>
  </dd>

</dl>

<h3>Voice commands</h3>
<p>Sends a beep through the chosen device using given frequency (\s-1HZ\s0) and length (in miliseconds). Returns a defined value on success or undef on failure. The state of the vgetty changes to \*(L"\s-1BEEPING\s0\*(R" and <strong>vgetty</strong> returns \*(L"\s-1READY\s0\*(R" after a beep is finshed. Example:         $v-&gt;beep(50,10);         # Possibly do something else         $v-&gt;waitfor(&apos;READY&apos;);</p>
<dl class='dl-vertical'>
  <dt>
    dial($number)
  </dt>
  <dd>
    <p>Modem tries to dial a given number. The <strong>vgetty</strong> changes its state to \*(L"\s-1DIALING\s0\*(R" and returns \*(L"\s-1READY\s0\*(R" after the dialing is finished.</p>
  </dd>
  <dt>
    play($filename)
  </dt>
  <dd>
    <p>The <strong>vgetty</strong> tries to play the given file as a raw modem data. See the \*(L"Voice data\*(R" section for details on creating the raw modem data file. It changes the state to \*(L"\s-1PLAYING\s0\*(R" and returns \*(L"\s-1READY\s0\*(R" after playing the whole file.</p>
  </dd>
  <dt>
    record($filename)
  </dt>
  <dd>
    <p>The <strong>vgetty</strong> records the voice it can hear on the line to the given file. It uses the raw modem data format (which can be re-played using the <strong>play</strong> subroutine). <strong>vgetty</strong> changes its state to \*(L"\s-1RECORDING\s0\*(R" and you need to manually stop the recording using the <strong>stop</strong> method after some time (or, you can set <strong>autostop</strong> and wait for any event - silence, busy tone, etc).</p>
  </dd>
  <dt>
    wait($seconds)
  </dt>
  <dd>
    <p>The modem waits for a given number of seconds. Changes its state to \*(L"\s-1WAITING\s0\*(R" and returns \*(L"\s-1READY\s0\*(R" after the wait is finished. Example:         $v-&gt;<strong>wait</strong>(5);         $v-&gt;waitfor(&apos;READY&apos;);</p>
  </dd>
  <dt>
    stop
  </dt>
  <dd>
    <p>The <strong>vgetty</strong> stops anything it is currently doing and returns to the command state. You must use <strong>stop</strong> when you want to call another <strong>beep</strong>, <strong>dial</strong>, <strong>play</strong>, <strong>record</strong> or <strong>wait</strong> before the previous one is finished. The <strong>vgetty</strong> returns \*(L"\s-1READY\s0\*(R" after the <strong>stop</strong> is called. So it is possible to interrupt a main routine waiting for \*(L"\s-1READY\s0\*(R" from the event handler:         my $dtmf;         $v-&gt;add_handler(&apos;RECEIVED_DTMF&apos;, &apos;readnum&apos;,                 sub { my $self=shift; $self-&gt;stop; $dtmf = $_[2]; });         $v-&gt;enable_events;         $v-&gt;wait(10);         $v-&gt;waitfor(&apos;READY&apos;); In the previous example the <strong>waitfor</strong> method can be finished either by the 10-second timeout expired, or by the '\s-1READY\s0' generated by the <strong>stop</strong> in the event handler. See also the <strong>Events</strong> section.</p>
  </dd>
  <dt>
    play_and_wait($file)
  </dt>
  <dd>
    <p>It is an abbreviation for the following:         $v-&gt;play($file);         $v-&gt;waitfor(&apos;READY&apos;); It is repeated so much time in the voice applications so I have decided to make a special routine for it. I may add the similar routines for <strong>dial</strong>, <strong>record</strong>, <strong>beep</strong> and even <strong>wait</strong> in the future releases.</p>
  </dd>

</dl>

<h3>Event handler methods</h3>
<p>Installs a call-back routine $handler for the event type $event. The call-back routine is called with three arguments. The first one is the Modem::Vgetty object itself, the second one is the event name and the third one is optional event argument. The <strong></strong><strong>$handler_name</strong><strong></strong> argument can be anything. It is used when you want to delete this handler for identificating it. This method deletes the handler $handler_name for the $event event. The result of unregistering the handler from the event handler of the same event is unspecified. It may or may not be called.</p>
<dl class='dl-vertical'>
  <dt>
    enable_events
  </dt>
  <dd>
    <p>Tells the <strong>vgetty</strong> that the voice shell is willing to dispatch events. No events are sent by <strong>vgetty</strong> until this method is called.</p>
  </dd>
  <dt>
    disable_events
  </dt>
  <dd>
    <p>Tells the <strong>vgetty</strong> that the voice shell doesn't want to receive any events anymore.</p>
  </dd>

</dl>

<h3>The \fBreadnum\fP method</h3>
<p>The applications often need to read the multi-digit number via the \s-1DTMF\s0 tones.  This routine plays the <strong></strong><strong>$message</strong><strong></strong> to the voice object and then waits for the sequence of the \s-1DTMF\s0 keys finished by the `#' key. If no key is pressed for <strong></strong><strong>$tmout</strong><strong></strong> of seconds, it re-plays the message again. It returns failure if no key is pressed after the message is played <strong></strong><strong>$repeat</strong><strong></strong>-th time. It returns a string (a sequence of \s-1DTMF\s0 tones 0-9,A-D and `*') without the final `#'. When some \s-1DTMF\s0 tones are received and no terminating `#' or other tone is received for <strong></strong><strong>$tmout</strong><strong></strong> seconds, the routine returns the string it currently has without waiting for the final '#'. \s-1DTMF\s0 tones are accepted even at the time the <strong></strong><strong>$message</strong><strong></strong> is played. When the \s-1DTMF\s0 tone is received, the playing of the <strong></strong><strong>$message</strong><strong></strong> is (with some latency, of course) stopped. <strong>\s-1NOTE:\s0</strong> The interface of this routine can be changed in future releases, because I am not (yet) decided whether the current interface is the best one. See also the <strong>\s-1EXAMPLES\s0</strong> section where the source code of this routine (and its co-routine) is discussed.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EVENTS</h2>
        <div class="sectioncontent">
<h3>Introduction</h3>
<p>Events are asynchronous messages sent by <strong>vgetty</strong> to the voice shell. The <strong>Modem::Vgetty</strong> module dispatches events itself in the <strong>receive</strong> method. User can register any number of handlers for each event. When an event arrives, all handlers for that event are called (in no specified order).</p>
<h3>Event types</h3>
<p>At this time, the <strong>Modem::Vgetty</strong> module recognizes the following event types (description is mostly re-typed from the <strong>vgetty</strong> documentation):</p>
<dl class='dl-vertical'>
  <dt>
    \s-1BONG_TONE\s0
  </dt>
  <dd>
    <p>The modem detected a bong tone on the line.</p>
  </dd>
  <dt>
    \s-1BUSY_TONE\s0
  </dt>
  <dd>
    <p>The modem detected busy tone on the line (when dialing to the busy number or when caller finished the call).</p>
  </dd>
  <dt>
    \s-1CALL_WAITING\s0
  </dt>
  <dd>
    <p>Defined in \s-1IS-101\s0 (I think it is when the line receives another call-in when some call is already in progress. -Yenya).</p>
  </dd>
  <dt>
    \s-1DIAL_TONE\s0
  </dt>
  <dd>
    <p>The modem detected dial tone on the line.</p>
  </dd>
  <dt>
    \s-1DATA_CALLING_TONE\s0
  </dt>
  <dd>
    <p>The modem detected data calling tone on the line.</p>
  </dd>
  <dt>
    \s-1DATA_OR_FAX_DETECTED\s0
  </dt>
  <dd>
    <p>The modem detected data or fax calling tones on the line.</p>
  </dd>
  <dt>
    \s-1FAX_CALLING_TONE\s0
  </dt>
  <dd>
    <p>The modem detected fax calling tone on the line.</p>
  </dd>
  <dt>
    \s-1HANDSET_ON_HOOK\s0
  </dt>
  <dd>
    <p>Locally connected handset went on hook.</p>
  </dd>
  <dt>
    \s-1HANDSET_OFF_HOOK\s0
  </dt>
  <dd>
    <p>Locally connected handset went off hook.</p>
  </dd>
  <dt>
    \s-1LOOP_BREAK\s0
  </dt>
  <dd>
    <p>Defined in \s-1IS-101\s0.</p>
  </dd>
  <dt>
    \s-1LOOP_POLARITY_CHANGE\s0
  </dt>
  <dd>
    <p>Defined in \s-1IS-101\s0.</p>
  </dd>
  <dt>
    \s-1NO_ANSWER\s0
  </dt>
  <dd>
    <p>After dialing the modem didn't detect answer for the time give in dial_timeout in voice.conf.</p>
  </dd>
  <dt>
    \s-1NO_DIAL_TONE\s0
  </dt>
  <dd>
    <p>The modem didn't detect dial tone (make sure your modem is connected properly to your telephone company's line, or check the \s-1ATX\s0 command if dial tone in your system differs from the standard).</p>
  </dd>
  <dt>
    \s-1NO_VOICE_ENERGY\s0
  </dt>
  <dd>
    <p>It means that the modem detected voice energy at the beginning of the session, but after that there was a period of some time of silence (the actual time can be set using the <strong>rec_silence_len</strong> and <strong>rec_silence_treshold</strong> parameters in <strong>voice.conf</strong>).</p>
  </dd>
  <dt>
    \s-1RING_DETECTED\s0
  </dt>
  <dd>
    <p>The modem detected an incoming ring.</p>
  </dd>
  <dt>
    \s-1RINGBACK_DETECTED\s0
  </dt>
  <dd>
    <p>The modem detected a ringback condition on the line.</p>
  </dd>
  <dt>
    \s-1RECEIVE_DTMF\s0
  </dt>
  <dd>
    <p>The modem detected a dtmf code. The actual code value (one of 0-9, *, #, A-D) is given to the event handler as the third argument.</p>
  </dd>
  <dt>
    \s-1SILENCE_DETECTED\s0
  </dt>
  <dd>
    <p>The modem detected that there was no voice energy at the beginning of the session and after some time of silence (the actual time can be set using the <strong>rec_silence_len</strong> and <strong>rec_silence_treshold</strong> parameters in <strong>voice.conf</strong>).</p>
  </dd>
  <dt>
    \s-1SIT_TONE\s0
  </dt>
  <dd>
    <p>Defined in \s-1IS-101\s0.</p>
  </dd>
  <dt>
    \s-1TDD_DETECTED\s0
  </dt>
  <dd>
    <p>Defined in \s-1IS-101\s0.</p>
  </dd>
  <dt>
    \s-1VOICE_DETECTED\s0
  </dt>
  <dd>
    <p>The modem detected a voice signal on the line. \s-1IS-101\s0 does not define, how the modem makes this decision, so be careful.</p>
  </dd>
  <dt>
    \s-1UNKNOWN_EVENT\s0
  </dt>
  <dd>
    <p>None of the above :)</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VOICE DATA</h2>
        <div class="sectioncontent">
<p>Voice shell can send the voice data to the modem using the <strong>play</strong> method and record them using the <strong>record</strong> method. The \*(L".rmd\*(R" extension (Raw Modem Data) is usually used for these files. The \*(L".rmd\*(R" is not a single format - every modem has its own format (sampling frequency, data bit depth, etc). There is a <strong>pvftools</strong> package for converting the sound files (it is a set of filters similar to the <strong>netpbm</strong> for image files). The <strong></strong><strong>pvftormd</strong><strong>\|(1)</strong> filter can be used to create the \s-1RMD\s0 files for all known types of modems.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<h3>Answering machine</h3>
<p>A simple answering machine can look like this:</p><p>        #!/usr/bin/perl         use Modem::Vgetty;         my $voicemaster = &apos;root@localhost&apos;;         my $tmout = 30;         my $finish = 0;         my $v = new Modem::Vgetty;         $v-&gt;add_handler(&apos;BUSY_TONE&apos;, &apos;finish&apos;,                 sub { $v-&gt;stop; $finish=1; });         $v-&gt;add_handler(&apos;SILENCE_DETECTED&apos;, &apos;finish&apos;,                 sub { $v-&gt;stop; $finish=1; });         local $SIG{ALRM} = sub { $v-&gt;stop; };         $v-&gt;enable_events;         $v-&gt;play_and_wait(&apos;/path/welcome.rmd&apos;);         $v-&gt;beep(100,10);         $v-&gt;waitfor(&apos;READY&apos;);         if ($finish == 0) {                 my $num = 0;                 $num++ while(-r "/path/$num.rmd");                 $v-&gt;record("/path/$num.rmd");                 alarm $tmout;                 $v-&gt;waitfor(&apos;READY&apos;);         }         system "echo &apos;Play with rmdtopvf /path/$num.rmd|pvftoau &gt;/dev/audio&apos;" .                  " | mail -s &apos;New voice message&apos; $voicemaster";         exit 0;</p><p>See the <strong>examples/answering_machine.pl</strong> in the source distribution, which contains a more configurable version of the above text. It first sets the event handlers for the case of busy tone (the caller hangs up) or silence (the caller doesn't speak at all). The handler stops <strong>vgetty</strong> from anything it is currently doing and sets the $finish variable to 1. Then the reception of the events is enabled and the welcome message is played. Then the answering machine beeps and starts to record the message. Note that we need to check the $finish variable before we start recording to determine if user hanged up the phone. Now we find the first filename &lt;number&gt;.rmd such that this file does not exist and we start to record the message to this file. We record until user hangs up the phone or until the timeout occurs.</p>
<h3>Readnum routine</h3>
<p>An interesting application of the low-level routines is the <strong>Voice::Modem::readnum</strong> method. The calling sequence of this method has been discussed above. The source code for this routine and its co-routine will be discussed here, so that you can write your own variants of <strong>readnum</strong> (which in fact does not have too general interface). See also the source code of <strong>Vgetty.pm</strong> for the <strong>readnum</strong> source.</p><p>The <strong>readnum</strong> routine needs to have its own event handler for the <strong>\s-1RECEIVED_DTMF\s0</strong> event and the way the handler can communicate with this routine. In our solution we use \*(L"static\*(R" variables:</p><p>        my $_readnum_number = &apos;&apos;;         my $_readnum_timeout = 10;         my $_readnum_in_timeout = 1;</p><p>The event handler will add the new character to the end of the <strong></strong><strong>$_readnum_number</strong><strong></strong> variable. The <strong></strong><strong>$_readnum_timeout</strong><strong></strong> is the number of seconds both <strong>readnum</strong> and the event handler should wait for the next keypress, and the <strong></strong><strong>$_readnum_in_timeout</strong><strong></strong> is a flag used by the event handler for notifying the main <strong>readnum</strong> routine that it forced the <strong>vgetty</strong> to emit the `\s-1READY\s0' message because of the final `#' has been received.</p><p>        sub _readnum_event {                 my $self = shift;                 my $input = shift; # Unused. Should be &apos;RECEIVED_DTMF&apos;.                 my $dtmf = shift;</p><p>                if ($dtmf eq &apos;#&apos;) { # Stop the reading now.                         $_readnum_in_timeout = 0;                         $self-&gt;stop;                         $self-&gt;{LOG}-&gt;print("_readnum_event(): Got #; stopping&#92;n");                         return;                 }                 $_readnum_number .= $dtmf;                 $self-&gt;stop;                 $self-&gt;expect(&apos;READY&apos;);                 # Restart the wait again.                 $_readnum_in_timeout = 1;                 $self-&gt;wait($_readnum_timeout);         }</p><p>The event handler is installed for the `\s-1RECEIVED_DTMF\s0' event only, so it doesn't need to check for the <strong></strong><strong>$input</strong><strong></strong> value. The actual \s-1DTMF\s0 key is in the third parameter, <strong></strong><strong>$dtmf</strong><strong></strong>. Note that the handler will be called when <strong>vgetty</strong> is \s-1PLAYING\s0 or \s-1WAITING\s0 and the <strong>readnum</strong> routine will be waiting for the `\s-1READY\s0' message. This allows us to immediately interrupt waiting by the <strong></strong><strong>$self</strong><strong>-</strong>stop&gt; (which emits the `\s-1READY\s0' message). So when the `#' \s-1DTMF\s0 tone is received, we send a <strong>stop</strong> to <strong>vgetty</strong>. If something else is received, we <strong>stop</strong> the <strong>vgetty</strong> too but we enter a new wait using <strong></strong><strong>$self</strong><strong>-</strong>wait&gt;.</p><p>        sub readnum {                 my $self = shift;                 my $message = shift;                 my $timeout = shift;                 my $times = shift;                 $_readnum_number = &apos;&apos;;                 $_readnum_in_timeout = 1;                 $_readnum_timeout = $timeout if $timeout != 0;                 $times = 3 if $times == 0;</p><p>                # Install the handler.                 $self-&gt;add_handler(&apos;RECEIVED_DTMF&apos;, &apos;readnum&apos;, &#92;&_readnum_event);                 while($_readnum_in_timeout != 0 && $_readnum_number eq &apos;&apos;                         && $times-- &gt; 0) {                         $self-&gt;play_and_wait($message);                         last if $_readnum_in_timeout == 0;                         while ($_readnum_in_timeout != 0) {                                 $self-&gt;wait($_readnum_timeout);                                 $self-&gt;expect(&apos;READY&apos;);                         }                 }                 return undef if $times &lt; 0;                 $self-&gt;del_handler(&apos;RECEIVED_DTMF&apos;, &apos;readnum&apos;);                 $self-&gt;stop;                 $self-&gt;expect(&apos;READY&apos;);                 $_readnum_number;         }</p><p>The <strong>readnum</strong> routine just sets up the event handler, then plays the <strong></strong><strong>$message</strong><strong></strong> and waits for the input (possibly several times). The main work is done in the event handler. At the end the handler is unregistered and the final value is returned.</p>
<h3>Callme script</h3>
<p>In the <strong>examples</strong> subdirectory of the source distribution there is a <strong>callme.pl</strong> script. This dials the given number and plays the given message. Use the following command to run it:</p><p>        vm shell -S /usr/bin/perl callme.pl &lt;number&gt; &lt;message&gt;.rmd</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>There may be some, but it will more likely be in the <strong>vgetty</strong> itself. On the other hand, there can be typos in this manual (English is not my native language) or some parts of the interface that should be redesigned. Feel free to mail any comments on this module to me.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Modem type recognition
  </dt>
  <dd>
    <p>The <strong>vgetty</strong> should be able to tell the voice shell the name of the current modem type.</p>
  </dd>
  <dt>
    The <em>_wait()</em> routines
  </dt>
  <dd>
    <p>I need to implement the routines similar to <strong>play_and_wait</strong> for other <strong>vgetty</strong> states as well.</p>
  </dd>
  <dt>
    Debugging information
  </dt>
  <dd>
    <p>The module has currently some support for writing a debug logs (use the $Modem::Vgetty::testing = 1 and watch the /var/log/voicelog file). This needs to be re-done using (I think) Sys::Syslog. I need to implement some kind of log-levels, etc.</p>
  </dd>
  <dt>
    Mgetty/Vgetty 1.1.17
  </dt>
  <dd>
    <p>Need to figure out what is new in 1.1.17 (I use 1.1.14 now). I think new <strong>vgetty</strong> can play more than one file in the single `\s-1PLAY\s0' command, it (I think) have some support for sending voice data from/to the voice shell via the pipe, etc.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>The <strong>Modem::Vgetty</strong> package was written by Jan \*(L"Yenya\*(R" Kasprzak &lt;kas@fi.muni.cz&gt;. Feel free to mail me any suggestions etc. on this module. Module itself is available from \s-1CPAN\s0, but be sure to check the following address, where the development versions can be found:</p><p>        http://www.fi.muni.cz/~kas/vgetty/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 1998 Jan \*(L"Yenya\*(R" Kasprzak &lt;kas@fi.muni.cz&gt;. All rights reserved. This package is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Method::Autoload.3pm.html"><span aria-hidden="true">&larr;</span> Method::Autoload.3pm: Autoloads methods from a list of packages into the current package</a></li>
   <li class="next"><a href="Module::Build::CipUX.3pm.html">Module::Build::CipUX.3pm: Extension for building cipux <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ost_String: This is a generic and portable string class.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="This is a generic and portable string class.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ost_String (3) manual">
  <meta name="twitter:description" content="This is a generic and portable string class.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_String-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/ost_String.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ost_String (3) manual" />
  <meta property="og:description" content="This is a generic and portable string class." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_String-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ost_String<small> (3)</small></h1>
        <p class="lead">This is a generic and portable string class.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_String.3.html">
      <span itemprop="name">ost_String: This is a generic and portable string class.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcommoncpp2-doc/">
      <span itemprop="name">libcommoncpp2-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_String.3.html">
      <span itemprop="name">ost_String: This is a generic and portable string class.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;string.h&gt;</p><p>Inherited by <strong>ost::SString</strong>.</p><h3>Public Types</h3>
<p>typedef size_t <strong>size_type</strong></p>
<h3>Public Member Functions</h3>
<p><strong>String</strong> ()</p><p><em>Construct an empty string. </em> <strong>String</strong> (const <strong>String</strong> &original)</p><p><em>Copy constructor. </em> <strong>String</strong> (const char *str)</p><p><em>Create a string from a cstring. </em> <strong>String</strong> (std::string string)</p><p><em>Create a </em><strong>String</strong><em> from std::string. </em><strong></strong> <strong>String</strong> (const <strong>String</strong> &str, size_t offset, size_t len=<strong>npos</strong>)</p><p><em>Create a new string from a subset of another string. </em> <strong>String</strong> (size_t <strong>size</strong>, const char *format,...)</p><p><em>Create a string from formatted text input. </em> <strong>String</strong> (size_t <strong>count</strong>, const char fill= ' ')</p><p><em>Fill a new string with character data. </em> virtual <strong>~String</strong> ()</p><p><em>Destroy the string... </em> const char * <strong>getIndex</strong> (size_t <strong>index</strong>) const </p><p><em>Get a string pointer to string content based on an indexed offset. </em> char * <strong>getText</strong> (void) const </p><p><em>Get the text of a string. </em> long <strong>getValue</strong> (long defvalue=0l) const </p><p><em>Get the value of a string. </em> bool <strong>getBool</strong> (bool defbool=false) const </p><p><em>Get the bool flag of a string. </em> const size_t <strong>getLength</strong> (void) const </p><p><em>Get the assigned length of string. </em> const size_t <strong>getSize</strong> (void) const </p><p><em>Get the allocation size of the string variable. </em> bool <strong>isEmpty</strong> (void) const </p><p><em>Return true if string is empty. </em> void <strong>resize</strong> (size_t <strong>size</strong>)</p><p><em>Re-allocate buffer space for string. </em> void <strong>clear</strong> (void)</p><p><em>Clear the contents of the entire string. </em> char <strong>at</strong> (ssize_t offset) const </p><p><em>Return a character at a known offset. </em> unsigned <strong>count</strong> (const <strong>String</strong> &s, size_t offset=0) const </p><p><em>Count the number of occurences of a specific string within our string. </em> unsigned <strong>count</strong> (const char *s, size_t offset=0, size_t len=0) const </p><p><em>Count the number of occurrences of a specific text pattern within our string. </em> <strong>String</strong> <strong>token</strong> (const char *delim=' &#92;t&#92;n&#92;r', size_t offset=0)</p><p><em>Extract a new string as a token from the current string. </em> size_t <strong>find</strong> (const <strong>String</strong> &s, size_t offset=0, unsigned instance=1) const </p><p><em>Find the index to the nth instance of a substring in our string. </em> size_t <strong>rfind</strong> (const <strong>String</strong> &s, size_t offset=0) const </p><p><em>Find last occurence of a substring in our string. </em> size_t <strong>find</strong> (const char *s, size_t offset=0, size_t len=0, unsigned <strong>count</strong>=1) const </p><p><em>Find the index to the nth instance of text in our string. </em> size_t <strong>rfind</strong> (const char *s, size_t offset=0, size_t len=0) const </p><p><em>Find last occurence of a text in our string. </em> void <strong>trim</strong> (const char *cs)</p><p><em>Trim trailing characters from a string. </em> void <strong>chop</strong> (const char *cs)</p><p><em>Chop leading characters from a string. </em> void <strong>strip</strong> (const char *cs)</p><p><em>Strip lead and trailing characters from a string. </em> void <strong>chop</strong> (size_t chars)</p><p><em>Chop n leading characters from a string. </em> void <strong>trim</strong> (size_t <strong>count</strong>)</p><p><em>Trim n trailing characters from a string. </em> void <strong>erase</strong> (size_t start, size_t len=<strong>npos</strong>)</p><p><em>Erase a portion of string. </em> void <strong>insert</strong> (size_t start, const char *<strong>text</strong>, size_t len=0)</p><p><em>Insert text into a string. </em> void <strong>insert</strong> (size_t start, const <strong>String</strong> &str)</p><p><em>Insert other string into our string. </em> void <strong>replace</strong> (size_t start, size_t len, const char *<strong>text</strong>, size_t <strong>count</strong>=0)</p><p><em>Replace text at a specific position in the string with new text. </em> void <strong>replace</strong> (size_t start, size_t len, const <strong>String</strong> &string)</p><p><em>Replace text at a specific position in the string with new string,. </em> size_t <strong>find</strong> (unsigned instance, const char *<strong>text</strong>, size_t offset=0, size_t len=0) const </p><p><em>A more convenient version of find for nth occurences, by putting the instance first. </em> size_t <strong>find</strong> (unsigned instance, const <strong>String</strong> &string, size_t offset=0) const </p><p><em>A more convenient version of find for nth occurences, by putting the instance first. </em> <strong>String</strong> <strong>substr</strong> (size_t start, size_t len) const </p><p><em>Return a new string that contains a specific substring of the current string. </em> const char *() <strong>index</strong> (size_t ind) const </p><p><em>Return an indexed string based on the index, such as from a find. </em> void <strong>compact</strong> (void)</p><p><em>Reduce the size of the string allocation to the minimum needed based on the current effective length. </em> char * <strong>c_str</strong> (void) const </p><p><em>Old ANSI C++ compatible string pointer extraction. </em> <strong>operator char *</strong> () const </p><p><em>Get our string data through dereference operator. </em> bool <strong>operator!</strong> (void) const </p><p><em>Logical test for string empty. </em> char * <strong>text</strong> (void) const </p><p><em>Alternate get text method. </em> char * <strong>data</strong> (void) const </p><p><em>Alternate get text method. </em> size_t <strong>length</strong> (void) const </p><p><em>Get length as if null terminated string. </em> size_t <strong>size</strong> (void) const </p><p><em>Get actual length of string data. </em> size_t <strong>capacity</strong> (void) const </p><p><em>Get space allocated to hold current string. </em> bool <strong>empty</strong> (void) const </p><p><em>Return true if string is empty. </em> void <strong>append</strong> (const char *str, size_t <strong>count</strong>=0)</p><p><em>Append text to the end of the current string. </em> void <strong>append</strong> (size_t <strong>size</strong>, const char *format,...)</p><p><em>Append formatted text to the end of the current string. </em> void <strong>append</strong> (const char *str, size_t offset, size_t <strong>count</strong>)</p><p><em>Append text into the current string. </em> void <strong>add</strong> (char c)</p><p><em>Add a character to the end of a string. </em> void <strong>append</strong> (const <strong>String</strong> &str)</p><p><em>Append string to the end of the current string. </em> const char <strong>operator[]</strong> (unsigned ind) const </p><p><em>Extract a character by array indexing. </em> const char * <strong>operator=</strong> (const char *str)</p><p><em>Assign our string for c string. </em> <strong>String</strong> & <strong>operator+=</strong> (const <strong>String</strong> &str)</p><p><em>Append operator. </em> <strong>String</strong> & <strong>operator+=</strong> (char c)</p><p><em>Append operator. </em> <strong>String</strong> & <strong>operator+=</strong> (const char *str)</p><p><em>Append operator. </em> <strong>String</strong> & <strong>operator+=</strong> (const std::string &str)</p><p><em>Append operator. </em> bool <strong>operator&lt;</strong> (const <strong>String</strong> &str) const </p><p>bool <strong>operator&lt;</strong> (const char *str) const </p><p>bool <strong>operator&gt;</strong> (const <strong>String</strong> &str) const </p><p>bool <strong>operator&gt;</strong> (const char *str) const </p><p>bool <strong>operator&lt;=</strong> (const <strong>String</strong> &str) const </p><p>bool <strong>operator&lt;=</strong> (const char *str) const </p><p>bool <strong>operator&gt;=</strong> (const <strong>String</strong> &str) const </p><p>bool <strong>operator&gt;=</strong> (const char *str) const </p><p>bool <strong>operator==</strong> (const <strong>String</strong> &str) const </p><p>bool <strong>operator==</strong> (const char *str) const </p><p>bool <strong>operator!=</strong> (const <strong>String</strong> &str) const </p><p>bool <strong>operator!=</strong> (const char *str) const </p><p><strong>String</strong> & <strong>operator+=</strong> (int i)</p><p><em>Append operator. </em> <strong>String</strong> & <strong>operator+=</strong> (unsigned int i)</p><p><strong>String</strong> & <strong>operator+=</strong> (long l)</p><p><strong>String</strong> & <strong>operator+=</strong> (unsigned long l)</p><p><strong>String</strong> & <strong>operator+=</strong> (float f)</p><p><strong>String</strong> & <strong>operator+=</strong> (double d)</p><p><strong>String</strong> & <strong>operator+=</strong> (short s)</p><p><strong>String</strong> & <strong>operator+=</strong> (unsigned short s)</p><p><strong>String</strong> & <strong>operator=</strong> (int i)</p><p><em>Assignment operator. </em> <strong>String</strong> & <strong>operator=</strong> (unsigned int i)</p><p><strong>String</strong> & <strong>operator=</strong> (long l)</p><p><strong>String</strong> & <strong>operator=</strong> (unsigned long l)</p><p><strong>String</strong> & <strong>operator=</strong> (float f)</p><p><strong>String</strong> & <strong>operator=</strong> (double d)</p><p><strong>String</strong> & <strong>operator=</strong> (short s)</p><p><strong>String</strong> & <strong>operator=</strong> (unsigned short s)</p><p><strong>String</strong> & <strong>operator=</strong> (const <strong>String</strong> &original)</p><p>bool <strong>operator*=</strong> (const <strong>String</strong> &str) const </p><p><em>Test if string is contained in our string. </em> bool <strong>operator*=</strong> (const char *str) const </p><p><em>Test if text is contained in our string. </em></p>
<h3>Static Public Attributes</h3>
<p>static const size_t <strong>npos</strong></p>
<h3>Protected Member Functions</h3>
<p>bool <strong>isBig</strong> (void) const </p><p><em>Determine if string is allocated in local variable or an external reference. </em> const char * <strong>set</strong> (const char *str, size_t len=0)</p><p><em>Set the content of the string variable to the specified string value, and use smart re-allocation strategies if appropriate to shrink the size of the variable. </em> void <strong>set</strong> (const <strong>String</strong> &str)</p><p><em>Set the content of the string variable to that of another variable. </em> const char * <strong>set</strong> (size_t <strong>size</strong>, const char *format,...)</p><p><em>Set the content of the string variable to that of a formatted printf style string. </em> void <strong>copy</strong> (const <strong>String</strong> &str)</p><p><em>Impliment the copy constructor, used internally. </em> void <strong>init</strong> (void)</p><p><em>Used to initialize a string object. </em> size_t <strong>setSize</strong> (size_t <strong>size</strong>)</p><p><em>Set the size of allocated space in the string variable (capacity) to a known value. </em> void <strong>setLength</strong> (size_t len)</p><p><em>Set the length value of the string content. </em> virtual int <strong>compare</strong> (const char *<strong>text</strong>, size_t len=0, size_t <strong>index</strong>=0) const </p><p><em>A derivable low level comparison operator. </em> size_t <strong>search</strong> (const char *<strong>text</strong>, size_t clen=0, size_t offset=0) const </p><p><em>An internal method used to search for a substring starting at a known offset. </em></p>
<h3>Static Protected Member Functions</h3>
<p>static char * <strong>getSpace</strong> (size_t <strong>size</strong>)</p><p><em>Used to fetch memory, if needed, based on the size, from the pager, or the system heap. </em></p>
<h3>Static Protected Attributes</h3>
<p>static const unsigned <strong>minsize</strong></p><p>static const unsigned <strong>slotsize</strong></p><p>static const unsigned <strong>pagesize</strong></p><p>static const unsigned <strong>slotlimit</strong></p><p>static const unsigned <strong>slotcount</strong></p>
<h3>Friends</h3>
<p>class <strong>StringObject</strong></p><p>class <strong>MemPager</strong></p><p><strong>__EXPORT</strong> <strong>String</strong> <strong>operator+</strong> (const <strong>String</strong> &s1, const <strong>String</strong> &s2)</p><p><em>Add two strings and return a temporary object. </em> <strong>__EXPORT</strong> <strong>String</strong> <strong>operator+</strong> (const <strong>String</strong> &s1, const char *s2)</p><p><strong>__EXPORT</strong> <strong>String</strong> <strong>operator+</strong> (const char *s1, const <strong>String</strong> &s2)</p><p><strong>__EXPORT</strong> <strong>String</strong> <strong>operator+</strong> (const <strong>String</strong> &s1, const char c2)</p><p><strong>__EXPORT</strong> <strong>String</strong> <strong>operator+</strong> (const char c1, const <strong>String</strong> &s2)</p><p><strong>__EXPORT</strong> std::istream & <strong>getline</strong> (std::istream &is, <strong>String</strong> &str, char delim= '&#92;n', size_t <strong>size</strong>=0)</p><p><em>Fetch input from a std::istream into the current string variable until either the string variable is filled (based on current length) or the deliminator is read. </em> <strong>__EXPORT</strong> std::ostream & <strong>operator&lt;&lt;</strong> (std::ostream &os, const <strong>String</strong> &str)</p><p><em>Stream the content of our string variable directly to a C++ streaming source. </em> std::istream & <strong>operator&gt;&gt;</strong> (std::istream &is, <strong>String</strong> &str)</p><p><em>Stream input into our variable. </em> <strong>__EXPORT</strong> int <strong>strprintf</strong> (<strong>String</strong> &str, size_t <strong>size</strong>, const char *format,...)</p><p><em>Print values directly into a string variable. </em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>This is a generic and portable string class.</p><p>It uses optimized memory allocation strategies to efficiently handle smaller string content by grouping strings into 32 byte aligned slots that can be re-allocated from a free list directly.</p><p>While meant to cover the basic functionality of the ANSI C++ string class in form and function, this class offers some important enhancements, including the ability to derive class type specific versions of itself. The latter might be used to derive a unicode string, a string for data and time data types, or to add case insensitive comparisons, for example.</p><p><strong>Author:</strong></p><p>David Sugar dyfet@ostel.com Generic string class.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>typedef size_t \fBost::String::size_type\fP</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>ost::String::String ()</h3>
<p>Construct an empty string.</p>
<h3>ost::String::String (const \fBString\fP &original)</h3>
<p>Copy constructor.</p><p><strong>Parameters:</strong></p><p><em>original</em> string to copy from.</p>
<h3>ost::String::String (const char *str)</h3>
<p>Create a string from a cstring.</p><p><strong>Parameters:</strong></p><p><em>str</em> text to set with.</p>
<h3>ost::String::String (std::stringstring)</h3>
<p>Create a <strong>String</strong> from std::string.</p><p><strong>Parameters:</strong></p><p><em>string</em> from std::string to copy from.</p>
<h3>ost::String::String (const \fBString\fP &str, size_toffset, size_tlen = \fC\fBnpos\fP\fP)</h3>
<p>Create a new string from a subset of another string.</p><p><strong>Parameters:</strong></p><p><em>str</em> reference of source string.</p><p><em>offset</em> offset to start of data in prior string.</p><p><em>len</em> length of our substring.</p>
<h3>ost::String::String (size_tsize, const char *format, ...)</h3>
<p>Create a string from formatted text input.</p><p><strong>Parameters:</strong></p><p><em>size</em> to allocate for our new string.</p><p><em>format</em> of data to input.</p>
<h3>ost::String::String (size_tcount, const charfill = \fC' '\fP)</h3>
<p>Fill a new string with character data.</p><p><strong>Parameters:</strong></p><p><em>count</em> size of new string.</p><p><em>fill</em> char to fill string with.</p>
<h3>virtual ost::String::~String ()\fC [virtual]\fP</h3>
<p>Destroy the string...</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void ost::String::add (charc)</h3>
<p>Add a character to the end of a string.</p><p><strong>Parameters:</strong></p><p><em>c</em> char to add.</p>
<h3>void ost::String::append (const char *str, size_tcount = \fC0\fP)</h3>
<p>Append text to the end of the current string.</p><p><strong>Parameters:</strong></p><p><em>str</em> text to append.</p><p><em>count</em> size of text to append.</p>
<h3>void ost::String::append (size_tsize, const char *format, ...)</h3>
<p>Append formatted text to the end of the current string.</p><p><strong>Parameters:</strong></p><p><em>size</em> size of text to append.</p><p><em>format</em> of data to append.</p>
<h3>void ost::String::append (const char *str, size_toffset, size_tcount)</h3>
<p>Append text into the current string.</p><p><strong>Parameters:</strong></p><p><em>str</em> text to append.</p><p><em>offset</em> offset to overlay.</p><p><em>count</em> size of text to append.</p>
<h3>void ost::String::append (const \fBString\fP &str)</h3>
<p>Append string to the end of the current string.</p><p><strong>Parameters:</strong></p><p><em>str</em> string to append.</p>
<h3>char ost::String::at (ssize_toffset) const</h3>
<p>Return a character at a known offset.</p><p><strong>Returns:</strong></p><p>character at offset.</p>
<h3>char* ost::String::c_str (void) const\fC [inline]\fP</h3>
<p>Old ANSI C++ compatible string pointer extraction.</p><p><strong>Returns:</strong></p><p>string data.</p>
<h3>size_t ost::String::capacity (void) const\fC [inline]\fP</h3>
<p>Get space allocated to hold current string.</p><p><strong>Returns:</strong></p><p>space of memory buffer from heap or local.</p>
<h3>void ost::String::chop (const char *cs)\fC [inline]\fP</h3>
<p>Chop leading characters from a string.</p><p><strong>Parameters:</strong></p><p><em>cs</em> list of chars to chop.</p><p>References ost::strchop().</p>
<h3>void ost::String::chop (size_tchars)\fC [inline]\fP</h3>
<p>Chop n leading characters from a string.</p><p><strong>Parameters:</strong></p><p><em>chars</em> count to chop.</p>
<h3>void ost::String::clear (void)</h3>
<p>Clear the contents of the entire string.</p>
<h3>void ost::String::compact (void)\fC [inline]\fP</h3>
<p>Reduce the size of the string allocation to the minimum needed based on the current effective length.</p>
<h3>virtual int ost::String::compare (const char *text, size_tlen = \fC0\fP, size_tindex = \fC0\fP) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>A derivable low level comparison operator. This can be used to create custom comparison data types in derived string classes.</p><p><strong>Returns:</strong></p><p>0 if match, or value for ordering.</p><p><strong>Parameters:</strong></p><p><em>text</em> text to compare.</p><p><em>len</em> length of text to compare.</p><p><em>index</em> offset from start of string, used in searchs.</p>
<h3>void ost::String::copy (const \fBString\fP &str)\fC [protected]\fP</h3>
<p>Impliment the copy constructor, used internally. Will always create a minimum sized string allocation.</p><p><strong>Parameters:</strong></p><p><em>str</em> string to copy from.</p>
<h3>unsigned ost::String::count (const \fBString\fP &s, size_toffset = \fC0\fP) const</h3>
<p>Count the number of occurences of a specific string within our string.</p><p><strong>Returns:</strong></p><p>count of instances.</p><p><strong>Parameters:</strong></p><p><em>s</em> string to test.</p><p><em>offset</em> offset to start from.</p>
<h3>unsigned ost::String::count (const char *s, size_toffset = \fC0\fP, size_tlen = \fC0\fP) const</h3>
<p>Count the number of occurrences of a specific text pattern within our string.</p><p><strong>Returns:</strong></p><p>count of instances.</p><p><strong>Parameters:</strong></p><p><em>s</em> text pattern to find</p><p><em>offset</em> offset to start from.</p><p><em>len</em> length of text pattern if specified.</p>
<h3>char* ost::String::data (void) const\fC [inline]\fP</h3>
<p>Alternate get text method.</p><p><strong>Returns:</strong></p><p>string data.</p>
<h3>bool ost::String::empty (void) const\fC [inline]\fP</h3>
<p>Return true if string is empty.</p>
<h3>void ost::String::erase (size_tstart, size_tlen = \fC\fBnpos\fP\fP)</h3>
<p>Erase a portion of string.</p><p><strong>Parameters:</strong></p><p><em>start</em> starting index to erase from.</p><p><em>len</em> number of characters to erase.</p>
<h3>size_t ost::String::find (const \fBString\fP &s, size_toffset = \fC0\fP, unsignedinstance = \fC1\fP) const</h3>
<p>Find the index to the nth instance of a substring in our string.</p><p><strong>Returns:</strong></p><p>index of found substring.</p><p><strong>Parameters:</strong></p><p><em>s</em> string to search for.</p><p><em>offset</em> offset to start at.</p><p><em>instance</em> instance to look for.</p>
<h3>size_t ost::String::find (const char *s, size_toffset = \fC0\fP, size_tlen = \fC0\fP, unsignedcount = \fC1\fP) const</h3>
<p>Find the index to the nth instance of text in our string.</p><p><strong>Returns:</strong></p><p>index of found substring.</p><p><strong>Parameters:</strong></p><p><em>s</em> string to search for.</p><p><em>offset</em> offset to start at.</p><p><em>len</em> size of string text.</p><p><em>count</em> instance to look for.</p>
<h3>size_t ost::String::find (unsignedinstance, const char *text, size_toffset = \fC0\fP, size_tlen = \fC0\fP) const\fC [inline]\fP</h3>
<p>A more convenient version of find for nth occurences, by putting the instance first.</p><p><strong>Parameters:</strong></p><p><em>instance</em> nth instance to look for.</p><p><em>text</em> text to look for.</p><p><em>offset</em> offset to start at.</p><p><em>len</em> length of text.</p><p>References ost::find().</p>
<h3>size_t ost::String::find (unsignedinstance, const \fBString\fP &string, size_toffset = \fC0\fP) const\fC [inline]\fP</h3>
<p>A more convenient version of find for nth occurences, by putting the instance first.</p><p><strong>Parameters:</strong></p><p><em>instance</em> nth instance to look for.</p><p><em>string</em> reference to look for.</p><p><em>offset</em> offset to start at.</p><p>References ost::find().</p>
<h3>bool ost::String::getBool (booldefbool = \fCfalse\fP) const</h3>
<p>Get the bool flag of a string.</p><p><strong>Returns:</strong></p><p>boolean value.</p>
<h3>const char* ost::String::getIndex (size_tindex) const</h3>
<p>Get a string pointer to string content based on an indexed offset. A NULL is returned if the index is outsize of range.</p><p><strong>Returns:</strong></p><p>string content or NULL if invalid index.</p><p><strong>Parameters:</strong></p><p><em>index</em></p>
<h3>const size_t ost::String::getLength (void) const</h3>
<p>Get the assigned length of string.</p><p><strong>Returns:</strong></p><p>string length.</p>
<h3>const size_t ost::String::getSize (void) const</h3>
<p>Get the allocation size of the string variable.</p><p><strong>Returns:</strong></p><p>allocation size.</p>
<h3>static char* ost::String::getSpace (size_tsize)\fC [static]\fP, \fC [protected]\fP</h3>
<p>Used to fetch memory, if needed, based on the size, from the pager, or the system heap.</p><p><strong>Returns:</strong></p><p>string pointer to space.</p><p><strong>Parameters:</strong></p><p><em>size</em> of space needed.</p>
<h3>char* ost::String::getText (void) const</h3>
<p>Get the text of a string.</p><p><strong>Returns:</strong></p><p>string content.</p>
<h3>long ost::String::getValue (longdefvalue = \fC0l\fP) const</h3>
<p>Get the value of a string.</p><p><strong>Returns:</strong></p><p>string value as number.</p>
<h3>const char*() ost::String::index (size_tind) const\fC [inline]\fP</h3>
<p>Return an indexed string based on the index, such as from a find. If out of range, a NULL string is returned.</p><p><strong>Returns:</strong></p><p>pointer to string data from our string,</p><p><strong>Parameters:</strong></p><p><em>ind</em> index or offset to use.</p>
<h3>void ost::String::init (void)\fC [protected]\fP</h3>
<p>Used to initialize a string object.</p>
<h3>void ost::String::insert (size_tstart, const char *text, size_tlen = \fC0\fP)</h3>
<p>Insert text into a string.</p><p><strong>Parameters:</strong></p><p><em>start</em> starting offset to insert at.</p><p><em>text</em> text to insert.</p><p><em>len</em> size of text to insert.</p>
<h3>void ost::String::insert (size_tstart, const \fBString\fP &str)</h3>
<p>Insert other string into our string.</p><p><strong>Parameters:</strong></p><p><em>start</em> string offset to insert at.</p><p><em>str</em> string to insert.</p>
<h3>bool ost::String::isBig (void) const\fC [inline]\fP, \fC [protected]\fP</h3>
<p>Determine if string is allocated in local variable or an external reference.</p><p><strong>Returns:</strong></p><p>true if external heap is used.</p>
<h3>bool ost::String::isEmpty (void) const</h3>
<p>Return true if string is empty.</p><p><strong>Returns:</strong></p><p>true if string is empty string.</p>
<h3>size_t ost::String::length (void) const\fC [inline]\fP</h3>
<p>Get length as if null terminated string.</p><p><strong>Returns:</strong></p><p>cstring length.</p>
<h3>ost::String::operator char * () const\fC [inline]\fP</h3>
<p>Get our string data through dereference operator.</p><p><strong>Returns:</strong></p><p>string data.</p>
<h3>bool ost::String::operator! (void) const\fC [inline]\fP</h3>
<p>Logical test for string empty.</p><p><strong>Returns:</strong></p><p>true if is empty.</p>
<h3>bool \fBost::String::operator!\fP= (const \fBString\fP &str) const</h3>

<h3>bool \fBost::String::operator!\fP= (const char *str) const</h3>

<h3>bool ost::String::operator*= (const \fBString\fP &str) const</h3>
<p>Test if string is contained in our string.</p>
<h3>bool ost::String::operator*= (const char *str) const</h3>
<p>Test if text is contained in our string.</p>
<h3>\fBString\fP& ost::String::operator+= (const \fBString\fP &str)\fC [inline]\fP</h3>
<p>Append operator.</p>
<h3>\fBString\fP& ost::String::operator+= (charc)\fC [inline]\fP</h3>
<p>Append operator.</p>
<h3>\fBString\fP& ost::String::operator+= (const char *str)\fC [inline]\fP</h3>
<p>Append operator.</p>
<h3>\fBString\fP& ost::String::operator+= (const std::string &str)\fC [inline]\fP</h3>
<p>Append operator.</p>
<h3>\fBString\fP& ost::String::operator+= (inti)\fC [inline]\fP</h3>
<p>Append operator.</p>
<h3>\fBString\fP& ost::String::operator+= (unsigned inti)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator+= (longl)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator+= (unsigned longl)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator+= (floatf)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator+= (doubled)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator+= (shorts)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator+= (unsigned shorts)\fC [inline]\fP</h3>

<h3>bool ost::String::operator&lt; (const \fBString\fP &str) const</h3>

<h3>bool ost::String::operator&lt; (const char *str) const</h3>

<h3>bool ost::String::operator&lt;= (const \fBString\fP &str) const</h3>

<h3>bool ost::String::operator&lt;= (const char *str) const</h3>

<h3>const char* ost::String::operator= (const char *str)\fC [inline]\fP</h3>
<p>Assign our string for c string.</p>
<h3>\fBString\fP& ost::String::operator= (inti)\fC [inline]\fP</h3>
<p>Assignment operator.</p>
<h3>\fBString\fP& ost::String::operator= (unsigned inti)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator= (longl)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator= (unsigned longl)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator= (floatf)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator= (doubled)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator= (shorts)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator= (unsigned shorts)\fC [inline]\fP</h3>

<h3>\fBString\fP& ost::String::operator= (const \fBString\fP &original)\fC [inline]\fP</h3>

<h3>bool ost::String::operator== (const \fBString\fP &str) const</h3>

<h3>bool ost::String::operator== (const char *str) const</h3>

<h3>bool ost::String::operator&gt; (const \fBString\fP &str) const</h3>

<h3>bool ost::String::operator&gt; (const char *str) const</h3>

<h3>bool ost::String::operator&gt;= (const \fBString\fP &str) const</h3>

<h3>bool ost::String::operator&gt;= (const char *str) const</h3>

<h3>const char ost::String::operator[] (unsignedind) const\fC [inline]\fP</h3>
<p>Extract a character by array indexing.</p><p><strong>Returns:</strong></p><p>character code.</p>
<h3>void ost::String::replace (size_tstart, size_tlen, const char *text, size_tcount = \fC0\fP)</h3>
<p>Replace text at a specific position in the string with new text.</p><p><strong>Parameters:</strong></p><p><em>start</em> starting offset to replace at.</p><p><em>len</em> length of text to remove.</p><p><em>text</em> text to replace with.</p><p><em>count</em> size of replacement text.</p>
<h3>void ost::String::replace (size_tstart, size_tlen, const \fBString\fP &string)</h3>
<p>Replace text at a specific position in the string with new string,.</p><p><strong>Parameters:</strong></p><p><em>start</em> starting offset to replace at.</p><p><em>len</em> length of text to remove.</p><p><em>string</em> reference to replace with.</p>
<h3>void ost::String::resize (size_tsize)</h3>
<p>Re-allocate buffer space for string.</p><p><strong>Parameters:</strong></p><p><em>size</em> new size to use.</p>
<h3>size_t ost::String::rfind (const \fBString\fP &s, size_toffset = \fC0\fP) const</h3>
<p>Find last occurence of a substring in our string.</p><p><strong>Returns:</strong></p><p>index of last instance found,</p><p><strong>Parameters:</strong></p><p><em>s</em> string to search for.</p><p><em>offset</em> offset to start from.</p>
<h3>size_t ost::String::rfind (const char *s, size_toffset = \fC0\fP, size_tlen = \fC0\fP) const</h3>
<p>Find last occurence of a text in our string.</p><p><strong>Returns:</strong></p><p>index of last instance found,</p><p><strong>Parameters:</strong></p><p><em>s</em> string to search for.</p><p><em>offset</em> offset to start from.</p><p><em>len</em> size of string to look for.</p>
<h3>size_t ost::String::search (const char *text, size_tclen = \fC0\fP, size_toffset = \fC0\fP) const\fC [protected]\fP</h3>
<p>An internal method used to search for a substring starting at a known offset. Used by find and count methods.</p><p><strong>Returns:</strong></p><p>npos if fails, or offset to text found.</p><p><strong>Parameters:</strong></p><p><em>text</em> text to search for.</p><p><em>clen</em> length of search text.</p><p><em>offset</em> offset to start from.</p>
<h3>const char* ost::String::set (const char *str, size_tlen = \fC0\fP)\fC [protected]\fP</h3>
<p>Set the content of the string variable to the specified string value, and use smart re-allocation strategies if appropriate to shrink the size of the variable.</p><p><strong>Parameters:</strong></p><p><em>str</em> string to set.</p><p><em>len</em> length of string if passed.</p>
<h3>void ost::String::set (const \fBString\fP &str)\fC [protected]\fP</h3>
<p>Set the content of the string variable to that of another variable. Uses the string set method.</p><p><strong>Parameters:</strong></p><p><em>str</em> string to copy from.</p>
<h3>const char* ost::String::set (size_tsize, const char *format, ...)\fC [protected]\fP</h3>
<p>Set the content of the string variable to that of a formatted printf style string.</p><p><strong>Parameters:</strong></p><p><em>size</em> of string data to set.</p><p><em>format</em> of string to write into object.</p>
<h3>void ost::String::setLength (size_tlen)\fC [protected]\fP</h3>
<p>Set the length value of the string content.</p><p><strong>Parameters:</strong></p><p><em>len</em> size in bytes.</p>
<h3>size_t ost::String::setSize (size_tsize)\fC [protected]\fP</h3>
<p>Set the size of allocated space in the string variable (capacity) to a known value. The value is recomputed and adjusted based on allocation method.</p><p><strong>Parameters:</strong></p><p><em>size</em> in bytes.</p>
<h3>size_t ost::String::size (void) const\fC [inline]\fP</h3>
<p>Get actual length of string data.</p><p><strong>Returns:</strong></p><p>actual size of string.</p>
<h3>void ost::String::strip (const char *cs)</h3>
<p>Strip lead and trailing characters from a string.</p><p><strong>Parameters:</strong></p><p><em>cs</em> list of chars to strip.</p>
<h3>\fBString\fP ost::String::substr (size_tstart, size_tlen) const\fC [inline]\fP</h3>
<p>Return a new string that contains a specific substring of the current string.</p><p><strong>Returns:</strong></p><p>new string.</p><p><strong>Parameters:</strong></p><p><em>start</em> starting offset for extracted substring.</p><p><em>len</em> length of substring.</p>
<h3>char* ost::String::text (void) const\fC [inline]\fP</h3>
<p>Alternate get text method.</p><p><strong>Returns:</strong></p><p>string data.</p>
<h3>\fBString\fP ost::String::token (const char *delim = \fC' &#92;t&#92;n&#92;r'\fP, size_toffset = \fC0\fP)</h3>
<p>Extract a new string as a token from the current string.</p><p><strong>Returns:</strong></p><p>string containing token.</p><p><strong>Parameters:</strong></p><p><em>delim</em> deliminator characters.</p><p><em>offset</em> offset to start from.</p>
<h3>void ost::String::trim (const char *cs)\fC [inline]\fP</h3>
<p>Trim trailing characters from a string.</p><p><strong>Parameters:</strong></p><p><em>cs</em> list of chars to trim.</p><p>References ost::strtrim().</p>
<h3>void ost::String::trim (size_tcount)</h3>
<p>Trim n trailing characters from a string.</p><p><strong>Parameters:</strong></p><p><em>count</em> number of bytes to trim.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Friends And Related Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fB__EXPORT\fP std::istream& getline (std::istream &is, \fBString\fP &str, chardelim = \fC'&#92;n'\fP, size_tsize = \fC0\fP)\fC [friend]\fP</h3>
<p>Fetch input from a std::istream into the current string variable until either the string variable is filled (based on current length) or the deliminator is read.</p><p><strong>Parameters:</strong></p><p><em>is</em> stream to read.</p><p><em>str</em> string to save into.</p><p><em>delim</em> deliminator to use.</p><p><em>size</em> optional size limitor.</p>
<h3>friend class \fBMemPager\fP\fC [friend]\fP</h3>

<h3>\fB__EXPORT\fP \fBString\fP operator+ (const \fBString\fP &s1, const \fBString\fP &s2)\fC [friend]\fP</h3>
<p>Add two strings and return a temporary object.</p>
<h3>\fB__EXPORT\fP \fBString\fP operator+ (const \fBString\fP &s1, const char *s2)\fC [friend]\fP</h3>

<h3>\fB__EXPORT\fP \fBString\fP operator+ (const char *s1, const \fBString\fP &s2)\fC [friend]\fP</h3>

<h3>\fB__EXPORT\fP \fBString\fP operator+ (const \fBString\fP &s1, const charc2)\fC [friend]\fP</h3>

<h3>\fB__EXPORT\fP \fBString\fP operator+ (const charc1, const \fBString\fP &s2)\fC [friend]\fP</h3>

<h3>\fB__EXPORT\fP std::ostream& operator&lt;&lt; (std::ostream &os, const \fBString\fP &str)\fC [friend]\fP</h3>
<p>Stream the content of our string variable directly to a C++ streaming source.</p>
<h3>std::istream& operator&gt;&gt; (std::istream &is, \fBString\fP &str)\fC [friend]\fP</h3>
<p>Stream input into our variable.</p>
<h3>friend class \fBStringObject\fP\fC [friend]\fP</h3>

<h3>\fB__EXPORT\fP int strprintf (\fBString\fP &str, size_tsize, const char *format, ...)\fC [friend]\fP</h3>
<p>Print values directly into a string variable.</p><p><strong>Returns:</strong></p><p>character count.</p><p><strong>Parameters:</strong></p><p><em>str</em> object reference to use.</p><p><em>size</em> of string required.</p><p><em>format</em> of data.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>bool ost::String::big</h3>

<h3>struct { ... }     ost::String::bigstring</h3>

<h3>size_t ost::String::length</h3>

<h3>char ost::String::length</h3>

<h3>struct { ... }     ost::String::ministring</h3>

<h3>const unsigned ost::String::minsize\fC [static]\fP, \fC [protected]\fP</h3>

<h3>const size_t ost::String::npos\fC [static]\fP</h3>

<h3>const unsigned ost::String::pagesize\fC [static]\fP, \fC [protected]\fP</h3>

<h3>size_t ost::String::size</h3>

<h3>const unsigned ost::String::slotcount\fC [static]\fP, \fC [protected]\fP</h3>

<h3>const unsigned ost::String::slotlimit\fC [static]\fP, \fC [protected]\fP</h3>

<h3>const unsigned ost::String::slotsize\fC [static]\fP, \fC [protected]\fP</h3>

<h3>char* ost::String::text</h3>

<h3>char ost::String::text[(sizeof(char *)+(sizeof(size_t)*2)+1)]</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for GNU CommonC++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ost_StackPager.3.html"><span aria-hidden="true">&larr;</span> ost_StackPager.3: The stackpager provides a repository to stash and retrieve working data in last-in-first-out order.</a></li>
   <li class="next"><a href="ost_StringObject.3.html">ost_StringObject.3: The stringobject class is used to derive subclasses that use the string managed memory pool for all space allocations by overriding new and delete operators. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

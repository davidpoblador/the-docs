<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::Grove: Perl-style xml objects</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl-style xml objects">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::Grove (3pm) manual">
  <meta name="twitter:description" content="Perl-style xml objects">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-grove-perl-XML::Grove-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::Grove.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::Grove (3pm) manual" />
  <meta property="og:description" content="Perl-style xml objects" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-grove-perl-XML::Grove-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::Grove<small> (3pm)</small></h1>
        <p class="lead">Perl-style xml objects</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Grove.3pm.html">
      <span itemprop="name">XML::Grove: Perl-style xml objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-grove-perl/">
      <span itemprop="name">libxml-grove-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Grove.3pm.html">
      <span itemprop="name">XML::Grove: Perl-style xml objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use XML::Grove;

 # Basic parsing and grove building
 use XML::Grove::Builder;
 use XML::Parser::PerlSAX;
 $grove_builder = XML::Grove::Builder-&gt;new;
 $parser = XML::Parser::PerlSAX-&gt;new ( Handler =&gt; $grove_builder );
 $document = $parser-&gt;parse ( Source =&gt; { SystemId =&gt; &apos;filename&apos; } );

 # Creating new objects
 $document = XML::Grove::Document-&gt;new ( Contents =&gt; [ ] );
 $element = XML::Grove::Element-&gt;new ( Name =&gt; &apos;tag&apos;,
                                       Attributes =&gt; { },
                                       Contents =&gt; [ ] );

 # Accessing XML objects
 $tag_name = $element-&gt;{Name};
 $contents = $element-&gt;{Contents};
 $parent = $element-&gt;{Parent};
 $characters-&gt;{Data} = &apos;XML is fun!&apos;;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>XML::Grove is a tree-based object model for accessing the information set of parsed or stored \s-1XML\s0, \s-1HTML\s0, or \s-1SGML\s0 instances.  XML::Grove objects are Perl hashes and arrays where you access the properties of the objects using normal Perl syntax:</p><p>  $text = $characters-&gt;{Data};</p><h3>How To Create a Grove</h3>
<p>There are several ways for groves to come into being, they can be read from a file or string using a parser and a grove builder, they can be created by your Perl code using the `\*(C`new()\*(C'' methods of XML::Grove::Objects, or databases or other sources can act as groves.</p><p>The most common way to build groves is using a parser and a grove builder.  The parser is the package that reads the characters of an \s-1XML\s0 file, recognizes the \s-1XML\s0 syntax, and produces ``events'' reporting when elements (tags), text (characters), processing instructions, and other sequences occur.  A grove builder receives (``consumes'' or ``handles'') these events and builds XML::Grove objects.  The last thing the parser does is return the XML::Grove::Document object that the grove builder created, with all of it's elements and character data.</p><p>The most common parser and grove builder are XML::Parser::PerlSAX (in libxml-perl) and XML::Grove::Builder.  To build a grove, create the grove builder first:</p><p>  $grove_builder = XML::Grove::Builder-&gt;new;</p><p>Then create the parser, passing it the grove builder as it's handler:</p><p>  $parser = XML::Parser::PerlSAX-&gt;new ( Handler =&gt; $grove_builder );</p><p>This associates the grove builder with the parser so that every time you parse a document with this parser it will return an XML::Grove::Document object.  To parse a file, use the `\*(C`Source\*(C'' parameter to the `\*(C`parse()\*(C'' method containing a `\*(C`SystemId\*(C'' parameter (\s-1URL\s0 or path) of the file you want to parse:</p><p>  $document = $parser-&gt;parse ( Source =&gt; { SystemId =&gt; &apos;kjv.xml&apos; } );</p><p>To parse a string held in a Perl variable, use the `\*(C`Source\*(C'' parameter containing a `\*(C`String\*(C'' parameter:</p><p>  $document = $parser-&gt;parse ( Source =&gt; { String =&gt; $xml_text } );</p><p>The following are all parsers that work with XML::Grove::Builder:</p><p>  XML::Parser::PerlSAX (in libxml-perl, uses XML::Parser)   XML::ESISParser      (in libxml-perl, uses James Clark&apos;s &#96;nsgmls&apos;)   XML::SAX2Perl        (in libxml-perl, translates SAX 1.0 to PerlSAX)</p><p>Most parsers supply more properties than the standard information set below and XML::Grove will make available all the properties given by the parser, refer to the parser documentation to find out what additional properties it may provide.</p><p>Although there are not any available yet (August 1999), PerlSAX filters can be used to process the output of a parser before it is passed to XML::Grove::Builder.  XML::Grove::PerlSAX can be used to provide input to PerlSAX filters or other PerlSAX handlers.</p>
<h3>Using Groves</h3>
<p>The properties provided by parsers are available directly using Perl's normal syntax for accessing hashes and arrays.  For example, to get the name of an element:</p><p>  $element_name = $element-&gt;{Name};</p><p>By convention, all properties provided by parsers are in mixed case. `\*(C`Parent\*(C'' properties are available using the `\*(C`Data::Grove::Parent\*(C'' module.</p><p>The following is the minimal set of objects and their properties that you are likely to get from all parsers:</p>
<h3>XML::Grove::Document</h3>
<p>The Document object is parent of the root element of the parsed \s-1XML\s0 document.</p>
<dl class='dl-vertical'>
  <dt>
    Contents
  </dt>
  <dd>
    <p>An array containing the root element.</p>
  </dd>

</dl>
<p>A document's `Contents' may also contain processing instructions, comments, and whitespace.</p><p>Some parsers provide information about the document type, the \s-1XML\s0 declaration, or notations and entities.  Check the parser documentation for property names.</p>
<h3>XML::Grove::Element</h3>
<p>The Element object represents elements from the \s-1XML\s0 source.</p>
<dl class='dl-vertical'>
  <dt>
    Parent
  </dt>
  <dd>
    <p>The parent object of this element.</p>
  </dd>
  <dt>
    Name
  </dt>
  <dd>
    <p>A string, the element type name of this element</p>
  </dd>
  <dt>
    Attributes
  </dt>
  <dd>
    <p>A hash of strings or arrays</p>
  </dd>
  <dt>
    Contents
  </dt>
  <dd>
    <p>An array of elements, characters, processing instructions, etc.</p>
  </dd>

</dl>
<p>In a purely minimal grove, the attributes of an element will be plain text (Perl scalars).  Some parsers provide access to notations and entities in attributes, in which case the attribute may contain an array.</p>
<h3>XML::Grove::Characters</h3>
<p>The Characters object represents text from the \s-1XML\s0 source.</p>
<dl class='dl-vertical'>
  <dt>
    Parent
  </dt>
  <dd>
    <p>The parent object of this characters object</p>
  </dd>
  <dt>
    Data
  </dt>
  <dd>
    <p>A string, the characters</p>
  </dd>

</dl>

<h3>XML::Grove::PI</h3>
<p>The \s-1PI\s0 object represents processing instructions from the \s-1XML\s0 source.</p>
<dl class='dl-vertical'>
  <dt>
    Parent
  </dt>
  <dd>
    <p>The parent object of this \s-1PI\s0 object.</p>
  </dd>
  <dt>
    Target
  </dt>
  <dd>
    <p>A string, the processing instruction target.</p>
  </dd>
  <dt>
    Data
  </dt>
  <dd>
    <p>A string, the processing instruction data, or undef if none was supplied.</p>
  </dd>

</dl>
<p>In addition to the minimal set of objects above, XML::Grove knows about and parsers may provide the following objects.  Refer to the parser documentation for descriptions of the properties of these objects.</p><p>  XML::Grove::   ::Entity::External  External entity reference   ::Entity::SubDoc    External SubDoc reference (SGML)   ::Entity::SGML      External SGML reference (SGML)   ::Entity            Entity reference   ::Notation          Notation declaration   ::Comment           &lt;!-- A Comment --&gt;   ::SubDoc            A parsed subdocument (SGML)   ::CData             A CDATA marked section   ::ElementDecl       An element declaration from the DTD   ::AttListDecl       An element&apos;s attribute declaration, from the DTD</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>XML::Grove by itself only provides one method, <em>new()</em>, for creating new XML::Grove objects.  There are Data::Grove and XML::Grove extension modules that give additional methods for working with XML::Grove objects and new extensions can be created as needed. `\*(C`new\*(C'' creates a new XML::Grove object with the type <em>\s-1OBJECT\s0</em>, and with the initial <em>\s-1PROPERTIES\s0</em>.  <em>\s-1PROPERTIES\s0</em> may be given as either a list of key-value pairs, a hash, or an XML::Grove object to copy. <em>\s-1OBJECT\s0</em> may be any of the objects listed above.</p><p>This is a list of available extensions and the methods they provide (as of Feb 1999).  Refer to their module documentation for more information on how to use them.</p><p>  XML::Grove::AsString     as_string       return portions of groves as a string     attr_as_string  return an element&apos;s attribute as a string</p><p>  XML::Grove::AsCanonXML     as_canon_xml    return XML text in canonical XML format</p><p>  XML::Grove::PerlSAX     parse           emulate a PerlSAX parser using the grove objects</p><p>  Data::Grove::Parent     root            return the root element of a grove     rootpath        return an array of all objects between the root                     element and this object, inclusive</p><p>    Data::Grove::Parent also adds &#96;C&lt;Parent&gt;&apos; and &#96;C&lt;Raw&gt;&apos; properties     to grove objects.</p><p>  Data::Grove::Visitor     accept          call back a subroutine using an object type name     accept_name     call back using an element or tag name     children_accept for each child in Contents, call back a sub     children_accept_name  same, but using tag names     attr_accept     call back for the objects in attributes</p><p>  XML::Grove::IDs     get_ids         return a list of all ID attributes in grove</p><p>  XML::Grove::Path     at_path         $el-&gt;at_path(&apos;/html/body/ul/li[4]&apos;)</p><p>  XML::Grove::Sub     filter          run a sub against all the objects in the grove</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING EXTENSIONS</h2>
        <div class="sectioncontent">
<p>The class `\*(C`XML::Grove\*(C'' is the superclass of all classes in the XML::Grove module.  `\*(C`XML::Grove\*(C'' is a subclass of `\*(C`Data::Grove\*(C''.</p><p>If you create an extension and you want to add a method to <em>all</em> XML::Grove objects, then create that method in the XML::Grove package.  Many extensions only need to add methods to XML::Grove::Document and/or XML::Grove::Element.</p><p>When you create an extension you should definitly provide a way to invoke your module using objects from your package too.  For example, XML::Grove::AsString's `\*(C`as_string()\*(C'' method can also be called using an XML::Grove::AsString object:</p><p>  $writer= new XML::Grove::AsString;   $string = $writer-&gt;as_string ( $xml_object );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Ken MacLeod, ken@bitsko.slc.ut.us</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::Grove&hellip;</h2>
        <div class="sectioncontent">
<p><em>perl</em>\|(1), <em>XML::Grove</em>\|(3)</p><p>Extensible Markup Language (\s-1XML\s0) &lt;http://www.w3c.org/XML&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::Generator::DOM.3pm.html"><span aria-hidden="true">&larr;</span> XML::Generator::DOM.3pm: Xml::generator subclass for producing dom trees instead of strings.</a></li>
   <li class="next"><a href="XML::Grove::AsCanonXML.3pm.html">XML::Grove::AsCanonXML.3pm: Output xml objects in canonical xml <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

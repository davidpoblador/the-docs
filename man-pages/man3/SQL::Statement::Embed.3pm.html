<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SQL::Statement::Embed: Embed a sql engine in a dbd or module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Embed a sql engine in a dbd or module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SQL::Statement::Embed (3pm) manual">
  <meta name="twitter:description" content="Embed a sql engine in a dbd or module">
  <meta name="twitter:image" content="https://www.carta.tech/images/libsql-statement-perl-SQL::Statement::Embed-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/SQL::Statement::Embed.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SQL::Statement::Embed (3pm) manual" />
  <meta property="og:description" content="Embed a sql engine in a dbd or module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libsql-statement-perl-SQL::Statement::Embed-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SQL::Statement::Embed<small> (3pm)</small></h1>
        <p class="lead">Embed a sql engine in a dbd or module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/SQL::Statement::Embed.3pm.html">
      <span itemprop="name">SQL::Statement::Embed: Embed a sql engine in a dbd or module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libsql-statement-perl/">
      <span itemprop="name">libsql-statement-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/SQL::Statement::Embed.3pm.html">
      <span itemprop="name">SQL::Statement::Embed: Embed a sql engine in a dbd or module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>SQL::Statement is designed to be easy to embed in other modules and to be especially easy to embed in \s-1DBI\s0 drivers.  It provides a \s-1SQL\s0 Engine and the other module needs to then provide a data source and a storage mechanism. For example, the \s-1DBD::CSV\s0 module uses SQL::Statement as an embedded \s-1SQL\s0 engine by implementing a file-based data source and by using \s-1DBI\s0 as the user interface.  Similarly DBD::Amazon uses SQL::Statement as its \s-1SQL\s0 engine, provides its own extensions to the supported \s-1SQL\s0 syntax, and uses on-the-fly searches of Amazon.com as its data source.</p><p>SQL::Statement is the basis for at least eight existing DBDs (\s-1DBI\s0 database drivers).  If you have a new data source, you too can create a \s-1DBD\s0 without having to reinvent the \s-1SQL\s0 wheel.  It is fun and easy so become a \s-1DBD\s0 author today!</p><p>SQL::Statement can be also be embedded without \s-1DBI\s0.  We will explore that first since developing a \s-1DBD\s0 uses most of the same methods and techniques.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">The role of SQL::Statement subclasses</h2>
        <div class="sectioncontent">
<p>SQL::Statement provides a \s-1SQL\s0 parsing and execution engine.  It neither provides a data source nor storage mechanism other than in-memory tables. The DBI::DBD::SqlEngine contains a subclass of SQL::Statement to abstract from embedding SQL::Statement into a \s-1DBD\s0 and lets you concentrate on the extensions you need to make. DBD::File extends DBI::DBD::SqlEngine by providing access to file-based storage mechanisms.  It is quite possible to use things other than files as data souces, in which case you would not use DBD::File, instead you would replace DBD::File's methods with your own.  In the examples below, we use DBD::File, replacing only a few methods.</p><p>SQL::Statement provides \s-1SQL\s0 parsing and evaluation and DBI::DBD::SqlEngine provides \s-1DBI\s0 integration.  The only thing missing is a data source - what we actually want to store and query.   As an example suppose we are going to create a subclass called 'Foo' that will provide as a data source the in-memory storage which is used in \s-1SQL::RAM\s0 to provide the \*(C`TEMP\*(C' tables in SQL::Statement, but the rows are stored as a string using a serializer (Storable).</p><p>Consider what needs to happen to perform a \s-1SELECT\s0 query on our 'Foo' data:</p>
<pre>
 * receive a SQL string
 * parse the SQL string into a request structure
 * open the table(s) specified in the request
 * define column names and positions for the table
 * read rows from the table
 * convert the rows from colon-separated format into perl arrays
 * match the columns and rows against the requested selection criteria
 * return requested rows and columns to the user
</pre>
<p>To perform operations like \s-1INSERT\s0 and \s-1DELETE\s0, we also need to:</p><p> * convert rows from perl arrays into colon-separated format  * write rows  * delete rows</p><p>SQL::Statement takes care of all of the \s-1SQL\s0 parsing and evaluation. DBD::File takes care of file opening, reading, writing, and deleting. So the only things 'Foo' is really responsible for are:</p><p> * define column names and positions for the table  * convert rows from colon-separated format into perl arrays  * convert rows from perl arrays into colon-separated format</p><p>In SQL::Statement subclasses these responsibilities are assigned to two objects.  A ::Statement object is responsible for opening the table by creating new ::Table objects.  A ::Table object is responsible for defining the column names and positions, opening data sources, reading, converting, writing and deleting data.</p><p>The real work is demzufolge done in the ::Table object, the ::Statement subclass is required to deliver the right ::Table object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Creating a ::Statement object</h2>
        <div class="sectioncontent">
<p>A subclass of SQL::Statement must provide at least one method called <em>open_table()</em>.  The method should open a new Table object and define the table's columns.  For our 'Foo' module, here is the complete object definition:</p><p>    package Foo;</p><p>    package Foo::Statement;     use DBD::File;     use base qw(DBI::DBD::SqlEngine::Statement);</p><p>    sub open_table {         my ($self, $sth, $table, $createMode, $lockMode) = @_;</p><p>        my $class = ref $self;         $class =~ s/::Statement/::Table/;</p><p>        return $class-&gt;new ($sth, $table, $createMode, $lockMode);     }</p><p>Since 'Foo' is an in-memory data source, we subclass SQL::Statement indirectly through DBD::File::Statement.  The <em>open_table()</em> method lets DBD::File do the actual table opening.  All we do is define the files directory (f_dir), the names of the columns (col_names) and the positions of the columns (col_nums).  DBD::File creates and returns a $tbl object. It names that object according to the module that calls it, so in our case the object will be a Foo::Table object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Creating a ::Table object</h2>
        <div class="sectioncontent">
<p>Table objects are responsible for reading, converting, writing, and deleting data. Since DBD::File provides most of those services, our 'Foo' subclass only needs to define three methods - <em>fetch_row()</em> to read data, <em>push_row()</em> to write data, and <em>push_names()</em> to store column names.  We will leave deleting to DBD::File, since deleting a record in the 'Foo' format is the same process as deleting a record in any other simple file-based format.  Here is the complete object defintion:</p><p> package Foo::Table;  use base qw(DBD::File::Table);</p><p> sub fetch_row {     my($self, $data) = @_;     my $fieldstr = $self-&gt;{fh}-&gt;getline;     return undef unless $fieldstr;     chomp $fieldstr;     my @fields   = split /:/,$fieldstr;     $self-&gt;{row} = (@fields ? &#92;@fields : undef);  }  sub push_row {     my($self, $data, $fields) = @_;     my $str = join &apos;:&apos;, map { defined $_ ? $_ : &apos;&apos; } @$fields;     $self-&gt;{fh}-&gt;print( $str."&#92;n");     1;  }  sub push_names {}  1;</p><p>The <em>fetch_row()</em> method uses DBD::File's <em>getline()</em> method to physically read a row of data, then we convert it from native colon-separated format into a perl arrayref.</p><p>The <em>push_row()</em> method converts from a perl arrayref back to colon-separated format then uses DBD::File's <em>print()</em> method to print it to file.</p><p>The push_names method does nothing because it's purpose is to store column names in a file and in our 'Foo' subclass, we are defining the column names ourselves, not storing them in a file.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Trying out our new subclass</h2>
        <div class="sectioncontent">
<p>Here is a script which should create and query a file in our 'Foo' format. It assumes you have saved the Foo, Foo::Statement, and Foo::Table classes shown above into a file called Foo.pm.</p><p> #!perl -w  use strict;  use Foo;  my $parser = SQL::Parser-&gt;new();  $parser-&gt;{RaiseError}=1;  $parser-&gt;{PrintError}=0;  for my $sql(split /&#92;n/,  "  DROP TABLE IF EXISTS group_id     CREATE TABLE group_id (username CHAR,uid INT, gid INT)     INSERT INTO group_id VALUES(&apos;joe&apos;,1,1)     INSERT INTO group_id VALUES(&apos;sue&apos;,2,1)     INSERT INTO group_id VALUES(&apos;bob&apos;,3,2)     SELECT * FROM group_id             "  ){     my $stmt = Foo::Statement-&gt;new($sql,$parser);     $stmt-&gt;execute;     next unless $stmt-&gt;command eq &apos;SELECT&apos;;     while (my $row=$stmt-&gt;fetch) {         print "@$row&#92;n";     }  }</p><p>This is the same script as shown in the section on executing and fetching in SQL::Statement::Structure except that instead of SQL::Statement-&gt;<em>new()</em>, we are using Foo::Statement-&gt;<em>new()</em>.   The other difference is that the execute/fetch example was using in-memory storage while this script is using file-based storage and the 'Foo' format we defined.  When you run this script, you will be creating a file called \*(L"group_id\*(R" and it will contain the specified data in colon-separated format.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Developing a new DBD</h2>
        <div class="sectioncontent">
<h3>Moving from a subclass to a \s-1DBD\s0</h3>
<p>A \s-1DBD\s0 based on SQL::Statement uses the same two subclasses that are shown above.  They should be called DBD::Foo::Statement and DBD::Foo::Table, but would otherwise be identical to the non-DBD subclass illustrated above. To turn it into a full \s-1DBD\s0, you have to sublass DBD::File, DBD::File::dr, DBD::File::db, and DBD::File::st.  In many cases a simple subclass with few or no methods overridden is sufficient.</p><p>Here is a working DBD::Foo:</p><p> package DBD::Foo;  use base qw(DBD::File);</p><p> package DBD::Foo::dr;  $DBD::Foo::dr::imp_data_size = 0;  use base qw(DBD::File::dr);</p><p> package DBD::Foo::db;  $DBD::Foo::db::imp_data_size = 0;  use base qw(DBD::File::db);</p><p> package DBD::Foo::st;  $DBD::Foo::st::imp_data_size = 0;  use base qw(DBD::File::st);</p><p> package DBD::Foo::Statement;  use base qw(DBD::File::Statement);</p><p> sub open_table {      my $self = shift @_;      my $data = shift @_;      $data-&gt;{Database}-&gt;{f_dir} = &apos;./&apos;;      my $tbl  = $self-&gt;SUPER::open_table($data,@_);      $tbl-&gt;{col_names} = [qw(username uid gid)];      $tbl-&gt;{col_nums}  = {username=&gt;0,uid=&gt;1,gid=&gt;2};      return $tbl;  }</p><p> package DBD::Foo::Table;  use base qw(DBD::File::Table);</p><p> sub fetch_row {     my($self, $data) = @_;     my $fieldstr = $self-&gt;{fh}-&gt;getline;     return undef unless $fieldstr;     chomp $fieldstr;     my @fields   = split /:/,$fieldstr;     $self-&gt;{row} = (@fields ? &#92;@fields : undef);  }  sub push_row {      my($self, $data, $fields) = @_;      my $str = join &apos;:&apos;, map { defined $_ ? $_ : &apos;&apos; } @$fields;      $self-&gt;{fh}-&gt;print( $str."&#92;n");      1;  }  sub push_names {}  1;</p>
<h3>A sample script to test our new \s-1DBD\s0</h3>
<p>Assuming you saved the DBD::Foo shown above as a file called \*(L"Foo.pm\*(R" in a directory called \*(L"\s-1DBD\s0\*(R", this script will work, so will most other \s-1DBI\s0 methods such as selectall_arrayref, fetchrow_hashref, etc.</p><p> #!perl -w  use strict;  use lib qw(/home/jeff/data/module/lib); # or wherever you stored DBD::Foo  use DBI;  my $dbh=DBI-&gt;connect(&apos;dbi:Foo:&apos;);  $dbh-&gt;{RaiseError}=1;  $dbh-&gt;{PrintError}=0;  for my $sql(split /&#92;n/,  "  DROP TABLE IF EXISTS group_id     CREATE TABLE group_id (username CHAR,uid INT, gid INT)     INSERT INTO group_id VALUES(&apos;joe&apos;,1,1)     INSERT INTO group_id VALUES(&apos;sue&apos;,2,1)     INSERT INTO group_id VALUES(&apos;bob&apos;,3,2)     SELECT * FROM group_id             "  ){     my $stmt = $dbh-&gt;prepare($sql);     $stmt-&gt;execute;     next unless $stmt-&gt;{NUM_OF_FIELDS};     while (my $row=$stmt-&gt;fetch) {         print "@$row&#92;n";     }  }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Expanding the DBD</h2>
        <div class="sectioncontent">
<p>Now that we have a basic \s-1DBD\s0 operational, there are several directions for expansion.  In the first place, we might want to override some or all of DBD::File::Table to provide alternate means of reading, writing, and deleting from our data source.  We might want to override the <em>open_table()</em> method to provide a different means of identifying column names (e.g. reading them from the file itself) or to provide other kinds of metadata. See SQL::Eval for documentation of the \s-1API\s0 for ::Table objects and see DBD::File for an example subclass.</p><p>We might want to create extensions to the \s-1SQL\s0 syntax specific to our \s-1DBD\s0. See the section on extending \s-1SQL\s0 syntax in SQL::Statement::Syntax.</p><p>We might want to provide a completely different kind of data source.  See \s-1DBD::DBM\s0 (whose source code includes documentation on subclassing SQL::Statement and DBD::File), and other DBD::File subclasses such as \s-1DBD::CSV\s0.</p><p>We might also want to provide a completely different storage mechanism, something not based on files at all.  See DBD::Amazon and DBD::AnyData.</p><p>And we will almost certainly want to fine-tune the \s-1DBI\s0 interface, see \s-1DBI::DBD\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Getting help with a new DBD</h2>
        <div class="sectioncontent">
<p>The dbi-devATperl.org mailing list should be your first stop in creating a new \s-1DBD\s0.  Tim Bunce, the author of \s-1DBI\s0 and many \s-1DBD\s0 authors hang out there. Tell us what you are planning and we will offer suggestions about similar modules or other people working on similar issues, or on how to proceed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR & COPYRIGHT</h2>
        <div class="sectioncontent">
<p>  Copyright (c) 2005, Jeff Zucker &lt;jzuckerATcpan.org&gt;, all rights reserved.   Copyright (c) 2010, Jens Rehsack &lt;rehsackATcpan.org&gt;, all rights reserved.</p><p>This document may be freely modified and distributed under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SQL::Statement.3pm.html"><span aria-hidden="true">&larr;</span> SQL::Statement.3pm: Sql parsing and processing engine</a></li>
   <li class="next"><a href="SQL::Statement::Function.3pm.html">SQL::Statement::Function.3pm: Implements the built-in string concatenation <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

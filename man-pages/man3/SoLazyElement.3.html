<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoLazyElement: The solazyelement class is used to handle material and shape properties.  so[gl]lazyelement is, as the name implies, an element that is lazy about sending things to opengl. the changes are not sent to opengl until sogllazyelement::send() is called. this means that you can change the state of certain attributes several times, but the state will only be sent to opengl once.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The solazyelement class is used to handle material and shape properties.  so[gl]lazyelement is, as the name implies, an element that is lazy about sending things to opengl. the changes are not sent to opengl until sogllazyelement::send() is called. this means that you can change the state of certain attributes several times, but the state will only be sent to opengl once.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoLazyElement (3) manual">
  <meta name="twitter:description" content="The solazyelement class is used to handle material and shape properties.  so[gl]lazyelement is, as the name implies, an element that is lazy about sending things to opengl. the changes are not sent to opengl until sogllazyelement::send() is called. this means that you can change the state of certain attributes several times, but the state will only be sent to opengl once.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoLazyElement-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoLazyElement.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoLazyElement (3) manual" />
  <meta property="og:description" content="The solazyelement class is used to handle material and shape properties.  so[gl]lazyelement is, as the name implies, an element that is lazy about sending things to opengl. the changes are not sent to opengl until sogllazyelement::send() is called. this means that you can change the state of certain attributes several times, but the state will only be sent to opengl once." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoLazyElement-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoLazyElement<small> (3)</small></h1>
        <p class="lead">The solazyelement class is used to handle material and shape properties.  so[gl]lazyelement is, as the name implies, an element that is lazy about sending things to opengl. the changes are not sent to opengl until sogllazyelement::send() is called. this means that you can change the state of certain attributes several times, but the state will only be sent to opengl once.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoLazyElement.3.html">
      <span itemprop="name">SoLazyElement: The solazyelement class is used to handle material and shape properties.  so[gl]lazyelement is, as the name implies, an element that is lazy about sending things to opengl. the changes are not sent to opengl until sogllazyelement::send() is called. this means that you can change the state of certain attributes several times, but the state will only be sent to opengl once.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoLazyElement.3.html">
      <span itemprop="name">SoLazyElement: The solazyelement class is used to handle material and shape properties.  so[gl]lazyelement is, as the name implies, an element that is lazy about sending things to opengl. the changes are not sent to opengl until sogllazyelement::send() is called. this means that you can change the state of certain attributes several times, but the state will only be sent to opengl once.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/elements/SoLazyElement.h&gt;</p><p>Inherits <strong>SoElement</strong>.</p><p>Inherited by <strong>SoGLLazyElement</strong>.</p><h3>Public Types</h3>
<p>enum <strong>cases</strong> { <strong>LIGHT_MODEL_CASE</strong> = 0, <strong>COLOR_MATERIAL_CASE</strong>, <strong>DIFFUSE_CASE</strong>, <strong>AMBIENT_CASE</strong>, <strong>EMISSIVE_CASE</strong>, <strong>SPECULAR_CASE</strong>, <strong>SHININESS_CASE</strong>, <strong>BLENDING_CASE</strong>, <strong>TRANSPARENCY_CASE</strong>, <strong>VERTEXORDERING_CASE</strong>, <strong>TWOSIDE_CASE</strong>, <strong>CULLING_CASE</strong>, <strong>SHADE_MODEL_CASE</strong>, <strong>ALPHATEST_CASE</strong>, <strong>GLIMAGE_CASE</strong>, <strong>LAZYCASES_LAST</strong> }</p><p>enum <strong>masks</strong> { <strong>LIGHT_MODEL_MASK</strong> = 1 &lt;&lt; LIGHT_MODEL_CASE, <strong>COLOR_MATERIAL_MASK</strong> = 1 &lt;&lt; COLOR_MATERIAL_CASE, <strong>DIFFUSE_MASK</strong> = 1 &lt;&lt; DIFFUSE_CASE, <strong>AMBIENT_MASK</strong> = 1 &lt;&lt; AMBIENT_CASE, <strong>EMISSIVE_MASK</strong> = 1&lt;&lt;EMISSIVE_CASE, <strong>SPECULAR_MASK</strong> = 1 &lt;&lt; SPECULAR_CASE, <strong>SHININESS_MASK</strong> = 1 &lt;&lt; SHININESS_CASE, <strong>TRANSPARENCY_MASK</strong> = 1 &lt;&lt; TRANSPARENCY_CASE, <strong>BLENDING_MASK</strong> = 1 &lt;&lt; BLENDING_CASE, <strong>VERTEXORDERING_MASK</strong> = 1 &lt;&lt; VERTEXORDERING_CASE, <strong>TWOSIDE_MASK</strong> = 1 &lt;&lt; TWOSIDE_CASE, <strong>CULLING_MASK</strong> = 1 &lt;&lt; CULLING_CASE, <strong>SHADE_MODEL_MASK</strong> = 1 &lt;&lt; SHADE_MODEL_CASE, <strong>ALPHATEST_MASK</strong> = 1 &lt;&lt; ALPHATEST_CASE, <strong>GLIMAGE_MASK</strong> = 1 &lt;&lt; GLIMAGE_CASE, <strong>ALL_MASK</strong> = (1 &lt;&lt; LAZYCASES_LAST)-1 }</p><p>enum <strong>internalMasks</strong> { <strong>OTHER_COLOR_MASK</strong> = AMBIENT_MASK|EMISSIVE_MASK|SPECULAR_MASK|SHININESS_MASK, <strong>ALL_COLOR_MASK</strong> = OTHER_COLOR_MASK|DIFFUSE_MASK, <strong>NO_COLOR_MASK</strong> = ALL_MASK & (~ALL_COLOR_MASK), <strong>ALL_BUT_DIFFUSE_MASK</strong> = ALL_MASK &(~ DIFFUSE_MASK), <strong>DIFFUSE_ONLY_MASK</strong> = ALL_MASK &(~ OTHER_COLOR_MASK) }</p><p>enum <strong>LightModel</strong> { <strong>BASE_COLOR</strong>, <strong>PHONG</strong> }</p><p>enum <strong>VertexOrdering</strong> { <strong>CW</strong>, <strong>CCW</strong> }</p>
<h3>Public Member Functions</h3>
<p>virtual void <strong>init</strong> (<strong>SoState</strong> *state)</p><p>virtual void <strong>push</strong> (<strong>SoState</strong> *state)</p><p>virtual SbBool <strong>matches</strong> (const <strong>SoElement</strong> *) const </p><p>virtual <strong>SoElement</strong> * <strong>copyMatchInfo</strong> (void) const </p><p>int32_t <strong>getNumDiffuse</strong> (void) const </p><p>int32_t <strong>getNumTransparencies</strong> (void) const </p><p>int32_t <strong>getNumColorIndices</strong> (void) const </p><p>SbBool <strong>isPacked</strong> (void) const </p><p>SbBool <strong>isTransparent</strong> (void) const </p><p>const uint32_t * <strong>getPackedPointer</strong> (void) const </p><p>const <strong>SbColor</strong> * <strong>getDiffusePointer</strong> (void) const </p><p>const int32_t * <strong>getColorIndexPointer</strong> (void) const </p><p>const float * <strong>getTransparencyPointer</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static int <strong>getClassStackIndex</strong> (void)</p><p>static void * <strong>createInstance</strong> (void)</p><p>static void <strong>initClass</strong> ()</p><p>static void <strong>setToDefault</strong> (<strong>SoState</strong> *state)</p><p>static void <strong>setDiffuse</strong> (<strong>SoState</strong> *state, <strong>SoNode</strong> *node, int32_t numcolors, const <strong>SbColor</strong> *colors, SoColorPacker *packer)</p><p>static void <strong>setTransparency</strong> (<strong>SoState</strong> *state, <strong>SoNode</strong> *node, int32_t numvalues, const float *transparency, SoColorPacker *packer)</p><p>static void <strong>setPacked</strong> (<strong>SoState</strong> *state, <strong>SoNode</strong> *node, int32_t numcolors, const uint32_t *colors, const SbBool packedtransparency=FALSE)</p><p>static void <strong>setColorIndices</strong> (<strong>SoState</strong> *state, <strong>SoNode</strong> *node, int32_t numindices, const int32_t *indices)</p><p>static void <strong>setAmbient</strong> (<strong>SoState</strong> *state, const <strong>SbColor</strong> *color)</p><p>static void <strong>setEmissive</strong> (<strong>SoState</strong> *state, const <strong>SbColor</strong> *color)</p><p>static void <strong>setSpecular</strong> (<strong>SoState</strong> *state, const <strong>SbColor</strong> *color)</p><p>static void <strong>setShininess</strong> (<strong>SoState</strong> *state, float value)</p><p>static void <strong>setColorMaterial</strong> (<strong>SoState</strong> *state, SbBool value)</p><p>static void <strong>enableBlending</strong> (<strong>SoState</strong> *state, int sfactor, int dfactor)</p><p>static void <strong>enableSeparateBlending</strong> (<strong>SoState</strong> *state, int sfactor, int dfactor, int alpha_sfactor, int alpha_dfactor)</p><p>static void <strong>disableBlending</strong> (<strong>SoState</strong> *state)</p><p>static void <strong>setLightModel</strong> (<strong>SoState</strong> *state, const int32_t model)</p><p>static void <strong>setVertexOrdering</strong> (<strong>SoState</strong> *state, VertexOrdering ordering)</p><p>static void <strong>setBackfaceCulling</strong> (<strong>SoState</strong> *state, SbBool onoff)</p><p>static void <strong>setTwosideLighting</strong> (<strong>SoState</strong> *state, SbBool onoff)</p><p>static void <strong>setShadeModel</strong> (<strong>SoState</strong> *state, SbBool flatshading)</p><p>static void <strong>setAlphaTest</strong> (<strong>SoState</strong> *state, int func, float value)</p><p>static const <strong>SbColor</strong> & <strong>getDiffuse</strong> (<strong>SoState</strong> *state, int index)</p><p>static float <strong>getTransparency</strong> (<strong>SoState</strong> *, int index)</p><p>static const uint32_t * <strong>getPackedColors</strong> (<strong>SoState</strong> *)</p><p>static const int32_t * <strong>getColorIndices</strong> (<strong>SoState</strong> *)</p><p>static int32_t <strong>getColorIndex</strong> (<strong>SoState</strong> *, int num)</p><p>static const <strong>SbColor</strong> & <strong>getAmbient</strong> (<strong>SoState</strong> *)</p><p>static const <strong>SbColor</strong> & <strong>getEmissive</strong> (<strong>SoState</strong> *)</p><p>static const <strong>SbColor</strong> & <strong>getSpecular</strong> (<strong>SoState</strong> *)</p><p>static float <strong>getShininess</strong> (<strong>SoState</strong> *)</p><p>static SbBool <strong>getColorMaterial</strong> (<strong>SoState</strong> *)</p><p>static SbBool <strong>getBlending</strong> (<strong>SoState</strong> *, int &sfactor, int &dfactor)</p><p>static SbBool <strong>getAlphaBlending</strong> (<strong>SoState</strong> *, int &sfactor, int &dfactor)</p><p>static int32_t <strong>getLightModel</strong> (<strong>SoState</strong> *)</p><p>static int <strong>getAlphaTest</strong> (<strong>SoState</strong> *state, float &value)</p><p>static SbBool <strong>getTwoSidedLighting</strong> (<strong>SoState</strong> *state)</p><p>static <strong>SoLazyElement</strong> * <strong>getInstance</strong> (<strong>SoState</strong> *state)</p><p>static float <strong>getDefaultAmbientIntensity</strong> (void)</p><p>static <strong>SbColor</strong> <strong>getDefaultDiffuse</strong> (void)</p><p>static <strong>SbColor</strong> <strong>getDefaultAmbient</strong> (void)</p><p>static <strong>SbColor</strong> <strong>getDefaultSpecular</strong> (void)</p><p>static <strong>SbColor</strong> <strong>getDefaultEmissive</strong> (void)</p><p>static float <strong>getDefaultShininess</strong> (void)</p><p>static uint32_t <strong>getDefaultPacked</strong> (void)</p><p>static float <strong>getDefaultTransparency</strong> (void)</p><p>static int32_t <strong>getDefaultLightModel</strong> (void)</p><p>static int32_t <strong>getDefaultColorIndex</strong> (void)</p><p>static void <strong>setMaterials</strong> (<strong>SoState</strong> *state, <strong>SoNode</strong> *node, uint32_t bitmask, SoColorPacker *cPacker, const <strong>SbColor</strong> *diffuse, const int numdiffuse, const float *transp, const int numtransp, const <strong>SbColor</strong> &ambient, const <strong>SbColor</strong> &emissive, const <strong>SbColor</strong> &specular, const float shininess, const SbBool istransparent)</p><p>static <strong>SoLazyElement</strong> * <strong>getWInstance</strong> (<strong>SoState</strong> *state)</p><p>static void <strong>setTransparencyType</strong> (<strong>SoState</strong> *state, int32_t type)</p>
<h3>Protected Member Functions</h3>
<p>virtual void <strong>lazyDidSet</strong> (uint32_t mask)</p><p>virtual void <strong>lazyDidntSet</strong> (uint32_t mask)</p><p>virtual void <strong>setDiffuseElt</strong> (<strong>SoNode</strong> *, int32_t numcolors, const <strong>SbColor</strong> *colors, SoColorPacker *packer)</p><p>virtual void <strong>setPackedElt</strong> (<strong>SoNode</strong> *node, int32_t numcolors, const uint32_t *colors, const SbBool packedtransparency)</p><p>virtual void <strong>setColorIndexElt</strong> (<strong>SoNode</strong> *node, int32_t numindices, const int32_t *indices)</p><p>virtual void <strong>setTranspElt</strong> (<strong>SoNode</strong> *node, int32_t numtransp, const float *transp, SoColorPacker *packer)</p><p>virtual void <strong>setTranspTypeElt</strong> (int32_t type)</p><p>virtual void <strong>setAmbientElt</strong> (const <strong>SbColor</strong> *color)</p><p>virtual void <strong>setEmissiveElt</strong> (const <strong>SbColor</strong> *color)</p><p>virtual void <strong>setSpecularElt</strong> (const <strong>SbColor</strong> *color)</p><p>virtual void <strong>setShininessElt</strong> (float value)</p><p>virtual void <strong>setColorMaterialElt</strong> (SbBool value)</p><p>virtual void <strong>enableBlendingElt</strong> (int sfactor, int dfactor, int alpha_sfactor, int alpha_dfactor)</p><p>virtual void <strong>disableBlendingElt</strong> (void)</p><p>virtual void <strong>setLightModelElt</strong> (<strong>SoState</strong> *state, int32_t model)</p><p>virtual void <strong>setMaterialElt</strong> (<strong>SoNode</strong> *node, uint32_t bitmask, SoColorPacker *packer, const <strong>SbColor</strong> *diffuse, const int numdiffuse, const float *transp, const int numtransp, const <strong>SbColor</strong> &ambient, const <strong>SbColor</strong> &emissive, const <strong>SbColor</strong> &specular, const float shininess, const SbBool istransparent)</p><p>virtual void <strong>setVertexOrderingElt</strong> (VertexOrdering ordering)</p><p>virtual void <strong>setBackfaceCullingElt</strong> (SbBool onoff)</p><p>virtual void <strong>setTwosideLightingElt</strong> (SbBool onoff)</p><p>virtual void <strong>setShadeModelElt</strong> (SbBool flatshading)</p><p>virtual void <strong>setAlphaTestElt</strong> (int func, float value)</p>
<h3>Protected Attributes</h3>
<p>struct SoLazyElement::CoinState <strong>coinstate</strong></p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoLazyElement</strong> class is used to handle material and shape properties.</p><p>So[GL]LazyElement is, as the name implies, an element that is lazy about sending things to OpenGL. The changes are not sent to OpenGL until <strong>SoGLLazyElement::send()</strong> is called. This means that you can change the state of certain attributes several times, but the state will only be sent to OpenGL once.</p><p>When creating a new shape node in Coin, it's a common operation to modify the OpenGL diffuse color. There are several ways you can send the color to OpenGL. If you're not going to use the color outside your node, you can just as well send it using plain OpenGL. You can also set the color in the element, and then force a send by using <strong>SoGLLazyElement::send</strong>(state, SoLazyElement::DIFFUSE_MASK).</p><p>However, when creating an extension shape node, it's always recommended to create an instance of <strong>SoMaterialBundle</strong> on the stack. If this instance is created after you update <strong>SoLazyElement</strong> with a new color, the new color will be sent to OpenGL when you call <strong>SoMaterialBundle::sendFirst()</strong>. This call will also update all other lazy OpenGL state, and it's actually required to either use <strong>SoMaterialBundle::sendFirst()</strong> or call <strong>SoGLLazyElement::send</strong>(state, SoLazyElement::ALL_MASK) when creating a shape node.</p><p>If you decide to send the color to OpenGL using glColor*(), you should notify <strong>SoGLLazyElement</strong> about this by calling SoGLLazyElement::reset(state, SoLazyElement::DIFFUSE_MASK). This will notify <strong>SoGLLazyElement</strong> that the current OpenGL diffuse color is unknown.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void * SoLazyElement::createInstance (void)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoLazyElement::initClass (void)\fC [static]\fP</h3>
<p>This static method initializes static data for the <strong>SoDiffuseColorElement</strong> class.</p>
<h3>void SoLazyElement::init (\fBSoState\fP *state)\fC [virtual]\fP</h3>
<p>This function initializes the element type in the given <strong>SoState</strong>. It is called for the first element of each enabled element type in <strong>SoState</strong> objects.</p><p>Reimplemented from <strong>SoElement</strong>.</p><p>Reimplemented in <strong>SoGLLazyElement</strong>.</p>
<h3>void SoLazyElement::push (\fBSoState\fP *state)\fC [virtual]\fP</h3>
<p>This method is called every time a new element is required in one of the stacks. This happens when a writable element is requested, using <strong>SoState::getElement()</strong> or indirectly <strong>SoElement::getElement()</strong>, and the depth of the current element is less than the state depth.</p><p>Override this method if your element needs to copy data from the previous top of stack. The <strong>push()</strong> method is called on the new element, and the previous element can be found using <strong>SoElement::getNextInStack()</strong>.</p><p>Reimplemented from <strong>SoElement</strong>.</p><p>Reimplemented in <strong>SoGLLazyElement</strong>.</p>
<h3>SbBool SoLazyElement::matches (const \fBSoElement\fP *) const\fC [virtual]\fP</h3>
<p>Will always return TRUE in Coin.</p><p>Implements <strong>SoElement</strong>.</p>
<h3>\fBSoElement\fP * SoLazyElement::copyMatchInfo (void) const\fC [virtual]\fP</h3>
<p>Just returns NULL in Coin.</p><p>Implements <strong>SoElement</strong>.</p>
<h3>void SoLazyElement::setToDefault (\fBSoState\fP *state)\fC [static]\fP</h3>
<p>Internal function used for resetting the OpenGL state before FBO rendering.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoLabel.3.html"><span aria-hidden="true">&larr;</span> SoLabel.3: The solabel class is a node for holding label information in a scene graph.  use this node as a convenient way of labeling nodes or subgraphs within a scene graph.</a></li>
   <li class="next"><a href="SoLevelOfDetail.3.html">SoLevelOfDetail.3: The solevelofdetail class is used to choose a child based on projected size.  a level-of-detail mechanism is typically used by application programmers to assist the library in speeding up the rendering. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

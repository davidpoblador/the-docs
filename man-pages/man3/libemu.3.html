<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libemu: Emulate x86 shellcodes</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Emulate x86 shellcodes">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libemu (3) manual">
  <meta name="twitter:description" content="Emulate x86 shellcodes">
  <meta name="twitter:image" content="https://www.carta.tech/images/libemu2-libemu-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libemu.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libemu (3) manual" />
  <meta property="og:description" content="Emulate x86 shellcodes" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libemu2-libemu-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libemu<small> (3)</small></h1>
        <p class="lead">Emulate x86 shellcodes</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libemu.3.html">
      <span itemprop="name">libemu: Emulate x86 shellcodes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libemu2/">
      <span itemprop="name">libemu2</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libemu.3.html">
      <span itemprop="name">libemu: Emulate x86 shellcodes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;emu/emu.h&gt;
#include &lt;emu/emu_memory.h&gt;
#include &lt;emu/emu_cpu.h&gt;


struct emu * emu_new ()
void emu_free (struct emu *e)
struct emu_memory * emu_memory_get (struct emu *e)
struct emu_logging * emu_logging_get (struct emu *e)
struct emu_cpu * emu_cpu_get (struct emu *e)
void emu_errno_set (struct emu *e, int err)
int emu_errno (struct emu *c)
void emu_strerror_set (struct emu *e,
const char *format,...)
const char * emu_strerror (struct emu *e)

void emu_memory_clear (struct emu_memory *em)
int32_t emu_memory_read_byte (struct emu_memory *m,
uint32_t addr, uint8_t *byte)
int32_t emu_memory_read_word (struct emu_memory *m,
uint32_t addr, uint16_t *word)
int32_t emu_memory_read_dword (struct emu_memory *m,
uint32_t addr, uint32_t *dword)
int32_t emu_memory_read_block (struct emu_memory *m,
uint32_t addr, void *dest, size_t len)
int32_t emu_memory_read_string (struct emu_memory *m,
uint32_t addr, struct emu_string *s, uint32_t maxsize)
int32_t emu_memory_write_byte (struct emu_memory *m,
uint32_t addr, uint8_t byte)
int32_t emu_memory_write_word (struct emu_memory *m,
uint32_t addr, uint16_t word)
int32_t emu_memory_write_dword (struct emu_memory *m,
uint32_t addr, uint32_t dword)
int32_t emu_memory_write_block (struct emu_memory *m,
uint32_t addr, void *src, size_t len)
void emu_memory_segment_select (struct emu_memory *m,
enum emu_segment s)
enum emu_segment emu_memory_segment_get (struct emu_memory *m)
int32_t emu_memory_alloc (struct emu_memory *m,
uint32_t *addr, size_t len)
uint32_t emu_memory_get_usage (struct emu_memory *m)
void emu_memory_mode_ro (struct emu_memory *m)
void emu_memory_mode_rw (struct emu_memory *m)

uint32_t emu_cpu_reg32_get (struct emu_cpu *cpu_p, enum emu_reg32 reg)
uint16_t emu_cpu_reg16_get (struct emu_cpu *cpu_p, enum emu_reg16 reg)
uint8_t  emu_cpu_reg8_get  (struct emu_cpu *cpu_p, enum emu_reg8  reg)
void emu_cpu_reg16_set (struct emu_cpu *cpu_p, enum emu_reg16 reg, uint16_t val)
void emu_cpu_reg32_set (struct emu_cpu *cpu_p, enum emu_reg32 reg, uint32_t val)
void emu_cpu_reg8_set  (struct emu_cpu *cpu_p, enum emu_reg8 reg,  uint8_t val)
uint32_t emu_cpu_eflags_get (struct emu_cpu *c)
void emu_cpu_eflags_set (struct emu_cpu *c, uint32_t val)
void emu_cpu_eip_set (struct emu_cpu *c, uint32_t eip)
uint32_t emu_cpu_eip_get (struct emu_cpu *c)
int32_t emu_cpu_parse (struct emu_cpu *c)
int32_t emu_cpu_step (struct emu_cpu *c)
int32_t emu_cpu_run (struct emu_cpu *c)
void emu_cpu_debug_print (struct emu_cpu *c)

int32_t emu_shellcode_test(struct emu *e, uint8_t *data, uint16_t size)

struct emu_env_w32 *emu_env_w32_new(struct emu *e)
void emu_env_w32_free(struct emu_env_w32 *env)
struct emu_env_w32_dll_export *emu_env_w32_eip_check(struct emu_env_w32 *env)
int32_t emu_env_w32_export_hook(struct emu_env_w32 *env,
const char *dllname,
const char *exportname,
int32_t (*fnhook) (struct emu_env_w32 *env, struct emu_env_w32_dll_export *ex)
);


</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>libemu provides basic x86 emulation including memory access and registers.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ROUTINES</h2>
        <div class="sectioncontent">
<p><strong>emu_new()</strong> is used to create a new emulation entity, use <strong>emu_free()</strong> to free all associated memory. <strong>emu_memory_get()</strong> , <strong>emu_logging_get()</strong> and <strong>emu_cpu_get()</strong> can be used to obtain pointers to different parts of the emulation. For errorhandling, use <strong>emu_errno()</strong> or <strong>emu_strerror()</strong> returning either a POSIX errno or a string describing the error. When writing extensions <strong>emu_errno_set()</strong> and <strong>emu_strerror_set()</strong> will come handy too.</p><p>The <strong>emu_memory</strong> is split up in pages, therefore there are functions to access the memory without taking care of page borders. <strong>emu_memory_read_byte()</strong> , <strong>emu_memory_read_word()</strong> , <strong>emu_memory_read_dword()</strong> , <strong>emu_memory_read_string()</strong> and <strong>emu_memory_read_block()</strong> can be used to read values from the emu memory. <strong>emu_memory_read_string()</strong> will allocate the required memory for the string within the <strong>emu_string</strong> provided by itself, as you won't be able to know the strings length, in all other cases, the pointer to the location has to provide enough space to write the data.</p><p>Once the emulation is created, code is written to the memory, we need to set the registers to the initial values, the cpuflags to the start values and EIP to the point where to start code execution. <strong>emu_cpu</strong> provides functions to access all registers, the flags and EIP for read and write. To access the 32bit registers use <strong>emu_cpu_reg32_get()</strong> and <strong>emu_cpu_reg32_set()</strong> where <em>reg</em> is one of eax, ecx, edx, ebx, esp, ebp, esi, edi. To access the 16bit registers use <strong>emu_cpu_reg16_get()</strong> and <strong>emu_cpu_reg16_set()</strong> with ax, cx, dx, bx, sp, bp, si, di as valid values for <em>reg.</em> In case of 8bit register access use <strong>emu_cpu_reg8_get()</strong> and <strong>emu_cpu_reg8_set()</strong> with al, cl, dl, bl, ah, ch, dh, bh as values for <em>reg</em>. Accessing the cpu's flags is possible using <strong>emu_cpu_eflags_get()</strong> and <strong>emu_cpu_eflags_set()</strong>. Accessing EIP can be done using <strong>emu_cpu_eip_set()</strong> and <strong>emu_cpu_eip_get()</strong>. Once everything is setup, parse the first instruction using <strong>emu_cpu_parse()</strong> , on success it will return 0, on failure use <strong>emu_strerror()</strong> to get a description of the error. If parsing was successfull, step the first instruction using <strong>emu_cpu_step()</strong>.</p><p>If you want to detect shellcodes in buffers, use <strong>emu_shellcode_test()</strong> , the emu will copy the buffer to it's pages and try to detect a shellcode. If a possible shellcode gets detected, the guessed starting offset is returned, else -1.</p><p>To be able to run shellcodes using windows api, one has to provide parts of the windows process environment to the emulation, as well as some kind of emulation for the used api calls. <strong>emu_env_w32_new()</strong> will created a minimalistic process environment in <em>e</em> and using <strong>emu_env_w32_eip_check()</strong> after step allows you intercepting calls to exported api. If the return value of <strong>emu_env_w32_eip_check()</strong> is not NULL, the dll exports information is returned, including the calls name and hook. If you want to hook calls to api exports, use <strong>emu_env_w32_export_hook()</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Markus Koetter &lt;nepenthesdev@gmail.com&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libefence.3.html"><span aria-hidden="true">&larr;</span> libefence.3: Electric fence malloc debugger</a></li>
   <li class="next"><a href="libexpect.3.html">libexpect.3: Programmed dialogue library with interactive programs <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

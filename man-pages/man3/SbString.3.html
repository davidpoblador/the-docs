<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SbString: The sbstring class is a string class with convenience functions for string operations.  this is the class used for storing and working with character strings. it automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sbstring class is a string class with convenience functions for string operations.  this is the class used for storing and working with character strings. it automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SbString (3) manual">
  <meta name="twitter:description" content="The sbstring class is a string class with convenience functions for string operations.  this is the class used for storing and working with character strings. it automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SbString-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SbString.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SbString (3) manual" />
  <meta property="og:description" content="The sbstring class is a string class with convenience functions for string operations.  this is the class used for storing and working with character strings. it automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SbString-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SbString<small> (3)</small></h1>
        <p class="lead">The sbstring class is a string class with convenience functions for string operations.  this is the class used for storing and working with character strings. it automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SbString.3.html">
      <span itemprop="name">SbString: The sbstring class is a string class with convenience functions for string operations.  this is the class used for storing and working with character strings. it automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SbString.3.html">
      <span itemprop="name">SbString: The sbstring class is a string class with convenience functions for string operations.  this is the class used for storing and working with character strings. it automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SbString.h&gt;</p><h3>Public Member Functions</h3>
<p><strong>SbString</strong> (void)</p><p><strong>SbString</strong> (const char *s)</p><p><strong>SbString</strong> (const char *s, int start, int end)</p><p><strong>SbString</strong> (const <strong>SbString</strong> &s)</p><p><strong>SbString</strong> (const int digits)</p><p><strong>~SbString</strong> ()</p><p>uint32_t <strong>hash</strong> (void) const </p><p>int <strong>getLength</strong> (void) const </p><p>void <strong>makeEmpty</strong> (SbBool freeold=TRUE)</p><p>const char * <strong>getString</strong> (void) const </p><p><strong>SbString</strong> <strong>getSubString</strong> (int startidx, int endidx=-1) const </p><p>void <strong>deleteSubString</strong> (int startidx, int endidx=-1)</p><p>void <strong>addIntString</strong> (const int value)</p><p>char <strong>operator[]</strong> (int index) const </p><p><strong>SbString</strong> & <strong>operator=</strong> (const char *s)</p><p><strong>SbString</strong> & <strong>operator=</strong> (const <strong>SbString</strong> &s)</p><p><strong>SbString</strong> & <strong>operator+=</strong> (const char *s)</p><p><strong>SbString</strong> & <strong>operator+=</strong> (const <strong>SbString</strong> &s)</p><p><strong>SbString</strong> & <strong>operator+=</strong> (const char c)</p><p>int <strong>operator!</strong> (void) const </p><p>int <strong>compareSubString</strong> (const char *text, int offset=0) const </p><p><strong>SbString</strong> & <strong>sprintf</strong> (const char *formatstr,...)</p><p><strong>SbString</strong> & <strong>vsprintf</strong> (const char *formatstr, va_list args)</p><p>void <strong>apply</strong> (char(*func)(char input))</p><p>int <strong>find</strong> (const <strong>SbString</strong> &s) const </p><p>SbBool <strong>findAll</strong> (const <strong>SbString</strong> &s, <strong>SbIntList</strong> &found) const </p><p><strong>SbString</strong> <strong>lower</strong> () const </p><p><strong>SbString</strong> <strong>upper</strong> () const </p><p>void <strong>print</strong> (std::FILE *fp) const </p>
<h3>Static Public Member Functions</h3>
<p>static uint32_t <strong>hash</strong> (const char *s)</p>
<h3>Friends</h3>
<p>int <strong>operator==</strong> (const <strong>SbString</strong> &sbstr, const char *s)</p><p>int <strong>operator==</strong> (const char *s, const <strong>SbString</strong> &sbstr)</p><p>int <strong>operator==</strong> (const <strong>SbString</strong> &str1, const <strong>SbString</strong> &str2)</p><p>int <strong>operator!=</strong> (const <strong>SbString</strong> &sbstr, const char *s)</p><p>int <strong>operator!=</strong> (const char *s, const <strong>SbString</strong> &sbstr)</p><p>int <strong>operator!=</strong> (const <strong>SbString</strong> &str1, const <strong>SbString</strong> &str2)</p><p>const <strong>SbString</strong> <strong>operator+</strong> (const <strong>SbString</strong> &str1, const <strong>SbString</strong> &str2)</p><p>const <strong>SbString</strong> <strong>operator+</strong> (const <strong>SbString</strong> &sbstr, const char *s)</p><p>const <strong>SbString</strong> <strong>operator+</strong> (const char *s, const <strong>SbString</strong> &sbstr)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SbString</strong> class is a string class with convenience functions for string operations.</p><p>This is the class used for storing and working with character strings. It automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc.</p><p>This class should also be well suited for use by the application programmer throughout the application using the Coin library.</p><p><strong>See also:</strong></p><p><strong>SbName</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SbString::SbString (void)\fC [inline]\fP</h3>
<p>This is the default constructor. It initializes the string to be empty.</p>
<h3>SbString::SbString (const char *str)\fC [inline]\fP</h3>
<p>This constructor assigns from the given string.</p>
<h3>SbString::SbString (const char *str, intstart, intend)\fC [inline]\fP</h3>
<p>This constructor constructs a string from the given substring from <em>start</em> to <em>end</em> indices inclusive. If <em>end</em> is -1, the substring from <em>start</em> until the end of the string is used.</p>
<h3>SbString::SbString (const \fBSbString\fP &str)\fC [inline]\fP</h3>
<p>This is the copy constructor.</p>
<h3>SbString::SbString (const intdigits)\fC [inline]\fP</h3>
<p>Construct an <strong>SbString</strong> instance containing the <em>digits</em> of the integer argument.</p>
<h3>SbString::~SbString ()\fC [inline]\fP</h3>
<p>The destructor. Deallocates any internal resources used during the lifetime of the <strong>SbString</strong> instance.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>uint32_t SbString::hash (void) const\fC [inline]\fP</h3>
<p>This method returns a reasonable hash value for the current string.</p><p><strong>See also:</strong></p><p>uint32_t <strong>SbString::hash(const char * s)</strong></p>
<h3>uint32_t SbString::hash (const char *s)\fC [inline]\fP, \fC [static]\fP</h3>
<p>This static method returns a hash value for the given string.</p>
<h3>int SbString::getLength (void) const\fC [inline]\fP</h3>
<p>This method returns the length of the string.</p>
<h3>void SbString::makeEmpty (SbBoolfreeold = \fCTRUE\fP)\fC [inline]\fP</h3>
<p>This method clears the string, making it an empty string (''). If <em>freeold</em> is TRUE<em> (which is the default), the memory used by the old string is freed. Otherwise, memory will be kept and reused when the string is manipulated later.</em></p>
<h3>const char * SbString::getString (void) const\fC [inline]\fP</h3>
<p>This method returns the pointer to the string (character array).</p>
<h3>\fBSbString\fP SbString::getSubString (intstartidx, intendidx = \fC-1\fP) const\fC [inline]\fP</h3>
<p>This method returns a new string which contains a substring defined by the given indices <em>startidx</em> and <em>endidx</em> (inclusive).</p><p>If <em>endidx</em> is -1, the substring from <em>startidx</em> to the end of the string is used.</p><p>This will return a string which is (<em>endidx</em> - <em>startidx</em> + 1) characters long, i.e. if this string is 'foo/bar' and we call by SbString::getSubString(0, 3), the returned string will be 'foo/'.</p>
<h3>void SbString::deleteSubString (intstartidx, intendidx = \fC-1\fP)\fC [inline]\fP</h3>
<p>This method deletes the substring defined by <em>startidx</em> and <em>endidx</em> (inclusive). If <em>endidx</em> is -1, the substring from <em>startidx</em> to the end of the string is deleted.</p>
<h3>void SbString::addIntString (const intvalue)\fC [inline]\fP</h3>
<p>Constructs a string from the given integer (e.g. intToString(42) creates the string '42'), and adds this to the contents of the string.</p>
<h3>char SbString::operator[] (intindex) const\fC [inline]\fP</h3>
<p>Returns character at position <em>index</em> in the string.</p><p><strong>See also:</strong></p><p><strong>getSubString()</strong></p>
<h3>\fBSbString\fP & SbString::operator= (const char *str)\fC [inline]\fP</h3>
<p>This is the assignment operator.</p>
<h3>\fBSbString\fP & SbString::operator= (const \fBSbString\fP &str)\fC [inline]\fP</h3>
<p>Assign from the given string.</p>
<h3>\fBSbString\fP & SbString::operator+= (const char *str)\fC [inline]\fP</h3>
<p>Concatenate the given string to the end of the current one.</p>
<h3>\fBSbString\fP & SbString::operator+= (const \fBSbString\fP &str)\fC [inline]\fP</h3>
<p>Concatenate the given string to the end of the current one.</p>
<h3>\fBSbString\fP & SbString::operator+= (const charc)\fC [inline]\fP</h3>
<p>Concatenate the given character to the end of the current string.</p><p><strong>Note:</strong></p><p>This member function is not compatible with OpenInventor.</p>
<h3>int SbString::operator! (void) const\fC [inline]\fP</h3>
<p>This unary operator results in TRUE if the current string is empty ('') or FALSE otherwise.</p>
<h3>int SbString::compareSubString (const char *text, intoffset = \fC0\fP) const\fC [inline]\fP</h3>
<p>Uses <em>text</em> as a substring to be compared to the string, starting at offset <em>offset</em>. Return value is 0 upon success, and the failing character comparison difference upon failure.</p>
<h3>\fBSbString\fP & SbString::sprintf (const char *formatstr, ...)\fC [inline]\fP</h3>
<p>Set <strong>SbString</strong> instance to the formatted string <em>formatstr</em>, replacing the current contents. The control characters within <em>formatstr</em> and the remaining arguments should follow the conventions of the printf() call.</p><p>Note that this function is not part of the original Open Inventor API.</p>
<h3>\fBSbString\fP & SbString::vsprintf (const char *formatstr, va_listargs)\fC [inline]\fP</h3>
<p>Set <strong>SbString</strong> instance to the formatted string <em>formatstr</em>, replacing the current contents. The control characters within <em>formatstr</em> and the arguments of the <em>args</em> argument list should follow the conventions of the printf() call.</p><p>Note that this function is not part of the original Open Inventor API.</p>
<h3>int SbString::find (const \fBSbString\fP &strarg) const</h3>
<p>If <em>s</em> is found, the method returns the first index where <em>s</em> starts. Otherwise it returns -1.</p><p>Note: <strong>SbString::find()</strong> is a Coin specific extension to the original Open Inventor API.</p><p><strong>See also:</strong></p><p><strong>SbString::findAll()</strong></p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>SbBool SbString::findAll (const \fBSbString\fP &strarg, \fBSbIntList\fP &found) const</h3>
<p>All occurences of <em>str</em> is represented in <em>found</em> as indices to the characters where <em>str</em> starts. If 1 or more is found, TRUE<em> is returned, else FALSE</em> is returned.</p><p>Note: <strong>SbString::findAll()</strong> is an extension to the original Open Inventor API.</p><p><strong>See also:</strong></p><p><strong>SbString::find()</strong></p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>\fBSbString\fP SbString::lower () const</h3>
<p>Converts all of the characters to lowercase using tolower().</p><p><strong>Since:</strong></p><p>Coin 3.1</p>
<h3>\fBSbString\fP SbString::upper () const</h3>
<p>Converts all of the characters to uppercase using toupper().</p><p><strong>Since:</strong></p><p>Coin 3.1</p>
<h3>void SbString::print (std::FILE *fp) const</h3>
<p>Dump the state of this object to the <em>file</em> stream. Only works in debug version of library, method does nothing in an optimized compile.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Friends And Related Function Documentation</h2>
        <div class="sectioncontent">
<h3>int operator== (const \fBSbString\fP &str, const char *s)\fC [friend]\fP</h3>
<p>Equality operator. Check if the strings have the same contents.</p>
<h3>int operator== (const char *s, const \fBSbString\fP &str)\fC [friend]\fP</h3>
<p>Equality operator. Check if the strings have the same contents.</p>
<h3>int operator== (const \fBSbString\fP &str1, const \fBSbString\fP &str2)\fC [friend]\fP</h3>
<p>Equality operator. Check if the strings have the same contents.</p>
<h3>int \fBoperator!\fP= (const \fBSbString\fP &str, const char *s)\fC [friend]\fP</h3>
<p>Inequality operator.</p>
<h3>int \fBoperator!\fP= (const char *s, const \fBSbString\fP &str)\fC [friend]\fP</h3>
<p>Inequality operator.</p>
<h3>int \fBoperator!\fP= (const \fBSbString\fP &str1, const \fBSbString\fP &str2)\fC [friend]\fP</h3>
<p>Inequality operator.</p>
<h3>const \fBSbString\fP operator+ (const \fBSbString\fP &str1, const \fBSbString\fP &str2)\fC [friend]\fP</h3>
<p>Addition operator.</p>
<h3>const \fBSbString\fP operator+ (const \fBSbString\fP &sbstr, const char *s)\fC [friend]\fP</h3>
<p>Addition operator.</p>
<h3>const \fBSbString\fP operator+ (const char *s, const \fBSbString\fP &sbstr)\fC [friend]\fP</h3>
<p>Addition operator.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SbSphereSheetProjector.3.html"><span aria-hidden="true">&larr;</span> SbSphereSheetProjector.3: The sbspheresheetprojector class projects 2d points to 3d points on a sheet covering a spherical shape.  the following stand-alone example shows how screen space coordinates projects into 3d when mapped with an sbspheresheetprojector. it outputs the resulting projections as an sopointset in a inventor-file on stdout:</a></li>
   <li class="next"><a href="SbStringList.3.html">SbStringList.3: The sbstringlist class is a container for arrays of sbstring pointers.  note that upon using the equality and inequality operators, the strings themselves are not compared, only the pointer values. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Eval::Context: </title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Eval::Context (3pm) manual">
  <meta name="twitter:description" content="">
  <meta name="twitter:image" content="https://www.carta.tech/images/libeval-context-perl-Eval::Context-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Eval::Context.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Eval::Context (3pm) manual" />
  <meta property="og:description" content="" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libeval-context-perl-Eval::Context-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Eval::Context<small> (3pm)</small></h1>
        <p class="lead"></p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Eval::Context.3pm.html">
      <span itemprop="name">Eval::Context: </span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libeval-context-perl/">
      <span itemprop="name">libeval-context-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Eval::Context.3pm.html">
      <span itemprop="name">Eval::Context: </span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>        use Eval::Context ;</p><p>        my $context = new Eval::Context(PRE_CODE =&gt; "use strict;&#92;nuse warnings;&#92;n") ;</p><p>        # code will be evaluated with strict and warnings loaded in the context.</p><p>        $context-&gt;eval(CODE =&gt; &apos;print "evaluated in an Eval::Context!" ;&apos;) ;         $context-&gt;eval(CODE_FROM_FILE =&gt; &apos;file.pl&apos;) ;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module define a subroutine that let you evaluate Perl code in a specific context. The code can be passed directly as a string or as a file name to read from. It also provides some subroutines to let you define and optionally share variables and subroutines between your code and the code you wish to evaluate. Finally there is some support for running your code in a safe compartment.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Don't play with fire!</h2>
        <div class="sectioncontent">
<p>Don't start using this module, or any other module, thinking it will let you take code from anywhere and be safe. Read perlsec, Safe, Opcode, Taint and other security related documents. Control your input.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBROUTINES/METHODS</h2>
        <div class="sectioncontent">
<p>Subroutines that are not part of the public interface are marked with [p].</p><h3>new(@named_arguments)</h3>
<p>Create an Eval::Context object.  The object is used as a repository of \*(L"default\*(R" values for your code evaluations. The context can be used many times. The values can be temporarily overridden during the \*(C`eval\*(C' call.</p><p>  my $context = new Eval::Context() ; # default context</p><p>  my $context = new Eval::Context                 (                 NAME              =&gt; &apos;libraries evaluation context&apos;,                 PACKAGE           =&gt; &apos;libraries&apos;,                 SAFE              =&gt; {...} ;</p><p>                PRE_CODE          =&gt; "use strict ;&#92;n"                 POST_CODE         =&gt; sub{},                 PERL_EVAL_CONTEXT =&gt; undef,</p><p>                INSTALL_SUBS      =&gt; {...},                 INSTALL_VARIABLES =&gt; [...],                 EVAL_SIDE_PERSISTENT_VARIABLES =&gt; {...},</p><p>                INTERACTION =&gt; {...},                 DISPLAY_SOURCE_IN_CONTEXT =&gt; 1, #useful when debuging                 ) ;</p><p><em>\s-1ARGUMENTS\s0</em></p><ul>
<li><p>@named_arguments - setup data for the object All the arguments optional. The argument passed to \*(C`new\*(C' can also be passed to \*(C`eval\*(C'. All arguments are named.</p><ul>
<li><p>\s-1NAME\s0 - use when displaying information about the object. Set automatically to 'Anonymous' if not set. The name will also be reported by perl if an error occurs during your code evaluation.</p></li><li><p>\s-1PACKAGE\s0 - the package the code passed to \*(C`eval\*(C' will evaluated be in. If not set, a unique package name is generated and used for every \*(C`eval\*(C' call.</p></li><li><p>\s-1REMOVE_PACKAGE_AFTER_EVAL\s0 - When set the content of the package after evaluation will be erase The default behavior is to remove all data from after the call to \*(C`eval\*(C'.</p></li><li><p>\s-1PRE_CODE\s0 - code prepended to the code passed to <em>eval</em></p></li><li><p>\s-1POST_CODE\s0 - code appended to the code passed to <em>eval</em></p></li><li><p>\s-1PERL_EVAL_CONTEXT\s0 - the context to eval code in (void, scalar, list). This option Works as  \*(L"wantarray\*(R" in perlfunc. It will override the context in which \*(C`eval\*(C' is called.</p></li><li><p>\s-1INSTALL_SUBS\s0 - subs that will be available in the eval. A hash where the keys are a function names and the values a code references.</p></li><li><p>\s-1SAFE\s0 This argument must be a hash reference. if the hash is empty, a default safe compartment will be used. Read Safe documentation for more information.         SAFE =&gt; {} # default safe environment You can have a finer control over the safe compartment <strong>Eval::Context</strong> that will be used.         my $compartment = new Safe(&apos;ABC&apos;) ;</p><p>        my $context = new Eval::Context                 (                 SAFE =&gt; # controlling the safe environment                         {                         PACKAGE     =&gt; &apos;ABC&apos;,                         PRE_CODE    =&gt; "use my module ;&#92;n" # code we consider safe                         USE_STRICT  =&gt; 0,                # set to 1 by default                         COMPARTMENT =&gt; $compartment ,   # use default if not passed                         } ,                 }</p><p>        $context-&gt;eval(CODE =&gt; .....) ;</p><ul>
<li><p>\s-1COMPARTMENT\s0 - a Safe object, you create, that will be used by <strong>Eval::Context</strong></p></li><li><p>\s-1USE_STRICT\s0 - Controls if strict is used in the Safe compartment The default is to use strict. Note that \*(L"Safe\*(R" in perldoc default is to \s-1NOT\s0 use strict (undocumented).</p></li><li><p>\s-1PRE_CODE\s0 - safe code you want to evaluate in the same context as the unsafe code This let you, for example, use certain modules which provide subroutines to be used in the evaluated code. The default compartment is quite restrictive and you can't even use strict in it without tuning the safe compartment.</p></li>
</ul><p>A few remarks: - See &lt;http://rt.cpan.org/Ticket/Display.html?id=31090&gt; on \s-1RT\s0 - Pass the same package name to your safe compartment and to <strong>Eval::Context</strong>. - If you really want to be on the safe side, control your input. When you use a module, are you sure the module hasn't been fiddle with? - Leave strict on. Even for trivial code.</p></li><li><p>\s-1INSTALL_VARIABLES\s0 - \*(L"Give me sugar baby\*(R" Ash. <strong>Eval::Context</strong> has mechanisms you can use to set and share variables with the code you will evaluate. There are two sides in an <strong>Eval::Context</strong>. The <em>caller-side</em>, the side where the calls to \*(C`eval\*(C' are made and the <em>eval-side</em>, the side where the code to be evaluated is run.</p><ul>
<li><p>How should you get values back from the eval-side Although you can use the mechanisms below to get values from the <em>eval-side</em>, the cleanest way is to get the results directly from the \*(C`eval\*(C' call.         my $context = new Eval::Context() ;</p><p>        my ($scalr_new_value, $a_string) =                 $context-&gt;eval                         (                         INSTALL_VARIABLES =&gt;[[ &apos;$scalar&apos;  =&gt; 42]] ,                         CODE =&gt; "&#92;$scalar++ ;&#92;n (&#92;$scalar, &apos;a string&apos;) ;",                         ) ;</p></li><li><p>initializing variables on the <em>eval side</em> You can pass <strong>\s-1INSTALL_VARIABLES\s0</strong> to \*(C`new\*(C' or \*(C`eval\*(C'. You can initialize different variables for each run of \*(C`eval\*(C'.         my $context = new Eval::Context                 (                 INSTALL_VARIABLES =&gt;                         [                         # variables on eval-side    #initialization source                         [ &apos;$data&apos;                =&gt; 42],                         [ &apos;$scalar&apos;              =&gt; $scalar_caller_side ],                         [ &apos;%hash&apos;                =&gt; &#92;%hash_caller_side ]                         [ &apos;$hash&apos;                =&gt; &#92;%hash_caller_side ],                         [ &apos;$object&apos;              =&gt; $object ],                         ] ,                 ) ; The variables will be <strong>my</strong> variables on the eval-side. You can declare variables of any of the base types supported by perl. The initialization data , on the caller-side, is serialized and deserialized to make the values available on the eval-side. Modifying the variables on the eval-side does not modify the variables on the caller-side. The initialization data can be scalars or references and even <strong>my</strong> variables.</p></li><li><p>Persistent variables When evaluating code many times in the same context, you may wish to have variables persist between evaluations. <strong>Eval::Context</strong> allows you to declare, define and control such <em>state</em> variables. This mechanism lets you control which variables are persistent. Access to the persistent variables is controlled per \*(C`eval\*(C' run. Persistent variables are <strong>my</strong> variables on the <em>eval-side</em>. Modifying the variables on the eval-side does not modify the variables on the <em>caller-side</em>. Define persistent variables:         # note: creating persistent variables in &apos;new&apos; makes little sense as         # it will force those values in the persistent variables for every run.         # This may or may not be what you want.</p><p>        my $context = new Eval::Context() ;</p><p>        $context-&gt;eval                 (                 INSTALL_VARIABLES =&gt;                         [                         [ &apos;$scalar&apos;  =&gt; 42                 =&gt; $Eval::Context::PERSISTENT ] ,</p><p>                        # make %hash and $hash available on the eval-side. both are                         # initialized from the same caller-side hash                         [ &apos;%hash&apos;    =&gt; &#92;%hash_caller_side =&gt; $Eval::Context::PERSISTENT ] ,                         [ &apos;$hash&apos;    =&gt; &#92;%hash_caller_side =&gt; $Eval::Context::PERSISTENT ] ,                         ],                 CODE =&gt; &apos;$scalar++&apos;,                 ) ; Later, use the persistent value:         $context-&gt;eval                 (                 INSTALL_VARIABLES =&gt;                         [                         [ &apos;$scalar&apos;  =&gt; $Eval::Context::USE =&gt; $Eval::Context::PERSISTENT ] ,                         # here you decided %hash and $hash shouldn&apos;t be available on the eval-side                         ],</p><p>                CODE =&gt; &apos;$scalar&apos;,                 ) ; <strong></strong><strong>$Eval::Context::USE</strong><strong></strong> means <em>\*(L"make the persistent variable and it's value available on the eval-side\*(R"</em>. Any other value will reinitialize the persistent variable. See also <strong>\s-1REMOVE_PERSISTENT\s0</strong> in \*(C`eval\*(C'.</p></li><li><p>Manually synchronizing caller-side data with persistent eval-side data Although the first intent of persistent variables is to be used as state variables on the eval-side, you can get persistent variables values on the caller-side. To change the value of an <em>eval-side</em> persistent variable, simply reinitialize it with <strong>\s-1INSTALL_VARIABLES\s0</strong> next time you call \*(C`eval\*(C'.         my $context = new Eval::Context                         (                         INSTALL_VARIABLES =&gt;                                 [                                 [&apos;%hash&apos; =&gt; &#92;%hash_caller_side =&gt; $Eval::Context::PERSISTENT]                                 ] ,                         ) ;</p><p>        $context-&gt;Eval(CODE =&gt; &apos;$hash{A}++ ;&apos;) ;</p><p>        # throws exception if you request a non existing variable         my %hash_after_eval = $context-&gt;GetPersistantVariables(&apos;%hash&apos;) ;</p></li><li><p>Getting the list of all the \s-1PERSISTENT\s0 variables         my @persistent_variable_names = $context-&gt;GetPersistantVariablesNames() ;</p></li><li><p>Creating persistent variables on the eval-side The mechanism above gave you fine control over persistent variables on the <em>eval-side</em>. The negative side is that <strong>only</strong> the variables you made persistent exist on the <em>eval-side</em>. <strong>Eval::Context</strong> has another mechanism that allows the <em>eval-side</em> to store variables between evaluations without the <em>caller-side</em> declaration of the variables. To allow the <em>eval-side</em> to store any variable, add this to you \*(C`new\*(C' call.         my $context = new Eval::Context                 (                 PACKAGE =&gt; &apos;my_package&apos;,</p><p>                EVAL_SIDE_PERSISTENT_VARIABLES =&gt;                         {                         SAVE =&gt; { NAME =&gt; &apos;SavePersistent&apos;, VALIDATOR =&gt; sub{} },                         GET  =&gt; { NAME =&gt; &apos;GetPersistent&apos;,  VALIDATOR =&gt; sub{} },                         },                 ) ; The <em>eval-side</em> can now store variables between calls to \*(C`eval\*(C'         SavePersistent(&apos;name&apos;, $value) ; later in another call to \*(C`eval\*(C':         my $variable = GetPersistent(&apos;name&apos;) ; By fine tuning <strong>\s-1EVAL_SIDE_PERSISTENT_VARIABLES\s0</strong> you can control what variables are stored by the <em>eval-side</em>. This should seldom be used and only to help those storing data from the <em>eval-side</em>. You may have notices in the code above that a package name was passed as argument to \*(C`new\*(C'. This is very important as the package names that are automatically generated differ for each \*(C`eval\*(C' call. If you want to run all you <em>eval-side</em> code in different packages (<strong>Eval::Context</strong> default behavior), you must tell <strong>Eval::Context</strong> where to store the <em>eval-side</em> values. This is done by setting <strong>\s-1CATEGORY\s0</strong> The validator sub can verify if the value to be stored are valid, E.G.: variable name, variable value is within range, ... Here is an example of code run in different packages but can share variables. Only variables which names start with <em>A</em> are valid.         new Eval::Context                 (                 EVAL_SIDE_PERSISTENT_VARIABLES =&gt;                         {                         CATEGORY =&gt; &apos;TEST&apos;,                         SAVE =&gt;                                 {                                 NAME =&gt; &apos;SavePersistent&apos;,                                 VALIDATOR =&gt; sub                                         {                                         my ($self, $name, $value, $package) = @_ ;                                         $self-&gt;{INTERACTION}{DIE}-&gt;                                                 (                                                 $self,                                                 "SavePersistent: name &apos;$name&apos; doesn&apos;t start with A!"                                                 )  unless $name =~ /^A/ ;                                         },                                 },</p><p>                        GET =&gt; {NAME =&gt; &apos;GetPersistent&apos;,VALIDATOR =&gt; sub {}},                         },                 ) ;</p><p>        $context-&gt;eval(CODE =&gt; &apos;SavePersistent(&apos;A_variable&apos;, 123) ;&apos;) ; later:         $context-&gt;eval(CODE =&gt; &apos;GetPersistent(&apos;A_variable&apos;) ;&apos;) ;</p></li><li><p>Shared variables You can also share references between the <em>caller-side</em> and the <em>eval-side</em>.         my $context =                 new Eval::Context                         (                         INSTALL_VARIABLES =&gt;                                 [                                 # reference to reference only                                 [ &apos;$scalar&apos; =&gt; &#92;$scalar           =&gt; $Eval::Context::SHARED ],                                 [ &apos;$hash&apos;   =&gt; &#92;%hash_caller_side =&gt; $Eval::Context::SHARED ],                                 [ &apos;$object&apos; =&gt; $object            =&gt; $Eval::Context::SHARED ],                                 ] ,                         ) ; Modification of the variables on the <em>eval-side</em> will modify the variable on the <em>caller-side</em>. There are but a few reasons to share references. Note that you can share references to <strong>my</strong> variables.</p></li>
</ul></li><li><p>\s-1INTERACTION\s0 Lets you define subs used to interact with the user.         INTERACTION      =&gt;                 {                 INFO     =&gt; &#92;&sub,                 WARN     =&gt; &#92;&sub,                 DIE      =&gt; &#92;&sub,                 EVAL_DIE =&gt; &#92;&sub,                 }</p>
<dl class='dl-vertical'>
  <dt>
    \s-1INFO\s0 - defaults to CORE::print
  </dt>
  <dd>
    <p>This sub will be used when displaying information.</p>
  </dd>
  <dt>
    \s-1WARN\s0 - defaults to Carp::carp
  </dt>
  <dd>
    <p>This sub will be used when a warning is displayed.</p>
  </dd>
  <dt>
    \s-1DIE\s0 - defaults to Carp::confess
  </dt>
  <dd>
    <p>Used when an error occurs.</p>
  </dd>
  <dt>
    \s-1EVAL_DIE\s0 - defaults to Carp::confess, with a dump of the code to be evaluated
  </dt>
  <dd>
    <p>Used when an error occurs during code evaluation.</p>
  </dd>

</dl>
</li><li><p>\s-1FILE\s0 - the file where the object has been created. This is practical if you want to wrap the object. <strong>\s-1FILE\s0</strong> and <strong>\s-1LINE\s0</strong> will be set automatically if not set.</p></li><li><p>\s-1LINE\s0 - the line where the object has been created. Set automatically if not set.</p></li><li><p>\s-1DISPLAY_SOURCE_IN_CONTEXT\s0 - if set, the code to evaluated will be displayed before evaluation</p></li>
</ul></li>
</ul><p><em>Return</em></p><ul>
<li><p>an <strong>Eval::Context</strong> object.</p></li>
</ul>
<h3>[p] Setup</h3>
<p>Helper sub called by new.</p>
<h3>[p] CheckOptionNames</h3>
<p>Verifies the named options passed as arguments with a list of valid options. Calls <strong>{\s-1INTERACTION\s0}{\s-1DIE\s0}</strong> in case of error.</p>
<h3>[p] SetInteractionDefault</h3>
<p>Sets {\s-1INTERACTION\s0} fields that are not set by the user.</p>
<h3>[p] CanonizeName</h3>
<p>Transform a string into a a string with can be used as a package name or file name usable within perl code.</p>
<h3>eval(@named_arguments)</h3>
<p>Evaluates Perl code, passed as a string or read from a file, in the context.</p><p>        my $context = new Eval::Context(PRE_CODE =&gt; "use strict;&#92;nuse warnings;&#92;n") ;</p><p>        $context-&gt;eval(CODE =&gt; &apos;print "evaluated in an Eval::Context!";&apos;) ;         $context-&gt;eval(CODE_FROM_FILE =&gt; &apos;file.pl&apos;) ;</p><p><em>Call context</em></p><p>Evaluation context of the code (void, scalar, list) is the same as the context this subroutine was called in or in the context defined by <strong>\s-1PERL_EVAL_CONTEXT\s0</strong> if that option is present.</p><p><em>Arguments</em></p><p><strong>\s-1NOTE:\s0 You can override any argument passed to </strong>\*(C`new\*(C'<strong>. The override is temporary during</strong> the duration of this call.</p><ul>
<li><p>@named_arguments - Any of \*(C`new\*(C' options plus the following.</p><ul>
<li><p>\s-1CODE\s0 - a string containing perl code (valid code or an exception is raised)</p></li><li><p>\s-1CODE_FROM_FILE\s0 - a file containing  perl code</p></li><li><p>\s-1REMOVE_PERSISTENT\s0 A list of regex used to match the persistent variable names to be removed, persistent variable removal is done before any variable installation is done</p></li><li><p>\s-1FILE\s0 and \s-1LINE\s0 - will be used in the evaluated code 'file_name' set to the caller's file and line by default</p></li>
</ul><p>\s-1NOTE:\s0 <strong>\s-1CODE\s0</strong> or <strong>\s-1CODE_FROM_FILE\s0</strong> is <strong>mandatory</strong>.</p></li>
</ul><p><em>Return</em></p><ul>
<li><p>What the code to be evaluated returns</p></li>
</ul>
<h3>[p] VerifyAndCompleteOptions</h3>
<p>Helper sub for \*(C`eval\*(C'.</p>
<h3>[p] EvalCleanup</h3>
<p>Handles the package cleanup or persistent variables cleanup after a call to \*(C`eval\*(C'.</p>
<h3>[p] GetPackageName</h3>
<p>Returns a canonized package name. the name is either passed as argument from the caller or a temporary package name.</p>
<h3>[p] EvalSetup</h3>
<p>Handles the setup of the context before <em>eval-side</em> code is evaluated. Sets the variables and the shared subroutines.</p>
<h3>[p] VerifyCodeInput</h3>
<p>Verify that <strong>\s-1CODE\s0</strong> or <strong>\s-1CODE_FROM_FILE\s0</strong> are properly set.</p>
<h3>[p] RemovePersistent</h3>
<p>Handles the removal of persistent variables.</p>
<h3>[p] GetCallContextWrapper</h3>
<p>Generates perl code to wrap the code to be evaluated in the right calling context.</p>
<h3>[p] SetupSafeCompartment</h3>
<p>If running in safe mode, setup a safe compartment from the argument, otherwise defines the evaluation package.</p>
<h3>[p] GetInstalledVariablesCode</h3>
<p>Generates variables on the eval-side from the \s-1INSTALL_VARIABLES\s0 definitions. Dispatches the generation to specialize subroutines.</p>
<h3>[p] GetPersistentVariablesSetFromCaller</h3>
<p>Generates code to make persistent variables, defined on the <em>caller-side</em> available on the <em>eval-side</em>.</p>
<h3>[p] GetSharedVariablesSetFromCaller</h3>
<p>Handles the mechanism used to share variables (references) between the <em>caller-side</em> and the <em>eval-side</em>.</p><p>Shared variables must be defined and references. If the shared variable is <strong>undef</strong>, the variable that was previously shared, under the passed name, is used if it exists or an exception is raised.</p><p>Also check that variables are not <strong>\s-1PERSISTENT\s0</strong> and <strong>\s-1SHARED\s0</strong>.</p>
<h3>[p] GetVariablesSetFromCaller</h3>
<p>Generates code that creates local variables on the <em>eval-side</em></p>
<h3>\fIGetPersistentVariableNames()\fP</h3>
<p><em>Arguments</em> - none</p><p><em>Returns</em> - the list of existing persistent variables names</p><p>        my @persistent_variable_names = $context-&gt;GetPersistantVariablesNames() ;</p>
<h3>GetPersistantVariables(@variable_names)</h3>
<p><em>Arguments</em></p><ul>
<li><p>@variable_names - list of variable names to retrieve</p></li>
</ul><p><em>Returns</em> - list of values corresponding to the input names</p><p>This subroutine will return whatever the <em>caller-site</em> set or the <em>eval-side</em> modified. Thus if you created a <em></em><strong>%hash</strong><em></em> persistent variable, a hash (not a hash reference) will be returned.</p><p>If you request multiple values, list flattening will be in effect. Be careful.</p><p>        my $context = new Eval::Context                         (                         INSTALL_VARIABLES =&gt;                                 [                                 [&apos;%hash&apos; =&gt; &#92;%hash_caller_side =&gt; $Eval::Context::PERSISTENT]                                 ] ,                         ) ;</p><p>        $context-&gt;Eval(CODE =&gt; &apos;$hash{A}++ ;&apos;) ;</p><p>        # may throw exception         my %hash_after_eval = $context-&gt;GetPersistantVariables(&apos;%hash&apos;) ;</p>
<h3>[p] SetEvalSidePersistenceHandlers</h3>
<p>Set the code needed to handle <em>eval-side</em> persistent variables.</p>
<h3>[p] RemoveEvalSidePersistenceHandlers</h3>
<p>Removes <em>eval-side</em> persistent variable handlers. Used after calling \*(C`eval\*(C' so the next \*(C`eval\*(C' can not access <em>eval-side</em> persistent variables without being allowed to do so.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS AND LIMITATIONS</h2>
        <div class="sectioncontent">
<p>I have reported a very strange error when <strong>Safe</strong> and <strong>Carp</strong> are used together. &lt;http://rt.cpan.org/Ticket/Display.html?id=31090&gt;. The error can be reproduced without using <strong>Eval::Context</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>        Khemir Nadim ibn Hamouda         CPAN ID: NKH         mailto:nadim@khemir.net</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>You can find documentation for this module with the perldoc command.</p><p>    perldoc Eval::Context</p><p>You can also look for information at:</p><ul>
<li><p>AnnoCPAN: Annotated \s-1CPAN\s0 documentation http://annocpan.org/dist/Eval-Context &lt;http://annocpan.org/dist/Eval-Context&gt;</p></li><li><p>\s-1RT:\s0 \s-1CPAN\s0's request tracker Please report any bugs or feature requests to  L &lt;bug-eval-context@rt.cpan.org&gt;. We will be notified, and then you'll automatically be notified of progress on your bug as we make changes.</p></li><li><p>Search \s-1CPAN\s0 http://search.cpan.org/dist/Eval-Context &lt;http://search.cpan.org/dist/Eval-Context&gt;</p></li>
</ul>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Eval::Closure.3pm.html"><span aria-hidden="true">&larr;</span> Eval::Closure.3pm: Safely and cleanly create closures via string eval</a></li>
   <li class="next"><a href="Excel::Template.3pm.html">Excel::Template.3pm: Excel::template <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cthread: Lcg thread inferface</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Lcg thread inferface">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Cthread (3) manual">
  <meta name="twitter:description" content="Lcg thread inferface">
  <meta name="twitter:image" content="https://www.carta.tech/images/liblcgdm-dev-Cthread-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/Cthread.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Cthread (3) manual" />
  <meta property="og:description" content="Lcg thread inferface" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/liblcgdm-dev-Cthread-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Cthread<small> (3)</small></h1>
        <p class="lead">Lcg thread inferface</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/Cthread.3.html">
      <span itemprop="name">Cthread: Lcg thread inferface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/liblcgdm-dev/">
      <span itemprop="name">liblcgdm-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/Cthread.3.html">
      <span itemprop="name">Cthread: Lcg thread inferface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;Cthread_api.h&gt;</strong></p><p><strong>int Cthread_create(void *(*</strong><em>startroutine</em><strong>)(void *), void * </strong><em>arg</em><strong>);</strong></p><p><strong>int Cthread_create_detached(void *(*</strong><em>startroutine</em><strong>)(void *),void *</strong><em>arg</em><strong>);</strong></p><p><strong>int Cthread_join(int </strong><em>cid</em><strong>, int **</strong><em>status</em><strong>);</strong></p><p><strong>int Cthread_mutex_lock(void *</strong><em>addr</em><strong>);</strong></p><p><strong>int Cthread_mutex_trylock(void *</strong><em>addr</em><strong>);</strong></p><p><strong>int Cthread_mutex_timedlock(void *</strong><em>addr</em><strong>, int </strong><em>timeout</em><strong>);</strong></p><p><strong>int Cthread_mutex_unlock(void *</strong><em>addr</em><strong>);</strong></p><p><strong>int Cthread_mutex_destroy(void *</strong><em>addr</em><strong>);</strong></p><p><strong>int Cthread_cond_wait(void *</strong><em>addr</em><strong>);</strong></p><p><strong>int Cthread_cond_timedwait(void *</strong><em>addr</em><strong>, int </strong><em>timeout</em><strong>);</strong></p><p><strong>int Cthread_cond_signal(void *</strong><em>addr</em><strong>);</strong></p><p><strong>int Cthread_cond_broadcast(void *</strong><em>addr</em><strong>);</strong></p><p><strong>int Cthread_detach(int </strong><em>cid</em><strong>);</strong></p><p><strong>int Cthread_kill(int </strong><em>cid</em><strong>, int </strong><em>signo</em><strong>);</strong></p><p><strong>int Cthread_exit(void *</strong><em>status</em><strong>);</strong></p><p><strong>int Cthread_self(void);</strong></p><p><strong>int Cthread_getspecific(int *</strong><em>global_key</em><strong>, void **</strong><em>addr</em><strong>);</strong></p><p><strong>int Cthread_setspecific(int *</strong><em>global_key</em><strong>, void * </strong><em>addr</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>Cthread</strong> is a common API interface for multithreaded programs, although there is also support for nonthreaded application, where some of the <strong>Cthread</strong> functions then becomes useless.</p><p>For non-thread applications see the section <strong>NON-THREAD ENVIRONMENT</strong></p><p>Any created thread is identified uniquely with a <strong>cid</strong>, standing for <strong>C</strong>thread <strong>id</strong>entifier.</p><p>In multithread environment, <strong>Cthread</strong> is an interface to <strong>pthread</strong> functions on <strong>UNIX</strong>, and an interface to <strong>Win32</strong> C-runtime library on <strong>Windows/NT</strong>.</p><p><strong>Cthread_create</strong> is creating a thread given its starting point <em>startroutine</em> and its arguments <em>arg</em> address. The thread is created with the default parameters, e.g. it is a joinable thread.</p><p>Return value is the <strong>Cthread</strong> identifier <em>cid</em> , greater or equal to zero, or -1 on error.</p><p><strong>Cthread_create_detached</strong> takes the same arguments as <strong>Cthread_create</strong> and (tries) to create a detachable thread, which will then make it act as a daemon. This means that ressources used by this thread will be freed immediately when it terminates. On the other hand, such thread cannot be synchronized with other threads using the <strong>Cthread_join</strong> method.</p><p>You have to remind that creating a detachable thread do not work immediately at the creation step on every thread implementation, in particular in the <strong>DCE</strong> threads. If the implementation do not allow this at creation time, then <strong>Cthread_create_detached</strong> calls <strong>Cthread_create</strong>. Please have a look at <strong>Cthread_detach</strong> section.</p><p>Return value is the <strong>Cthread</strong> identifier <em>cid</em> , greater or equal to zero, or -1 on error.</p><p><strong>Cthread_exit</strong> makes current thread exiting. If <strong>status</strong> isn't NULL, it is assumed to point to an integer whose value if the status that a <strong>Cthread_join</strong> would received, in case the thread is joinable. Please note that <strong>Cthread_exit</strong> is dangerous and non-recommended on Windows platform.</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_kill</strong> sends <strong>signo</strong> signal number to the thread <strong>cid.</strong> This affect the status that a <strong>Cthread_join</strong> would received, in case the thread to be killed is joinable. Please note that <strong>Cthread_kill</strong> is not supported on DCE threads.</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_join</strong> suspends the calling thread until the one identified with the <strong>Cthread</strong> identifier <em>cid</em> terminates. If the <em>status</em> parameter is not <strong>NULL</strong>, the status of the terminating thread <em>cid</em> is stored there. This status is the pointer returned by thread <em>cid</em> at its end.</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_mutex_lock</strong> is an alias for <strong>Cthread_mutex_timedlock</strong> with a <em>timeout</em> of -1.</p><p><strong>Cthread_mutex_trylock</strong> is an alias for <strong>Cthread_mutex_timedlock</strong> with a <em>timeout</em> of 0.</p><p><strong>Cthread_mutex_timedlock</strong> is acquiring a mutex, creating it if necessary, on the <em>addr</em> address. The second parameter is the eventual <em>timeout</em> in seconds. If this parameter is &lt; 0, the calling thread is suspended until it is granted access to <em>addr</em> , if it is zero, the calling thread will try to gain the lock, and if it is greater than zero the calling thread will wait up to <em>timeout</em> seconds.</p><p>Please note that, in <strong>Cthread</strong>, a creation of a mutex is always associated with a creation of a conditionnal variable. See <strong>Cthread_cond_timedwait</strong> and <strong>Cthread_cond_broadcast_</strong>.</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_mutex_unlock</strong> is unlocking the mutex that the calling thread is assumed to have acquired previously, calling <strong>Cthread_mutex_timedlock</strong> on the <em>addr</em> address.</p><p><strong>Cthread_cond_wait</strong> is an alias for <strong>Cthread_cond_timedwait</strong> with a <em>timeout</em> of -1.</p><p><strong>Cthread_cond_timedwait</strong> is waiting for a condition variable, which is, by default in <strong>Cthread</strong>, broadcasted, associated with a mutex previously created on the <em>addr</em> address. Calling this function before the creation <strong>and</strong> the lock of a mutex, with <strong>Cthread_mutex_timedlock</strong> is a programming error.</p><p>While the thread is waiting on a condition to arise on the <em>addr</em> address, the corresponding lock is released. It will be acquired as soon as the condition happens. Please note that the use of condition is subject to normal thread programming rules, e.g. the lock, a loop on a predicate, a wait inside the loop, and the unlock.</p><p>If the <em>timeout</em> parameter, in seconds, is greater than zero, then the function will not suspend the calling thread more than this limit.</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_cond_signal</strong> is an alias for <strong>Cthread_cond_broadcast</strong>.</p><p><strong>Cthread_cond_broadcast</strong> restarts threads that are waiting on a condition variable vs. <em>addr</em> address.</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_detach</strong> is detaching the calling thread, identified with <em>cid</em> <strong>Cthread</strong> identifier. Whereas the normal thread packages that allow a thread to be detached at the creation step, see <strong>Cthread_create_detached</strong>, returns an error if such a detached thread tries to detach himself again, <strong>Cthread_detach</strong> will not, because of this different behaviour vs. different thread implementations: it is not possible everywhere to create a detached thread immediately, like in DCE threads.</p><p>This means that if a user is creating a thread with <strong>Cthread_create</strong> or <strong>Cthread_create_detached</strong>, the created thread will, in any case, be allowed to call <strong>Cthread_detach</strong>: if the calling thread is not yet detached, it will be changed so forth, and if the calling thread is already detached, the return value will be 0.</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_mutex_destroy</strong> is removing its corresponding entry in <strong>Cthread</strong> internal linked list, freeing all thread associated stuff, like the mutex itself, and the conditionnal variable (see <strong>Cthread_mutex_timedlock</strong>).</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_self</strong> is returning the <strong>Cthread</strong> identifier <em>cid</em> of the calling thread.</p><p>Return value is the <em>cid</em> (greater or equal to zero) on success, or -1 on error.</p><p><strong>Cthread_getspecific</strong> is creating and/or getting a thread-specific storage address for every instance of the <em>global_key</em> address, storing its result in <em>addr</em> location. The first time it is called, the stored result is <strong>NULL</strong>, next time it will be the address of the memory the user would have previously allocated and associated with the key using <strong>Cthread_setspecific</strong>.</p><p>Return value is 0 on success, or -1 on error.</p><p><strong>Cthread_setspecific</strong> is associating a memory, starting at <em>addr</em> that he have previously allocated, with the <em>global_key</em> address. If he tries to do so without calling previously <strong>Cthread_getspecific</strong>, then such a call will be done internally.</p><p>Return value is 0 on success, or -1 on error.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p>Beyond the errno value, <strong>Cthread</strong> is setting the serrno value to generic values that can be:</p><p><strong>SECTHREADINIT</strong></p><p>LCG Thread interface initialization error</p><p>A thread initialisation call failed. In principle, on UNIX this will be a call to pthread_mutex_init (and possibly pthread_mutexattr_init) that failed, on Windows/NT this might be a call to CreateMutex.</p><p><strong>SECTHREADERR</strong></p><p>LCG Thread interface failure in calling your thread library</p><p>A thread call to your native system library (like the pthread one on UNIX) failed. Please note that this is differentiated to the Cthread initialization and can happen if you are using too much thread keys, for example. This is really a run-time error only concerning your operating system thread interface. Any other system call failure, but not a thread one, and not at the initialisation step, will set serrno to <strong>SEINTERNAL</strong></p><p><strong>SEOPNOTSUP</strong></p><p>Operation not supported</p><p>This can be generated only if you compiled Cthread with a -DCTHREAD_PROTO flag that Cthread do not know about. Check your LCG configuration site.def.</p><p><strong>SEINTERNAL</strong></p><p>Internal error</p><p>You can have more information by compiling the Cthread package with the flag -DCTHREAD_DEBUG, and catching the printout on your stderr stream. This is any system call that failed (like malloc()), except those to the thread library (for which SECTHREADERR or SECTHREADINIT is to  be found), or any critical internal run-time error (such as a non correct value found in some Cthread internal structures).</p><p><strong>SETIMEDOUT</strong> (routines with a timeout parameter only)</p><p>Timed out</p><p>You called a routine with a timeout value greater than zero that reached the maximum number of timeout seconds in waiting state.</p><p><strong>EINVAL</strong></p><p>Invalid parameters</p><p>You called a routine with invalid parameter(s). Please check your code.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p><strong>Here is an example with thread-specific data</strong></p>
<pre>
#include &lt;Cthread_api.h&gt; /* <strong>Cthread</strong> include file */
#include &lt;stdio.h&gt;       /* For I/O functions and definitions */
#define NTHREADS 5 /* Number of threads */
#define NLOOP    5 /* Number of loops in threads */

static int global_key;

/* Internal Prototypes */
void *mythread(void *);
void  testit();

int main() {
  int i, n;

  for (i=1; i &lt;= NTHREADS; i++) {
    if ((n = <strong>Cthread_create</strong>(&mythread,NULL)) &lt; 0) {
      exit(EXIT_FAILURE);
    } else {
      fprintf(stderr,"[main] --&gt; Created Cthread ID %d&#92;n",n);
    }
  }

  sleep(NTHREADS);
  exit(EXIT_SUCCESS);
}

void *mythread(void *arg) {
  int i;

  /* Call the same routine NLOOP times */
  for (i=1; i &lt;= NLOOP; i++) {
    testit();
  }

  return(NULL);
}

void testit() {
  char *addr = NULL;
  int   n;

  if ((n = <strong>Cthread_detach</strong>(Cthread_self())))
    exit(EXIT_FAILURE);

  if ((n = <strong>Cthread_getspecific</strong>(&global_key,(void **) &addr)))
    exit(EXIT_FAILURE);

  if (addr == NULL) {
    addr = malloc(100);
    fprintf(stderr,"[%d] --&gt; new 0x%x&#92;n",
            Cthread_self(),addr);
    if (<strong>Cthread_setspecific</strong>(&global_key,addr))
      exit(EXIT_FAILURE);
  } else {
    fprintf(stderr,"[%d] --&gt; old 0x%x&#92;n",
            Cthread_self(),addr);
  }

  sprintf(addr,"[%d] Print with TSD buffer : Cthread ID=%d&#92;n",
               Cthread_self(),Cthread_self());

  fprintf(stderr,addr);

  return;
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NON-THREAD ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>In such an environment, almost all methods becomes no-op, except:</p><p>Creation of process(es):</p><p><strong>Cthread_create</strong></p><p><strong>Cthread_create_detached</strong> (equivalent to <strong>Cthread_create</strong>)</p><p><strong>Cthread_join</strong></p><p>Use of "Process"-specific variables:</p><p><strong>Cthread_getspecific</strong></p><p><strong>Cthread_setspecific</strong></p><p>For these two last functions, <strong>Cthread</strong> will garbage itself its eventual list of "Process"-specific variables. This means that, <strong>as in a thread environment</strong>, the user will <strong>not</strong> have to free memory allocated <strong>and</strong> registered with a call to <strong>Cthread_setspecific</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Cthread&hellip;</h2>
        <div class="sectioncontent">
<p><strong>pthread</strong>, <strong>DCE</strong>, <strong>LinuxThreads</strong>, <strong>Win32</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><strong>LCG Grid Deployment</strong> Team</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Csec_api.3.html"><span aria-hidden="true">&larr;</span> Csec_api.3: Provides authentication in lcg services</a></li>
   <li class="next"><a href="CurrentMatrix.3.html">CurrentMatrix.3: Choose the current transformation matrix <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

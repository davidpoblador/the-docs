<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>std::__detail::_Nfa: Std::__detail::_nfa -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Std::__detail::_nfa -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="std::__detail::_Nfa (3cxx) manual">
  <meta name="twitter:description" content="Std::__detail::_nfa -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libstdc++-4.8-doc-std::__detail::_Nfa-3cxx.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3cxx/std::__detail::_Nfa.3cxx.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="std::__detail::_Nfa (3cxx) manual" />
  <meta property="og:description" content="Std::__detail::_nfa -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libstdc++-4.8-doc-std::__detail::_Nfa-3cxx.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">std::__detail::_Nfa<small> (3cxx)</small></h1>
        <p class="lead">Std::__detail::_nfa -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::__detail::_Nfa.3cxx.html">
      <span itemprop="name">std::__detail::_Nfa: Std::__detail::_nfa -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libstdc++-4.8-doc/">
      <span itemprop="name">libstdc++-4.8-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::__detail::_Nfa.3cxx.html">
      <span itemprop="name">std::__detail::_Nfa: Std::__detail::_nfa -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Inherits <strong>std::__detail::_Automaton</strong>, and <strong>std::vector&lt; _State &gt;</strong>.</p><h3>Public Types</h3>
<p>typedef</p><p><strong>regex_constants::syntax_option_type</strong> <strong>_FlagT</strong>"</p><p>typedef unsigned int <strong>_SizeT</strong></p><p>typedef <strong>_State</strong> <strong>_StateT</strong></p><p>typedef _Alloc <strong>allocator_type</strong></p><p>typedef</p><p>__gnu_cxx::__normal_iterator</p><p>&lt; const_pointer, <strong>vector</strong> &gt; <strong>const_iterator</strong>"</p><p>typedef</p><p>_Alloc_traits::const_pointer <strong>const_pointer</strong>"</p><p>typedef</p><p>_Alloc_traits::const_reference <strong>const_reference</strong>"</p><p>typedef <strong>std::reverse_iterator</strong></p><p>&lt; const_iterator &gt; <strong>const_reverse_iterator</strong>"</p><p>typedef ptrdiff_t <strong>difference_type</strong></p><p>typedef</p><p>__gnu_cxx::__normal_iterator</p><p>&lt; pointer, <strong>vector</strong> &gt; <strong>iterator</strong>"</p><p>typedef _Base::pointer <strong>pointer</strong></p><p>typedef _Alloc_traits::reference <strong>reference</strong></p><p>typedef <strong>std::reverse_iterator</strong></p><p>&lt; iterator &gt; <strong>reverse_iterator</strong>"</p><p>typedef size_t <strong>size_type</strong></p><p>typedef <strong>_State</strong> <strong>value_type</strong></p>
<h3>Public Member Functions</h3>
<p><strong>_Nfa</strong> (_FlagT __f)</p><p>const <strong>_StateSet</strong> & <strong>_M_final_states</strong> () const </p><p><strong>_StateIdT</strong> <strong>_M_insert_accept</strong> ()</p><p><strong>_StateIdT</strong> <strong>_M_insert_alt</strong> (<strong>_StateIdT</strong> __next, <strong>_StateIdT</strong> __alt)</p><p><strong>_StateIdT</strong> <strong>_M_insert_matcher</strong> (<strong>_Matcher</strong> __m)</p><p><strong>_StateIdT</strong> <strong>_M_insert_subexpr_begin</strong> (const <strong>_Tagger</strong> &__t)</p><p><strong>_StateIdT</strong> <strong>_M_insert_subexpr_end</strong> (unsigned int __i, const <strong>_Tagger</strong> &__t)</p><p>_FlagT <strong>_M_options</strong> () const </p><p><strong>_StateIdT</strong> <strong>_M_start</strong> () const </p><p>_SizeT <strong>_M_sub_count</strong> () const </p><p>void <strong>assign</strong> (size_type __n, const value_type &__val)</p><p>void <strong>assign</strong> (_InputIterator __first, _InputIterator __last)</p><p>void <strong>assign</strong> (initializer_list&lt; value_type &gt; __l)</p><p>reference <strong>at</strong> (size_type __n)</p><p>const_reference <strong>at</strong> (size_type __n) const</p><p>reference <strong>back</strong> ()</p><p>const_reference <strong>back</strong> () const</p><p>iterator <strong>begin</strong> () noexcept</p><p>const_iterator <strong>begin</strong> () const noexcept</p><p>size_type <strong>capacity</strong> () const noexcept</p><p>const_iterator <strong>cbegin</strong> () const noexcept</p><p>const_iterator <strong>cend</strong> () const noexcept</p><p>void <strong>clear</strong> () noexcept</p><p><strong>const_reverse_iterator</strong> <strong>crbegin</strong> () const noexcept</p><p><strong>const_reverse_iterator</strong> <strong>crend</strong> () const noexcept</p><p><strong>_State</strong> * <strong>data</strong> () noexcept</p><p>const <strong>_State</strong> * <strong>data</strong> () const noexcept</p><p>iterator <strong>emplace</strong> (iterator __position, _Args &&...__args)</p><p>void <strong>emplace_back</strong> (_Args &&...__args)</p><p>bool <strong>empty</strong> () const noexcept</p><p>iterator <strong>end</strong> () noexcept</p><p>const_iterator <strong>end</strong> () const noexcept</p><p>iterator <strong>erase</strong> (iterator __position)</p><p>iterator <strong>erase</strong> (iterator __first, iterator __last)</p><p>reference <strong>front</strong> ()</p><p>const_reference <strong>front</strong> () const</p><p>iterator <strong>insert</strong> (iterator __position, const value_type &__x)</p><p>iterator <strong>insert</strong> (iterator __position, value_type &&__x)</p><p>void <strong>insert</strong> (iterator __position, initializer_list&lt; value_type &gt; __l)</p><p>void <strong>insert</strong> (iterator __position, size_type __n, const value_type &__x)</p><p>void <strong>insert</strong> (iterator __position, _InputIterator __first, _InputIterator __last)</p><p>size_type <strong>max_size</strong> () const noexcept</p><p>reference <strong>operator[]</strong> (size_type __n)</p><p>const_reference <strong>operator[]</strong> (size_type __n) const</p><p>void <strong>pop_back</strong> ()</p><p>void <strong>push_back</strong> (const value_type &__x)</p><p>void <strong>push_back</strong> (value_type &&__x)</p><p><strong>reverse_iterator</strong> <strong>rbegin</strong> () noexcept</p><p><strong>const_reverse_iterator</strong> <strong>rbegin</strong> () const noexcept</p><p><strong>reverse_iterator</strong> <strong>rend</strong> () noexcept</p><p><strong>const_reverse_iterator</strong> <strong>rend</strong> () const noexcept</p><p>void <strong>reserve</strong> (size_type __n)</p><p>void <strong>resize</strong> (size_type __new_size)</p><p>void <strong>resize</strong> (size_type __new_size, const value_type &__x)</p><p>void <strong>shrink_to_fit</strong> ()</p><p>size_type <strong>size</strong> () const noexcept</p><p>void <strong>swap</strong> (<strong>vector</strong> &__x) noexcept(_Alloc_traits::_S_nothrow_swap())</p>
<h3>Protected Member Functions</h3>
<p>pointer <strong>_M_allocate</strong> (size_t __n)</p><p>pointer <strong>_M_allocate_and_copy</strong> (size_type __n, _ForwardIterator __first, _ForwardIterator __last)</p><p>void <strong>_M_assign_aux</strong> (_InputIterator __first, _InputIterator __last, <strong>std::input_iterator_tag</strong>)</p><p>void <strong>_M_assign_aux</strong> (_ForwardIterator __first, _ForwardIterator __last, <strong>std::forward_iterator_tag</strong>)</p><p>void <strong>_M_assign_dispatch</strong> (_Integer __n, _Integer __val, __true_type)</p><p>void <strong>_M_assign_dispatch</strong> (_InputIterator __first, _InputIterator __last, __false_type)</p><p>size_type <strong>_M_check_len</strong> (size_type __n, const char *__s) const</p><p>void <strong>_M_deallocate</strong> (pointer __p, size_t __n)</p><p>void <strong>_M_default_append</strong> (size_type __n)</p><p>void <strong>_M_default_initialize</strong> (size_type __n)</p><p>void <strong>_M_emplace_back_aux</strong> (_Args &&...__args)</p><p>void <strong>_M_erase_at_end</strong> (pointer __pos)</p><p>void <strong>_M_fill_assign</strong> (size_type __n, const value_type &__val)</p><p>void <strong>_M_fill_initialize</strong> (size_type __n, const value_type &__value)</p><p>void <strong>_M_fill_insert</strong> (iterator __pos, size_type __n, const value_type &__x)</p><p>_Tp_alloc_type & <strong>_M_get_Tp_allocator</strong> () noexcept</p><p>const _Tp_alloc_type & <strong>_M_get_Tp_allocator</strong> () const noexcept</p><p>void <strong>_M_initialize_dispatch</strong> (_Integer __n, _Integer __value, __true_type)</p><p>void <strong>_M_initialize_dispatch</strong> (_InputIterator __first, _InputIterator __last, __false_type)</p><p>void <strong>_M_insert_aux</strong> (iterator __position, _Args &&...__args)</p><p>void <strong>_M_insert_dispatch</strong> (iterator __pos, _Integer __n, _Integer __val, __true_type)</p><p>void <strong>_M_insert_dispatch</strong> (iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)</p><p>void <strong>_M_range_check</strong> (size_type __n) const</p><p>void <strong>_M_range_initialize</strong> (_InputIterator __first, _InputIterator __last, <strong>std::input_iterator_tag</strong>)</p><p>void <strong>_M_range_initialize</strong> (_ForwardIterator __first, _ForwardIterator __last, <strong>std::forward_iterator_tag</strong>)</p><p>void <strong>_M_range_insert</strong> (iterator __pos, _InputIterator __first, _InputIterator __last, <strong>std::input_iterator_tag</strong>)</p><p>void <strong>_M_range_insert</strong> (iterator __pos, _ForwardIterator __first, _ForwardIterator __last, <strong>std::forward_iterator_tag</strong>)</p><p>bool <strong>_M_shrink_to_fit</strong> ()</p><p>allocator_type <strong>get_allocator</strong> () const noexcept</p>
<h3>Protected Attributes</h3>
<p>_Vector_impl <strong>_M_impl</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>struct _Nfa</p><p>A collection of all states making up an NFA.</p><p>An NFA is a 4-tuple M = (K, S, s, F), where K is a finite set of states, S is the alphabet of the NFA, s is the initial state, F is a set of final (accepting) states.</p><p>This NFA class is templated on S, a type that will hold values of the underlying alphabet (without regard to semantics of that alphabet). The other elements of the tuple are generated during construction of the NFA and are available through accessor member functions.</p><p>Definition at line 269 of file regex_nfa.h.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>pointer \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::_M_allocate_and_copy (size_type__n, _ForwardIterator__first, _ForwardIterator__last)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP</h3>
<p>Memory expansion handler. Uses the member allocation function to obtain <em>n</em> bytes of memory, and then copies [first,last) into it.</p><p>Definition at line 1135 of file stl_vector.h.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::_M_range_check (size_type__n) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP</h3>
<p>Safety check used only from at().</p><p>Definition at line 791 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::size().</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::assign (size_type__n, const value_type &__val)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Assigns a given value to a vector.</p><p><strong>Parameters:</strong></p><p><em>__n</em> Number of elements to be assigned.</p><p><em>__val</em> Value to be assigned.</p><p>This function fills a vector with <em>__n</em> copies of the given value. Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. Old data may be lost.</p><p>Definition at line 479 of file stl_vector.h.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::assign (_InputIterator__first, _InputIterator__last)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Assigns a range to a vector.</p><p><strong>Parameters:</strong></p><p><em>__first</em> An input iterator.</p><p><em>__last</em> An input iterator.</p><p>This function fills a vector with copies of the elements in the range [__first,__last).</p><p>Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. Old data may be lost.</p><p>Definition at line 498 of file stl_vector.h.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::assign (initializer_list&lt; value_type &gt;__l)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Assigns an initializer list to a vector.</p><p><strong>Parameters:</strong></p><p><em>__l</em> An initializer_list.</p><p>This function fills a vector with copies of the elements in the initializer list <em>__l</em>.</p><p>Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. Old data may be lost.</p><p>Definition at line 524 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::assign().</p>
<h3>reference \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::at (size_type__n)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Provides access to the data contained in the vector.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The index of the element for which data should be accessed.</p><p><strong>Returns:</strong></p><p>Read/write reference to data.</p><p><strong>Exceptions:</strong></p><p><em>std::out_of_range</em> If <em>__n</em> is an invalid index.</p><p>This function provides for safer data access. The parameter is first checked that it is in the range of the vector. The function throws out_of_range if the check fails.</p><p>Definition at line 810 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::_M_range_check().</p>
<h3>const_reference \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::at (size_type__n) const\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Provides access to the data contained in the vector.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The index of the element for which data should be accessed.</p><p><strong>Returns:</strong></p><p>Read-only (constant) reference to data.</p><p><strong>Exceptions:</strong></p><p><em>std::out_of_range</em> If <em>__n</em> is an invalid index.</p><p>This function provides for safer data access. The parameter is first checked that it is in the range of the vector. The function throws out_of_range if the check fails.</p><p>Definition at line 828 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::_M_range_check().</p>
<h3>reference \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::back ()\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Returns a read/write reference to the data at the last element of the vector.</p><p>Definition at line 855 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::end().</p>
<h3>const_reference \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::back () const\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) reference to the data at the last element of the vector.</p><p>Definition at line 863 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::end().</p>
<h3>iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::begin ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read/write iterator that points to the first element in the vector. Iteration is done in ordinary element order.</p><p>Definition at line 538 of file stl_vector.h.</p>
<h3>const_iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::begin () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first element in the vector. Iteration is done in ordinary element order.</p><p>Definition at line 547 of file stl_vector.h.</p>
<h3>size_type \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::capacity () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns the total number of elements that the vector can hold before needing to allocate more memory.</p><p>Definition at line 725 of file stl_vector.h.</p>
<h3>const_iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first element in the vector. Iteration is done in ordinary element order.</p><p>Definition at line 611 of file stl_vector.h.</p>
<h3>const_iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::cend () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last element in the vector. Iteration is done in ordinary element order.</p><p>Definition at line 620 of file stl_vector.h.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::clear ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 1125 of file stl_vector.h.</p>
<h3>\fBconst_reverse_iterator\fP \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::crbegin () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) reverse iterator that points to the last element in the vector. Iteration is done in reverse element order.</p><p>Definition at line 629 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::end().</p>
<h3>\fBconst_reverse_iterator\fP \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::crend () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the vector. Iteration is done in reverse element order.</p><p>Definition at line 638 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::begin().</p>
<h3>\fB_State\fP * \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::data ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a pointer such that [data(), data() + size()) is a valid range. For a non-empty vector, data() == &front().</p><p>Definition at line 878 of file stl_vector.h.</p><p>References std::__addressof(), and std::vector&lt; _Tp, _Alloc &gt;::front().</p>
<h3>iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::emplace (iterator__position, _Args &&...__args)\fC [inherited]\fP</h3>
<p>Inserts an object in vector before specified iterator.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator into the vector.</p><p><em>__args</em> Arguments.</p><p><strong>Returns:</strong></p><p>An iterator that points to the inserted data.</p><p>This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list.</p>
<h3>bool \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::empty () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns true if the vector is empty. (Thus begin() would equal end().)</p><p>Definition at line 734 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::begin(), and std::vector&lt; _Tp, _Alloc &gt;::end().</p>
<h3>iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::end ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read/write iterator that points one past the last element in the vector. Iteration is done in ordinary element order.</p><p>Definition at line 556 of file stl_vector.h.</p>
<h3>const_iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::end () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last element in the vector. Iteration is done in ordinary element order.</p><p>Definition at line 565 of file stl_vector.h.</p>
<h3>iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::erase (iterator__position)\fC [inherited]\fP</h3>
<p>Remove element at given position.</p><p><strong>Parameters:</strong></p><p><em>__position</em> Iterator pointing to element to be erased.</p><p><strong>Returns:</strong></p><p>An iterator pointing to the next element (or end()).</p><p>This function will erase the element at the given position and thus shorten the vector by one.</p><p>Note This operation could be expensive and if it is frequently used the user should consider using std::list. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p>
<h3>iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::erase (iterator__first, iterator__last)\fC [inherited]\fP</h3>
<p>Remove a range of elements.</p><p><strong>Parameters:</strong></p><p><em>__first</em> Iterator pointing to the first element to be erased.</p><p><em>__last</em> Iterator pointing to one past the last element to be erased.</p><p><strong>Returns:</strong></p><p>An iterator pointing to the element pointed to by <em>__last</em> prior to erasing (or end()).</p><p>This function will erase the elements in the range [__first,__last) and shorten the vector accordingly.</p><p>Note This operation could be expensive and if it is frequently used the user should consider using std::list. The user is also cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p>
<h3>reference \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::front ()\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Returns a read/write reference to the data at the first element of the vector.</p><p>Definition at line 839 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::begin().</p>
<h3>const_reference \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::front () const\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) reference to the data at the first element of the vector.</p><p>Definition at line 847 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::begin().</p>
<h3>iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::insert (iterator__position, const value_type &__x)\fC [inherited]\fP</h3>
<p>Inserts given value into vector before specified iterator.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator into the vector.</p><p><em>__x</em> Data to be inserted.</p><p><strong>Returns:</strong></p><p>An iterator that points to the inserted data.</p><p>This function will insert a copy of the given value before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list.</p>
<h3>iterator \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::insert (iterator__position, value_type &&__x)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Inserts given rvalue into vector before specified iterator.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator into the vector.</p><p><em>__x</em> Data to be inserted.</p><p><strong>Returns:</strong></p><p>An iterator that points to the inserted data.</p><p>This function will insert a copy of the given rvalue before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list.</p><p>Definition at line 988 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::emplace(), and std::move().</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::insert (iterator__position, initializer_list&lt; value_type &gt;__l)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Inserts an initializer_list into the vector.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator into the vector.</p><p><em>__l</em> An initializer_list.</p><p>This function will insert copies of the data in the initializer_list <em>l</em> into the vector before the location specified by <em>position</em>.</p><p>Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list.</p><p>Definition at line 1005 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::insert().</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::insert (iterator__position, size_type__n, const value_type &__x)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Inserts a number of copies of given data into the vector.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator into the vector.</p><p><em>__n</em> Number of elements to be inserted.</p><p><em>__x</em> Data to be inserted.</p><p>This function will insert a specified number of copies of the given data before the location specified by <em>position</em>.</p><p>Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list.</p><p>Definition at line 1023 of file stl_vector.h.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::insert (iterator__position, _InputIterator__first, _InputIterator__last)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Inserts a range into the vector.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator into the vector.</p><p><em>__first</em> An input iterator.</p><p><em>__last</em> An input iterator.</p><p>This function will insert copies of the data in the range [__first,__last) into the vector before the location specified by <em>pos</em>.</p><p>Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list.</p><p>Definition at line 1044 of file stl_vector.h.</p>
<h3>size_type \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::max_size () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns the size() of the largest possible vector.</p><p>Definition at line 650 of file stl_vector.h.</p><p>References std::allocator_traits&lt; _Tp_alloc_type &gt;::max_size().</p>
<h3>reference \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::operator[] (size_type__n)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Subscript access to the data contained in the vector.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The index of the element for which data should be accessed.</p><p><strong>Returns:</strong></p><p>Read/write reference to data.</p><p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see at().)</p><p>Definition at line 770 of file stl_vector.h.</p>
<h3>const_reference \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::operator[] (size_type__n) const\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Subscript access to the data contained in the vector.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The index of the element for which data should be accessed.</p><p><strong>Returns:</strong></p><p>Read-only (constant) reference to data.</p><p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see at().)</p><p>Definition at line 785 of file stl_vector.h.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::pop_back ()\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Removes last element. This is a typical stack operation. It shrinks the vector by one.</p><p>Note that no data is returned, and if the last element's data is needed, it should be retrieved before pop_back() is called.</p><p>Definition at line 937 of file stl_vector.h.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::push_back (const value_type &__x)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Add data to the end of the vector.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Data to be added.</p><p>This is a typical stack operation. The function creates an element at the end of the vector and assigns the given data to it. Due to the nature of a vector this operation can be done in constant time if the vector has preallocated space available.</p><p>Definition at line 901 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::end().</p>
<h3>\fBreverse_iterator\fP \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::rbegin ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read/write reverse iterator that points to the last element in the vector. Iteration is done in reverse element order.</p><p>Definition at line 574 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::end().</p>
<h3>\fBconst_reverse_iterator\fP \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::rbegin () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) reverse iterator that points to the last element in the vector. Iteration is done in reverse element order.</p><p>Definition at line 583 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::end().</p>
<h3>\fBreverse_iterator\fP \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::rend ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read/write reverse iterator that points to one before the first element in the vector. Iteration is done in reverse element order.</p><p>Definition at line 592 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::begin().</p>
<h3>\fBconst_reverse_iterator\fP \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::rend () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the vector. Iteration is done in reverse element order.</p><p>Definition at line 601 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::begin().</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::reserve (size_type__n)\fC [inherited]\fP</h3>
<p>Attempt to preallocate enough memory for specified number of elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> Number of elements required.</p><p><strong>Exceptions:</strong></p><p><em>std::length_error</em> If <em>n</em> exceeds max_size()<em>.</em></p><p>This function attempts to reserve enough memory for the vector to hold the specified number of elements. If the number requested is more than max_size(), length_error is thrown.</p><p>The advantage of this function is that if optimal code is a necessity and the user can determine the number of elements that will be required, the user can reserve the memory in advance, and thus prevent a possible reallocation of memory and copying of vector data.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::resize (size_type__new_size)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Resizes the vector to the specified number of elements.</p><p><strong>Parameters:</strong></p><p><em>__new_size</em> Number of elements the vector should contain.</p><p>This function will resize the vector to the specified number of elements. If the number is smaller than the vector's current size the vector is truncated, otherwise default constructed elements are appended.</p><p>Definition at line 664 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::size().</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::resize (size_type__new_size, const value_type &__x)\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>Resizes the vector to the specified number of elements.</p><p><strong>Parameters:</strong></p><p><em>__new_size</em> Number of elements the vector should contain.</p><p><em>__x</em> Data with which new elements should be populated.</p><p>This function will resize the vector to the specified number of elements. If the number is smaller than the vector's current size the vector is truncated, otherwise the vector is extended and new elements are populated with given data.</p><p>Definition at line 684 of file stl_vector.h.</p><p>References std::vector&lt; _Tp, _Alloc &gt;::end(), std::vector&lt; _Tp, _Alloc &gt;::insert(), and std::vector&lt; _Tp, _Alloc &gt;::size().</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::shrink_to_fit ()\fC [inline]\fP, \fC [inherited]\fP</h3>
<p>A non-binding request to reduce capacity() to size().</p><p>Definition at line 716 of file stl_vector.h.</p>
<h3>size_type \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::size () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Returns the number of elements in the vector.</p><p>Definition at line 645 of file stl_vector.h.</p>
<h3>void \fBstd::vector\fP&lt; \fB_State\fP , _Alloc &gt;::swap (\fBvector\fP&lt; _State &gt; &__x)\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP</h3>
<p>Swaps data with another vector.</p><p><strong>Parameters:</strong></p><p><em>__x</em> A vector of the same element and allocator types.</p><p>This exchanges the elements between two vectors in constant time. (Three pointers, so it should be quite fast.) Note that the global std::swap() function is specialized such that std::swap(v1,v2) will feed to this function.</p><p>Definition at line 1108 of file stl_vector.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for libstdc++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libstdc++-4.9-doc-std::__detail::_Mod_range_hashing.3cxx.html"><span aria-hidden="true">&larr;</span> std::__detail::_Mod_range_hashing.3cxx: Std::__detail::_mod_range_hashing -</a></li>
   <li class="next"><a href="libstdc++-4.8-doc-std::__detail::_Node_const_iterator.3cxx.html">std::__detail::_Node_const_iterator.3cxx: Std::__detail::_node_const_iterator _value, __constant_iterators, __cache  - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LaTeX::TOM: A module for parsing, analyzing, and manipulating latex documents.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A module for parsing, analyzing, and manipulating latex documents.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="LaTeX::TOM (3pm) manual">
  <meta name="twitter:description" content="A module for parsing, analyzing, and manipulating latex documents.">
  <meta name="twitter:image" content="https://www.carta.tech/images/liblatex-tom-perl-LaTeX::TOM-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/LaTeX::TOM.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="LaTeX::TOM (3pm) manual" />
  <meta property="og:description" content="A module for parsing, analyzing, and manipulating latex documents." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/liblatex-tom-perl-LaTeX::TOM-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">LaTeX::TOM<small> (3pm)</small></h1>
        <p class="lead">A module for parsing, analyzing, and manipulating latex documents.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/LaTeX::TOM.3pm.html">
      <span itemprop="name">LaTeX::TOM: A module for parsing, analyzing, and manipulating latex documents.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/liblatex-tom-perl/">
      <span itemprop="name">liblatex-tom-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/LaTeX::TOM.3pm.html">
      <span itemprop="name">LaTeX::TOM: A module for parsing, analyzing, and manipulating latex documents.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use LaTeX::TOM;

 $parser = LaTeX::TOM-&gt;new;

 $document = $parser-&gt;parseFile(&apos;mypaper.tex&apos;);

 $latex = $document-&gt;toLaTeX;

 $specialnodes = $document-&gt;getNodesByCondition(sub {
     my $node = shift;
     return (
       $node-&gt;getNodeType eq &apos;TEXT&apos;
         && $node-&gt;getNodeText =~ /magic string/
     );
 });

 $sections = $document-&gt;getNodesByCondition(sub {
     my $node = shift;
     return (
       $node-&gt;getNodeType eq &apos;COMMAND&apos;
         && $node-&gt;getCommandName =~ /section$/
     );
 });

 $indexme = $document-&gt;getIndexableText;

 $document-&gt;print;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides a parser which parses and interprets (though not fully) LaTeX documents and returns a tree-based representation of what it finds. This tree is a \*(C`LaTeX::TOM::Tree\*(C'.  The tree contains \*(C`LaTeX::TOM::Node\*(C' nodes.</p><p>This module should be especially useful to anyone who wants to do processing of LaTeX documents that requires extraction of plain-text information, or altering of the plain-text components (or alternatively, the math-text components).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMPONENTS</h2>
        <div class="sectioncontent">
<h3>LaTeX::TOM::Parser</h3>
<p>The parser recognizes 3 parameters upon creation.  The parameters, in order, are</p>
<dl class='dl-vertical'>
  <dt>
    parse error handling (= <strong>0</strong> || 1 || 2)
  </dt>
  <dd>
    <p>Determines what happens when a parse error is encountered.  0 results in a warning.  1 results in a die.  2 results in silence.  Note that particular groupings in LaTeX (i.e. newcommands and the like) contain invalid TeX or LaTeX, so you nearly always need this parameter to be 0 or 2 to completely parse the document.</p>
  </dd>
  <dt>
    read inputs flag (= 0 || <strong>1</strong>)
  </dt>
  <dd>
    <p>This flag determines whether a scan for \*(C`&#92;input\*(C' and \*(C`&#92;input-like\*(C' commands is performed, and the resulting called files parsed and added to the parent parse tree.  0 means no, 1 means do it.  Note that this will happen recursively if it is turned on.  Also, bibliographies (<em>.bbl</em> files) are detected and included.</p>
  </dd>
  <dt>
    apply mappings flag (= 0 || <strong>1</strong>)
  </dt>
  <dd>
    <p>This flag determines whether (most) user-defined mappings are applied.  This means \*(C`&#92;defs\*(C', \*(C`&#92;newcommands\*(C', and \*(C`&#92;newenvironments\*(C'.  This is critical for properly analyzing the content of the document, as this must be phrased in terms of the semantics of the original TeX and LaTeX commands, not ad hoc user macros. So, for instance, do not expect plain-text extraction to work properly with this option off.</p>
  </dd>

</dl>
<p>The parser returns a \*(C`LaTeX::TOM::Tree\*(C' ($document in the \s-1SYNOPSIS\s0).</p>
<h3>LaTeX::TOM::Node</h3>
<p>Nodes may be of the following types:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1TEXT\s0
  </dt>
  <dd>
    <p>\*(C`TEXT\*(C' nodes can be thought of as representing the plain-text portions of the LaTeX document.  This includes math and anything else that is not a recognized TeX or LaTeX command, or user-defined command.  In reality, \*(C`TEXT\*(C' nodes contain commands that this parser does not yet recognize the semantics of.</p>
  </dd>
  <dt>
    \s-1COMMAND\s0
  </dt>
  <dd>
    <p>A \*(C`COMMAND\*(C' node represents a TeX command.  It always has child nodes in a tree, though the tree might be empty if the command operates on zero parameters. An example of a command is  &#92;textbf{blah} This would parse into a \*(C`COMMAND\*(C' node for \*(C`textbf\*(C', which would have a subtree containing the \*(C`TEXT\*(C' node with text ``blah.''</p>
  </dd>
  <dt>
    \s-1ENVIRONMENT\s0
  </dt>
  <dd>
    <p>Similarly, TeX environments parse into \*(C`ENVIRONMENT\*(C' nodes, which have metadata about the environment, along with a subtree representing what is contained in the environment.  For example,  &#92;begin{equation}    r = &#92;frac{-b &#92;pm &#92;sqrt{b^2 - 4ac}}{2a}  &#92;end{equation} Would parse into an \*(C`ENVIRONMENT\*(C' node of the class ``equation'' with a child tree containing the result of parsing &#96;&#96;r = &#92;frac{-b &#92;pm &#92;sqrt{b^2 - 4ac}}{2a}.&apos;&apos;</p>
  </dd>
  <dt>
    \s-1GROUP\s0
  </dt>
  <dd>
    <p>A \*(C`GROUP\*(C' is like an anonymous \*(C`COMMAND\*(C'.  Since you can put whatever you want in curly-braces (\*(C`{}\*(C') in TeX in order to make semantically isolated regions, this separation is preserved by the parser.  A \*(C`GROUP\*(C' is just the subtree of the parsed contents of plain curly-braces. It is important to note that currently only the first \*(C`GROUP\*(C' in a series of \*(C`GROUP\*(C's following a LaTeX command will actually be parsed into a \*(C`COMMAND\*(C' node. The reason is that, for the initial purposes of this module, it was not necessary to recognize additional \*(C`GROUP\*(C's as additional parameters to the \*(C`COMMAND\*(C'.  However, this is something that this module really should do eventually.  Currently if you want all the parameters to a multi-parametered command, you'll need to pick out all the following \*(C`GROUP\*(C' nodes yourself. Eventually this will become something like a list which is stored in the \*(C`COMMAND\*(C' node, much like \s-1XML::DOM\s0's treatment of attributes.  These are, in a sense, apart from the rest of the document tree.  Then \*(C`GROUP\*(C' nodes will become much more rare.</p>
  </dd>
  <dt>
    \s-1COMMENT\s0
  </dt>
  <dd>
    <p>A \*(C`COMMENT\*(C' node is very similar to a \*(C`TEXT\*(C' node, except it is specifically for lines beginning with &#96;&#96;%&apos;&apos; (the TeX comment delimeter) or the right-hand portion of a line that has &#96;&#96;%&apos;&apos; at some internal point.</p>
  </dd>

</dl>

<h3>LaTeX::TOM::Trees</h3>
<p>As mentioned before, the Tree is the return result of a parse.</p><p>The tree is nothing more than an arrayref of Nodes, some of which may contain their own trees.  This is useful knowledge at this point, since the user isn't provided with a full suite of convenient tree-modification methods.  However, Trees do already have some very convenient methods, described in the next section.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>LaTeX::TOM</h3>
<p><em>new</em> Instantiate a new parser object.</p><p>In this section all of the methods for each of the components are listed and described.</p>
<h3>LaTeX::TOM::Parser</h3>
<p>The methods for the parser (aside from the constructor, discussed above) are :</p><p><em>parseFile (filename)</em> Read in the contents of <em>filename</em> and parse them, returning a \*(C`LaTeX::TOM::Tree\*(C'.</p><p><em>parse (string)</em> Parse the string <em>string</em> and return a \*(C`LaTeX::TOM::Tree\*(C'.</p>
<h3>LaTeX::TOM::Tree</h3>
<p>This section contains methods for the Trees returned by the parser.</p><p><em>copy</em> Duplicate a tree into new memory.</p><p><em>print</em> A debug print of the structure of the tree.</p><p><em>plainText</em> Returns an arrayref which is a list of strings representing the text of all \*(C`getNodePlainTextFlag = 1\*(C' \*(C`TEXT\*(C' nodes, in an inorder traversal.</p><p><em>indexableText</em> A method like the above but which goes one step further; it cleans all of the returned text and concatenates it into a single string which one could consider having all of the standard information retrieval value for the document, making it useful for indexing.</p><p><em>toLaTeX</em> Return a string representing the LaTeX encoded by the tree.  This is especially useful to get a normal document again, after modifying nodes of the tree.</p><p><em>getTopLevelNodes</em> Return a list of \*(C`LaTeX::TOM::Nodes\*(C' at the top level of the Tree.</p><p><em>getAllNodes</em> Return an arrayref with <strong>all</strong> nodes of the tree.  This \*(L"flattens\*(R" the tree.</p><p><em>getCommandNodesByName (name)</em> Return an arrayref with all \*(C`COMMAND\*(C' nodes in the tree which have a name matching <em>name</em>.</p><p><em>getEnvironmentsByName (name)</em> Return an arrayref with all \*(C`ENVIRONMENT\*(C' nodes in the tree which have a class matching <em>name</em>.</p><p><em>getNodesByCondition (code reference)</em> This is a catch-all search method which can be used to pull out nodes that match pretty much any perl expression, without manually having to traverse the tree.  <em>code reference</em> is a perl code reference which receives as its first argument the node of the tree that is currently scrutinized and is expected to return a boolean value. See the \s-1SYNOPSIS\s0 for examples.</p><p><em>getFirstNode</em> Returns the first node of the tree.  This is useful if you want to walk the tree yourself, starting with the first node.</p>
<h3>LaTeX::TOM::Node</h3>
<p>This section contains the methods for nodes of the parsed Trees.</p><p><em>getNodeType</em> Returns the type, one of \*(C`TEXT\*(C', \*(C`COMMAND\*(C', \*(C`ENVIRONMENT\*(C', \*(C`GROUP\*(C', or \*(C`COMMENT\*(C', as described above.</p><p><em>getNodeText</em> Applicable for \*(C`TEXT\*(C' or \*(C`COMMENT\*(C' nodes; this returns the document text they contain. This is undef for other node types.</p><p><em>setNodeText</em> Set the node text, also for \*(C`TEXT\*(C' and \*(C`COMMENT\*(C' nodes.</p><p><em>getNodeStartingPosition</em> Get the starting character position in the document of this node.  For \*(C`TEXT\*(C' and \*(C`COMMENT\*(C' nodes, this will be where the text begins.  For \*(C`ENVIRONMENT\*(C', \*(C`COMMAND\*(C', or \*(C`GROUP\*(C' nodes, this will be the position of the <em>last</em> character of the opening identifier.</p><p><em>getNodeEndingPosition</em> Same as above, but for last character.  For \*(C`GROUP\*(C', \*(C`ENVIRONMENT\*(C', or \*(C`COMMAND\*(C' nodes, this will be the <em>first</em> character of the closing identifier.</p><p><em>getNodeOuterStartingPosition</em> Same as getNodeStartingPosition, but for \*(C`GROUP\*(C', \*(C`ENVIRONMENT\*(C', or \*(C`COMMAND\*(C' nodes, this returns the <em>first</em> character of the opening identifier.</p><p><em>getNodeOuterEndingPosition</em> Same as getNodeEndingPosition, but for \*(C`GROUP\*(C', \*(C`ENVIRONMENT\*(C', or \*(C`COMMAND\*(C' nodes, this returns the <em>last</em> character of the closing identifier.</p><p><em>getNodeMathFlag</em> This applies to any node type.  It is 1 if the node sets, or is contained within, a math mode region.  0 otherwise.  \*(C`TEXT\*(C' nodes which have this flag as 1 can be assumed to be the actual mathematics contained in the document.</p><p><em>getNodePlainTextFlag</em> This applies only to \*(C`TEXT\*(C' nodes.  It is 1 if the node is non-math <strong>and</strong> is visible (in other words, will end up being a part of the output document). One would only want to index \*(C`TEXT\*(C' nodes with this property, for information retrieval purposes.</p><p><em>getEnvironmentClass</em> This applies only to \*(C`ENVIRONMENT\*(C' nodes.  Returns what class of environment the node represents (the \*(C`X\*(C' in \*(C`&#92;begin{X}\*(C' and \*(C`&#92;end{X}\*(C').</p><p><em>getCommandName</em> This applies only to \*(C`COMMAND\*(C' nodes.  Returns the name of the command (the \*(C`X\*(C' in \*(C`&#92;X{...}\*(C').</p><p><em>getChildTree</em> This applies only to \*(C`COMMAND\*(C', \*(C`ENVIRONMENT\*(C', and \*(C`GROUP\*(C' nodes: it returns the \*(C`LaTeX::TOM::Tree\*(C' which is ``under'' the calling node.</p><p><em>getFirstChild</em> This applies only to \*(C`COMMAND\*(C', \*(C`ENVIRONMENT\*(C', and \*(C`GROUP\*(C' nodes: it returns the first node from the first level of the child subtree.</p><p><em>getLastChild</em> Same as above, but for the last node of the first level.</p><p><em>getPreviousSibling</em> Return the prior node on the same level of the tree.</p><p><em>getNextSibling</em> Same as above, but for following node.</p><p><em>getParent</em> Get the parent node of this node in the tree.</p><p><em>getNextGroupNode</em> This is an interesting function, and kind of a hack because of the way the parser makes the current tree.  Basically it will give you the next sibling that is a \*(C`GROUP\*(C' node, until it either hits the end of the tree level, a \*(C`TEXT\*(C' node which doesn't match \*(C`/^&#92;s*$/\*(C', or a \*(C`COMMAND\*(C' node. This is useful for finding all \*(C`GROUP\*(C'ed parameters after a \*(C`COMMAND\*(C' node (see comments for \*(C`GROUP\*(C' in the \*(C`COMPONENTS\*(C' / \*(C`LaTeX::TOM::Node\*(C' section).  You can just have a while loop that calls this method until it gets \*(C`undef\*(C', and you'll know you've found all the parameters to a command. Note: this may be bad, but \*(C`TEXT\*(C' Nodes matching \*(C`/^&#92;s*&#92;[[0-9]+&#92;]$/\*(C' (optional parameter groups) are treated as if they were 'blank'.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>Due to the lack of tree-modification methods, currently this module is mostly useful for minor modifications to the parsed document, for instance, altering the text of \*(C`TEXT\*(C' nodes but not deleting the nodes.  Of course, the user can still do this by breaking abstraction and directly modifying the Tree.</p><p>Also note that the parsing is not complete.  This module was not written with the intention of being able to produce output documents the way ``latex'' does. The intent was instead to be able to analyze and modify the document on a logical level with regards to the content; it doesn't care about the document formatting and outputting side of TeX/LaTeX.</p><p>There is much work still to be done.  See the <em>\s-1TODO\s0</em> list in the <em>\s-1TOM\s0.pm</em> source.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Probably plenty.  However, this module has performed fairly well on a set of ~1000 research publications from the Computing Research Repository, so I deemed it ``good enough'' to use for purposes similar to mine.</p><p>Please let the authors know of parser errors if you discover any.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREDITS</h2>
        <div class="sectioncontent">
<p>Thanks to (in order of appearance) who have contributed valuable suggestions & patches:</p><p> Otakar Smrz  Moritz Lenz  James Bowlin  Jesse S. Bangs</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Written by Aaron Krowne &lt;akrowne@vt.edu&gt;</p><p>Maintained by Steven Schubiger &lt;schubiger@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WEB SITE</h2>
        <div class="sectioncontent">
<p>Please see http://br.endernet.org/~akrowne/elaine/latex_tom/ for this module's home on the \s-1WWW\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p><p>See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="LaTeX::Decode::Data.3pm.html"><span aria-hidden="true">&larr;</span> LaTeX::Decode::Data.3pm: Data to decode from latex to unicode</a></li>
   <li class="next"><a href="Layout::Manager.3pm.html">Layout::Manager.3pm: 2d layout management <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

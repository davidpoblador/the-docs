<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Lexing: The run-time library for lexers generated by ocamllex.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The run-time library for lexers generated by ocamllex.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Lexing (3o) manual">
  <meta name="twitter:description" content="The run-time library for lexers generated by ocamllex.">
  <meta name="twitter:image" content="https://www.carta.tech/images/ocaml-nox-Lexing-3o.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3o/Lexing.3o.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Lexing (3o) manual" />
  <meta property="og:description" content="The run-time library for lexers generated by ocamllex." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ocaml-nox-Lexing-3o.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Lexing<small> (3o)</small></h1>
        <p class="lead">The run-time library for lexers generated by ocamllex.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3o/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3o/Lexing.3o.html">
      <span itemprop="name">Lexing: The run-time library for lexers generated by ocamllex.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ocaml-nox/">
      <span itemprop="name">ocaml-nox</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3o/Lexing.3o.html">
      <span itemprop="name">Lexing: The run-time library for lexers generated by ocamllex.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Module</h2>
        <div class="sectioncontent">
<p>Module   Lexing</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Documentation</h2>
        <div class="sectioncontent">
<p>Module <strong>Lexing</strong>  : <strong>sig end</strong></p><p>The run-time library for lexers generated by <strong>ocamllex</strong> .</p><p><strong>===</strong> <strong>Positions</strong> <strong>===</strong></p><p><em>type position</em> = {  pos_fname : <strong>string</strong> ;  pos_lnum : <strong>int</strong> ;  pos_bol : <strong>int</strong> ;  pos_cnum : <strong>int</strong> ;  }</p><p>A value of type <strong>position</strong> describes a point in a source file. <strong>pos_fname</strong> is the file name; <strong>pos_lnum</strong> is the line number; <strong>pos_bol</strong> is the offset of the beginning of the line (number of characters between the beginning of the lexbuf and the beginning of the line); <strong>pos_cnum</strong> is the offset of the position (number of characters between the beginning of the lexbuf and the position). The difference between <strong>pos_cnum</strong> and <strong>pos_bol</strong> is the character offset within the line (i.e. the column number, assuming each character is one column wide).</p><p>See the documentation of type <strong>lexbuf</strong> for information about how the lexing engine will manage positions.</p><p><em>val dummy_pos</em> : <strong>position</strong></p><p>A value of type <strong>position</strong> , guaranteed to be different from any valid position.</p><p><strong>===</strong> <strong>Lexer buffers</strong> <strong>===</strong></p><p><em>type lexbuf</em> = {  refill_buff : <strong>lexbuf -&gt; unit</strong> ;</p><p><strong>mutable</strong> lex_buffer : <strong>string</strong> ;</p><p><strong>mutable</strong> lex_buffer_len : <strong>int</strong> ;</p><p><strong>mutable</strong> lex_abs_pos : <strong>int</strong> ;</p><p><strong>mutable</strong> lex_start_pos : <strong>int</strong> ;</p><p><strong>mutable</strong> lex_curr_pos : <strong>int</strong> ;</p><p><strong>mutable</strong> lex_last_pos : <strong>int</strong> ;</p><p><strong>mutable</strong> lex_last_action : <strong>int</strong> ;</p><p><strong>mutable</strong> lex_eof_reached : <strong>bool</strong> ;</p><p><strong>mutable</strong> lex_mem : <strong>int array</strong> ;</p><p><strong>mutable</strong> lex_start_p : <strong>position</strong> ;</p><p><strong>mutable</strong> lex_curr_p : <strong>position</strong> ;  }</p><p>The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.</p><p>At each token, the lexing engine will copy <strong>lex_curr_p</strong> to <strong>lex_start_p</strong> , then change the <strong>pos_cnum</strong> field of <strong>lex_curr_p</strong> by updating it with the number of characters read since the start of the <strong>lexbuf</strong> .  The other fields are left unchanged by the lexing engine.  In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also <strong>new_line</strong> ).</p><p><em>val from_channel</em> : <strong>Pervasives.in_channel -&gt; lexbuf</strong></p><p>Create a lexer buffer on the given input channel. <strong>Lexing.from_channel inchan</strong> returns a lexer buffer which reads from the input channel <strong>inchan</strong> , at the current reading position.</p><p><em>val from_string</em> : <strong>string -&gt; lexbuf</strong></p><p>Create a lexer buffer which reads from the given string. Reading starts from the first character in the string. An end-of-input condition is generated when the end of the string is reached.</p><p><em>val from_function</em> : <strong>(string -&gt; int -&gt; int) -&gt; lexbuf</strong></p><p>Create a lexer buffer with the given function as its reading method. When the scanner needs more characters, it will call the given function, giving it a character string <strong>s</strong> and a character count <strong>n</strong> . The function should put <strong>n</strong> characters or less in <strong>s</strong> , starting at character number 0, and return the number of characters provided. A return value of 0 means end of input.</p><p><strong>===</strong> <strong>Functions for lexer semantic actions</strong> <strong>===</strong></p><p><strong>=== The following functions can be called from the semantic actions</strong> <strong>of lexer definitions (the ML code enclosed in braces that</strong> <strong>computes the value returned by lexing functions). They give</strong> <strong>access to the character string matched by the regular expression</strong> <strong>associated with the semantic action. These functions must be</strong> <strong>applied to the argument lexbuf, which, in the code generated by</strong> <strong>ocamllex, is bound to the lexer buffer passed to the parsing</strong> <strong>function. ===</strong></p><p><em>val lexeme</em> : <strong>lexbuf -&gt; string</strong></p><p><strong>Lexing.lexeme lexbuf</strong> returns the string matched by the regular expression.</p><p><em>val lexeme_char</em> : <strong>lexbuf -&gt; int -&gt; char</strong></p><p><strong>Lexing.lexeme_char lexbuf i</strong> returns character number <strong>i</strong> in the matched string.</p><p><em>val lexeme_start</em> : <strong>lexbuf -&gt; int</strong></p><p><strong>Lexing.lexeme_start lexbuf</strong> returns the offset in the input stream of the first character of the matched string. The first character of the stream has offset 0.</p><p><em>val lexeme_end</em> : <strong>lexbuf -&gt; int</strong></p><p><strong>Lexing.lexeme_end lexbuf</strong> returns the offset in the input stream of the character following the last character of the matched string. The first character of the stream has offset 0.</p><p><em>val lexeme_start_p</em> : <strong>lexbuf -&gt; position</strong></p><p>Like <strong>lexeme_start</strong> , but return a complete <strong>position</strong> instead of an offset.</p><p><em>val lexeme_end_p</em> : <strong>lexbuf -&gt; position</strong></p><p>Like <strong>lexeme_end</strong> , but return a complete <strong>position</strong> instead of an offset.</p><p><em>val new_line</em> : <strong>lexbuf -&gt; unit</strong></p><p>Update the <strong>lex_curr_p</strong> field of the lexbuf to reflect the start of a new line.  You can call this function in the semantic action of the rule that matches the end-of-line character.</p><p><strong>Since</strong> 3.11.0</p><p><strong>===</strong> <strong>Miscellaneous functions</strong> <strong>===</strong></p><p><em>val flush_input</em> : <strong>lexbuf -&gt; unit</strong></p><p>Discard the contents of the buffer and reset the current position to 0.  The next use of the lexbuf will trigger a refill.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Int64.3o.html"><span aria-hidden="true">&larr;</span> Int64.3o: 64-bit integers.</a></li>
   <li class="next"><a href="List.3o.html">List.3o: List operations. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

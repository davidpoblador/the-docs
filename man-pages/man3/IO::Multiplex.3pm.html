<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>IO::Multiplex: Manage io on many file handles</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Manage io on many file handles">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="IO::Multiplex (3pm) manual">
  <meta name="twitter:description" content="Manage io on many file handles">
  <meta name="twitter:image" content="https://www.carta.tech/images/libio-multiplex-perl-IO::Multiplex-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/IO::Multiplex.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="IO::Multiplex (3pm) manual" />
  <meta property="og:description" content="Manage io on many file handles" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libio-multiplex-perl-IO::Multiplex-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">IO::Multiplex<small> (3pm)</small></h1>
        <p class="lead">Manage io on many file handles</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IO::Multiplex.3pm.html">
      <span itemprop="name">IO::Multiplex: Manage io on many file handles</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libio-multiplex-perl/">
      <span itemprop="name">libio-multiplex-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IO::Multiplex.3pm.html">
      <span itemprop="name">IO::Multiplex: Manage io on many file handles</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use IO::Multiplex;

  my $mux = new IO::Multiplex;
  $mux-&gt;add($fh1);
  $mux-&gt;add(&#92;*FH2);
  $mux-&gt;set_callback_object(...);
  $mux-&gt;listen($server_socket);
  $mux-&gt;loop;

  sub mux_input { ... }
</pre>
<p>\*(C`IO::Multiplex\*(C' is designed to take the effort out of managing multiple file handles. It is essentially a really fancy front end to the \*(C`select\*(C' system call. In addition to maintaining the \*(C`select\*(C' loop, it buffers all input and output to/from the file handles.  It can also accept incoming connections on one or more listen sockets.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>It is object oriented in design, and will notify you of significant events by calling methods on an object that you supply.  If you are not using objects, you can simply supply \*(C`_\|_PACKAGE_\|_\*(C' instead of an object reference.</p><p>You may have one callback object registered for each file handle, or one global one.  Possibly both \*(-- the per-file handle callback object will be used instead of the global one.</p><p>Each file handle may also have a timer associated with it.  A callback function is called when the timer expires.</p><h3>Handling input on descriptors</h3>
<p>When input arrives on a file handle, the \*(C`mux_input\*(C' method is called on the appropriate callback object.  This method is passed three arguments (in addition to the object reference itself of course):</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>a reference to the mux,</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>A reference to the file handle, and</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>a reference to the input buffer for the file handle.</p>
  </dd>

</dl>
<p>The method should remove the data that it has consumed from the reference supplied.  It may leave unconsumed data in the input buffer.</p>
<h3>Handling output to descriptors</h3>
<p>If \*(C`IO::Multiplex\*(C' did not handle output to the file handles as well as input from them, then there is a chance that the program could block while attempting to write.  If you let the multiplexer buffer the output, it will write the data only when the file handle is capable of receiveing it.</p><p>The basic method for handing output to the multiplexer is the \*(C`write\*(C' method, which simply takes a file descriptor and the data to be written, like this:</p><p>    $mux-&gt;write($fh, "Some data");</p><p>For convenience, when the file handle is \*(C`add\*(C'ed to the multiplexer, it is tied to a special class which intercepts all attempts to write to the file handle.  Thus, you can use print and printf to send output to the handle in a normal manner:</p><p>    printf $fh "%s%d%X", $foo, $bar, $baz</p><p>Unfortunately, Perl support for tied file handles is incomplete, and functions such as \*(C`send\*(C' cannot be supported.</p><p>Also, file handle object methods such as the \*(C`send\*(C' method of \*(C`IO::Socket\*(C' cannot be intercepted.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<h3>Simple Example</h3>
<p>This is a simple telnet-like program, which demonstrates the concepts covered so far.  It does not really work too well against a telnet server, but it does \s-1OK\s0 against the sample server presented further down.</p><p>    use IO::Socket;     use IO::Multiplex;</p><p>    # Create a multiplex object     my $mux  = new IO::Multiplex;     # Connect to the host/port specified on the command line,     # or localhost:23     my $sock = new IO::Socket::INET(Proto    =&gt; &apos;tcp&apos;,                                     PeerAddr =&gt; shift || &apos;localhost&apos;,                                     PeerPort =&gt; shift || 23)         or die "socket: $@";</p><p>    # add the relevant file handles to the mux     $mux-&gt;add($sock);     $mux-&gt;add(&#92;*STDIN);     # We want to buffer output to the terminal.  This prevents the program     # from blocking if the user hits CTRL-S for example.     $mux-&gt;add(&#92;*STDOUT);</p><p>    # We&apos;re not object oriented, so just request callbacks to the     # current package     $mux-&gt;set_callback_object(_\|_PACKAGE_\|_);</p><p>    # Enter the main mux loop.     $mux-&gt;loop;</p><p>    # mux_input is called when input is available on one of     # the descriptors.     sub mux_input {         my $package = shift;         my $mux     = shift;         my $fh      = shift;         my $input   = shift;</p><p>        # Figure out whence the input came, and send it on to the         # other place.         if ($fh == $sock) {             print STDOUT $$input;         } else {             print $sock $$input;         }         # Remove the input from the input buffer.         $$input = &apos;&apos;;     }</p><p>    # This gets called if the other end closes the connection.     sub mux_close {         print STDERR "Connection Closed&#92;n";         exit;     }</p>
<h3>A server example</h3>
<p>Servers are just as simple to write.  We just register a listen socket with the multiplex object \*(C`listen\*(C' method.  It will automatically accept connections on it and add them to its list of active file handles.</p><p>This example is a simple chat server.</p><p>    use IO::Socket;     use IO::Multiplex;</p><p>    my $mux  = new IO::Multiplex;</p><p>    # Create a listening socket     my $sock = new IO::Socket::INET(Proto     =&gt; &apos;tcp&apos;,                                     LocalPort =&gt; shift || 2300,                                     Listen    =&gt; 4)         or die "socket: $@";</p><p>    # We use the listen method instead of the add method.     $mux-&gt;listen($sock);</p><p>    $mux-&gt;set_callback_object(_\|_PACKAGE_\|_);     $mux-&gt;loop;</p><p>    sub mux_input {         my $package = shift;         my $mux     = shift;         my $fh      = shift;         my $input   = shift;</p><p>        # The handles method returns a list of references to handles which         # we have registered, except for listen sockets.         foreach $c ($mux-&gt;handles) {             print $c $$input;         }         $$input = &apos;&apos;;     }</p>
<h3>A more complex server example</h3>
<p>Let us take a look at the beginnings of a multi-user game server.  We will have a Player object for each player.</p><p>    # Paste the above example in here, up to but not including the     # mux_input subroutine.</p><p>    # mux_connection is called when a new connection is accepted.     sub mux_connection {         my $package = shift;         my $mux     = shift;         my $fh      = shift;</p><p>        # Construct a new player object         Player-&gt;new($mux, $fh);     }</p><p>    package Player;</p><p>    my %players = ();</p><p>    sub new {         my $package = shift;         my $self    = bless { mux  =&gt; shift,                               fh   =&gt; shift } =&gt; $package;</p><p>        # Register the new player object as the callback specifically for         # this file handle.</p><p>        $self-&gt;{mux}-&gt;set_callback_object($self, $self-&gt;{fh});         print $self-&gt;{fh}             "Greetings, Professor.  Would you like to play a game?&#92;n";</p><p>        # Register this player object in the main list of players         $players{$self} = $self;         $mux-&gt;set_timeout($self-&gt;{fh}, 1);     }</p><p>    sub players { return values %players; }</p><p>    sub mux_input {         my $self = shift;         shift; shift;         # These two args are boring         my $input = shift;    # Scalar reference to the input</p><p>        # Process each line in the input, leaving partial lines         # in the input buffer         while ($$input =~ s/^(.*?)&#92;n//) {             $self-&gt;process_command($1);         }     }</p><p>    sub mux_close {        my $self = shift;</p><p>       # Player disconnected;        # [Notify other players or something...]        delete $players{$self};     }     # This gets called every second to update player info, etc...     sub mux_timeout {         my $self = shift;         my $mux  = shift;</p><p>        $self-&gt;heartbeat;         $mux-&gt;set_timeout($self-&gt;{fh}, 1);     }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>new</h3>
<p>Construct a new \*(C`IO::Multiplex\*(C' object.</p><p>    $mux = new IO::Multiplex;</p>
<h3>listen</h3>
<p>Add a socket to be listened on.  The socket should have had the \*(C`bind\*(C' and \*(C`listen\*(C' system calls already applied to it.  The \*(C`IO::Socket\*(C' module will do this for you.</p><p>    $socket = new IO::Socket::INET(Listen =&gt; ..., LocalAddr =&gt; ...);     $mux-&gt;listen($socket);</p><p>Connections will be automatically accepted and \*(C`add\*(C'ed to the multiplex object.  \*(C`The mux_connection\*(C' callback method will also be called.</p>
<h3>add</h3>
<p>Add a file handle to the multiplexer.</p><p>    $mux-&gt;add($fh);</p><p>As a side effect, this sets non-blocking mode on the handle, and disables \s-1STDIO\s0 buffering.  It also ties it to intercept output to the handle.</p>
<h3>remove</h3>
<p>Removes a file handle from the multiplexer.  This also unties the handle.  It does not currently turn \s-1STDIO\s0 buffering back on, or turn off non-blocking mode.</p><p>    $mux-&gt;remove($fh);</p>
<h3>set_callback_object</h3>
<p>Set the object on which callbacks are made.  If you are not using objects, you can specify the name of the package into which the method calls are to be made.</p><p>If a file handle is supplied, the callback object is specific for that handle:</p><p>    $mux-&gt;set_callback_object($object, $fh);</p><p>Otherwise, it is considered a default callback object, and is used when events occur on a file handle that does not have its own callback object.</p><p>    $mux-&gt;set_callback_object(_\|_PACKAGE_\|_);</p><p>The previously registered object (if any) is returned.</p><p>See also the \s-1CALLBACK\s0 \s-1INTERFACE\s0 section.</p>
<h3>kill_output</h3>
<p>Remove any pending output on a file descriptor.</p><p>    $mux-&gt;kill_output($fh);</p>
<h3>outbuffer</h3>
<p>Return or set the output buffer for a descriptor</p><p>    $output = $mux-&gt;outbuffer($fh);     $mux-&gt;outbuffer($fh, $output);</p>
<h3>inbuffer</h3>
<p>Return or set the input buffer for a descriptor</p><p>    $input = $mux-&gt;inbuffer($fh);     $mux-&gt;inbuffer($fh, $input);</p>
<h3>set_timeout</h3>
<p>Set the timer for a file handle.  The timeout value is a certain number of seconds in the future, after which the \*(C`mux_timeout\*(C' callback is called.</p><p>If the \*(C`Time::HiRes\*(C' module is installed, the timers may be specified in fractions of a second.</p><p>Timers are not reset automatically.</p><p>    $mux-&gt;set_timeout($fh, 23.6);</p><p>Use \*(C`$mux-&gt;set_timeout($fh, undef)\*(C' to cancel a timer.</p>
<h3>handles</h3>
<p>Returns a list of handles that the \*(C`IO::Multiplex\*(C' object knows about, excluding listen sockets.</p><p>    @handles = $mux-&gt;handles;</p>
<h3>loop</h3>
<p>Enter the main loop and start processing \s-1IO\s0 events.</p><p>    $mux-&gt;loop;</p>
<h3>endloop</h3>
<p>Prematurly terminate the loop.  The loop will automatically terminate when there are no remaining descriptors to be watched.</p><p>    $mux-&gt;endloop;</p>
<h3>udp_peer</h3>
<p>Get peer endpoint of where the last udp packet originated.</p><p>    $saddr = $mux-&gt;udp_peer($fh);</p>
<h3>is_udp</h3>
<p>Sometimes \s-1UDP\s0 packets require special attention. This method will tell if a file handle is of type \s-1UDP\s0.</p><p>    $is_udp = $mux-&gt;is_udp($fh);</p>
<h3>write</h3>
<p>Send output to a file handle.</p><p>    $mux-&gt;write($fh, "&apos;ere I am, JH!&#92;n");</p>
<h3>shutdown</h3>
<p>Shut down a socket for reading or writing or both.  See the \*(C`shutdown\*(C' Perl documentation for further details.</p><p>If the shutdown is for reading, it happens immediately.  However, shutdowns for writing are delayed until any pending output has been successfully written to the socket.</p><p>    $mux-&gt;shutdown($socket, 1);</p>
<h3>close</h3>
<p>Close a handle.  Always use this method to close a handle that is being watched by the multiplexer.</p><p>    $mux-&gt;close($fh);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACK INTERFACE</h2>
        <div class="sectioncontent">
<p>Callback objects should support the following interface.  You do not have to provide all of these methods, just provide the ones you are interested in.</p><p>All methods receive a reference to the callback object (or package) as their first argument, in the traditional object oriented way. References to the \*(C`IO::Multiplex\*(C' object and the relevant file handle are also provided.  This will be assumed in the method descriptions.</p><h3>mux_input</h3>
<p>Called when input is ready on a descriptor.  It is passed a reference to the input buffer.  It should remove any input that it has consumed, and leave any partially received data in the buffer.</p><p>    sub mux_input {         my $self = shift;         my $mux  = shift;         my $fh   = shift;         my $data = shift;</p><p>        # Process each line in the input, leaving partial lines         # in the input buffer         while ($$data =~ s/^(.*?&#92;n)//) {             $self-&gt;process_command($1);         }     }</p>
<h3>mux_eof</h3>
<p>This is called when an end-of-file condition is present on the descriptor. This is does not nessecarily mean that the descriptor has been closed, as the other end of a socket could have used \*(C`shutdown\*(C' to close just half of the socket, leaving us free to write data back down the still open half.  Like mux_input, it is also passed a reference to the input buffer. It should consume the entire buffer or else it will just be lost.</p><p>In this example, we send a final reply to the other end of the socket, and then shut it down for writing.  Since it is also shut down for reading (implicly by the \s-1EOF\s0 condition), it will be closed once the output has been sent, after which the mux_close callback will be called.</p><p>    sub mux_eof {         my $self = shift;         my $mux  = shift;         my $fh   = shift;</p><p>        print $fh "Well, goodbye then!&#92;n";         $mux-&gt;shutdown($fh, 1);     }</p>
<h3>mux_close</h3>
<p>Called when a handle has been completely closed.  At the time that \*(C`mux_close\*(C' is called, the handle will have been removed from the multiplexer, and untied.</p>
<h3>mux_outbuffer_empty</h3>
<p>Called after all pending output has been written to the file descriptor.</p>
<h3>mux_connection</h3>
<p>Called upon a new connection being accepted on a listen socket.</p>
<h3>mux_timeout</h3>
<p>Called when a timer expires.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Copyright 1999 Bruce J Keeler &lt;bruce@gridpoint.com&gt;</p><p>Copyright 2001-2008 Rob Brown &lt;bbb@cpan.org&gt;</p><p>Released under the same terms as Perl itself.</p><p>$Id: Multiplex.pm,v 1.36 2008/09/15 08:17:50 rob Exp $</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="IO::LockedFile::Flock.3pm.html"><span aria-hidden="true">&larr;</span> IO::LockedFile::Flock.3pm: Implements the io::lockedfile class for the flock scheme.</a></li>
   <li class="next"><a href="IO::Prompt.3pm.html">IO::Prompt.3pm: Interactively prompt for user input <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Shell::POSIX::Select: The posix shell's "select" loop for perl</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The posix shell's "select" loop for perl">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Shell::POSIX::Select (3pm) manual">
  <meta name="twitter:description" content="The posix shell's "select" loop for perl">
  <meta name="twitter:image" content="https://www.carta.tech/images/libshell-posix-select-perl-Shell::POSIX::Select-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Shell::POSIX::Select.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Shell::POSIX::Select (3pm) manual" />
  <meta property="og:description" content="The posix shell's "select" loop for perl" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libshell-posix-select-perl-Shell::POSIX::Select-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Shell::POSIX::Select<small> (3pm)</small></h1>
        <p class="lead">The posix shell's "select" loop for perl</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Shell::POSIX::Select.3pm.html">
      <span itemprop="name">Shell::POSIX::Select: The posix shell's "select" loop for perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libshell-posix-select-perl/">
      <span itemprop="name">libshell-posix-select-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Shell::POSIX::Select.3pm.html">
      <span itemprop="name">Shell::POSIX::Select: The posix shell's "select" loop for perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">PURPOSE</h2>
        <div class="sectioncontent">
<p>This module implements the \*(C`select\*(C' loop of the \*(L"\s-1POSIX\s0\*(R" shells (Bash, Korn, and derivatives) for Perl. That loop is unique in two ways: it's by far the friendliest feature of any \s-1UNIX\s0 shell, and it's the <em>only</em> \s-1UNIX\s0 shell loop that's missing from the Perl language.  Until now!</p><p>What's so great about this loop? It automates the generation of a numbered menu of choices, prompts for a choice, proofreads that choice and complains if it's invalid (at least in this enhanced implementation), and executes a code-block with a variable set to the chosen value.  That saves a lot of coding for interactive programs \*(-- especially if the menu consists of many values!</p><p>The benefit of bringing this loop to Perl is that it obviates the need for future programmers to reinvent the <em>Choose-From-A-Menu</em> wheel.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>select [ [my|local|our] scalar_var ] ( [\s-1LIST\s0] ) { [\s-1CODE\s0] }</p><p>In the above, the enclosing square brackets <em>(not typed)</em> identify optional elements, and vertical bars separate mutually-exclusive choices:</p><p>The required elements are the keyword \*(C`select\*(C', the <em>parentheses</em>, and the <em>curly braces</em>. See \*(L"\s-1SYNTAX\s0\*(R" for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ELEMENTARY EXAMPLES</h2>
        <div class="sectioncontent">
<p>\s-1NOTE:\s0 All non-trivial programming examples shown in this document are distributed with this module, in the <strong>Scripts</strong> directory. \*(L"\s-1ADDITIONAL\s0 \s-1EXAMPLES\s0\*(R", covering more features, are shown below.</p><h3>ship2me.plx</h3>

<pre>
    use Shell::POSIX::Select;

    select $shipper ( &apos;UPS&apos;, &apos;FedEx&apos; ) {
        print "&#92;nYou chose: $shipper&#92;n";
        last;
    }
    ship ($shipper, $ARGV[0]);  # prints confirmation message
</pre>
<p><strong>Screen</strong></p><p>    ship2me.plx  &apos;42 hemp toothbrushes&apos;  # program invocation</p><p>    1) UPS   2) FedEx</p><p>    Enter number of choice: 2</p><p>    You chose: FedEx     Your order has been processed.  Thanks for your business!</p>
<h3>ship2me2.plx</h3>
<p>This variation on the preceding example shows how to use a custom menu-heading and interactive prompt.</p><p>    use Shell::POSIX::Select qw($Heading $Prompt);</p><p>    $Heading=&apos;Select a Shipper&apos; ;     $Prompt=&apos;Enter Vendor Number: &apos; ;</p><p>    select $shipper ( &apos;UPS&apos;, &apos;FedEx&apos; ) {       print "&#92;nYou chose: $shipper&#92;n";       last;     }     ship ($shipper, $ARGV[0]);  # prints confirmation message</p><p><strong>Screen</strong></p><p>    ship2me2.plx &apos;42 hemp toothbrushes&apos;</p><p>    Select a Shipper</p><p>    1) UPS   2) FedEx</p><p>    Enter Vendor Number: 2</p><p>    You chose: FedEx     Your order has been processed.  Thanks for your business!</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNTAX</h2>
        <div class="sectioncontent">
<h3>Loop Structure</h3>
<p>Supported invocation formats include the following:</p><p> use Shell::POSIX::Select ;</p><p> select                 ()      { }         # Form 0  select                 ()      { CODE }    # Form 1  select                 (LIST)  { CODE }    # Form 2  select         $var    (LIST)  { CODE }    # Form 3  select my      $var    (LIST)  { CODE }    # Form 4  select our     $var    (LIST)  { CODE }    # Form 5  select local   $var    (LIST)  { CODE }    # Form 6</p><p>If the loop variable is omitted (as in <em>Forms</em> <em>0</em>, <em>1</em> and <em>2</em> above), it defaults to $_, \*(C`local\*(C'ized to the loop's scope. If the \s-1LIST\s0 is omitted (as in <em>Forms</em> <em>0</em> and <em>1</em>), @ARGV is used by default, unless the loop occurs within a subroutine, in which case @_ is used instead. If \s-1CODE\s0 is omitted (as in <em>Form</em> <em>0</em>, it defaults to a statement that <strong>prints</strong> the loop variable.</p><p>The cases shown above are merely examples; all reasonable permutations are permitted, including:</p><p> select       $var    (    )  { CODE }  select local $var    (LIST)  {      }</p><p>The only form that's <em>not</em> allowed is one that specifies the loop-variable's declarator without naming the loop variable, as in:</p><p> select our () { } # WRONG!  Must name variable with declarator!</p>
<h3>The Loop variable</h3>
<p>See \*(L"\s-1SCOPING\s0 \s-1ISSUES\s0\*(R" for full details about the implications of different types of declarations for the loop variable. When the interactive user responds to the \*(C`select\*(C' loop's prompt with a valid input (i.e., a number in the correct range), the variable $Reply is set within the loop to that number. Of course, the actual item selected is usually of great interest than its number in the menu, but there are cases in which access to this number is useful (see \*(L"menu_ls.plx\*(R" for an example).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>This loop is syntactically similar to Perl's \*(C`foreach\*(C' loop, and functionally related, so we'll describe it in those terms.</p><p> foreach $var  ( LIST ) { CODE }</p><p>The job of \*(C`foreach\*(C' is to run one iteration of \s-1CODE\s0 for each LIST-item, with the current item's value placed in \*(C`local\*(C'ized $var (or if the variable is missing, \*(C`local\*(C'ized $_).</p><p> select  $var  ( LIST ) { CODE }</p><p>In contrast, the \*(C`select\*(C' loop displays a numbered menu of LIST-items on the screen, prompts for (numerical) input, and then runs an iteration with $var being set that number's LIST-item.</p><p>In other words, \*(C`select\*(C' is like an interactive, multiple-choice version of a \*(C`foreach\*(C' loop. And that's cool!  What's <em>not</em> so cool is that \*(C`select\*(C' is also the <em>only</em> \s-1UNIX\s0 shell loop that's been left out of the Perl language.  <em>Until now!</em></p><p>This module implements the \*(C`select\*(C' loop of the Korn and Bash (\*(L"\s-1POSIX\s0\*(R") shells for Perl. It accomplishes this through Filter::Simple's <em>Source Code Filtering</em> service, allowing the programmer to blithely proceed as if this control feature existed natively in Perl.</p><p>The Bash and Korn shells differ slightly in their handling of \*(C`select\*(C' loops, primarily with respect to the layout of the on-screen menu. This implementation currently follows the Korn shell version most closely (but see \*(L"TODO-LIST\*(R" for notes on planned enhancements).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENHANCEMENTS</h2>
        <div class="sectioncontent">
<p>Although the shell doesn't allow the loop variable to be omitted, for compliance with Perlish expectations, the \*(C`select\*(C' loop uses \*(C`local\*(C'ized $_ by default (as does the native \*(C`foreach\*(C' loop).  See \*(L"\s-1SYNTAX\s0\*(R" for details.</p><p>The interface and behavior of the Shell versions has been retained where deemed desirable, and sensibly modified along Perlish lines elsewhere. Accordingly, the (primary) default \s-1LIST\s0 is <strong></strong><strong>@ARGV</strong><strong></strong> (paralleling the Shell's <strong>\*(L"$@\*(R"</strong>), menu prompts can be customized by having the script import and set <strong></strong><strong>$Prompt</strong><strong></strong> (paralleling the Shell's <strong></strong><strong>$PS3</strong><strong></strong>), and the user's response to the prompt appears in the variable <strong></strong><strong>$Reply</strong><strong></strong> (paralleling the Shell's <strong></strong><strong>$REPLY</strong><strong></strong>), \*(C`local\*(C'ized to the loop.</p><p>A deficiency of the shell implementation is the inability of the user to provide a <em>heading</em> for each \*(C`select\*(C' menu. Sure, the shell programmer can <strong>echo</strong> a heading before the loop is entered and the menu is displayed, but that approach doesn't help when an <em>Outer loop</em> is reentered on departure from an <em>Inner loop</em>, because the <strong>echo</strong> preceding the <em>Outer loop</em> won't be re-executed.</p><p>A similar deficiency surrounds the handling of a custom prompt string, and the need to automatically display it on moving from an inner loop to an outer one.</p><p>To address these deficiencies, this implementation provides the option of having a heading and prompt bound to each \*(C`select\*(C' loop.  See \*(L"\s-1IMPORTS\s0 \s-1AND\s0 \s-1OPTIONS\s0\*(R" for details.</p><p>Headings and prompts are displayed in reverse video on the terminal, if possible, to make them more visually distinct.</p><p>Some shell versions simply ignore bad input, such as the entry of a number outside the menu's valid range, or alphabetic input.  I can't imagine any argument in favor of this behavior being desirable when input is coming from a terminal, so this implementation gives clear warning messages for such cases by default (see \*(L"Warnings\*(R" for details).</p><p>After a menu's initial prompt is issued, some shell versions don't show it again unless the user enters an empty line. This is desirable in cases where the menu is sufficiently large as to cause preceding output to scroll off the screen, and undesirable otherwise. Accordingly, an option is provided to enable or disable automatic prompting (see \*(L"Prompts\*(R").</p><p>This implementation always issues a fresh prompt when a terminal user submits \s-1EOF\s0 as input to a nested \*(C`select\*(C' loop. In such cases, experience shows it's critical to reissue the menu of the outer loop before accepting any more input.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SCOPING ISSUES</h2>
        <div class="sectioncontent">
<p>If the loop variable is named and provided with a <em>declarator</em> (\*(C`my\*(C', \*(C`our\*(C', or \*(C`local\*(C'), the variable is scoped within the loop using that type of declaration. But if the variable is named but lacks a declarator, no declaration is applied to the variable.</p><p>This allows, for example, a variable declared as private <em>above the loop</em> to be accessible from within the loop, and beyond it, and one declared as private <em>for the loop</em> to be confined to it:</p><p>    select my $loopvar ( ) { }     print "$loopvar DOES NOT RETAIN last value from loop here&#92;n";     -------------------------------------------------------------     my $loopvar;     select $loopvar ( ) { }     print "$loopvar RETAINS last value from loop here&#92;n";</p><p>With this design, \*(C`select\*(C' behaves differently than the native \*(C`foreach\*(C' loop, which nowadays employs automatic localization.</p><p>    foreach $othervar ( ) { } # variable localized automatically     print "$othervar DOES NOT RETAIN last value from loop here&#92;n";</p><p>    select $othervar ( ) { } # variable in scope, or global     print "$othervar RETAINS last value from loop here&#92;n";</p><p>This difference in the treatment of variables is intentional, and appropriate. That's because the whole point of \*(C`select\*(C' is to let the user choose a value from a list, so it's often critically important to be able to see, even outside the loop, the value assigned to the loop variable.</p><p>In contrast, it's usually considered undesirable and unnecessary for the value of the \*(C`foreach\*(C' loop's variable to be visible outside the loop, because in most cases it will simply be that of the last element in the list.</p><p>Of course, in situations where the \*(C`foreach\*(C'-like behavior of implicit \*(C`local\*(C'ization is desired, the programmer has the option of declaring the \*(C`select\*(C' loop's variable as \*(C`local\*(C'.</p><p>Another deficiency of the Shell versions is that it's difficult for the programmer to differentiate between a \*(C`select\*(C' loop being exited via \*(C`last\*(C', versus the loop detecting \s-1EOF\s0 on input. To correct this situation, the variable $Eof can be imported and checked for a <em>\s-1TRUE\s0</em> value upon exit from a \*(C`select\*(C' loop (see \*(L"Eof Detection\*(R").</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPORTS AND OPTIONS</h2>
        <div class="sectioncontent">
<h3>Syntax</h3>
<p> use Shell::POSIX::Select (      &apos;$Prompt&apos;,      # to customize per-menu prompt      &apos;$Heading&apos;,     # to customize per-menu heading      &apos;$Eof&apos;,         # T/F for Eof detection   # Variables must come first, then key/value options      prompt   =&gt; &apos;Enter number of choice:&apos;,  # or &apos;whatever:&apos;      style    =&gt; &apos;Bash&apos;,     # or &apos;Korn&apos;      warnings =&gt; 1,          # or 0      debug    =&gt; 0,          # or 1-5      logging  =&gt; 0,          # or 1      testmode =&gt; &lt;unset&gt;,    # or &apos;make&apos;, or &apos;foreach&apos;  );</p><p><em>\s-1NOTE:\s0</em> The values shown for options are the defaults, except for \*(C`testmode\*(C', which doesn't have one.</p>
<h3>Prompts</h3>
<p>There are two ways to customize the prompt used to solicit choices from \*(C`select\*(C' menus; through use of the prompt <em>option</em>, which applies to all loops, or the $Prompt variable, which can be set independently for each loop.</p><p><em>The prompt option</em></p><p>The \*(C`prompt\*(C' option is intended for use in programs that either contain a single \*(C`select\*(C' loop, or are content to use the same prompt for every loop. It allows a custom interactive prompt to be set in the <strong>use</strong> statement.</p><p>The prompt string should not end in a whitespace character, because that doesn't look nice when the prompt is highlighted for display (usually in <em>reverse video</em>). To offset the cursor from the prompt's end, <em>one space</em> is inserted automatically after display highlighting has been turned off.</p><p>If the environment variable $ENV{Shell_POSIX_Select_prompt} is present, its value overrides the one in the <strong>use</strong> statement.</p><p>The default prompt is \*(L"Enter number of choice:\*(R". To get the same prompt as provided by the Korn or Bash shell, use \*(C`prompt =&gt;&gt; Korn\*(C' or \*(C`prompt =&gt; Bash\*(C'.</p><p><em>The </em><strong>$Prompt</strong><em> variable</em></p><p>The programmer may also modify the prompt during execution, which may be desirable with nested loops that require different user instructions. This is accomplished by importing the $Prompt variable, and setting it to the desired prompt string before entering the loop.  Note that imported variables have to be listed as the initial arguments to the \*(C`use\*(C' directive, and properly quoted. See \*(L"order.plx\*(R" for an example.</p><p>\s-1NOTE:\s0 If the program's input channel is not connected to a terminal, prompting is automatically disabled (since there's no point in soliciting input from a <em>pipe</em>!). The programmer has the option of binding a heading to each loop's menu, by importing $Heading and setting it just before entering the associated loop. See \*(L"order.plx\*(R" for an example. A common concern with the Shell's \*(C`select\*(C' loop is distinguishing between cases where a loop ends due to \s-1EOF\s0 detection, versus the execution of \*(C`break\*(C' (like Perl's \*(C`last\*(C'). Although the Shell programmer can check the $REPLY variable to make this distinction, this implementation localizes its version of that variable ($Reply) to the loop, obviating that possibility.</p><p>Therefore, to make \s-1EOF\s0 detection as convenient and easy as possible, the programmer may import $Eof and check it for a <em>\s-1TRUE\s0</em> value after a \*(C`select\*(C' loop. See \*(L"lc_filename.plx\*(R" for a programming example.</p>
<h3>Styles</h3>
<p>The \*(C`style\*(C' options <em>Korn</em> and <em>Bash</em> can be used to request a more Kornish or Bashlike style of behavior. Currently, the only difference is that the former disables, and the latter enables, prompting for every input.  A value can be provided for the \*(C`style\*(C' option using an argument of the form \*(C`style =&gt; &apos;Korn&apos;\*(C' to the \*(C`use\*(C' directive. The default setting is \*(C`Bash\*(C'. If the environment variable $ENV{Shell_POSIX_Select_style} is set to \*(C`Korn\*(C' or \*(C`Bash\*(C', its value overrides the one provided with the <strong>use</strong> statement.</p>
<h3>Warnings</h3>
<p>The \*(C`warnings\*(C' option, whose values range from 0 to 1, enables informational messages meant to help the interactive user provide correct inputs. The default setting is 1, which provides warnings about incorrect responses to menu prompts (<em>non-numeric</em>, <em>out of range</em>, etc.). Level 0 turns these off.</p><p>If the environment variable $ENV{Shell_POSIX_Select_warnings} is present, its value takes precedence.</p>
<h3>Logging</h3>
<p>The \*(C`logging\*(C' option, whose value ranges from 0 to 1, causes informational messages and source code to be saved in temporary files (primarily for debugging purposes).</p><p>The default setting is 0, which disables logging.</p><p>If the environment variable $ENV{Shell_POSIX_Select_logging} is present, its value takes precedence.</p>
<h3>Debug</h3>
<p>The \*(C`debug\*(C' option, whose values range from 0 to 9, enables informational messages to aid in identifying bugs. If the environment variable $ENV{Shell_POSIX_Select_debug} is present, and set to one of the acceptable values, it takes precedence.</p><p>This option is primarly intended for the author's use, but users who find bugs may want to enable it and email the output to \*(L"\s-1AUTHOR\s0\*(R".  But before concluding that the problem is truly a bug in this module, please confirm that the program runs correctly with the option \*(C`testmode =&gt; foreach\*(C' enabled (see \*(L"Testmode\*(R").</p>
<h3>Testmode</h3>
<p>The \*(C`testmode\*(C' option, whose values are 'make' and 'foreach', changes the way the program is executed.  The 'make' option is used during the module's installation, and causes the program to dump the modified source code and screen display to files, and then stop (rather than interacting with the user).</p><p>If the environment variable $ENV{Shell_POSIX_Select_testmode} is present, and set to one of the acceptable values, it takes precedence.</p><p>With the \*(C`foreach\*(C' option enabled, the program simply translates occurrences of \*(C`select\*(C' into \*(C`foreach\*(C', which provides a useful method for checking that the program is syntactically correct before any serious filtering has been applied (which can introduce syntax errors). This works because the two loops, in their <em>full forms</em>, have identical syntax.</p><p>Note that before you use \*(C`testmode =&gt; foreach\*(C', you <em>must</em> fill in any missing parts that are required by \*(C`foreach\*(C'.</p><p>For instance,</p><p>\*(C`	select () {}\*(C'</p><p>must be rewritten as follows, to explicitly show \*(L"@ARGV\*(R" (assuming it's not in a subroutine) and \*(L"print\*(R":</p><p>\*(C`	foreach (@ARGV) { print; }\*(C'</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADDITIONAL EXAMPLES</h2>
        <div class="sectioncontent">
<p>\s-1NOTE:\s0 All non-trivial programming examples shown in this document are distributed with this module, in the <strong>Scripts</strong> directory. See \*(L"\s-1ELEMENTARY\s0 \s-1EXAMPLES\s0\*(R" for simpler uses of \*(C`select\*(C'.</p><h3>pick_file.plx</h3>
<p>This program lets the user choose filenames to be sent to the output. It's sort of like an interactive Perl \*(C`grep\*(C' function, with a live user providing the filtering service. As illustrated below, it could be used with Shell command substitution to provide selected arguments to a command.</p><p>    use Shell::POSIX::Select  (         prompt =&gt; &apos;Pick File(s):&apos; ,         style =&gt; &apos;Korn&apos;  # for automatic prompting     );     select ( &lt;*&gt; ) { }</p><p><strong>Screen</strong></p><p>    lp &#96;pick_file&#96;&gt;   # Using UNIX-like OS</p><p>    1) memo1.txt   2) memo2.txt   3) memo3.txt     4) junk1.txt   5) junk2.txt   6) junk3.txt</p><p>    Pick File(s): 4     Pick File(s): 2     Pick File(s): ^D</p><p>    request id is yumpy@guru+587</p>
<h3>browse_images.plx</h3>
<p>Here's a simple yet highly useful script.   It displays a menu of all the image files in the current directory, and then displays the chosen ones on-screen using a backgrounded image viewer. It uses Perl's \*(C`grep\*(C' to filter-out filenames that don't end in the desired extensions.</p><p>    use Shell::POSIX::Select ;</p><p>    $viewer=&apos;xv&apos;;  # Popular image viewer</p><p>    select ( grep /&#92;.(jpg|gif|tif|png)$/i, &lt;*&gt; ) {         system "$viewer $_ &" ;     # run viewer in background     }</p>
<h3>perl_man.plx</h3>
<p>Back in the olden days, we only had one Perl man-page. It was voluminous, but at least you knew what argument to give the <strong>man</strong> command to get the documentaton.</p><p>Now we have over a hundred Perl man pages, with unpredictable names that are difficult to remember.  Here's the program I use that allows me to select the man-page of interest from a menu.</p><p> use Shell::POSIX::Select ;</p><p> # Extract man-page names from the TOC portion of the output of "perldoc perl"  select $manpage ( sort ( &#96;perldoc perl&#96; =~ /^&#92;s+(perl&#92;w+)&#92;s/mg) ) {      system "perldoc &apos;$manpage&apos;" ;  }</p><p><strong>Screen</strong></p><p>  1) perl5004delta     2) perl5005delta     3) perl561delta   4) perl56delta       5) perl570delta      6) perl571delta  . . .</p><p><em>(This large menu spans multiple screens, but all parts can be accessed</em>  using your normal terminal scrolling facility.)</p><p> Enter number of choice: 6</p><p> <strong>PERL571DELTA</strong>(1)       Perl Programmers Reference Guide</p><p> NAME         perl571delta - what&apos;s new for perl v5.7.1</p><p> DESCRIPTION         This document describes differences between the 5.7.0         release and the 5.7.1 release.  . . .</p>
<h3>pick.plx</h3>
<p>This more general \*(C`pick\*(C'-ing program lets the user make selections from <em>arguments</em>, if they're present, or else <em>input</em>, in the spirit of Perl's \*(C`-n\*(C' invocation option and \*(C`&lt;&gt;\*(C' input operator.</p><p> use Shell::POSIX::Select ;</p><p> BEGIN {      if (@ARGV) {          @choices=@ARGV ;      }      else { # if no args, get choices from input          @choices=&lt;STDIN&gt;  or  die "$0: No data&#92;n";          chomp @choices ;          # STDIN already returned EOF, so must reopen          # for terminal before menu interaction          open STDIN, "/dev/tty"  or              die "$0: Failed to open STDIN, $!" ;  # UNIX example      }  }  select ( @choices ) { }   # prints selections to output</p><p><strong>Sample invocations (UNIX-like system)</strong></p><p>    lp &#96;pick *.txt&#96;    # same output as shown for "pick_file"</p><p>    find . -name &apos;*.plx&apos; -print | pick | xargs lp  # includes sub-dirs</p><p>    who |         awk &apos;{ print $1 }&apos; |        # isolate user names             pick |                  # select user names                 Mail -s &apos;Promote these people!&apos;  boss</p>
<h3>delete_file.plx</h3>
<p>In this program, the user selects a filename to be deleted.  The outer loop is used to refresh the list, so the file deleted on the previous iteration gets removed from the next menu. The outer loop is <em>labeled</em> (as \*(C`OUTER\*(C'), so that the inner loop can refer to it when necessary.</p><p> use Shell::POSIX::Select (      &apos;$Eof&apos;,   # for ^D detection      prompt=&gt;&apos;Choose file for deletion:&apos;  ) ;</p><p> OUTER:      while ( @files=&lt;*.py&gt; ) { # collect serpentine files          select ( @files ) {   # prompt for deletions              print STDERR  "Really delete $_? [y/n]: " ;              my $answer = &lt;STDIN&gt; ;     # ^D sets $Eof below              defined $answer  or  last OUTER ;  # exit on ^D              $answer eq "y&#92;n"  and  unlink  and  last ;          }          $Eof and last;  }</p>
<h3>lc_filename.plx</h3>
<p>This example shows the benefit of importing $Eof, so the outer loop can be exited when the user supplies \*(C`^D\*(C' to the inner one.</p><p>Here's how it works. If the rename succeeds in the inner loop, execution of \*(C`last\*(C' breaks out of the \*(C`select\*(C' loop; $Eof will then be evaluated as <em>\s-1FALSE\s0</em>, and the \*(C`while\*(C' loop will start a new \*(C`select\*(C' loop, with a (depleted) filename menu.  But if the user presses \*(C`^D\*(C' to the menu prompt, $Eof will test as <em>\s-1TRUE\s0</em>, triggering the exit from the \*(C`while\*(C' loop.</p><p> use Shell::POSIX::Select (      &apos;$Eof&apos; ,      prompt =&gt; &apos;Enter number (^D to exit):&apos;      style =&gt; &apos;Korn&apos;  # for automatic prompting  );</p><p> # Rename selected files from current dir to lowercase  while ( @files=&lt;*[A-Z]*&gt; ) {   # refreshes select&apos;s menu      select ( @files ) { # skip fully lower-case names          if (rename $_, "&#92;L$_") {              last ;          }          else {              warn "$0: rename failed for $_: $!&#92;n";          }      }      $Eof  and  last ;   # Handle ^D to menu prompt  }</p><p><strong>Screen</strong></p><p> lc_filename.plx</p><p> 1) Abe.memo   2) Zeke.memo  Enter number (^D to exit): 1</p><p> 1) Zeke.memo  Enter number (^D to exit): ^D</p>
<h3>order.plx</h3>
<p>This program sets a custom prompt and heading for each of its two loops, and shows the use of a label on the outer loop.</p><p> use Shell::POSIX::Select qw($Prompt $Heading);</p><p> $Heading="&#92;n&#92;nQuantity Menu:";  $Prompt="Choose Quantity:";</p><p> OUTER:    select my $quantity (1..4) {       $Heading="&#92;nSize Menu:" ;       $Prompt=&apos;Choose Size:&apos; ;</p><p>      select my $size ( qw (L XL) ) {           print "You chose $quantity units of size $size&#92;n" ;           last OUTER ;    # Order is complete       }    }</p><p><strong>Screen</strong></p><p> order.plx</p><p> Quantity Menu:  1)  1    2)  2    3)  3    4)  4  Choose Quantity: 4</p><p> Size Menu:  1) L   2) XL  Choose Size: ^D       (changed my mind about the quantity)</p><p> Quantity Menu:  1)  1    2)  2    3)  3    4)  4  Choose Quantity: 2</p><p> Size Menu:  1)  L    2)  XL  Choose Size: 2  You chose 2 units of size XL</p>
<h3>browse_records.plx</h3>
<p>This program shows how you can implement a \*(L"record browser\*(R", that builds a menu from the designated field of each record, and then shows the record associated with the selected field.</p><p>To use a familiar example, we'll browse the \s-1UNIX\s0 password file by user-name.</p><p> use Shell::POSIX::Select ( style =&gt; &apos;Korn&apos; );</p><p> if (@ARGV != 2  and  @ARGV != 3) {      die "Usage: $0 fieldnum filename [delimiter]" ;  }</p><p> # Could also use Getopt:* module for option parsing  ( $field, $file, $delim) = @ARGV ;  if ( ! defined $delim ) {      $delim=&apos;[&#92;040&#92;t]+&apos; # SP/TAB sequences  }</p><p> $field-- ;  # 2-&gt;1, 1-&gt;0, etc., for 0-based indexing</p><p> foreach ( &#96;cat "$file"&#96; ) {      # field is the key in the hash, value is entire record      $f2r{ (split /$delim/, $_)[ $field ] } = $_ ;  }</p><p> # Show specified fields in menu, and display associated records  select $record ( sort keys %f2r ) {      print "$f2r{$record}&#92;n" ;  }</p><p><strong>Screen</strong></p><p> browsrec.plx  &apos;1&apos;  /etc/passwd  &apos;:&apos;</p><p>  1) at     2) bin       3) contix   4) daemon  5) ftp     6) games   7) lp     8) mail      9) man     10) named  11) news   12) nobody  13) pop   14) postfix  15) root    16) spug   17) sshd   18) tim</p><p> Enter number of choice: 18</p><p> tim:x:213:100:Tim Maher:/home/tim:/bin/bash</p><p> Enter number of choice: ^D</p>
<h3>menu_ls.plx</h3>
<p>This program shows a prototype for a menu-oriented front end to a \s-1UNIX\s0 command, that prompts the user for command-option choices, assembles the requested command, and then runs it.</p><p>It employs the user's numeric choice, stored in the $Reply variable, to extract from an array the command option associated with each option description.</p><p> use Shell::POSIX::Select qw($Heading $Prompt $Eof) ;</p><p> # following avoids used-only once warning  my ($type, $format) ;</p><p> # Would be more Perlish to associate choices with options  # via a Hash, but this approach demonstrates $Reply variable</p><p> @formats = ( &apos;regular&apos;, &apos;long&apos; ) ;  @fmt_opt = ( &apos;&apos;,        &apos;-l&apos;   ) ;</p><p> @types   = ( &apos;only non-hidden&apos;, &apos;all files&apos; ) ;  @typ_opt = ( &apos;&apos;,                &apos;-a&apos; ,      ) ;</p><p> print "** LS-Command Composer **&#92;n&#92;n" ;</p><p> $Heading="&#92;n**** Style Menu ****" ;  $Prompt= "Choose listing style:" ;  OUTER:    select $format ( @formats ) {        $user_format=$fmt_opt[ $Reply - 1 ] ;</p><p>       $Heading="&#92;n**** File Menu ****" ;        $Prompt="Choose files to list:" ;        select $type ( @types ) {   # ^D restarts OUTER            $user_type=$typ_opt[ $Reply - 1 ] ;            last OUTER ;    # leave loops once final choice obtained        }    }  $Eof  and  exit ;   # handle ^D to OUTER</p><p> # Now construct user&apos;s command  $command="ls  $user_format  $user_type" ;</p><p> # Show command, for educational value  warn "&#92;nPress &lt;ENTER&gt; to execute &#92;"$command&#92;"&#92;n" ;</p><p> # Now wait for input, then run command  defined &lt;&gt;  or  print "&#92;n"  and  exit ;</p><p> system $command ;    # finally, run the command</p><p><strong>Screen</strong></p><p> menu_ls.plx</p><p> ** LS-Command Composer **</p><p> 1) regular    2) long  Choose listing format: 2</p><p> 1) only non-hidden   2) all files  Choose files to list:  2</p><p> Press &lt;ENTER&gt; to execute "ls -l -a" &lt;ENTER&gt;</p><p> total 13439  -rw-r--r--    1 yumpy   gurus    1083 Feb  4 15:41 README  -rw-rw-r--    6 yumpy   gurus     277 Dec 17 14:36 .exrc.mmkeys  -rw-rw-r--    7 yumpy   gurus     285 Jan 16 18:45 .exrc.podkeys  $</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<h3>\s-1UNIX\s0 Orientation</h3>
<p>I've been a \s-1UNIX\s0 programmer since 1976, and a Linux proponent since 1992, so it's most natural for me to program for those platforms. Accordingly, this early release has some minor features that are only allowed, or perhaps only entirely functional, on UNIX-like systems. I'm open to suggestions on how to implement some of these features in a more portable manner.</p><p>Some of the programming examples are also \s-1UNIX\s0 oriented, but it should be easy enough for those specializing on other platforms to make the necessary adapations. 8-}</p>
<h3>Terminal Display Modes</h3>
<p>These have been tested under UNIX/Linux, and work as expected, using <strong>tput</strong>.  When time permits, I'll convert to a portable implementation that will support other OSs.</p>
<h3>Incorrect Line Numbers in Warnings</h3>
<p>Because this module inserts new source code into your program, Perl messages that reference line numbers will refer to a different source file than you wrote.  For this reason, only messages referring to lines before the first \*(C`select\*(C' loop in your program will be correct.</p><p>If you're on a UNIX-like system, by enabling the \*(C`debugging\*(C' and \*(C`logging\*(C' options (see \*(L"Debug\*(R" and \*(L"Logging\*(R"), you can get an on-screen report of the proper offset to apply to interpret the line numbers of the source code that gets dumped to the <em>/tmp/SELECT_source</em> file.  Of course, if everything works correctly, you'll have little reason to look at the source. 8-}</p>
<h3>Comments can Interfere with Filtering</h3>
<p>Because of the way Filter::Simple works, ostensibly \*(L"commented-out\*(R" \*(C`select\*(C' loops like the following can actually break your program:</p><p> # select (@ARGV)  # { ; }  select (@ARGV) { ; }</p><p>A future version of Filter::Simple (or more precisely Text::Balanced, on which on which it depends) may correct this problem.</p><p>In any case, there's an easy workaround for the commented-out select loop problem; just change <em>se</em>lect into <em>es</em>lect when you comment it out, and there'll be no problem.</p><p>For other problems involving troublesome text within comments, see \*(L"Failure to Identify select Loops\*(R". When a properly formed \*(C`select\*(C' loop appears in certain contexts, such as before a line containing certain patterns of dollar signs or quotes, it will not be properly identified and translated into standard Perl.</p><p>The failure of the filtering routine to rewrite the loop causes the compiler to issue the following fatal error when it sees the <strong>{</strong> following the <strong>(\s-1LIST\s0)</strong>:</p><p>syntax error at <em>filename</em> line <em>X</em>, near \*(L") {\*(R"</p><p>This of course prevents the program from running.</p><p>The problem is either a bug in Filter::Simple, or one of the modules on which it depends. Until this is resolved, you may be able to handle such cases by explicitly turning filtering off before the offending code is encountered, using the <strong>no</strong> directive:</p><p>    use Shell::POSIX::Select;     # filtering ON     select (@names) { print ; }</p><p>    no Shell::POSIX::Select;      # filtering OFF     # $X$</p>
<h3>Restrictions on Loop-variable Names</h3>
<p>Due to a bug in most versions of Text::Balanced, loop-variable names that look like Perl operators, including $m, $a, $s, $y, $tr, $qq, $qw, $qr, and $qx, and possibly others, cause syntax errors. Newer versions of that module (unreleased at the time of this writing) have corrected this problem, so download the latest version if you must use such names.</p>
<h3>Please Report Bugs!</h3>
<p>This is a non-trivial program, that does some fairly complex parsing and data munging, so I'm sure there are some latent bugs awaiting your discovery. Please share them with me, by emailing the offending code, and/or the diagnostic messages enabled by the <em>debug</em> option setting (see \*(L"\s-1IMPORTS\s0 \s-1AND\s0 \s-1OPTIONS\s0\*(R").</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO-LIST</h2>
        <div class="sectioncontent">
<h3>More Shell-like Menus</h3>
<p>In a future release, there could be options for more accurately emulating Bash and Korn-style behavior, if anybody cares (the main difference is in how the items are ordered in the menus).</p>
<h3>More Extensive Test Suite</h3>
<p>More tests are needed, especially for the complex and tricky cases.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MODULE DEPENDENCIES</h2>
        <div class="sectioncontent">
<p> File::Spec::Functions  Text::Balanced  Filter::Simple</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS: Default</h2>
        <div class="sectioncontent">
<p> $Reply</p><p>This variable is \*(C`local\*(C'ized to each \*(C`select\*(C' loop, and provides the menu-number of the most recent valid selection. For an example of its use, see \*(L"menu_ls.plx\*(R".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS: Optional</h2>
        <div class="sectioncontent">
<p> $Heading  $Prompt  $Eof</p><p>See \*(L"\s-1IMPORTS\s0 \s-1AND\s0 \s-1OPTIONS\s0\*(R" for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SCRIPTS</h2>
        <div class="sectioncontent">
<p> browse_images  browse_jpeg  browse_records  delete_file  lc_filename  long_listem  menu_ls  order  perl_man  pick  pick_file</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p> Tim Maher  Consultix  yumpy@cpan.org  http://www.teachmeperl.com</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>I probably never would have even attempted to write this module if it weren't for the provision of Filter::Simple by Damian Conway, which I ruthlessly exploited to make a hard job easy.</p><p><em>The Damian</em> also gave useful tips during the module's development, for which I'm grateful.</p><p>I <em>definitely</em> wouldn't have ever written this module, if I hadn't found myself writing a chapter on <em>Looping</em> for my upcoming <strong>Manning Publications</strong> book, and once again lamenting the fact that the most friendly Shell loop was still missing from Perl. So in a fit of zeal, I vowed to rectify that oversight!</p><p>I hope you find this module as useful as I do! 8-}</p><p>For more examples of how this loop can be used in Perl programs, watch for my upcoming book, <em>Minimal Perl: for Shell Users and Programmers</em> (see &lt;http://teachmeperl.com/mp4sh.html&gt;) in early fall, 2003.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Shell::POSIX::Select&hellip;</h2>
        <div class="sectioncontent">
<p> man ksh     # on UNIX or UNIX-like systems</p><p> man bash    # on UNIX or UNIX-like systems</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DON'T SEE ALSO</h2>
        <div class="sectioncontent">
<p><strong>perldoc -f select</strong>, which has nothing to do with this module (the names just happen to match up).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p> This document describes version 0.05.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2002-2003, Timothy F. Maher.  All rights reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Shell::Command.3pm.html"><span aria-hidden="true">&larr;</span> Shell::Command.3pm: Cross-platform functions emulating common shell commands</a></li>
   <li class="next"><a href="Sort::Fields.3pm.html">Sort::Fields.3pm: Sort lines containing delimited fields <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

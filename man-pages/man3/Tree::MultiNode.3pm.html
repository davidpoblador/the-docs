<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tree::MultiNode: A multi node tree object.  most useful for modeling heirarchial data structures.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A multi node tree object.  most useful for modeling heirarchial data structures.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Tree::MultiNode (3pm) manual">
  <meta name="twitter:description" content="A multi node tree object.  most useful for modeling heirarchial data structures.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtree-multinode-perl-Tree::MultiNode-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Tree::MultiNode.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Tree::MultiNode (3pm) manual" />
  <meta property="og:description" content="A multi node tree object.  most useful for modeling heirarchial data structures." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtree-multinode-perl-Tree::MultiNode-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Tree::MultiNode<small> (3pm)</small></h1>
        <p class="lead">A multi node tree object.  most useful for modeling heirarchial data structures.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Tree::MultiNode.3pm.html">
      <span itemprop="name">Tree::MultiNode: A multi node tree object.  most useful for modeling heirarchial data structures.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtree-multinode-perl/">
      <span itemprop="name">libtree-multinode-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Tree::MultiNode.3pm.html">
      <span itemprop="name">Tree::MultiNode: A multi node tree object.  most useful for modeling heirarchial data structures.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Tree::MultiNode;
  use strict;
  use warnings;
  my $tree   = new Tree::MultiNode;
  my $handle = new Tree::MultiNode::Handle($tree);

  $handle-&gt;set_key("top");
  $handle-&gt;set_value("level");

  $handle-&gt;add_child("child","1");
  $handle-&gt;add_child("child","2");

  $handle-&gt;first();
  $handle-&gt;down();

  $handle-&gt;add_child("grandchild","1-1");
  $handle-&gt;up();

  $handle-&gt;last();
  $handle-&gt;down();

  $handle-&gt;add_child("grandchild","2-1");
  $handle-&gt;up();

  $handle-&gt;top();
  &dump_tree($handle);

  my $depth = 0;
  sub dump_tree
  {
    ++$depth;
    my $handle = shift;
    my $lead = &apos; &apos; x ($depth*2);
    my($key,$val);

    ($key,$val) = $handle-&gt;get_data();

    print $lead, "key:   $key&#92;n";
    print $lead, "val:   $val&#92;n";
    print $lead, "depth: $depth&#92;n";

    my $i;
    for( $i = 0; $i &lt; scalar($handle-&gt;children); ++$i ) {
      $handle-&gt;down($i);
        &dump_tree($handle);
      $handle-&gt;up();
    }
    --$depth;
  }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Tree::MultiNode, Tree::MultiNode::Node, and MultiNode::Handle are objects modeled after \*(C+ classes that I had written to help me model heirarchical information as datastructures (such as the relationships between records in an \s-1RDBMS\s0).  The tree is basicly a list of lists type data structure, where each node has a key, a value, and a list of children.  The tree has no internal sorting, though all operations perserve the order of the child nodes.</p><p><strong>&#92;$1</strong></p><p>The concept of creating a handle based on a tree lets you have multiple handles into a single tree without having to copy the tree.  You have to use a handle for all operations on the tree (other than construction).</p><p>When you first construct a tree, it will have a single empty node.  When you construct a handle into that tree, it will set the top node in the tree as it's current node.</p><p>  my $tree   = new Tree::MultiNode;   my $handle = new Tree::MultiNode::Handle($tree); At this point, you can set the key/value in the top node, or start adding child nodes.</p><p>  $handle-&gt;set_key("blah");   $handle-&gt;set_value("foo");</p><p>  $handle-&gt;add_child("quz","baz");   # or   $handle-&gt;add_child();</p><p>add_child can take 3 paramters \*(-- a key, a value, and a position.  The key and value will set the key/value of the child on construction. If pos is passed, the new child will be inserted into the list of children.</p><p>To move the handle so it points at a child (so you can start manipulating that child), there are a series of methods to call:</p><p>  $handle-&gt;first();   # sets the current child to the first in the list   $handle-&gt;next();    # sets the next, or first if there was no next   $handle-&gt;prev();    # sets the previous, or last if there was no next   $handle-&gt;last();    # sets to the last child   $handle-&gt;down();    # positions the handle&apos;s current node to the                       # current child</p><p>To move back up, you can call the method up:</p><p>  $handle-&gt;up();      # moves to this node&apos;s parent</p><p><em>up()</em> will fail if the current node has no parent node.  Most of the member functions return either undef to indicate failure, or some other value to indicate success. If set to a true value, it enables debugging output in the code.  This will likely be removed in future versions as the code becomes more stable.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API REFERENCE</h2>
        <div class="sectioncontent">
<p>The tree object.   @param    package name or tree object [scalar]   @returns  new tree object</p><p>Creates a new Tree.  The tree will have a single top level node when created. The first node will have no value (undef) in either it's key or it's value.</p><p>  my $tree = new Tree::MultiNode; Please note that the Node object is used internaly by the MultiNode object. Though you have the ability to interact with the nodes, it is unlikely that you should need to.  That being said, the interface is documented here anyway.   new($)     @param    package name or node object to clone [scalar]     @returns  new node object</p><p>  new($$)     @param    key   [scalar]     @param    value [scalar]     @returns  new node object</p><p>Creates a new Node.  There are three behaviors for new.  A constructor with no arguments creates a new, empty node.  A single argument of another node object will create a clone of the node object.  If two arguments are passed, the first is stored as the key, and the second is stored as the value.</p><p>  # clone an existing node   my $node = new Tree::MultiNode::Node($oldNode);   # or   my $node = $oldNode-&gt;new();</p><p>  # create a new node   my $node = new Tree::MultiNode::Node;   my $node = new Tree::MultiNode::Node("fname");   my $node = new Tree::MultiNode::Node("fname","Larry");   @param     key [scalar]   @returns   the key [scalar]</p><p>Used to set, or retreive the key for a node.  If a parameter is passed, it sets the key for the node.  The value of the key member is alwyays returned.</p><p>  print $node3-&gt;key(), "&#92;n";    # &apos;fname&apos;   @param    the value to set [scalar]   @returns  the value [scalar]</p><p>Used to set, or retreive the value for a node.  If a parameter is passed, it sets the value for the node.  The value of the value member is alwyays returned.</p><p>  print $node3-&gt;value(), "&#92;n";   # &apos;Larry&apos;   @returns  the deleted key</p><p>Clears the key member bu deleting it.</p><p>  $node3-&gt;clear_key();   @returns  the deleted value</p><p>Clears the value member bu deleting it.</p><p>  $node3-&gt;clear_value();   @returns  reference to children [array reference]</p><p>Returns a refrence to the array that contains the children of the node object.</p><p>  $array_ref = $node3-&gt;children(); These functions return arrays consisting of the appropriate data from the child nodes.</p><p>  my @keys     = $handle-&gt;child_keys();   my @vals     = $handle-&gt;child_values();   my %kv_pairs = $handle-&gt;child_kv_pairs(); This function returns a hashtable that consists of the child keys as the hash keys, and the position in the child array as the value.  This allows for a quick and dirty way of looking up the position of a given key in the child list.</p><p>  my %h = $node-&gt;child_key_positions(); Returns a refrence to the parent node of the current node.</p><p>  $node_parent = $node3-&gt;parent(); Used for diagnostics, it prints out the members of the node.</p><p>  $node3-&gt;dump(); Handle is used as a 'pointer' into the tree.  It has a few attributes that it keeps track of.  These are:</p><p>  1. the top of the tree   2. the current node   3. the current child node   4. the depth of the current node</p><p>The top of the tree never changes, and you can reset the handle to point back at the top of the tree by calling the <em>top()</em> method.</p><p>The current node is where the handle is 'pointing' in the tree.  The current node is changed with functions like <em>top()</em>, <em>down()</em>, and <em>up()</em>.</p><p>The current child node is used for traversing downward into the tree.  The members <em>first()</em>, <em>next()</em>, <em>prev()</em>, <em>last()</em>, and <em>position()</em> can be used to set the current child, and then traverse down into it.</p><p>The depth of the current node is a measure of the length of the path from the top of the tree to the current node, i.e. the top of the node has a depth of 0, each of its children has a depth of 1, etc. Constructs a new handle.  You must pass a tree object to Handle::New.</p><p>  my $tree   = new Tree::MultiNode;   my $handle = new Tree::MultiNode::Handle($tree); Returns the tree that was used to construct the node.  Useful if you're trying to create another node into the tree.</p><p>  my $handle2 = new Tree::MultiNode::Handle($handle-&gt;tree()); Retrieves both the key, and value (as an array) for the current node.</p><p>  my ($key,$val) = $handle-&gt;get_data(); Retrieves the key for the current node.</p><p>  $key = $handle-&gt;get_key(); Sets the key for the current node.</p><p>  $handle-&gt;set_key("lname"); Retreives the value for the current node.</p><p>  $val = $handle-&gt;get_value(); Sets the value for the current node.</p><p>  $handle-&gt;set_value("Wall"); get_child takes an optional paramater which is the position of the child that is to be retreived.  If this position is not specified, get_child attempts to return the current child.  get_child returns a Node object.</p><p>  my $child_node = $handle-&gt;get_child(); This member adds a new child node to the end of the array of children for the current node.  There are three optional parameters:</p><p>  - a key   - a vlaue   - a position</p><p>If passed, the key and value will be set in the new child.  If a position is passed, the new child will be inserted into the current array of children at the position specified.</p><p>  $handle-&gt;add_child();                    # adds a blank child   $handle-&gt;add_child("language","perl");   # adds a child to the end   $handle-&gt;add_child("language","C++",0);  # adds a child to the front Gets the depth for the current node.</p><p>  my $depth = $handle-&gt;depth(); Sets the current child via a specified value \*(-- basicly it iterates through the array of children, looking for a match.  You have to supply the key to look for, and optionaly a sub ref to find it.  The default for this sub is</p><p>  sub { return shift eq shift; }</p><p>Which is sufficient for testing the equality of strings (the most common thing that I think will get stored in the tree).  If you're storing multiple datatypes as keys, you'll have to write a sub that figures out how to perform the comparisions in a sane manner.</p><p>The sub ref should take 2 args, and compare them \*(-- return false if they don't match, and true if they do.</p><p>  $handle-&gt;select(&apos;lname&apos;, sub { return shift eq shift; } ); Sets, or retreives the current child position.</p><p>  print "curr child pos is: ", $handle-&gt;position(), "&#92;n";   $handle-&gt;<strong>position</strong>(5);    # sets the 6th child as the current child These functions manipulate the current child member.  <em>first()</em> sets the first child as the current child, while <em>last()</em> sets the last.  <em>next()</em>, and <em>prev()</em> will move to the next/prev child respectivly.  If there is no current child node, <em>next()</em> will have the same effect as <em>first()</em>, and <em>prev()</em> will operate as <em>last()</em>. <em>prev()</em> fails if the current child is the first child, and <em>next()</em> fails if the current child is the last child \*(-- i.e. they do not wrap around.</p><p>These functions will fail if there are no children for the current node.</p><p>  $handle-&gt;first();  # sets to the 0th child   $handle-&gt;next();   # to the 1st child   $handle-&gt;prev();   # back to the 0th child   $handle-&gt;last();   # go straight to the last child. <em>down()</em> moves the handle to point at the current child node.  It fails if there is no current child node.  When <em>down()</em> is called, the current child becomes invalid (undef).</p><p>  $handle-&gt;down(); <em>down()</em> moves the handle to point at the parent of the current node.  It fails if there is no parent node.  When <em>up()</em> is called, the current child becomes invalid (undef).</p><p>  $handle-&gt;up(); Resets the handle to point back at the top of the tree. When <em>top()</em> is called, the current child becomes invalid (undef).</p><p>  $handle-&gt;top(); This returns an array of Node objects that represents the children of the current Node.  Unlike <em>Node::children()</em>, the array <em>Handle::children()</em> is not a refrnece to an array, but an array.  Useful if you need to iterate through the children of the current node.</p><p>  print "There are: ", scalar($handle-&gt;children()), " children&#92;n";   foreach $child ($handle-&gt;children()) {     print $child-&gt;key(), " : ", $child-&gt;value(), "&#92;n";   } This function returns a hashtable that consists of the child keys as the hash keys, and the position in the child array as the value.  This allows for a quick and dirty way of looking up the position of a given key in the child list.</p><p>  my %h = $handle-&gt;child_key_positions(); Returns the key at the specified position, or from the corresponding child node.</p><p>  my $key = $handle-&gt;get_child_key(); Returns the value at the specified position, or from the corresponding child node.</p><p>  my $value = $handle-&gt;get_child_value(); Returns <em>Tree::MultiNode::Node::child_kv_paris()</em> for the current node for this handle.</p><p>  my %pairs = $handle-&gt;kv_pairs(); Returns the keys from the current node's children. Returns undef if there is no currnet node.   $handle-&gt;traverse(sub {     my $h = shift;     printf "%sk: %s v: %s&#92;n",(&apos;  &apos; x $handle-&gt;depth()),$h-&gt;get_data();   });</p><p>Traverse takes a subroutine reference, and will visit each node of the tree, starting with the node the handle currently points to, recrusivly down from the current position of the handle.  Each time the subroutine is called, it will be passed a handle which points to the node to be visited.  Any additional arguments after the sub ref will be passed to the traverse function _before_ the handle is passed.  This should allow you to pass constant arguments to the sub ref.</p><p>Modifying the node that the handle points to will cause traverse to work from the new node forward.   $handle-&gt;traverse( &#92;&Some::Object::method, $obj, $const1, &#92;%const2 );</p><p>  ...   sub method   {     my $handle = pop;     my $self   = shift;     my $const1 = shift;     my $const2 = shift;     # do something   }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Tree::MultiNode&hellip;</h2>
        <div class="sectioncontent">
<p>Algorithms in \*(C+</p>
<pre>
   Robert Sedgwick
   Addison Wesley 1992
   \s-1ISBN\s0 0201510596
</pre>
<p>The Art of Computer Programming  Volume 1 Fundamental Algorithms</p>
<pre>
  third edition, Donald E. Knuth
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Kyle R. Burton mortis@voicenet.com (initial version, and maintenence) Daniel X. Pape dpape@canis.uiuc.edu (see Changes file from the source archive), Eric Joanis &lt;joanis@cs.toronto.edu&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>- There is currently no way to remove a child node.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Toolkit.3pm.html"><span aria-hidden="true">&larr;</span> Toolkit.3pm: Keep your handy modules organized</a></li>
   <li class="next"><a href="Tree::Node.3pm.html">Tree::Node.3pm: Node class for perl implementation of red/black tree <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

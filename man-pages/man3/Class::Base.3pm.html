<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::Base: Useful base class for deriving other modules</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Useful base class for deriving other modules">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::Base (3pm) manual">
  <meta name="twitter:description" content="Useful base class for deriving other modules">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-base-perl-Class::Base-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::Base.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::Base (3pm) manual" />
  <meta property="og:description" content="Useful base class for deriving other modules" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-base-perl-Class::Base-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::Base<small> (3pm)</small></h1>
        <p class="lead">Useful base class for deriving other modules</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Base.3pm.html">
      <span itemprop="name">Class::Base: Useful base class for deriving other modules</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-base-perl/">
      <span itemprop="name">libclass-base-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Base.3pm.html">
      <span itemprop="name">Class::Base: Useful base class for deriving other modules</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    package My::Funky::Module;
    use base qw( Class::Base );

    # custom initialiser method
    sub init {
        my ($self, $config) = @_;

        # copy various params into $self
        $self-&gt;params($config, qw( FOO BAR BAZ ))
            || return undef;

        # to indicate a failure
        return $self-&gt;error(&apos;bad constructor!&apos;)
            if $something_bad;

        # or to indicate general happiness and well-being
        return $self;
    }

    package main;

    # new() constructor folds args into hash and calls init()
    my $object = My::Funky::Module-&gt;new( foo =&gt; &apos;bar&apos;, ... )
          || die My::Funky::Module-&gt;error();

    # error() class/object method to get/set errors
    $object-&gt;error(&apos;something has gone wrong&apos;);
    print $object-&gt;error();

    # debugging() method (de-)activates the debug() method
    $object-&gt;<strong>debugging</strong>(1);

    # debug() prints to STDERR if debugging enabled
    $object-&gt;debug(&apos;The &apos;, $animal, &apos; sat on the &apos;, $place);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Please consider using Badger::Base instead which is the successor of this module.</p><p>This module implements a simple base class from which other modules can be derived, thereby inheriting a number of useful methods such as \*(C`new()\*(C', \*(C`init()\*(C', \*(C`params()\*(C', \*(C`clone()\*(C', \*(C`error()\*(C' and \*(C`debug()\*(C'.</p><p>For a number of years, I found myself re-writing this module for practically every Perl project of any significant size.  Or rather, I would copy the module from the last project and perform a global search and replace to change the names.  Each time it got a little more polished and eventually, I decided to Do The Right Thing and release it as a module in it's own right.</p><p>It doesn't pretend to be an all-encompassing solution for every kind of object creation problem you might encounter.  In fact, it only supports blessed hash references that are created using the popular, but by no means universal convention of calling \*(C`new()\*(C' with a list or reference to a hash array of named parameters.  Constructor failure is indicated by returning undef and setting the $ERROR package variable in the module's class to contain a relevant message (which you can also fetch by calling \*(C`error()\*(C' as a class method).</p><p>e.g.</p><p>    my $object = My::Module-&gt;new(         file =&gt; &apos;myfile.html&apos;,         msg  =&gt; &apos;Hello World&apos;     ) || die $My::Module::ERROR;</p><p>or:</p><p>    my $object = My::Module-&gt;new({         file =&gt; &apos;myfile.html&apos;,         msg  =&gt; &apos;Hello World&apos;,     }) || die My::Module-&gt;error();</p><p>The \*(C`new()\*(C' method handles the conversion of a list of arguments into a hash array and calls the \*(C`init()\*(C' method to perform any initialisation.  In many cases, it is therefore sufficient to define a module like so:</p><p>    package My::Module;     use Class::Base;     use base qw( Class::Base );</p><p>    sub init {         my ($self, $config) = @_;         # copy some config items into $self         $self-&gt;params($config, qw( FOO BAR )) || return undef;         return $self;     }</p><p>    # ...plus other application-specific methods</p><p>    1;</p><p>Then you can go right ahead and use it like this:</p><p>    use My::Module;</p><p>    my $object = My::Module-&gt;new( FOO =&gt; &apos;the foo value&apos;,                                   BAR =&gt; &apos;the bar value&apos; )         || die $My::Module::ERROR;</p><p>Despite its limitations, Class::Base can be a surprisingly useful module to have lying around for those times where you just want to create a regular object based on a blessed hash reference and don't want to worry too much about duplicating the same old code to bless a hash, define configuration values, provide an error reporting mechanism, and so on.  Simply derive your module from \*(C`Class::Base\*(C' and leave it to worry about most of the detail.  And don't forget, you can always redefine your own \*(C`new()\*(C', \*(C`error()\*(C', or other method, if you don't like the way the Class::Base version works.</p><h3>Subclassing Class::Base</h3>
<p>This module is what object-oriented afficionados would describe as an \*(L"abstract base class\*(R".  That means that it's not designed to be used as a stand-alone module, rather as something from which you derive your own modules.  Like this:</p><p>    package My::Funky::Module     use base qw( Class::Base );</p><p>You can then use it like this:</p><p>    use My::Funky::Module;</p><p>    my $module = My::Funky::Module-&gt;new();</p>
<h3>Construction and Initialisation Methods</h3>
<p>If you want to apply any per-object initialisation, then simply write an \*(C`init()\*(C' method.  This gets called by the \*(C`new()\*(C' method which passes a reference to a hash reference of configuration options.</p><p>    sub init {         my ($self, $config) = @_;</p><p>        ...</p><p>        return $self;     }</p><p>When you create new objects using the \*(C`new()\*(C' method you can either pass a hash reference or list of named arguments.  The \*(C`new()\*(C' method does the right thing to fold named arguments into a hash reference for passing to the \*(C`init()\*(C' method.  Thus, the following are equivalent:</p><p>    # hash reference     my $module = My::Funky::Module-&gt;new({         foo =&gt; &apos;bar&apos;,         wiz =&gt; &apos;waz&apos;,     });</p><p>    # list of named arguments (no enclosing &apos;{&apos; ... &apos;}&apos;)     my $module = My::Funky::Module-&gt;new(         foo =&gt; &apos;bar&apos;,         wiz =&gt; &apos;waz&apos;     );</p><p>Within the \*(C`init()\*(C' method, you can either handle the configuration yourself:</p><p>    sub init {         my ($self, $config) = @_;</p><p>        $self-&gt;{ file } = $config-&gt;{ file }             || return $self-&gt;error(&apos;no file specified&apos;);</p><p>        return $self;     }</p><p>or you can call the \*(C`params()\*(C' method to do it for you:</p><p>    sub init {         my ($self, $config) = @_;</p><p>        $self-&gt;params($config, &apos;file&apos;)             || return $self-&gt;error(&apos;no file specified&apos;);</p><p>        return $self;     }</p>
<h3>Error Handling</h3>
<p>The \*(C`init()\*(C' method should return $self to indicate success or undef to indicate a failure.  You can use the \*(C`error()\*(C' method to report an error within the \*(C`init()\*(C' method.  The \*(C`error()\*(C' method returns undef, so you can use it like this:</p><p>    sub init {         my ($self, $config) = @_;</p><p>        # let&apos;s make &apos;foobar&apos; a mandatory argument         $self-&gt;{ foobar } = $config-&gt;{ foobar }             || return $self-&gt;error("no foobar argument");</p><p>        return $self;     }</p><p>When you create objects of this class via \*(C`new()\*(C', you should now check the return value.  If undef is returned then the error message can be retrieved by calling \*(C`error()\*(C' as a class method.</p><p>    my $module = My::Funky::Module-&gt;new()           || die My::Funky::Module-&gt;error();</p><p>Alternately, you can inspect the $ERROR package variable which will contain the same error message.</p><p>    my $module = My::Funky::Module-&gt;new()          || die $My::Funky::Module::ERROR;</p><p>Of course, being a conscientious Perl programmer, you will want to be sure that the $ERROR package variable is correctly defined.</p><p>    package My::Funky::Module     use base qw( Class::Base );</p><p>    our $ERROR;</p><p>You can also call \*(C`error()\*(C' as an object method.  If you pass an argument then it will be used to set the internal error message for the object and return undef.  Typically this is used within the module methods to report errors.</p><p>    sub another_method {         my $self = shift;</p><p>        ...</p><p>        # set the object error         return $self-&gt;error(&apos;something bad happened&apos;);     }</p><p>If you don't pass an argument then the \*(C`error()\*(C' method returns the current error value.  Typically this is called from outside the object to determine its status.  For example:</p><p>    my $object = My::Funky::Module-&gt;new()         || die My::Funky::Module-&gt;error();</p><p>    $object-&gt;another_method()         || die $object-&gt;error();</p>
<h3>Debugging Methods</h3>
<p>The module implements two methods to assist in writing debugging code: <em>debug()</em> and <em>debugging()</em>.  Debugging can be enabled on a per-object or per-class basis, or as a combination of the two.</p><p>When creating an object, you can set the \*(C`DEBUG\*(C' flag (or lower case \*(C`debug\*(C' if you prefer) to enable or disable debugging for that one object.</p><p>    my $object = My::Funky::Module-&gt;new( debug =&gt; 1 )           || die My::Funky::Module-&gt;error();</p><p>    my $object = My::Funky::Module-&gt;new( DEBUG =&gt; 1 )           || die My::Funky::Module-&gt;error();</p><p>If you don't explicitly specify a debugging flag then it assumes the value of the $DEBUG package variable in your derived class or 0 if that isn't defined.</p><p>You can also switch debugging on or off via the \*(C`debugging()\*(C' method.</p><p>    $object-&gt;<strong>debugging</strong>(0);      # debug off     $object-&gt;<strong>debugging</strong>(1);      # debug on</p><p>The \*(C`debug()\*(C' method examines the internal debugging flag (the \*(C`_DEBUG\*(C' member within the $self hash) and if it finds it set to any true value then it prints to \s-1STDERR\s0 all the arguments passed to it.  The output is prefixed by a tag containing the class name of the object in square brackets (but see the \*(C`id()\*(C' method below for details on how to change that value).</p><p>For example, calling the method as:</p><p>    $object-&gt;debug(&apos;foo&apos;, &apos;bar&apos;);</p><p>prints the following output to \s-1STDERR:\s0</p><p>    [My::Funky::Module] foobar</p><p>When called as class methods, \*(C`debug()\*(C' and \*(C`debugging()\*(C' instead use the $DEBUG package variable in the derived class as a flag to control debugging.  This variable also defines the default \*(C`DEBUG\*(C' flag for any objects subsequently created via the <em>new()</em> method.</p><p>    package My::Funky::Module     use base qw( Class::Base );</p><p>    our $ERROR;     our $DEBUG = 0 unless defined $DEBUG;</p><p>    # some time later, in a module far, far away     package main;</p><p>    # debugging off (by default)     my $object1 = My::Funky::Module-&gt;new();</p><p>    # turn debugging on for My::Funky::Module objects     $My::Funky::Module::DEBUG = 1;</p><p>    # alternate syntax     My::Funky::Module-&gt;<strong>debugging</strong>(1);</p><p>    # debugging on (implicitly from $DEBUG package var)     my $object2 = My::Funky::Module-&gt;new();</p><p>    # debugging off (explicit override)     my $object3 = My::Funky::Module-&gt;new(debug =&gt; 0);</p><p>If you call \*(C`debugging()\*(C' without any arguments then it returns the value of the internal object flag or the package variable accordingly.</p><p>    print "debugging is turned ", $object-&gt;debugging() ? &apos;on&apos; : &apos;off&apos;;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>\fInew()\fP</h3>
<p>Class constructor method which expects a reference to a hash array of parameters or a list of \*(C`name =&gt; value\*(C' pairs which are automagically folded into a hash reference.  The method blesses a hash reference and then calls the \*(C`init()\*(C' method, passing the reference to the hash array of configuration parameters.</p><p>Returns a reference to an object on success or undef on error.  In the latter case, the \*(C`error()\*(C' method can be called as a class method, or the $ERROR package variable (in the derived class' package) can be inspected to return an appropriate error message.</p><p>    my $object = My::Class-&gt;new( foo =&gt; &apos;bar&apos; )   # params list          || die $My::Class::$ERROR;               # package var</p><p>or</p><p>    my $object = My::Class-&gt;new({ foo =&gt; &apos;bar&apos; }) # params hashref           || die My::Class-&gt;error;                # class method</p>
<h3>init(&#92;%config)</h3>
<p>Object initialiser method which is called by the \*(C`new()\*(C' method, passing a reference to a hash array of configuration parameters.  The method may be derived in a subclass to perform any initialisation required.  It should return $self on success, or \*(C`undef\*(C' on error, via a call to the \*(C`error()\*(C' method.</p><p>    package My::Module;     use base qw( Class::Base );</p><p>    sub init {         my ($self, $config) = @_;</p><p>        # let&apos;s make &apos;foobar&apos; a mandatory argument         $self-&gt;{ foobar } = $config-&gt;{ foobar }             || return $self-&gt;error("no foobar argument");</p><p>        return $self;     } The \*(C`params()\*(C' method accept a reference to a hash array as the first argument containing configuration values such as those passed to the \*(C`init()\*(C' method.  The second argument can be a reference to a list of parameter names or a reference to a hash array mapping parameter names to default values.  If the second argument is not a reference then all the remaining arguments are taken as parameter names.  Thus the method can be called as follows:</p><p>    sub init {         my ($self, $config) = @_;</p><p>        # either...         $self-&gt;params($config, qw( foo bar ));</p><p>        # or...         $self-&gt;params($config, [ qw( foo bar ) ]);</p><p>        # or...         $self-&gt;params($config, { foo =&gt; &apos;default foo value&apos;,                                  bar =&gt; &apos;default bar value&apos; } );</p><p>        return $self;     }</p><p>The method looks for values in $config corresponding to the keys specified and copies them, if defined, into $self.</p><p>Keys can be specified in \s-1UPPER\s0 \s-1CASE\s0 and the method will look for either upper or lower case equivalents in the $config hash.  Thus you can call \*(C`params()\*(C' from \*(C`init()\*(C' like so:</p><p>    sub init {         my ($self, $config) = @_;         $self-&gt;params($config, qw( FOO BAR ))         return $self;     }</p><p>but use either case for parameters passed to \*(C`new()\*(C':</p><p>    my $object = My::Module-&gt;new( FOO =&gt; &apos;the foo value&apos;,                                   BAR =&gt; &apos;the bar value&apos; )         || die My::Module-&gt;error();</p><p>    my $object = My::Module-&gt;new( foo =&gt; &apos;the foo value&apos;,                                   bar =&gt; &apos;the bar value&apos; )         || die My::Module-&gt;error();</p><p>Note however that the internal key within $self used to store the value will be in the case provided in the call to \*(C`params()\*(C' (upper case in this example).  The method doesn't look for upper case equivalents when they are specified in lower case.</p><p>When called in list context, the method returns a list of all the values corresponding to the list of keys, some of which may be undefined (allowing you to determine which values were successfully set if you need to).  When called in scalar context it returns a reference to the same list.</p>
<h3>\fIclone()\fP</h3>
<p>The \*(C`clone()\*(C' method performs a simple shallow copy of the object hash and creates a new object blessed into the same class.  You may want to provide your own \*(C`clone()\*(C' method to perform a more complex cloning operation.</p><p>    my $clone = $object-&gt;clone();</p>
<h3>error($msg, ...)</h3>
<p>General purpose method for getting and setting error messages.  When called as a class method, it returns the value of the $ERROR package variable (in the derived class' package) if called without any arguments, or sets the same variable when called with one or more arguments.  Multiple arguments are concatenated together.</p><p>    # set error     My::Module-&gt;error(&apos;set the error string&apos;);     My::Module-&gt;error(&apos;set &apos;, &apos;the &apos;, &apos;error string&apos;);</p><p>    # get error     print My::Module-&gt;error();     print $My::Module::ERROR;</p><p>When called as an object method, it operates on the \*(C`_ERROR\*(C' member of the object, returning it when called without any arguments, or setting it when called with arguments.</p><p>    # set error     $object-&gt;error(&apos;set the error string&apos;);</p><p>    # get error     print $object-&gt;error();</p><p>The method returns \*(C`undef\*(C' when called with arguments.  This allows it to be used within object methods as shown:</p><p>    sub my_method {         my $self = shift;</p><p>        # set error and return undef in one         return $self-&gt;error(&apos;bad, bad, error&apos;)             if $something_bad;     } Prints all arguments to \s-1STDERR\s0 if the internal \*(C`_DEBUG\*(C' flag (when called as an object method) or $DEBUG package variable (when called as a class method) is set to a true value.  Otherwise does nothing. The output is prefixed by a string of the form \*(L"[Class::Name]\*(R" where the name of the class is that returned by the \*(C`id()\*(C' method.</p>
<h3>debugging($flag)</h3>
<p>Used to get (no arguments) or set ($flag defined) the value of the internal \*(C`_DEBUG\*(C' flag (when called as an object method) or $DEBUG package variable (when called as a class method).</p>
<h3>id($newid)</h3>
<p>The \*(C`debug()\*(C' method calls this method to return an identifier for the object for printing in the debugging message.  By default it returns the class name of the object (i.e. \*(C`ref $self\*(C'), but you can of course subclass the method to return some other value.  When called with an argument it uses that value to set its internal \*(C`_ID\*(C' field which will be returned by subsequent calls to \*(C`id()\*(C'.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Andy Wardley &lt;abw@kfs.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This is version 0.04 of Class::Base.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p>This module began life as the Template::Base module distributed as part of the Template Toolkit.</p><p>Thanks to Brian Moseley and Matt Sergeant for suggesting various enhancments, some of which went into version 0.02.</p><p>Version 0.04 was uploaded by Gabor Szabo.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 1996-2012 Andy Wardley.  All Rights Reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::Autouse.3pm.html"><span aria-hidden="true">&larr;</span> Class::Autouse.3pm: Run-time load a class the first time you call a method in it.</a></li>
   <li class="next"><a href="Class::C3::Adopt::NEXT.3pm.html">Class::C3::Adopt::NEXT.3pm: Make next suck less <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

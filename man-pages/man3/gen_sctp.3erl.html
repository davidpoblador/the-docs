<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gen_sctp: The gen_sctp module provides functions for communicating with sockets using the sctp protocol.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The gen_sctp module provides functions for communicating with sockets using the sctp protocol.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gen_sctp (3erl) manual">
  <meta name="twitter:description" content="The gen_sctp module provides functions for communicating with sockets using the sctp protocol.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-gen_sctp-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/gen_sctp.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gen_sctp (3erl) manual" />
  <meta property="og:description" content="The gen_sctp module provides functions for communicating with sockets using the sctp protocol." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-gen_sctp-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gen_sctp<small> (3erl)</small></h1>
        <p class="lead">The gen_sctp module provides functions for communicating with sockets using the sctp protocol.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gen_sctp.3erl.html">
      <span itemprop="name">gen_sctp: The gen_sctp module provides functions for communicating with sockets using the sctp protocol.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gen_sctp.3erl.html">
      <span itemprop="name">gen_sctp: The gen_sctp module provides functions for communicating with sockets using the sctp protocol.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <em>gen_sctp</em> module provides functions for communicating with sockets using the SCTP protocol. The implementation assumes that the OS kernel supports SCTP (RFC2960) through the user-level Sockets API Extensions. During development this implementation was tested on Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed), and on Solaris 10, 11. During OTP adaptation it was tested on SUSE Linux Enterprise Server 10 (x86_64) kernel 2.6.16.27-0.6-smp, with lksctp-tools-1.0.6, briefly on Solaris 10, and later on SUSE Linux Enterprise Server 10 Service Pack 1 (x86_64) kernel 2.6.16.54-0.2.3-smp with lksctp-tools-1.0.7, and later also on FreeBSD 8.2.</p><p>This module was written for one-to-many style sockets (type <em>seqpacket</em>). With the addition of <strong>peeloff/2</strong>, one-to-one style sockets (type <em>stream</em>) were introduced.</p><p>Record definitions for the <em>gen_sctp</em> module can be found using:</p>
<pre>
  -include_lib("kernel/include/inet_sctp.hrl").
</pre>
<p>These record definitions use the "new" spelling 'adaptation', not the deprecated 'adaption', regardless of which spelling the underlying C API uses.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTENTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><strong>DATA TYPES</strong></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><strong>EXPORTS</strong></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><strong>SCTP SOCKET OPTIONS</strong></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><strong>SCTP EXAMPLES</strong></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><strong>SEE ALSO</strong></p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
<strong>assoc_id()</strong>

</pre>
<p>An opaque term returned in for example #sctp_paddr_change{} that identifies an association for an SCTP socket. The term is opaque except for the special value <em>0</em> that has a meaning such as "the whole endpoint" or "all future associations".</p>
<pre>
<strong>option()</strong> = {active, true | false | once | -32768..32767}

         | {buffer, integer() &gt;= 0}

         | {dontroute, boolean()}

         | {high_msgq_watermark, integer() &gt;= 1}

         | {linger, {boolean(), integer() &gt;= 0}}

         | {low_msgq_watermark, integer() &gt;= 1}

         | {mode, list | binary}

         | list

         | binary

         | {priority, integer() &gt;= 0}

         | {recbuf, integer() &gt;= 0}

         | {reuseaddr, boolean()}

         | {ipv6_v6only, boolean()}

         | {sctp_adaptation_layer, #sctp_setadaptation{}}

         | {sctp_associnfo, #sctp_assocparams{}}

         | {sctp_autoclose, integer() &gt;= 0}

         | {sctp_default_send_param, #sctp_sndrcvinfo{}}

         | {sctp_delayed_ack_time, #sctp_assoc_value{}}

         | {sctp_disable_fragments, boolean()}

         | {sctp_events, #sctp_event_subscribe{}}

         | {sctp_get_peer_addr_info, #sctp_paddrinfo{}}

         | {sctp_i_want_mapped_v4_addr, boolean()}

         | {sctp_initmsg, #sctp_initmsg{}}

         | {sctp_maxseg, integer() &gt;= 0}

         | {sctp_nodelay, boolean()}

         | {sctp_peer_addr_params, #sctp_paddrparams{}}

         | {sctp_primary_addr, #sctp_prim{}}

         | {sctp_rtoinfo, #sctp_rtoinfo{}}

         | {sctp_set_peer_primary_addr, #sctp_setpeerprim{}}

         | {sctp_status, #sctp_status{}}

         | {sndbuf, integer() &gt;= 0}

         | {tos, integer() &gt;= 0}

</pre>
<p>One of the <strong>SCTP Socket Options.</strong></p>
<pre>
<strong>option_name()</strong> = active

              | buffer

              | dontroute

              | high_msgq_watermark

              | linger

              | low_msgq_watermark

              | mode

              | priority

              | recbuf

              | reuseaddr

              | ipv6_v6only

              | sctp_adaptation_layer

              | sctp_associnfo

              | sctp_autoclose

              | sctp_default_send_param

              | sctp_delayed_ack_time

              | sctp_disable_fragments

              | sctp_events

              | sctp_get_peer_addr_info

              | sctp_i_want_mapped_v4_addr

              | sctp_initmsg

              | sctp_maxseg

              | sctp_nodelay

              | sctp_peer_addr_params

              | sctp_primary_addr

              | sctp_rtoinfo

              | sctp_set_peer_primary_addr

              | sctp_status

              | sndbuf

              | tos

</pre>

<pre>
<strong></strong>
<strong>sctp_socket()</strong>

</pre>
<p>Socket identifier returned from <em>open/*</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
abort(Socket, Assoc) -&gt; ok | {error, inet:posix()}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Assoc = #sctp_assoc_change{}</p><p>Abnormally terminates the association given by <em>Assoc</em>, without flushing of unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and it can be used in new associations.</p>
<pre>
<strong></strong>
close(Socket) -&gt; ok | {error, inet:posix()}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Completely closes the socket and all associations on it. The unsent data is flushed as in <em>eof/2</em>. The <em>close/1</em> call is blocking or otherwise depending of the value of the <strong>linger</strong> socket <strong>option</strong>. If <em>close</em> does not linger or linger timeout expires, the call returns and the data is flushed in the background.</p>
<pre>
<strong></strong>
connect(Socket, Addr, Port, Opts) -&gt;
<strong></strong>
           {ok, Assoc} | {error, inet:posix()}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Addr = <strong>inet:ip_address()</strong> | <strong>inet:hostname()</strong></p><p>Port = <strong>inet:port_number()</strong></p><p>Opts = [Opt :: <strong>option()</strong>]</p><p>Assoc = #sctp_assoc_change{}</p><p>Same as <em>connect(Socket, Addr, Port, Opts, infinity)</em>.</p>
<pre>
<strong></strong>
connect(Socket, Addr, Port, Opts, Timeout) -&gt;
<strong></strong>
           {ok, Assoc} | {error, inet:posix()}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Addr = <strong>inet:ip_address()</strong> | <strong>inet:hostname()</strong></p><p>Port = <strong>inet:port_number()</strong></p><p>Opts = [Opt :: <strong>option()</strong>]</p><p>Timeout = timeout()</p><p>Assoc = #sctp_assoc_change{}</p><p>Establishes a new association for the socket <em>Socket</em>, with the peer (SCTP server socket) given by <em>Addr</em> and <em>Port</em>. The <em>Timeout</em>, is expressed in milliseconds. A socket can be associated with multiple peers.</p><p><strong>WARNING:</strong> Using a value of <em>Timeout</em> less than the maximum time taken by the OS to establish an association (around 4.5 minutes if the default values from RFC 4960 are used) can result in inconsistent or incorrect return values. This is especially relevant for associations sharing the same <em>Socket</em> (i.e. source address and port) since the controlling process blocks until <em>connect/*</em> returns. <strong>connect_init/*</strong> provides an alternative not subject to this limitation.</p><p>The result of <em>connect/*</em> is an <em>#sctp_assoc_change{}</em> event which contains, in particular, the new <strong>Association ID</strong>.</p>
<pre>
   #sctp_assoc_change{
        state             = atom(),
        error             = atom(),
        outbound_streams  = integer(),
        inbound_streams   = integer(),
        assoc_id          = assoc_id()
  }
</pre>
<p>The number of outbound and inbound streams can be set by giving an <em>sctp_initmsg</em> option to <em>connect</em> as in:</p>
<pre>
  connect(Socket, Ip, Port,
        [{sctp_initmsg,#sctp_initmsg{num_ostreams=OutStreams,
                                     max_instreams=MaxInStreams}}])
</pre>
<p>All options <em>Opt</em> are set on the socket before the association is attempted. If an option record has got undefined field values, the options record is first read from the socket for those values. In effect, <em>Opt</em> option records only define field values to change before connecting.</p><p>The returned <em>outbound_streams</em> and <em>inbound_streams</em> are the actual stream numbers on the socket, which may be different from the requested values (<em>OutStreams</em> and <em>MaxInStreams</em> respectively) if the peer requires lower values.</p><p>The following values of <em>state</em> are possible:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>comm_up</em>: association successfully established. This indicates a successful completion of <em>connect</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>cant_assoc</em>: association cannot be established (<em>connect/*</em> failure).</p>
  </dd>

</dl>
<p>All other states do not normally occur in the output from <em>connect/*</em>. Rather, they may occur in <em>#sctp_assoc_change{}</em> events received instead of data in <strong>recv/*</strong> calls. All of them indicate losing the association due to various error conditions, and are listed here for the sake of completeness. The <em>error</em> field may provide more detailed diagnostics.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>comm_lost</em>;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>restart</em>;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>shutdown_comp</em>.</p>
  </dd>

</dl>

<pre>
<strong></strong>
connect_init(Socket, Addr, Port, Opts) -&gt;
<strong></strong>
                ok | {error, inet:posix()}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Addr = <strong>inet:ip_address()</strong> | <strong>inet:hostname()</strong></p><p>Port = <strong>inet:port_number()</strong></p><p>Opts = [<strong>option()</strong>]</p><p>Same as <em>connect_init(Socket, Addr, Port, Opts, infinity)</em>.</p>
<pre>
<strong></strong>
connect_init(Socket, Addr, Port, Opts, Timeout) -&gt;
<strong></strong>
                ok | {error, inet:posix()}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Addr = <strong>inet:ip_address()</strong> | <strong>inet:hostname()</strong></p><p>Port = <strong>inet:port_number()</strong></p><p>Opts = [<strong>option()</strong>]</p><p>Timeout = timeout()</p><p>Initiates a new association for the socket <em>Socket</em>, with the peer (SCTP server socket) given by <em>Addr</em> and <em>Port</em>.</p><p>The fundamental difference between this API and <em>connect/*</em> is that the return value is that of the underlying OS <a href="../man2/connect.2.html"><strong>connect</strong>(2)</a> system call. If <em>ok</em> is returned then the result of the association establishement is received by the calling process as an <strong> #sctp_assoc_change{}</strong> event. The calling process must be prepared to receive this, or poll for it using <em>recv/*</em> depending on the value of the active option.</p><p>The parameters are as described in <strong>connect/*</strong>, with the exception of the <em>Timeout</em> value.</p><p>The timer associated with <em>Timeout</em> only supervises IP resolution of <em>Addr</em></p>
<pre>
<strong></strong>
controlling_process(Socket, Pid) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Pid = pid()</p><p>Reason = closed | not_owner | <strong>inet:posix()</strong></p><p>Assigns a new controlling process <em>Pid</em> to <em>Socket</em>. Same implementation as <em>gen_udp:controlling_process/2</em>.</p>
<pre>
<strong></strong>
eof(Socket, Assoc) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Assoc = #sctp_assoc_change{}</p><p>Reason = term()</p><p>Gracefully terminates the association given by <em>Assoc</em>, with flushing of all unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and it can be used in new associations.</p>
<pre>
<strong></strong>
listen(Socket, IsServer) -&gt; ok | {error, Reason}

</pre>

<pre>
<strong></strong>
listen(Socket, Backlog) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Backlog = integer()</p><p>Reason = term()</p><p>Sets up a socket to listen on the IP address and port number it is bound to.</p><p>For type <em>seqpacket</em> sockets (the default) <em>IsServer</em> must be <em>true</em> or <em>false</em>. In contrast to TCP, in SCTP there is no listening queue length. If <em>IsServer</em> is <em>true</em> the socket accepts new associations, i.e. it will become an SCTP server socket.</p><p>For type <em>stream</em> sockets Backlog defines the backlog queue length just like in TCP.</p>
<pre>
<strong></strong>
open() -&gt; {ok, Socket} | {error, inet:posix()}

</pre>

<pre>
<strong></strong>
open(Port) -&gt; {ok, Socket} | {error, inet:posix()}

</pre>

<pre>
<strong></strong>
open(Opts) -&gt; {ok, Socket} | {error, inet:posix()}

</pre>

<pre>
<strong></strong>
open(Port, Opts) -&gt; {ok, Socket} | {error, inet:posix()}

</pre>
<p>Types:</p><p>Opts = [Opt]</p><p>Opt = {ip, IP}</p>
<pre>
    | {ifaddr, IP}
</pre>

<pre>
    | <strong>inet:address_family()</strong>
</pre>

<pre>
    | {port, Port}
</pre>

<pre>
    | {type, SockType}
</pre>

<pre>
    | <strong>option()</strong>
</pre>
<p>IP = <strong>inet:ip_address()</strong> | any | loopback</p><p>Port = <strong>inet:port_number()</strong></p><p>SockType = seqpacket | stream</p><p>Socket = <strong>sctp_socket()</strong></p><p>Creates an SCTP socket and binds it to the local addresses specified by all <em>{ip,IP}</em> (or synonymously <em>{ifaddr,IP}</em>) options (this feature is called SCTP multi-homing). The default <em>IP</em> and <em>Port</em> are <em>any</em> and <em>0</em>, meaning bind to all local addresses on any one free port.</p><p>Other options are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>inet6</em>: Set up the socket for IPv6.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>inet</em>: Set up the socket for IPv4. This is the default.</p>
  </dd>

</dl>
<p>A default set of socket <strong>options</strong> is used. In particular, the socket is opened in <strong>binary</strong> and <strong>passive</strong> mode, with SockType <em>seqpacket</em>, and with reasonably large <strong>kernel</strong> and driver <strong>buffers.</strong></p>
<pre>
<strong></strong>
peeloff(Socket, Assoc) -&gt; {ok, NewSocket} | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Assoc = #sctp_assoc_change{} | <strong>assoc_id()</strong></p><p>NewSocket = <strong>sctp_socket()</strong></p><p>Reason = term()</p><p>Branch off an existing association Assoc in a socket Socket of type <em>seqpacket</em> (one-to-many style) into a new socket NewSocket of type <em>stream</em> (one-to-one style).</p><p>The existing association argument Assoc can be either a <strong> #sctp_assoc_change{} </strong> record as returned from e.g <strong>recv/*</strong>, <strong>connect/*</strong> or from a listening socket in active mode. Or it can be just the field <em>assoc_id</em> integer from such a record.</p>
<pre>
<strong></strong>
recv(Socket) -&gt;
<strong></strong>
        {ok, {FromIP, FromPort, AncData, Data}} | {error, Reason}

</pre>

<pre>
<strong></strong>
recv(Socket, Timeout) -&gt;
<strong></strong>
        {ok, {FromIP, FromPort, AncData, Data}} | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Timeout = timeout()</p><p>FromIP = <strong>inet:ip_address()</strong></p><p>FromPort = <strong>inet:port_number()</strong></p><p>AncData = [#sctp_sndrcvinfo{}]</p><p>Data = binary()</p>
<pre>
     | string()
</pre>

<pre>
     | #sctp_sndrcvinfo{}
</pre>

<pre>
     | #sctp_assoc_change{}
</pre>

<pre>
     | #sctp_paddr_change{}
</pre>

<pre>
     | #sctp_adaptation_event{}
</pre>
<p>Reason = <strong>inet:posix()</strong></p>
<pre>
       | #sctp_send_failed{}
</pre>

<pre>
       | #sctp_paddr_change{}
</pre>

<pre>
       | #sctp_pdapi_event{}
</pre>

<pre>
       | #sctp_remote_error{}
</pre>

<pre>
       | #sctp_shutdown_event{}
</pre>
<p>Receives the <em>Data</em> message from any association of the socket. If the receive times out <em>{error,timeout</em> is returned. The default timeout is <em>infinity</em>. <em>FromIP</em> and <em>FromPort</em> indicate the sender's address.</p><p><em>AncData</em> is a list of Ancillary Data items which may be received along with the main <em>Data</em>. This list can be empty, or contain a single <strong>#sctp_sndrcvinfo{}</strong> record, if receiving of such ancillary data is enabled (see option <strong>sctp_events</strong>). It is enabled by default, since such ancillary data provide an easy way of determining the association and stream over which the message has been received. (An alternative way would be to get the Association ID from the <em>FromIP</em> and <em>FromPort</em> using the <strong>sctp_get_peer_addr_info</strong> socket option, but this would still not produce the Stream number).</p><p>The actual <em>Data</em> received may be a <em>binary()</em>, or <em>list()</em> of bytes (integers in the range 0 through 255) depending on the socket mode, or an SCTP Event. The following SCTP Events are possible:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><strong>#sctp_sndrcvinfo{}</strong></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><strong>#sctp_assoc_change{}</strong>;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<pre>
  #sctp_paddr_change{
        addr      = {ip_address(),port()},
        state     = atom(),
        error     = integer(),
        assoc_id  = assoc_id()
  }
</pre>
<p>Indicates change of the status of the peer's IP address given by <em>addr</em> within the association <em>assoc_id</em>. Possible values of <em>state</em> (mostly self-explanatory) include:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>addr_unreachable</em>;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>addr_available</em>;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>addr_removed</em>;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>addr_added</em>;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>addr_made_prim</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>addr_confirmed</em>.</p>
  </dd>

</dl>
<p>In case of an error (e.g. <em>addr_unreachable</em>), the <em>error</em> field provides additional diagnostics. In such cases, the <em>#sctp_paddr_change{}</em> Event is automatically converted into an <em>error</em> term returned by <em>gen_sctp:recv</em>. The <em>error</em> field value can be converted into a string using <em>error_string/1</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<pre>
  #sctp_send_failed{
        flags     = true | false,
        error     = integer(),
        info      = #sctp_sndrcvinfo{},
        assoc_id  = assoc_id()
        data      = binary()
  }
</pre>
<p>The sender may receive this event if a send operation fails. The <em>flags</em> is a Boolean specifying whether the data have actually been transmitted over the wire; <em>error</em> provides extended diagnostics, use <em>error_string/1</em>; <em>info</em> is the original <strong>#sctp_sndrcvinfo{}</strong> record used in the failed <strong>send/*,</strong> and <em>data</em> is the whole original data chunk attempted to be sent.</p><p>In the current implementation of the Erlang/SCTP binding, this Event is internally converted into an <em>error</em> term returned by <em>recv/*</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<pre>
  #sctp_adaptation_event{
        adaptation_ind = integer(),
        assoc_id       = assoc_id()
  }
</pre>
<p>Delivered when a peer sends an Adaptation Layer Indication parameter (configured through the option <strong>sctp_adaptation_layer</strong>). Note that with the current implementation of the Erlang/SCTP binding, this event is disabled by default.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<pre>
  #sctp_pdapi_event{
        indication = sctp_partial_delivery_aborted,
        assoc_id   = assoc_id()
  }
</pre>
<p>A partial delivery failure. In the current implementation of the Erlang/SCTP binding, this Event is internally converted into an <em>error</em> term returned by <em>recv/*</em>.</p>
<pre>
<strong></strong>
send(Socket, SndRcvInfo, Data) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>SndRcvInfo = #sctp_sndrcvinfo{}</p><p>Data = binary() | iolist()</p><p>Reason = term()</p><p>Sends the <em>Data</em> message with all sending parameters from a <strong>#sctp_sndrcvinfo{}</strong> record. This way, the user can specify the PPID (passed to the remote end) and Context (passed to the local SCTP layer) which can be used for example for error identification. However, such a fine level of user control is rarely required. The send/4 function is sufficient for most applications.</p>
<pre>
<strong></strong>
send(Socket, Assoc, Stream, Data) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>Socket = <strong>sctp_socket()</strong></p><p>Assoc = #sctp_assoc_change{} | <strong>assoc_id()</strong></p><p>Stream = integer()</p><p>Data = binary() | iolist()</p><p>Reason = term()</p><p>Sends <em>Data</em> message over an existing association and given stream.</p>
<pre>
<strong></strong>
error_string(ErrorNumber) -&gt; ok | string() | unknown_error

</pre>
<p>Types:</p><p>ErrorNumber = integer()</p><p>Translates an SCTP error number from for example <em>#sctp_remote_error{}</em> or <em>#sctp_send_failed{}</em> into an explanatory string, or one of the atoms <em>ok</em> for no error and <em>undefined</em> for an unrecognized error.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SCTP SOCKET OPTIONS</h2>
        <div class="sectioncontent">
<p>The set of admissible SCTP socket options is by construction orthogonal to the sets of TCP, UDP and generic INET options: only those options which are explicitly listed below are allowed for SCTP sockets. Options can be set on the socket using <strong></strong><em>gen_sctp:open/1,2</em> or <strong></strong><em>inet:setopts/2</em>, retrieved using <strong></strong><em>inet:getopts/2</em>, and when calling <strong></strong><em>gen_sctp:connect/4,5</em> options can be changed.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{mode, list|binary}</em> or just <em>list</em> or <em>binary</em>: Determines the type of data returned from <em>gen_sctp:recv/1,2</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{active, true|false|once|N}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If <em>false</em> (passive mode, the default), the caller needs to do an explicit <em>gen_sctp:recv</em> call in order to retrieve the available data from the socket.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If <em>true</em> (full active mode), the pending data or events are sent to the owning process.</p><p><em>NB:</em> This can cause the message queue to overflow, as there is no way to throttle the sender in this case (no flow control!).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If <em>once</em>, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control as well as the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If <em>active</em> is specified as an integer <em>N</em> in the range -32768 to 32767 (inclusive), then that number is added to the socket's count of the number of data messages to be delivered to the controlling process. If the result of the addition would be negative, the count is set to 0. Once the count reaches 0, either through the delivery of messages or by being explicitly set with <strong>inet:setopts/2</strong>, the socket's mode is automatically reset to passive (<em>{active, false}</em>) mode. When a socket in this active mode transitions to passive mode, the message <em>{sctp_passive, Socket}</em> is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call <strong>inet:setopts/2</strong> to set the socket back into an active mode.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{tos, integer()}</em>: Sets the Type-Of-Service field on the IP datagrams being sent, to the given value, which effectively determines a prioritization policy for the outbound packets. The acceptable values are system-dependent. TODO: we do not provide symbolic names for these values yet.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{priority, integer()}</em>: A protocol-independent equivalent of <em>tos</em> above. Setting priority implies setting tos as well.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{dontroute, true|false}</em>: By default <em>false</em>. If <em>true</em>, the kernel does not send packets via any gateway, only sends them to directly connected hosts.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{reuseaddr, true|false}</em>: By default <em>false</em>. If true, the local binding address <em>{IP,Port}</em> of the socket can be re-used immediately: no waiting in the CLOSE_WAIT state is performed (may be required for high-throughput servers).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sndbuf, integer()}</em>: The size, in bytes, of the *kernel* send buffer for this socket. Sending errors would occur for datagrams larger than <em>val(sndbuf)</em>. Setting this option also adjusts the size of the driver buffer (see <em>buffer</em> above).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{recbuf, integer()}</em>: The size, in bytes, of the *kernel* recv buffer for this socket. Sending errors would occur for datagrams larger than <em>val(sndbuf)</em>. Setting this option also adjusts the size of the driver buffer (see <em>buffer</em> above).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_module, module()}</em>: Override which callback module is used. Defaults to <em>inet_sctp</em> for IPv4 and <em>inet6_sctp</em> for IPv6.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_rtoinfo, #sctp_rtoinfo{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_rtoinfo{
        assoc_id = assoc_id(),
        initial  = integer(),
        max      = integer(),
        min      = integer()
  }
</pre>
<p>Determines re-transmission time-out parameters, in milliseconds, for the association(s) given by <em>assoc_id</em>. If <em>assoc_id = 0</em> (default) indicates the whole endpoint. See RFC2960 and Sockets API Extensions for SCTP for the exact semantics of the fields values.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_associnfo, #sctp_assocparams{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_assocparams{
        assoc_id                 = assoc_id(),
        asocmaxrxt               = integer(),
        number_peer_destinations = integer(),
        peer_rwnd                = integer(),
        local_rwnd               = integer(),
        cookie_life              = integer()
  }
</pre>
<p>Determines association parameters for the association(s) given by <em>assoc_id</em>. <em>assoc_id = 0</em> (default) indicates the whole endpoint. See Sockets API Extensions for SCTP for the discussion of their semantics. Rarely used.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_initmsg, #sctp_initmsg{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_initmsg{
       num_ostreams   = integer(),
       max_instreams  = integer(),
       max_attempts   = integer(),
       max_init_timeo = integer()
  }
</pre>
<p>Determines the default parameters which this socket attempts to negotiate with its peer while establishing an association with it. Should be set after <em>open/*</em> but before the first <em>connect/*</em>. <em>#sctp_initmsg{}</em> can also be used as ancillary data with the first call of <em>send/*</em> to a new peer (when a new association is created).</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>num_ostreams</em>: number of outbound streams;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>max_instreams</em>: max number of in-bound streams;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>max_attempts</em>: max re-transmissions while establishing an association;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>max_init_timeo</em>: time-out in milliseconds for establishing an association.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_autoclose, integer() &gt;= 0}</em>: Determines the time (in seconds) after which an idle association is automatically closed. <em>0</em> means that the association is never automatically closed.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_nodelay, true|false}</em>: Turns on|off the Nagle algorithm for merging small packets into larger ones (which improves throughput at the expense of latency).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_disable_fragments, true|false}</em>: If <em>true</em>, induces an error on an attempt to send a message which is larger than the current PMTU size (which would require fragmentation/re-assembling). Note that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_i_want_mapped_v4_addr, true|false}</em>: Turns on|off automatic mapping of IPv4 addresses into IPv6 ones (if the socket address family is AF_INET6).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_maxseg, integer()}</em>: Determines the maximum chunk size if message fragmentation is used. If <em>0</em>, the chunk size is limited by the Path MTU only.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_primary_addr, #sctp_prim{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_prim{
        assoc_id = assoc_id(),
        addr     = {IP, Port}
  }
  IP = ip_address()
  Port = port_number()
</pre>
<p>For the association given by <em>assoc_id</em>, <em>{IP,Port}</em> must be one of the peer's addresses. This option determines that the given address is treated by the local SCTP stack as the peer's primary address.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_set_peer_primary_addr, #sctp_setpeerprim{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_setpeerprim{
        assoc_id = assoc_id(),
        addr     = {IP, Port}
  }
  IP = ip_address()
  Port = port_number()
</pre>
<p>When set, informs the peer that it should use <em>{IP, Port}</em> as the primary address of the local endpoint for the association given by <em>assoc_id</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_adaptation_layer, #sctp_setadaptation{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_setadaptation{
        adaptation_ind = integer()
  }
</pre>
<p>When set, requests that the local endpoint uses the value given by <em>adaptation_ind</em> as the Adaptation Indication parameter for establishing new associations. See RFC2960 and Sockets API Extenstions for SCTP for more details.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_peer_addr_params, #sctp_paddrparams{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_paddrparams{
        assoc_id   = assoc_id(),
        address    = {IP, Port},
        hbinterval = integer(),
        pathmaxrxt = integer(),
        pathmtu    = integer(),
        sackdelay  = integer(),
        flags      = list()
  }
  IP = ip_address()
  Port = port_number()
</pre>
<p>This option determines various per-address parameters for the association given by <em>assoc_id</em> and the peer address <em>address</em> (the SCTP protocol supports multi-homing, so more than 1 address can correspond to a given association).</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>hbinterval</em>: heartbeat interval, in milliseconds;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>pathmaxrxt</em>: max number of retransmissions before this address is considered unreachable (and an alternative address is selected);</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>pathmtu</em>: fixed Path MTU, if automatic discovery is disabled (see <em>flags</em> below);</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sackdelay</em>: delay in milliseconds for SAC messages (if the delay is enabled, see <em>flags</em> below);</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>flags</em>: the following flags are available:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>hb_enable</em>: enable heartbeat;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>hb_disable</em>: disable heartbeat;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>hb_demand</em>: initiate heartbeat immediately;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>pmtud_enable</em>: enable automatic Path MTU discovery;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>pmtud_disable</em>: disable automatic Path MTU discovery;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sackdelay_enable</em>: enable SAC delay;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sackdelay_disable</em>: disable SAC delay.</p>
  </dd>

</dl>

  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_default_send_param, #sctp_sndrcvinfo{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_sndrcvinfo{
        stream     = integer(),
        ssn        = integer(),
        flags      = list(),
        ppid       = integer(),
        context    = integer(),
        timetolive = integer(),
        tsn        = integer(),
        cumtsn     = integer(),
        assoc_id   = assoc_id()
  }
</pre>
<p><em>#sctp_sndrcvinfo{}</em> is used both in this socket option, and as ancillary data while sending or receiving SCTP messages. When set as an option, it provides a default values for subsequent <em>gen_sctp:send</em>calls on the association given by <em>assoc_id</em>. <em>assoc_id = 0</em> (default) indicates the whole endpoint. The following fields typically need to be specified by the sender:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sinfo_stream</em>: stream number (0-base) within the association to send the messages through;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sinfo_flags</em>: the following flags are recognised:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>unordered</em>: the message is to be sent unordered;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>addr_over</em>: the address specified in <em>gen_sctp:send</em> overwrites the primary peer address;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>abort</em>: abort the current association without flushing any unsent data;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>eof</em>: gracefully shut down the current association, with flushing of unsent data.</p>
  </dd>

</dl>
<p>Other fields are rarely used. See RFC2960 and Sockets API Extensions for SCTP for full information.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_events, #sctp_event_subscribe{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_event_subscribe{
          data_io_event          = true | false,
          association_event      = true | false,
          address_event          = true | false,
          send_failure_event     = true | false,
          peer_error_event       = true | false,
          shutdown_event         = true | false,
          partial_delivery_event = true | false,
          adaptation_layer_event = true | false
    }
</pre>
<p>This option determines which <strong>SCTP Events</strong> are to be received (via <strong>recv/*</strong>) along with the data. The only exception is <em>data_io_event</em> which enables or disables receiving of <strong>#sctp_sndrcvinfo{}</strong> ancillary data, not events. By default, all flags except <em>adaptation_layer_event</em> are enabled, although <em>sctp_data_io_event</em> and <em>association_event</em> are used by the driver itself and not exported to the user level.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_delayed_ack_time, #sctp_assoc_value{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_assoc_value{
        assoc_id    = assoc_id(),
        assoc_value = integer()
  }
</pre>
<p>Rarely used. Determines the ACK time (given by <em>assoc_value</em> in milliseconds) for the given association or the whole endpoint if <em>assoc_value = 0</em> (default).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_status, #sctp_status{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_status{
        assoc_id            = assoc_id(),
        state               = atom(),
        rwnd                = integer(),
        unackdata           = integer(),
        penddata            = integer(),
        instrms             = integer(),
        outstrms            = integer(),
        fragmentation_point = integer(),
        primary             = #sctp_paddrinfo{}
  }
</pre>
<p>This option is read-only. It determines the status of the SCTP association given by <em>assoc_id</em>. Possible values of <em>state</em> follows. The state designations are mostly self-explanatory. <em>state_empty</em> is the default which means that no other state is active:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_empty</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_closed</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_cookie_wait</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_cookie_echoed</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_established</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_shutdown_pending</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_shutdown_sent</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_shutdown_received</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sctp_state_shutdown_ack_sent</em></p>
  </dd>

</dl>
<p>The semantics of other fields is the following:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sstat_rwnd</em>: the association peer's current receiver window size;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sstat_unackdata</em>: number of unacked data chunks;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sstat_penddata</em>: number of data chunks pending receipt;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sstat_instrms</em>: number of inbound streams;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sstat_outstrms</em>: number of outbound streams;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sstat_fragmentation_point</em>: message size at which SCTP fragmentation will occur;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>sstat_primary</em>: information on the current primary peer address (see below for the format of <em>#sctp_paddrinfo{}</em>).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sctp_get_peer_addr_info, #sctp_paddrinfo{}}</em>:</p>
  </dd>

</dl>

<pre>
  #sctp_paddrinfo{
        assoc_id  = assoc_id(),
        address   = {IP, Port},
        state     = inactive | active,
        cwnd      = integer(),
        srtt      = integer(),
        rto       = integer(),
        mtu       = integer()
  }
  IP = ip_address()
  Port = port_number()
</pre>
<p>This option is read-only. It determines the parameters specific to the peer's address given by <em>address</em> within the association given by <em>assoc_id</em>. The <em>address</em> field must be set by the caller; all other fields are filled in on return. If <em>assoc_id = 0</em> (default), the <em>address</em> is automatically translated into the corresponding association ID. This option is rarely used; see RFC2960 and Sockets API Extensions for SCTP for the semantics of all fields.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SCTP EXAMPLES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Example of an Erlang SCTP Server which receives SCTP messages and prints them on the standard output:</p>
  </dd>

</dl>

<pre>
  -module(sctp_server).

  -export([server/0,server/1,server/2]).
  -include_lib("kernel/include/inet.hrl").
  -include_lib("kernel/include/inet_sctp.hrl").

  server() -&gt;
      server(any, 2006).

  server([Host,Port]) when is_list(Host), is_list(Port) -&gt;
      {ok, #hostent{h_addr_list = [IP|_]}} = inet:gethostbyname(Host),
      io:format("~w -&gt; ~w~n", [Host, IP]),
      server([IP, list_to_integer(Port)]).

  server(IP, Port) when is_tuple(IP) orelse IP == any orelse IP == loopback,
                        is_integer(Port) -&gt;
      {ok,S} = gen_sctp:open(Port, [{recbuf,65536}, {ip,IP}]),
      io:format("Listening on ~w:~w. ~w~n", [IP,Port,S]),
      ok     = gen_sctp:listen(S, true),
      server_loop(S).

  server_loop(S) -&gt;
      case gen_sctp:recv(S) of
      {error, Error} -&gt;
          io:format("SCTP RECV ERROR: ~p~n", [Error]);
      Data -&gt;
          io:format("Received: ~p~n", [Data])
      end,
      server_loop(S).
</pre>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Example of an Erlang SCTP Client which interacts with the above Server. Note that in this example, the Client creates an association with the Server with 5 outbound streams. For this reason, sending of "Test 0" over Stream 0 succeeds, but sending of "Test 5" over Stream 5 fails. The client then <em>abort</em>s the association, which results in the corresponding Event being received on the Server side.</p>
  </dd>

</dl>

<pre>
  -module(sctp_client).

  -export([client/0, client/1, client/2]).
  -include_lib("kernel/include/inet.hrl").
  -include_lib("kernel/include/inet_sctp.hrl").

  client() -&gt;
      client([localhost]).

  client([Host]) -&gt;
      client(Host, 2006);

  client([Host, Port]) when is_list(Host), is_list(Port) -&gt;
      client(Host,list_to_integer(Port)),
      init:stop().

  client(Host, Port) when is_integer(Port) -&gt;
      {ok,S}     = gen_sctp:open(),
      {ok,Assoc} = gen_sctp:connect
          (S, Host, Port, [{sctp_initmsg,#sctp_initmsg{num_ostreams=5}}]),
      io:format("Connection Successful, Assoc=~p~n", [Assoc]),

      io:write(gen_sctp:send(S, Assoc, 0, &lt;&lt;"Test 0"&gt;&gt;)),
      io:nl(),
      timer:sleep(10000),
      io:write(gen_sctp:send(S, Assoc, 5, &lt;&lt;"Test 5"&gt;&gt;)),
      io:nl(),
      timer:sleep(10000),
      io:write(gen_sctp:abort(S, Assoc)),
      io:nl(),

      timer:sleep(1000),
      gen_sctp:close(S).
</pre>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>A very simple Erlang SCTP Client which uses the connect_init API.</p>
  </dd>

</dl>

<pre>
-module(ex3).

-export([client/4]).
-include_lib("kernel/include/inet.hrl").
-include_lib("kernel/include/inet_sctp.hrl").

client(Peer1, Port1, Peer2, Port2)
  when is_tuple(Peer1), is_integer(Port1), is_tuple(Peer2), is_integer(Port2) -&gt;
    {ok,S}     = gen_sctp:open(),
    SctpInitMsgOpt = {sctp_initmsg,#sctp_initmsg{num_ostreams=5}},
    ActiveOpt = {active, true},
    Opts = [SctpInitMsgOpt, ActiveOpt],
    ok = gen_sctp:connect(S, Peer1, Port1, Opts),
    ok = gen_sctp:connect(S, Peer2, Port2, Opts),
    io:format("Connections initiated~n", []),
    client_loop(S, Peer1, Port1, undefined, Peer2, Port2, undefined).

client_loop(S, Peer1, Port1, AssocId1, Peer2, Port2, AssocId2) -&gt;
    receive
        {sctp, S, Peer1, Port1, {_Anc, SAC}}
          when is_record(SAC, sctp_assoc_change), AssocId1 == undefined -&gt;
            io:format("Association 1 connect result: ~p. AssocId: ~p~n",
                      [SAC#sctp_assoc_change.state,
                       SAC#sctp_assoc_change.assoc_id]),
            client_loop(S, Peer1, Port1, SAC#sctp_assoc_change.assoc_id,
                        Peer2, Port2, AssocId2);

        {sctp, S, Peer2, Port2, {_Anc, SAC}}
          when is_record(SAC, sctp_assoc_change), AssocId2 == undefined -&gt;
            io:format("Association 2 connect result: ~p. AssocId: ~p~n",
                      [SAC#sctp_assoc_change.state, SAC#sctp_assoc_change.assoc_id]),
            client_loop(S, Peer1, Port1, AssocId1, Peer2, Port2,
                        SAC#sctp_assoc_change.assoc_id);

        {sctp, S, Peer1, Port1, Data} -&gt;
            io:format("Association 1: received ~p~n", [Data]),
            client_loop(S, Peer1, Port1, AssocId1,
                        Peer2, Port2, AssocId2);

        {sctp, S, Peer2, Port2, Data} -&gt;
            io:format("Association 2: received ~p~n", [Data]),
            client_loop(S, Peer1, Port1, AssocId1,
                        Peer2, Port2, AssocId2);

        Other -&gt;
            io:format("Other ~p~n", [Other]),
            client_loop(S, Peer1, Port1, AssocId1,
                        Peer2, Port2, AssocId2)

    after 5000 -&gt;
            ok
    end.

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO gen_sctp&hellip;</h2>
        <div class="sectioncontent">
<p><strong>inet(3erl)</strong>, <strong>gen_tcp(3erl)</strong>, <strong>gen_udp(3erl)</strong>, RFC2960 (Stream Control Transmission Protocol), Sockets API Extensions for SCTP.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gen_fsm.3erl.html"><span aria-hidden="true">&larr;</span> gen_fsm.3erl: Generic finite state machine behaviour</a></li>
   <li class="next"><a href="gen_server.3erl.html">gen_server.3erl: Generic server behaviour <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

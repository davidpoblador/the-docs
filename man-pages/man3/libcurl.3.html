<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libcurl: Client-side url transfers</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Client-side url transfers">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libcurl (3) manual">
  <meta name="twitter:description" content="Client-side url transfers">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcurl4-doc-libcurl-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libcurl.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libcurl (3) manual" />
  <meta property="og:description" content="Client-side url transfers" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcurl4-doc-libcurl-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libcurl<small> (3)</small></h1>
        <p class="lead">Client-side url transfers</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libcurl.3.html">
      <span itemprop="name">libcurl: Client-side url transfers</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcurl4-doc/">
      <span itemprop="name">libcurl4-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libcurl.3.html">
      <span itemprop="name">libcurl: Client-side url transfers</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is a short overview on how to use libcurl in your C programs. There are specific man pages for each function mentioned in here. There are also the <a href="../man3/libcurl-easy.3.html"><strong>libcurl-easy</strong>(3)</a></em> man page, the <a href="../man3/libcurl-multi.3.html"><strong>libcurl-multi</strong>(3)</a></em> man page, the <a href="../man3/libcurl-share.3.html"><strong>libcurl-share</strong>(3)</a></em> man page and the <a href="../man3/libcurl-tutorial.3.html"><strong>libcurl-tutorial</strong>(3)</a></em> man page for in-depth understanding on how to program with libcurl.</p><p>There are many bindings available that bring libcurl access to your favourite language. Look elsewhere for documentation on those.</p><p>libcurl has a global constant environment that you must set up and maintain while using libcurl.  This essentially means you call <a href="../man3/curl_global_init.3.html"><strong>curl_global_init</strong>(3)</a></em> at the start of your program and <a href="../man3/curl_global_cleanup.3.html"><strong>curl_global_cleanup</strong>(3)</a></em> at the end.  See <strong>GLOBAL CONSTANTS</strong> below for details.</p><p>To transfer files, you create an "easy handle" using <a href="../man3/curl_easy_init.3.html"><strong>curl_easy_init</strong>(3)</a></em> for a single individual transfer (in either direction). You then set your desired set of options in that handle with <a href="../man3/curl_easy_setopt.3.html"><strong>curl_easy_setopt</strong>(3)</a></em>. Options you set with <a href="../man3/curl_easy_setopt.3.html"><strong>curl_easy_setopt</strong>(3)</a></em> stick. They will be used on every repeated use of this handle until you either change the option, or you reset them all with <a href="../man3/curl_easy_reset.3.html"><strong>curl_easy_reset</strong>(3)</a></em>.</p><p>To actually transfer data you have the option of using the "easy" interface, or the "multi" interface.</p><p>The easy interface is a synchronous interface with which you call <a href="../man3/curl_easy_perform.3.html"><strong>curl_easy_perform</strong>(3)</a></em> and let it perform the transfer. When it is completed, the function returns and you can continue. More details are found in the <a href="../man3/libcurl-easy.3.html"><strong>libcurl-easy</strong>(3)</a></em> man page.</p><p>The multi interface on the other hand is an asynchronous interface, that you call and that performs only a little piece of the transfer on each invoke. It is perfect if you want to do things while the transfer is in progress, or similar. The multi interface allows you to select() on libcurl action, and even to easily download multiple files simultaneously using a single thread. See further details in the <a href="../man3/libcurl-multi.3.html"><strong>libcurl-multi</strong>(3)</a></em> man page.</p><p>You can have multiple easy handles share certain data, even if they are used in different threads. This magic is setup using the share interface, as described in the <a href="../man3/libcurl-share.3.html"><strong>libcurl-share</strong>(3)</a></em> man page.</p><p>There is also a series of other helpful functions to use, including these:</p>
<dl class='dl-vertical'>
  <dt>
    curl_version_info()
  </dt>
  <dd>
    <p>gets detailed libcurl (and other used libraries) version info</p>
  </dd>
  <dt>
    curl_getdate()
  </dt>
  <dd>
    <p>converts a date string to time_t</p>
  </dd>
  <dt>
    curl_easy_getinfo()
  </dt>
  <dd>
    <p>get information about a performed transfer</p>
  </dd>
  <dt>
    curl_formadd()
  </dt>
  <dd>
    <p>helps building an HTTP form POST</p>
  </dd>
  <dt>
    curl_formfree()
  </dt>
  <dd>
    <p>free a list built with <a href="../man3/curl_formadd.3.html"><strong>curl_formadd</strong>(3)</a></em></p>
  </dd>
  <dt>
    curl_slist_append()
  </dt>
  <dd>
    <p>builds a linked list</p>
  </dd>
  <dt>
    curl_slist_free_all()
  </dt>
  <dd>
    <p>frees a whole curl_slist</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LINKING WITH LIBCURL</h2>
        <div class="sectioncontent">
<p>On unix-like machines, there's a tool named curl-config that gets installed with the rest of the curl stuff when 'make install' is performed.</p><p>curl-config is added to make it easier for applications to link with libcurl and developers to learn about libcurl and how to use it.</p><p>Run 'curl-config --libs' to get the (additional) linker options you need to link with the particular version of libcurl you've installed. See the <a href="../man1/curl-config.1.html"><strong>curl-config</strong>(1)</a></em> man page for further details.</p><p>Unix-like operating system that ship libcurl as part of their distributions often don't provide the curl-config tool, but simply install the library and headers in the common path for this purpose.</p><p>Many Linux and similar sytems use pkg-config to provide build and link options about libraries and libcurl supports that as well.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIBCURL SYMBOL NAMES</h2>
        <div class="sectioncontent">
<p>All public functions in the libcurl interface are prefixed with 'curl_' (with a lowercase c). You can find other functions in the library source code, but other prefixes indicate that the functions are private and may change without further notice in the next release.</p><p>Only use documented functions and functionality!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PORTABILITY</h2>
        <div class="sectioncontent">
<p>libcurl works <strong>exactly</strong> the same, on any of the platforms it compiles and builds on.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THREADS</h2>
        <div class="sectioncontent">
<p>Never ever call curl-functions simultaneously using the same handle from several threads. libcurl is thread-safe and can be used in any number of threads, but you must use separate curl handles if you want to use libcurl in more than one thread simultaneously.</p><p>The global environment functions are not thread-safe.  See <strong>GLOBAL</strong> CONSTANTS below for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERSISTENT CONNECTIONS</h2>
        <div class="sectioncontent">
<p>Persistent connections means that libcurl can re-use the same connection for several transfers, if the conditions are right.</p><p>libcurl will <strong>always</strong> attempt to use persistent connections. Whenever you use <a href="../man3/curl_easy_perform.3.html"><strong>curl_easy_perform</strong>(3)</a></em> or <a href="../man3/curl_multi_perform.3.html"><strong>curl_multi_perform</strong>(3)</a></em> etc, libcurl will attempt to use an existing connection to do the transfer, and if none exists it'll open a new one that will be subject for re-use on a possible following call to <a href="../man3/curl_easy_perform.3.html"><strong>curl_easy_perform</strong>(3)</a></em> or <a href="../man3/curl_multi_perform.3.html"><strong>curl_multi_perform</strong>(3)</a></em>.</p><p>To allow libcurl to take full advantage of persistent connections, you should do as many of your file transfers as possible using the same handle.</p><p>If you use the easy interface, and you call <a href="../man3/curl_easy_cleanup.3.html"><strong>curl_easy_cleanup</strong>(3)</a></em>, all the possibly open connections held by libcurl will be closed and forgotten.</p><p>When you've created a multi handle and are using the multi interface, the connection pool is instead kept in the multi handle so closing and creating new easy handles to do transfers will not affect them. Instead all added easy handles can take advantage of the single shared pool.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GLOBAL CONSTANTS</h2>
        <div class="sectioncontent">
<p>There are a variety of constants that libcurl uses, mainly through its internal use of other libraries, which are too complicated for the library loader to set up.  Therefore, a program must call a library function after the program is loaded and running to finish setting up the library code.  For example, when libcurl is built for SSL capability via the GNU TLS library, there is an elaborate tree inside that library that describes the SSL protocol.</p><p><em>curl_global_init()</em> is the function that you must call.  This may allocate resources (e.g. the memory for the GNU TLS tree mentioned above), so the companion function <em>curl_global_cleanup()</em> releases them.</p><p>The basic rule for constructing a program that uses libcurl is this: Call <em>curl_global_init()</em>, with a <em>CURL_GLOBAL_ALL</em> argument, immediately after the program starts, while it is still only one thread and before it uses libcurl at all.  Call <em>curl_global_cleanup()</em> immediately before the program exits, when the program is again only one thread and after its last use of libcurl.</p><p>You can call both of these multiple times, as long as all calls meet these requirements and the number of calls to each is the same.</p><p>It isn't actually required that the functions be called at the beginning and end of the program -- that's just usually the easiest way to do it. It <em>is</em> required that the functions be called when no other thread in the program is running.</p><p>These global constant functions are <em>not thread safe</em>, so you must not call them when any other thread in the program is running.  It isn't good enough that no other thread is using libcurl at the time, because these functions internally call similar functions of other libraries, and those functions are similarly thread-unsafe.  You can't generally know what these libraries are, or whether other threads are using them.</p><p>The global constant situation merits special consideration when the code you are writing to use libcurl is not the main program, but rather a modular piece of a program, e.g. another library.  As a module, your code doesn't know about other parts of the program -- it doesn't know whether they use libcurl or not.  And its code doesn't necessarily run at the start and end of the whole program.</p><p>A module like this must have global constant functions of its own, just like <em>curl_global_init()</em> and <em>curl_global_cleanup()</em>. The module thus has control at the beginning and end of the program and has a place to call the libcurl functions.  Note that if multiple modules in the program use libcurl, they all will separately call the libcurl functions, and that's OK because only the first <em>curl_global_init()</em> and the last <em>curl_global_cleanup()</em> in a program change anything.  (libcurl uses a reference count in static memory).</p><p>In a C++ module, it is common to deal with the global constant situation by defining a special class that represents the global constant environment of the module.  A program always has exactly one object of the class, in static storage.  That way, the program automatically calls the constructor of the object as the program starts up and the destructor as it terminates.  As the author of this libcurl-using module, you can make the constructor call <em>curl_global_init()</em> and the destructor call <em>curl_global_cleanup()</em> and satisfy libcurl's requirements without your user having to think about it.</p><p><em>curl_global_init()</em> has an argument that tells what particular parts of the global constant environment to set up.  In order to successfully use any value except <em>CURL_GLOBAL_ALL</em> (which says to set up the whole thing), you must have specific knowledge of internal workings of libcurl and all other parts of the program of which it is part.</p><p>A special part of the global constant environment is the identity of the memory allocator.  <em>curl_global_init()</em> selects the system default memory allocator, but you can use <em>curl_global_init_mem()</em> to supply one of your own.  However, there is no way to use <em>curl_global_init_mem()</em> in a modular program -- all modules in the program that might use libcurl would have to agree on one allocator.</p><p>There is a failsafe in libcurl that makes it usable in simple situations without you having to worry about the global constant environment at all: <em>curl_easy_init()</em> sets up the environment itself if it hasn't been done yet.  The resources it acquires to do so get released by the operating system automatically when the program exits.</p><p>This failsafe feature exists mainly for backward compatibility because there was a time when the global functions didn't exist.  Because it is sufficient only in the simplest of programs, it is not recommended for any program to rely on it.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libcpuset.3.html"><span aria-hidden="true">&larr;</span> libcpuset.3: Library for managing cpu and memory placement.</a></li>
   <li class="next"><a href="libcurl-easy.3.html">libcurl-easy.3: Easy interface overview <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Graphic: Structured graphic abstract base class and subclass that stores a complete set of graphics state attributes</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Structured graphic abstract base class and subclass that stores a complete set of graphics state attributes">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Graphic (3U) manual">
  <meta name="twitter:description" content="Structured graphic abstract base class and subclass that stores a complete set of graphics state attributes">
  <meta name="twitter:image" content="https://www.carta.tech/images/ivtools-dev-Graphic-3U.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3U/Graphic.3U.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Graphic (3U) manual" />
  <meta property="og:description" content="Structured graphic abstract base class and subclass that stores a complete set of graphics state attributes" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ivtools-dev-Graphic-3U.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Graphic<small> (3U)</small></h1>
        <p class="lead">Structured graphic abstract base class and subclass that stores a complete set of graphics state attributes</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3U/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3U/Graphic.3U.html">
      <span itemprop="name">Graphic: Structured graphic abstract base class and subclass that stores a complete set of graphics state attributes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ivtools-dev/">
      <span itemprop="name">ivtools-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3U/Graphic.3U.html">
      <span itemprop="name">Graphic: Structured graphic abstract base class and subclass that stores a complete set of graphics state attributes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;Unidraw/Graphic/graphic.h&gt;</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>Graphic</strong> is an abstract base class for structured graphics objects.  Graphic objects maintain graphics state and geometric information, which lets them draw themselves on demand and support hit detection.</p><p>Graphic subclasses can implement graphical objects such as lines, rectangles, ellipses, and polygons.  Subclasses can also support hierarchical composition of Graphic instances, thus providing an object-oriented rendition of traditional structured graphics functionality.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GRAPHIC PUBLIC OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>virtual void Draw(Canvas*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Draw(Canvas*, Coord, Coord, Coord, Coord)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void DrawClipped(Canvas*, Coord, Coord, Coord, Coord)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Erase(Canvas*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Erase(Canvas*, Coord, Coord, Coord, Coord)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void EraseClipped(Canvas*, Coord, Coord, Coord, Coord)</strong></p>
  </dt>
  <dd>
    <p>Draw or erase the graphic on the given canvas.  The one-parameter Draw and Erase operations draw and erase the graphic in its entirety.  The five-parameter forms take four coordinates defining a rectangular area with which to cull drawing.  Composite graphics in particular can use this information to avoid drawing children falling entirely outside the given area.  DrawClipped and EraseClipped draw the graphic strictly within a rectangular area.  All Coord parameters are in canvas coordinates.</p>
  </dd>
  <dt>
    <p><strong>virtual void FillBg(boolean)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetBrush(PSBrush*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetColors(PSColor* fg, PSColor* bg)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetFont(PSFont*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetPattern(PSPattern*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual int BgFilled()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual PSBrush* GetBrush()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual PSColor* GetFgColor()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual PSColor* GetBgColor()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual PSFont* GetFont()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual PSPattern* GetPattern()</strong></p>
  </dt>
  <dd>
    <p>Set and get the graphic's graphic state attributes analogous to those defined for Painters.  The base class implements the operations for setting and getting the fill mode and colors; the other operations should be redefined in subclasses that need them.</p>
  </dd>
  <dt>
    <p><strong>void Translate(float dx, float dy)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void Scale(float x, float y, float cx = 0.0, float cy = 0.0)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void Rotate(float angle, float cx = 0.0, float cy = 0.0)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void SetTransformer(Transformer*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>Transformer* GetTransformer()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void TotalTransformation(Transformer& t)</strong></p>
  </dt>
  <dd>
    <p>Coordinates passed to drawing operations are transformed according to the current translation, rotation, and scale factor.  Optionally, scaling and rotation can be performed relative to a point (<em>cx</em>, <em>cy</em>).  The base class stores a transformer <em>_t</em> that can be directly set and accessed with SetTransformer and GetTransformer.  The default transformer is nil, meaning no transformations are performed. TotalTransformation uses concatTransformer (described below) to concatenate <em>t</em> (usually the identity transformation) and the transformers of the graphic's parents to obtain the graphic's total transformation, which it then stores in <em>t</em>.</p><p>Unless otherwise noted, input and output coordinates are affected by the concatentation of <em>this</em>'s transformer, its parent's transformer, its parent's parent's, and so on up to the root of the graphic instance hierarchy.  Prior to transformation, coordinates reflect the <em>graphic's coordinate system</em>.  Following transformation, the coordinates reflect the canvas coordinate system (i.e., they are canvas coordinates).  The coordinates that Graphic subclass constructors require are normally in graphic coordinates, while operations for returning a graphic's bounding box (see below) are in canvas coordinates.</p>
  </dd>
  <dt>
    <p><strong>void Align(Alignment, Graphic*, Alignment)</strong></p>
  </dt>
  <dd>
    <p>Position the given graphic relative to <em>this</em>, which stays fixed, while the graphic supplied as the argument is translated appropriately.  The first Alignment parameter specifies the alignment with respect to <em>this</em>, while the second specifies the alignment with respect to the given graphic.</p>
  </dd>
  <dt>
    <p><strong>virtual void GetBounds(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float& left, float& bottom, float& right, float& top</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>Return the exact coordinates of the smallest box circumscribing the graphic. The return values are in canvas coordinates.</p>
  </dd>
  <dt>
    <p><strong>void GetBox(Coord& left, Coord& bottom, Coord& right, Coord& top)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void GetBox(BoxObj&)</strong></p>
  </dt>
  <dd>
    <p>Return the smallest bounding box circumscribing the graphic.  The return values are in canvas coordinates.  The <strong>BoxObj</strong> represents a rectangle defined by lower left and upper right coordinates (see geomobjs(3U) for details).</p>
  </dd>
  <dt>
    <p><strong>virtual void GetCenter(float& x, float& y)</strong></p>
  </dt>
  <dd>
    <p>Return the center point of the graphic in canvas coordinates.</p>
  </dd>
  <dt>
    <p><strong>virtual boolean Contains(PointObj&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual boolean Intersects(BoxObj&)</strong></p>
  </dt>
  <dd>
    <p>Return whether or not the graphic contains the given point or intersects the given rectangular area specified in canvas coordinates. <strong>PointObj</strong> describes a point (see geomobjs(3U)).  These operations are used most often for fine-grained hit detection.</p>
  </dd>
  <dt>
    <p><strong>void SetTag(void*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void* GetTag()</strong></p>
  </dt>
  <dd>
    <p>Set or return a tag associated with the graphic.</p>
  </dd>
  <dt>
    <p><strong>Graphic* Parent()</strong></p>
  </dt>
  <dd>
    <p>Return the graphic's parent, if any.</p>
  </dd>
  <dt>
    <p><strong>virtual void First(Iterator&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Last(Iterator&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Next(Iterator&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Prev(Iterator&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual boolean Done(Iterator)</strong></p>
  </dt>
  <dd>
    <p>Operations for iterating over the graphic's children, if any.  These operations do nothing by default. Graphics that compose other graphics should redefine these operations to permit traversal of their children.  First and Last initialize an iterator to point to the beginning and end of the list of children, respectively.  Next increments the iterator to point to the following child, while Prev decrements the iterator to point to the preceding child.  Done returns whether or not the iterator points beyond the first or last child in the list.</p>
  </dd>
  <dt>
    <p><strong>Graphic* GetGraphic(Iterator)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void SetGraphic(Graphic*, Iterator&)</strong></p>
  </dt>
  <dd>
    <p>These operations do nothing by default.  Subclasses that contain children should redefine them as follows: GetGraphic should return the graphic to which an iterator points.  SetGraphic should initialize the iterator to point to a particular graphic in the list of children; it should initialize the iterator to point to a nil instance if the given graphic is not a child.</p>
  </dd>
  <dt>
    <p><strong>virtual void Bequeath()</strong></p>
  </dt>
  <dd>
    <p>Bequeath does nothing by default.  Composite graphic subclasses should redefine it so that it propagates to the children all the graphics state in <em>this</em> that can affect them.  This will prevent a change in a child's appearance should it be removed from <em>this</em>. Following the call to Bequeath, <em>this</em> should no longer define any graphics state attributes.</p>
  </dd>
  <dt>
    <p><strong>virtual Graphic* FirstGraphicContaining(PointObj&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Graphic* LastGraphicContaining(PointObj&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Graphic* FirstGraphicIntersecting(BoxObj&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Graphic* LastGraphicIntersecting(BoxObj&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Graphic* FirstGraphicWithin(BoxObj&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Graphic* LastGraphicWithin(BoxObj&)</strong></p>
  </dt>
  <dd>
    <p>These operation do nothing by default.  Composite graphic subclasses should redefine them so that they return the first or last child that contains a point, intersects a rectangular area, or does not extend beyond the given rectangular area, respectively.</p>
  </dd>
  <dt>
    <p><strong>virtual Graphic& operator = (Graphic&)</strong></p>
  </dt>
  <dd>
    <p>Assign the given graphic's graphics state attributes to <em>this</em>.</p>
  </dd>
  <dt>
    <p><strong>virtual Graphic* Copy()</strong></p>
  </dt>
  <dd>
    <p>Return a copy of the graphic.  Subclasses should redefine this operation to return an instance of their type.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GRAPHIC PROTECTED MEMBERS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>Graphic(Graphic* gr = nil)</strong></p>
  </dt>
  <dd>
    <p>Initialize the graphics, optionally supplying a graphic from which to obtain an initial set of graphics state attributes.  Graphic is an abstract base class.  Therefore its constructor is protected to prevent instantiation.</p>
  </dd>
  <dt>
    <p><strong>virtual void draw(Canvas*, Graphic* gs)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void drawClipped(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Canvas*, Coord, Coord, Coord, Coord, Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void erase(Canvas*, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void eraseClipped(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Canvas*, Coord, Coord, Coord, Coord, Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>Graphic subclasses redefine these <em>stateless drawing operations</em> to render themselves.  These operations are called by the corresponding capitalized operations, which supply them with the extra trailing Graphic parameter <em>gs</em>.  This parameter defines the graphics state with which to draw the graphic.  The graphic state is normally computed using the <em>concat</em> functions described below. Subclasses normally use the graphics state passed to them without ignoring or modifying it, though they may safely do so if they must override one or more attributes.</p>
  </dd>
  <dt>
    <p><strong>void update(Graphic* gs)</strong></p>
  </dt>
  <dd>
    <p>Graphics ultimately use a Painter to draw themselves.  The Graphic class maintains a protected static painter <em>_p</em> that subclasses can use to draw themselves.  The update operation sets <em>_p</em>'s graphics state attributes to match those of the given graphic to ensure that the painter will generate graphics with the proper color, font, etc.  Subclasses should call update in their stateless drawing operations (normally supplying the graphic they were passed) before they call any drawing operations on <em>_p</em>.  The graphics that <em>_p</em> generates, therefore, will reflect the graphics state that was passed to the stateless drawing operation.</p>
  </dd>
  <dt>
    <p><strong>virtual void getExtent(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float& left, float& bottom, float& cx, float& cy,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float& tol, Graphic* gs</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void GetExtent(Extent&)</strong></p>
  </dt>
  <dd>
    <p>A graphic's <em>extent</em> defines its physical boundaries. Subclasses redefine getExtent to return this boundary information based on the graphics state supplied in <em>gs</em>.  The <em>left</em>, <em>bottom</em>, <em>cx</em>, and <em>cy</em> parameters define the graphic's lower left corner and center, respectively, in canvas coordinates.  The <em>tol</em> parameter specifies a fixed amount of space around the boundary to account for parts of the graphic's appearance that do not scale linearly (e.g., brush width).  The relationship between getExtent and GetExtent is the same as that between draw and Draw: getExtent is the stateless version of GetExtent, which concatenates the parent's graphics state and calls getExtent with the result.</p>
  </dd>
  <dt>
    <p><strong>void getBounds(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float& left, float& bottom, float& right, float& top,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic* gs</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void getBox(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Coord& left, Coord& bottom, Coord& right, Coord& top,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void getBox(BoxObj&, Graphic*)</strong></p>
  </dt>
  <dd>
    <p>Stateless versions of the corresponding capitalized bounding box operations, which call the stateless versions with the cumulative graphics state of <em>this</em>'s ancestors.  These operations are defined in terms of getExtent and therefore should not be reimplemented by subclasses.</p>
  </dd>
  <dt>
    <p><strong>virtual boolean contains(PointObj&, Graphic* gs)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual boolean intersects(BoxObj&, Graphic*)</strong></p>
  </dt>
  <dd>
    <p>Stateless versions of the corresponding capitalized operations for fine-grained hit detection.  By default, these operations return true if the argument is contained in or intersects <em>this</em>'s bounding box.  Subclasses can redefine these operations to make a more discerning decision.</p>
  </dd>
  <dt>
    <p><strong>Graphic* getRoot()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void totalGS(Graphic& g)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void parentXform(Transformer& t)</strong></p>
  </dt>
  <dd>
    <p>Helper functions for parent-related operations.  getRoot returns the root graphic in <em>this</em>'s hierarchy.  totalGS uses concat (described below) to concatenate the graphics state of <em>this</em> and all its ancestors, returning the result in <em>g</em>. Any graphics state that <em>g</em> stored initially will be lost.  The parentXform operation uses concatTransform (described below) to concatenate the transformations of all ancestors of <em>this</em>, returning the result in <em>t</em>.  Any transformations that <em>t</em> stored initially will be lost.</p>
  </dd>
  <dt>
    <p><strong>void setParent(Graphic* g, Graphic* parent)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void unsetParent(Graphic* g)</strong></p>
  </dt>
  <dd>
    <p>Operations for setting and getting the value of another graphic's (<em>g</em>'s) parent as stored in the <em>_parent</em> protected member variable.  Normally only composite graphics change this attribute of another graphic, usually a newly-acquired child.</p>
  </dd>
  <dt>
    <p><strong>void cachingOn()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void cachingOff()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual boolean extentCached()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void uncacheExtent()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void uncacheParents()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void uncacheChildren()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void invalidateCaches()</strong></p>
  </dt>
  <dd>
    <p>Operations that support extent caching.  Some Graphic subclasses may cache extent information when it is computed for the first time, thereby improving performance.  For example, it may be expensive to compute the extent for composite graphics that have many children; thus caching the extent will improve performance if the extent does not change often.</p><p>cachingOn and cachingOff change the value of <em>_caching</em>, a protected static boolean member of Graphic that indicates whether caching is active on a global basis.  Extent-caching subclasses should check this member to avoid caching when it is <em>false</em>.  Caching subclasses should redefine extentCached to return whether or not they have cached their extent (in whatever form they store it).  They should redefine uncacheExtent to discard any extent information they've cached.  By default, uncacheParents simply calls uncacheExtent on each ancestor of <em>this</em>, while uncacheChildren does nothing by default.  Subclasses should redefine uncacheChildren to make any children uncache their extents.</p>
  </dd>
  <dt>
    <p><strong>virtual void concatGS(Graphic* a, Graphic* b, Graphic* dest)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void concatTransformer(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Transformer* a, Transformer* b, Transformer* dest</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void concat(Graphic* a, Graphic* b, Graphic* dest)</strong></p>
  </dt>
  <dd>
    <p>Operations for concatenting graphics state.  concatGS concatenates <em>a</em>'s graphics state (brush, font, pattern, etc., but <em>not</em> transformation matrix) with <em>b</em>'s and assigns the result to <em>dest</em>. According to the default concatenation semantics, <em>dest</em> will receive graphics state attributes defined by <em>b</em>; <em>dest</em> will receive only those attributes from <em>a</em> that <em>b</em> does not define (i.e., those for which <em>b</em> returns <em>nil</em>).  By default, concatTransformer does a matrix multiply of <em>a</em> and <em>b</em> and assigns the result to <em>dest</em>.  The concat operation concatenates both the graphics state and transformation of its arguments, assigning the results to <em>dest</em>.</p>
  </dd>
  <dt>
    <p><strong>void transform(Coord&, Coord&, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void transform(Coord, Coord, Coord&, Coord&, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void transform(float, float, float&, float&, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void transformList(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Coord[], Coord[], int, Coord[], Coord[], Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void transformRect(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float, float, float, float,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float&, float&, float&, float&, Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void invTransform(Coord&, Coord&, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void invTransform(Coord, Coord, Coord&, Coord&, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void invTransform(float, float, float&, float&, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void invTransformList(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Coord[], Coord[], int, Coord[], Coord[], Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void invTransformRect(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float, float, float, float,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float&, float&, float&, float&, Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>Convenience functions analogous to the Transformer operations of the same name.  These operations simply check if <em>_t</em> is nil before calling the corresponding Transformer operation on it.</p>
  </dd>
  <dt>
    <p><strong>virtual void drawGraphic(Graphic* g, Canvas*, Graphic* gs)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void drawClippedGraphic(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic* g, Canvas*, Coord, Coord, Coord, Coord, Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void eraseGraphic(Graphic* g, Canvas*, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void eraseClippedGraphic(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic* g, Canvas*, Coord, Coord, Coord, Coord, Graphic*</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void getExtentGraphic(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic* g, float& left, float& bottom, float& cx, float& cy,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    float& tol, Graphic* gs</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual boolean containsGraphic(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic* g, PointObj&, Graphic* gs</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual boolean intersectsGraphic(Graphic* g, BoxObj&, Graphic*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual boolean extentCachedGraphic(Graphic* g)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void uncacheExtentGraphic(Graphic* g)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void uncacheParentsGraphic(Graphic* g)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void uncacheChildrenGraphic(Graphic* g)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void invalidateCachesGraphic(Graphic* g)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void concatGSGraphic(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic* g, Graphic* a, Graphic* b, Graphic* dest</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void concatTransformerGraphic(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic* g, Transformer* a, Transformer* b,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Transformer* dest</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void concatGraphic(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Graphic* g, Graphic* a, Graphic* b, Graphic* dest</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>Helper functions that let graphic subclasses call the protected member functions on instances of other subclasses that redefine them.  All these helper functions take the affected instance as their first parameter.  All are semantically identical to the corresponding functions described above (which omit the "Graphic" suffix and the leading <em>g</em> parameter).  Composite graphics are the most likely users of such helper functions, calling them on their children.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FULLGRAPHIC PUBLIC OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>FullGraphic(Graphic* = nil)</strong></p>
  </dt>
  <dd>
    <p>Construct a full graphic, optionally supplying another graphic from which to copy an initial set of graphics state attributes. FullGraphic objects store a full complement of graphics state attributes; consequently, FullGraphic redefines all the operations for setting and getting these attributes.  The FullGraphic class can be used as a base class from which to derive graphics that require a complete set of graphics state and store such state.  It is also useful to instantiate FullGraphics and use them as graphics state repositories.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Graphic&hellip;</h2>
        <div class="sectioncontent">
<p>Canvas(3I), Iterator(3U), Painter(3I) Transformer(3I), geomobjs(3U), pspaint(3U)</p><p>"Applying Object-Oriented Design to Structured Graphics," John M. Vlissides and Mark A. Linton, in <em>Proceedings of the 1988</em> USENIX C++ Conference, Denver, CO, October 1988, pp. 81-94.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="GVUpdater.3U.html"><span aria-hidden="true">&larr;</span> GVUpdater.3U: Updates graphicviews structure to match its subject</a></li>
   <li class="next"><a href="GraphicBlock.3U.html">GraphicBlock.3U: Interactor that displays a graphic <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

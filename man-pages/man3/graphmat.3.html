<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>graphmat: 3d graphics and associated matrix and vector routines</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="3d graphics and associated matrix and vector routines">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="graphmat (3) manual">
  <meta name="twitter:description" content="3d graphics and associated matrix and vector routines">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclippoly-dev-graphmat-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/graphmat.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="graphmat (3) manual" />
  <meta property="og:description" content="3d graphics and associated matrix and vector routines" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclippoly-dev-graphmat-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">graphmat<small> (3)</small></h1>
        <p class="lead">3d graphics and associated matrix and vector routines</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/graphmat.3.html">
      <span itemprop="name">graphmat: 3d graphics and associated matrix and vector routines</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclippoly-dev/">
      <span itemprop="name">libclippoly-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/graphmat.3.html">
      <span itemprop="name">graphmat: 3d graphics and associated matrix and vector routines</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<strong>#include &lt;graphmat.h&gt;</strong>

<em>/* Data initialisation */</em>

<strong>hmat2_t *m_alloc2(m_result)</strong>

<strong>hmat2_t *m_result;</strong>

<strong>void		m_free2(matrix)</strong>

<strong>hmat2_t	*matrix;</strong>

<strong>hvec2_t *v_alloc2(v_result)</strong>

<strong>hvec2_t *v_result;</strong>

<strong>void		v_free2(vector)</strong>

<strong>hmat2_t	*vector;</strong>

<strong>hmat3_t *m_alloc3(m_result)</strong>

<strong>hmat3_t *m_result;</strong>

<strong>void		m_free3(matrix)</strong>

<strong>hmat3_t	*matrix;</strong>

<strong>hvec3_t *v_alloc3(v_result)</strong>

<strong>hvec3_t *v_result;</strong>

<strong>void		v_free3(vector)</strong>

<strong>hmat3_t	*vector;</strong>

<strong>hmat2_t *m_cpy2(m_source, m_result)</strong>

<strong>hmat2_t *m_source, *m_result;</strong>

<strong>hmat2_t *m_unity2( m_result)</strong>

<strong>hmat2_t *m_result;</strong>

<strong>hvec2_t *v_cpy2(v_source, v_result)</strong>

<strong>hvec2_t *v_source, *v_result;</strong>

<strong>hvec2_t *v_fill2(x, y, w, v_result)</strong>

<strong>double x, y, w;</strong>

<strong>hvec2_t	*v_result;</strong>

<strong>hvec2_t *v_unity2(axis, v_result)</strong>

<strong>b_axis axis;</strong>

<strong>hvec2_t *v_result;</strong>

<strong>hvec2_t *v_zero2(v_result)</strong>

<strong>hvec2_t *v_result;</strong>

<strong>hmat3_t *m_cpy3(m_source, m_result)</strong>

<strong>hmat3_t *m_source, *m_result;</strong>

<strong>hmat3_t *m_unity3(m_result)</strong>

<strong>hmat3_t *m_result;</strong>

<strong>hvec3_t *v_cpy3(v_source, v_result)</strong>

<strong>hvec3_t *v_source, *v_result;</strong>

<strong>hvec3_t *v_fill3(x, y, z, w, v_result)</strong>

<strong>double x, y, z, w;</strong>

<strong>hvec3_t	*v_result;</strong>

<strong>hvec3_t *v_unity3(axis, v_result)</strong>

<strong>b_axis axis;</strong>

<strong>hvec3_t *v_result;</strong>

<strong>hvec3_t *v_zero3(vector)</strong>

<strong>hvec3_t *vector;</strong>


<em>/* Basic Linear Algebra */</em>

<strong>double m_det2(matrix)</strong>

<strong>hmat2_t *matrix;</strong>

<strong>double v_len2(vector)</strong>

<strong>hvec2_t *vector;</strong>

<strong>double vtmv_mul2(vector, matrix)</strong>

<strong>hvec2_t *vector;</strong>

<strong>hmat2_t *matrix;</strong>

<strong>double vv_inprod2(vectorA, vectorB)</strong>

<strong>hvec2_t *vectorA, *vectorB;</strong>

<strong>hmat2_t *m_inv2(matrix, m_result)</strong>

<strong>hmat2_t *matrix, *m_result;</strong>

<strong>hmat2_t *m_tra2(matrix, m_result)</strong>

<strong>hmat2_t *matrix, *m_result;</strong>

<strong>hmat2_t *mm_add2(matrixA, matrixB, m_result)</strong>

<strong>hmat2_t *matrixA, *matrixB, *m_result;</strong>

<strong>hmat2_t *mm_mul2(matrixA, matrixB, m_result)</strong>

<strong>hmat2_t *matrixA, *matrixB, *m_result;</strong>

<strong>hmat2_t *mm_sub2(matrixA, matrixB, m_result)</strong>

<strong>hmat2_t *matrixA, *matrixB, *m_result;</strong>

<strong>hmat2_t *mtmm_mul2(matrixA, matrixB, m_result)</strong>

<strong>hmat2_t *matrixA, *matrixB, *m_result;</strong>

<strong>hmat2_t *sm_mul2(scalar, matrix, m_result)</strong>

<strong>double scalar;</strong>

<strong>hmat2_t *matrix, *m_result;</strong>

<strong>hmat2_t *vvt_mul2(vectorA, vectorB, m_result)</strong>

<strong>hvec2_t *vectorA, *vectorB;</strong>

<strong>hmat2_t	*m_result;</strong>

<strong>hvec2_t *mv_mul2(matrix, vector, v_result)</strong>

<strong>hmat2 *matrix;</strong>

<strong>hvec2_t *vector, *v_result;</strong>

<strong>hvec2_t *sv_mul2(scalar, vector, v_result)</strong>

<strong>double scalar;</strong>

<strong>hvec2_t *vector, *v_result;</strong>

<strong>hvec2_t *v_homo2(vector, v_result)</strong>

<strong>hvec2_t *vector, *v_result;</strong>

<strong>hvec2_t *v_norm2(vector, v_result)</strong>

<strong>hvec2_t *vector, *v_result;</strong>

<strong>hvec2_t *vv_add2(vectorA, vectorB, v_result)</strong>

<strong>hvec2_t *vectorA, *vectorB, *v_result;</strong>

<strong>hvec2_t *vv_sub2(vectorA, vectorB, v_result)</strong>

<strong>hvec2_t *vectorA, *vectorB, *v_result;</strong>

<strong>double m_det3(matrix)</strong>

<strong>hmat3_t *matrix;</strong>

<strong>double v_len3(vector)</strong>

<strong>hvec3_t *vector;</strong>

<strong>double vtmv_mul3(vector, matrix)</strong>

<strong>hvec3_t *vector;</strong>

<strong>hmat3_t *matrix;</strong>

<strong>double vv_inprod3(vectorA, vectorB)</strong>

<strong>hvec3_t *vectorA, *vectorB;</strong>

<strong>hmat3_t *m_inv3(matrix, m_result)</strong>

<strong>hmat3_t *matrix, *m_result;</strong>

<strong>hmat3_t *m_tra3(matrix, m_result)</strong>

<strong>hmat3_t *matrix, *m_result;</strong>

<strong>hmat3_t *mm_add3(matrixA, matrixB, m_result)</strong>

<strong>hmat3_t *matrixA, *matrixB, *m_result;</strong>

<strong>hmat3_t *mm_mul3(matrixA, matrixB, m_result)</strong>

<strong>hmat3_t *matrixA, *matrixB, *m_result;</strong>

<strong>hmat3_t *mm_sub3(matrixA, matrixB, m_result)</strong>

<strong>hmat3_t *matrixA, *matrixB, *m_result;</strong>

<strong>hmat3_t *mtmm_mul3(matrixA, matrixB, m_result)</strong>

<strong>hmat3_t *matrixA, *matrixB, *m_result;</strong>

<strong>hmat3_t *sm_mul3(scalar, matrix, m_result)</strong>

<strong>double scalar;</strong>

<strong>hmat3_t *matrix, *m_result;</strong>

<strong>hmat3_t *vvt_mul3(vectorA, vectorB, m_result)</strong>

<strong>hvec3_t *vectorA, *vectorB;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hvec3_t *mv_mul3(matrix, vector, v_result)</strong>

<strong>hmat3_t *matrix;</strong>

<strong>*hvec3_t *vector, *v_result;</strong>

<strong>hvec3_t *sv_mul3(scalar, vec, v_result)</strong>

<strong>double scalar;</strong>

<strong>hvec3_t *vector, *v_result;</strong>

<strong>hvec3_t *v_homo3(vector, v_result)</strong>

<strong>hvec3_t *vector, *v_result;</strong>

<strong>hvec3_t *v_norm3(vector, v_result)</strong>

<strong>hvec3_t *vector, *v_result;</strong>

<strong>hvec3_t *vv_add3(vectorA, vectorB, v_result)</strong>

<strong>hvec3_t *vectorA, *vectorB, *v_result;</strong>

<strong>hvec3_t *vv_cross3(vectorA, vectorB, v_result)</strong>

<strong>hvec3_t *vectorA, *vectorB, *v_result;</strong>

<strong>hvec3_t *vv_sub3(vectorA, vectorB, v_result)</strong>

<strong>hvec3_t *vectorA, *vectorB, *v_result;</strong>



<em>/* Elementary transformations */</em>

<strong>hmat2_t *miraxis2(axis, m_result)</strong>

<strong>b_axis	axis;</strong>

<strong>hmat2_t	*m_result;</strong>

<strong>hmat2_t	*mirorig2(m_result)</strong>

<strong>hmat2_t	*m_result;</strong>

<strong>hmat2_t *rot2( rotation, m_result)</strong>

<strong>double rotation;</strong>

<strong>hmat2_t	*m_result;</strong>

<strong>hmat2_t *scaorig2(scale, m_result)</strong>

<strong>double scale;</strong>

<strong>hmat2_t	*m_result;</strong>

<strong>hmat2_t *scaxis2(scale, axis, m_result)</strong>

<strong>double scale;</strong>

<strong>b_axis	axis;</strong>

<strong>hmat2_t	*m_result;</strong>

<strong>hmat2_t *transl2(translation, m_result)</strong>

<strong>hvec2_t	*translation;</strong>

<strong>hmat2_t	*m_result;</strong>

<strong>hmat3_t *miraxis3(axis, m_result)</strong>

<strong>b_axis	axis;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t	*mirorig3(m_result)</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t *mirplane3(plane, m_result)</strong>

<strong>b_axis	plane;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t *prjorthaxis(axis, m_result)</strong>

<strong>b_axis	axis;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t *prjpersaxis(axis, m_result)</strong>

<strong>b_axis	axis;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t *rot3( rotation, axis, m_result)</strong>

<strong>double rotation;</strong>

<strong>b_axis	axis;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t *scaorig3(scale, m_result)</strong>

<strong>double scale;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t *scaplane(scale, plane, m_result)</strong>

<strong>double scale;</strong>

<strong>b_axis	plane;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t *scaxis3(scale, axis, m_result)</strong>

<strong>double scale;</strong>

<strong>b_axis	axis;</strong>

<strong>hmat3_t	*m_result;</strong>

<strong>hmat3_t *transl3(translation, m_result)</strong>

<strong>hvec3_t *translation;</strong>

<strong>hmat3_t	*m_result;</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Matrix and vector routines associated with 3d graphics in homogeneous coordinates, such as basic linear algebra and elementary transformations.</p><p>This library is setup with a multi-level approach.</p><p><em>Level1 :</em> <strong>the data level.</strong></p><p><em>Level 2:</em> <strong>the data initialisation level.</strong></p><p><em>Level 3:</em> <strong>basic linear algebra level.</strong></p><p><em>Level 4:</em> <strong>elementary transformation level.</strong></p><p><em></em> Level 1, the data structures, is realised as follows :</p><p><strong>typedef union</strong></p><p><strong>{</strong></p><p><strong>double a[3];</strong></p><p><strong>struct</strong></p><p><strong>{</strong></p><p><strong>double x, y, w;</strong></p><p><strong>} s;</strong></p><p><strong>} hvec2_t;</strong></p><p><strong>typedef union</strong></p><p><strong>{</strong></p><p><strong>double a[4];</strong></p><p><strong>struct</strong></p><p><strong>{</strong></p><p><strong>double x, y, z, w;</strong></p><p><strong>} s;</strong></p><p><strong>} hvec3_t;</strong></p><p><strong>typedef struct</strong></p><p><strong>{</strong></p><p><strong>double m[3][3];</strong></p><p><strong>} hmat2_t;</strong></p><p><strong>typedef struct</strong></p><p><strong>{</strong></p><p><strong>double m[4][4];</strong></p><p><strong>} hmat3_t;</strong></p><p>To access the data elements of a vector or a matrix can be accessed with the macros:</p><p>#define	v_x( vec )		((vec).s.x)</p><p>#define	v_y( vec )		((vec).s.y)</p><p>#define	v_z( vec )		((vec).s.z)</p><p>#define	v_w( vec )		((vec).s.w)</p><p>#define	v_elem( vec, i )	((vec).a[(i)])</p><p>#define	m_elem( mat, i, j )	((mat).m[(i)][(j)])</p><p><strong>typedef enum</strong></p><p><strong>{</strong></p><p><strong>X_AXIS, Y_AXIS, Z_AXIS</strong></p><p><strong>} b_axis;</strong></p><p>The functions are as follows sorted:</p><p>first on the level in which they belong, then on their return value and then on their name.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMES</h2>
        <div class="sectioncontent">
<p>The function names begin with an abbreviation of the type of operand, and in which order the operations will be carried out on that operand. Then the order of and which operation will be carried out, followed by the type of coordinates. (i.e <em>vtmv_mul3(vector, matrix) :</em> first take the transpose of <em>vector,</em> multiply the transpose with <em>matrix,</em> this result is multiplied by the incoming vector, all coordinates are homogeneous 3d coordinates.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>All the "functions" may have been implemented as macro's, so you can't take the address of a function. It is however guaranteed that arguments of each function/macro will be evaluated only once, except for the result argument, which can be evaluated multiple times.</p><p>All operations can be used in place, but overlapping data gives unspecified results.</p><p>If the parameter <em>v_result</em> or <em>m_result</em> of a function or the parameter of an initialisation function equals <strong>NULL,</strong> space for the parameter will be dynamically allocated using <strong>malloc(),</strong> otherwise the parameter is assumed to hold a pointer to a memory area which can be used. A pointer to the used area (which may have been new allocated) is always returned.</p><p>If an error occurred like memory could not be allocated, an attempt to divide by zero occurs, or an attempt to invert a singular matrix a general error-routine will be called, which has two parameters : <em>gm_errno</em> and <em>gm_func.</em></p><p><em>gm_errno</em> is the error type which is one of the following constants : <strong>DIV0,</strong> <strong>NOMEM</strong> or <strong>MATSING.</strong> <em>gm_func</em> is a pointer to a string which contains the name of the function where the error occurred.</p><p>A pointer to the error routine is defined as follows :</p><p><strong>void (* gm_error)(gm_errno, gm_func);</strong></p><p><strong>gm_error_t gm_errno;</strong></p><p><strong>char *gm_func;</strong></p><p>With <em>gm_error_t</em> is defined as :</p><p><strong>typedef enum</strong></p><p><strong>{</strong></p><p><strong>DIV0, NOMEM, MATSING</strong></p><p><strong>} gm_error_t;</strong></p><p>The default error handler will abort after printing a diagnostic. You can redirect <em>gm_error</em> to your own error handler. It is not advisable to return from the error handler as error recovery is not expected to take place.</p><p>Matrices are of type <strong>hmat3_t</strong> or <strong>hmat2_t</strong> for 2d or 3d coordinates, respectively.</p><p>Vectors are of type <strong>hvec3_t</strong> or <strong>hvec2_t.</strong></p><p>The elements of a vector can be accessed in two manners, the first one is by name of an element of a structure, the second is like an array.</p><p>A plane is described by the normal to that plane, with the assumption made that the origin is an element of the plane.</p><p><em>rotation</em> is assumed to be a radial.</p><p>If a function is deallocating memory, it will check if the incoming pointer is a <strong>NULL</strong> pointer.</p><p><em>/* Level2 : Data initialisation */</em></p><p><strong>m_alloc2(), v_alloc2(), m_alloc3(), v_alloc3()</strong> allocate memory for a data item of type <strong>hmat2_t, hvec2_t, hmat3_t</strong> and <strong>hvec3_t</strong> respectively.</p><p><strong>m_free2(), v_free2(), m_free3(), v_free3()</strong> reclaim the storage allocated previously.</p><p><strong>m_cpy2(), m_cpy3()</strong> copies <em>m_matrix</em> into <em>m_result.</em></p><p><strong>m_unity2(), m_unity3()</strong> returns the unity matrix. (2d respectively 3d homogeneous coordinates)</p><p><strong>v_cpy2(), v_cpy3()</strong> copies <em>v_source</em> into <em>v_result.</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>v_fill2(), v_fill3()</strong> fills <em>v_result</em> according the given values.</p><p><strong>v_unity2(), v_unity3()</strong> returns the unity vector with <em>w = 1.0,</em> the incoming basic axis <em>axis = 1.0,</em> and the other element(s) are 0.0; (2d  respectively 3d homogeneous coordinates)</p><p><strong>v_zero2(), v_zero3()</strong> return a vector with <em>w</em> = 1.0 and the other elements 0.0;</p><p><strong>m_cpy2(), m_cpy3()</strong> copies <em>m_source</em> into <em>m_result.</em> (2d respectively 3d homogeneous coordinates)</p><p><em>/* level3 : Basic Linear Algebra */</em></p><p><strong>m_det2(), m_det3()</strong> calculates the determinant of the incoming matrix. The determinant is calculated in cartesian rather than homogeneous coordinates.</p><p><strong>v_len2(), v_len3()</strong> calculates the length of the cathesian part of the homogeneous vector.</p><p><strong>vtmv_mul2(), vtmv_mul3()</strong> calculate the result of the transpose of the incoming vector multiplied by the incoming matrix multiplied by the incoming vector (2d respectively 3d homogeneous coordinates)</p><p><strong>vv_inprod2(), vv_inprod3()</strong> calculates the geometrical innerproduct (vector . vector) of <em>vectorA</em> and <em>vectorB.</em></p><p><strong>m_inv2(), m_inv3()</strong> calculates the inverse of <em>matrix.</em> It is an error if the matrix in singular.</p><p><strong>m_tra2(), m_tra3()</strong> calculates the transpose <em>matrix.</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>mm_add2(), mm_sub2(), mm_add3(), mm_sub3()</strong> calculates the result of <em>matrixA</em> + respectively - <em>matrixB.</em> This operation is unspecified in the sense of homogeneous coordinates; the matrices are taken in their normal, mathematial sense.</p><p><strong>mm_mul2(), mm_mul3()</strong> calculates the result of <em>matrixA*matrixB</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>mtmm_mul2(), mtmm_mul3()</strong> calculates the result of the transpose of the incoming <em>matrixA</em> multiplied by <em>matrixB</em> multiplied by <em>matrixA</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>sm_mul2(), sm_mul3()</strong> calculates the result of <em>scalar*matrix</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>mv_mul2(), mv_mul3()</strong> calculates the result of <em>matrix*vector</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>sv_mul2(), sv_mul3()</strong> calculates the result of <em>scalar*vector.</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>v_homo2(), v_homo3()</strong> homogenize <em>vector</em> so that the <em>w</em> component becomes 1.0 but the length of the vector in homogeneous coordinates stays the same. (2d respectively 3d homogeneous coordinates)</p><p><strong>v_norm2(), v_norm3()</strong> normalises the incoming vector so the length of the cartesian vector becomes 1.0. The homogeneous length stays the same. (2d respectively 3d homogeneous coordinates)</p><p><strong>vv_add2(), vv_sub2(), vv_add3(), vv_sub3()</strong> calculates the result of <em>vectorA</em> + respectively - <em>vectorB.</em> These operations are done in the mathematical sense. Be careful with homogeneous coordinates, as not every possible input makes sense.</p><p><strong>vvt_mul2(), vvt_mul3()</strong> calculates the result of <em>vectorA</em> multiplied by the transpose of <em>vectorB</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>vv_cross3()</strong> calculates the geometrical crossproduct ( <em>vectorA x vectorB) of two</em> vectors (3d homogeneous coordinates)</p><p><em>/* level4 : Elementary transformations */</em></p><p><strong>miraxis2(), miraxis3()</strong> calculates the mirror matrix with respect to <em>axis.</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>mirorg2(), mirorg3()</strong> calculates the mirror matrix relative to the origin. (2d respectively 3d homogeneous coordinates)</p><p><strong>mirplane3()</strong> calculates the mirror matrix relative to a plane. (3d homogeneous coordinates)</p><p><strong>rot2()</strong> calculates the rotation matrix over <em>rotation</em> relative to the origin. (2d homogeneous coordinates)</p><p><strong>rot3()</strong> calculates the rotation matrix over <em>rotation</em> along <em>axis.</em> (3d homogeneous coordinates)</p><p><strong>scaorg2(), scaorg3()</strong> calculates the matrix of scaling with <em>scale</em> relative to the origin. (2d respectively 3d homogeneous coordinates)</p><p><strong>scaplane3()</strong> calculates the matrix of scaling with <em>scale</em> relative to a plane of which <em>plane</em> is the normal. (3d homogeneous coordinates)</p><p><strong>scaxis2(), scaxis3()</strong> calculates the matrix of scaling with <em>scale</em> relative to the line given by <em>axis.</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>transl2(), transl3()</strong> calculates the translation matrix over <em>translation.</em> (2d respectively 3d homogeneous coordinates)</p><p><strong>prjorthaxis()</strong> calculates the orthographic projection matrix along <em>axis.</em> (3d homogeneous coordinates)</p><p><strong>prjpersaxis()</strong> calculates the perspective projection with along <em>axis</em> The focus is in the origin. The projection plane is on distance 1.0 before the camera. (3d homogeneous coordinates)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>Vector addition and subtraction and matrix addition and substraction are not defined for homogeneous coordinates. One can add and subtract a point vector and a free vector, but you have to normalise the point vector first. The result of the subtraction of two point vectors is a free vector.</p><p>Calculating the determinant of a matrix and the length of a vector is unspecified in the sense of homogeneous coordinates</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUES</h2>
        <div class="sectioncontent">
<p>There are six types of return values: <strong></strong> void, double, *hvec3_t, *hvec2_t, *hmat3_t and *hmat2_t.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO graphmat&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/graphadd.3.html"><strong>graphadd</strong>(3)</a>, graphmat++(3), fmatpinv(3TV), malloc(3V), Graphics and matrix routines.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTE</h2>
        <div class="sectioncontent">
<p>Library file is <strong>/usr/local/lib/libgraphmat.a</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Hans Gringhuis.</p><p>Klamer Schutte</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="graphadd.3.html"><span aria-hidden="true">&larr;</span> graphadd.3: Additional 3d graphics and associated matrix and vector routines</a></li>
   <li class="next"><a href="graphmat++.3.html">graphmat++.3: Syntatic simple interface to graphmat. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

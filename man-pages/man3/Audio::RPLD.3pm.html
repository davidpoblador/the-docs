<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Audio::RPLD: Module to communicate with roaraudio playlist daemon</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Module to communicate with roaraudio playlist daemon">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Audio::RPLD (3pm) manual">
  <meta name="twitter:description" content="Module to communicate with roaraudio playlist daemon">
  <meta name="twitter:image" content="https://www.carta.tech/images/libaudio-rpld-perl-Audio::RPLD-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Audio::RPLD.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Audio::RPLD (3pm) manual" />
  <meta property="og:description" content="Module to communicate with roaraudio playlist daemon" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libaudio-rpld-perl-Audio::RPLD-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Audio::RPLD<small> (3pm)</small></h1>
        <p class="lead">Module to communicate with roaraudio playlist daemon</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Audio::RPLD.3pm.html">
      <span itemprop="name">Audio::RPLD: Module to communicate with roaraudio playlist daemon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libaudio-rpld-perl/">
      <span itemprop="name">libaudio-rpld-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Audio::RPLD.3pm.html">
      <span itemprop="name">Audio::RPLD: Module to communicate with roaraudio playlist daemon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Audio::RPLD;

 # Open new connection
 my $rpld = Audio::RPLD-&gt;new([$addr[, $type[, $port]]]);

 # Work with the connection
 $rpld-&gt;play();
 $rpld-&gt;stop();
 #...

 # close the connection
 $rpld-&gt;disconnect();

 # reconnect:
 $rpld-&gt;connect($addr[, $type[, $port]]);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is used to communicate with a RoarAudio PlayList Daemon (rpld). It includes support for nearly all of the protocol.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>Common Arguments</h3>
<p>Here is a list of all the arguments used in this documentation so I do not need to explain later for each method again. The Address of the server. This can be a filename or host or nodename. If the type is known to you, you should set the $type argument. Do not limit the user to hostname or filenames or something. The user should be abled to enter any server location in a freeform text input. This is the type of the address of the server. Currently defined types are:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1UNIX\s0
  </dt>
  <dd>
    <p>Use a \s-1UNIX\s0 socket to connect to the server.</p>
  </dd>
  <dt>
    DECnet
  </dt>
  <dd>
    <p>Use a DECnet socket to connect to the server (currently not supported because there is no IO::Socket::DECnet yet).</p>
  </dd>
  <dt>
    \s-1INET\s0
  </dt>
  <dd>
    <p>Use a \s-1INET\s0 (IPv4) socket to connect to the server.</p>
  </dd>
  <dt>
    #SOCKET
  </dt>
  <dd>
    <p>Use a already connected socket as connection to the server. This can for example be a object opened with a \s-1SSL/TLS\s0 or proxy module or any other bidirectional \s-1IO\s0 object. Object is passed as $addr parameter.</p>
  </dd>
  <dt>
    a value of undef
  </dt>
  <dd>
    <p>Use Autodetection.</p>
  </dd>

</dl>
<p>If using a \s-1INET\s0 socket this is the port number to connect to. Use undef (not include in arguments list) to use defaults. A Playlist to use. This can be a integer to use the playlist \s-1ID\s0 (which is preferred), a string to use the playlist name or $any (return value of $rpld-&gt;<em>any()</em>) to search thru all playlists and use the first hint. $any is not supported by all commands as it does not make sense for all commands. A volume. If this is an integer the volume is in range 0 to 65535 (recommended). If it's a string and suffixed by a '%' it is in range 0 to 100. A value of zero always means total silence. A history size. This is an integer or undef. If undef the server's default is used. The address of a RoarAudio server as used as backend for a queue. If undef the default server will be used. The mixer \s-1ID\s0 of the mixer core which should be used by a queue. If undef the server's default mixer core will be used. This should normally be undef. The stream role as used by a queue. This is the name or undef to use rpld's or RoarAudio server's default. This is the name of the role not the \s-1ID\s0. Common values include \*(L"music\*(R" and \*(L"background_music\*(R". A floating point describing how much the user likes a song. A string of a name of some object. A Playlist entry (item) identifier. This is a string of one of the several types. Here is a quick overview:</p>
<dl class='dl-vertical'>
  <dt>
    Long Global Track Number
  </dt>
  <dd>
    <p>The long \s-1GTN\s0 is a hex string (with leading 0x) prefixed by 'long:' with a length of 64 bit (16 raw digits). It is used to identify a playlist entry within the runtime of the server process. This one is the one you normally use for all operations like queuing a track for playback.</p>
  </dd>
  <dt>
    Short Global Track Number
  </dt>
  <dd>
    <p>The short \s-1GTN\s0 is a shorter (only 32 bit) version of the \s-1GTN\s0 prefixed with 'short:'. It's use is exactly the same as for the long \s-1GTN\s0. It exists to get the \s-1GTN\s0 passed thru things which do not support more than 32 bit. As this is normally not the case for Perl (you pass them around as strings anyway) you should not need to use it at all. It's not recommended to use this one.</p>
  </dd>
  <dt>
    \s-1UUID\s0
  </dt>
  <dd>
    <p>The \s-1UUID\s0 is a string prefixed with 'uuid:' followed by the normal hex-dash notation (example: uuid:54ab0c5f-b058-4c9b-ab3b-dea11b608482). It is used to identify a song. In contrast to the \s-1GTN\s0 this is not changed by commands such like copy or move operations. The normal use for this is if you want to store something over multiple runtimes of the server process like favorites or something. If a song does not include a \s-1UUID\s0 in it's meta data the server will generate a random one so each song has one. Those UUIDs can also be used together with the Tantalos protocol.</p>
  </dd>
  <dt>
    Pointer
  </dt>
  <dd>
    <p>A pointer is a string (the pointer name) prefixed by 'pointer:' (example: pointer:default). Those are used to have symbolic pointers a playlist entry. The following pointers are currently known by rpld:</p>
<dl class='dl-vertical'>
  <dt>
    default
  </dt>
  <dd>
    <p>If the Main Queue runs out of songs and the current pointer reached the end of the current playlist the current pointer is set to this value and song lookup is done again. For details about the current pointer see below.</p>
  </dd>
  <dt>
    current
  </dt>
  <dd>
    <p>If the Main Queue run out of queued songs the song this pointer points to is automatically queued and this pointer is set to the next entry the the playlist. This is used for 'start here and just play the playlist' behavior. If this pointer reaches the end of the playlist it becomes undefined and if the default pointer is set redefined with it's value. See above for more information about the default pointer.</p>
  </dd>
  <dt>
    startup
  </dt>
  <dd>
    <p>If the startup pointer is set the song it points to is added once at startup of the daemon. This can for example be used to implement boot sounds.</p>
  </dd>
  <dt>
    temp
  </dt>
  <dd>
    <p>The temp pointer is a pointer for user defined jobs. It is the only pointer which is not global (shared with all clients) but a client local pointer. The application can use it for whatever it wants to use it for.</p>
  </dd>

</dl>
<p>As of rpld 0.1rc7 multi queue support was added. To support this pointers can have a queue and client \s-1ID\s0 suffix. The suffix has the syntax: pointer[queue:client]. Both queue and client can be omitted. If the client \s-1ID\s0 is omitted the colon (':') can be omitted, too. If both are omitted the brackets ('[]') can also be omitted. Queue defaults to the current client's default queue and client defaults to the current client.</p>
  </dd>
  <dt>
    Numerical Index
  </dt>
  <dd>
    <p>This is a numerical index of the entry. It's format is num:N where N is the index starting with zero. For example num:0 is the first entry in playlist, num:15 is the 16th entry.</p>
  </dd>
  <dt>
    Likeness Index
  </dt>
  <dd>
    <p>This is like the normal numerical index just uses the likeness values of the entries. This is hardly of use to the user and mainly for internal use. Syntax is likeness:F with F the floating point index.</p>
  </dd>
  <dt>
    Random Entry
  </dt>
  <dd>
    <p>A Random entry can be selected by using random:[\s-1PLI\s0]. \s-1PLI\s0 is a optional parameter. It must be the \s-1ID\s0 of the playlist to select entry from. If no playlist is given the current one is used.</p>
  </dd>
  <dt>
    Random liked Entry
  </dt>
  <dd>
    <p>This is like normal random entry but prioritized by the value set with \s-1LIKE\s0 and \s-1DISLIKE\s0 commands. Syntax is: randomlike:[\s-1PLI\s0].</p>
  </dd>

</dl>
<p>A Pointer. This is a string of the pointer name. It is not prefixed with 'pointer:' as when used as \s-1PLE\s0.</p>
<h3>Common return values</h3>
<p>The following return types are used by methods in this module: The instance of this module as returned by <em>new()</em>. A general return value. This is undef in case of failure or a defined value in case of no error. The value may be a string, hash- or arrayref depending on the method. See description of the method for details. The return value of <em>any()</em>. This can be used as wildcard for playlist names in some cases.</p>
<h3>Basic functions</h3>
<p><em></em><strong>$rpld</strong><em> = Audio::RPLD-&gt;new([$addr[, </em><strong>$type</strong><em>[, </em><strong>$port</strong><em>]]])</em></p><p>This method creates a new Audio::RPLD object. If arguments are passed they are directly passed to a call to the connect method (see below) in order to connect to the server. If this fails undef is returned. If no arguments are given you need to connect the object to the server via the connect method later on your own.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;connect($addr[, </em><strong>$type</strong><em>[, </em><strong>$port</strong><em>]])</em></p><p>Connect to a server. You must not call this on a already connected object.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>connect_default()</em><em></em></p><p>Connect to a server by trying default locations. You must not call this on a already connected object.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>disconnect()</em><em></em></p><p>Disconnect from the server. You may use $rpld-&gt;<em>connect()</em> again to connect to a (new/different) server.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>is_connected()</em><em></em></p><p>Returns true value if the object is currently connected to a server or undef if not.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;identify([%options])</em></p><p>This identifies the process at the server. An optional list of options is taken. Each key-value pair is send to the server as it is.</p><p>Currently supported keys are: name, pid, nodename and hostid.</p><p>This command is send automatically at connect. You only need to call this manually if want to set one of those options. It is recommended to do this at least for the application name.</p>
<h3>Special values</h3>
<p><em></em><strong>$any</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>any()</em><em></em></p><p>This function returns a value that can be used as playlist wildcard.</p>
<h3>Basic communication functions</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>noop()</em><em></em></p><p>Send a \s-1NOOP\s0 command to the server.</p><p>This can be used to ping the server or for keep-alive.</p>
<h3>Server information functions</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>serverinfo()</em><em></em></p><p>Send a \s-1SERVERINFO\s0 command to the server.</p><p>This tells basic information about the server like it's version and location.</p><p>The return value is a hashref which contains the following keys (all keys may or may not be set depending on what info the server provides):</p>
<dl class='dl-vertical'>
  <dt>
    version
  </dt>
  <dd>
    <p>This is the product name, version and vendor information for the server.</p>
  </dd>
  <dt>
    location
  </dt>
  <dd>
    <p>This is the location of the server in a lion readable way e.g. \*(L"kitchen\*(R".</p>
  </dd>
  <dt>
    description
  </dt>
  <dd>
    <p>This is a description for the server e.g. \*(L"Central Media Server\*(R"</p>
  </dd>
  <dt>
    contact
  </dt>
  <dd>
    <p>Those are information on the server administrator. Normally contains nick or real name as well as an e-mail address.</p>
  </dd>
  <dt>
    serial
  </dt>
  <dd>
    <p>This is a string with the serial number of the device.</p>
  </dd>
  <dt>
    address
  </dt>
  <dd>
    <p>This contains address data of the device.</p>
  </dd>
  <dt>
    uiurl
  </dt>
  <dd>
    <p>This is an \s-1URL\s0 to a user interface used to control the server. This can be a web interface such as Romie or some other kind of interface. All protocols are allowed. This includes telnet:// and ssh://.</p>
  </dd>
  <dt>
    hostid
  </dt>
  <dd>
    <p>This is the \s-1UNIX\s0 HostID of the server.</p>
  </dd>
  <dt>
    license
  </dt>
  <dd>
    <p>This is the license of the server software or device.</p>
  </dd>
  <dt>
    build
  </dt>
  <dd>
    <p>This is a build stamp. It contains information on the build. This is mostly useful when reporting problems to upstream or the distributor.</p>
  </dd>
  <dt>
    system
  </dt>
  <dd>
    <p>This contains a sub-hash with information about the server's \s-1OS\s0. Those information are normally read via the <em>uname()</em> system call by the server software. This means all limits of <em>uname()</em> also apply to those data. The following keys are know as of this writing:</p>
<dl class='dl-vertical'>
  <dt>
    sysname
  </dt>
  <dd>
    <p>The operating system's name e.g. \*(L"NetBSD\*(R".</p>
  </dd>
  <dt>
    release
  </dt>
  <dd>
    <p>The operating system's release.</p>
  </dd>
  <dt>
    nodename
  </dt>
  <dd>
    <p>The node name of as known by the operating system.</p>
  </dd>
  <dt>
    machine
  </dt>
  <dd>
    <p>The host architecture as known by the operating system.</p>
  </dd>

</dl>

  </dd>
  <dt>
    x
  </dt>
  <dd>
    <p>This is a sub-hash with vendor specific information. The name is based on the \*(L"X-\*(R"-prefix those keys have. The content and format is fully up to the server software. However the following keys have been seen in the wild:</p>
<dl class='dl-vertical'>
  <dt>
    application This key is used by the RoarAudio PlayList Daemon (rpld) and contains it's name.
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>

</dl>

<h3>Storing and restoring</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>store()</em><em></em></p><p>Ask the server to store (dump) all data on permanent storage (disk). This is normally used at exit to save all the playlists on disk so they can be restored at next startup.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>restore()</em><em></em></p><p>Restore from disk. This is normally done at startup time (by rpld itself). You should not call this again if the server already restored it's state because this may result in undefined behavior. Current behavior of rpld is that it forgets the complete current state and loads the new state. This was changed in version 0.1rc7. Before version 0.1rc7 it added everything to the current state resulting in duplicates. This may change in future.</p>
<h3>Playback control</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>play()</em><em></em></p><p>Start playback.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>stop()</em><em></em></p><p>Stop playback.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>next()</em><em></em></p><p>Skip to next song.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>prev()</em><em></em></p><p>Skip to previous song.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>isplaying()</em><em></em></p><p>Return a true value if we are currently playing.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>showidentifier()</em><em></em></p><p>Return a identifier for the currently running stream at the server. The format of this identifier is undefined. This should not be used. Using this value can result in race conditions.</p>
<h3>Queue control</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>flushq()</em><em></em></p><p>Flush the Main Queue. Playback is stopped (because no songs are left in the queue).</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>showcur()</em><em></em></p><p>Return the Playlist entry for the current song (if playback is running this is the currently played song). This contains information about this song from the playlist. If you want to read the current meta data or other live data use $rpld-&gt;<em>showplaying()</em>.</p><p>The return value is in the same format as that of $rpld-&gt;<em>showple()</em>. See $rpld-&gt;<em>showple()</em> for more information on it.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>showplaying()</em><em></em></p><p>Returns live information on what is currently played.</p><p>The return value is a hashref which contains the following keys (all keys may or may not be set depending on what info the server provides):</p>
<dl class='dl-vertical'>
  <dt>
    state
  </dt>
  <dd>
    <p>A string of the current playback state in uppercase. Possible values include: \s-1STOPPED\s0, \s-1PAUSE\s0, \s-1RUNNING\s0.</p>
  </dd>
  <dt>
    longgtn
  </dt>
  <dd>
    <p>The long \s-1GTN\s0 of the current ple.</p>
  </dd>
  <dt>
    shortgtn
  </dt>
  <dd>
    <p>The short \s-1GTN\s0 of the current ple.</p>
  </dd>
  <dt>
    uuid
  </dt>
  <dd>
    <p>The \s-1UUID\s0 of the current ple.</p>
  </dd>
  <dt>
    time
  </dt>
  <dd>
    <p>A hash containing keys for the current playback time in different units. The unit name is the key name. Units may include: samples, s.</p>
  </dd>
  <dt>
    meta
  </dt>
  <dd>
    <p>A hash containing keys for each meta data type provided by the server. Types may include: title, album, artist, performer, version.</p>
  </dd>
  <dt>
    mduc
  </dt>
  <dd>
    <p>The meta data update counter (\s-1MDUC\s0) for current playback.</p>
  </dd>
  <dt>
    rate
  </dt>
  <dd>
    <p>The sample rate of the current playback.</p>
  </dd>
  <dt>
    channels
  </dt>
  <dd>
    <p>The number of channels of the current playback.</p>
  </dd>
  <dt>
    bits
  </dt>
  <dd>
    <p>The number of bits of the current playback.</p>
  </dd>

</dl>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;listq([$playlist])</em></p><p>List playlist entries of the Main Queue or the given playlist. This is the same as $rpld-&gt;<em>listple()</em> expect that the default playlist is the Main Queue not the currently selected playlist.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;showqueue([$playlist])</em></p><p>Returns a hashref with information about the given list or the current queue if no list is given. The structure of the hashref is the same as for <em>listplaylist()</em>. This function is the same as <em>showlist()</em> but returns the current queue as default of no list is given.</p>
<h3>Volume control</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;setvolume($vol)</em></p><p>Set volume to $vol.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>showvolume()</em><em></em></p><p>Return a hashref to a hash containing volume information.</p><p>The hash contains the following keys:</p>
<dl class='dl-vertical'>
  <dt>
    value
  </dt>
  <dd>
    <p>The current playback volume in units of scale.</p>
  </dd>
  <dt>
    scale
  </dt>
  <dd>
    <p>The unit of value.</p>
  </dd>
  <dt>
    pc
  </dt>
  <dd>
    <p>The volume in percent.</p>
  </dd>

</dl>
<p>The current volume (as float) is value/scale.</p>
<h3>Controlling pause state</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>pause()</em><em></em></p><p>Set the playback in pause mode.</p><p>You should not use this function but $rpld-&gt;<em>togglepause()</em> if possible.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>unpause()</em><em></em></p><p>Unpause the playback.</p><p>You should not use this function but $rpld-&gt;<em>togglepause()</em> if possible.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>togglepause()</em><em></em></p><p>Toggle the pause state. This is the recommended function to change the pause state of playback.</p><p>This is because it interacts best with other applications changing the current pause state.</p>
<h3>Playlist management</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;setplaylist($playlist)</em></p><p>Select the given playlist. After selecting a playlist it becomes the default playlist for most operations which take a optional playlist argument. (Operations for which this does not set the default are marked in the corresponding description).</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;addplaylist($name)</em></p><p>Add a playlist.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;delplaylist($playlist)</em></p><p>Delete a playlist. All entries are deleted, too.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;flushplaylist($playlist)</em></p><p>Flush a playlist. If this is used on the Main Queue the playback is stopped as no songs are left to play.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>listplaylist()</em><em></em></p><p>Get a list of playlists known by the server. This returns a arrayref to a array containing a hashref for each list. This hash contains the following keys:</p>
<dl class='dl-vertical'>
  <dt>
    id
  </dt>
  <dd>
    <p>The \s-1ID\s0 of the playlist.</p>
  </dd>
  <dt>
    parent
  </dt>
  <dd>
    <p>The \s-1ID\s0 of the parent playlist.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>The name of the playlist.</p>
  </dd>
  <dt>
    children
  </dt>
  <dd>
    <p>A arrayref with the IDs of the children playlists.</p>
  </dd>
  <dt>
    history_size (optional)
  </dt>
  <dd>
    <p>The size of the history if this is a history. This is the number of PLEs this playlist will store before old entries becomes deleted automatically.</p>
  </dd>
  <dt>
    history (optional)
  </dt>
  <dd>
    <p>The \s-1PLI\s0 of the playlist used as history if this is a queue.</p>
  </dd>
  <dt>
    volume (optional)
  </dt>
  <dd>
    <p>The playback volume if this is a queue.</p>
  </dd>
  <dt>
    backend (optional)
  </dt>
  <dd>
    <p>The backend used by this queue (if this is a queue). The backend is the name (server address) of the RoarAudio server.</p>
  </dd>
  <dt>
    mixer (optional)
  </dt>
  <dd>
    <p>The \s-1ID\s0 of the Mixer used on the RoarAudio server. -1 for default. Only set if this is a queue.</p>
  </dd>
  <dt>
    role (optional)
  </dt>
  <dd>
    <p>The Stream role used by this queue. Often \*(L"music\*(R" or \*(L"background_music\*(R". Only if this is a queue.</p>
  </dd>

</dl>
<p>Parent/child information should be used to display a tree to the user.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;showlist($playlist)</em></p><p>Returns a hashref with information about the given playlist. The structure of the hashref is the same as for <em>listplaylist()</em>.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;setparentlist($playlist)</em></p><p>Set the parent playlist of the current playlist. Setting parent playlist of a list the current one is currently not supported.</p>
<h3>Queue management</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;setqueue($playlist)</em></p><p>Select the given playlist as queue. After selecting a queue it becomes the default queue for the current connection.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;delqueue($playlist)</em></p><p>Delete a queue from a playlist. The playlist will not be removed just the queue.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;addqueue($playlist, </em><strong>$history</strong><em>[, </em><strong>$backend</strong><em>[, </em><strong>$mixer</strong><em>[, </em><strong>$role</strong><em>]]])</em></p><p>Add a queue to playlist $pl with the playlist $history as history. Optionally the server to connect to can be given as $backend and the mixer to connect to as $mixer. In addition the stream role can be set using $role.</p>
<h3>History management</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;addhistory($playlist, [$size])</em></p><p>Add a history to the playlist. The history size can be set using the optional argument $size. If not given the server's default will be used.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;delhistory($playlist)</em></p><p>Delete a history from a playlist. The playlist will not be removed just the history.</p>
<h3>Playlist Entry management</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;delple($ple[, </em><strong>$playlist</strong><em>])</em></p><p>Delete the given playlist entry.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;queueple($ple[, </em><strong>$playlist</strong><em>[, </em><strong>$pos</strong><em>]])</em></p><p>Queue the given playlist entry. This means it is copied over to the Main Queue. This function is recommended over $rpld-&gt;<em>copyple()</em> to queue songs.</p><p>The optional position is used to give the place in the playlist where to queue the song. It is counted as 'n entries after the first one'. This means if you pass a value of zero the song is placed as next song. If you pass a value of one it is placed as the song after the next song and so on. A value of -1 means that it is added before the first one. If you place a song before the first one in the Main Queue playback is stopped and restarted so this song becomes the currently played song.</p><p>If you omit the position or pass undef the default behavior is to add at the end of the playlist which should be the default in your applications, too.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;copyple($ple, </em><strong>$playlist_from</strong><em>, </em><strong>$playlist_to</strong><em>[, </em><strong>$pos</strong><em>])</em></p><p>The given playlist entry is copied from the playlist $playlist_from to the playlist $playlist_to. If $playlist_from is undef the currently selected playlist is used as source.</p><p>For the meaning of the position parameter ($pos) see $rpld-&gt;<em>queueple()</em> above.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;moveple($ple, </em><strong>$playlist_from</strong><em>, </em><strong>$playlist_to</strong><em>[, </em><strong>$pos</strong><em>])</em></p><p>The given playlist entry is moved from the playlist $playlist_from to the playlist $playlist_to. If $playlist_from is undef the currently selected playlist is used as source.</p><p>For the meaning of the position parameter ($pos) see $rpld-&gt;<em>queueple()</em> above.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;listple($playlist)</em></p><p>List all playlist entries from the given playlist. The return value is an arrayref with elements as if they are returned by $rpld-&gt;<em>showple()</em>. See $rpld-&gt;<em>showple()</em> for more info about the return format.</p><p>Note: You should avoid calling this too often as it returns a large amount of data. You also should not store data for currently not used playlists (for example only store data for the playlist currently shown to the user).</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;searchple($needle, </em><strong>$op</strong><em>, </em><strong>$src</strong><em>, [$pli, [$opts]])</em></p><p>List playlist entries matching a given rule. The return value is the same as for $rpld-&gt;<em>listple()</em>.</p><p>This function accepts the following arguments: The needle is the search term the server will search for. It may be a scalar value or a arrayref. If an arrayref the array must have one or two elements. If the array has two elements the first one is the type of needle and the second is the value to search for. The supported types depend on the server. As of version 0.1.5 RoarAudio PlayList Daemon supports: String types, \s-1DISCID\s0, \s-1UUID\s0, \s-1GENRE\s0, TRACKNUM[\s-1BER\s0]. String types are defined with a type of undef. If it has only one element the type defaults to undef (string type). If a scalar value is given the type is automatically selected based on the prefix. If a prefix is found matching one of the known types that type is selected. If no such prefix is found the string is used as string type. This is handy for user interfaces with only a single \*(L"intelligent\*(R" search box. For non-user input the array form is strongly recommended. This is the operator used to compare needle to the source. Currently the following options are defined. For negative versions see $opts.</p>
<dl class='dl-vertical'>
  <dt>
    eq
  </dt>
  <dd>
    <p>The needle must to match the source.</p>
  </dd>
  <dt>
    ne
  </dt>
  <dd>
    <p>The needle must not match the source.</p>
  </dd>
  <dt>
    in
  </dt>
  <dd>
    <p>The needle is found anywhere within the source.</p>
  </dd>
  <dt>
    begin
  </dt>
  <dd>
    <p>The needle is found at the begin of the source.</p>
  </dd>
  <dt>
    end
  </dt>
  <dd>
    <p>The needle is found at the end of the source.</p>
  </dd>

</dl>
<p>This is the source to compare the needle with. This can be undef, a scalar value, $any or a arrayref. $any matches any information within the \s-1PLE\s0. If an arrayref is used the array must consist of one or two elements. The first element is the source. The second is the sub-source. Valid values depend on the server software. As of version 0.1.5 RoarAudio PlayList Daemon supports: \s-1ALBUM\s0, \s-1TITLE\s0, \s-1ARTIST\s0, \s-1PERFORMER\s0, \s-1VERSION\s0, \s-1FILENAME\s0, \s-1DISCID\s0, \s-1UUID\s0, \s-1GENRE\s0, TRACKNUM[\s-1BER\s0] and \s-1TAG:\s0\*(L"Tagname\*(R". Not all of them can be used with all kinds of needles. If $src is a scalar value it is interpreted as ['\s-1TAG\s0', $src] or [$src] depending on the needle. If this is undef the source is selected by the type of needle with string needles defaulting to $any. This is the playlist to search in or $any. This is an hashref with options. All options are optional. The following keys are currently defined:</p>
<dl class='dl-vertical'>
  <dt>
    neg
  </dt>
  <dd>
    <p>If set to a true value the search is inverted.</p>
  </dd>
  <dt>
    casesensitive
  </dt>
  <dd>
    <p>If set to a true value the search is done case sensetive.</p>
  </dd>
  <dt>
    queues
  </dt>
  <dd>
    <p>If set to true value searching in queues is allowed. If set to a false but not undef value such searches are disallowed. If set to undef the default is used.</p>
  </dd>
  <dt>
    histories
  </dt>
  <dd>
    <p>Does the same as \*(L"queues\*(R" just for histories.</p>
  </dd>

</dl>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;showple($ple[, </em><strong>$playlist</strong><em>])</em></p><p>Return data of the given playlist entry. If no playlist is given the currently selected one is used.</p><p>The return value is a hashref with the following keys:</p>
<dl class='dl-vertical'>
  <dt>
    codec (optional)
  </dt>
  <dd>
    <p>The name of the used codec.</p>
  </dd>
  <dt>
    length (optional)
  </dt>
  <dd>
    <p>The playback length in seconds.</p>
  </dd>
  <dt>
    file
  </dt>
  <dd>
    <p>The filename. This may be anything supported by RoarAudio's \s-1DSTR\s0. Including local files, web radio streams and other types.</p>
  </dd>
  <dt>
    meta
  </dt>
  <dd>
    <p>The value for the meta key is a hashref of it's own to a list of provided meta data. The following keys may be included. All are optional. Other keys may also be included.</p>
<dl class='dl-vertical'>
  <dt>
    album
  </dt>
  <dd>
    <p>Name of the album.</p>
  </dd>
  <dt>
    title
  </dt>
  <dd>
    <p>Title of the song.</p>
  </dd>
  <dt>
    artist
  </dt>
  <dd>
    <p>Name of the Artist.</p>
  </dd>
  <dt>
    performer
  </dt>
  <dd>
    <p>Name of the performer for this record.</p>
  </dd>
  <dt>
    version
  </dt>
  <dd>
    <p>Version of this record.</p>
  </dd>
  <dt>
    discid
  </dt>
  <dd>
    <p>\s-1CDDB\s0 DiscID for this song.</p>
  </dd>
  <dt>
    tracknumber
  </dt>
  <dd>
    <p>Tracknumber of this song in the album.</p>
  </dd>
  <dt>
    totaltracks
  </dt>
  <dd>
    <p>Total number of tracks in this album.</p>
  </dd>
  <dt>
    genre
  </dt>
  <dd>
    <p>Genre of this song.</p>
  </dd>
  <dt>
    genreid
  </dt>
  <dd>
    <p>Genre \s-1ID\s0 of this song.</p>
  </dd>

</dl>

  </dd>
  <dt>
    longid
  </dt>
  <dd>
    <p>The long \s-1GTN\s0 for the entry.</p>
  </dd>
  <dt>
    shortid
  </dt>
  <dd>
    <p>The short \s-1GTN\s0 for the entry.</p>
  </dd>
  <dt>
    uuid (optional)
  </dt>
  <dd>
    <p>The \s-1UUID\s0 for the entry.</p>
  </dd>
  <dt>
    likeness (optional)
  </dt>
  <dd>
    <p>The likeness value stored by the server. This is a float in rage from zero to infinity. The bigger the value is the more the song is liked.</p>
  </dd>

</dl>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;like($ple[, </em><strong>$likeness</strong><em>])</em></p><p>Tells the server that the user likes this entry. Optionally tells the server how much. A value of +1.0 is the default if no value is given. This is added to the likeness value stored by the server. A value of zero has no effect. A negative value indicates dislikeness. See <em>dislike()</em> for more information about dislikeness.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;dislike($ple[, </em><strong>$likeness</strong><em>])</em></p><p>This is the same as <em>like()</em> just marks a the given entry as disliked. Optionally tells the server how much. A value of +1.0 is the default if no value is given. The value is subtracted from server's value. A value of zero has no effect. A negative value indicates likeness. See <em>like()</em> for more information about likeness.</p>
<h3>Pointers</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;setpointer($pointer, </em><strong>$ple</strong><em>[, </em><strong>$playlist</strong><em>])</em></p><p>Set the given pointer to the given playlist entry. If no playlist is given the currently selected one is used.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;unsetpointer($pointer)</em></p><p>Unset the given pointer.</p><p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;showpointer([$pointer])</em></p><p>Returns information about the given or all pointers.</p><p>The return value is a hashref with keys of the pointer names. The values for those keys are a hashref containing information on the corresponding pointer. If the hashref for the pointer points to a empty hash (no keys defined) then the pointer is not defined.</p><p>If the pointer is defined the following keys are contained:</p>
<dl class='dl-vertical'>
  <dt>
    raw
  </dt>
  <dd>
    <p>The playlist entry the pointer points to in a raw format.</p>
  </dd>
  <dt>
    longid (optional)
  </dt>
  <dd>
    <p>If the pointer contains an information about the playlist entries long \s-1GTN\s0 this \s-1GTN\s0.</p>
  </dd>
  <dt>
    shortid (optional)
  </dt>
  <dd>
    <p>If the pointer contains an information about the playlist entries short \s-1GTN\s0 this \s-1GTN\s0.</p>
  </dd>
  <dt>
    uuid (optional)
  </dt>
  <dd>
    <p>If the pointer contains an information about the playlist entries \s-1UUID\s0 this \s-1UUID\s0.</p>
  </dd>
  <dt>
    random (optional)
  </dt>
  <dd>
    <p>If the pointer points to a random song within a playlist this contains the corresponding search string.</p>
  </dd>
  <dt>
    randomlike (optional)
  </dt>
  <dd>
    <p>If the pointer points to a random song (respecting likeness) within a playlist this contains the corresponding search string.</p>
  </dd>
  <dt>
    playlist (optional)
  </dt>
  <dd>
    <p>If the pointer contains a playlist hint this contains the playlist \s-1ID\s0.</p>
  </dd>

</dl>

<h3>Clients</h3>
<p><em></em><strong>$res</strong><em> = </em><strong>$rpld</strong><em>-&gt;</em><em>listclients()</em><em></em></p><p>Get a list of clients connected to the server. This returns a arrayref to a array containing a hashref for each client. This hash contains the following keys:</p>
<dl class='dl-vertical'>
  <dt>
    id
  </dt>
  <dd>
    <p>The \s-1ID\s0 of the client.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>The name of the client.</p>
  </dd>
  <dt>
    protocol
  </dt>
  <dd>
    <p>The name of the protocol the client is using.</p>
  </dd>
  <dt>
    pid (optional)
  </dt>
  <dd>
    <p>The process \s-1ID\s0 of the client.</p>
  </dd>
  <dt>
    nodename (optional)
  </dt>
  <dd>
    <p>The name of the node the client is being conneected from.</p>
  </dd>
  <dt>
    hostid (optional)
  </dt>
  <dd>
    <p>The unix hostid of the node the client is being connected from.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Audio::RPLD&hellip;</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>  Philipp "ph3-der-loewe" Schafft &lt;lion@lion.leolix.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>      Copyright (C) Philipp &apos;ph3-der-loewe&apos; Schafft - 2009-2012</p><p>  This file is part of Audio::RPLD,   a library to access the RoarAudio PlayList Daemon from Perl.   See README for details.</p><p>  This file is free software; you can redistribute it and/or modify   it under the terms of the GNU General Public License version 3   as published by the Free Software Foundation.</p><p>  Audio::RPLD is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.</p><p>  You should have received a copy of the GNU General Public License   along with this software; see the file COPYING.gplv3.   If not, write to the Free Software Foundation, 51 Franklin Street,   Fifth Floor, Boston, MA 02110-1301, USA.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Audio::Nama::Object.3pm.html"><span aria-hidden="true">&larr;</span> Audio::Nama::Object.3pm: Class builder</a></li>
   <li class="next"><a href="Audio::Scrobbler.3pm.html">Audio::Scrobbler.3pm: Perl interface to audioscrobbler.com/last.fm <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

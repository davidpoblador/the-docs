<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>numa_tonodemask_memory - NUMA policy library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Numa policy library">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">numa_tonodemask_memory<small> (3)</small></h1>
        <p class="lead">Numa policy library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/numa_tonodemask_memory.3.html">
      <span itemprop="name">numa_tonodemask_memory</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/numactl/">
      <span itemprop="name">numactl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<p><strong>#include &lt;numa.h&gt;</strong></p>
<p class='spacer'>

<p><strong>cc ... -lnuma</strong></p>
<p class='spacer'>

<p><strong>int numa_available(void);</strong></p>
<p class='spacer'>

<p><strong>int numa_max_possible_node(void);</strong></p>
<p class='spacer'>

<p><strong>int numa_num_possible_nodes();</strong></p>
<p class='spacer'>

<p><strong>int numa_max_node(void);</strong></p>
<p class='spacer'>

<p><strong>int numa_num_configured_nodes();</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_get_mems_allowed(void);</strong></p>
<p class='spacer'>

<p><strong>int numa_num_configured_cpus(void);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_all_nodes_ptr;</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_no_nodes_ptr;</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_all_cpus_ptr;</strong></p>
<p class='spacer'>

<p><strong>int numa_num_task_cpus();</strong></p>
<p class='spacer'>

<p><strong>int numa_num_task_nodes();</strong></p>
<p class='spacer'>

<p><strong>int numa_parse_bitmap(char *</strong><em>line</em><strong> , struct bitmask *</strong><em>mask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_parse_nodestring(const char *</strong><em>string</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_parse_nodestring_all(const char *</strong><em>string</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_parse_cpustring(const char *</strong><em>string</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_parse_cpustring_all(const char *</strong><em>string</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>long numa_node_size(int </strong><em>node</em><strong>, long *</strong><em>freep</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>long long numa_node_size64(int </strong><em>node</em><strong>, long long *</strong><em>freep</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_preferred(void);</strong></p>
<p class='spacer'>

<p><strong>void numa_set_preferred(int </strong><em>node</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_get_interleave_node(void);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_get_interleave_mask(void);</strong></p>
<p class='spacer'>

<p><strong>void numa_set_interleave_mask(struct bitmask *</strong><em>nodemask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_interleave_memory(void *</strong><em>start</em><strong>, size_t </strong><em>size</em><strong>, struct bitmask *</strong><em>nodemask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_bind(struct bitmask *</strong><em>nodemask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_set_localalloc(void);</strong></p>
<p class='spacer'>

<p><strong>void numa_set_membind(struct bitmask *</strong><em>nodemask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_get_membind(void);</strong></p>
<p class='spacer'>

<p><strong>void *numa_alloc_onnode(size_t </strong><em>size</em><strong>, int </strong><em>node</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void *numa_alloc_local(size_t </strong><em>size</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void *numa_alloc_interleaved(size_t </strong><em>size</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void *numa_alloc_interleaved_subset(size_t </strong><em>size</em><strong>,  struct bitmask *</strong><em>nodemask</em><strong>);</strong> <strong>void *numa_alloc(size_t </strong><em>size</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void *numa_realloc(void *old_addr</strong><em>, size_t </em><strong>old_size</strong><em>, size_t </em><strong>new_size</strong><em>);</em></p>
<p class='spacer'>

<p><strong>void numa_free(void *</strong><em>start</em><strong>, size_t </strong><em>size</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_run_on_node(int </strong><em>node</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_run_on_node_mask(struct bitmask *</strong><em>nodemask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_run_on_node_mask_all(struct bitmask *</strong><em>nodemask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_get_run_node_mask(void);</strong></p>
<p class='spacer'>

<p><strong>void numa_tonode_memory(void *</strong><em>start</em><strong>, size_t </strong><em>size</em><strong>, int </strong><em>node</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_tonodemask_memory(void *</strong><em>start</em><strong>, size_t </strong><em>size</em><strong>, struct bitmask *</strong><em>nodemask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_setlocal_memory(void *</strong><em>start</em><strong>, size_t </strong><em>size</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_police_memory(void *</strong><em>start</em><strong>, size_t </strong><em>size</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_set_bind_policy(int </strong><em>strict</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_set_strict(int </strong><em>strict</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_distance(int </strong><em>node1</em><strong>, int </strong><em>node2</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_sched_getaffinity(pid_t </strong><em>pid</em><strong>, struct bitmask *</strong><em>mask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_sched_setaffinity(pid_t </strong><em>pid</em><strong>, struct bitmask *</strong><em>mask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_node_to_cpus(int </strong><em>node</em><strong>, struct bitmask *</strong><em>mask</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_node_of_cpu(int </strong><em>cpu</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_allocate_cpumask();</strong></p>
<p class='spacer'>

<p><strong>void numa_free_cpumask();</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_allocate_nodemask();</strong></p>
<p class='spacer'>

<p><strong>void numa_free_nodemask();</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_bitmask_alloc(unsigned int </strong><em>n</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_bitmask_clearall(struct bitmask *</strong><em>bmp</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_bitmask_clearbit(struct bitmask *</strong><em>bmp</em><strong>, unsigned int </strong><em>n</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_bitmask_equal(const struct bitmask *</strong><em>bmp1</em><strong>, const struct bitmask *</strong><em>bmp2</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_bitmask_free(struct bitmask *</strong><em>bmp</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_bitmask_isbitset(const struct bitmask *</strong><em>bmp</em><strong>, unsigned int </strong><em>n</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>unsigned int numa_bitmask_nbytes(struct bitmask *</strong><em>bmp</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_bitmask_setall(struct bitmask *</strong><em>bmp</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>struct bitmask *numa_bitmask_setbit(struct bitmask *</strong><em>bmp</em><strong>, unsigned int </strong><em>n</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void copy_bitmask_to_nodemask(struct bitmask *</strong><em>bmp</em><strong>, nodemask_t *</strong><em>nodemask</em><strong>)</strong></p>
<p class='spacer'>

<p><strong>void copy_nodemask_to_bitmask(nodemask_t *</strong><em>nodemask</em><strong>, struct bitmask *</strong><em>bmp</em><strong>)</strong></p>
<p class='spacer'>

<p><strong>void copy_bitmask_to_bitmask(struct bitmask *</strong><em>bmpfrom</em><strong>, struct bitmask *</strong><em>bmpto</em><strong>)</strong></p>
<p class='spacer'>

<p><strong>unsigned int numa_bitmask_weight(const struct bitmask *bmp )</strong></p>
<p class='spacer'>

<p><strong>int numa_move_pages(int </strong><em>pid</em><strong>, unsigned long </strong><em>count</em><strong>, void **</strong><em>pages</em><strong>, const int *</strong><em>nodes</em><strong>, int *</strong><em>status</em><strong>, int </strong><em>flags</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int numa_migrate_pages(int </strong><em>pid</em><strong>, struct bitmask *</strong><em>fromnodes</em><strong>, struct bitmask *</strong><em>tonodes</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>void numa_error(char *</strong><em>where</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>extern int </strong><em>numa_exit_on_error</em><strong>;</strong></p>
<p class='spacer'>

<p><strong>extern int </strong><em>numa_exit_on_warn</em><strong>;</strong></p>
<p class='spacer'>

<p><strong>void numa_warn(int </strong><em>number</em><strong>, char *</strong><em>where</em><strong>, ...);</strong></p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<p>The <em>libnuma</em> library offers a simple programming interface to the NUMA (Non Uniform Memory Access) policy supported by the Linux kernel. On a NUMA architecture some memory areas have different latency or bandwidth than others.</p>
<p class='spacer'>

<p>Available policies are page interleaving (i.e., allocate in a round-robin fashion from all, or a subset, of the nodes on the system), preferred node allocation (i.e., preferably allocate on a particular node), local allocation (i.e., allocate on the node on which the task is currently executing), or allocation only on specific nodes (i.e., allocate on some subset of the available nodes). It is also possible to bind tasks to specific nodes.</p>
<p class='spacer'>

<p>Numa memory allocation policy may be specified as a per-task attribute, that is inherited by children tasks and processes, or as an attribute of a range of process virtual address space. Numa memory policies specified for a range of virtual address space are shared by all tasks in the process. Further more, memory policies specified for a range of a shared memory attached using <a href="../man2/shmat.2.html"><strong>shmat</strong>(2)</a></em> or <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a></em> from shmfs/hugetlbfs are shared by all processes that attach to that region. Memory policies for shared disk backed file mappings are currently ignored.</p>
<p class='spacer'>

<p>The default memory allocation policy for tasks and all memory range is local allocation. This assumes that no ancestor has installed a non-default policy.</p>
<p class='spacer'>

<p>For setting a specific policy globally for all memory allocations in a process and its children it is easiest to start it with the <a href="../man8/numactl.8.html"><strong>numactl</strong>(8)</a> utility. For more finegrained policy inside an application this library can be used.</p>
<p class='spacer'>

<p>All numa memory allocation policy only takes effect when a page is actually faulted into the address space of a process by accessing it. The <strong>numa_alloc_*</strong> functions take care of this automatically.</p>
<p class='spacer'>

<p>A <em>node</em> is defined as an area where all memory has the same speed as seen from a particular CPU. A node can contain multiple CPUs. Caches are ignored for this definition.</p>
<p class='spacer'>

<p>Most functions in this library are only concerned about numa nodes and their memory. The exceptions to this are: <em>numa_node_to_cpus</em>(), <em>numa_node_of_cpu</em>(), <em>numa_bind</em>(), <em>numa_run_on_node</em>(), <em>numa_run_on_node_mask</em>(), <em>numa_run_on_node_mask_all</em>(), and <em>numa_get_run_node_mask</em>(). These functions deal with the CPUs associated with numa nodes. See the descriptions below for more information.</p>
<p class='spacer'>

<p>Some of these functions accept or return a pointer to struct bitmask. A struct bitmask controls a bit map of arbitrary length containing a bit representation of nodes.  The predefined variable <em>numa_all_nodes_ptr</em> points to a bit mask that has all available nodes set; <em>numa_no_nodes_ptr</em> points to the empty set.</p>
<p class='spacer'>

<p>Before any other calls in this library can be used <strong>numa_available</strong>() must be called. If it returns -1, all other functions in this library are undefined.</p>
<p class='spacer'>

<p><strong>numa_max_possible_node()</strong> returns the number of the highest possible node in a system. In other words, the size of a kernel type nodemask_t (in bits) minus 1. This number can be gotten by calling <strong>numa_num_possible_nodes()</strong> and subtracting 1.</p>
<p class='spacer'>

<p><strong>numa_num_possible_nodes()</strong> returns the size of kernel's node mask (kernel type nodemask_t). In other words, large enough to represent the maximum number of nodes that the kernel can handle. This will match the kernel's MAX_NUMNODES value. This count is derived from /proc/self/status, field Mems_allowed.</p>
<p class='spacer'>

<p><strong>numa_max_node</strong>() returns the highest node number available on the current system. (See the node numbers in /sys/devices/system/node/ ).  Also see <strong>numa_num_configured_nodes().</strong></p>
<p class='spacer'>

<p><strong>numa_num_configured_nodes()</strong> returns the number of memory nodes in the system. This count includes any nodes that are currently disabled. This count is derived from the node numbers in /sys/devices/system/node. (Depends on the kernel being configured with /sys (CONFIG_SYSFS)).</p>
<p class='spacer'>

<p><strong>numa_get_mems_allowed()</strong> returns the mask of nodes from which the process is allowed to allocate memory in it's current cpuset context. Any nodes that are not included in the returned bitmask will be ignored in any of the following libnuma memory policy calls.</p>
<p class='spacer'>

<p><strong>numa_num_configured_cpus()</strong> returns the number of cpus in the system.  This count includes any cpus that are currently disabled. This count is derived from the cpu numbers in /sys/devices/system/cpu. If the kernel is configured without /sys (CONFIG_SYSFS=n) then it falls back to using the number of online cpus.</p>
<p class='spacer'>

<p><strong>numa_all_nodes_ptr</strong> points to a bitmask that is allocated by the library with bits representing all nodes on which the calling task may allocate memory. This set may be up to all nodes on the system, or up to the nodes in the current cpuset. The bitmask is allocated by a call to <strong>numa_allocate_nodemask()</strong> using size <strong>numa_max_possible_node().</strong> The set of nodes to record is derived from /proc/self/status, field "Mems_allowed".  The user should not alter this bitmask.</p>
<p class='spacer'>

<p><strong>numa_no_nodes_ptr</strong> points to a bitmask that is allocated by the library and left all zeroes.  The bitmask is allocated by a call to <strong>numa_allocate_nodemask()</strong> using size <strong>numa_max_possible_node().</strong> The user should not alter this bitmask.</p>
<p class='spacer'>

<p><strong>numa_all_cpus_ptr</strong> points to a bitmask that is allocated by the library with bits representing all cpus on which the calling task may execute. This set may be up to all cpus on the system, or up to the cpus in the current cpuset. The bitmask is allocated by a call to <strong>numa_allocate_cpumask()</strong> using size <strong>numa_num_possible_cpus().</strong> The set of cpus to record is derived from /proc/self/status, field "Cpus_allowed".  The user should not alter this bitmask.</p>
<p class='spacer'>

<p><strong>numa_num_task_cpus()</strong> returns the number of cpus that the calling task is allowed to use.  This count is derived from the map /proc/self/status, field "Cpus_allowed". Also see the bitmask <strong>numa_all_cpus_ptr.</strong></p>
<p class='spacer'>

<p><strong>numa_num_task_nodes()</strong> returns the number of nodes on which the calling task is allowed to allocate memory.  This count is derived from the map /proc/self/status, field "Mems_allowed". Also see the bitmask <strong>numa_all_nodes_ptr.</strong></p>
<p class='spacer'>

<p><strong>numa_parse_bitmap()</strong> parses <em>line</em> , which is a character string such as found in /sys/devices/system/node/nodeN/cpumap into a bitmask structure. The string contains the hexadecimal representation of a bit map. The bitmask may be allocated with <strong>numa_allocate_cpumask().</strong> Returns  0 on success.  Returns -1 on failure. This function is probably of little use to a user application, but it is used by <em>libnuma</em> internally.</p>
<p class='spacer'>

<p><strong>numa_parse_nodestring()</strong> parses a character string list of nodes into a bit mask. The bit mask is allocated by <strong>numa_allocate_nodemask().</strong> The string is a comma-separated list of node numbers or node ranges. A leading ! can be used to indicate "not" this list (in other words, all nodes except this list), and a leading + can be used to indicate that the node numbers in the list are relative to the task's cpuset.  The string can be "all" to specify all ( <strong>numa_num_task_nodes()</strong> ) nodes.  Node numbers are limited by the number in the system.  See <strong>numa_max_node()</strong> and <strong>numa_num_configured_nodes().</strong></p>
<p class='spacer'>

<p>Examples:  1-5,7,10   !4-5   +0-3</p>
<p class='spacer'>

<p>If the string is of 0 length, bitmask <strong>numa_no_nodes_ptr</strong> is returned.  Returns 0 if the string is invalid.</p>
<p class='spacer'>

<p><strong>numa_parse_nodestring_all()</strong> is similar to <strong>numa_parse_nodestring</strong> , but can parse all possible nodes, not only current nodeset.</p>
<p class='spacer'>

<p><strong>numa_parse_cpustring()</strong> parses a character string list of cpus into a bit mask. The bit mask is allocated by <strong>numa_allocate_cpumask().</strong> The string is a comma-separated list of cpu numbers or cpu ranges. A leading ! can be used to indicate "not" this list (in other words, all cpus except this list), and a leading + can be used to indicate that the cpu numbers in the list are relative to the task's cpuset.  The string can be "all" to specify all ( <strong>numa_num_task_cpus()</strong> ) cpus. Cpu numbers are limited by the number in the system.  See <strong>numa_num_task_cpus()</strong> and <strong>numa_num_configured_cpus().</strong></p>
<p class='spacer'>

<p>Examples:  1-5,7,10   !4-5   +0-3</p>
<p class='spacer'>

<p>Returns 0 if the string is invalid.</p>
<p class='spacer'>

<p><strong>numa_parse_cpustring_all()</strong> is similar to <strong>numa_parse_cpustring</strong> , but can parse all possible cpus, not only current cpuset.</p>
<p class='spacer'>

<p><strong>numa_node_size</strong>() returns the memory size of a node. If the argument <em>freep</em> is not NULL, it used to return the amount of free memory on the node. On error it returns -1.</p>
<p class='spacer'>

<p><strong>numa_node_size64</strong>() works the same as <strong>numa_node_size</strong>() except that it returns values as <em>long long</em> instead of <em>long</em>. This is useful on 32-bit architectures with large nodes.</p>
<p class='spacer'>

<p><strong>numa_preferred</strong>() returns the preferred node of the current task. This is the node on which the kernel preferably allocates memory, unless some other policy overrides this.</p>
<p class='spacer'>

<p><strong>numa_set_preferred</strong>() sets the preferred node for the current task to <em>node</em>. The system will attempt to allocate memory from the preferred node, but will fall back to other nodes if no memory is available on the the preferred node. Passing a <em>node</em> of -1 argument specifies local allocation and is equivalent to calling <strong>numa_set_localalloc</strong>().</p>
<p class='spacer'>

<p><strong>numa_get_interleave_mask</strong>() returns the current interleave mask if the task's memory allocation policy is page interleaved. Otherwise, this function returns an empty mask.</p>
<p class='spacer'>

<p><strong>numa_set_interleave_mask</strong>() sets the memory interleave mask for the current task to <em>nodemask</em>. All new memory allocations are page interleaved over all nodes in the interleave mask. Interleaving can be turned off again by passing an empty mask (<em>numa_no_nodes</em>). The page interleaving only occurs on the actual page fault that puts a new page into the current address space. It is also only a hint: the kernel will fall back to other nodes if no memory is available on the interleave target.</p>
<p class='spacer'>

<p><strong>numa_interleave_memory</strong>() interleaves <em>size</em> bytes of memory page by page from <em>start</em> on nodes specified in <em>nodemask</em>. The <em>size</em> argument will be rounded up to a multiple of the system page size. If <em>nodemask</em> contains nodes that are externally denied to this process, this call will fail. This is a lower level function to interleave allocated but not yet faulted in memory. Not yet faulted in means the memory is allocated using <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a> or <a href="../man2/shmat.2.html"><strong>shmat</strong>(2)</a>, but has not been accessed by the current process yet. The memory is page interleaved to all nodes specified in <em>nodemask</em>. Normally <strong>numa_alloc_interleaved</strong>() should be used for private memory instead, but this function is useful to handle shared memory areas. To be useful the memory area should be several megabytes at least (or tens of megabytes of hugetlbfs mappings) If the <strong>numa_set_strict</strong>() flag is true then the operation will cause a numa_error if there were already pages in the mapping that do not follow the policy.</p>
<p class='spacer'>

<p><strong>numa_bind</strong>() binds the current task and its children to the nodes specified in <em>nodemask</em>. They will only run on the CPUs of the specified nodes and only be able to allocate memory from them. This function is equivalent to calling <em>numa_run_on_node_mask(nodemask)</em> followed by <em>numa_set_membind(nodemask)</em>. If tasks should be bound to individual CPUs inside nodes consider using <em>numa_node_to_cpus</em> and the <a href="../man2/sched_setaffinity.2.html"><strong>sched_setaffinity</strong>(2)</a></em> syscall.</p>
<p class='spacer'>

<p><strong>numa_set_localalloc</strong>() sets the memory allocation policy for the calling task to local allocation. In this mode, the preferred node for memory allocation is effectively the node where the task is executing at the time of a page allocation.</p>
<p class='spacer'>

<p><strong>numa_set_membind</strong>() sets the memory allocation mask. The task will only allocate memory from the nodes set in <em>nodemask</em>. Passing an empty <em>nodemask</em> or a <em>nodemask</em> that contains nodes other than those in the mask returned by <em>numa_get_mems_allowed</em>() will result in an error.</p>
<p class='spacer'>

<p><strong>numa_get_membind</strong>() returns the mask of nodes from which memory can currently be allocated. If the returned mask is equal to <em>numa_all_nodes</em>, then memory allocation is allowed from all nodes.</p>
<p class='spacer'>

<p><strong>numa_alloc_onnode</strong>() allocates memory on a specific node. The <em>size</em> argument will be rounded up to a multiple of the system page size. if the specified <em>node</em> is externally denied to this process, this call will fail. This function is relatively slow compared to the <a href="../man3/malloc.3.html"><strong>malloc</strong>(3)</a>, family of functions. The memory must be freed with <strong>numa_free</strong>(). On errors NULL is returned.</p>
<p class='spacer'>

<p><strong>numa_alloc_local</strong>() allocates <em>size</em> bytes of memory on the local node. The <em>size</em> argument will be rounded up to a multiple of the system page size. This function is relatively slow compared to the <a href="../man3/malloc.3.html"><strong>malloc</strong>(3)</a> family of functions. The memory must be freed with <strong>numa_free</strong>(). On errors NULL is returned.</p>
<p class='spacer'>

<p><strong>numa_alloc_interleaved</strong>() allocates <em>size</em> bytes of memory page interleaved on all nodes. This function is relatively slow and should only be used for large areas consisting of multiple pages. The interleaving works at page level and will only show an effect when the area is large. The allocated memory must be freed with <strong>numa_free</strong>(). On error, NULL is returned.</p>
<p class='spacer'>

<p><strong>numa_alloc_interleaved_subset</strong>() attempts to allocate <em>size</em> bytes of memory page interleaved on all nodes. The <em>size</em> argument will be rounded up to a multiple of the system page size. The nodes on which a process is allowed to allocate memory may be constrained externally. If this is the case, this function may fail. This function is relatively slow compare to <a href="../man3/malloc.3.html"><strong>malloc</strong>(3)</a>, family of functions and should only be used for large areas consisting of multiple pages. The interleaving works at page level and will only show an effect when the area is large. The allocated memory must be freed with <strong>numa_free</strong>(). On error, NULL is returned.</p>
<p class='spacer'>

<p><strong>numa_alloc</strong>() allocates <em>size</em> bytes of memory with the current NUMA policy. The <em>size</em> argument will be rounded up to a multiple of the system page size. This function is relatively slow compare to the <a href="../man3/malloc.3.html"><strong>malloc</strong>(3)</a> family of functions. The memory must be freed with <strong>numa_free</strong>(). On errors NULL is returned.</p>
<p class='spacer'>

<p><strong>numa_realloc</strong>() changes the size of the memory area pointed to by <em>old_addr</em> from <em>old_size</em> to <em>new_size.</em> The memory area pointed to by <em>old_addr</em> must have been allocated with one of the <strong>numa_alloc*</strong> functions. The <em>new_size</em> will be rounded up to a multiple of the system page size. The contents of the memory area will be unchanged to the minimum of the old and new sizes; newly allocated memory will be uninitialized. The memory policy (and node bindings) associated with the original memory area will be preserved in the resized area. For example, if the initial area was allocated with a call to <strong>numa_alloc_onnode(),</strong> then the new pages (if the area is enlarged) will be allocated on the same node. However, if no memory policy was set for the original area, then <strong>numa_realloc</strong>() cannot guarantee that the new pages will be allocated on the same node. On success, the address of the resized area is returned (which might be different from that of the initial area), otherwise NULL is returned and <em>errno</em> is set to indicate the error. The pointer returned by <strong>numa_realloc</strong>() is suitable for passing to <strong>numa_free</strong>().</p>
<p class='spacer'>

<p><strong>numa_free</strong>() frees <em>size</em> bytes of memory starting at <em>start</em>, allocated by the <strong>numa_alloc_*</strong> functions above. The <em>size</em> argument will be rounded up to a multiple of the system page size.</p>
<p class='spacer'>

<p><strong>numa_run_on_node</strong>() runs the current task and its children on a specific node. They will not migrate to CPUs of other nodes until the node affinity is reset with a new call to <strong>numa_run_on_node_mask</strong>(). Passing -1 permits the kernel to schedule on all nodes again. On success, 0 is returned; on error -1 is returned, and <em>errno</em> is set to indicate the error.</p>
<p class='spacer'>

<p><strong>numa_run_on_node_mask</strong>() runs the current task and its children only on nodes specified in <em>nodemask</em>. They will not migrate to CPUs of other nodes until the node affinity is reset with a new call to <strong>numa_run_on_node_mask</strong>() or <strong>numa_run_on_node</strong>(). Passing <em>numa_all_nodes</em> permits the kernel to schedule on all nodes again. On success, 0 is returned; on error -1 is returned, and <em>errno</em> is set to indicate the error.</p>
<p class='spacer'>

<p><strong>numa_run_on_node_mask_all</strong>() runs the current task and its children only on nodes specified in <em>nodemask</em> like <em>numa_run_on_node_mask</em> but without any cpuset awareness.</p>
<p class='spacer'>

<p><strong>numa_get_run_node_mask</strong>() returns a mask of CPUs on which the current task is allowed to run.</p>
<p class='spacer'>

<p><strong>numa_tonode_memory</strong>() put memory on a specific node. The constraints described for <strong>numa_interleave_memory</strong>() apply here too.</p>
<p class='spacer'>

<p><strong>numa_tonodemask_memory</strong>() put memory on a specific set of nodes. The constraints described for <strong>numa_interleave_memory</strong>() apply here too.</p>
<p class='spacer'>

<p><strong>numa_setlocal_memory</strong>() locates memory on the current node. The constraints described for <strong>numa_interleave_memory</strong>() apply here too.</p>
<p class='spacer'>

<p><strong>numa_police_memory</strong>() locates memory with the current NUMA policy. The constraints described for <strong>numa_interleave_memory</strong>() apply here too.</p>
<p class='spacer'>

<p><strong>numa_distance</strong>() reports the distance in the machine topology between two nodes. The factors are a multiple of 10. It returns 0 when the distance cannot be determined. A node has distance 10 to itself. Reporting the distance requires a Linux kernel version of <em>2.6.10</em> or newer.</p>
<p class='spacer'>

<p><strong>numa_set_bind_policy</strong>() specifies whether calls that bind memory to a specific node should use the preferred policy or a strict policy. The preferred policy allows the kernel to allocate memory on other nodes when there isn't enough free on the target node. strict will fail the allocation in that case. Setting the argument to specifies strict, 0 preferred. Note that specifying more than one node non strict may only use the first node in some kernel versions.</p>
<p class='spacer'>

<p><strong>numa_set_strict</strong>() sets a flag that says whether the functions allocating on specific nodes should use use a strict policy. Strict means the allocation will fail if the memory cannot be allocated on the target node. Default operation is to fall back to other nodes. This doesn't apply to interleave and default.</p>
<p class='spacer'>

<p><strong>numa_get_interleave_node()</strong> is used by <em>libnuma</em> internally. It is probably not useful for user applications. It uses the MPOL_F_NODE flag of the get_mempolicy system call, which is not intended for application use (its operation may change or be removed altogether in future kernel versions). See <a href="../man2/get_mempolicy.2.html"><strong>get_mempolicy</strong>(2)</a>.</p>
<p class='spacer'>

<p><strong>numa_pagesize()</strong> returns the number of bytes in page. This function is simply a fast alternative to repeated calls to the getpagesize system call. See <a href="../man2/getpagesize.2.html"><strong>getpagesize</strong>(2)</a>.</p>
<p class='spacer'>

<p><strong>numa_sched_getaffinity()</strong> retrieves a bitmask of the cpus on which a task may run.  The task is specified by <em>pid.</em> Returns the return value of the sched_getaffinity system call.  See <a href="../man2/sched_getaffinity.2.html"><strong>sched_getaffinity</strong>(2)</a>. The bitmask must be at least the size of the kernel's cpu mask structure. Use <strong>numa_allocate_cpumask()</strong> to allocate it. Test the bits in the mask by calling <strong>numa_bitmask_isbitset().</strong></p>
<p class='spacer'>

<p><strong>numa_sched_setaffinity()</strong> sets a task's allowed cpu's to those cpu's specified in <em>mask.</em> The task is specified by <em>pid.</em> Returns the return value of the sched_setaffinity system call. See <a href="../man2/sched_setaffinity.2.html"><strong>sched_setaffinity</strong>(2)</a>.  You may allocate the bitmask with <strong>numa_allocate_cpumask().</strong> Or the bitmask may be smaller than the kernel's cpu mask structure. For example, call <strong>numa_bitmask_alloc()</strong> using a maximum number of cpus from <strong>numa_num_configured_cpus().</strong> Set the bits in the mask by calling <strong>numa_bitmask_setbit().</strong></p>
<p class='spacer'>

<p><strong>numa_node_to_cpus</strong>() converts a node number to a bitmask of CPUs. The user must pass a bitmask structure with a mask buffer long enough to represent all possible cpu's. Use numa_allocate_cpumask() to create it.  If the bitmask is not long enough <em>errno</em> will be set to <em>ERANGE</em> and -1 returned. On success 0 is returned.</p>
<p class='spacer'>

<p><strong>numa_node_of_cpu</strong>() returns the node that a cpu belongs to. If the user supplies an invalid cpu <em>errno</em> will be set to <em>EINVAL</em> and -1 will be returned.</p>
<p class='spacer'>

<p><strong>numa_allocate_cpumask</strong> () returns a bitmask of a size equal to the kernel's cpu mask (kernel type cpumask_t).  In other words, large enough to represent NR_CPUS cpus.  This number of cpus can be gotten by calling <strong>numa_num_possible_cpus().</strong> The bitmask is zero-filled.</p>
<p class='spacer'>

<p><strong>numa_free_cpumask</strong> frees a cpumask previously allocate by <em>numa_allocate_cpumask.</em></p>
<p class='spacer'>

<p><strong>numa_allocate_nodemask()</strong> returns a bitmask of a size equal to the kernel's node mask (kernel type nodemask_t).  In other words, large enough to represent MAX_NUMNODES nodes.  This number of nodes can be gotten by calling <strong>numa_num_possible_nodes().</strong> The bitmask is zero-filled.</p>
<p class='spacer'>

<p><strong>numa_free_nodemask()</strong> frees a nodemask previous allocated by <em>numa_allocate_nodemask().</em></p>
<p class='spacer'>

<p><strong>numa_bitmask_alloc()</strong> allocates a bitmask structure and its associated bit mask. The memory allocated for the bit mask contains enough words (type unsigned long) to contain <em>n</em> bits.  The bit mask is zero-filled.  The bitmask structure points to the bit mask and contains the <em>n</em> value.</p>
<p class='spacer'>

<p><strong>numa_bitmask_clearall()</strong> sets all bits in the bit mask to 0.  The bitmask structure points to the bit mask and contains its size ( <em>bmp</em> -&gt;size).  The value of <em>bmp</em> is always returned.  Note that <strong>numa_bitmask_alloc()</strong> creates a zero-filled bit mask.</p>
<p class='spacer'>

<p><strong>numa_bitmask_clearbit()</strong> sets a specified bit in a bit mask to 0.  Nothing is done if the <em>n</em> value is greater than the size of the bitmask (and no error is returned). The value of <em>bmp</em> is always returned.</p>
<p class='spacer'>

<p><strong>numa_bitmask_equal()</strong> returns 1 if two bitmasks are equal.  It returns 0 if they are not equal.  If the bitmask structures control bit masks of different sizes, the "missing" trailing bits of the smaller bit mask are considered to be 0.</p>
<p class='spacer'>

<p><strong>numa_bitmask_free()</strong> deallocates the memory of both the bitmask structure pointed to by <em>bmp</em> and the bit mask.  It is an error to attempt to free this bitmask twice.</p>
<p class='spacer'>

<p><strong>numa_bitmask_isbitset()</strong> returns the value of a specified bit in a bit mask. If the <em>n</em> value is greater than the size of the bit map, 0 is returned.</p>
<p class='spacer'>

<p><strong>numa_bitmask_nbytes()</strong> returns the size (in bytes) of the bit mask controlled by <em>bmp.</em> The bit masks are always full words (type unsigned long), and the returned size is the actual size of all those words.</p>
<p class='spacer'>

<p><strong>numa_bitmask_setall()</strong> sets all bits in the bit mask to 1.  The bitmask structure points to the bit mask and contains its size ( <em>bmp</em> -&gt;size). The value of <em>bmp</em> is always returned.</p>
<p class='spacer'>

<p><strong>numa_bitmask_setbit()</strong> sets a specified bit in a bit mask to 1.  Nothing is done if <em>n</em> is greater than the size of the bitmask (and no error is returned). The value of <em>bmp</em> is always returned.</p>
<p class='spacer'>

<p><strong>copy_bitmask_to_nodemask()</strong> copies the body (the bit map itself) of the bitmask structure pointed to by <em>bmp</em> to the nodemask_t structure pointed to by the <em>nodemask</em> pointer. If the two areas differ in size, the copy is truncated to the size of the receiving field or zero-filled.</p>
<p class='spacer'>

<p><strong>copy_nodemask_to_bitmask()</strong> copies the nodemask_t structure pointed to by the <em>nodemask</em> pointer to the body (the bit map itself) of the bitmask structure pointed to by the <em>bmp</em> pointer. If the two areas differ in size, the copy is truncated to the size of the receiving field or zero-filled.</p>
<p class='spacer'>

<p><strong>copy_bitmask_to_bitmask()</strong> copies the body (the bit map itself) of the bitmask structure pointed to by the <em>bmpfrom</em> pointer to the body of the bitmask structure pointed to by the <em>bmpto</em> pointer. If the two areas differ in size, the copy is truncated to the size of the receiving field or zero-filled.</p>
<p class='spacer'>

<p><strong>numa_bitmask_weight()</strong> returns a count of the bits that are set in the body of the bitmask pointed to by the <em>bmp</em> argument.</p>
<p class='spacer'>

<p class='spacer'>

<p><strong>numa_move_pages()</strong> moves a list of pages in the address space of the currently executing or current process. It simply uses the move_pages system call.</p>
<p class='spacer'>

<p><em>pid</em> - ID of task.  If not valid, use the current task.</p>
<p class='spacer'>

<p><em>count</em> - Number of pages.</p>
<p class='spacer'>

<p><em>pages</em> - List of pages to move.</p>
<p class='spacer'>

<p><em>nodes</em> - List of nodes to which pages can be moved.</p>
<p class='spacer'>

<p><em>status</em> - Field to which status is to be returned.</p>
<p class='spacer'>

<p><em>flags</em> - MPOL_MF_MOVE or MPOL_MF_MOVE_ALL</p>
<p class='spacer'>

<p>See <a href="../man2/move_pages.2.html"><strong>move_pages</strong>(2)</a>.</p>
<p class='spacer'>

<p><strong>numa_migrate_pages()</strong> simply uses the migrate_pages system call to cause the pages of the calling task, or a specified task, to be migated from one set of nodes to another. See <a href="../man2/migrate_pages.2.html"><strong>migrate_pages</strong>(2)</a>. The bit masks representing the nodes should be allocated with <strong>numa_allocate_nodemask()</strong> , or with <strong>numa_bitmask_alloc()</strong> using an <em>n</em> value returned from <strong>numa_num_possible_nodes().</strong> A task's current node set can be gotten by calling <strong>numa_get_membind().</strong> Bits in the <em>tonodes</em> mask can be set by calls to <strong>numa_bitmask_setbit().</strong></p>
<p class='spacer'>

<p><strong>numa_error</strong>() is a <em>libnuma</em> internal function that can be overridden by the user program. This function is called with a <em>char *</em> argument when a <em>libnuma</em> function fails. Overriding the library internal definition makes it possible to specify a different error handling strategy when a <em>libnuma</em> function fails. It does not affect <strong>numa_available</strong>(). The <strong>numa_error</strong>() function defined in <em>libnuma</em> prints an error on <em>stderr</em> and terminates the program if <em>numa_exit_on_error</em> is set to a non-zero value. The default value of <em>numa_exit_on_error</em> is zero.</p>
<p class='spacer'>

<p><strong>numa_warn</strong>() is a <em>libnuma</em> internal function that can be also overridden by the user program. It is called to warn the user when a <em>libnuma</em> function encounters a non-fatal error. The default implementation prints a warning to <em>stderr</em>. The first argument is a unique number identifying each warning. After that there is a <a href="../man3/printf.3.html"><strong>printf</strong>(3)</a>-style format string and a variable number of arguments. <em>numa_warn</em> exits the program when <em>numa_exit_on_warn</em> is set to a non-zero value. The default value of <em>numa_exit_on_warn</em> is zero.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Compatibility with libnuma version 1</h2>
        <div class="sectioncontent">

<p>Binaries that were compiled for libnuma version 1 need not be re-compiled to run with libnuma version 2.</p>
<p class='spacer'>

<p>Source codes written for libnuma version 1 may be re-compiled without change with version 2 installed. To do so, in the code's Makefile add this option to CFLAGS:  -DNUMA_VERSION1_COMPATIBILITY</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THREAD SAFETY</h2>
        <div class="sectioncontent">

<p><em>numa_set_bind_policy</em> and <em>numa_exit_on_error</em> are process global. The other calls are thread safe.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">

<p>Copyright 2002, 2004, 2007, 2008 Andi Kleen, SuSE Labs. <em>libnuma</em> is under the GNU Lesser General Public License, v2.1.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEE ALSO</h2>
        <div class="sectioncontent">

<p><a href="../man2/get_mempolicy.2.html"><strong>get_mempolicy</strong>(2)</a>, <a href="../man2/set_mempolicy.2.html"><strong>set_mempolicy</strong>(2)</a>, <a href="../man2/getpagesize.2.html"><strong>getpagesize</strong>(2)</a>, <a href="../man2/mbind.2.html"><strong>mbind</strong>(2)</a>, <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a>, <a href="../man2/shmat.2.html"><strong>shmat</strong>(2)</a>, <a href="../man8/numactl.8.html"><strong>numactl</strong>(8)</a>, <a href="../man2/sched_getaffinity.2.html"><strong>sched_getaffinity</strong>(2)</a> <a href="../man2/sched_setaffinity.2.html"><strong>sched_setaffinity</strong>(2)</a> <a href="../man2/move_pages.2.html"><strong>move_pages</strong>(2)</a> <a href="../man2/migrate_pages.2.html"><strong>migrate_pages</strong>(2)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="numa_tonode_memory.3.html"><span aria-hidden="true">&larr;</span> numa_tonode_memory.3: NUMA policy library</a></li>
   <li class="next"><a href="offsetof.3.html">offsetof.3: offset of a structure member <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

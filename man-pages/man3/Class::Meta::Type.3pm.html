<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::Meta::Type: Data type validation and accessor building.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Data type validation and accessor building.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::Meta::Type (3pm) manual">
  <meta name="twitter:description" content="Data type validation and accessor building.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-meta-perl-Class::Meta::Type-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::Meta::Type.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::Meta::Type (3pm) manual" />
  <meta property="og:description" content="Data type validation and accessor building." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-meta-perl-Class::Meta::Type-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::Meta::Type<small> (3pm)</small></h1>
        <p class="lead">Data type validation and accessor building.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Meta::Type.3pm.html">
      <span itemprop="name">Class::Meta::Type: Data type validation and accessor building.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-meta-perl/">
      <span itemprop="name">libclass-meta-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Meta::Type.3pm.html">
      <span itemprop="name">Class::Meta::Type: Data type validation and accessor building.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  package MyApp::TypeDef;

  use strict;
  use Class::Meta::Type;
  use IO::Socket;

  my $type = Class::Meta::Type-&gt;add(
      key  =&gt; &apos;io_socket&apos;,
      desc =&gt; &apos;IO::Socket object&apos;,
      name =&gt; &apos;IO::Socket Object&apos;
  );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This class stores the various data types us ed by \*(C`Class::Meta\*(C'. It manages all aspects of data type validation and method creation. New data types can be added to Class::Meta::Type by means of the \*(C`add()\*(C' constructor. This is useful for creating custom types for your Class::Meta-built classes.</p><p><strong>Note:</strong>This class manages the most advanced features of \*(C`Class::Meta\*(C'. Before deciding to create your own accessor closures as described in <em>add()</em>, you should have a thorough working knowledge of how Class::Meta works, and have studied the <em>add()</em> method carefully. Simple data type definitions such as that shown in the \s-1SYNOPSIS\s0, on the other hand, are encouraged.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTORS</h2>
        <div class="sectioncontent">
<h3>new</h3>
<p>  my $type = Class::Meta::Type-&gt;new($key);</p><p>Returns the data type definition for an existing data type. The definition will be looked up by the $key argument. Use \*(C`add()\*(C' to specify new types. If no data type exists for a given key, but \*(C`Class::Meta-&gt;for_key\*(C' returns a Class::Meta::Class object for that key, then \*(C`new()\*(C' will implicitly call \*(C`add()\*(C' to create add a new type corresponding to that class. This makes it easy to use any Class::Meta class as a data type.</p><p>Other data types can be added by means of the \*(C`add()\*(C' constructor, or by simply \*(C`use\*(C'ing one or more of the following modules:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::Types::Perl
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    scalar
  </dt>
  <dd>
    
  </dd>
  <dt>
    scalarref
  </dt>
  <dd>
    
  </dd>
  <dt>
    array
  </dt>
  <dd>
    
  </dd>
  <dt>
    hash
  </dt>
  <dd>
    
  </dd>
  <dt>
    code
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>
  <dt>
    Class::Meta::Types::String
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    string
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>
  <dt>
    Class::Meta::Types::Boolean
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    boolean
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>
  <dt>
    Class::Meta::Types::Numeric
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    whole
  </dt>
  <dd>
    
  </dd>
  <dt>
    integer
  </dt>
  <dd>
    
  </dd>
  <dt>
    decimal
  </dt>
  <dd>
    
  </dd>
  <dt>
    real
  </dt>
  <dd>
    
  </dd>
  <dt>
    float
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>

</dl>
<p>Read the documentation for the individual modules for details on their data types.</p>
<h3>add</h3>
<p>  my $type = Class::Meta::Type-&gt;add(       key  =&gt; &apos;io_socket&apos;,       name =&gt; &apos;IO::Socket Object&apos;,       desc =&gt; &apos;IO::Socket object&apos;   );</p><p>Creates a new data type definition and stores it for future use. Use this constructor to add new data types to meet the needs of your class. The named parameter arguments are:</p>
<dl class='dl-vertical'>
  <dt>
    key
  </dt>
  <dd>
    <p>Required. The key with which the data type can be looked up in the future via a call to \*(C`new()\*(C'. Note that the key will be used case-insensitively, so \*(L"foo\*(R", \*(L"Foo\*(R", and \*(L"\s-1FOO\s0\*(R" are equivalent, and the key must be unique.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>Required. The name of the data type. This should be formatted for display purposes, and indeed, Class::Meta will often use it in its own exceptions.</p>
  </dd>
  <dt>
    check
  </dt>
  <dd>
    <p>Optional. Specifies how to validate the value of an attribute of this type. The check parameter can be specified in any of the following ways:</p><ul>
<li><p>As a code reference. When Class::Meta executes this code reference, it will pass in the value to check, the object for which the attribute will be set, and the Class::Meta::Attribute object describing the attribute. If the attribute is a class attribute, then the second argument will not be an object, but a hash reference with two keys:</p><p>The existing value for the attribute is stored under the attribute name.</p>
<dl class='dl-vertical'>
  <dt>
    _\|_pkg
  </dt>
  <dd>
    <p>The name of the package to which the attribute is being assigned.</p>
  </dd>

</dl>
<p>If the new value is not the proper value for your custom data type, the code reference should throw an exception. Here's an example; it's the code reference used by \*(L"string\*(R" data type, which you can add to Class::Meta::Type simply by using Class::Meta::Types::String:   check =&gt; sub {       my $value = shift;       return unless defined $value && ref $value;       require Carp;       our @CARP_NOT = qw(Class::Meta::Attribute);       Carp::croak("Value &apos;$value&apos; is not a valid string");   } Here's another example. This code reference might be used to make sure that a new value is always greater than the existing value.   check =&gt; sub {       my ($new_val, $obj, $attr) = @_;       # Just return if the new value is greater than the old value.       return if defined $new_val && $new_val &gt; $_[1]-&gt;{$_[2]-&gt;get_name};       require Carp;       our @CARP_NOT = qw(Class::Meta::Attribute);       Carp::croak("Value &apos;$new_val&apos; is not greater than &apos;$old_val&apos;");   }</p></li><li><p>As an array reference. All items in this array reference must be code references that perform checks on a value, as specified above.</p></li><li><p>As a string. In this case, Class::Meta::Type assumes that your data type identifies a particular object type. Thus it will use the string to construct a validation code reference for you. For example, if you wanted to create a data type for IO::Socket objects, pass the string 'IO::Socket' to the check parameter and Class::Meta::Type will use the code reference returned by \*(C`class_validation_generator()\*(C' to generate the validation checks. If you'd like to specify an alternative class validation code generator, pass one to the \*(C`class_validation_generator()\*(C' class method. Or pass in a code reference or array reference of code reference as just described to use your own validator once.</p></li>
</ul><p>Note that if the \*(C`check\*(C' parameter is not specified, there will never be any validation of your custom data type. And yes, there may be times when you want this \*(-- The default \*(L"scalar\*(R" and \*(L"boolean\*(R" data types, for example, have no checks.</p>
  </dd>
  <dt>
    builder
  </dt>
  <dd>
    <p>Optional. This parameter specifies the accessor builder for attributes of this type. The \*(C`builder\*(C' parameter can be any of the following values:</p><p>The string 'default' uses Class::Meta::Type's default accessor building code, provided by Class::Meta::AccessorBuilder. This is the default value, of course. The string 'default' uses Class::Meta::Type's affordance accessor building code, provided by Class::Meta::AccessorBuilder::Affordance. Affordance accessors provide two accessors for an attribute, a \*(C`get_*\*(C' accessor and a \*(C`set_*\*(C' mutator. See Class::Meta::AccessorBuilder::Affordance for more information. The string 'default' uses Class::Meta::Type's semi-affordance accessor building code, provided by Class::Meta::AccessorBuilder::SemiAffordance. Semi-affordance accessors differ from affordance accessors in that they do not prepend \*(C`get_\*(C' to the accessor. So for an attribute \*(L"foo\*(R", the accessor would be named \*(C`foo()\*(C' and the mutator named \*(C`set_foo()\*(C'. See Class::Meta::AccessorBuilder::SemiAffordance for more information.</p>
<dl class='dl-vertical'>
  <dt>
    A Package Name
  </dt>
  <dd>
    <p>Pass in the name of a package that contains the functions \*(C`build()\*(C', \*(C`build_attr_get()\*(C', and \*(C`build_attr_set()\*(C'. These functions will be used to create the necessary accessors for an attribute. See Custom Accessor Building for details on creating your own accessor builders.</p>
  </dd>

</dl>

  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLASS METHODS</h2>
        <div class="sectioncontent">
<h3>default_builder</h3>
<p>  my $default_builder = Class::Meta::Type-&gt;default_builder;   Class::Meta::Type-&gt;default_builder($default_builder);</p><p>Get or set the default builder class attribute. The value can be any one of the values specified for the \*(C`builder\*(C' parameter to <em>add()</em>. The value set in this attribute will be used for the \*(C`builder\*(C' parameter to to <em>add()</em> when none is explicitly passed. Defaults to \*(L"default\*(R".</p>
<h3>class_validation_generator</h3>
<p>  my $gen = Class::Meta::Type-&gt;class_validation_generator;   Class::Meta::Type-&gt;class_validation_generator( sub {       my ($pkg, $name) = @_;       return sub {           die "&apos;$pkg&apos; is not a valid $name"             unless UNIVERSAL::isa($pkg, $name);       };   });</p><p>Gets or sets a code reference that will be used to generate the validation checks for class data types. That is to say, it will be used when a string is passed to the \*(C`checks\*(C' parameter to &lt;<em>add()</em>&gt; to generate the validation checking code for data types that are objects. By default, it will generate a validation checker like this:</p><p>  sub {       my $value = shift;       return if UNIVERSAL::isa($value, &apos;IO::Socket&apos;)       require Carp;       our @CARP_NOT = qw(Class::Meta::Attribute);       Carp::croak("Value &apos;$value&apos; is not a IO::Socket object");   };</p><p>But if you'd like to specify an alternate validation check generator\*(--perhaps you'd like to throw exception objects rather than use Carp\*(--just pass a code reference to this class method. The code reference should expect two arguments: the data type value to be validated, and the string passed via the \*(C`checks\*(C' parameter to \*(C`add()\*(C'. It should return a code reference or array of code references that validate the value. For example, you might want to do something like this to throw exception objects:</p><p>  use Exception::Class(&apos;MyException&apos;);</p><p>  Class::Meta::Type-&gt;class_validation_generator( sub {       my ($pkg, $type) = @_;       return [ sub {           my ($value, $object, $attr) = @_;           MyException-&gt;throw("Value &apos;$value&apos; is not a valid $type")             unless UNIVERSAL::isa($value, $pkg);       } ];   });</p><p>But if the default object data type validator is good enough for you, don't worry about it.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<h3>Instance Methods</h3>
<p><em>key</em></p><p>  my $key = $type-&gt;key;</p><p>Returns the key name for the type.</p><p><em>name</em></p><p>  my $name = $type-&gt;name;</p><p>Returns the type name.</p><p><em>check</em></p><p>  my $checks = $type-&gt;check;   my @checks = $type-&gt;check;</p><p>Returns an array reference or list of the data type validation code references for the data type.</p><p><em>build</em></p><p>This is a protected method, designed to be called only by the Class::Meta::Attribute class or a subclass of Class::Meta::Attribute. It creates accessors for the class that the Class::Meta::Attribute object is a part of by calling out to the \*(C`build()\*(C' method of the accessor builder class.</p><p>Although you should never call this method directly, subclasses of Class::Meta::Type may need to override its behavior.</p><p><em>make_attr_set</em></p><p>This is a protected method, designed to be called only by the Class::Meta::Attribute class or a subclass of Class::Meta::Attribute. It returns a reference to the attribute set accessor (mutator) created by the call to \*(C`build()\*(C', and usable as an indirect attribute accessor by the Class::Meta::Attribute \*(C`set()\*(C' method.</p><p>Although you should never call this method directly, subclasses of Class::Meta::Type may need to override its behavior.</p><p><em>make_attr_get</em></p><p>This is a protected method, designed to be called only by the Class::Meta::Attribute class or a subclass of Class::Meta::Attribute. It returns a reference to the attribute get accessor created by the call to \*(C`build()\*(C', and usable as an indirect attribute accessor by the Class::Meta::Attribute \*(C`get()\*(C' method.</p><p>Although you should never call this method directly, subclasses of Class::Meta::Type may need to override its behavior.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CUSTOM DATA TYPES</h2>
        <div class="sectioncontent">
<p>Creating custom data types can be as simple as calling \*(C`add()\*(C' and passing in the name of a class for the \*(C`check\*(C' parameter. This is especially useful when you just need to create attributes that contain objects of a particular type, and you're happy with the accessors that Class::Meta will create for you. For example, if you needed a data type for a DateTime object, you can set it up\*(--complete with validation of the data type, like this:</p><p>  my $type = Class::Meta::Type-&gt;add(       key   =&gt; &apos;datetime&apos;,       check =&gt; &apos;DateTime&apos;,       desc  =&gt; &apos;DateTime object&apos;,       name  =&gt; &apos;DateTime Object&apos;   );</p><p>From then on, you can create attributes of the type \*(L"datetime\*(R" without any further work. If you wanted to use affordance accessors, you'd simply add the requisite \*(C`builder\*(C' attribute:</p><p>  my $type = Class::Meta::Type-&gt;add(       key     =&gt; &apos;datetime&apos;,       check   =&gt; &apos;DateTime&apos;,       builder =&gt; &apos;affordance&apos;,       desc    =&gt; &apos;DateTime object&apos;,       name    =&gt; &apos;DateTime Object&apos;   );</p><p>The same goes for using semi-affordance accessors.</p><p>Other than that, adding other data types is really a matter of the judicious use of the \*(C`check\*(C' parameter. Ultimately, all attributes are scalar values. Whether they adhere to a particular data type depends entirely on the validation code references passed via \*(C`check\*(C'. For example, if you wanted to create a \*(L"range\*(R" attribute with only the allowed values 1-5, you could do it like this:</p><p>  my $range_chk = sub {       my $value = shift;       die "Value is not a number" unless $value =~ /^[1..5]$/;   };</p><p>  my $type = Class::Meta::Type-&gt;add(       key   =&gt; &apos;range&apos;,       check =&gt; $range_chk,       desc  =&gt; &apos;Pick a number between 1 and 5&apos;,       name  =&gt; &apos;Range (1-5)&apos;   );</p><p>Of course, the above value validator will throw an exception with the line number from which \*(C`die\*(C' is called. Even better is to use Carp to throw an error with the file and line number of the client code:</p><p>  my $range_chk = sub {       my $value = shift;       return if $value =~ /^[1..5]$/;       require Carp;       our @CARP_NOT = qw(Class::Meta::Attribute);       Carp::croak("Value is not a number");   };</p><p>The \*(C`our @CARP_NOT\*(C' line prevents the context from being thrown from within Class::Meta::Attribute, which is useful if you make use of that class' \*(C`set()\*(C' method.</p><h3>Custom Accessor Building</h3>
<p>Class::Meta also allows you to craft your own accessors. Perhaps you'd prefer to use a StudlyCaps affordance accessor standard. In that case, you'll need to create your own module that builds accessors. I recommend that you study Class::Meta::AccessorBuilder and Class::Meta::AccessorBuilder::Affordance before taking on creating your own.</p><p>Custom accessor building modules must have three functions.</p><p><em>build</em></p><p>The \*(C`build()\*(C' function creates and installs the actual accessor methods in a class. It should expect the following arguments:</p><p>  sub build {       my ($class, $attribute, $create, @checks) = @_;       # ...   }</p><p>These are: The name of the class into which the accessors are to be installed. A Class::Meta::Attribute object representing the attribute for which accessors are to be created. Use it to determine what types of accessors to create (read-only, write-only, or read/write, class or object), and to add checks for required constraints and accessibility (if the attribute is private, trusted, or protected). The value of the \*(C`create\*(C' parameter passed to Class::Meta::Attribute when the attribute object was created. Use this argument to determine what type of accessor(s) to create. See Class::Meta::Attribute for the possible values for this argument. A list of one or more data type validation code references. Use these in any accessors that set attribute values to check that the new value has a valid value.</p><p>See Class::Meta::AccessorBuilder for example attribute creation functions.</p><p><em>build_attr_get and build_attr_set</em></p><p>The \*(C`build_attr_get()\*(C' and \*(C`build_attr_set()\*(C' functions take a single argument, a Class::Meta::Attribute object, and return code references that either represent the corresponding methods, or that call the appropriate accessor methods to get and set an attribute, respectively. The code references will be used by Class::Meta::Attribute's \*(C`get()\*(C' and \*(C`set()\*(C' methods to get and set attribute values. Again, see Class::Meta::AccessorBuilder for examples before creating your own.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>This module is stored in an open GitHub repository &lt;http://github.com/theory/class-meta/&gt;. Feel free to fork and contribute!</p><p>Please file bug reports via GitHub Issues &lt;http://github.com/theory/class-meta/issues/&gt; or by sending mail to bug-Class-Meta@rt.cpan.org &lt;mailto:bug-Class-Meta@rt.cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David E. Wheeler &lt;david@justatheory.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Class::Meta::Type&hellip;</h2>
        <div class="sectioncontent">
<p>Other classes of interest within the Class::Meta distribution include:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta
  </dt>
  <dd>
    <p>This class contains most of the documentation you need to get started with Class::Meta.</p>
  </dd>
  <dt>
    Class::Meta::Attribute
  </dt>
  <dd>
    <p>This class manages Class::Meta class attributes, all of which are based on data types.</p>
  </dd>

</dl>
<p>These modules provide some data types to get you started:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::Types::Perl
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Types::String
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Types::Boolean
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Types::Numeric
  </dt>
  <dd>
    
  </dd>

</dl>
<p>The modules that Class::Meta comes with for creating accessors are:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::AccessorBuilder
  </dt>
  <dd>
    <p>Standard Perl-style accessors.</p>
  </dd>
  <dt>
    Class::Meta::AccessorBuilder::Affordance
  </dt>
  <dd>
    <p>Affordance accessors\*(--that is, explicit and independent get and set accessors.</p>
  </dd>
  <dt>
    Class::Meta::AccessorBuilder::SemiAffordance
  </dt>
  <dd>
    <p>Semi-affordance accessors\*(--that is, independent get and set accessors with an explicit set accessor.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2002-2011, David E. Wheeler. Some Rights Reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::Meta::Method.3pm.html"><span aria-hidden="true">&larr;</span> Class::Meta::Method.3pm: Class::meta class method introspection</a></li>
   <li class="next"><a href="Class::Meta::Types::Boolean.3pm.html">Class::Meta::Types::Boolean.3pm: Boolean data types <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

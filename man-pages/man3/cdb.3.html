<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cdb: Constant database library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Constant database library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="cdb (3) manual">
  <meta name="twitter:description" content="Constant database library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcdb-dev-cdb-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/cdb.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="cdb (3) manual" />
  <meta property="og:description" content="Constant database library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcdb-dev-cdb-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">cdb<small> (3)</small></h1>
        <p class="lead">Constant database library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/cdb.3.html">
      <span itemprop="name">cdb: Constant database library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcdb-dev/">
      <span itemprop="name">libcdb-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/cdb.3.html">
      <span itemprop="name">cdb: Constant database library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSYS</h2>
        <div class="sectioncontent">

<pre>
 #include &lt;cdb.h&gt;
 cc ... -lcdb
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>cdb</strong> is a library to create and access Constant DataBase files. File stores (key,value) pairs and used to quickly find a value based on a given key.  Cdb files are create-once files, that is, once created, file cannot be updated but recreated from scratch -- this is why database is called <em>constant</em>. Cdb file is optimized for quick access.  Format of such file described in <a href="../man5/cdb.5.html"><strong>cdb</strong>(5)</a> manpage.  This manual page corresponds to version <strong>0.78</strong> of <strong>tinycdb</strong> package.</p><p>Library defines two non-interlaced interfaces: for querying existing cdb file data (read-only mode) and for creating such a file (almost write-only).  Strictly speaking, those modes allows very limited set of opposite operation as well (i.e. in query mode, it is possible to update key's value).</p><p>All routines in this library are thread-safe as no global data used, except of <em>errno</em> variable for error indication.</p><p><strong>cdb</strong> datafiles may be moved between systems safely, since format does not depend on architecture.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUERY MODE</h2>
        <div class="sectioncontent">
<p>There are two query modes available.  First uses a structure that represents a cdb database, just like <strong>FILE</strong> structure in stdio library, and another works with plain filedescriptor. First mode is more sophisticated and flexible, and usually somewhat faster.  It uses <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a> internally.  This mode may look more "natural" or object-oriented compared to second one.</p><p>The following routines works with any mode:</p>
<pre>
unsigned <strong>cdb_unpack</strong>(<em>buf</em>)
   const unsigned char <em>buf</em>[4];
</pre>
<p>helper routine to convert 32-bit integer from internal representation to machine format.  May be used to handle application integers in a portable way.  There is no error return.</p><h3>Query Mode 1</h3>
<p>All query operations in first more deals with common data structure, <strong>struct cdb</strong>, associated with an open file descriptor.  This structure is opaque to application.</p><p>The following routines exists for accessing <strong>cdb</strong> database:</p>
<pre>
int <strong>cdb_init</strong>(<em>cdbp</em>, <em>fd</em>)
   struct cdb *<em>cdbp</em>;
   int <em>fd</em>;
</pre>
<p>initializes structure given by <em>cdbp</em> pointer and associates it with opened file descriptor <em>fd</em>.  Memory allocation for structure itself if needed and file open operation should be done by application.  File <em>fd</em> should be opened at least read-only, and should be seekable.  Routine returns 0 on success or negative value on error.</p>
<pre>
void <strong>cdb_free</strong>(<em>cdbp</em>)
   struct cdb *<em>cdbp</em>;
</pre>
<p>frees internal resources held by structure.  Note that this routine does <em>not</em> closes a file.</p>
<pre>
int <strong>cdb_fileno</strong>(<em>cdbp</em>)
  const struct cdb *<em>cdbp</em>;
</pre>
<p>returns filedescriptor associated with cdb (as was passed to <strong>cdb_init</strong>()).</p>
<pre>
int <strong>cdb_read</strong>(<em>cdbp</em>, <em>buf</em>, <em>len</em>, <em>pos</em>)
int <strong>cdb_readdata</strong>(<em>cdbp</em>, <em>buf</em>, <em>len</em>, <em>pos</em>)
int <strong>cdb_readkey</strong>(<em>cdbp</em>, <em>buf</em>, <em>len</em>, <em>pos</em>)
   const struct cdb *<em>cdbp</em>;
   void *<em>buf</em>;
   unsigned <em>len</em>;
   unsigned <em>pos</em>;
</pre>
<p>reads a data from cdb file, starting at position <em>pos</em> of length <em>len</em>, placing result to <em>buf</em>.  This routine may be used to get actual value found by <strong>cdb_find</strong>() or other routines that returns position and length of a data.  Returns 0 on success or negative value on error. Routines <strong>cdb_readdata</strong>() and <strong>cdb_readkey</strong>() are shorthands to read current (after e.g. <strong>cdb_find</strong>()) data and key respectively, using <strong>cdb_read</strong>().</p>
<pre>
const void *<strong>cdb_get</strong>(<em>cdbp</em>, <em>len</em>, <em>pos</em>)
const void *<strong>cdb_getdata</strong>(<em>cdbp</em>)
const void *<strong>cdb_getkey</strong>(<em>cdbp</em>)
   const struct cdb *<em>cdbp</em>;
   unsigned <em>len</em>;
   unsigned <em>pos</em>;
</pre>
<p>Internally, cdb library uses memory-mmaped region to access the on-disk database.  <strong>cdb_get</strong>() allows to access internal memory in a way similar to <strong>cdb_read</strong>() but without extra copying and buffer allocation.  Returns pointer to actual data on success or NULL on error (position points to outside of the database). Routines <strong>cdb_getdata</strong>() and <strong>cdb_getkey</strong>() are shorthands to access current (after e.g. <strong>cdb_find</strong>()) data and key respectively, using <strong>cdb_get</strong>().</p>
<pre>
int <strong>cdb_find</strong>(<em>cdbp</em>, <em>key</em>, <em>klen</em>)
unsigned <strong>cdb_datapos</strong>(<em>cdbp</em>)
unsigned <strong>cdb_datalen</strong>(<em>cdbp</em>)
unsigned <strong>cdb_keypos</strong>(<em>cdbp</em>)
unsigned <strong>cdb_keylen</strong>(<em>cdbp</em>)
   struct cdb *<em>cdbp</em>;
   const void *<em>key</em>;
   unsigned <em>klen</em>;
</pre>
<p>attempts to find a key given by (<em>key</em>,<em>klen</em>) parameters. If key exists in database, routine returns 1 and places position and length of value associated with this key to internal fields inside <em>cdbp</em> structure, to be accessible by <strong>cdb_datapos</strong>(<em>cdbp</em>) and <strong>cdb_datalen</strong>(<em>cdbp</em>) routines.  If key is not in database, <strong>cdb_find</strong>() returns 0.  On error, negative value is returned. Data pointers (available via <strong>cdb_datapos</strong>() and <strong>cdb_datalen</strong>()) gets updated only in case of successful search.  Note that using <strong>cdb_find</strong>() it is possible to lookup only <em>first</em> record with a given key.</p>
<pre>
int <strong>cdb_findinit(</strong><em>cdbfp</em>, <em>cdbp</em>, <em>key</em>, <em>klen</em>)
int <strong>cdb_findnext</strong>(<em>cdbfp</em>)
  struct cdb_find *<em>cdbfp</em>;
  const struct cdb *<em>cdbp</em>;
  const void *<em>key</em>;
  unsigned <em>klen</em>;
</pre>
<p>sequential-find routines that used separate structure.  It is possible to have more than one record with the same key in a database, and these routines allows to enumerate all them. <strong>cdb_findinit</strong>() initializes search structure pointed to by <em>cdbfp</em>.  It will return negative value on error or non-negative value on success.  <strong>cdb_findnext</strong>() attempts to find next (first when called right after <strong>cdb_findinit</strong>()) matching key, setting value position and length in <em>cdbfp</em> structure.  It will return positive value if given key was found, 0 if there is no more such key(s), or negative value on error.  To access value position and length after successful call to <strong>cdb_findnext</strong>() (when it returned positive result), use <strong>cdb_datapos</strong>(<em>cdbp</em>) and <strong>cdb_datalen</strong>(<em>cdbp</em>) routines.  It is error to continue using <strong>cdb_findnext</strong>() after it returned 0 or error condition (<strong>cdb_findinit</strong>() should be called again).  Current data pointers (available via <strong>cdb_datapos</strong>() and <strong>cdb_datalen</strong>()) gets updated only on successful search.</p>
<pre>
void <strong>cdb_seqinit</strong>(<em>cptr</em>, <em>cdbp</em>)
int <strong>cdb_seqnext</strong>(<em>cptr</em>, <em>cdbp</em>)
  unsigned *<em>cptr</em>;
  struct cdb *<em>cdbp</em>;
</pre>
<p>sequential enumeration of all records stored in cdb file. <strong>cdb_seqinit</strong>() initializes access current data pointer <em>cptr</em> to point before first record in a cdb file. <strong>cdb_seqnext</strong>() updates data pointers in <em>cdbp</em> to point to the next record and updates <em>cptr</em>, returning positive value on success, 0 on end of data condition and negative value on error.  Current record will be available after successful operation using <strong>cdb_datapos</strong>(<em>cdbp</em>) and <strong>cdb_datalen</strong>(<em>cdbp</em>) (for the data) and <strong>cdb_keypos</strong>(<em>cdbp</em>) and <strong>cdb_keylen</strong>(<em>cdbp</em>) (for the key of the record). Data pointers gets updated only in case of successful operation.</p>
<h3>Query Mode 2</h3>
<p>In this mode, one need to open a <strong>cdb</strong> file using one of standard system calls (such as <a href="../man2/open.2.html"><strong>open</strong>(2)</a>) to obtain a filedescriptor, and then pass that filedescriptor to cdb routines. Available methods to query a cdb database using only a filedescriptor include:</p>
<pre>
int <strong>cdb_seek</strong>(<em>fd</em>, <em>key</em>, <em>klen</em>, <em>dlenp</em>)
  int <em>fd</em>;
  const void *<em>key</em>;
  unsigned <em>klen</em>;
  unsigned *<em>dlenp</em>;
</pre>
<p>searches a cdb database (as pointed to by <em>fd</em> filedescriptor) for a key given by (<em>key</em>, <em>klen</em>), and positions file pointer to start of data associated with that key if found, so that next read operation from this filedescriptor will read that value, and places length of value, in bytes, to variable pointed to by <em>dlenp</em>. Returns positive value if operation was successful, 0 if key was not found, or negative value on error.  To read the data from a cdb file, <strong>cdb_bread</strong>() routine below can be used.</p>
<pre>
int <strong>cdb_bread</strong>(<em>fd</em>, <em>buf</em>, <em>len</em>)
  int <em>fd</em>;
  void *<em>buf</em>;
  int <em>len</em>;
</pre>
<p>reads data from a file (as pointed to by <em>fd</em> filedescriptor) and places <em>len</em> bytes from this file to a buffer pointed to by <em>buf</em>. Returns 0 if exactly <em>len</em> bytes was read, or a negative value in case of error or end-of-file.  This routine ignores interrupt errors (EINTR). Sets errno variable to <strong>EIO</strong> in case of end-of-file condition (when there is less than <em>len</em> bytes available to read).</p>
<h3>Notes</h3>
<p>Note that <em>value</em> of any given key may be updated in place by another value of the same size, by writing to file at position found by <strong>cdb_find</strong>() or <strong>cdb_seek</strong>().  However one should be very careful when doing so, since write operation may not succeed in case of e.g. power failure, thus leaving corrupted data.  When database is (re)created, one can guarantee that no incorrect data will be written to database, but not with inplace update.  Note also that it is not possible to update any key or to change length of value.</p>
<h3></h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREATING MODE</h2>
        <div class="sectioncontent">
<p><strong>cdb</strong> database file should usually be created in two steps: first, temporary file created and written to disk, and second, that temporary file is renamed to permanent place.  Unix <a href="../man2/rename.2.html"><strong>rename</strong>(2)</a> call is atomic operation, it removes destination file if any AND renaes another file in one step.  This way it is guaranteed that readers will not see incomplete database.  To prevent multiple simultaneous updates, locking may also be used.</p><p>All routines used to create <strong>cdb</strong> database works with <strong>struct cdb_make</strong> object that is opaque to application. Application may assume that <strong>struct cdb_make</strong> has at least the same member(s) as published in <strong>struct cdb</strong> above.</p>
<pre>
int <strong>cdb_make_start</strong>(<em>cdbmp</em>, <em>fd</em>)
   struct cdb_make *<em>cdbmp</em>;
   int <em>fd</em>;
</pre>
<p>initializes structure to create a database.  File <em>fd</em> should be opened read-write and should be seekable.  Returns 0 on success or negative value on error.</p>
<pre>
int <strong>cdb_make_add</strong>(<em>cdbmp</em>, <em>key</em>, <em>klen</em>, <em>val</em>, <em>vlen</em>)
   struct cdb_make *<em>cdbmp</em>;
   const void *<em>key</em>, *<em>val</em>;
   unsigned <em>klen</em>, <em>vlen</em>;
</pre>
<p>adds record with key (<em>key</em>,<em>klen</em>) and value (<em>val</em>,<em>vlen</em>) to a database.  Returns 0 on success or negative value on error.  Note that this routine does not checks if given key already exists, but <strong>cdb_find</strong>() will not see second record with the same key.  It is not possible to continue building a database if <strong>cdb_make_add</strong>() returned error indicator.</p>
<pre>
int <strong>cdb_make_finish</strong>(<em>cdbmp</em>)
   struct cdb_make *<em>cdbmp</em>;
</pre>
<p>finalizes database file, constructing all needed indexes, and frees memory structures.  It does <em>not</em> closes filedescriptor. Returns 0 on success or negative value on error.</p>
<pre>
int <strong>cdb_make_exists</strong>(<em>cdbmp</em>, <em>key</em>, <em>klen</em>)
   struct cdb_make *<em>cdbmp</em>;
   const void *<em>key</em>;
   unsigned <em>klen</em>;
</pre>
<p>This routine attempts to find given by (<em>key</em>,<em>klen</em>) key in a not-yet-complete database.  It may significantly slow down the whole process, and currently it flushes internal buffer to disk on every call with key those hash value already exists in db.  Returns 0 if such key doesn't exists, 1 if it is, or negative value on error. Note that database file should be opened read-write (not write-only) to use this routine.  If <strong>cdb_make_exists</strong>() returned error, it may be not possible to continue constructing database.</p>
<pre>
int <strong>cdb_make_find</strong>(<em>cdbmp</em>, <em>key</em>, <em>klen</em>, <em>mode</em>)
   struct cdb_make *<em>cdbmp</em>;
   const void *<em>key</em>;
   unsigned <em>klen</em>;
   int <em>mode</em>;
</pre>
<p>This routine attempts to find given by (<em>key</em>,<em>klen</em>) key in the database being created.  If the given key is already exists, it an action specified by <em>mode</em> will be performed:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>CDB_FIND</strong>
  </dt>
  <dd>
    <p>checks whenever the given record is already in the database.</p>
  </dd>
  <dt>
    <strong>CDB_FIND_REMOVE</strong>
  </dt>
  <dd>
    <p>removes all matching records by re-writing the database file accordingly.</p>
  </dd>
  <dt>
    <strong>CDB_FIND_FILL0</strong>
  </dt>
  <dd>
    <p>fills all matching records with zeros and removes them from index so that the records in question will not be findable with <strong>cdb_find</strong>().  This is faster than CDB_FIND_REMOVE, but leaves zero "gaps" in the database. Lastly inserted records, if matched, are always removed.</p>
  </dd>

</dl>
<p>If no matching keys was found, routine returns 0.  In case at least one record has been found/removed, positive value will be returned.  On error, negative value will be returned and <strong>errno</strong> will be set appropriately.  When <strong>cdb_make_find</strong>() returned negative value in case of error, it is not possible to continue constructing the database.</p><p><strong>cdb_make_exists</strong>() is the same as calling <strong>cdb_make_find</strong>() with <em>mode</em> set to CDB_FIND.</p>
<pre>
int <strong>cdb_make_put</strong>(<em>cdbmp</em>, <em>key</em>, <em>klen</em>, <em>val</em>, <em>vlen</em>, <em>mode</em>)
   struct cdb_make *<em>cdbmp</em>;
   const void *<em>key</em>, *<em>val</em>;
   unsigned <em>klen</em>, <em>vlen</em>;
   int <em>mode</em>;
</pre>
<p>This is a somewhat combined <strong>cdb_make_exists</strong>() and <strong>cdb_make_add</strong>() routines.  <em>mode</em> argument controls how repeated (already existing) keys will be treated:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>CDB_PUT_ADD</strong>
  </dt>
  <dd>
    <p>no duplicate checking will be performed.  This mode is the same as <strong>cdb_make_add</strong>() routine does.</p>
  </dd>
  <dt>
    <strong>CDB_PUT_REPLACE</strong>
  </dt>
  <dd>
    <p>If the key already exists, it will be removed from the database before adding new key,value pair.  This requires moving data in the file, and can be quite slow if the file is large. All matching old records will be removed this way.  This is the same as calling <strong>cdb_make_find</strong>() with CDB_FIND_REMOVE <em>mode</em> argument followed by calling <strong>cdb_make_add</strong>().</p>
  </dd>
  <dt>
    <strong>CDB_PUT_REPLACE0</strong>
  </dt>
  <dd>
    <p>If the key already exists and it isn't the last record in the file, old record will be zeroed out before adding new key,value pair. This is alot faster than CDB_PUT_REPLACE, but some extra data will still be present in the file.  The data -- old record -- will not be accessible by normal searches, but will appear in sequential database traversal.  This is the same as calling <strong>cdb_make_find</strong>() with CDB_FIND_FILL0 <em>mode</em> argument followed by <strong>cdb_make_add</strong>().</p>
  </dd>
  <dt>
    <strong>CDB_PUT_INSERT</strong>
  </dt>
  <dd>
    <p>add key,value pair only if such key does not exists in a database. Note that since query (see query mode above) will find first added record, this mode is somewhat useless (but allows to reduce database size in case of repeated keys).  This is the same as calling <strong>cdb_make_exists</strong>(), followed by <strong>cdb_make_add</strong>() if the key was not found.</p>
  </dd>
  <dt>
    <strong>CDB_PUT_WARN</strong>
  </dt>
  <dd>
    <p>add key,value pair unconditionally, but also check if this key already exists.  This is equivalent of <strong>cdb_make_exists</strong>() to check existence of the given key, unconditionally followed by <strong>cdb_make_add</strong>().</p>
  </dd>

</dl>
<p>If any error occurred during operations, the routine will return negative integer and will set global variable <strong>errno</strong> to indicate reason of failure.  In case of successful operation and no duplicates found, routine will return 0.  If any duplicates has been found or removed (which, in case of CDB_PUT_INSERT mode, indicates that the new record was not added), routine will return positive value.  If an error occurred and <strong>cdb_make_put</strong>() returned negative error, it is not possible to continue database construction process.</p><p>As with <strong>cdb_make_exists</strong>() and <strong>cdb_make_find</strong>(), usage of this routine with any but CDB_PUT_ADD mode can significantly slow down database creation process, especially when <em>mode</em> is equal to CDB_PUT_REPLACE0.</p>
<pre>
void <strong>cdb_pack</strong>(<em>num</em>, <em>buf</em>)
   unsigned <em>num</em>;
   unsigned char <em>buf</em>[4];
</pre>
<p>helper routine that used internally to convert machine integer <em>n</em> to internal form to be stored in datafile.  32-bit integer is stored in 4 bytes in network byte order.  May be used to handle application data. There is no error return.</p>
<pre>
unsigned <strong>cdb_hash</strong>(<em>buf</em>, <em>len</em>)
   const void *<em>buf</em>;
   unsigned <em>len</em>;
</pre>
<p>helper routine that calculates cdb hash value of given bytes. CDB hash function is</p>
<pre>
  hash[n] = (hash[n-1] + (hash[n-1] &lt;&lt; 5)) ^ buf[n]
</pre>
<p>starting with</p>
<pre>
  hash[-1] = 5381
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p><strong>cdb</strong> library may set <strong>errno</strong> to following on error:</p>
<dl class='dl-vertical'>
  <dt>
    EPROTO
  </dt>
  <dd>
    <p>database file is corrupted in some way</p>
  </dd>
  <dt>
    EINVAL
  </dt>
  <dd>
    <p>the same as EPROTO above if system lacks EPROTO constant</p>
  </dd>
  <dt>
    EINVAL
  </dt>
  <dd>
    <p><em>flag</em> argument for <strong>cdb_make_put</strong>() is invalid</p>
  </dd>
  <dt>
    EEXIST
  </dt>
  <dd>
    <p><em>flag</em> argument for <strong>cdb_make_put</strong>() is CDB_PUT_INSERT, and key already exists</p>
  </dd>
  <dt>
    ENOMEM
  </dt>
  <dd>
    <p>not enough memory to complete operation (<strong>cdb_make_finish</strong> and <strong>cdb_make_add</strong>)</p>
  </dd>
  <dt>
    EIO
  </dt>
  <dd>
    <p>set by <strong>cdb_bread</strong> and <strong>cdb_seek</strong> if a cdb file is shorter than expected or corrupted in some other way.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Note: in all examples below, error checking is not shown for brewity.</p><h3>Query Mode</h3>

<pre>
 int fd;
 struct cdb cdb;
 char *key, *data;
 unsigned keylen, datalen;

 /* opening the database */
 fd = open(filename, O_RDONLY);
 cdb_init(&cdb, fd);
 /* initialize key and keylen here */

 /* single-record search. */
 if (cdb_find(&cdb, key, keylen) &gt; 0) {
   datalen = cdb_datalen(&cdb);
   data = malloc(datalen + 1);
   cdb_read(&cdb, data, datalen, cdb_datapos(&cdb));
   data[datalen] = '&#92;0';
   printf("key=%s data=%s&#92;n", key, data);
   free(data);
 }
 else
   printf("key=%s not found&#92;n", key);

 /* multiple record search */
 struct cdb_find cdbf;
 int n;
 cdb_findinit(&cdbf, &cdb, key, keylen);
 n = 0;
 while(cdb_findnext(&cdbf) &gt; 0) {
   datalen = cdb_datalen(&cdb);
   data = malloc(datalen + 1);
   cdb_read(&cdb, data, datalen, cdb_datapos(&cdb));
   data[datalen] = '&#92;0';
   printf("key=%s data=%s&#92;n", key, data);
   free(data);
   ++n;
 }
 printf("key=%s %d records found&#92;n", n);

 /* sequential database access */
 unsigned pos;
 int n;
 cdb_seqinit(&pos, &cdb);
 n = 0;
 while(cdb_seqnext(&pos, &cdb) &gt; 0) {
   keylen = cdb_keylen(&cdb);
   key = malloc(keylen + 1);
   cdb_read(&cdb, key, keylen, cdb_keypos(&cdb));
   key[keylen] = '&#92;0';
   datalen = cdb_datalen(&cdb);
   data = malloc(datalen + 1);
   cdb_read(&cdb, data, datalen, cdb_datapos(&cdb));
   data[datalen] = '&#92;0';
   ++n;
   printf("record %n: key=%s data=%s&#92;n", n, key, data);
   free(data); free(key);
 }
 printf("total records found: %d&#92;n", n);

 /* close the database */
 cdb_free(&cdb);
 close(fd);

 /* simplistic query mode */
 fd = open(filename, O_RDONLY);
 if (cdb_seek(fd, key, keylen, &datalen) &gt; 0) {
   data = malloc(datalen + 1);
   cdb_bread(fd, data, datalen);
   data[datalen] = '&#92;0';
   printf("key=%s data=%s&#92;n", key, data);
 }
 else
   printf("key=%s not found&#92;n", key);
 close(fd);
</pre>

<h3>Create Mode</h3>

<pre>
 int fd;
 struct cdb_make cdbm;
 char *key, *data;
 unsigned keylen, datalen;

 /* initialize the database */
 fd = open(filename, O_RDWR|O_CREAT|O_TRUNC, 0644);
 cdb_make_start(&cdbm, fd);

 while(have_more_data()) {
   /* initialize key and data */
   if (cdb_make_exists(&cdbm, key, keylen) == 0)
     cdb_make_add(&cdbm, key, keylen, data, datalen);
   /* or use cdb_make_put() with appropriate flags */
 }

 /* finalize and close the database */
 cdb_make_finish(&cdbm);
 close(fd);
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO cdb&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man5/cdb.5.html"><strong>cdb</strong>(5)</a>, <a href="../man1/cdb.1.html"><strong>cdb</strong>(1)</a>, <a href="../man3/dbm.3.html"><strong>dbm</strong>(3)</a>, db(3), <a href="../man2/open.2.html"><strong>open</strong>(2)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>The <strong>tinycdb</strong> package written by Michael Tokarev &lt;mjt@corpit.ru&gt;, based on ideas and shares file format with original cdb library by Dan Bernstein.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>Public domain.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="cdawson.3.html"><span aria-hidden="true">&larr;</span> cdawson.3: Dawson's integral</a></li>
   <li class="next"><a href="cdb_datalen.3.html">cdb_datalen.3: Get length of data <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

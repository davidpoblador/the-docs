<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Boulder::Stream: Read and write tag/value data from an input stream</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Read and write tag/value data from an input stream">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Boulder::Stream (3pm) manual">
  <meta name="twitter:description" content="Read and write tag/value data from an input stream">
  <meta name="twitter:image" content="https://www.carta.tech/images/libboulder-perl-Boulder::Stream-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Boulder::Stream.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Boulder::Stream (3pm) manual" />
  <meta property="og:description" content="Read and write tag/value data from an input stream" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libboulder-perl-Boulder::Stream-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Boulder::Stream<small> (3pm)</small></h1>
        <p class="lead">Read and write tag/value data from an input stream</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Boulder::Stream.3pm.html">
      <span itemprop="name">Boulder::Stream: Read and write tag/value data from an input stream</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libboulder-perl/">
      <span itemprop="name">libboulder-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Boulder::Stream.3pm.html">
      <span itemprop="name">Boulder::Stream: Read and write tag/value data from an input stream</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
   #!/bin/perl
   # Read a series of People records from STDIN.
   # Add an "Eligible" tag to all those whose
   # Age &gt;= 35 and Friends list includes "Fred"
   use Boulder::Stream;

   # filestream way:
   my $stream = Boulder::Stream-&gt;newFh;
   while ( my $record = &lt;$stream&gt; ) {
      next unless $record-&gt;Age &gt;= 35;
      my @friends = $record-&gt;Friends;
      next unless grep {$_ eq &apos;Fred&apos;} @friends;

      $record-&gt;insert(Eligible =&gt; &apos;yes&apos;);
      print $stream $record;
    }

    # object oriented way:
   my $stream = Boulder::Stream-&gt;new;
   while (my $record = $stream-&gt;get ) {
      next unless $record-&gt;Age &gt;= 35;
      my @friends = $record-&gt;Friends;
      next unless grep {$_ eq &apos;Fred&apos;} @friends;

      $record-&gt;insert(Eligible =&gt; &apos;yes&apos;);
      print $stream $record;
    }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Boulder::Stream provides stream-oriented access to Boulder \s-1IO\s0 hierarchical tag/value data.  It can be used in a magic tied filehandle mode, as shown in the synopsis, or in object-oriented mode. Using tied filehandles, Stone objects are read from input using the standard &lt;&gt; operator.  Stone objects printed to the tied filehandle appear on the output stream in Boulder format.</p><p>By default, data is read from the magic \s-1ARGV\s0 filehandle (\s-1STDIN\s0 or a list of files provided on the command line) and written to \s-1STDOUT\s0. This can be changed to the filehandles of your choice.</p><h3>Pass through behavior</h3>
<p>When using the object-oriented form of Boulder::Stream, tags which aren't specifically requested by the <em>get()</em> method are passed through to output unchanged.  This allows pipes of programs to be constructed easily. Most programs will want to put the tags back into the boulder stream once they're finished, potentially adding their own.  Of course some programs will want to behave differently.  For example, a database query program will generate but not read a <strong>boulderio</strong> stream, while a report generator will read but not write the stream.</p><p>This convention allows the following type of pipe to be set up:</p><p>  query_database | find_vector | find_dups | &#92;     | blast_sequence | pick_primer | mail_report</p><p>If all the programs in the pipe follow the conventions, then it will be possible to interpose other programs, such as a repetitive element finder, in the middle of the pipe without disturbing other components.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SKELETON BOULDER PROGRAM</h2>
        <div class="sectioncontent">
<p>Here is a skeleton example.</p><p>   #!/bin/perl    use Boulder::Stream;</p><p>   my $stream = Boulder::Stream-&gt;newFh;</p><p>   while ( my $record = &lt;$stream&gt; ) {       next unless $record-&gt;Age &gt;= 35;       my @friends = $record-&gt;Friends;       next unless grep {$_ eq &apos;Fred&apos;} @friends;</p><p>      $record-&gt;insert(Eligible =&gt; &apos;yes&apos;);       print $stream $record;     }</p><p>The code starts by creating a <strong>Boulder::Stream</strong> object to handle the I/O.  It reads from the stream one record at a time, returning a Stone object.  We recover the <em>Age</em> and <em>Friends</em> tags, and continue looping unless the Age is greater or equal to 35, and the list of Friends contains \*(L"Fred\*(R".  If these criteria match, then we insert a new tag named Eligible and print the record to the stream. The output may look like this:</p><p>  Name=Janice   Age=36   Eligible=yes   Friends=Susan   Friends=Fred   Friends=Ralph   =   Name=Ralph   Age=42   Eligible=yes   Friends=Janice   Friends=Fred   =   Name=Susan   Age=35   Eligible=yes   Friends=Susan   Friends=Fred   =</p><p>Note that in this case only records that meet the criteria are echoed to standard output.  The object-oriented version of the program looks like this:</p><p>   #!/bin/perl    use Boulder::Stream;</p><p>   my $stream = Boulder::Stream-&gt;new;</p><p>   while ( my $record = $stream-&gt;get(&apos;Age&apos;,&apos;Friends&apos;) ) {       next unless $record-&gt;Age &gt;= 35;       my @friends = $record-&gt;Friends;       next unless grep {$_ eq &apos;Fred&apos;} @friends;</p><p>      $record-&gt;insert(Eligible =&gt; &apos;yes&apos;);       $stream-&gt;put($record);     }</p><p>The <em>get()</em> method is used to fetch Stones containing one or more of the indicated tags.  The <em>put()</em> method is used to send the result to standard output.  The pass-through behavior might produce a set of records like this one:</p><p>  Name=Janice   Age=36   Eligible=yes   Friends=Susan   Friends=Fred   Friends=Ralph   =   Name=Phillip   Age=30   =   Name=Ralph   Age=42   Eligible=yes   Friends=Janice   Friends=Fred   =   Name=Barbara   Friends=Agatha   Friends=Janice   =   Name=Susan   Age=35   Eligible=yes   Friends=Susan   Friends=Fred   =</p><p>Notice that there are now two records (\*(L"Phillip\*(R" and \*(L"Barbara\*(R") that do not contain the Eligible tag.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Boulder::Stream METHODS</h2>
        <div class="sectioncontent">
<p>The <strong></strong><strong>new()</strong><strong></strong> method creates a new <strong>Boulder::Stream</strong> object.  You can provide input and output filehandles. If you leave one or both undefined <strong></strong><strong>new()</strong><strong></strong> will default to standard input or standard output. You are free to use files, pipes, sockets, and other types of file handles.  You may provide the filehandle arguments as bare words, globs, or glob refs. You are also free to use the named argument style shown in the second heading. Returns a filehandle object tied to a Boulder::Stream object.  Reads on the filehandle perform a <em>get()</em>.  Writes invoke a <em>put()</em>.</p><p>To retrieve the underlying Boulder::Stream object, call Perl's built-in <em>tied()</em> function:</p><p>  $stream = tied $fh; Every time <em>get()</em> is called, it will return a new Stone object.  The Stone will be created from the input stream, using just the tags provided in the argument list.  Pass no tags to receive whatever tags are present in the input stream.</p><p>If none of the tags that you specify are in the current boulder record, you will receive an empty <strong>Stone</strong>.  At the end of the input stream, you will receive <strong>undef</strong>.</p><p>If called in an array context, <em>get()</em> returns a list of all stones from the input stream that contain one or more of the specified tags. Identical to get(&gt;, but the name is longer. Write a <strong>Stone</strong> to the output filehandle. Identical to <em>put()</em>, but the name is longer.</p><h3>Useful State Variables in a \fBBoulder::Stream\fP</h3>
<p>Every Boulder::Stream has several state variables that you can adjust. Fix them in this fashion:</p><p>        $a = new Boulder::Stream;         $a-&gt;{delim}=&apos;:&apos;;         $a-&gt;{record_start}=&apos;[&apos;;         $a-&gt;{record_end}=&apos;]&apos;;         $a-&gt;{passthru}=undef;</p><ul>
<li><p>delim This is the delimiter character between tags and values, \*(L"=\*(R" by default.</p></li><li><p>record_start This is the start of nested record character, \*(L"{\*(R" by default.</p></li><li><p>record_end This is the end of nested record character, \*(L"}\*(R" by default.</p></li><li><p>passthru This determines whether unrecognized tags should be passed through from the input stream to the output stream.  This is 'true' by default.  Set it to undef to override this behavior.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Because the delim, record_start and record_end characters in the <strong>Boulder::Stream</strong> object are used in optimized (once-compiled) pattern matching, you cannot change these values once <em>get()</em> has once been called.  To change the defaults, you must create the Boulder::Stream, set the characters, and only then begin reading from the input stream.  For the same reason, different Boulder::Stream objects cannot use different delimiters.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Lincoln D. Stein &lt;lstein@cshl.org&gt;, Cold Spring Harbor Laboratory, Cold Spring Harbor, \s-1NY\s0.  This module can be used and distributed on the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Boulder::Stream&hellip;</h2>
        <div class="sectioncontent">
<p>Boulder, Boulder::Blast, Boulder::Genbank, Boulder::Medline, Boulder::Unigene, Boulder::Omim, Boulder::SwissProt</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Boulder::Store.3pm.html"><span aria-hidden="true">&larr;</span> Boulder::Store.3pm: Simple persistent storage for stone tag/value objects</a></li>
   <li class="next"><a href="Boulder::String.3pm.html">Boulder::String.3pm: Read and write tag/value data from a string. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::Filter::Sort: Sax filter for sorting elements in xml</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Sax filter for sorting elements in xml">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::Filter::Sort (3pm) manual">
  <meta name="twitter:description" content="Sax filter for sorting elements in xml">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-filter-sort-perl-XML::Filter::Sort-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::Filter::Sort.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::Filter::Sort (3pm) manual" />
  <meta property="og:description" content="Sax filter for sorting elements in xml" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-filter-sort-perl-XML::Filter::Sort-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::Filter::Sort<small> (3pm)</small></h1>
        <p class="lead">Sax filter for sorting elements in xml</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Filter::Sort.3pm.html">
      <span itemprop="name">XML::Filter::Sort: Sax filter for sorting elements in xml</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-filter-sort-perl/">
      <span itemprop="name">libxml-filter-sort-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Filter::Sort.3pm.html">
      <span itemprop="name">XML::Filter::Sort: Sax filter for sorting elements in xml</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use XML::Filter::Sort;
  use XML::SAX::Machines qw( :all );

  my $sorter = XML::Filter::Sort-&gt;new(
    Record  =&gt; &apos;person&apos;,
    Keys    =&gt; [
                 [ &apos;lastname&apos;,  &apos;alpha&apos;, &apos;asc&apos; ],
                 [ &apos;firstname&apos;, &apos;alpha&apos;, &apos;asc&apos; ],
                 [ &apos;@age&apos;,      &apos;num&apos;,   &apos;desc&apos;]
               ],
  );

  my $filter = Pipeline( $sorter =&gt; &#92;*STDOUT );

  $filter-&gt;parse_file(&#92;*STDIN);
</pre>
<p>Or from the command line:</p><p>  xmlsort</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is a \s-1SAX\s0 filter for sorting 'records' in \s-1XML\s0 documents (including documents larger than available memory).  The \*(C`xmlsort\*(C' utility which is included with this distribution can be used to sort an \s-1XML\s0 file from the command line without writing Perl code (see \*(C`perldoc xmlsort\*(C').</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>These examples assume that you will create an XML::Filter::Sort object and use it in a SAX::Machines pipeline (as in the synopsis above).  Of course you could use the object directly by hooking up to a \s-1SAX\s0 generator and a \s-1SAX\s0 handler but such details are omitted from the sample code.</p><p>When you create an XML::Filter::Sort object (with the \*(C`new()\*(C' method), you must use the 'Record' option to identify which elements you want sorted.  The simplest way to do this is to simply use the element name, eg:</p><p>  my $sorter = XML::Filter::Sort-&gt;new( Record  =&gt; &apos;colour&apos; );</p><p>Which could be used to transform this \s-1XML:\s0</p><p>  &lt;options&gt;     &lt;colour&gt;red&lt;/colour&gt;     &lt;colour&gt;green&lt;/colour&gt;     &lt;colour&gt;blue&lt;/colour&gt;   &lt;options&gt;</p><p>to this:</p><p>  &lt;options&gt;     &lt;colour&gt;blue&lt;/colour&gt;     &lt;colour&gt;green&lt;/colour&gt;     &lt;colour&gt;red&lt;/colour&gt;   &lt;/options&gt;</p><p>You can define a more specific path to the record by adding a prefix of element names separated by forward slashes, eg:</p><p>  my $sorter = XML::Filter::Sort-&gt;new( Record  =&gt; &apos;hair/colour&apos; );</p><p>which would only sort &lt;colour&gt; elements contained directly within a &lt;hair&gt; element (and would therefore leave our sample document above unchanged).  A path which starts with a slash is an 'absolute' path and must specify all intervening elements from the root element to the record elements.</p><p>A record element may contain other elements.  The order of the record elements may be changed by the sorting process but the order of any child elements within them will not.</p><p>The default sort uses the full text of each 'record' element and uses an alphabetic comparison.  You can use the 'Keys' option to specify a list of elements within each record whose text content should be used as sort keys. You can also use this option to specify whether the keys should be compared alphabetically or numerically and whether the resulting order should be ascending or descending, eg:</p><p>  my $sorter = XML::Filter::Sort-&gt;new(     Record  =&gt; &apos;person&apos;,     Keys    =&gt; [                  [ &apos;lastname&apos;,  &apos;alpha&apos;, &apos;asc&apos;  ],                  [ &apos;firstname&apos;, &apos;alpha&apos;, &apos;asc&apos;  ],                  [ &apos;@age&apos;,      &apos;alpha&apos;, &apos;desc&apos; ],                ]   );</p><p>Given this record ...</p><p>    &lt;person age=&apos;35&apos;&gt;       &lt;firstname&gt;Aardvark&lt;/firstname&gt;       &lt;lastname&gt;Zebedee&lt;/lastname&gt;     &lt;/person&gt;</p><p>The above code would use 'Zebedee' as the first (primary) sort key, 'Aardvark' as the second sort key and the number 35 as the third sort key.  In this case, records with the same first and last name would be sorted from oldest to youngest.</p><p>As with the 'record' path, it is possible to specify a path to the sort key elements (or attributes).  To make a path relative to the record element itself, use './' at the start of the path.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Record =&gt; 'path string'
  </dt>
  <dd>
    <p>A simple path string defining which elements should be treated as 'records' to be sorted (see \*(L"\s-1PATH\s0 \s-1SYNTAX\s0\*(R").  Elements which do not match this path will not be altered by the filter.  Elements which do match this path will be re-ordered depending on their contents and the value of the Keys option. When a record element is re-ordered, it takes its leading whitespace with it. Only lists of contiguous record elements will be sorted.  A list of records which has a 'foreign body' (a non-record element, non-whitespace text, a comment or a processing instruction) between two elements will be treated as two separate lists and each will be sorted in isolation of the other.</p>
  </dd>
  <dt>
    Keys =&gt; [ [ 'path string', comparator, order ], ... ]
  </dt>
  <dd>
    
  </dd>
  <dt>
    Keys =&gt; 'delimited string'
  </dt>
  <dd>
    <p>This option specifies which parts of the records should be used as sort keys. The first form uses a list-of-lists syntax.  Each key is defined using a list of three elements:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>The 'path string' defines the path to an element or an attribute whose text contents should be used as the value of the sort key (see \*(L"\s-1PATH\s0 \s-1SYNTAX\s0\*(R").</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>The 'comparator' defines how these values should be compared.  This can be the string 'alpha' for alphabetic, the string 'num' for numeric or a reference to a subroutine taking two parameters and returning -1, 0 or 1 (similar to the standard Perl sort function but without the $a, $b magic). This item is optional and defaults to 'alpha'.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>The 'order' should be 'asc' for ascending or 'desc' for descending and if omitted, defaults to 'asc'.</p>
  </dd>

</dl>
<p>You may prefer to define the Keys using a delimited string rather than a list of lists.  Keys in the string should be separated by either newlines or semicolons and the components of a key should be separated by whitespace or commas.  It is not possible to define a subroutine reference comparator using the string syntax.</p>
  </dd>
  <dt>
    IgnoreCase =&gt; 1
  </dt>
  <dd>
    <p>Enabling this option will make sort comparisions case-insensitive (rather than the default case-sensitive).</p>
  </dd>
  <dt>
    NormaliseKeySpace =&gt; 1
  </dt>
  <dd>
    <p>The sort key values for each record will be the text content of the child elements specified using the Keys option (above).  If you enable this option, leading and trailing whitespace will be stripped from the keys and each internal run of spaces will be collapsed to a single space.  The default value for this option is off for efficiency. Note: The contents of the record are not affected by this setting - merely the copy of the data that is used in the sort comparisons.</p>
  </dd>
  <dt>
    KeyFilterSub =&gt; coderef
  </dt>
  <dd>
    <p>You can also supply your own custom 'fix-ups' by passing this option a reference to a subroutine.  The subroutine will be called once for each record and will be passed a list of the key values for the record.  The routine must return the same number of elements each time it is called, but this may be less than the number of values passed to it.  You might use this option to combine multiple key values into one (eg: using sprintf). Note: You can enable both the NormaliseKeySpace and the KeyFilterSub options - space normalisation will occur first.</p>
  </dd>
  <dt>
    TempDir =&gt; 'directory path'
  </dt>
  <dd>
    <p>This option serves two purposes: it enables disk buffering rather than the default memory buffering and it allows you to specify where on disk the data should be buffered.  Disk buffering will be slower than memory buffering, so don't ask for it if you don't need it.  For more details, see \*(L"\s-1IMPLEMENTATION\s0\*(R". Note: It is safe to specify the same temporary directory path for multiple instances since each will create a uniquely named subdirectory (and clean it up afterwards).</p>
  </dd>
  <dt>
    MaxMem =&gt; bytes
  </dt>
  <dd>
    <p>The disk buffering mode actually sorts chunks of records in memory before saving them to disk.  The default chunk size is 10 megabytes.  You can use this option to specify an alternative chunk size (in bytes) which is more attuned to your available resources (more is better).  A suffix of 'K' or 'M' is recognised as kilobytes or megabytes respectively. If you have not enabled disk buffering (using 'TempDir'), the MaxMem option has no effect.  Attempting to sort a large document using only memory buffering may result in Perl dying with an 'out of memory' error.</p>
  </dd>
  <dt>
    SkipIgnorableWS
  </dt>
  <dd>
    <p>If your \s-1SAX\s0 parser can do validation and generates <em>ignorable_whitespace()</em> events, you can enable this option to discard these events.  If you leave this option at it's default value (implying you want the whitespace), the events will be translated to <em>characters()</em> events.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PATH SYNTAX</h2>
        <div class="sectioncontent">
<p>A simple element path syntax is used in two places:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>with the 'Record' option to define which elements should be sorted</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>with the 'Keys' option to define which parts of each record should be used as sort keys.</p>
  </dd>

</dl>
<p>In each case you can use a just an element name, or a list of element names separated by forward slashes.  eg:</p><p>  Record =&gt; &apos;ul/li&apos;,   Keys   =&gt; &apos;name&apos;</p><p>If a 'Record' path begins with a '/' then it will be anchored at the document root.  If a 'Keys' path begins with './' then it is anchored at the current record element.  Unanchored paths can match at any level.</p><p>A 'Keys' path can include an attribute name prefixed with an '@' symbol, eg:</p><p>  Keys   =&gt; &apos;./@href&apos;</p><p>Each element or attribute name can include a namespace \s-1URI\s0 prefix in curly braces, eg:</p><p>  Record =&gt; &apos;{http://www.w3.org/1999/xhtml}li&apos;</p><p>If you do not include a namespace prefix, all elements with the specified name will be matched, regardless of any namespace \s-1URI\s0 association they might have.</p><p>If you include an empty namespace prefix (eg: &apos;{}li&apos;) then only records which do not have a namespace association will be matched.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTATION</h2>
        <div class="sectioncontent">
<p>In order to arrange records into sorted order, this module uses buffering.  It does not need to buffer the whole document, but for any sequence of records within a document, all records must be buffered.  Unless you specify otherwise, the records will be buffered in memory.  The memory requirements are similar to \s-1DOM\s0 implementations - 10 to 50 times the character count of the source \s-1XML\s0.  If your documents are so large that you would not process them with a \s-1DOM\s0 parser then you should enable disk buffering.</p><p>If you enable disk buffering, sequences of records will be assembled into 'chunks' of approximately 10 megabytes (this value is configurable).  Each chunk will be sorted and saved to disk.  At the end of the record sequence, all the sorted chunks will be merged and written out as \s-1SAX\s0 events.</p><p>The memory buffering mode represents each record an a <strong>XML::Filter::Sort::Buffer</strong> object and uses <strong>XML::Filter::Sort::BufferMgr</strong> objects to manage the buffers.  For details of the internals, see XML::Filter::Sort::BufferMgr.</p><p>The disk buffering mode represents each record an a <strong>XML::Filter::Sort::DiskBuffer</strong> object and uses <strong>XML::Filter::Sort::DiskBufferMgr</strong> objects to manage the buffers.  For details of the internals, see XML::Filter::Sort::DiskBufferMgr.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p><em>ignorable_whitespace()</em> events shouldn't be translated to normal <em>characters()</em> events - perhaps in a later release they won't be.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::Filter::Sort&hellip;</h2>
        <div class="sectioncontent">
<p><strong>XML::Filter::Sort</strong> requires XML::SAX::Base and plays nicely with XML::SAX::Machines.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2002-2005 Grant McLean &lt;grantm@cpan.org&gt;</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::Filter::SAXT.3pm.html"><span aria-hidden="true">&larr;</span> XML::Filter::SAXT.3pm: Replicates sax events to several sax event handlers</a></li>
   <li class="next"><a href="XML::Filter::Sort::Buffer.3pm.html">XML::Filter::Sort::Buffer.3pm: Implementation class used by xml::filter::sort <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

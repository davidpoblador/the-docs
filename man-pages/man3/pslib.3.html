<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pslib: Library to create postscript files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Library to create postscript files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pslib (3) manual">
  <meta name="twitter:description" content="Library to create postscript files">
  <meta name="twitter:image" content="https://www.carta.tech/images/pslib-dev-pslib-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pslib.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pslib (3) manual" />
  <meta property="og:description" content="Library to create postscript files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/pslib-dev-pslib-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pslib<small> (3)</small></h1>
        <p class="lead">Library to create postscript files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pslib.3.html">
      <span itemprop="name">pslib: Library to create postscript files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/pslib-dev/">
      <span itemprop="name">pslib-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pslib.3.html">
      <span itemprop="name">pslib: Library to create postscript files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>pslib is a library to create PostScript files with a set of about 50 functions for line drawing, text output, page handling, etc. It is very similar to other libraries like panda, cpdf or pdflib which produce PDF. pslib can to a certain degree replace those libraries if the PostScript file is converted to PDF with ghostscripts excellent pdf writer. The results achieved with pslib can be even better when it comes to text output, because it supports kerning, ligatures and hyphenation.</p><p>pslib is a C-library but there are bindings for Perl, Python, Tcl and PHP. This documentation will only describe the functions of the C-library, though most of what is said here can be applied to the other language bindings. The PHP extension of pslib is documented in PEAR. The extension is called ps.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GETTING STARTED</h2>
        <div class="sectioncontent">
<p>Programs which want to use pslib will have to include the header file libps/pslib.h and link against libps. Before doing any document creation the library should be initialized with <a href="../man3/PS_boot.3.html"><strong>PS_boot</strong>(3)</a></strong>. It will set the locale and selects the messages in your language as defined by the environment variable LC_ALL. Your locale settings will affect hyphenation which uses <a href="../man3/isalpha.3.html"><strong>isalpha</strong>(3)</a></strong> and <a href="../man3/tolower.3.html"><strong>tolower</strong>(3)</a></strong> to prepare the word for hyphenation. German umlauts will be filtered out if the locale is not set properly. The library should be finalized by <a href="../man3/PS_shutdown.3.html"><strong>PS_shutdown</strong>(3)</a></strong>.</p><p>A PostScript document is represented by a pointer to PSDoc. Such a document can be created with <a href="../man3/PS_new.3.html"><strong>PS_new</strong>(3)</a></strong> and destroyed with <a href="../man3/PS_delete.3.html"><strong>PS_delete</strong>(3)</a></strong>. <a href="../man3/PS_new.3.html"><strong>PS_new</strong>(3)</a></strong> returns a pointer to PSDoc. You can handle several documents at the same time. The following example will do the basic preparation without creating a document on the disk.</p>
<pre>
...
#include &lt;libps/pslib.h&gt;

main(int argc, char *argv[]) {
	PSDoc *psdoc;

	PS_boot();
	psdoc = PS_new();
	PS_delete(psdoc);
	PS_shutdown();
}

</pre>
<p>In order to actually create a PostScript document on disk you will have to call</p><p><strong></strong></p><p>int PS_open_file (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>filename</em><strong>);</strong></p><p>or</p><p><strong></strong></p><p>int PS_open_fp (PSDoc *<em>psdoc</em><strong>, FILE *</strong><em>fp</em><strong>);</strong></p><p><a href="../man3/PS_open_file.3.html"><strong>PS_open_file</strong>(3)</a></strong> will create a new file with the given file name, while <a href="../man3/PS_open_fp.3.html"><strong>PS_open_fp</strong>(3)</a></strong> will use an already open file. Both require a pointer to PSDoc.</p><p>If the document shall not be created on disk but in memory, which can be very handy in web application, one can use</p><p><strong></strong></p><p>int PS_open_mem (PSDoc *<em>psdoc</em><strong>, (*writeproc) </strong><em>(PSDoc *p, void *data, size_t size)</em><strong>);</strong></p><p>The second parameter is a function which is called instead of pslib's own output function.</p><p>Extending the previous example with one of the former three functions to open a document will at least create an initial empty PostScript document. It has to be closed with <a href="../man3/PS_close.3.html"><strong>PS_close</strong>(3)</a></strong>. <a href="../man3/PS_close.3.html"><strong>PS_close</strong>(3)</a></strong> will only close the file if it was opened by <a href="../man3/PS_open_file.3.html"><strong>PS_open_file</strong>(3)</a></strong>.</p>
<pre>
...
#include &lt;libps/pslib.h&gt;

main(int argc, char *argv[]) {
	PSDoc *psdoc;

	PS_boot();
	psdoc = PS_new();
	PS_open_file(psdoc, "test.ps");
	PS_close(psdoc);
	PS_delete(psdoc);
	PS_shutdown();
}

</pre>
<p>There are more sophisticated funktions to start a new PostScript document. They are used when error handling and memory management shall be controlled by the calling application. Check the manual pages <a href="../man3/PS_new2.3.html"><strong>PS_new2</strong>(3)</a></strong> and <strong>PS_new3</strong>(3)</strong> for a detailed description or read the section about memory management and error handler below..</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PAGE HANDLING</h2>
        <div class="sectioncontent">
<p>A PostScript document contains one or more pages. pslib provides the function</p><p><strong></strong></p><p>int PS_begin_page (PSDoc *<em>psdoc</em><strong>, float </strong><em>width</em><strong>, float </strong><em>height</em><strong>);</strong></p><p>and</p><p><strong></strong></p><p>int PS_end_page (PSDoc *<em>psdoc</em><strong>);</strong></p><p>to start a new page with the given size in points and to end a page. All functions that draw any visible output will only work within a page. The page size has no meaning for the PostScript interpreter but will be used by ghostscript or Acrobat Distiller to set the page size in the PDF document. Some PostScript viewer also use the size to resize the output window.</p><p>Starting the first page of a document will internally end the PostScript header. This may have impact on resource handling. For more information see the section about resource handling.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COORDINATE SYSTEM, SCOPE</h2>
        <div class="sectioncontent">
<p>PostScript defines a coordinate system with its origin in the lower left corner of a page. Its base unit is point which is 1/72 of an inch. Unless the coordinate system is scaled all values will be expected in point.</p><p>pslib provides many functions which may not be called at any time. For example, drawing and text output functions may only be called within a page, path constrution functions may only be called within a path. pslib defines so called scopes which are checked before executing a function. Those scopes are prolog, document, page, pattern, template, path and object. If for example, one tries to output text outside of a page or within a path, then an error will be issued.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DRAWING, PATH CONSTRUCTION</h2>
        <div class="sectioncontent">
<p>PostScript does not have any functions to draw a line directly but uses a two pass mechanism. First a path is constructed which is then drawn (stroken). The path can also be used for filling an area or to clip further drawing. A path must not be a continues line, it may consist of several subpaths.</p><p>Each path is started with</p><p><strong></strong></p><p>void PS_moveto (PSDoc *<em>psdoc</em><strong>, float </strong><em>x</em><strong>, float </strong><em>y</em><strong>);</strong></p><p>If this function is called within a path, it will just start a new subpath. The path can be constructed with one of the following functions.</p><p><strong></strong></p><p>void PS_lineto (PSDoc *<em>psdoc</em><strong>, float </strong><em>x</em><strong>, float </strong><em>y</em><strong>);</strong></p><p><strong></strong></p><p>void PS_rect (PSDoc *<em>psdoc</em><strong>, float </strong><em>x</em><strong>, float </strong><em>y</em><strong>, float </strong><em>width</em><strong>, float </strong><em>height</em><strong>);</strong></p><p><strong></strong></p><p>void PS_circle (PSDoc *<em>psdoc</em><strong>, float </strong><em>x</em><strong>, float </strong><em>y</em><strong>, float </strong><em>radius</em><strong>);</strong></p><p><strong></strong></p><p>void PS_arc (PSDoc *<em>psdoc</em><strong>, float </strong><em>x</em><strong>, float </strong><em>y</em><strong>, float </strong><em>radius</em><strong>, float </strong><em>alpha</em><strong>, float </strong><em>beta</em><strong>);</strong></p><p><strong></strong></p><p>void PS_arcn (PSDoc *<em>psdoc</em><strong>, float </strong><em>x</em><strong>, float </strong><em>y</em><strong>, float </strong><em>radius</em><strong>, float </strong><em>alpha</em><strong>, float </strong><em>beta</em><strong>);</strong></p><p><strong></strong></p><p>void PS_curveto (PSDoc *<em>psdoc</em><strong>, float </strong><em>x1</em><strong>, float </strong><em>y1</em><strong>, float </strong><em>x2</em><strong>, float </strong><em>y2</em><strong>, float </strong><em>x3</em><strong>, float </strong><em>y3</em><strong>);</strong></p><p>Once a path is constructed it can be optionally closed by</p><p><strong></strong></p><p>void PS_closepath (PSDoc *<em>psdoc</em><strong>);</strong></p><p>Closing a path means to add a segment from the last point to the starting point of the path. It is helpful if an area is to be filled. In most cases the path is used for drawing which is done with</p><p><strong></strong></p><p>void PS_stroke (PSDoc *<em>psdoc</em><strong>);</strong></p><p>In such a case you would not want to close the path. As already mentioned a path can also be filled or even both with the functions.</p><p><strong></strong></p><p>void PS_fill (PSDoc *<em>psdoc</em><strong>);</strong></p><p><strong></strong></p><p>void PS_fill_stroke (PSDoc *<em>psdoc</em><strong>);</strong></p><p><a href="../man3/PS_fill_stroke.3.html"><strong>PS_fill_stroke</strong>(3)</a></strong> does first fill and than stroke a path. This is important to realize because the stroken line may cover parts of the filled area, depending on how wide it is.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TEXT OUTPUT</h2>
        <div class="sectioncontent">
<p>Text output is definetly one of the strongest parts of pslib. pslib supports kerning, protusion, ligatures and hyphenation. All of it is in a wide range customizeable by parameters. The hyphenation algorithmn is based on the one used by TeX without the ability to take a whole paragraph into acount.</p><p>Text output requires at least the Adobe font metric files, even for the standard PostScript fonts. pslib has not, like other libraries, the font metrics for the standard fonts compiled in. They are freely available in the internet. If the font is to be embedded into the document, then the font outline (.pfb file) is also needed.</p><p>Additional files are needed for more sophisticated text output. It will be explained later in this documentation.</p><p>Before being able to output any text a font has to be loaded with</p><p><strong></strong></p><p>int PS_findfont (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>fontname</em><strong>, const char *</strong><em>encoding</em><strong>, int </strong><em>embed</em><strong>);</strong></p><p>It returns a unique id for the font. The fontname is the filename of the Adobe font metrics file without the extension .afm. If the font shall be embedded into the document, then the last parameter must be set to 1 and the file <em>fontname</em>.pfb must be present.</p><p>The <em>encoding</em> specifies the font encoding to be used in the PostScript document. It defaults to TeXBase1, which is a reasonable set of glyphs covering most western languages, when the empty string or NULL is passed. The special encoding 'builtin' stands for the encoding as provided by the font itself. It is usually AdobeStandardEncoding which is a smaller set of glyphs than TeXBase1. If unsure leave the encoding parameter empty.</p><p>Calling <a href="../man3/PS_findfont.3.html"><strong>PS_findfont</strong>(3)</a></strong> is a sensitive matter. Thought it may be called in almost every scope it is highly recommended to call it either within a page or before the first page (within the prolog). Especially when the font is to be embedded or uses a non default encoding. This limitation has to be enforced in order to be able to extract certain pages from the document without corruption. Programs like <strong>psselect</strong> extract a page by taking the prolog of the PostScript document and the selected page. Resources, like fonts, not being part of the page or the prolog will not be included into the resulting document and using those resources will provoke errors. pslib will output a warning in case of potential problems.</p><p><strong></strong></p><p>int PS_setfont (PSDoc *<em>psdoc</em><strong>, int </strong><em>fontid</em><strong>, float </strong><em>size</em><strong>);</strong></p><p>sets the font which was loaded with <a href="../man3/PS_findfont.3.html"><strong>PS_findfont</strong>(3)</a></strong> in a given size. After calling this function everything is prepared to output text with one of the following functions. Each text output function uses kerning pairs and ligatures if available.</p><p><strong></strong></p><p>int PS_show (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>text</em><strong>);</strong></p><p>outputs text at the current text position and moves the x position to the end of the text. If text is to be output at a certain position on the page the function</p><p><strong></strong></p><p>int PS_show_xy (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>text</em><strong>, float </strong><em>x</em><strong>, float </strong><em>y</em><strong>);</strong></p><p>can be used. Both functions also exist in a version which requires the length of the string as the third parameter. The are called <a href="../man3/PS_show2.3.html"><strong>PS_show2</strong>(3)</a></strong> and <a href="../man3/PS_show_xy2.3.html"><strong>PS_show_xy2</strong>(3)</a></strong>.</p><p>The functions mentioned so far will print all text into one line. If one would like to wrap a longer text into a box, the function</p><p><strong></strong></p><p>int PS_show_boxed (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>text</em><strong>, float </strong><em>left</em><strong>, float </strong><em>bottom</em><strong>, float </strong><em>width</em><strong>, float </strong><em>height</em><strong>, const char *</strong><em>hmode</em><strong>, const char *</strong><em>feature</em><strong>);</strong></p><p>should be usesd. It breaks the text into lines of length <em>width</em> and fills the box until there is no space left. The function returns the number of remaining chars which did not fit into the box. This number can be used to create a second, third, ... box for the remaining text. Text can be left and/or right justified or centered depending on the parameter <em>hmode</em>. Hyphenation is turned off by default, because it needs to be set up before it can be used.</p><p>Once again, working with fonts is an error prune issue, because it is important at what position in the document the fonts are loaded. At a rule of thumb you should load fonts which are used on several pages of the document before the first page, and fonts only used on a single page within that page. For a more detailed discussion see the section on resource handling.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HYPHENATION, KERNING, LIGATURES, PROTUSION</h2>
        <div class="sectioncontent">
<p>pslib's advanced text output features cover hyphenation, kerning, ligatures and protusion. Kerning and ligatures are turned on by default and will be used if the current font supports it. Some ligatures are built into pslib, just in case the font has the glyphs but misses the command to build the ligature. Those ligatures are fi, fl, ff, ffi, and ffl. Both ligatures and kerning can be turned off by setting the parameter 'ligature' respectively 'kerning' to false. pslib automatically inserts a ligature if the character sequence of that ligature is found. If a ligature is not to be used then its character sequence must be broken up with a broken bar character. Ligatures will never be used if charspacing has a value unequal to zero.</p><p>If a font provides more ligatures as those mentioned before, they are usually at places not conform to the Adobe Standard Encoding. There glyph name is often the name of the glyph supposed to be at that position in the Adobe Standard Encoding. pslib can utilize those ligatures when a so called encoding file is supplied. The encoding file contains an font encoding vector and definitions for extra ligatures. An encoding file is very similar to encoding files used by <strong>dvips</strong> and usually found in <em>/usr/share/texmf/dvips/base</em>. Adding a ligature requires a line like the following:</p>
<pre>
% LIGKERN char1 char2 =: ligature ;

</pre>
<p>If 'char1' is followed by 'char2' they will be both replaced by the glyph 'ligature'. This replacement may not be used exclusively for ligatures like 'fi' or 'ff' but for any combination of characters. Quite common is a hyphen followed by a hyphen, which is replaced by an endash.</p><p>In order to set up hyphenation you will first need a hyphenation dictionary for your language. Since pslib uses a well know hyphenation algorithmn used not just by TeX, but also by openoffice and scribus, one can take the dictionary from those programs. If you have scribus installed on your system, you will find the dictionaries for many languages in <em>/usr/lib/scribus/dicts</em>.</p><p>Hyphenation is turned on when the parameter 'hyphenation' is set to true and the parameter 'hyphendict' contains the file name of the hyphenation dictionary.</p><p>Protusion is an advanced method to improve the appearance of text margins. It is only used by the function <a href="../man3/PS_show_boxed.3.html"><strong>PS_show_boxed</strong>(3)</a></strong> if the horizontal mode is set to 'justify'. A margin may not look straight if lines end or begin with characters with a 'light' appearance like a period, hyphen or comma. Those characters should reach into the margin to make it look straight. pslib tries to read a so called protusion file whenever a font is loaded with <a href="../man3/PS_findfont.3.html"><strong>PS_findfont</strong>(3)</a></strong>. If it cannot be found a warning is issued. The file must be named 'fontname.pro' and contains a line for each character with protusion information. Finding reasonable protusion values can be a tedious work.</p>
<pre>
N hyphen ; M 0 650 ;
N comma ; M 0 650 ;
N period ; M 0 650 ;
N semicolon ; M 0 500 ;

</pre>
<p>The syntax is similar to an .afm file. The protusion values for the left and right margin are the last two numbers.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOADING FILES</h2>
        <div class="sectioncontent">
<p>All files which are being loaded by pslib are searched for in the current directory and the 'SearchPath'. 'SearchPath' is a parameter which is set by <a href="../man3/PS_set_parameter.3.html"><strong>PS_set_parameter</strong>(3)</a></strong>. <a href="../man3/PS_set_parameter.3.html"><strong>PS_set_parameter</strong>(3)</a></strong> can be called multiple times to add several directories to the search path. Function which are affected by the search path are <a href="../man3/PS_findfont.3.html"><strong>PS_findfont</strong>(3)</a></strong> for loading .afm, .pfb, and .enc files, <a href="../man3/PS_include_file.3.html"><strong>PS_include_file</strong>(3)</a></strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESOURCE HANDLING</h2>
        <div class="sectioncontent">
<p>Resources in pslib are fonts, patterns, templates, spot colors, and images. Templates and images are treated equally. A resource is usally loaded or created and can be used repeatingly afterwards. Resource handling is somewhat sensitve, in terms of the position in the document where they are loaded or created. Plain PostScript does not care about where a resource is defined as long as it is known before it is used. PostScript documents are not always printed but quite often displayed on the screen or processed by software. Most software which reads PostScript documents does not just interpret the PostScript code but also so called Document Structuring Conventions (DSC). Such instructions are helpful to provide further information about the document and to partition the document into sections like a prolog and pages. Programs evaluating those instructions can easily determine the page size, the creator, title or author, the number of pages and can jump straight to a certain page without interpreting the PostScript code before that page. Especially isolating certain pages requires the document to be created stringly following the DSC. This means that all resource which are used through out the document must be either created on each page where they are used (not very sensible if the resource is used more than once) or within the prolog right before the first page. pslib will put everything before the first page into the prolog. On the other side the prolog may not contain any PostScript code that does output something. pslib makes sure this rule is not violated.</p><p>In practice the above rules do not apply equally to all resource but can be seen as a general rule of thumb. Fonts can under certain circumstances be loaded at any time (see the section on 'Text output').</p><p>Please note, that starting from 0.4.5 of pslib images are treated as resources as well, though this behaviour can be turned of by setting `imagereuse' to `false' if existing code shows unexpected side effects.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMAGES</h2>
        <div class="sectioncontent">
<p>Placing images on a page in the PostScript document is similar to font handling. First the image has to be loaded with</p><p><strong></strong></p><p>int PS_open_image_file (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>type</em><strong>, const char *</strong><em>filename</em><strong>, const char *</strong><em>stringparam</em><strong>, int </strong><em>intparam</em><strong>);</strong></p><p>or</p><p><strong></strong></p><p>int PS_open_image (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>type</em><strong>, const char *</strong><em>source</em><strong>, const char *</strong><em>data</em><strong>, long </strong><em>length</em><strong>, int </strong><em>width</em><strong>, int </strong><em>height</em><strong>, int </strong><em>components</em><strong>, int </strong><em>bpc</em><strong>, const char *</strong><em>params</em><strong>);</strong></p><p>and than it can be placed on the page with the function</p><p><strong></strong></p><p>int PS_place_image (PSDoc *<em>psdoc</em><strong>, int </strong><em>imageid</em><strong>, float </strong><em>x</em><strong>, float </strong><em>y</em><strong>, float </strong><em>scale</em><strong>);</strong></p><p>Once an image is not needed anymore it should be closed to free the resources.</p><p><strong></strong></p><p>int PS_close_image (PSDoc *<em>psdoc</em><strong>, int </strong><em>imageid</em><strong>);</strong></p><p>Until version 0.4.4 of pslib images are not real resources. Each call of <a href="../man3/PS_place_image.3.html"><strong>PS_place_image</strong>(3)</a></strong> wrote the complete image into the PostScript file. Starting with version 0.4.5 images are by default reusable objects which are saved once into the PostScript file (with <a href="../man3/PS_open_image.3.html"><strong>PS_open_image</strong>(3)</a></strong> or <a href="../man3/PS_open_image_file.3.html"><strong>PS_open_image_file</strong>(3)</a></strong>) and replayed as often as desired with <a href="../man3/PS_place_image.3.html"><strong>PS_place_image</strong>(3)</a></strong>. This behaviour can be turned off if `imagereuse' is set to `false'. Reusing images usually has the advantages of smaller file size, faster processing of the PostScript file and the possibility to place images into templates which was not allowed till version 0.4.4. If an image is placed into a template and is not needed anymore, it can be closed right after ending the template.</p><p>Please note, that everything sayed about resources becomes true for reusable images, too.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TEMPLATES</h2>
        <div class="sectioncontent">
<p>Templates are a bit like images created within the document itself. Their big advantage is its reusability on any page thoughout the document by simply referencing them. This saves a lot of disk space if the template is placed many times. They are often used for logos or headers which are to be placed on each page. A template is started with the function</p><p><strong></strong></p><p>int PS_begin_template (PSDoc *<em>psdoc</em><strong>, float </strong><em>width</em><strong>, float </strong><em>height</em><strong>);</strong></p><p>Like a page or an image a template has a boundig box. Within that box almost any operation for drawing, text output, etc. can be called. Everything beyond the bounding box is clipped. A template is ended and ready for use with</p><p><strong></strong></p><p>int PS_end_template (PSDoc *<em>psdoc</em><strong>);</strong></p><p>Each template has its own id which was returned by <a href="../man3/PS_begin_template.3.html"><strong>PS_begin_template</strong>(3)</a></strong>. This id is like an image id and can be passed to <a href="../man3/PS_place_image.3.html"><strong>PS_place_image</strong>(3)</a></strong>. This makes a template identical to an image in terms of handling. Any call of <a href="../man3/PS_place_image.3.html"><strong>PS_place_image</strong>(3)</a></strong> will only place a reference to the template into the document which results in a small document size.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COLORS</h2>
        <div class="sectioncontent">
<p>pslib supports all colorspaces available in PostScript including spot colors. Opposed to the PostScript color modell which knows just one current color, pslib distinguishes between a stroke and fill color. Colors are set with</p><p><strong></strong></p><p>int PS_setcolor (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>type</em><strong>, const char *</strong><em>colorspace</em><strong>, float </strong><em>c1</em><strong>, float </strong><em>c2</em><strong>, float </strong><em>c3</em><strong>, float </strong><em>c4</em><strong>);</strong></p><p><em>type</em> determines if the fill, stroke or both (fillstroke) colors are set by the function. The colorspace can be any of 'gray', 'rgb', 'cmyk', 'spot', or 'pattern'. The colorspace 'pattern' is somewhat special and will be discussed in the next section. The float parameters contain the actual values of the color. Depending on the colorspace not all parameters will be evaluated. Spot colors need to be created before with</p><p><strong></strong></p><p>int PS_makespotcolor (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>name</em><strong>, float</strong><em>reserved</em><strong>);</strong></p><p>The name of the spot color can be any string value, thought one will usually take the official name of the spot color, e.g. PANTONE 114 C. Each spot color has a color in an alternative colorspace which is used when the spot color itself cannot be used. This is always the case when the PostScript file is viewed on a computer screen or printed by an ink printer. If the PostScript document is separated for professional printing, the alternative color has no meaning. The alternative color is taken from the current fill color. This means, that you have to call <a href="../man3/PS_setcolor.3.html"><strong>PS_setcolor</strong>(3)</a></strong> and set the current fill color before calling <a href="../man3/PS_makespotcolor.3.html"><strong>PS_makespotcolor</strong>(3)</a></strong>. <a href="../man3/PS_makespotcolor.3.html"><strong>PS_makespotcolor</strong>(3)</a></strong> can only handle fill colors in the colorspace 'gray', 'rgb', or 'cmyk'.</p><p><a href="../man3/PS_makespotcolor.3.html"><strong>PS_makespotcolor</strong>(3)</a></strong> returns the id of the spot color which is passed as parameter <em>c1</em> to <a href="../man3/PS_setcolor.3.html"><strong>PS_setcolor</strong>(3)</a></strong>. All spot colors used in the document should be defined before the first page, otherwise they will not be included into the list of custom colors within the document comments section at the beginning of the file.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COLOR SEPARATION</h2>
        <div class="sectioncontent">
<p>Printing a document sometimes requires to separate colors because certain printers print each color separately. Color separation is often done on the multi color document by the printing company. However, pslib can separate colors very easily by setting the value 'separationcolor' on a value from 1 to 4, depending on the color you would like to separate (1=cyan, 2=magenta, 3=yellow, 4=black). This has to be done before creating a page. The resulting document will contain only those parts in the separated color. Consequently, one has to create four identical pages, each called with a different value for 'separationcolor'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PATTERNS</h2>
        <div class="sectioncontent">
<p>Filling an area can be done with a single color or a self designed pattern. Such a pattern can be any drawing. Actually, it can be everything which can be put on a page. If a pattern is used for filling it is repeatingly placed in horizontal and vertical direction with a given distance. Pattern are started with</p><p><strong></strong></p><p>int PS_begin_pattern (PSDoc *<em>psdoc</em><strong>, float </strong><em>width</em><strong>, float </strong><em>height</em><strong>, float </strong><em>xstep</em><strong>, float </strong><em>ystep</em><strong>, int </strong><em>painttype</em><strong>);</strong></p><p>and ended with</p><p><strong></strong></p><p>int PS_end_pattern (PSDoc *<em>psdoc</em><strong>);</strong></p><p>Within those two functions almost any output operation can be used for creating the pattern. Once a pattern is created, it can be used like a color for filling. Just pass the string "pattern" and the pattern id (returned by <a href="../man3/PS_begin_pattern.3.html"><strong>PS_begin_pattern</strong>(3)</a></strong>) to <a href="../man3/PS_setcolor.3.html"><strong>PS_setcolor</strong>(3)</a></strong>. Any following drawing and/or filling operation will now use the pattern.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HYPERLINKS, BOOKMARKS</h2>
        <div class="sectioncontent">
<p>PostScript itself does not support any hyperlink functions like PDF does. Nervertheless, one can embed hyperlinks into a PostScript document which will be used if the document is later converted to PDF. Such commands for embedding hyperlinks are called pdfmarks. pdfmarks allow to store any feature in a PostScript document which is available in PDF. The PostScript interpreter itself will not care about the pdfmarks. This features makes pslib a viable alternative to libraries creating PDF directly.</p><p>Some functions of pslib will place a pdfmark silently into the document. The most prominent function is <a href="../man3/PS_begin_page.3.html"><strong>PS_begin_page</strong>(3)</a></strong> which stores the page size with the help of pdfmarks.</p><p>pslib supports several types of hyperlinks, which are inserted with the following function.</p><p><strong></strong></p><p>int PS_add_weblink (PSDoc *<em>psdoc</em><strong>, float </strong><em>llx</em><strong>, float </strong><em>lly</em><strong>, float </strong><em>urx</em><strong>, float </strong><em>ury</em><strong>, const char *</strong><em>url</em><strong>);</strong></p><p><strong></strong></p><p>int PS_add_pdflink (PSDoc *<em>psdoc</em><strong>, float </strong><em>llx</em><strong>, float </strong><em>lly</em><strong>, float </strong><em>urx</em><strong>, float </strong><em>ury</em><strong>, const char *</strong><em>filename</em><strong>, int </strong><em>page</em><strong>, const char *</strong><em>dest</em><strong>);</strong></p><p><strong></strong></p><p>int PS_add_locallink (PSDoc *<em>psdoc</em><strong>, float </strong><em>llx</em><strong>, float </strong><em>lly</em><strong>, float </strong><em>urx</em><strong>, float </strong><em>ury</em><strong>, int </strong><em>page</em><strong>, const char *</strong><em>dest</em><strong>);</strong></p><p><strong></strong></p><p>int PS_add_launchlink (PSDoc *<em>psdoc</em><strong>, float </strong><em>llx</em><strong>, float </strong><em>lly</em><strong>, float </strong><em>urx</em><strong>, float </strong><em>ury</em><strong>, const char *</strong><em>filename</em><strong>);</strong></p><p>Each of the above function requires a rectangle with its lower left corner at <em>llx</em>, <em>lly</em> and its upper right corner at <em>urx</em>, <em>ury</em>. The rectangle will not be visible in the PostScript file and marks the sensitve area of the link. When the document is concerted to PDF, the rectangle will become visible. Its appearance can be set with the functions.</p><p><strong></strong></p><p>int PS_set_border_style (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>style</em><strong>, float </strong><em>width</em><strong>);</strong></p><p><em>style</em> can be either 'solid' or 'dashed'.</p><p><strong></strong></p><p>int PS_set_border_color (PSDoc *<em>psdoc</em><strong>, float </strong><em>red</em><strong>, float </strong><em>green</em><strong>, float </strong><em>blue</em><strong>);</strong></p><p><strong></strong></p><p>int PS_set_border_dash (PSDoc *<em>psdoc</em><strong>, float </strong><em>black</em><strong>, float </strong><em>white</em><strong>);</strong></p><p>pslib also supports to add bookmarks which will be displayed by PDF viewers as a table of contents next to the document. Bookmarks have a title and point to a page in the document. The can be added with</p><p><strong></strong></p><p>int PS_add_bookmark (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>text</em><strong>, int </strong><em>parent</em><strong>, int </strong><em>open</em><strong>);</strong></p><p>To build up a hierachical tree of bookmarks, one can pass a parent bookmark when creating a new one. The parent bookmark is referenced by its id as it is returned by the function itself. A bookmark is always added for the current page. It is shown open if the parameter <em>open</em> is greater 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TYPE3 FONTS</h2>
        <div class="sectioncontent">
<p>PostScript knows several types of fonts. The most common is called Type1 which are usally supplied by many font manufactures as .pfb files. pslib can read those fonts and use them right away. Another type of font is called Type3. Type3 fonts distinguish from Type1 fonts by the way its glyphs are constructed. Glyphs in Type3 fonts are created with regular PostScript commands and can easily be created with pslib. All you need to do is start a new font with</p><p><strong></strong></p><p>int PS_begin_font (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>fontname</em><strong>, int </strong><em>reserved</em><strong>, double </strong><em>a</em><strong>, double </strong><em>b</em><strong>, double </strong><em>c</em><strong>, double </strong><em>d</em><strong>, double </strong><em>e</em><strong>, double </strong><em>f</em><strong>, const char *</strong><em>optlist</em><strong>);</strong></p><p>and end finish it with</p><p><strong></strong></p><p>int PS_end_font (PSDoc *<em>psdoc</em><strong>);</strong></p><p>Each font contains of a number of glyphs which are created with a pair of</p><p><strong></strong></p><p>int PS_begin_glyph (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>glyphname</em><strong>, double </strong><em>wx</em><strong>, double </strong><em>llx</em><strong>, double </strong><em>lly</em><strong>, double </strong><em>urx</em><strong>, double </strong><em>ury</em><strong>);</strong></p><p>and</p><p><strong></strong></p><p>int PS_end_glyph (PSDoc *<em>psdoc</em><strong>);</strong></p><p>Within a glyph each command is allowed to create a path and to stroke or fill it. Once a font is created it can be used like any other font by calling <a href="../man3/PS_setfont.3.html"><strong>PS_setfont</strong>(3)</a></strong>.</p><p>The font cannot be saved to a file and used by other applications but it can used within the pslib document which has several advantages when certain symbols, e.g. logos are used through out a document.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMORY MANAGEMENT, ERROR HANDLING</h2>
        <div class="sectioncontent">
<p>pslib uses by default its on memory management and error handling functions. In many cases the calling application has its own memory management and error handling. pslib can be told to use those functions by calling <a href="../man3/PS_new2.3.html"><strong>PS_new2</strong>(3)</a></strong> instead of <a href="../man3/PS_new.3.html"><strong>PS_new</strong>(3)</a></strong>.</p><p><strong></strong></p><p>int PS_new2 (PSDoc *<em>psdoc</em><strong>, (errorhandler *) </strong><em>(PSDoc *p, int type, const char *msg, void *data)</em><strong>, (allocproc *) </strong><em>(PSDoc *p, size_t size, const char *caller)</em><strong>, (reallocproc *) </strong><em>(PSDoc *p, void *mem, size_t size, const char *caller)</em><strong>, (freeproc *) </strong><em>(PSDoc *p, void *mem)</em><strong>, void *</strong><em>opaque</em><strong>);</strong></p><p>The errorhandler and the last parameter <em>opaque</em> allow to pass arbitrary data as the last parameter to its own errorhandler. This is quite often used if errors are being output in a widget of a graphical toolkit. The pointer to that widget can be passed as <em>opaque</em> and pslib will pass it forward to the error handler.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DOCUMENT INFORMATION</h2>
        <div class="sectioncontent">
<p>PostScript documents usually contain a header made of comments with information about the document. The printer usually disregards this information but many PostScript viewer use it. Besides that, one can also place pdfmarks into the PostScript document which contain the title, keywords, author and other information. pslib provides the function <a href="../man3/PS_set_info.3.html"><strong>PS_set_info</strong>(3)</a></strong> to set those fields.</p><p><strong></strong></p><p>int PS_set_info (PSDoc *<em>psdoc</em><strong>, const char *</strong><em>key</em><strong>, const char *</strong><em>value</em><strong>);</strong></p><p><a href="../man3/PS_set_info.3.html"><strong>PS_set_info</strong>(3)</a></strong> must be called before the first page. Calling it later will have no effect and produces a warning. The function may also be used to set the bounding box of the document. Usually there is no need for it, because the dimension of the first page will be used for the bounding box.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pslib&hellip;</h2>
        <div class="sectioncontent">
<p>The detailed manual pages for each function of the library.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>This manual page was written by Uwe Steinmann &lt;uwe@steinmann.cx&gt;.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pslawil.3.html"><span aria-hidden="true">&larr;</span> pslawil.3: Get the transform given by h44,h33, & h43h34 into v  starting at row m</a></li>
   <li class="next"><a href="psorg2l.3.html">psorg2l.3: Generate an m-by-n real distributed matrix q denoting a(ia:ia+m-1,ja:ja+n-1) with orthonormal columns, which is defined as the last n columns of a product of k elementary reflectors of order m   q = h(k) <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

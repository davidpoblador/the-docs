<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Params::CallbackRequest: Functional and object-oriented callback architecture</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Functional and object-oriented callback architecture">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Params::CallbackRequest (3pm) manual">
  <meta name="twitter:description" content="Functional and object-oriented callback architecture">
  <meta name="twitter:image" content="https://www.carta.tech/images/libparams-callbackrequest-perl-Params::CallbackRequest-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Params::CallbackRequest.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Params::CallbackRequest (3pm) manual" />
  <meta property="og:description" content="Functional and object-oriented callback architecture" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libparams-callbackrequest-perl-Params::CallbackRequest-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Params::CallbackRequest<small> (3pm)</small></h1>
        <p class="lead">Functional and object-oriented callback architecture</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Params::CallbackRequest.3pm.html">
      <span itemprop="name">Params::CallbackRequest: Functional and object-oriented callback architecture</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libparams-callbackrequest-perl/">
      <span itemprop="name">libparams-callbackrequest-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Params::CallbackRequest.3pm.html">
      <span itemprop="name">Params::CallbackRequest: Functional and object-oriented callback architecture</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Functional parameter-triggered callbacks:</p>
<pre>
  use strict;
  use Params::CallbackRequest;

  # Create a callback function.
  sub calc_time {
      my $cb = shift;
      my $params = $cb-&gt;params;
      my $val = $cb-&gt;value;
      $params-&gt;{my_time} = localtime($val || time);
  }

  # Set up a callback request object.
  my $cb_request = Params::CallbackRequest-&gt;new(
      callbacks =&gt; [ { cb_key  =&gt; &apos;calc_time&apos;,
                       pkg_key =&gt; &apos;myCallbacker&apos;,
                       cb      =&gt; &#92;&calc_time } ]
  );

  # Request callback execution.
  my %params = (&apos;myCallbacker|calc_time_cb&apos; =&gt; 1);
  $cb_request-&gt;request(&#92;%params);

  # Demonstrate the result.
  print "The time is $params{my_time}&#92;n";
</pre>
<p>Or, in a subclass of Params::Callback:</p><p>  package MyApp::Callback;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;myCallbacker&apos; );</p><p>  # Set up a callback method.   sub calc_time : Callback {       my $self = shift;       my $params = $self-&gt;request_params;       my $val = $cb-&gt;value;       $params-&gt;{my_time} = localtime($val || time);   }</p><p>And then, in your application:</p><p>  # Load order is important here!   use MyApp::Callback;   use Params::CallbackRequest;</p><p>  my $cb_request = Params::Callback-&gt;new( cb_classes =&gt; [qw(myCallbacker)] );   my %params = (&apos;myCallbacker|calc_time_cb&apos; =&gt; 1);   $cb_request-&gt;request(&#92;%params);   print "The time is $params{my_time}&#92;n";</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Params::CallbackRequest provides functional and object-oriented callbacks to method and function parameters. Callbacks may be either code references provided to the \*(C`new()\*(C' constructor, or methods defined in subclasses of Params::Callback. Callbacks are triggered either for every call to the Params::CallbackRequest \*(C`request()\*(C' method, or by specially named keys in the parameters to \*(C`request()\*(C'.</p><p>The idea behind this module is to provide a sort of plugin architecture for Perl templating systems. Callbacks are triggered by the contents of a request to the Perl templating server, before the templating system itself executes. This approach allows you to carry out logical processing of data submitted from a form, to affect the contents of the request parameters before they're passed to the templating system for processing, and even to redirect or abort the request before the templating system handles it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">JUSTIFICATION</h2>
        <div class="sectioncontent">
<p>Why would you want to do this? Well, there are a number of reasons. Some I can think of offhand include:</p>
<dl class='dl-vertical'>
  <dt>
    Stricter separation of logic from presentation
  </dt>
  <dd>
    <p>While some Perl templating systems enforce separation of application logic from presentation (e.g., \s-1TT\s0, HTML::Template), others do not (e.g., HTML::Mason, Apache::ASP). Even in the former case, application logic is often put into scripts that are executed alongside the presentation templates, and loaded on-demand under mod_perl. By moving the application logic into Perl modules and then directing the templating system to execute that code as callbacks, you obviously benefit from a cleaner separation of application logic and presentation.</p>
  </dd>
  <dt>
    Widgitization
  </dt>
  <dd>
    <p>Thanks to their ability to preprocess parameters, callbacks enable developers to develop easier-to-use, more dynamic widgets that can then be used in any and all templating systems. For example, a widget that puts many related fields into a form (such as a date selection widget) can have its fields preprocessed by a callback (for example, to properly combine the fields into a unified date parameter) before the template that responds to the form submission gets the data. See Params::Callback for an example solution for this very problem.</p>
  </dd>
  <dt>
    Shared Memory
  </dt>
  <dd>
    <p>If you run your templating system under mod_perl, callbacks are just Perl subroutines in modules loaded at server startup time. Thus the memory they consume is all in the Apache parent process, and shared by the child processes. For code that executes frequently, this can be much less resource-intensive than code in templates, since templates are loaded separately in each Apache child process on demand.</p>
  </dd>
  <dt>
    Performance
  </dt>
  <dd>
    <p>Since they're executed before the templating architecture does much processing, callbacks have the opportunity to short-circuit the template processing by doing something else. A good example is redirection. Often the application logic in callbacks does its thing and then redirects the user to a different page. Executing the redirection in a callback eliminates a lot of extraneous processing that would otherwise be executed before the redirection, creating a snappier response for the user.</p>
  </dd>
  <dt>
    Testing
  </dt>
  <dd>
    <p>Templating system templates are not easy to test via a testing framework such as Test::Harness. Subroutines in modules, on the other hand, are fully testable. This means that you can write tests in your application test suite to test your callback subroutines.</p>
  </dd>

</dl>
<p>And if those aren't enough reasons, then just consider this: Callbacks are just <em>way cool.</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>Params::CallbackRequest supports two different types of callbacks: those triggered by a specially named parameter keys, and those executed for every request.</p><h3>Parameter-Triggered Callbacks</h3>
<p>Parameter-triggered callbacks are triggered by specially named parameter keys. These keys are constructed as follows: The package name followed by a pipe character (\*(L"|\*(R"), the callback key with the string \*(L"_cb\*(R" appended to it, and finally an optional priority number at the end. For example, if you specified a callback with the callback key \*(L"save\*(R" and the package key \*(L"world\*(R", a callback field might be specified like this:</p><p>  my $params = { "world|save_cb" =&gt; &apos;Save World&apos; };</p><p>When the parameters hash $params is passed to Params::CallbackRequest's \*(C`request()\*(C' method, the \*(C`world|save_cb\*(C' parameter would trigger the callback associated with the \*(L"save\*(R" callback key in the \*(L"world\*(R" package. If such a callback hasn't been configured, then Params::CallbackRequest will throw a Params::CallbackRequest::Exceptions::InvalidKey exception. Here's how to configure a functional callback when constructing your Params::CallbackRequest object so that that doesn't happen:</p><p>  my $cb_request = Params::CallbackRequest-&gt;new     ( callbacks =&gt; [ { pkg_key =&gt; &apos;world&apos;,                        cb_key  =&gt; &apos;save&apos;,                        cb      =&gt; &#92;&My::World::save } ] );</p><p>With this configuration, the \*(C`world|save_cb\*(C' parameter key will trigger the execution of the \*(C`My::World::save()\*(C' subroutine during a callback request:</p><p>  # Execute parameter-triggered callback.   $cb_request-&gt;request($params);</p><p><em>Functional Callback Subroutines</em></p><p>Functional callbacks use a code reference for parameter-triggered callbacks, and Params::CallbackRequest executes them with a single argument, a Params::Callback object. Thus, a callback subroutine will generally look something like this:</p><p>  sub foo {       my $cb = shift;       # Do stuff.   }</p><p>The Params::Callback object provides accessors to data relevant to the callback, including the callback key, the package key, and the parameter hash. It also includes an \*(C`abort()\*(C' method. See the Params::Callback documentation for all the goodies.</p><p>Note that Params::CallbackRequest installs an exception handler during the execution of callbacks, so if any of your callback subroutines \*(C`die\*(C', Params::CallbackRequest will throw an Params::Callback::Exception::Execution exception. If your callback subroutines throw their own exception objects, Params::CallbackRequest will simply rethrow them. If you don't like this configuration, use the \*(C`exception_handler\*(C' parameter to \*(C`new()\*(C' to install your own exception handler.</p><p><em>Object-Oriented Callback Methods</em></p><p>Object-oriented callback methods, which are supported under Perl 5.6 or later, are defined in subclasses of Params::Callback, and identified by attributes in their declarations. Unlike functional callbacks, callback methods are not called with a Params::Callback object, but with an instance of the callback subclass. These classes inherit all the goodies provided by Params::Callback, so you can essentially use their instances exactly as you would use the Params::Callback object in functional callback subroutines. But because they're subclasses, you can add your own methods and attributes. See Params::Callback for all the gory details on subclassing, along with a few examples. Generally, callback methods will look like this:</p><p>  sub foo : Callback {       my $self = shift;       # Do stuff.   }</p><p>As with functional callback subroutines, method callbacks are executed with a custom exception handler. Again, see the \*(C`exception_handler\*(C' parameter to install your own exception handler.</p><p><strong>Note:</strong> Under mod_perl, it's important that you \*(C`use\*(C' any and all Params::Callback subclasses <em>before</em> you \*(C`use Params::CallbackRequest\*(C'. This is to get around an issue with identifying the names of the callback methods in mod_perl. Read the comments in the Params::Callback source code if you're interested in learning more.</p><p><em>The Package Key</em></p><p>The use of the package key is a convenience so that a system with many functional callbacks can use callbacks with the same keys but in different packages. The idea is that the package key will uniquely identify the module in which each callback subroutine is found, but it doesn't necessarily have to be so. Use the package key any way you wish, or not at all:</p><p>  my $cb_request = Params::CallbackRequest-&gt;new     ( callbacks =&gt; [ { cb_key  =&gt; &apos;save&apos;,                        cb      =&gt; &#92;&My::World::save } ] );</p><p>But note that if you don't specify the package key, you'll still need to provide one in the parameter hash passed to \*(C`request()\*(C'. By default, that key is \*(L"\s-1DEFAULT\s0\*(R". Such a callback parameter would then look like this:</p><p>  my $params = { "DEFAULT|save_cb" =&gt; &apos;Save World&apos; };</p><p>If you don't like the \*(L"\s-1DEFAULT\s0\*(R" package name, you can set an alternative default using the \*(C`default_pkg_name\*(C' parameter to \*(C`new()\*(C':</p><p>  my $cb_request = Params::CallbackRequest-&gt;new     ( callbacks        =&gt; [ { cb_key  =&gt; &apos;save&apos;,                               cb      =&gt; &#92;&My::World::save } ],       default_pkg_name =&gt; &apos;MyPkg&apos; );</p><p>Then, of course, any callbacks without a specified package key of their own must then use the custom default:</p><p>  my $params = { "MyPkg|save_cb" =&gt; &apos;Save World&apos; };   $cb_request-&gt;request($params);</p><p><em>The Class Key</em></p><p>The class key is essentially a synonym for the package key, but applies more directly to object-oriented callbacks. The difference is mainly that it corresponds to an actual class, and that all Params::Callback subclasses are <em>required</em> to have a class key; it's not optional as it is with functional callbacks. The class key may be declared in your Params::Callback subclass like so:</p><p>  package MyApp::CallbackHandler;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;MyCBHandler&apos; );</p><p>The class key can also be declared by implementing a \*(C`CLASS_KEY\*(C' subroutine, like so:</p><p>  package MyApp::CallbackHandler;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass;   use constant CLASS_KEY =&gt; &apos;MyCBHandler&apos;;</p><p>If no class key is explicitly defined, Params::Callback will use the subclass name, instead. In any event, the \*(C`register_callback()\*(C' method <strong>must</strong> be called to register the subclass with Params::Callback. See the Params::Callback documentation for complete details.</p><p><em>Priority</em></p><p>Sometimes one callback is more important than another. For example, you might rely on the execution of one callback to set up variables needed by another. Since you can't rely on the order in which callbacks are executed (the parameters are passed via a hash, and the processing of a hash is, of course, unordered), you need a method of ensuring that the setup callback executes first.</p><p>In such a case, you can set a higher priority level for the setup callback than for callbacks that depend on it. For functional callbacks, you can do it like this:</p><p>  my $cb_request = Params::CallbackRequest-&gt;new     ( callbacks        =&gt; [ { cb_key   =&gt; &apos;setup&apos;,                               priority =&gt; 3,                               cb       =&gt; &#92;&setup },                             { cb_key   =&gt; &apos;save&apos;,                               cb       =&gt; &#92;&save }                           ] );</p><p>For object-oriented callbacks, you can define the priority right in the callback method declaration:</p><p>  sub setup : Callback( priority =&gt; 3 ) {       my $self = shift;       # ...   }</p><p>  sub save : Callback {       my $self = shift;       # ...   }</p><p>In these examples, the \*(L"setup\*(R" callback has been configured with a priority level of \*(L"3\*(R". This ensures that it will always execute before the \*(L"save\*(R" callback, which has the default priority of \*(L"5\*(R". Obviously, this is true regardless of the order of the fields in the hash:</p><p>  my $params = { "DEFAULT|save_cb"  =&gt; &apos;Save World&apos;,                  "DEFAULT|setup_cb" =&gt; 1 };</p><p>In this configuration, the \*(L"setup\*(R" callback will always execute first because of its higher priority.</p><p>Although the \*(L"save\*(R" callback got the default priority of \*(L"5\*(R", this too can be customized to a different priority level via the \*(C`default_priority\*(C' parameter to \*(C`new()\*(C' for functional callbacks and the \*(C`default_priority\*(C' to the class declaration for object-oriented callbacks. For example, this functional callback configuration:</p><p>  my $cb_request = Params::CallbackRequest-&gt;new     ( callbacks        =&gt; [ { cb_key   =&gt; &apos;setup&apos;,                               priority =&gt; 3,                               cb       =&gt; &#92;&setup },                             { cb_key   =&gt; &apos;save&apos;,                               cb       =&gt; &#92;&save }                           ],       default_priority =&gt; 2 );</p><p>Or this Params::Callback subclass declaration:</p><p>  package MyApp::CallbackHandler;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass( class_key        =&gt; &apos;MyCBHandler&apos;,                                   default_priority =&gt; 2 );</p><p>Will cause the \*(L"save\*(R" callback to always execute before the \*(L"setup\*(R" callback, since its priority level will default to \*(L"2\*(R".</p><p>In addition, the priority level can be overridden via the parameter key itself by appending a priority level to the end of the key name. Hence, this example:</p><p>  my $params = { "DEFAULT|save_cb2" =&gt; &apos;Save World&apos;,                  "DEFAULT|setup_cb" =&gt; 1 };</p><p>Causes the \*(L"save\*(R" callback to execute before the \*(L"setup\*(R" callback by overriding the \*(L"save\*(R" callback's priority to level \*(L"2\*(R". Of course, any other parameter key that triggers the \*(L"save\*(R" callback without a priority override will still execute the \*(L"save\*(R" callback at its configured level.</p>
<h3>Request Callbacks</h3>
<p>Request callbacks come in two flavors: those that execute before the parameter-triggered callbacks, and those that execute after the parameter-triggered callbacks. Functional request callbacks may be specified via the \*(C`pre_callbacks\*(C' and \*(C`post_callbacks\*(C' parameters to \*(C`new()\*(C', respectively:</p><p>  my $cb_request = Params::CallbackRequest-&gt;new     ( pre_callbacks  =&gt; [ &#92;&translate, &#92;&foobarate ],       post_callbacks =&gt; [ &#92;&escape, &#92;&negate ] );</p><p>Object-oriented request callbacks may be declared via the \*(C`PreCallback\*(C' and \*(C`PostCallback\*(C' method attributes, like so:</p><p>  sub translate : PreCallback { ... }   sub foobarate : PreCallback { ... }   sub escape : PostCallback { ... }   sub negate : PostCallback { ... }</p><p>In these examples, the \*(C`translate()\*(C' and \*(C`foobarate()\*(C' subroutines or methods will execute (in that order) before any parameter-triggered callbacks are executed (none will be in these examples, since none are specified).</p><p>Conversely, the \*(C`escape()\*(C' and \*(C`negate()\*(C' subroutines or methods will be executed (in that order) after all parameter-triggered callbacks have been executed. And regardless of what parameter-triggered callbacks may be triggered, the request callbacks will always be executed for <em>every</em> request (unless an exception is thrown by an earlier callback).</p><p>Although they may be used for different purposes, the \*(C`pre_callbacks\*(C' and \*(C`post_callbacks\*(C' functional callback code references expect the same argument as parameter-triggered functional callbacks: a Params::Callback object:</p><p>  sub foo {       my $cb = shift;       # Do your business here.   }</p><p>Similarly, object-oriented request callback methods will be passed an object of the class defined in the class key portion of the callback trigger \*(-- either an object of the class in which the callback is defined, or an object of a subclass:</p><p>  sub foo : PostCallback {       my $self = shift;       # ...   }</p><p>Of course, the attributes of the Params::Callback or subclass object will be different than in parameter-triggered callbacks. For example, the \*(C`priority\*(C', \*(C`pkg_key\*(C', and \*(C`cb_key\*(C' attributes will naturally be undefined. It will, however, be the same instance of the object passed to all other functional callbacks \*(-- or to all other class callbacks with the same class key \*(-- in a single request.</p><p>Like the parameter-triggered callbacks, request callbacks run under the nose of a custom exception handler, so if any of them \*(C`die\*(C's, an Params::Callback::Exception::Execution exception will be thrown. Use the \*(C`exception_handler\*(C' parameter to \*(C`new()\*(C' if you don't like this.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<p>Params::CallbackRequest supports a number of its own parameters to the \*(C`new()\*(C' constructor (though none of them, sadly, trigger callbacks). The parameters to \*(C`new()\*(C' are as follows: Parameter-triggered functional callbacks are configured via the \*(C`callbacks\*(C' parameter. This parameter is an array reference of hash references, and each hash reference specifies a single callback. The supported keys in the callback specification hashes are:</p><p>Required. A string that, when found in a properly-formatted parameter hash key, will trigger the execution of the callback. Required. A reference to the Perl subroutine that will be executed when the \*(C`cb_key\*(C' has been found in a parameter hash passed to \*(C`request()\*(C'. Each code reference should expect a single argument: a Params::Callback object. The same instance of a Params::Callback object will be used for all functional callbacks in a single call to \*(C`request()\*(C'. Optional. A key to uniquely identify the package in which the callback subroutine is found. This parameter is useful in systems with many callbacks, where developers may wish to use the same \*(C`cb_key\*(C' for different subroutines in different packages. The default package key may be set via the \*(C`default_pkg_key\*(C' parameter to \*(C`new()\*(C'. Optional. Indicates the level of priority of a callback. Some callbacks are more important than others, and should be executed before the others. Params::CallbackRequest supports priority levels ranging from \*(L"0\*(R" (highest priority) to \*(L"9\*(R" (lowest priority). The default priority for functional callbacks may be set via the \*(C`default_priority\*(C' parameter.</p><p>This parameter accepts an array reference of code references that should be executed for <em>every</em> call to \*(C`request()\*(C' <em>before</em> any parameter-triggered callbacks. They will be executed in the order in which they're listed in the array reference. Each code reference should expect a Params::Callback object as its sole argument. The same instance of a Params::Callback object will be used for all functional callbacks in a single call to \*(C`request()\*(C'. Use pre-parameter-triggered request callbacks when you want to do something with the parameters submitted for every call to \*(C`request()\*(C', such as convert character sets. This parameter accepts an array reference of code references that should be executed for <em>every</em> call to \*(C`request()\*(C' <em>after</em> all parameter-triggered callbacks have been called. They will be executed in the order in which they're listed in the array reference. Each code reference should expect a Params::Callback object as its sole argument. The same instance of a Params::Callback object will be used for all functional callbacks in a single call to \*(C`request()\*(C'. Use post-parameter-triggered request callbacks when you want to do something with the parameters submitted for every call to \*(C`request()\*(C', such as encode or escape their values for presentation. An array reference listing the class keys of all of the Params::Callback subclasses containing callback methods that you want included in your Params::CallbackRequest object. Alternatively, the \*(C`cb_classes\*(C' parameter may simply be the word \*(L"\s-1ALL\s0\*(R", in which case <em>all</em> Params::Callback subclasses will have their callback methods registered with your Params::CallbackRequest object. See the Params::Callback documentation for details on creating callback classes and methods. <strong>Note:</strong> In a mod_perl environment, be sure to \*(C`use Params::CallbackRequest\*(C' <em>only</em> after you've \*(C`use\*(C'd all of the Params::Callback subclasses you need or else you won't be able to use their callback methods. The priority level at which functional callbacks will be executed. Does not apply to object-oriented callbacks. This value will be used in each hash reference passed via the \*(C`callbacks\*(C' parameter to \*(C`new()\*(C' that lacks a \*(C`priority\*(C' key. You may specify a default priority level within the range of \*(L"0\*(R" (highest priority) to \*(L"9\*(R" (lowest priority). If not specified, it defaults to \*(L"5\*(R". The default package key for functional callbacks. Does not apply to object-oriented callbacks. This value that will be used in each hash reference passed via the \*(C`callbacks\*(C' parameter to \*(C`new()\*(C' that lacks a \*(C`pkg_key\*(C' key. It can be any string that evaluates to a true value, and defaults to \*(L"\s-1DEFAULT\s0\*(R" if not specified. By default, Params::CallbackRequest will execute all callbacks triggered by parameter hash keys. However, in many situations it may be desirable to skip any callbacks that have no value for the callback field. One can do this by simply checking \*(C`$cbh-&gt;value\*(C' in the callback, but if you need to disable the execution of all parameter-triggered callbacks when the callback parameter value is undefined or the null string (''), pass the \*(C`ignore_null\*(C' parameter with a true value. It is set to a false value by default. By default, Params::CallbackRequest will clear out the contents of the hash accessed via the \*(C`notes()\*(C' method just before returning from a call to \*(C`request()\*(C'. There may be some circumstances when it's desirable to allow the notes hash to persist beyond the duration of a a call to \*(C`request()\*(C'. For example, a templating architecture may wish to keep the notes around for the duration of the execution of a template request. In such cases, pass a true value to the \*(C`leave_notes\*(C' parameter, and use the \*(C`clear_notes()\*(C' method to manually clear out the notes hash at the appropriate point. Params::CallbackRequest installs a custom exception handler during the execution of callbacks. This custom exception handler will simply rethrow any exception objects it comes across, but will throw a Params::Callback::Exception::Execution exception object if it is passed only a string value (such as is passed by \*(C`die "fool!"\*(C'). But if you find that you're throwing your own exceptions in your callbacks, and want to handle them differently, pass the \*(C`exception_handler\*(C' parameter a code reference to do what you need.</p><h3>Instance Methods</h3>
<p>Params::CallbackRequest of course has several instance methods. I cover the most important, first.</p><p><em>request</em></p><p>  $cb_request-&gt;request(&#92;%params);</p><p>  # If you&apos;re in a mod_perl environment, pass in an Apache request object   # to be passed to the Callback classes.   $cb_request-&gt;request(&#92;%params, apache_req =&gt; $r);</p><p>  # Or pass in argument to be passed to callback class constructors.   $cb_request-&gt;request(&#92;%params, @args);</p><p>Executes the callbacks specified when the Params::CallbackRequest object was created. It takes a single required argument, a hash reference of parameters. Any subsequent arguments are passed to the constructor for each callback class for which callbacks will be executed. By default, the only extra parameter supported by the Params::Callback base class is an Apache request object, which can be passed via the \*(C`apache_req\*(C' parameter. Returns the Params::CallbackRequest object on success, or the code passed to Params::Callback's \*(C`abort()\*(C' method if callback execution was aborted.</p><p>A single call to \*(C`request()\*(C' is referred to as a \*(L"callback request\*(R" (naturally!). First, all pre-request callbacks are executed. Then, any parameter-triggered callbacks triggered by the keys in the parameter hash reference passed as the sole argument are executed. And finally, all post-request callbacks are executed. \*(C`request()\*(C' returns the Params::CallbackRequest object on successful completion of the request.</p><p>Any callback that calls \*(C`abort()\*(C' on its Params::Callback object will prevent any other callbacks scheduled by the request to run subsequent to its execution from being executed (including post-request callbacks). Furthermore, any callback that \*(C`die\*(C's or throws an exception will of course also prevent any subsequent callbacks from executing, and in addition must also be caught by the caller or the whole process will terminate:</p><p>  eval { $cb_request-&gt;request(&#92;%params) };   if (my $err = $@) {       # Handle exception.   }</p><p><em>notes</em></p><p>  $cb_request-&gt;notes($key =&gt; $value);   my $val = $cb_request-&gt;notes($key);   my $notes = $cb_request-&gt;notes;</p><p>The \*(C`notes()\*(C' method provides a place to store application data, giving developers a way to share data among multiple callbacks over the course of a call to \*(C`request()\*(C'. Any data stored here persists for the duration of the request unless the \*(C`leave_notes\*(C' parameter to \*(C`new()\*(C' has been passed a true value. In such cases, use \*(C`clear_notes()\*(C' to manually clear the notes.</p><p>Conceptually, \*(C`notes()\*(C' contains a hash of key-value pairs. \*(C`notes($key, $value)\*(C' stores a new entry in this hash. \*(C`notes($key)\*(C' returns a previously stored value. \*(C`notes()\*(C' without any arguments returns a reference to the entire hash of key-value pairs.</p><p>\*(C`notes()\*(C' is similar to the mod_perl method \*(C`$r-&gt;pnotes()\*(C'. The main differences are that this \*(C`notes()\*(C' can be used in a non-mod_perl environment, and that its lifetime is tied to the lifetime of the call to \*(C`request()\*(C' unless the \*(C`leave_notes\*(C' parameter is true.</p><p>For the sake of convenience, a shortcut to \*(C`notes()\*(C' is provide to callback code via the \*(C`notes()\*(C' method in Params::Callback.</p><p><em>clear_notes</em></p><p>  $cb_request-&gt;clear_notes;</p><p>Use this method to clear out the notes hash. Most useful when the \*(C`leave_notes\*(C' parameter to \*(C`new()\*(C' has been set to at true value and you need to manage the clearing of notes yourself. This method is specifically designed for a templating environment, where it may be advantageous for the templating architecture to allow the notes to persist beyond the duration of a call to \*(C`request()\*(C', e.g., to keep them for the duration of a call to the templating architecture itself. See MasonX::Interp::WithCallbacks for an example of this strategy.</p>
<h3>Accessor Methods</h3>
<p>The properties \*(C`default_priority\*(C' and \*(C`default_pkg_key\*(C' have standard read-only accessor methods of the same name. For example:</p><p>  my $cb_request = Params::CallbackRequest-&gt;new;   my $default_priority = $cb_request-&gt;default_priority;   my $default_pkg_key = $cb_request-&gt;default_pkg_key;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGMENTS</h2>
        <div class="sectioncontent">
<p>Garth Webb implemented the original callbacks in Bricolage, based on an idea he borrowed from Paul Lindner's work with Apache::ASP. My thanks to them both for planting this great idea! This implementation is however completely independent of previous implementations.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Params::CallbackRequest&hellip;</h2>
        <div class="sectioncontent">
<p>Params::Callback objects get passed as the sole argument to all functional callbacks, and offer access to data relevant to the callback. Params::Callback also defines the object-oriented callback interface, making its documentation a must-read for anyone who wishes to create callback classes and methods.</p><p>MasonX::Interp::WithCallbacks uses this module to provide a callback architecture for HTML::Mason.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>This module is stored in an open GitHub repository &lt;http://github.com/theory/params-callbackrequest/&gt;. Feel free to fork and contribute!</p><p>Please file bug reports via GitHub Issues &lt;http://github.com/theory/params-callbackrequest/issues/&gt; or by sending mail to bug-params-callbackrequest@rt.cpan.org &lt;mailto:bug-params-callbackrequest@rt.cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David E. Wheeler &lt;david@justatheory.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright 2003-2011 David E. Wheeler. Some Rights Reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Params::Callback.3pm.html"><span aria-hidden="true">&larr;</span> Params::Callback.3pm: Parameter callback base class</a></li>
   <li class="next"><a href="Params::CallbackRequest::Exceptions.3pm.html">Params::CallbackRequest::Exceptions.3pm: Parameter callback exception definitions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

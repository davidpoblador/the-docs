<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::DBI: Simple database abstraction</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Simple database abstraction">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::DBI (3pm) manual">
  <meta name="twitter:description" content="Simple database abstraction">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-dbi-perl-Class::DBI-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::DBI.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::DBI (3pm) manual" />
  <meta property="og:description" content="Simple database abstraction" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-dbi-perl-Class::DBI-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::DBI<small> (3pm)</small></h1>
        <p class="lead">Simple database abstraction</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::DBI.3pm.html">
      <span itemprop="name">Class::DBI: Simple database abstraction</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-dbi-perl/">
      <span itemprop="name">libclass-dbi-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::DBI.3pm.html">
      <span itemprop="name">Class::DBI: Simple database abstraction</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  package Music::DBI;
  use base &apos;Class::DBI&apos;;
  Music::DBI-&gt;connection(&apos;dbi:mysql:dbname&apos;, &apos;username&apos;, &apos;password&apos;);

  package Music::Artist;
  use base &apos;Music::DBI&apos;;
  Music::Artist-&gt;table(&apos;artist&apos;);
  Music::Artist-&gt;columns(All =&gt; qw/artistid name/);
  Music::Artist-&gt;has_many(cds =&gt; &apos;Music::CD&apos;);

  package Music::CD;
  use base &apos;Music::DBI&apos;;
  Music::CD-&gt;table(&apos;cd&apos;);
  Music::CD-&gt;columns(All =&gt; qw/cdid artist title year reldate/);
  Music::CD-&gt;has_many(tracks =&gt; &apos;Music::Track&apos;);
  Music::CD-&gt;has_a(artist =&gt; &apos;Music::Artist&apos;);
  Music::CD-&gt;has_a(reldate =&gt; &apos;Time::Piece&apos;,
    inflate =&gt; sub { Time::Piece-&gt;strptime(shift, "%Y-%m-%d") },
    deflate =&gt; &apos;ymd&apos;,
  );

  Music::CD-&gt;might_have(liner_notes =&gt; LinerNotes =&gt; qw/notes/);

  package Music::Track;
  use base &apos;Music::DBI&apos;;
  Music::Track-&gt;table(&apos;track&apos;);
  Music::Track-&gt;columns(All =&gt; qw/trackid cd position title/);

  #-- Meanwhile, in a nearby piece of code! --#

  my $artist = Music::Artist-&gt;insert({ artistid =&gt; 1, name =&gt; &apos;U2&apos; });

  my $cd = $artist-&gt;add_to_cds({
    cdid   =&gt; 1,
    title  =&gt; &apos;October&apos;,
    year   =&gt; 1980,
  });

  # Oops, got it wrong.
  $cd-&gt;year(1981);
  $cd-&gt;update;

  # etc.

  foreach my $track ($cd-&gt;tracks) {
    print $track-&gt;position, $track-&gt;title
  }

  $cd-&gt;delete; # also deletes the tracks

  my $cd  = Music::CD-&gt;<strong>retrieve</strong>(1);
  my @cds = Music::CD-&gt;retrieve_all;
  my @cds = Music::CD-&gt;search(year =&gt; 1980);
  my @cds = Music::CD-&gt;search_like(title =&gt; &apos;October%&apos;);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>Class::DBI provides a convenient abstraction layer to a database.</p><p>It not only provides a simple database to object mapping layer, but can be used to implement several higher order database functions (triggers, referential integrity, cascading delete etc.), at the application level, rather than at the database.</p><p>This is particularly useful when using a database which doesn't support these (such as MySQL), or when you would like your code to be portable across multiple databases which might implement these things in different ways.</p><p>In short, Class::DBI aims to make it simple to introduce 'best practice' when dealing with data stored in a relational database.</p><h3>How to set it up</h3>

<dl class='dl-vertical'>
  <dt>
    <em>Set up a database.</em>
  </dt>
  <dd>
    <p>You must have an existing database set up, have \s-1DBI\s0.pm installed and the necessary \s-1DBD::\s0 driver module for that database.  See \s-1DBI\s0 and the documentation of your particular database and driver for details.</p>
  </dd>
  <dt>
    <em>Set up a table for your objects to be stored in.</em>
  </dt>
  <dd>
    <p>Class::DBI works on a simple one class/one table model.  It is your responsibility to have your database tables already set up. Automating that process is outside the scope of Class::DBI. Using our \s-1CD\s0 example, you might declare a table something like this:   CREATE TABLE cd (     cdid   INTEGER   PRIMARY KEY,     artist INTEGER, # references &apos;artist&apos;     title  VARCHAR(255),     year   <strong>CHAR</strong>(4),   );</p>
  </dd>
  <dt>
    <em>Set up an application base class</em>
  </dt>
  <dd>
    <p>It's usually wise to set up a \*(L"top level\*(R" class for your entire application to inherit from, rather than have each class inherit directly from Class::DBI.  This gives you a convenient point to place system-wide overrides and enhancements to Class::DBI's behavior.   package Music::DBI;   use base &apos;Class::DBI&apos;;</p>
  </dd>
  <dt>
    <em>Give it a database connection</em>
  </dt>
  <dd>
    <p>Class::DBI needs to know how to access the database.  It does this through a \s-1DBI\s0 connection which you set up by calling the <em>connection()</em> method.   Music::DBI-&gt;connection(&apos;dbi:mysql:dbname&apos;, &apos;user&apos;, &apos;password&apos;); By setting the connection up in your application base class all the table classes that inherit from it will share the same connection.</p>
  </dd>
  <dt>
    <em>Set up each Class</em>
  </dt>
  <dd>
    <p>  package Music::CD;   use base &apos;Music::DBI&apos;; Each class will inherit from your application base class, so you don't need to repeat the information on how to connect to the database.</p>
  </dd>
  <dt>
    <em>Declare the name of your table</em>
  </dt>
  <dd>
    <p>Inform Class::DBI what table you are using for this class:   Music::CD-&gt;table(&apos;cd&apos;);</p>
  </dd>
  <dt>
    <em>Declare your columns.</em>
  </dt>
  <dd>
    <p>This is done using the <em>columns()</em> method. In the simplest form, you tell it the name of all your columns (with the single primary key first):   Music::CD-&gt;columns(All =&gt; qw/cdid artist title year/); If the primary key of your table spans multiple columns then declare them using a separate call to <em>columns()</em> like this:   Music::CD-&gt;columns(Primary =&gt; qw/pk1 pk2/);   Music::CD-&gt;columns(Others =&gt; qw/foo bar baz/); For more information about how you can more efficiently use subsets of your columns, see \*(L"\s-1LAZY\s0 \s-1POPULATION\s0\*(R"</p>
  </dd>
  <dt>
    <em>Done.</em>
  </dt>
  <dd>
    <p>That's it! You now have a class with methods to \*(L"insert\*(R", \*(L"retrieve\*(R", \*(L"search\*(R" for, \*(L"update\*(R" and \*(L"delete\*(R" objects from your table, as well as accessors and mutators for each of the columns in that object (row).</p>
  </dd>

</dl>
<p>Let's look at all that in more detail:</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLASS METHODS</h2>
        <div class="sectioncontent">
<h3>connection</h3>
<p>  _\|_PACKAGE_\|_-&gt;connection($data_source, $user, $password, &#92;%attr);</p><p>This sets up a database connection with the given information.</p><p>This uses Ima::DBI to set up an inheritable connection (named Main). It is therefore usual to only set up a <em>connection()</em> in your application base class and let the 'table' classes inherit from it.</p><p>  package Music::DBI;   use base &apos;Class::DBI&apos;;</p><p>  Music::DBI-&gt;connection(&apos;dbi:foo:dbname&apos;, &apos;user&apos;, &apos;password&apos;);</p><p>  package My::Other::Table;   use base &apos;Music::DBI&apos;;</p><p>Class::DBI helps you along a bit to set up the database connection. <em>connection()</em> provides its own default attributes depending on the driver name in the data_source parameter. The <em>connection()</em> method provides defaults for these attributes:</p><p>  FetchHashKeyName   =&gt; &apos;NAME_lc&apos;,   ShowErrorStatement =&gt; 1,   ChopBlanks         =&gt; 1,   AutoCommit         =&gt; 1,</p><p>(Except for Oracle and Pg, where AutoCommit defaults 0, placing the database in transactional mode).</p><p>The defaults can always be extended (or overridden if you know what you're doing) by supplying your own &#92;%attr parameter. For example:</p><p>  Music::DBI-&gt;connection(dbi:foo:dbname&apos;,&apos;user&apos;,&apos;pass&apos;,{ChopBlanks=&gt;0});</p><p>The RootClass of DBIx::ContextualFetch in also inherited from Ima::DBI, and you should be very careful not to change this unless you know what you're doing!</p><p><em>Dynamic Database Connections / db_Main</em></p><p>It is sometimes desirable to generate your database connection information dynamically, for example, to allow multiple databases with the same schema to not have to duplicate an entire class hierarchy.</p><p>The preferred method for doing this is to supply your own <em>db_Main()</em> method rather than calling \*(L"connection\*(R". This method should return a valid database handle, and should ensure it sets the standard attributes described above, preferably by combining $class-&gt;<em>_default_attributes()</em> with your own. Note, this handle *must* have its RootClass set to DBIx::ContextualFetch, so it is usually not possible to just supply a $dbh obtained elsewhere.</p><p>Note that connection information is class data, and that changing it at run time may have unexpected behaviour for instances of the class already in existence.</p>
<h3>table</h3>
<p>  _\|_PACKAGE_\|_-&gt;table($table);</p><p>  $table = Class-&gt;table;   $table = $obj-&gt;table;</p><p>An accessor to get/set the name of the database table in which this class is stored.  It -must- be set.</p><p>Table information is inherited by subclasses, but can be overridden.</p>
<h3>table_alias</h3>
<p>  package Shop::Order;   _\|_PACKAGE_\|_-&gt;table(&apos;orders&apos;);   _\|_PACKAGE_\|_-&gt;table_alias(&apos;orders&apos;);</p><p>When Class::DBI constructs \s-1SQL\s0, it aliases your table name to a name representing your class. However, if your class's name is an \s-1SQL\s0 reserved word (such as 'Order') this will cause \s-1SQL\s0 errors. In such cases you should supply your own alias for your table name (which can, of course, be the same as the actual table name).</p><p>This can also be passed as a second argument to 'table':</p><p>  _\|_PACKAGE_\|_-&gt;table(&apos;orders&apos;, &apos;orders&apos;);</p><p>As with table, this is inherited but can be overridden.</p>
<h3>sequence / auto_increment</h3>
<p>  _\|_PACKAGE_\|_-&gt;sequence($sequence_name);</p><p>  $sequence_name = Class-&gt;sequence;   $sequence_name = $obj-&gt;sequence;</p><p>If you are using a database which supports sequences and you want to use a sequence to automatically supply values for the primary key of a table, then you should declare this using the <em>sequence()</em> method:</p><p>  _\|_PACKAGE_\|_-&gt;columns(Primary =&gt; &apos;id&apos;);   _\|_PACKAGE_\|_-&gt;sequence(&apos;class_id_seq&apos;);</p><p>Class::DBI will use the sequence to generate a primary key value when objects are inserted without one.</p><p>*NOTE* This method does not work for Oracle. However, Class::DBI::Oracle (which can be downloaded separately from \s-1CPAN\s0) provides a suitable replacement <em>sequence()</em> method.</p><p>If you are using a database with \s-1AUTO_INCREMENT\s0 (e.g. MySQL) then you do not need this, and any call to <em>insert()</em> without a primary key specified will fill this in automagically.</p><p>Sequence and auto-increment mechanisms only apply to tables that have a single column primary key. For tables with multi-column primary keys you need to supply the key values manually.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTORS and DESTRUCTORS</h2>
        <div class="sectioncontent">
<p>The following are methods provided for convenience to insert, retrieve and delete stored objects.  It's not entirely one-size fits all and you might find it necessary to override them.</p><h3>insert</h3>
<p>  my $obj = Class-&gt;insert(&#92;%data);</p><p>This is a constructor to insert new data into the database and create an object representing the newly inserted row.</p><p>%data consists of the initial information to place in your object and the database.  The keys of %data match up with the columns of your objects and the values are the initial settings of those fields.</p><p>  my $cd = Music::CD-&gt;insert({     cdid   =&gt; 1,     artist =&gt; $artist,     title  =&gt; &apos;October&apos;,     year   =&gt; 1980,   });</p><p>If the table has a single primary key column and that column value is not defined in %data, <em>insert()</em> will assume it is to be generated. If a <em>sequence()</em> has been specified for this Class, it will use that. Otherwise, it will assume the primary key can be generated by \s-1AUTO_INCREMENT\s0 and attempt to use that.</p><p>The \*(C`before_create\*(C' trigger is invoked directly after storing the supplied values into the new object and before inserting the record into the database. The object stored in $self may not have all the functionality of the final object after_creation, particularly if the database is going to be providing the primary key value.</p><p>For tables with multi-column primary keys you need to supply all the key values, either in the arguments to the <em>insert()</em> method, or by setting the values in a \*(C`before_create\*(C' trigger.</p><p>If the class has declared relationships with foreign classes via <em>has_a()</em>, you can pass an object to <em>insert()</em> for the value of that key. Class::DBI will Do The Right Thing.</p><p>After the new record has been inserted into the database the data for non-primary key columns is discarded from the object. If those columns are accessed again they'll simply be fetched as needed. This ensures that the data in the application is consistent with what the database <em>actually</em> stored.</p><p>The \*(C`after_create\*(C' trigger is invoked after the database insert has executed.</p>
<h3>find_or_create</h3>
<p>  my $cd = Music::CD-&gt;find_or_create({ artist =&gt; &apos;U2&apos;, title =&gt; &apos;Boy&apos; });</p><p>This checks if a \s-1CD\s0 can be found to match the information passed, and if not inserts it.</p>
<h3>delete</h3>
<p>  $obj-&gt;delete;   Music::CD-&gt;search(year =&gt; 1980, title =&gt; &apos;Greatest %&apos;)-&gt;delete_all;</p><p>Deletes this object from the database and from memory. If you have set up any relationships using \*(C`has_many\*(C' or \*(C`might_have\*(C', this will delete the foreign elements also, recursively (cascading delete).  $obj is no longer usable after this call.</p><p>Multiple objects can be deleted by calling delete_all on the Iterator returned from a search. Each object found will be deleted in turn, so cascading delete and other triggers will be honoured.</p><p>The \*(C`before_delete\*(C' trigger is when an object instance is about to be deleted. It is invoked before any cascaded deletes.  The \*(C`after_delete\*(C' trigger is invoked after the record has been deleted from the database and just before the contents in memory are discarded.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETRIEVING OBJECTS</h2>
        <div class="sectioncontent">
<p>Class::DBI provides a few very simple search methods.</p><p>It is not the goal of Class::DBI to replace the need for using \s-1SQL\s0. Users are expected to write their own searches for more complex cases.</p><p>Class::DBI::AbstractSearch, available on \s-1CPAN\s0, provides a much more complex search interface than Class::DBI provides itself.</p><h3>retrieve</h3>
<p>  $obj = Class-&gt;retrieve( $id );   $obj = Class-&gt;retrieve( %key_values );</p><p>Given key values it will retrieve the object with that key from the database.  For tables with a single column primary key a single parameter can be used, otherwise a hash of key-name key-value pairs must be given.</p><p>  my $cd = Music::CD-&gt;<strong>retrieve</strong>(1) or die "No such cd";</p>
<h3>retrieve_all</h3>
<p>  my @objs = Class-&gt;retrieve_all;   my $iterator = Class-&gt;retrieve_all;</p><p>Retrieves objects for all rows in the database. This is probably a bad idea if your table is big, unless you use the iterator version.</p>
<h3>search</h3>
<p>  @objs = Class-&gt;search(column1 =&gt; $value, column2 =&gt; $value ...);</p><p>This is a simple search for all objects where the columns specified are equal to the values specified e.g.:</p><p>  @cds = Music::CD-&gt;search(year =&gt; 1990);   @cds = Music::CD-&gt;search(title =&gt; "Greatest Hits", year =&gt; 1990);</p><p>You may also specify the sort order of the results by adding a final hash of arguments with the key 'order_by':</p><p>  @cds = Music::CD-&gt;search(year =&gt; 1990, { order_by=&gt;&apos;artist&apos; });</p><p>This is passed through 'as is', enabling order_by clauses such as 'year \s-1DESC\s0, title'.</p>
<h3>search_like</h3>
<p>  @objs = Class-&gt;search_like(column1 =&gt; $like_pattern, ....);</p><p>This is a simple search for all objects where the columns specified are like the values specified.  $like_pattern is a pattern given in \s-1SQL\s0 \s-1LIKE\s0 predicate syntax.  '%' means \*(L"any zero or more characters\*(R", '_' means \*(L"any single character\*(R".</p><p>  @cds = Music::CD-&gt;search_like(title =&gt; &apos;October%&apos;);   @cds = Music::CD-&gt;search_like(title =&gt; &apos;Hits%&apos;, artist =&gt; &apos;Various%&apos;);</p><p>You can also use 'order_by' with these, as with <em>search()</em>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ITERATORS</h2>
        <div class="sectioncontent">
<p>  my $it = Music::CD-&gt;search_like(title =&gt; &apos;October%&apos;);   while (my $cd = $it-&gt;next) {     print $cd-&gt;title;   }</p><p>Any of the above searches (as well as those defined by has_many) can also be used as an iterator.  Rather than creating a list of objects matching your criteria, this will return a Class::DBI::Iterator instance, which can return the objects required one at a time.</p><p>Currently the iterator initially fetches all the matching row data into memory, and defers only the creation of the objects from that data until the iterator is asked for the next object. So using an iterator will only save significant memory if your objects will inflate substantially when used.</p><p>In the case of has_many relationships with a mapping method, the mapping method is not called until each time you call 'next'. This means that if your mapping is not a one-to-one, the results will probably not be what you expect.</p><h3>Subclassing the Iterator</h3>
<p>  Music::CD-&gt;iterator_class(&apos;Music::CD::Iterator&apos;);</p><p>You can also subclass the default iterator class to override its functionality.  This is done via class data, and so is inherited into your subclasses.</p>
<h3>\s-1QUICK\s0 \s-1RETRIEVAL\s0</h3>
<p>  my $obj = Class-&gt;construct(&#92;%data);</p><p>This is used to turn data from the database into objects, and should thus only be used when writing constructors. It is very handy for cheaply setting up lots of objects from data for without going back to the database.</p><p>For example, instead of doing one \s-1SELECT\s0 to get a bunch of IDs and then feeding those individually to <em>retrieve()</em> (and thus doing more \s-1SELECT\s0 calls), you can do one \s-1SELECT\s0 to get the essential data of many objects and feed that data to <em>construct()</em>:</p><p>   return map $class-&gt;construct($_), $sth-&gt;fetchall_hash;</p><p>The <em>construct()</em> method creates a new empty object, loads in the column values, and then invokes the \*(C`select\*(C' trigger.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPY AND MOVE</h2>
        <div class="sectioncontent">
<h3>copy</h3>
<p>  $new_obj = $obj-&gt;copy;   $new_obj = $obj-&gt;copy($new_id);   $new_obj = $obj-&gt;copy({ title =&gt; &apos;new_title&apos;, rating =&gt; 18 });</p><p>This creates a copy of the given $obj, removes the primary key, sets any supplied column values and calls <em>insert()</em> to make a new record in the database.</p><p>For tables with a single column primary key, <em>copy()</em> can be called with no parameters and the new object will be assigned a key automatically.  Or a single parameter can be supplied and will be used as the new key.</p><p>For tables with a multi-column primary key, <em>copy()</em> must be called with parameters which supply new values for all primary key columns, unless a \*(C`before_create\*(C' trigger will supply them. The <em>insert()</em> method will fail if any primary key columns are not defined.</p><p>  my $blrunner_dc = $blrunner-&gt;copy("Bladerunner: Director&apos;s Cut");   my $blrunner_unrated = $blrunner-&gt;copy({     Title =&gt; "Bladerunner: Director&apos;s Cut",     Rating =&gt; &apos;Unrated&apos;,   });</p>
<h3>move</h3>
<p>  my $new_obj = Sub::Class-&gt;move($old_obj);   my $new_obj = Sub::Class-&gt;move($old_obj, $new_id);   my $new_obj = Sub::Class-&gt;move($old_obj, &#92;%changes);</p><p>For transferring objects from one class to another. Similar to <em>copy()</em>, an instance of Sub::Class is inserted using the data in $old_obj (Sub::Class is a subclass of $old_obj's subclass). Like <em>copy()</em>, you can supply $new_id as the primary key of $new_obj (otherwise the usual sequence or autoincrement is used), or a hashref of multiple new values.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRIGGERS</h2>
        <div class="sectioncontent">
<p>  _\|_PACKAGE_\|_-&gt;add_trigger(trigger_point_name =&gt; &#92;&code_to_execute);</p><p>  # e.g.</p><p>  _\|_PACKAGE_\|_-&gt;add_trigger(after_create  =&gt; &#92;&call_after_create);</p><p>It is possible to set up triggers that will be called at various points in the life of an object. Valid trigger points are:</p><p>  before_create       (also used for deflation)   after_create   before_set_$column  (also used by add_constraint)   after_set_$column   (also used for inflation and by has_a)   before_update       (also used for deflation and by might_have)   after_update   before_delete   after_delete   select              (also used for inflation and by construct and _flesh)</p><p>You can create any number of triggers for each point, but you cannot specify the order in which they will be run.</p><p>All triggers are passed the object they are being fired for, except when \*(C`before_set_$column\*(C' is fired during \*(L"insert\*(R", in which case the class is passed in place of the object, which does not yet exist. You may change object values if required.</p><p>Some triggers are also passed extra parameters as name-value pairs. The individual triggers are further documented with the methods that trigger them.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRAINTS</h2>
        <div class="sectioncontent">
<p>  _\|_PACKAGE_\|_-&gt;add_constraint(&apos;name&apos;, column =&gt; &#92;&check_sub);</p><p>  # e.g.</p><p>  _\|_PACKAGE_\|_-&gt;add_constraint(&apos;over18&apos;, age =&gt; &#92;&check_age);</p><p>  # Simple version   sub check_age {     my ($value) = @_;     return $value &gt;= 18;   }</p><p>  # Cross-field checking - must have SSN if age &lt; 18   sub check_age {     my ($value, $self, $column_name, $changing) = @_;     return 1 if $value &gt;= 18;     # We&apos;re old enough.     return 1 if $changing-&gt;{SSN}; # We&apos;re also being given an SSN     return 0 if !ref($self);      # This is an insert, so we can&apos;t have an SSN     return 1 if $self-&gt;ssn;       # We already have one in the database     return 0;                     # We can&apos;t find an SSN anywhere   }</p><p>It is also possible to set up constraints on the values that can be set on a column. The constraint on a column is triggered whenever an object is created and whenever the value in that column is being changed.</p><p>The constraint code is called with four parameters:</p><p>  - The new value to be assigned   - The object it will be assigned to   (or class name when initially creating an object)   - The name of the column   (useful if many constraints share the same code)   - A hash ref of all new column values being assigned   (useful for cross-field validation)</p><p>The constraints are applied to all the columns being set before the object data is changed. Attempting to create or modify an object where one or more constraint fail results in an exception and the object remains unchanged.</p><p>The exception thrown has its data set to a hashref of the column being changed and the value being changed to.</p><p>Note 1: Constraints are implemented using before_set_$column triggers. This will only prevent you from setting these values through a the provided <em>insert()</em> or <em>set()</em> methods. It will always be possible to bypass this if you try hard enough.</p><p>Note 2: When an object is created constraints are currently only checked for column names included in the parameters to <em>insert()</em>. This is probably a bug and is likely to change in future.</p><h3>constrain_column</h3>
<p>  Film-&gt;constrain_column(year =&gt; qr/^&#92;d{4}$/);   Film-&gt;constrain_column(rating =&gt; [qw/U Uc PG 12 15 18/]);   Film-&gt;constrain_column(title =&gt; sub { length() &lt;= 20 });</p><p>Simple anonymous constraints can also be added to a column using the <em>constrain_column()</em> method.  By default this takes either a regex which must match, a reference to a list of possible values, or a subref which will have $_ aliased to the value being set, and should return a true or false value.</p><p>However, this behaviour can be extended (or replaced) by providing a constraint handler for the type of argument passed to constrain_column. This behavior should be provided in a method named \*(L"_constrain_by_$type\*(R", where $type is the moniker of the argument. For example, the year example above could be provided by <em>_constrain_by_array()</em>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA NORMALIZATION</h2>
        <div class="sectioncontent">
<p>Before an object is assigned data from the application (via insert or a set accessor) the <em>normalize_column_values()</em> method is called with a reference to a hash containing the column names and the new values which are to be assigned (after any validation and constraint checking, as described below).</p><p>Currently Class::DBI does not offer any per-column mechanism here. The default method is empty.  You can override it in your own classes to normalize (edit) the data in any way you need. For example the values in the hash for certain columns could be made lowercase.</p><p>The method is called as an instance method when the values of an existing object are being changed, and as a class method when a new object is being created.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA VALIDATION</h2>
        <div class="sectioncontent">
<p>Before an object is assigned data from the application (via insert or a set accessor) the <em>validate_column_values()</em> method is called with a reference to a hash containing the column names and the new values which are to be assigned.</p><p>The method is called as an instance method when the values of an existing object are being changed, and as a class method when a new object is being inserted.</p><p>The default method calls the before_set_$column trigger for each column name in the hash. Each trigger is called inside an eval.  Any failures result in an exception after all have been checked.  The exception data is a reference to a hash which holds the column name and error text for each trigger error.</p><p>When using this mechanism for form data validation, for example, this exception data can be stored in an exception object, via a custom <em>_croak()</em> method, and then caught and used to redisplay the form with error messages next to each field which failed validation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXCEPTIONS</h2>
        <div class="sectioncontent">
<p>All errors that are generated, or caught and propagated, by Class::DBI are handled by calling the <em>_croak()</em> method (as an instance method if possible, or else as a class method).</p><p>The <em>_croak()</em> method is passed an error message and in some cases some extra information as described below. The default behaviour is simply to call Carp::croak($message).</p><p>Applications that require custom behaviour should override the <em>_croak()</em> method in their application base class (or table classes for table-specific behaviour). For example:</p><p>  use Error;</p><p>  sub _croak {     my ($self, $message, %info) = @_;     # convert errors into exception objects     # except for duplicate insert errors which we&apos;ll ignore     Error-&gt;throw(-text =&gt; $message, %info)       unless $message =~ /^Can&apos;t insert .* duplicate/;     return;   }</p><p>The <em>_croak()</em> method is expected to trigger an exception and not return. If it does return then it should use \*(C`return;\*(C' so that an undef or empty list is returned as required depending on the calling context. You should only return other values if you are prepared to deal with the (unsupported) consequences.</p><p>For exceptions that are caught and propagated by Class::DBI, $message includes the text of $@ and the original $@ value is available in $info{err}. That allows you to correctly propagate exception objects that may have been thrown 'below' Class::DBI (using Exception::Class::DBI for example).</p><p>Exceptions generated by some methods may provide additional data in $info{data} and, if so, also store the method name in $info{method}. For example, the <em>validate_column_values()</em> method stores details of failed validations in $info{data}. See individual method documentation for what additional data they may store, if any.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WARNINGS</h2>
        <div class="sectioncontent">
<p>All warnings are handled by calling the <em>_carp()</em> method (as an instance method if possible, or else as a class method). The default behaviour is simply to call <em>Carp::carp()</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTANCE METHODS</h2>
        <div class="sectioncontent">
<h3>accessors</h3>
<p>Class::DBI inherits from Class::Accessor and thus provides individual accessor methods for every column in your subclass.  It also overrides the <em>get()</em> and <em>set()</em> methods provided by Accessor to automagically handle database reading and writing. (Note that as it doesn't make sense to store a list of values in a column, <em>set()</em> takes a hash of column =&gt; value pairs, rather than the single key =&gt; values of Class::Accessor).</p>
<h3>the fundamental \fIset()\fP and \fIget()\fP methods</h3>
<p>  $value = $obj-&gt;get($column_name);   @values = $obj-&gt;get(@column_names);</p><p>  $obj-&gt;set($column_name =&gt; $value);   $obj-&gt;set($col1 =&gt; $value1, $col2 =&gt; $value2 ... );</p><p>These methods are the fundamental entry points for getting and setting column values.  The extra accessor methods automatically generated for each column of your table are simple wrappers that call these <em>get()</em> and <em>set()</em> methods.</p><p>The <em>set()</em> method calls <em>normalize_column_values()</em> then <em>validate_column_values()</em> before storing the values.  The \*(C`before_set_$column\*(C' trigger is invoked by <em>validate_column_values()</em>, checking any constraints that may have been set up.</p><p>The \*(C`after_set_$column\*(C' trigger is invoked after the new value has been stored.</p><p>It is possible for an object to not have all its column data in memory (due to lazy inflation).  If the <em>get()</em> method is called for such a column then it will select the corresponding group of columns and then invoke the \*(C`select\*(C' trigger.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Changing Your Column Accessor Method Names</h2>
        <div class="sectioncontent">
<h3>accessor_name_for / mutator_name_for</h3>
<p>It is possible to change the name of the accessor method created for a column either declaratively or programmatically.</p><p>If, for example, you have a column with a name that clashes with a method otherwise created by Class::DBI, such as 'meta_info', you could create that Column explicitly with a different accessor (and/or mutator) when setting up your columns:</p><p>        my $meta_col = Class::DBI::Column-&gt;new(meta_info =&gt; {                 accessor =&gt; &apos;metadata&apos;,         });</p><p>  _\|_PACKAGE_\|_-&gt;columns(All =&gt; qw/id name/, $meta_col);</p><p>If you want to change the name of all your accessors, or all that match a certain pattern, you need to provide an accessor_name_for($col) method, which will convert a column name to a method name.</p><p>e.g: if your local database naming convention was to prepend the word 'customer' to each column in the 'customer' table, so that you had the columns 'customerid', 'customername' and 'customerage', but you wanted your methods to just be $customer-&gt;name and $customer-&gt;age rather than $customer-&gt;customername etc., you could create a</p><p>  sub accessor_name_for {     my ($class, $column) = @_;     $column =~ s/^customer//;     return $column;   }</p><p>Similarly, if you wanted to have distinct accessor and mutator methods, you could provide a mutator_name_for($col) method which would return the name of the method to change the value:</p><p>  sub mutator_name_for {     my ($class, $column) = @_;     return "set_" . $column-&gt;accessor;   }</p><p>If you override the mutator name, then the accessor method will be enforced as read-only, and the mutator as write-only.</p>
<h3>update vs auto update</h3>
<p>There are two modes for the accessors to work in: manual update and autoupdate. When in autoupdate mode, every time one calls an accessor to make a change an \s-1UPDATE\s0 will immediately be sent to the database. Otherwise, if autoupdate is off, no changes will be written until <em>update()</em> is explicitly called.</p><p>This is an example of manual updating:</p><p>  # The calls to NumExplodingSheep() and Rating() will only make the   # changes in memory, not in the database.  Once update() is called   # it writes to the database in one swell foop.   $gone-&gt;<strong>NumExplodingSheep</strong>(5);   $gone-&gt;Rating(&apos;NC-17&apos;);   $gone-&gt;update;</p><p>And of autoupdating:</p><p>  # Turn autoupdating on for this object.   $gone-&gt;<a href="../man1/autoupdate.1.html"><strong>autoupdate</strong>(1)</a>;</p><p>  # Each accessor call causes the new value to immediately be written.   $gone-&gt;<strong>NumExplodingSheep</strong>(5);   $gone-&gt;Rating(&apos;NC-17&apos;);</p><p>Manual updating is probably more efficient than autoupdating and it provides the extra safety of a <em>discard_changes()</em> option to clear out all unsaved changes.  Autoupdating can be more convenient for the programmer. Autoupdating is <em>off</em> by default.</p><p>If changes are neither updated nor rolled back when the object is destroyed (falls out of scope or the program ends) then Class::DBI's \s-1DESTROY\s0 method will print a warning about unsaved changes.</p>
<h3>autoupdate</h3>
<p>  _\|_PACKAGE_\|_-&gt;autoupdate($on_or_off);   $update_style = Class-&gt;autoupdate;</p><p>  $obj-&gt;autoupdate($on_or_off);   $update_style = $obj-&gt;autoupdate;</p><p>This is an accessor to the current style of auto-updating.  When called with no arguments it returns the current auto-updating state, true for on, false for off.  When given an argument it turns auto-updating on and off: a true value turns it on, a false one off.</p><p>When called as a class method it will control the updating style for every instance of the class.  When called on an individual object it will control updating for just that object, overriding the choice for the class.</p><p>  _\|_PACKAGE_\|_-&gt;<a href="../man1/autoupdate.1.html"><strong>autoupdate</strong>(1)</a>;     # Autoupdate is now on for the class.</p><p>  $obj = Class-&gt;retrieve(&apos;Aliens Cut My Hair&apos;);   $obj-&gt;<strong>autoupdate</strong>(0);      # Shut off autoupdating for this object.</p><p>The update setting for an object is not stored in the database.</p>
<h3>update</h3>
<p>  $obj-&gt;update;</p><p>If \*(L"autoupdate\*(R" is not enabled then changes you make to your object are not reflected in the database until you call <em>update()</em>.  It is harmless to call <em>update()</em> if there are no changes to be saved.  (If autoupdate is on there'll never be anything to save.)</p><p>Note: If you have transactions turned on for your database (but see \*(L"\s-1TRANSACTIONS\s0\*(R" below) you will also need to call <em>dbi_commit()</em>, as <em>update()</em> merely issues the \s-1UPDATE\s0 to the database).</p><p>After the database update has been executed, the data for columns that have been updated are deleted from the object. If those columns are accessed again they'll simply be fetched as needed. This ensures that the data in the application is consistent with what the database <em>actually</em> stored.</p><p>When <em>update()</em> is called the \*(C`before_update\*(C'($self) trigger is always invoked immediately.</p><p>If any columns have been updated then the \*(C`after_update\*(C' trigger is invoked after the database update has executed and is passed:</p>
<pre>
  ($self, discard_columns =&gt; &#92;@discard_columns)
</pre>
<p>The trigger code can modify the discard_columns array to affect which columns are discarded.</p><p>For example:</p><p>  Class-&gt;add_trigger(after_update =&gt; sub {     my ($self, %args) = @_;     my $discard_columns = $args{discard_columns};     # discard the md5_hash column if any field starting with &apos;foo&apos;     # has been updated - because the md5_hash will have been changed     # by a trigger.     push @$discard_columns, &apos;md5_hash&apos; if grep { /^foo/ } @$discard_columns;   });</p><p>Take care to not delete a primary key column unless you know what you're doing.</p><p>The <em>update()</em> method returns the number of rows updated.  If the object had not changed and thus did not need to issue an \s-1UPDATE\s0 statement, the <em>update()</em> call will have a return value of -1.</p><p>If the record in the database has been deleted, or its primary key value changed, then the update will not affect any records and so the <em>update()</em> method will return 0.</p>
<h3>discard_changes</h3>
<p>  $obj-&gt;discard_changes;</p><p>Removes any changes you've made to this object since the last update. Currently this simply discards the column values from the object.</p><p>If you're using autoupdate this method will throw an exception.</p>
<h3>is_changed</h3>
<p>  my $changed = $obj-&gt;is_changed;   my @changed_keys = $obj-&gt;is_changed;</p><p>Indicates if the given $obj has changes since the last update. Returns a list of keys which have changed. (If autoupdate is on, this method will return an empty list, unless called inside a before_update or after_set_$column trigger)</p>
<h3>id</h3>
<p>  $id = $obj-&gt;id;   @id = $obj-&gt;id;</p><p>Returns a unique identifier for this object based on the values in the database. It's the equivalent of $obj-&gt;get($self-&gt;columns('Primary')), with inflated values reduced to their ids.</p><p>A warning will be generated if this method is used in scalar context on a table with a multi-column primary key.</p>
<h3>LOW-LEVEL \s-1DATA\s0 \s-1ACCESS\s0</h3>
<p>On some occasions, such as when you're writing triggers or constraint routines, you'll want to manipulate data in a Class::DBI object without using the usual <em>get()</em> and <em>set()</em> accessors, which may themselves call triggers, fetch information from the database, etc.</p><p>Rather than interacting directly with the data hash stored in a Class::DBI object (the exact implementation of which may change in future releases) you could use Class::DBI's low-level accessors. These appear 'private' to make you think carefully about using them - they should not be a common means of dealing with the object.</p><p>The data within the object is modelled as a set of key-value pairs, where the keys are normalized column names (returned by <em>find_column()</em>), and the values are the data from the database row represented by the object. Access is via these functions:</p>
<dl class='dl-vertical'>
  <dt>
    _attrs
  </dt>
  <dd>
    <p>  @values = $object-&gt;_attrs(@cols); Returns the values for one or more keys.</p>
  </dd>
  <dt>
    _attribute_store
  </dt>
  <dd>
    <p>  $object-&gt;_attribute_store( { $col0 =&gt; $val0, $col1 =&gt; $val1 } );   $object-&gt;_attribute_store($col0, $val0, $col1, $val1); Stores values in the object.  They key-value pairs may be passed in either as a simple list or as a hash reference.  This only updates values in the object itself; changes will not be propagated to the database.</p>
  </dd>
  <dt>
    _attribute_set
  </dt>
  <dd>
    <p>  $object-&gt;_attribute_set( { $col0 =&gt; $val0, $col1 =&gt; $val1 } );   $object-&gt;_attribute_set($col0, $val0, $col1, $val1); Updates values in the object via <em>_attribute_store()</em>, but also logs the changes so that they are propagated to the database with the next update.  (Unlike <em>set()</em>, however, <em>_attribute_set()</em> will not trigger an update if autoupdate is turned on.)</p>
  </dd>
  <dt>
    _attribute_delete
  </dt>
  <dd>
    <p>  @values = $object-&gt;_attribute_delete(@cols); Deletes values from the object, and returns the deleted values.</p>
  </dd>
  <dt>
    _attribute_exists
  </dt>
  <dd>
    <p>  $bool = $object-&gt;_attribute_exists($col); Returns a true value if the object contains a value for the specified column, and a false value otherwise.</p>
  </dd>

</dl>
<p>By default, Class::DBI uses simple hash references to store object data, but all access is via these routines, so if you want to implement a different data model, just override these functions.</p>
<h3>\s-1OVERLOADED\s0 \s-1OPERATORS\s0</h3>
<p>Class::DBI and its subclasses overload the perl builtin <em>stringify</em> and <em>bool</em> operators. This is a significant convenience.</p><p>The perl builtin <em>bool</em> operator is overloaded so that a Class::DBI object reference is true so long as all its key columns have defined values.  (This means an object with an <em>id()</em> of zero is not considered false.)</p><p>When a Class::DBI object reference is used in a string context it will, by default, return the value of the primary key. (Composite primary key values will be separated by a slash).</p><p>You can also specify the column(s) to be used for stringification via the special 'Stringify' column group. So, for example, if you're using an auto-incremented primary key, you could use this to provide a more meaningful display string:</p><p>  Widget-&gt;columns(Stringify =&gt; qw/name/);</p><p>If you need to do anything more complex, you can provide an <em>stringify_self()</em> method which stringification will call:</p><p>  sub stringify_self {     my $self = shift;     return join ":", $self-&gt;id, $self-&gt;name;   }</p><p>This overloading behaviour can be useful for columns that have <em>has_a()</em> relationships.  For example, consider a table that has price and currency fields:</p><p>  package Widget;   use base &apos;My::Class::DBI&apos;;   Widget-&gt;table(&apos;widget&apos;);   Widget-&gt;columns(All =&gt; qw/widgetid name price currency_code/);</p><p>  $obj = Widget-&gt;retrieve($id);   print $obj-&gt;price . " " . $obj-&gt;currency_code;</p><p>The would print something like "\*(C`42.07 USD\*(C'\*(L".  If the currency_code field is later changed to be a foreign key to a new currency table then $obj-&gt;currency_code will return an object reference instead of a plain string. Without overloading the stringify operator the example would now print something like \*(R"\*(C`42.07 Widget=HASH(0x1275}\*(C'" and the fix would be to change the code to add a call to <em>id()</em>:</p><p>  print $obj-&gt;price . " " . $obj-&gt;currency_code-&gt;id;</p><p>However, with overloaded stringification, the original code continues to work as before, with no code changes needed.</p><p>This makes it much simpler and safer to add relationships to existing applications, or remove them later.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TABLE RELATIONSHIPS</h2>
        <div class="sectioncontent">
<p>Databases are all about relationships. Thus Class::DBI provides a way for you to set up descriptions of your relationhips.</p><p>Class::DBI provides three such relationships: 'has_a', 'has_many', and 'might_have'. Others are available from \s-1CPAN\s0.</p><h3>has_a</h3>
<p>  Music::CD-&gt;has_a(column =&gt; &apos;Foreign::Class&apos;);</p><p>  Music::CD-&gt;has_a(artist =&gt; &apos;Music::Artist&apos;);   print $cd-&gt;artist-&gt;name;</p><p>'has_a' is most commonly used to supply lookup information for a foreign key. If a column is declared as storing the primary key of another table, then calling the method for that column does not return the id, but instead the relevant object from that foreign class.</p><p>It is also possible to use has_a to inflate the column value to a non Class::DBI based. A common usage would be to inflate a date field to a date/time object:</p><p>  Music::CD-&gt;has_a(reldate =&gt; &apos;Date::Simple&apos;);   print $cd-&gt;reldate-&gt;format("%d %b, %Y");</p><p>  Music::CD-&gt;has_a(reldate =&gt; &apos;Time::Piece&apos;,     inflate =&gt; sub { Time::Piece-&gt;strptime(shift, "%Y-%m-%d") },     deflate =&gt; &apos;ymd&apos;,   );   print $cd-&gt;reldate-&gt;strftime("%d %b, %Y");</p><p>If the foreign class is another Class::DBI representation retrieve is called on that class with the column value. Any other object will be instantiated either by calling new($value) or using the given 'inflate' method. If the inflate method name is a subref, it will be executed, and will be passed the value and the Class::DBI object as arguments.</p><p>When the object is being written to the database the object will be deflated either by calling the 'deflate' method (if given), or by attempting to stringify the object. If the deflate method is a subref, it will be passed the Class::DBI object as an argument.</p><p>*NOTE* You should not attempt to make your primary key column inflate using <em>has_a()</em> as bad things will happen. If you have two tables which share a primary key, consider using <em>might_have()</em> instead.</p>
<h3>has_many</h3>
<p>  Class-&gt;has_many(method_to_create =&gt; "Foreign::Class");</p><p>  Music::CD-&gt;has_many(tracks =&gt; &apos;Music::Track&apos;);</p><p>  my @tracks = $cd-&gt;tracks;</p><p>  my $track6 = $cd-&gt;add_to_tracks({     position =&gt; 6,     title    =&gt; &apos;Tomorrow&apos;,   });</p><p>This method declares that another table is referencing us (i.e. storing our primary key in its table).</p><p>It creates a named accessor method in our class which returns a list of all the matching Foreign::Class objects.</p><p>In addition it creates another method which allows a new associated object to be constructed, taking care of the linking automatically. This method is the same as the accessor method with \*(L"add_to_\*(R" prepended.</p><p>The add_to_tracks example above is exactly equivalent to:</p><p>  my $track6 = Music::Track-&gt;insert({     cd       =&gt; $cd,     position =&gt; 6,     title    =&gt; &apos;Tomorrow&apos;,   });</p><p>When setting up the relationship the foreign class's <em>has_a()</em> declarations are examined to discover which of its columns reference our class. (Note that because this happens at compile time, if the foreign class is defined in the same file, the class with the <em>has_a()</em> must be defined earlier than the class with the <em>has_many()</em>. If the classes are in different files, Class::DBI should usually be able to do the right things, as long as all classes inherit Class::DBI before 'use'ing any other classes.)</p><p>If the foreign class has no <em>has_a()</em> declarations linking to this class, it is assumed that the foreign key in that class is named after the <em>moniker()</em> of this class.</p><p>If this is not true you can pass an additional third argument to the <em>has_many()</em> declaration stating which column of the foreign class is the foreign key to this class.</p><p><em>Limiting</em></p><p>  Music::Artist-&gt;has_many(cds =&gt; &apos;Music::CD&apos;);   my @cds = $artist-&gt;cds(year =&gt; 1980);</p><p>When calling the method created by has_many, you can also supply any additional key/value pairs for restricting the search. The above example will only return the CDs with a year of 1980.</p><p><em>Ordering</em></p><p>  Music::CD-&gt;has_many(tracks =&gt; &apos;Music::Track&apos;, { order_by =&gt; &apos;playorder&apos; });</p><p>has_many takes an optional final hashref of options. If an 'order_by' option is set, its value will be set in an \s-1ORDER\s0 \s-1BY\s0 clause in the \s-1SQL\s0 issued. This is passed through 'as is', enabling order_by clauses such as 'length \s-1DESC\s0, position'.</p><p><em>Mapping</em></p><p>  Music::CD-&gt;has_many(styles =&gt; [ &apos;Music::StyleRef&apos; =&gt; &apos;style&apos; ]);</p><p>If the second argument to has_many is turned into a listref of the Classname and an additional method, then that method will be called in turn on each of the objects being returned.</p><p>The above is exactly equivalent to:</p><p>  Music::CD-&gt;has_many(_style_refs =&gt; &apos;Music::StyleRef&apos;);</p><p>  sub styles {     my $self = shift;     return map $_-&gt;style, $self-&gt;_style_refs;   }</p><p>For an example of where this is useful see \*(L"\s-1MANY\s0 \s-1TO\s0 \s-1MANY\s0 \s-1RELATIONSHIPS\s0\*(R" below.</p><p><em>Cascading Delete</em></p><p>  Music::Artist-&gt;has_many(cds =&gt; &apos;Music::CD&apos;, { cascade =&gt; &apos;Fail&apos; });</p><p>It is also possible to control what happens to the 'child' objects when the 'parent' object is deleted. By default this is set to 'Delete' - so, for example, when you delete an artist, you also delete all their CDs, leaving no orphaned records. However you could also set this to 'None', which would leave all those orphaned records (although this generally isn't a good idea), or 'Fail', which will throw an exception when you try to delete an artist that still has any CDs.</p><p>You can also write your own Cascade strategies by supplying a Class Name here.</p><p>For example you could write a Class::DBI::Cascade::Plugin::Nullify which would set all related foreign keys to be \s-1NULL\s0, and plug it into your relationship:</p><p>  Music::Artist-&gt;has_many(cds =&gt; &apos;Music::CD&apos;, {     cascade =&gt; &apos;Class::DBI::Cascade::Plugin::Nullify&apos;   });</p>
<h3>might_have</h3>
<p>  Music::CD-&gt;might_have(method_name =&gt; Class =&gt; (@fields_to_import));</p><p>  Music::CD-&gt;might_have(liner_notes =&gt; LinerNotes =&gt; qw/notes/);</p><p>  my $liner_notes_object = $cd-&gt;liner_notes;   my $notes = $cd-&gt;notes; # equivalent to $cd-&gt;liner_notes-&gt;notes;</p><p><em>might_have()</em> is similar to <em>has_many()</em> for relationships that can have at most one associated objects. For example, if you have a \s-1CD\s0 database to which you want to add liner notes information, you might not want to add a 'liner_notes' column to your main \s-1CD\s0 table even though there is no multiplicity of relationship involved (each \s-1CD\s0 has at most one 'liner notes' field). So, you create another table with the same primary key as this one, with which you can cross-reference.</p><p>But you don't want to have to keep writing methods to turn the the 'list' of liner_notes objects you'd get back from has_many into the single object you'd need. So, <em>might_have()</em> does this work for you. It creates an accessor to fetch the single object back if it exists, and it also allows you import any of its methods into your namespace. So, in the example above, the LinerNotes class can be mostly invisible - you can just call $cd-&gt;notes and it will call the notes method on the correct LinerNotes object transparently for you.</p><p>Making sure you don't have namespace clashes is up to you, as is correctly creating the objects, but this may be made simpler in later versions. (Particularly if someone asks for this!)</p>
<h3>Notes</h3>
<p><em>has_a()</em>, <em>might_have()</em> and <em>has_many()</em> check that the relevant class has already been loaded. If it hasn't then they try to load the module of the same name using require.  If the require fails because it can't find the module then it will assume it's not a simple require (i.e., Foreign::Class isn't in Foreign/Class.pm) and that you will take care of it and ignore the warning. Any other error, such as a syntax error, triggers an exception.</p><p>\s-1NOTE:\s0 The two classes in a relationship do not have to be in the same database, on the same machine, or even in the same type of database! It is quite acceptable for a table in a MySQL database to be connected to a different table in an Oracle database, and for cascading delete etc to work across these. This should assist greatly if you need to migrate a database gradually.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MANY TO MANY RELATIONSHIPS</h2>
        <div class="sectioncontent">
<p>Class::DBI does not currently support Many to Many relationships, per se. However, by combining the relationships that already exist it is possible to set these up.</p><p>Consider the case of Films and Actors, with a linking Role table with a multi-column Primary Key. First of all set up the Role class:</p><p>  Role-&gt;table(&apos;role&apos;);   Role-&gt;columns(Primary =&gt; qw/film actor/);   Role-&gt;has_a(film =&gt; &apos;Film&apos;);   Role-&gt;has_a(actor =&gt; &apos;Actor&apos;);</p><p>Then, set up the Film and Actor classes to use this linking table:</p><p>  Film-&gt;table(&apos;film&apos;);   Film-&gt;columns(All =&gt; qw/id title rating/);   Film-&gt;has_many(stars =&gt; [ Role =&gt; &apos;actor&apos; ]);</p><p>  Actor-&gt;table(&apos;actor&apos;);   Actor-&gt;columns(All =&gt; qw/id name/);   Actor-&gt;has_many(films =&gt; [ Role =&gt; &apos;film&apos; ]);</p><p>In each case the 'mapping method' variation of <em>has_many()</em> is used to call the lookup method on the Role object returned. As these methods are the 'has_a' relationships on the Role, these will return the actual Actor and Film objects, providing a cheap many-to-many relationship.</p><p>In the case of Film, this is equivalent to the more long-winded:</p><p>  Film-&gt;has_many(roles =&gt; "Role");</p><p>  sub actors {     my $self = shift;     return map $_-&gt;actor, $self-&gt;roles   }</p><p>As this is almost exactly what is created internally, add_to_stars and add_to_films will generally do the right thing as they are actually doing the equivalent of add_to_roles:</p><p>  $film-&gt;add_to_actors({ actor =&gt; $actor });</p><p>Similarly a cascading delete will also do the right thing as it will only delete the relationship from the linking table.</p><p>If the Role table were to contain extra information, such as the name of the character played, then you would usually need to skip these short-cuts and set up each of the relationships, and associated helper methods, manually.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADDING NEW RELATIONSHIP TYPES</h2>
        <div class="sectioncontent">
<h3>add_relationship_type</h3>
<p>The relationships described above are implemented through Class::DBI::Relationship subclasses.  These are then plugged into Class::DBI through an <em>add_relationship_type()</em> call:</p><p>  _\|_PACKAGE_\|_-&gt;add_relationship_type(     has_a      =&gt; "Class::DBI::Relationship::HasA",     has_many   =&gt; "Class::DBI::Relationship::HasMany",     might_have =&gt; "Class::DBI::Relationship::MightHave",   );</p><p>If is thus possible to add new relationship types, or modify the behaviour of the existing types.  See Class::DBI::Relationship for more information on what is required.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEFINING SQL STATEMENTS</h2>
        <div class="sectioncontent">
<p>There are several main approaches to setting up your own \s-1SQL\s0 queries:</p><p>For queries which could be used to create a list of matching objects you can create a constructor method associated with this \s-1SQL\s0 and let Class::DBI do the work for you, or just inline the entire query.</p><p>For more complex queries you need to fall back on the underlying Ima::DBI query mechanism. (Caveat: since Ima::DBI uses sprintf-style interpolation, you need to be careful to double any \*(L"wildcard\*(R" % signs in your queries).</p><h3>add_constructor</h3>
<p>  _\|_PACKAGE_\|_-&gt;add_constructor(method_name =&gt; &apos;SQL_where_clause&apos;);</p><p>The \s-1SQL\s0 can be of arbitrary complexity and will be turned into:</p><p>  SELECT (essential columns)     FROM (table name)    WHERE &lt;your SQL&gt;</p><p>This will then create a method of the name you specify, which returns a list of objects as with any built in query.</p><p>For example:</p><p>  Music::CD-&gt;add_constructor(new_music =&gt; &apos;year &gt; 2000&apos;);   my @recent = Music::CD-&gt;new_music;</p><p>You can also supply placeholders in your \s-1SQL\s0, which must then be specified at query time:</p><p>  Music::CD-&gt;add_constructor(new_music =&gt; &apos;year &gt; ?&apos;);   my @recent = Music::CD-&gt;new_music(2000);</p>
<h3>retrieve_from_sql</h3>
<p>On occasions where you want to execute arbitrary \s-1SQL\s0, but don't want to go to the trouble of setting up a constructor method, you can inline the entire \s-1WHERE\s0 clause, and just get the objects back directly:</p><p>  my @cds = Music::CD-&gt;retrieve_from_sql(qq{     artist = &apos;Ozzy Osbourne&apos; AND     title like "%Crazy"      AND     year &lt;= 1986     ORDER BY year     LIMIT 2,3   });</p>
<h3>Ima::DBI queries</h3>
<p>When you can't use 'add_constructor', e.g. when using aggregate functions, you can fall back on the fact that Class::DBI inherits from Ima::DBI and prefers to use its style of dealing with statements, via <em>set_sql()</em>.</p><p>The Class::DBI <em>set_sql()</em> method defaults to using <em>prepare_cached()</em> unless the $cache parameter is defined and false (see Ima::DBI docs for more information).</p><p>To assist with writing \s-1SQL\s0 that is inheritable into subclasses, several additional substitutions are available here: _\|_TABLE_\|_, _\|_ESSENTIAL_\|_ and _\|_IDENTIFIER_\|_.  These represent the table name associated with the class, its essential columns, and the primary key of the current object, in the case of an instance method on it.</p><p>For example, the \s-1SQL\s0 for the internal 'update' method is implemented as:</p><p>  _\|_PACKAGE_\|_-&gt;set_sql(&apos;update&apos;, &lt;&lt;"");     UPDATE _\|_TABLE_\|_     SET    %s     WHERE  _\|_IDENTIFIER_\|_</p><p>The 'longhand' version of the new_music constructor shown above would similarly be:</p><p>  Music::CD-&gt;set_sql(new_music =&gt; qq{     SELECT _\|_ESSENTIAL_\|_       FROM _\|_TABLE_\|_      WHERE year &gt; ?   });</p><p>For such '\s-1SELECT\s0' queries Ima::DBI's <em>set_sql()</em> method is extended to create a helper shortcut method, named by prefixing the name of the \s-1SQL\s0 fragment with 'search_'. Thus, the above call to <em>set_sql()</em> will automatically set up the method Music::CD-&gt;<em>search_new_music()</em>, which will execute this search and return the relevant objects or Iterator. (If there are placeholders in the query, you must pass the relevant arguments when calling your search method.)</p><p>This does the equivalent of:</p><p>  sub search_new_music {     my ($class, @args) = @_;     my $sth = $class-&gt;sql_new_music;     $sth-&gt;execute(@args);     return $class-&gt;sth_to_objects($sth);   }</p><p>The $sth which is used to return the objects here is a normal DBI-style statement handle, so if the results can't be turned into objects easily, it is still possible to call $sth-&gt;fetchrow_array etc and return whatever data you choose.</p><p>Of course, any query can be added via set_sql, including joins.  So, to add a query that returns the 10 Artists with the most CDs, you could write (with MySQL):</p><p>  Music::Artist-&gt;set_sql(most_cds =&gt; qq{     SELECT artist.id, COUNT(cd.id) AS cds       FROM artist, cd      WHERE artist.id = cd.artist      GROUP BY artist.id      ORDER BY cds DESC      LIMIT 10   });</p><p>  my @artists = Music::Artist-&gt;search_most_cds();</p><p>If you also need to access the 'cds' value returned from this query, the best approach is to declare 'cds' to be a \s-1TEMP\s0 column. (See \*(L"Non-Persistent Fields\*(R" below).</p>
<h3>Class::DBI::AbstractSearch</h3>
<p>  my @music = Music::CD-&gt;search_where(     artist =&gt; [ &apos;Ozzy&apos;, &apos;Kelly&apos; ],     status =&gt; { &apos;!=&apos;, &apos;outdated&apos; },   );</p><p>The Class::DBI::AbstractSearch module, available from \s-1CPAN\s0, is a plugin for Class::DBI that allows you to write arbitrarily complex searches using perl data structures, rather than \s-1SQL\s0.</p>
<h3>Single Value SELECTs</h3>
<p><em>select_val</em></p><p>Selects which only return a single value can couple Class::DBI's <em>sql_single()</em> \s-1SQL\s0, with the $sth-&gt;<em>select_val()</em> call which we get from DBIx::ContextualFetch.</p><p>  _\|_PACKAGE_\|_-&gt;set_sql(count_all =&gt; "SELECT COUNT(*) FROM _\|_TABLE_\|_");   # .. then ..   my $count = $class-&gt;sql_count_all-&gt;select_val;</p><p>This can also take placeholders and/or do column interpolation if required:</p><p>  _\|_PACKAGE_\|_-&gt;set_sql(count_above =&gt; q{     SELECT COUNT(*) FROM _\|_TABLE_\|_ WHERE %s &gt; ?   });   # .. then ..   my $count = $class-&gt;sql_count_above(&apos;year&apos;)-&gt;select_val(2001);</p><p><em>sql_single</em></p><p>Internally Class::DBI defines a very simple \s-1SQL\s0 fragment called 'single':</p><p>  "SELECT %s FROM _\|_TABLE_\|_".</p><p>This is used to implement the above Class-&gt;<em>count_all()</em>:</p><p>  $class-&gt;sql_single("COUNT(*)")-&gt;select_val;</p><p>This interpolates the \s-1COUNT\s0(*) into the %s of the \s-1SQL\s0, and then executes the query, returning a single value.</p><p>Any \s-1SQL\s0 set up via <em>set_sql()</em> can of course be supplied here, and select_val can take arguments for any placeholders there.</p><p>Internally several helper methods are defined using this approach:</p>
<dl class='dl-vertical'>
  <dt>
    - count_all
  </dt>
  <dd>
    
  </dd>
  <dt>
    - maximum_value_of($column)
  </dt>
  <dd>
    
  </dd>
  <dt>
    - minimum_value_of($column)
  </dt>
  <dd>
    
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LAZY POPULATION</h2>
        <div class="sectioncontent">
<p>In the tradition of Perl, Class::DBI is lazy about how it loads your objects.  Often, you find yourself using only a small number of the available columns and it would be a waste of memory to load all of them just to get at two, especially if you're dealing with large numbers of objects simultaneously.</p><p>You should therefore group together your columns by typical usage, as fetching one value from a group can also pre-fetch all the others in that group for you, for more efficient access.</p><p>So for example, if we usually fetch the artist and title, but don't use the 'year' so much, then we could say the following:</p><p>  Music::CD-&gt;columns(Primary   =&gt; qw/cdid/);   Music::CD-&gt;columns(Essential =&gt; qw/artist title/);   Music::CD-&gt;columns(Others    =&gt; qw/year runlength/);</p><p>Now when you fetch back a \s-1CD\s0 it will come pre-loaded with the 'cdid', 'artist' and 'title' fields. Fetching the 'year' will mean another visit to the database, but will bring back the 'runlength' whilst it's there.</p><p>This can potentially increase performance.</p><p>If you don't like this behavior, then just add all your columns to the Essential group, and Class::DBI will load everything at once. If you have a single column primary key you can do this all in one shot with one single column declaration:</p><p>  Music::CD-&gt;columns(Essential =&gt; qw/cdid artist title year runlength/);</p><h3>columns</h3>
<p>  my @all_columns  = $class-&gt;columns;   my @columns      = $class-&gt;columns($group);</p><p>  my @primary      = $class-&gt;primary_columns;   my $primary      = $class-&gt;primary_column;   my @essential    = $class-&gt;_essential;</p><p>There are four 'reserved' groups: 'All', 'Essential', 'Primary' and '\s-1TEMP\s0'.</p><p><strong>'All'</strong> are all columns used by the class. If not set it will be created from all the other groups.</p><p><strong>'Primary'</strong> is the primary key columns for this class. It <em>must</em> be set before objects can be used.</p><p>If 'All' is given but not 'Primary' it will assume the first column in 'All' is the primary key.</p><p><strong>'Essential'</strong> are the minimal set of columns needed to load and use the object. Only the columns in this group will be loaded when an object is <em>retrieve()</em>'d. It is typically used to save memory on a class that has a lot of columns but where only use a few of them are commonly used. It will automatically be set to <strong>'Primary'</strong> if not explicitly set. The 'Primary' column is always part of the 'Essential' group.</p><p>For simplicity <em>primary_columns()</em>, <em>primary_column()</em>, and <em>_essential()</em> methods are provided to return these. The <em>primary_column()</em> method should only be used for tables that have a single primary key column.</p>
<h3>Non-Persistent Fields</h3>
<p>  Music::CD-&gt;columns(TEMP =&gt; qw/nonpersistent/);</p><p>If you wish to have fields that act like columns in every other way, but that don't actually exist in the database (and thus will not persist), you can declare them as part of a column group of '\s-1TEMP\s0'.</p>
<h3>find_column</h3>
<p>  Class-&gt;find_column($column);   $obj-&gt;find_column($column);</p><p>The columns of a class are stored as Class::DBI::Column objects. This method will return you the object for the given column, if it exists. This is most useful either in a boolean context to discover if the column exists, or to 'normalize' a user-entered column name to an actual Column.</p><p>The interface of the Column object itself is still under development, so you shouldn't really rely on anything internal to it.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRANSACTIONS</h2>
        <div class="sectioncontent">
<p>Class::DBI suffers from the usual problems when dealing with transactions. In particular, you should be very wary when committing your changes that you may actually be in a wider scope than expected and that your caller may not be expecting you to commit.</p><p>However, as long as you are aware of this, and try to keep the scope of your transactions small, ideally always within the scope of a single method, you should be able to work with transactions with few problems.</p><h3>dbi_commit / dbi_rollback</h3>
<p>  $obj-&gt;dbi_commit();   $obj-&gt;dbi_rollback();</p><p>These are thin aliases through to the \s-1DBI\s0's <em>commit()</em> and <em>rollback()</em> commands to commit or rollback all changes to this object.</p>
<h3>Localised Transactions</h3>
<p>A nice idiom for turning on a transaction locally (with AutoCommit turned on globally) (courtesy of Dominic Mitchell) is:</p><p>  sub do_transaction {     my $class = shift;     my ( $code ) = @_;     # Turn off AutoCommit for this scope.     # A commit will occur at the exit of this block automatically,     # when the local AutoCommit goes out of scope.     local $class-&gt;db_Main-&gt;{ AutoCommit };</p><p>    # Execute the required code inside the transaction.     eval { $code-&gt;() };     if ( $@ ) {       my $commit_error = $@;       eval { $class-&gt;dbi_rollback }; # might also die!       die $commit_error;     }   }</p><p>  And then you just call:</p><p>  Music::DBI-&gt;do_transaction( sub {     my $artist = Music::Artist-&gt;insert({ name =&gt; &apos;Pink Floyd&apos; });     my $cd = $artist-&gt;add_to_cds({       title =&gt; &apos;Dark Side Of The Moon&apos;,       year =&gt; 1974,     });   });</p><p>Now either both will get added, or the entire transaction will be rolled back.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UNIQUENESS OF OBJECTS IN MEMORY</h2>
        <div class="sectioncontent">
<p>Class::DBI supports uniqueness of objects in memory. In a given perl interpreter there will only be one instance of any given object at one time. Many variables may reference that object, but there can be only one.</p><p>Here's an example to illustrate:</p><p>  my $artist1 = Music::Artist-&gt;insert({ artistid =&gt; 7, name =&gt; &apos;Polysics&apos; });   my $artist2 = Music::Artist-&gt;<strong>retrieve</strong>(7);   my $artist3 = Music::Artist-&gt;search( name =&gt; &apos;Polysics&apos; )-&gt;first;</p><p>Now $artist1, $artist2, and $artist3 all point to the same object. If you update a property on one of them, all of them will reflect the update.</p><p>This is implemented using a simple object lookup index for all live objects in memory. It is not a traditional cache - when your objects go out of scope, they will be destroyed normally, and a future retrieve will instantiate an entirely new object.</p><p>The ability to perform this magic for you replies on your perl having access to the Scalar::Util::weaken function. Although this is part of the core perl distribution, some vendors do not compile support for it. To find out if your perl has support for it, you can run this on the command line:</p><p>  perl -e &apos;use Scalar::Util qw(weaken)&apos;</p><p>If you get an error message about weak references not being implemented, Class::DBI will not maintain this lookup index, but give you a separate instances for each retrieve.</p><p>A few new tools are offered for adjusting the behavior of the object index. These are still somewhat experimental and may change in a future release.</p><h3>remove_from_object_index</h3>
<p>  $artist-&gt;remove_from_object_index();</p><p>This is an object method for removing a single object from the live objects index. You can use this if you want to have multiple distinct copies of the same object in memory.</p>
<h3>clear_object_index</h3>
<p>  Music::DBI-&gt;clear_object_index();</p><p>You can call this method on any class or instance of Class::DBI, but the effect is universal: it removes all objects from the index.</p>
<h3>purge_object_index_every</h3>
<p>  Music::Artist-&gt;purge_object_index_every(2000);</p><p>Weak references are not removed from the index when an object goes out of scope. This means that over time the index will grow in memory. This is really only an issue for long-running environments like mod_perl, but every so often dead references are cleaned out to prevent this. By default, this happens every 1000 object loads, but you can change that default for your class by setting the 'purge_object_index_every' value.</p><p>(Eventually this may handled in the \s-1DESTROY\s0 method instead.)</p><p>As a final note, keep in mind that you can still have multiple distinct copies of an object in memory if you have multiple perl interpreters running. \s-1CGI\s0, mod_perl, and many other common usage situations run multiple interpreters, meaning that each one of them may have an instance of an object representing the same data. However, this is no worse than it was before, and is entirely normal for database applications in multi-process environments.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING</h2>
        <div class="sectioncontent">
<p>The preferred method of interacting with Class::DBI is for you to write a subclass for your database connection, with each table-class inheriting in turn from it.</p><p>As well as encapsulating the connection information in one place, this also allows you to override default behaviour or add additional functionality across all of your classes.</p><p>As the innards of Class::DBI are still in flux, you must exercise extreme caution in overriding private methods of Class::DBI (those starting with an underscore), unless they are explicitly mentioned in this documentation as being safe to override. If you find yourself needing to do this, then I would suggest that you ask on the mailing list about it, and we'll see if we can either come up with a better approach, or provide a new means to do whatever you need to do.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<h3>Multi-Column Foreign Keys are not supported</h3>
<p>You can't currently add a relationship keyed on multiple columns. You could, however, write a Relationship plugin to do this, and the world would be eternally grateful...</p>
<h3>Don't change or inflate the value of your primary columns</h3>
<p>Altering your primary key column currently causes Bad Things to happen. I should really protect against this.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORTED DATABASES</h2>
        <div class="sectioncontent">
<p>Theoretically Class::DBI should work with almost any standard \s-1RDBMS\s0. Of course, in the real world, we know that that's not true. It is known to work with MySQL, PostgreSQL, Oracle and SQLite, each of which have their own additional subclass on \s-1CPAN\s0 that you should explore if you're using them:</p><p>  L&lt;Class::DBI::mysql&gt;, L&lt;Class::DBI::Pg&gt;, L&lt;Class::DBI::Oracle&gt;,   L&lt;Class::DBI::SQLite&gt;</p><p>For the most part it's been reported to work with Sybase, although there are some issues with multi-case column/table names. Beyond that lies The Great Unknown(tm). If you have access to other databases, please give this a test run, and let me know the results.</p><p>Ima::DBI (and hence Class::DBI) requires a database that supports table aliasing and a \s-1DBI\s0 driver that supports placeholders. This means it won't work with older releases of DBD::AnyData (and any releases of its predecessor \s-1DBD::RAM\s0), and DBD::Sybase + FreeTDS may or may not work depending on your FreeTDS version.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CURRENT AUTHOR</h2>
        <div class="sectioncontent">
<p>Tony Bowden</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR EMERITUS</h2>
        <div class="sectioncontent">
<p>Michael G Schwern</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THANKS TO</h2>
        <div class="sectioncontent">
<p>Tim Bunce, Tatsuhiko Miyagawa, Perrin Harkins, Alexander Karelas, Barry Hoggard, Bart Lateur, Boris Mouzykantskii, Brad Bowman, Brian Parker, Casey West, Charles Bailey, Christopher L. Everett Damian Conway, Dan Thill, Dave Cash, David Jack Olrik, Dominic Mitchell, Drew Taylor, Drew Wilson, Jay Strauss, Jesse Sheidlower, Jonathan Swartz, Marty Pauley, Michael Styer, Mike Lambert, Paul Makepeace, Phil Crow, Richard Piacentini, Simon Cozens, Simon Wilcox, Thomas Klausner, Tom Renfro, Uri Gutman, William McKee, the Class::DBI mailing list, the \s-1POOP\s0 group, and all the others who've helped, but that I've forgetten to mention.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELEASE PHILOSOPHY</h2>
        <div class="sectioncontent">
<p>Class::DBI now uses a three-level versioning system. This release, for example, is version 3.0.17</p><p>The general approach to releases will be that users who like a degree of stability can hold off on upgrades until the major sub-version increases (e.g. 3.1.0). Those who like living more on the cutting edge can keep up to date with minor sub-version releases.</p><p>Functionality which was introduced during a minor sub-version release may disappear without warning in a later minor sub-version release. I'll try to avoid doing this, and will aim to have a deprecation cycle of at least a few minor sub-versions, but you should keep a close eye on the \s-1CHANGES\s0 file, and have good tests in place. (This is good advice generally, of course.) Anything that is in a major sub-version release will go through a deprecation cycle of at least one further major sub-version before it is removed (and usually longer).</p><h3>Getting changes accepted</h3>
<p>There is an active Class::DBI community, however I am not part of it. I am not on the mailing list, and I don't follow the wiki. I also do not follow Perl Monks or \s-1CPAN\s0 reviews or annoCPAN or whatever the tool du jour happens to be.</p><p>If you find a problem with Class::DBI, by all means discuss it in any of these places, but don't expect anything to happen unless you actually tell me about it.</p><p>The preferred method for doing this is via the \s-1CPAN\s0 \s-1RT\s0 interface, which you can access at http://rt.cpan.org/ or by emailing</p>
<pre>
  bugs-Class-DBI@rt.cpan.org
</pre>
<p>If you email me personally about Class::DBI issues, then I will probably bounce them on to there, unless you specifically ask me not to. Otherwise I can't keep track of what all needs fixed. (This of course means that if you ask me not to send your mail to \s-1RT\s0, there's a much higher chance that nothing will every happen about your problem).</p>
<h3>Bug Reports</h3>
<p>If you're reporting a bug then it has a much higher chance of getting fixed quicker if you can include a failing test case. This should be a completely stand-alone test that could be added to the Class::DBI distribution. That is, it should use Test::Simple or Test::More, fail with the current code, but pass when I fix the problem. If it needs to have a working database to show the problem, then this should preferably use SQLite, and come with all the code to set this up. The nice people on the mailing list will probably help you out if you need assistance putting this together.</p><p>You don't need to include code for actually fixing the problem, but of course it's often nice if you can. I may choose to fix it in a different way, however, so it's often better to ask first whether I'd like a patch, particularly before spending a lot of time hacking.</p>
<h3>Patches</h3>
<p>If you are sending patches, then please send either the entire code that is being changed or the output of 'diff -Bub'.  Please also note what version the patch is against. I tend to apply all patches manually, so I'm more interested in being able to see what you're doing than in being able to apply the patch cleanly. Code formatting isn't an issue, as I automagically run perltidy against the source after any changes, so please format for clarity.</p><p>Patches have a much better chance of being applied if they are small. People often think that it's better for me to get one patch with a bunch of fixes. It's not. I'd much rather get 100 small patches that can be applied one by one. A change that I can make and release in five minutes is always better than one that needs a couple of hours to ponder and work through.</p><p>I often reject patches that I don't like. Please don't take it personally. I also like time to think about the wider implications of changes. Often a <em>lot</em> of time. Feel free to remind me about things that I may have forgotten about, but as long as they're on rt.cpan.org I will get around to them eventually.</p>
<h3>Feature Requests</h3>
<p>Wish-list requests are fine, although you should probably discuss them on the mailing list (or equivalent) with others first. There's quite often a plugin somewhere that already does what you want.</p><p>In general I am much more open to discussion on how best to provide the flexibility for you to make your Cool New Feature(tm) a plugin rather than adding it to Class::DBI itself.</p><p>For the most part the core of Class::DBI already has most of the functionality that I believe it will ever need (and some more besides, that will probably be split off at some point). Most other things are much better off as plugins, with a separate life on \s-1CPAN\s0 or elsewhere (and with me nowhere near the critical path). Most of the ongoing work on Class::DBI is about making life easier for people to write extensions - whether they're local to your own codebase or released for wider consumption.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>Support for Class::DBI is mostly via the mailing list.</p><p>To join the list, or read the archives, visit</p>
<pre>
  http://lists.digitalcraftsmen.net/mailman/listinfo/classdbi
</pre>
<p>There is also a Class::DBI wiki at</p>
<pre>
  http://www.class-dbi.com/
</pre>
<p>The wiki contains much information that should probably be in these docs but isn't yet. (See above if you want to help to rectify this.)</p><p>As mentioned above, I don't follow the list or the wiki, so if you want to contact me individually, then you'll have to track me down personally.</p><p>There are lots of 3rd party subclasses and plugins available. For a list of the ones on \s-1CPAN\s0 see:</p>
<pre>
  http://search.cpan.org/search?query=Class%3A%3ADBI&mode=module
</pre>
<p>An article on Class::DBI was published on Perl.com a while ago. It's slightly out of date , but it's a good introduction:</p>
<pre>
  http://www.perl.com/pub/a/2002/11/27/classdbi.html
</pre>
<p>The wiki has numerous references to other articles, presentations etc.</p><p>http://poop.sourceforge.net/ provides a document comparing a variety of different approaches to database persistence, such as Class::DBI, Alazabo, Tangram, \s-1SPOPS\s0 etc.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Class::DBI&hellip;</h2>
        <div class="sectioncontent">
<p>Class::DBI is built on top of Ima::DBI, DBIx::ContextualFetch, Class::Accessor and Class::Data::Inheritable. The innards and much of the interface are easier to understand if you have an idea of how they all work as well.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::Container.3pm.html"><span aria-hidden="true">&larr;</span> Class::Container.3pm: Glues object frameworks together transparently</a></li>
   <li class="next"><a href="Class::DBI::AbstractSearch.3pm.html">Class::DBI::AbstractSearch.3pm: Abstract class::dbi's sql with sql::abstract::limit <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gen_event: Generic event handling behaviour</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Generic event handling behaviour">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gen_event (3erl) manual">
  <meta name="twitter:description" content="Generic event handling behaviour">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-gen_event-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/gen_event.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gen_event (3erl) manual" />
  <meta property="og:description" content="Generic event handling behaviour" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-gen_event-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gen_event<small> (3erl)</small></h1>
        <p class="lead">Generic event handling behaviour</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gen_event.3erl.html">
      <span itemprop="name">gen_event: Generic event handling behaviour</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/gen_event.3erl.html">
      <span itemprop="name">gen_event: Generic event handling behaviour</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A behaviour module for implementing event handling functionality. The OTP event handling model consists of a generic event manager process with an arbitrary number of event handlers which are added and deleted dynamically.</p><p>An event manager implemented using this module will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into an OTP supervision tree. Refer to <em>OTP Design Principles</em> for more information.</p><p>Each event handler is implemented as a callback module exporting a pre-defined set of functions. The relationship between the behaviour functions and the callback functions can be illustrated as follows:</p>
<pre>
gen_event module                   Callback module
----------------                   ---------------
gen_event:start_link       -----&gt;  -

gen_event:add_handler
gen_event:add_sup_handler  -----&gt;  Module:init/1

gen_event:notify
gen_event:sync_notify      -----&gt;  Module:handle_event/2

gen_event:call             -----&gt;  Module:handle_call/2

-                          -----&gt;  Module:handle_info/2

gen_event:delete_handler   -----&gt;  Module:terminate/2

gen_event:swap_handler
gen_event:swap_sup_handler -----&gt;  Module1:terminate/2
                                   Module2:init/1

gen_event:which_handlers   -----&gt;  -

gen_event:stop             -----&gt;  Module:terminate/2

-                          -----&gt;  Module:code_change/3
</pre>
<p>Since each event handler is one callback module, an event manager will have several callback modules which are added and deleted dynamically. Therefore <em>gen_event</em> is more tolerant of callback module errors than the other behaviours. If a callback function for an installed event handler fails with <em>Reason</em>, or returns a bad value <em>Term</em>, the event manager will not fail. It will delete the event handler by calling the callback function <em>Module:terminate/2</em> (see below), giving as argument <em>{error,{'EXIT',Reason}}</em> or <em>{error,Term}</em>, respectively. No other event handler will be affected.</p><p>A gen_event process handles system messages as documented in <strong>sys(3erl)</strong>. The <em>sys</em> module can be used for debugging an event manager.</p><p>Note that an event manager <em>does</em> trap exit signals automatically.</p><p>The gen_event process can go into hibernation (see <strong>erlang(3erl)</strong>) if a callback function in a handler module specifies <em>'hibernate'</em> in its return value. This might be useful if the server is expected to be idle for a long time. However this feature should be used with care as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you'd want to do between each event handled by a busy event manager.</p><p>It's also worth noting that when multiple event handlers are invoked, it's sufficient that one single event handler returns a <em>'hibernate'</em> request for the whole event manager to go into hibernation.</p><p>Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are given.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>handler()</strong> = atom() | {atom(), term()}

</pre>

<pre>
<strong>handler_args()</strong> = term()

</pre>

<pre>
<strong>add_handler_ret()</strong> = ok | term() | {'EXIT', term()}

</pre>

<pre>
<strong>del_handler_ret()</strong> = ok | term() | {'EXIT', term()}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> start_link() -&gt; Result</p><p><strong></strong> start_link(EventMgrName) -&gt; Result</p><p>Types:</p><p>EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</p><p> Name = atom()</p><p> GlobalName = ViaName = term()</p><p>Result = {ok,Pid} | {error,{already_started,Pid}}</p><p> Pid = pid()</p><p>Creates an event manager process as part of a supervision tree. The function should be called, directly or indirectly, by the supervisor. It will, among other things, ensure that the event manager is linked to the supervisor.</p><p>If <em>EventMgrName={local,Name}</em>, the event manager is registered locally as <em>Name</em> using <em>register/2</em>. If <em>EventMgrName={global,GlobalName}</em>, the event manager is registered globally as <em>GlobalName</em> using <em>global:register_name/2</em>. If no name is provided, the event manager is not registered. If <em>EventMgrName={via,Module,ViaName}</em>, the event manager will register with the registry represented by <em>Module</em>. The <em>Module</em> callback should export the functions <em>register_name/2</em>, <em>unregister_name/1</em>, <em>whereis_name/1</em> and <em>send/2</em>, which should behave like the corresponding functions in <em>global</em>. Thus, <em>{via,global,GlobalName}</em> is a valid reference.</p><p>If the event manager is successfully created the function returns <em>{ok,Pid}</em>, where <em>Pid</em> is the pid of the event manager. If there already exists a process with the specified <em>EventMgrName</em> the function returns <em>{error,{already_started,Pid}}</em>, where <em>Pid</em> is the pid of that process.</p><p><strong></strong> start() -&gt; Result</p><p><strong></strong> start(EventMgrName) -&gt; Result</p><p>Types:</p><p>EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</p><p> Name = atom()</p><p> GlobalName = ViaName = term()</p><p>Result = {ok,Pid} | {error,{already_started,Pid}}</p><p> Pid = pid()</p><p>Creates a stand-alone event manager process, i.e. an event manager which is not part of a supervision tree and thus has no supervisor.</p><p>See <em>start_link/0,1</em> for a description of arguments and return values.</p><p><strong></strong> add_handler(EventMgrRef, Handler, Args) -&gt; Result</p><p>Types:</p><p>EventMgr = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Handler = Module | {Module,Id}</p><p> Module = atom()</p><p> Id = term()</p><p>Args = term()</p><p>Result = ok | {'EXIT',Reason} | term()</p><p> Reason = term()</p><p>Adds a new event handler to the event manager <em>EventMgrRef</em>. The event manager will call <em>Module:init/1</em> to initiate the event handler and its internal state.</p><p><em>EventMgrRef</em> can be:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>the pid,</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Name</em>, if the event manager is locally registered,</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{Name,Node}</em>, if the event manager is locally registered at another node, or</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{global,GlobalName}</em>, if the event manager is globally registered.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{via,Module,ViaName}</em>, if the event manager is registered through an alternative process registry.</p>
  </dd>

</dl>
<p><em>Handler</em> is the name of the callback module <em>Module</em> or a tuple <em>{Module,Id}</em>, where <em>Id</em> is any term. The <em>{Module,Id}</em> representation makes it possible to identify a specific event handler when there are several event handlers using the same callback module.</p><p><em>Args</em> is an arbitrary term which is passed as the argument to <em>Module:init/1</em>.</p><p>If <em>Module:init/1</em> returns a correct value indicating successful completion, the event manager adds the event handler and this function returns <em>ok</em>. If <em>Module:init/1</em> fails with <em>Reason</em> or returns <em>{error,Reason}</em>, the event handler is ignored and this function returns <em>{'EXIT',Reason}</em> or <em>{error,Reason}</em>, respectively.</p><p><strong></strong> add_sup_handler(EventMgrRef, Handler, Args) -&gt; Result</p><p>Types:</p><p>EventMgr = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Handler = Module | {Module,Id}</p><p> Module = atom()</p><p> Id = term()</p><p>Args = term()</p><p>Result = ok | {'EXIT',Reason} | term()</p><p> Reason = term()</p><p>Adds a new event handler in the same way as <em>add_handler/3</em> but will also supervise the connection between the event handler and the calling process.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If the calling process later terminates with <em>Reason</em>, the event manager will delete the event handler by calling <em>Module:terminate/2</em> with <em>{stop,Reason}</em> as argument.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If the event handler later is deleted, the event manager sends a message<em>{gen_event_EXIT,Handler,Reason}</em> to the calling process. <em>Reason</em> is one of the following:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>normal</em>, if the event handler has been removed due to a call to <em>delete_handler/3</em>, or <em>remove_handler</em> has been returned by a callback function (see below).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>shutdown</em>, if the event handler has been removed because the event manager is terminating.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{swapped,NewHandler,Pid}</em>, if the process <em>Pid</em> has replaced the event handler with another event handler <em>NewHandler</em> using a call to <em>swap_handler/3</em> or <em>swap_sup_handler/3</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>a term, if the event handler is removed due to an error. Which term depends on the error.</p>
  </dd>

</dl>

  </dd>

</dl>
<p>See <em>add_handler/3</em> for a description of the arguments and return values.</p><p><strong></strong> notify(EventMgrRef, Event) -&gt; ok</p><p><strong></strong> sync_notify(EventMgrRef, Event) -&gt; ok</p><p>Types:</p><p>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Event = term()</p><p>Sends an event notification to the event manager <em>EventMgrRef</em>. The event manager will call <em>Module:handle_event/2</em> for each installed event handler to handle the event.</p><p><em>notify</em> is asynchronous and will return immediately after the event notification has been sent. <em>sync_notify</em> is synchronous in the sense that it will return <em>ok</em> after the event has been handled by all event handlers.</p><p>See <em>add_handler/3</em> for a description of <em>EventMgrRef</em>.</p><p><em>Event</em> is an arbitrary term which is passed as one of the arguments to <em>Module:handle_event/2</em>.</p><p><em>notify</em> will not fail even if the specified event manager does not exist, unless it is specified as <em>Name</em>.</p><p><strong></strong> call(EventMgrRef, Handler, Request) -&gt; Result</p><p><strong></strong> call(EventMgrRef, Handler, Request, Timeout) -&gt; Result</p><p>Types:</p><p>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Handler = Module | {Module,Id}</p><p> Module = atom()</p><p> Id = term()</p><p>Request = term()</p><p>Timeout = int()&gt;0 | infinity</p><p>Result = Reply | {error,Error}</p><p> Reply = term()</p><p> Error = bad_module | {'EXIT',Reason} | term()</p><p> Reason = term()</p><p>Makes a synchronous call to the event handler <em>Handler</em> installed in the event manager <em>EventMgrRef</em> by sending a request and waiting until a reply arrives or a timeout occurs. The event manager will call <em>Module:handle_call/2</em> to handle the request.</p><p>See <em>add_handler/3</em> for a description of <em>EventMgrRef</em> and <em>Handler</em>.</p><p><em>Request</em> is an arbitrary term which is passed as one of the arguments to <em>Module:handle_call/2</em>.</p><p><em>Timeout</em> is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom <em>infinity</em> to wait indefinitely. Default value is 5000. If no reply is received within the specified time, the function call fails.</p><p>The return value <em>Reply</em> is defined in the return value of <em>Module:handle_call/2</em>. If the specified event handler is not installed, the function returns <em>{error,bad_module}</em>. If the callback function fails with <em>Reason</em> or returns an unexpected value <em>Term</em>, this function returns <em>{error,{'EXIT',Reason}}</em> or <em>{error,Term}</em>, respectively.</p><p><strong></strong> delete_handler(EventMgrRef, Handler, Args) -&gt; Result</p><p>Types:</p><p>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Handler = Module | {Module,Id}</p><p> Module = atom()</p><p> Id = term()</p><p>Args = term()</p><p>Result = term() | {error,module_not_found} | {'EXIT',Reason}</p><p> Reason = term()</p><p>Deletes an event handler from the event manager <em>EventMgrRef</em>. The event manager will call <em>Module:terminate/2</em> to terminate the event handler.</p><p>See <em>add_handler/3</em> for a description of <em>EventMgrRef</em> and <em>Handler</em>.</p><p><em>Args</em> is an arbitrary term which is passed as one of the arguments to <em>Module:terminate/2</em>.</p><p>The return value is the return value of <em>Module:terminate/2</em>. If the specified event handler is not installed, the function returns <em>{error,module_not_found}</em>. If the callback function fails with <em>Reason</em>, the function returns <em>{'EXIT',Reason}</em>.</p><p><strong></strong> swap_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -&gt; Result</p><p>Types:</p><p>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Handler1 = Handler2 = Module | {Module,Id}</p><p> Module = atom()</p><p> Id = term()</p><p>Args1 = Args2 = term()</p><p>Result = ok | {error,Error}</p><p> Error = {'EXIT',Reason} | term()</p><p> Reason = term()</p><p>Replaces an old event handler with a new event handler in the event manager <em>EventMgrRef</em>.</p><p>See <em>add_handler/3</em> for a description of the arguments.</p><p>First the old event handler <em>Handler1</em> is deleted. The event manager calls <em>Module1:terminate(Args1, ...)</em>, where <em>Module1</em> is the callback module of <em>Handler1</em>, and collects the return value.</p><p>Then the new event handler <em>Handler2</em> is added and initiated by calling <em>Module2:init({Args2,Term})</em>, where <em>Module2</em> is the callback module of <em>Handler2</em> and <em>Term</em> the return value of <em>Module1:terminate/2</em>. This makes it possible to transfer information from <em>Handler1</em> to <em>Handler2</em>.</p><p>The new handler will be added even if the the specified old event handler is not installed in which case <em>Term=error</em>, or if <em>Module1:terminate/2</em> fails with <em>Reason</em> in which case <em>Term={'EXIT',Reason}</em>. The old handler will be deleted even if <em>Module2:init/1</em> fails.</p><p>If there was a supervised connection between <em>Handler1</em> and a process <em>Pid</em>, there will be a supervised connection between <em>Handler2</em> and <em>Pid</em> instead.</p><p>If <em>Module2:init/1</em> returns a correct value, this function returns <em>ok</em>. If <em>Module2:init/1</em> fails with <em>Reason</em> or returns an unexpected value <em>Term</em>, this this function returns <em>{error,{'EXIT',Reason}}</em> or <em>{error,Term}</em>, respectively.</p><p><strong></strong> swap_sup_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -&gt; Result</p><p>Types:</p><p>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Handler1 = Handler 2 = Module | {Module,Id}</p><p> Module = atom()</p><p> Id = term()</p><p>Args1 = Args2 = term()</p><p>Result = ok | {error,Error}</p><p> Error = {'EXIT',Reason} | term()</p><p> Reason = term()</p><p>Replaces an event handler in the event manager <em>EventMgrRef</em> in the same way as <em>swap_handler/3</em> but will also supervise the connection between <em>Handler2</em> and the calling process.</p><p>See <em>swap_handler/3</em> for a description of the arguments and return values.</p><p><strong></strong> which_handlers(EventMgrRef) -&gt; [Handler]</p><p>Types:</p><p>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p> Name = Node = atom()</p><p> GlobalName = ViaName = term()</p><p>Handler = Module | {Module,Id}</p><p> Module = atom()</p><p> Id = term()</p><p>Returns a list of all event handlers installed in the event manager <em>EventMgrRef</em>.</p><p>See <em>add_handler/3</em> for a description of <em>EventMgrRef</em> and <em>Handler</em>.</p><p><strong></strong> stop(EventMgrRef) -&gt; ok</p><p>Types:</p><p>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()</p><p>Name = Node = atom()</p><p>GlobalName = ViaName = term()</p><p>Terminates the event manager <em>EventMgrRef</em>. Before terminating, the event manager will call <em>Module:terminate(stop,...)</em> for each installed event handler.</p><p>See <em>add_handler/3</em> for a description of the argument.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACK FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The following functions should be exported from a <em>gen_event</em> callback module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> Module:init(InitArgs) -&gt; {ok,State} | {ok,State,hibernate} | {error,Reason}</p><p>Types:</p><p>InitArgs = Args | {Args,Term}</p><p> Args = Term = term()</p><p>State = term()</p><p>Reason = term()</p><p>Whenever a new event handler is added to an event manager, this function is called to initialize the event handler.</p><p>If the event handler is added due to a call to <em>gen_event:add_handler/3</em> or <em>gen_event:add_sup_handler/3</em>, <em>InitArgs</em> is the <em>Args</em> argument of these functions.</p><p>If the event handler is replacing another event handler due to a call to <em>gen_event:swap_handler/3</em> or <em>gen_event:swap_sup_handler/3</em>, or due to a <em>swap</em> return tuple from one of the other callback functions, <em>InitArgs</em> is a tuple <em>{Args,Term}</em> where <em>Args</em> is the argument provided in the function call/return tuple and <em>Term</em> is the result of terminating the old event handler, see <em>gen_event:swap_handler/3</em>.</p><p>If successful, the function should return <em>{ok,State}</em> or <em>{ok,State,hibernate}</em> where <em>State</em> is the initial internal state of the event handler.</p><p>If <em>{ok,State,hibernate}</em> is returned, the event manager will go into hibernation (by calling <strong>proc_lib:hibernate/3</strong>), waiting for the next event to occur.</p><p><strong></strong> Module:handle_event(Event, State) -&gt; Result</p><p>Types:</p><p>Event = term()</p><p>State = term()</p><p>Result = {ok,NewState} | {ok,NewState,hibernate}</p><p> | {swap_handler,Args1,NewState,Handler2,Args2} | remove_handler</p><p> NewState = term()</p><p> Args1 = Args2 = term()</p><p> Handler2 = Module2 | {Module2,Id}</p><p> Module2 = atom()</p><p> Id = term()</p><p>Whenever an event manager receives an event sent using <em>gen_event:notify/2</em> or <em>gen_event:sync_notify/2</em>, this function is called for each installed event handler to handle the event.</p><p><em>Event</em> is the <em>Event</em> argument of <em>notify</em>/<em>sync_notify</em>.</p><p><em>State</em> is the internal state of the event handler.</p><p>If the function returns <em>{ok,NewState}</em> or <em>{ok,NewState,hibernate}</em> the event handler will remain in the event manager with the possible updated internal state <em>NewState</em>.</p><p>If <em>{ok,NewState,hibernate}</em> is returned, the event manager will also go into hibernation (by calling <strong>proc_lib:hibernate/3</strong>), waiting for the next event to occur. It is sufficient that one of the event handlers return <em>{ok,NewState,hibernate}</em> for the whole event manager process to hibernate.</p><p>If the function returns <em>{swap_handler,Args1,NewState,Handler2,Args2}</em> the event handler will be replaced by <em>Handler2</em> by first calling <em>Module:terminate(Args1,NewState)</em> and then <em>Module2:init({Args2,Term})</em> where <em>Term</em> is the return value of <em>Module:terminate/2</em>. See <em>gen_event:swap_handler/3</em> for more information.</p><p>If the function returns <em>remove_handler</em> the event handler will be deleted by calling <em>Module:terminate(remove_handler,State)</em>.</p><p><strong></strong> Module:handle_call(Request, State) -&gt; Result</p><p>Types:</p><p>Request = term()</p><p>State = term()</p><p>Result = {ok,Reply,NewState} | {ok,Reply,NewState,hibernate}</p><p> | {swap_handler,Reply,Args1,NewState,Handler2,Args2}</p><p> | {remove_handler, Reply}</p><p> Reply = term()</p><p> NewState = term()</p><p> Args1 = Args2 = term()</p><p> Handler2 = Module2 | {Module2,Id}</p><p> Module2 = atom()</p><p> Id = term()</p><p>Whenever an event manager receives a request sent using <em>gen_event:call/3,4</em>, this function is called for the specified event handler to handle the request.</p><p><em>Request</em> is the <em>Request</em> argument of <em>call</em>.</p><p><em>State</em> is the internal state of the event handler.</p><p>The return values are the same as for <em>handle_event/2</em> except they also contain a term <em>Reply</em> which is the reply given back to the client as the return value of <em>call</em>.</p><p><strong></strong> Module:handle_info(Info, State) -&gt; Result</p><p>Types:</p><p>Info = term()</p><p>State = term()</p><p>Result = {ok,NewState} | {ok,NewState,hibernate}</p><p> | {swap_handler,Args1,NewState,Handler2,Args2} | remove_handler</p><p> NewState = term()</p><p> Args1 = Args2 = term()</p><p> Handler2 = Module2 | {Module2,Id}</p><p> Module2 = atom()</p><p> Id = term()</p><p>This function is called for each installed event handler when an event manager receives any other message than an event or a synchronous request (or a system message).</p><p><em>Info</em> is the received message.</p><p>See <em>Module:handle_event/2</em> for a description of State and possible return values.</p><p><strong></strong> Module:terminate(Arg, State) -&gt; term()</p><p>Types:</p><p>Arg = Args | {stop,Reason} | stop | remove_handler</p><p> | {error,{'EXIT',Reason}} | {error,Term}</p><p> Args = Reason = Term = term()</p><p>Whenever an event handler is deleted from an event manager, this function is called. It should be the opposite of <em>Module:init/1</em> and do any necessary cleaning up.</p><p>If the event handler is deleted due to a call to <em>gen_event:delete_handler</em>, <em>gen_event:swap_handler/3</em> or <em>gen_event:swap_sup_handler/3</em>, <em>Arg</em> is the <em>Args</em> argument of this function call.</p><p><em>Arg={stop,Reason}</em> if the event handler has a supervised connection to a process which has terminated with reason <em>Reason</em>.</p><p><em>Arg=stop</em> if the event handler is deleted because the event manager is terminating.</p><p>The event manager will terminate if it is part of a supervision tree and it is ordered by its supervisor to terminate. Even if it is <em>not</em> part of a supervision tree, it will terminate if it receives an <em>'EXIT'</em> message from its parent.</p><p><em>Arg=remove_handler</em> if the event handler is deleted because another callback function has returned <em>remove_handler</em> or <em>{remove_handler,Reply}</em>.</p><p><em>Arg={error,Term}</em> if the event handler is deleted because a callback function returned an unexpected value <em>Term</em>, or <em>Arg={error,{'EXIT',Reason}}</em> if a callback function failed.</p><p><em>State</em> is the internal state of the event handler.</p><p>The function may return any term. If the event handler is deleted due to a call to <em>gen_event:delete_handler</em>, the return value of that function will be the return value of this function. If the event handler is to be replaced with another event handler due to a swap, the return value will be passed to the <em>init</em> function of the new event handler. Otherwise the return value is ignored.</p><p><strong></strong> Module:code_change(OldVsn, State, Extra) -&gt; {ok, NewState}</p><p>Types:</p><p>OldVsn = Vsn | {down, Vsn}</p><p> Vsn = term()</p><p>State = NewState = term()</p><p>Extra = term()</p><p>This function is called for an installed event handler which should update its internal state during a release upgrade/downgrade, i.e. when the instruction <em>{update,Module,Change,...}</em> where <em>Change={advanced,Extra}</em> is given in the <em>.appup</em> file. See <em>OTP Design Principles</em> for more information.</p><p>In the case of an upgrade, <em>OldVsn</em> is <em>Vsn</em>, and in the case of a downgrade, <em>OldVsn</em> is <em>{down,Vsn}</em>. <em>Vsn</em> is defined by the <em>vsn</em> attribute(s) of the old version of the callback module <em>Module</em>. If no such attribute is defined, the version is the checksum of the BEAM file.</p><p><em>State</em> is the internal state of the event handler.</p><p><em>Extra</em> is passed as-is from the <em>{advanced,Extra}</em> part of the update instruction.</p><p>The function should return the updated internal state.</p><p><strong></strong> Module:format_status(Opt, [PDict, State]) -&gt; Status</p><p>Types:</p><p>Opt = normal | terminate</p><p>PDict = [{Key, Value}]</p><p>State = term()</p><p>Status = term()</p><p><strong></strong> Note:</p><p>This callback is optional, so event handler modules need not export it. If a handler does not export this function, the gen_event module uses the handler state directly for the purposes described below.</p><p>This function is called by a gen_event process when:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>One of <strong>sys:get_status/1,2</strong> is invoked to get the gen_event status. <em>Opt</em> is set to the atom <em>normal</em> for this case.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>The event handler terminates abnormally and gen_event logs an error. <em>Opt</em> is set to the atom <em>terminate</em> for this case.</p>
  </dd>

</dl>
<p>This function is useful for customising the form and appearance of the event handler state for these cases. An event handler callback module wishing to customise the <em>sys:get_status/1,2</em> return value as well as how its state appears in termination error logs exports an instance of <em>format_status/2</em> that returns a term describing the current state of the event handler.</p><p><em>PDict</em> is the current value of the gen_event's process dictionary.</p><p><em>State</em> is the internal state of the event handler.</p><p>The function should return <em>Status</em>, a term that customises the details of the current state of the event handler. Any term is allowed for <em>Status</em>. The gen_event module uses <em>Status</em> as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>When <em>sys:get_status/1,2</em> is called, gen_event ensures that its return value contains <em>Status</em> in place of the event handler's actual state term.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>When an event handler terminates abnormally, gen_event logs <em>Status</em> in place of the event handler's actual state term.</p>
  </dd>

</dl>
<p>One use for this function is to return compact alternative state representations to avoid having large state terms printed in logfiles.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO gen_event&hellip;</h2>
        <div class="sectioncontent">
<p><strong>supervisor(3erl)</strong>, <strong>sys(3erl)</strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gb_trees.3erl.html"><span aria-hidden="true">&larr;</span> gb_trees.3erl: General balanced trees</a></li>
   <li class="next"><a href="gen_fsm.3erl.html">gen_fsm.3erl: Generic finite state machine behaviour <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

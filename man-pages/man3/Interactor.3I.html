<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interactor: Base class for interactive objects</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Base class for interactive objects">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Interactor (3I) manual">
  <meta name="twitter:description" content="Base class for interactive objects">
  <meta name="twitter:image" content="https://www.carta.tech/images/ivtools-dev-Interactor-3I.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3I/Interactor.3I.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Interactor (3I) manual" />
  <meta property="og:description" content="Base class for interactive objects" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ivtools-dev-Interactor-3I.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Interactor<small> (3I)</small></h1>
        <p class="lead">Base class for interactive objects</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3I/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3I/Interactor.3I.html">
      <span itemprop="name">Interactor: Base class for interactive objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ivtools-dev/">
      <span itemprop="name">ivtools-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3I/Interactor.3I.html">
      <span itemprop="name">Interactor: Base class for interactive objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;InterViews/interactor.h&gt;</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>In 2.6, <strong>Interactor</strong> was the base class for all interactive objects. It is currently provided for backward compatibility.</p><p>Every interactor has a <em>shape</em> member variable that defines the desired characteristics of screen space in terms of size, shrinkability, and stretchability. This information is used to allocate display space for the interactor and the interactor's <em>canvas</em> member variable is set to the actual space obtained. The lower left corner of the canvas is addressed by (0,&nbsp;0); the upper right by the member variables (<em>xmax</em>,&nbsp;<em>ymax</em>).</p><p>The <em>input</em> member variable is the normal sensor for reading events. The <em>output</em> member variable is the standard painter for performing graphics operations. Interactors generally should not set <em>output</em>; it will either be inherited (and shared) from the interactor's parent or set by user customization attributes.</p><p>An interactor may optionally define the <em>perspective</em> member variable to represent the portion of total area that the interactor is displaying. Perspectives allow interactors to coordinate with other interactors, such as scrollers, that want to control the display area.</p><p>An interactor also may specify certain characteristics of the interactor's canvas, such as whether it is read-only or read/write, whether its contents should be saved when not visible. Interactors also may specify the visual format and interpretation of the input pointing device (e.g., mouse cursor) when it is inside the interactor's canvas.</p><p>To be mapped to some portion of the display, an interactor must have been inserted into a scene, called its <em>parent</em>. The interactor will be mapped when its parent is mapped. The root scene for the display can be accessed through a World(3I) object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTORS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>Interactor()</strong></p>
  </dt>
  <dd>
    <p>Construct an interactor. The <em>input</em> sensor and <em>output</em> painters are initialized to <em>nil</em>.</p>
  </dd>
  <dt>
    <p><strong>Interactor(const char* name)</strong></p>
  </dt>
  <dd>
    <p>Construct an interactor associated with the string <em>name</em>. The string is used to customize the behavior of the interactor according to user preferences.  Behavior can also be customized on a per-class basis using the subclass name. Although not explicitly documented, an instance of any object inheriting from interactor may be constructed with an additional argument (appearing first) containing the string name. For example, both ``HGlue(natural, stretch)'' and ``HGlue("somename", natural, stretch)'' are valid.</p>
  </dd>
  <dt>
    <p><strong>~Interactor()</strong></p>
  </dt>
  <dd>
    <p>The base destructor automatically deletes the base fields, including <em>shape</em>, <em>canvas</em>, <em>input</em>, and <em>output</em>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>void Align(Alignment, int w, int h, Coord& l, Coord& b)</strong></p>
  </dt>
  <dd>
    <p>Return the coordinates at which an object with the given width and height will have the given alignment within the interactor's canvas.</p>
  </dd>
  <dt>
    <p><strong>void SetClassName(const char*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>const char* GetClassName()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void SetInstance(const char*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>const char* GetInstance()</strong></p>
  </dt>
  <dd>
    <p>Set/get the class or instance name for an interactor. The names are used to determine user style preferences. SetClassName and SetInstance can only be performed by subclasses.</p>
  </dd>
  <dt>
    <p><strong>void Config(Scene* s)</strong></p>
  </dt>
  <dd>
    <p>Configure this interactor and its descendants according to user preferences. The scene <em>s</em> is assumed to be the interactor's parent and is used to inherit attribute values. This operation need not be called explicitly; it is called automatically when the ancestors of an interactor become known (e.g., when the interactor or an ancestor is inserted into a world).</p>
  </dd>

</dl>
<p>Configuration involves a traversal of the interactor hierarchy. For each interactor in the hierarchy, the <em>output</em> painter is either inherited from its parent or copied from its parent if there are user preferences specific to the interactor for painter attributes such as colors, font, and brush. For example, suppose the user preference is ``A*B*font:9x15'' and the interactor hierarchy is ``A.B.C.D'' (each ``.'' representing a nesting level in the hierarchy). Interactors A and B will share the same output painter, C will copy B's output and change the font to ``9x15'', and D will share C's output.</p><p>After assigning the output painter, configuration is performed recursively on any children interactors. The final step at each node in the traversal is to call the virtual Reconfig operation.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>virtual void Reconfig()</strong></p>
  </dt>
  <dd>
    <p>Perform any configuration specific to a particular interactor. This operation should minimally compute the interactor's shape based on the shape of its children and/or the characteristics of its output painter (e.g., font). It can also retrieve user preferences specific to this interactor's class or instance name using GetAttribute.</p>
  </dd>
  <dt>
    <p><strong>const char* GetAttribute(const char*)</strong></p>
  </dt>
  <dd>
    <p>Retrieve the value of a user preference with the given name. GetAttribute searches for the most specific match to the current context.</p>
  </dd>
  <dt>
    <p><strong>virtual void Reshape(Shape&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>Shape* GetShape()</strong></p>
  </dt>
  <dd>
    <p>Set/get the shape of an interactor. Reshape is a a suggestion that an interactor's shape should change to the given one. The default operation sets the interactor's shape to the new shape and calls Scene::Change on the interactor's parent. Suggested shape information may be lost when an interactor is configured; thus, it is best to avoid use of Reshape. The same affect can usually be achieved by putting the interactor in a box along with a particular shape of glue.</p>
  </dd>
  <dt>
    <p><strong>void SetCursor(Cursor*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>Cursor* GetCursor()</strong></p>
  </dt>
  <dd>
    <p>Set/get the cursor that will be displayed when the pointing device is inside the interactor's canvas. If the interactor does not explicitly set its cursor, it will use its parent's cursor. GetCursor returns nil in this case.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERACTOR HIERARCHY</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>Scene* Parent()</strong></p>
  </dt>
  <dd>
    <p>Return the interactor's parent or <em>nil</em> if the interactor has not been inserted into a scene.</p>
  </dd>
  <dt>
    <p><strong>World* GetWorld()</strong></p>
  </dt>
  <dd>
    <p>Return a pointer to the world the interactor has been inserted into or <em>nil</em> if the interactor's root ancestor is not mapped.</p>
  </dd>
  <dt>
    <p><strong>void GetRelative(Coord& x, Coord& y, Interactor* = nil)</strong></p>
  </dt>
  <dd>
    <p>Map coordinates that are relative to this interactor's canvas to be relative to another interactor's canvas. If the other interactor is <em>nil</em>, then the coordinates are made relative to the world.</p>
  </dd>
  <dt>
    <p><strong>virtual void GetComponents(Interactor**, int, Interactor**&, int&)</strong></p>
  </dt>
  <dd>
    <p>Construct an array of pointers to the interactors contained within this interactor. The first and second parameters specify an array of interactors that is already allocated. This array is used if it is large enough, otherwise a new array is allocated from free store. The third and fourth parameters return the which array was used and the actual number of components. This operation is only defined by scenes; the default operation sets the number of elements to zero.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OUTPUT</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>Canvas* GetCanvas() const</strong></p>
  </dt>
  <dd>
    <p>Return the interactor's canvas, which may be <em>nil</em> if the interactor is not mapped to a display.</p>
  </dd>
  <dt>
    <p><strong>ManagedWindow* GetTopLevelWindow() const</strong></p>
  </dt>
  <dd>
    <p>Return the top-level window associated with the interactor, if it is mapped and top-level.</p>
  </dd>
  <dt>
    <p><strong>virtual void Draw()</strong></p>
  </dt>
  <dd>
    <p>Draw is used to display the contents of an interactor, including the contents of any interior interactors.  The default Draw operation calls Redraw(0,&nbsp;0,&nbsp;<em>xmax</em>,&nbsp;<em>ymax</em>).  Interactors usually don't need to redefine Draw unless they contain interior interactors (i.e., scene subclasses); most simple interactors redefine only Redraw.</p>
  </dd>
  <dt>
    <p><strong>virtual void Highlight(boolean)</strong></p>
  </dt>
  <dd>
    <p>Turn highlighting on or off, depending on whether the parameter is true or false.  The default operation is a nop.</p>
  </dd>
  <dt>
    <p><strong>void SetCanvasType(CanvasType)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>CanvasType GetCanvasType()</strong></p>
  </dt>
  <dd>
    <p>Set/get the type of canvas desired for an interactor.  This operation must be performed before an interactor is mapped.  The possible canvas types are CanvasShapeOnly, meaning the interactor performs no input or output (e.g., glue), CanvasInputOnly, meaning the interactor performs no output, CanvasInputOutput, which is the default, CanvasSaveUnder, which suggests that the interactor will be mapped for a short time (e.g., a popup menu) and that the information under the canvas should be saved, CanvasSaveContents, which suggests that Redraw calls are expensive and should be avoided by caching the display, and CanvasSaveBoth, which requests both CanvasSaveUnder and CanvasSaveContents.</p>
  </dd>
  <dt>
    <p><strong>void Sync()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void Flush()</strong></p>
  </dt>
  <dd>
    <p>Sync waits until any pending operations have completed. Flush makes sure the local buffer of pending operations (if any) is sent to the display. An input operation will do a Sync automatically if it would block; thus, applications generally need not call Sync or Flush explicitly.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUT</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>void Listen(Sensor*)</strong></p>
  </dt>
  <dd>
    <p>When an interactor is mapped onto a display, its input interest is determined by its <em>input</em> sensor. A different sensor can be specified with the Listen operation. To switch back to <em>input</em>, call Listen(<em>input</em>).</p>
  </dd>
  <dt>
    <p><strong>void Read(Event&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>boolean Read(long sec, long usec, Event&)</strong></p>
  </dt>
  <dd>
    <p>Each application has a single input queue of events. Any interactor can use Read to take the next event from the queue. Redraw and Resize operations may be called as a side effect of a Read (or any input operation). The <em>target</em> field of the event specifies the interactor for which the event is intended, which is not necessarily the same as the interactor that performed the Read. The target is normally the interactor whose canvas is under the pointing device. The second form of Read behaves differently if there are no events to read in that it times out after the given number of seconds and microseconds have elapsed and returns false to the calling program.</p>
  </dd>
  <dt>
    <p><strong>void UnRead(Event&)</strong></p>
  </dt>
  <dd>
    <p>UnRead puts an event back on the input queue as if it had never been read.</p>
  </dd>
  <dt>
    <p><strong>virtual void Handle(Event&)</strong></p>
  </dt>
  <dd>
    <p>When an interactor wishes to pass an event to another interactor, it calls the other interactor's Handle operation. Thus, input flow control can be either procedural with Read or event-driven with Handle.</p>
  </dd>
  <dt>
    <p><strong>void Run()</strong></p>
  </dt>
  <dd>
    <p>Run implements a simple event dispatching loop. It calls Read to get the next event and passes the event to the target interactor via Handle. The loop terminates if the Handle operation sets the event's target to nil.</p>
  </dd>
  <dt>
    <p><strong>void QuitRunning(Event&)</strong></p>
  </dt>
  <dd>
    <p>QuitRunning sets the event's target to nil.  A Handle operation can call it to make Run exit its event dispatching loop.</p>
  </dd>
  <dt>
    <p><strong>boolean Check()</strong></p>
  </dt>
  <dd>
    <p>Check determines whether an event of interest has occurred.</p>
  </dd>
  <dt>
    <p><strong>void Poll(Event&)</strong></p>
  </dt>
  <dd>
    <p>Poll sets an event to reflect the current input state. Input polling can be wasteful of cycles and should be avoided if possible.</p>
  </dd>
  <dt>
    <p><strong>int CheckQueue()</strong></p>
  </dt>
  <dd>
    <p>CheckQueue returns the number of input packets that have been queued within the application. The event queue manager always reads as much information as possible from input; thus, a single Read might store many events in a local buffer.  Subsequent reads can simply access the buffer. This buffer can include out-of-band packets, such as those requiring a Redraw.  The number returned by CheckQueue does not correspond, therefore, to the actual number of input events.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VIEWS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>virtual void Adjust(Perspective&)</strong></p>
  </dt>
  <dd>
    <p>Adjust suggests to an interactor that its perspective should change to the given perspective; the interactor may choose to accept any part of the new perspective and must ensure that the parameter matches its (new) perspective before returning. Adjust can be used by another interactor to scroll, pan, or zoom an interactor.</p>
  </dd>
  <dt>
    <p><strong>Perspective* GetPerspective()</strong></p>
  </dt>
  <dd>
    <p>GetPerspective returns the perspective associated with an interactor or nil if the interactor has not assigned one.</p>
  </dd>
  <dt>
    <p><strong>virtual void Update()</strong></p>
  </dt>
  <dd>
    <p>Change the display to reflect some change in state that the interactor depends on. This operation is used in a number of contexts. One example is in managing perspectives. If an interactor changes its perspective (e.g., the total of size of what it is displaying changes), it must notify its perspective, which in turn calls Update on the interactors that access the perspective (such as a scroller).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROTECTED OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>virtual void Redraw(Coord l, Coord b, Coord r, Coord t)</strong></p>
  </dt>
  <dd>
    <p>The Redraw operation is called when some portion of the Interactor needs to be redrawn, presumably because it was previously obscured. The Redraw operation should NOT redraw interior interactors; the Interviews library or the Draw operation will call their Redraw operations automatically.  The default Redraw operation does nothing.</p>
  </dd>
  <dt>
    <p><strong>virtual void RedrawList(int n, Coord l[], Coord b[], Coord r[], Coord t[])</strong></p>
  </dt>
  <dd>
    <p>RedrawList notifies an interactor that several areas of its canvas need to be redrawn, presumably because it was raised to the top of other canvases.  The default RedrawList operation redraws each area separately with Redraw.</p>
  </dd>
  <dt>
    <p><strong>virtual void Resize()</strong></p>
  </dt>
  <dd>
    <p>Resize notifies an interactor that its canvas has been created or modified.  Only scenes are typically concerned with Resize, as they must place their component interactors within the new or resized canvas.  The default Resize operation does nothing.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Interactor&hellip;</h2>
        <div class="sectioncontent">
<p><em>InterViews Reference Manual</em>, Perspective(3I), Scene(3I), Sensor(3I), Shape(3I), World(3I)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="IOHandler.3I.html"><span aria-hidden="true">&larr;</span> IOHandler.3I: Read input, write output, or handle an i/o exception or timeout</a></li>
   <li class="next"><a href="MatchEditor.3I.html">MatchEditor.3I: Stringeditor with pattern matching <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

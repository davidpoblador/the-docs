<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoVRMLExtrusion: The sovrmlextrusion class is a a geometry node for extruding a cross section along a spine.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sovrmlextrusion class is a a geometry node for extruding a cross section along a spine.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoVRMLExtrusion (3) manual">
  <meta name="twitter:description" content="The sovrmlextrusion class is a a geometry node for extruding a cross section along a spine.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoVRMLExtrusion-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoVRMLExtrusion.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoVRMLExtrusion (3) manual" />
  <meta property="og:description" content="The sovrmlextrusion class is a a geometry node for extruding a cross section along a spine.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoVRMLExtrusion-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoVRMLExtrusion<small> (3)</small></h1>
        <p class="lead">The sovrmlextrusion class is a a geometry node for extruding a cross section along a spine.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoVRMLExtrusion.3.html">
      <span itemprop="name">SoVRMLExtrusion: The sovrmlextrusion class is a a geometry node for extruding a cross section along a spine.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoVRMLExtrusion.3.html">
      <span itemprop="name">SoVRMLExtrusion: The sovrmlextrusion class is a a geometry node for extruding a cross section along a spine.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/VRMLnodes/SoVRMLExtrusion.h&gt;</p><p>Inherits <strong>SoVRMLGeometry</strong>.</p><h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> <strong>SoVRMLExtrusion</strong> (void)</p><p>virtual void <strong>GLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>getPrimitiveCount</strong> (<strong>SoGetPrimitiveCountAction</strong> *action)</p><p>virtual void <strong>computeBBox</strong> (<strong>SoAction</strong> *action, <strong>SbBox3f</strong> &bbox, <strong>SbVec3f</strong> &center)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p>
<h3>Public Attributes</h3>
<p><strong>SoSFBool</strong> <strong>beginCap</strong></p><p><strong>SoSFBool</strong> <strong>ccw</strong></p><p><strong>SoSFBool</strong> <strong>convex</strong></p><p><strong>SoSFFloat</strong> <strong>creaseAngle</strong></p><p><strong>SoMFVec2f</strong> <strong>crossSection</strong></p><p><strong>SoSFBool</strong> <strong>endCap</strong></p><p><strong>SoMFRotation</strong> <strong>orientation</strong></p><p><strong>SoMFVec2f</strong> <strong>scale</strong></p><p><strong>SoSFBool</strong> <strong>solid</strong></p><p><strong>SoMFVec3f</strong> <strong>spine</strong></p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual <strong>~SoVRMLExtrusion</strong> ()</p><p>virtual void <strong>notify</strong> (<strong>SoNotList</strong> *list)</p><p>virtual void <strong>generatePrimitives</strong> (<strong>SoAction</strong> *action)</p><p>virtual <strong>SoDetail</strong> * <strong>createTriangleDetail</strong> (<strong>SoRayPickAction</strong> *action, const <strong>SoPrimitiveVertex</strong> *v1, const <strong>SoPrimitiveVertex</strong> *v2, const <strong>SoPrimitiveVertex</strong> *v3, <strong>SoPickedPoint</strong> *pp)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoVRMLExtrusion</strong> class is a a geometry node for extruding a cross section along a spine.</p><p><strong>The detailed class documentation is taken verbatim from the VRML97 standard (ISO/IEC 14772-1:1997). It is copyright The Web3D Consortium, and is used by permission of the Consortium:</strong></p>
<pre>
Extrusion {
  eventIn MFVec2f    set_crossSection
  eventIn MFRotation set_orientation
  eventIn MFVec2f    set_scale
  eventIn MFVec3f    set_spine
  field   SFBool     beginCap         TRUE
  field   SFBool     ccw              TRUE
  field   SFBool     convex           TRUE
  field   SFFloat    creaseAngle      0                # [0,inf)
  field   MFVec2f    crossSection     [ 1 1, 1 -1, -1 -1, -1 1, 1  1 ]    # (-inf,inf)
  field   SFBool     endCap           TRUE
  field   MFRotation orientation      0 0 1 0          # [-1,1],(-inf,inf)
  field   MFVec2f    scale            1 1              # (0,inf)
  field   SFBool     solid            TRUE
  field   MFVec3f    spine            [ 0 0 0, 0 1 0 ] # (-inf,inf)
}

</pre>
<p><em>Introduction</em></p><p>The Extrusion node specifies geometric shapes based on a two dimensional cross-section extruded along a three dimensional spine in the local coordinate system. The cross-section can be scaled and rotated at each spine point to produce a wide variety of shapes. An Extrusion node is defined by:</p><ul>
<li><p>a 2D crossSection piecewise linear curve (described as a series of connected vertices);</p></li>
</ul><ul>
<li><p>a 3D spine piecewise linear curve (also described as a series of connected vertices);</p></li>
</ul><ul>
<li><p>a list of 2D scale parameters;</p></li>
</ul><ul>
<li><p>a list of 3D orientation parameters.</p></li>
</ul><p><em>Algorithmic</em> <em>description</em></p><p>Shapes are constructed as follows. The cross-section curve, which starts as a curve in the Y=0 plane, is first scaled about the origin by the first scale parameter (first value scales in X, second value scales in Z). It is then translated by the first spine point and oriented using the first orientation parameter (as explained later). The same procedure is followed to place a cross- section at the second spine point, using the second scale and orientation values. Corresponding vertices of the first and second cross-sections are then connected, forming a quadrilateral polygon between each pair of vertices. This same procedure is then repeated for the rest of the spine points, resulting in a surface extrusion along the spine.</p><p>The final orientation of each cross-section is computed by first orienting it relative to the spine segments on either side of point at which the cross-section is placed. This is known as the spine-aligned cross-section plane (SCP), and is designed to provide a smooth transition from one spine segment to the next (see Figure 6.6). The SCP is then rotated by the corresponding orientation value. This rotation is performed relative to the SCP. For example, to impart twist in the cross- section, a rotation about the Y-axis (0 1 0) would be used. Other orientations are valid and rotate the cross-section out of the SCP.</p>
<pre>
  Figure 6.6
</pre>
<p>The SCP is computed by first computing its Y-axis and Z-axis, then taking the cross product of these to determine the X-axis. These three axes are then used to determine the rotation value needed to rotate the Y=0 plane to the SCP. This results in a plane that is the approximate tangent of the spine at each point, as shown in Figure 6.6. First the Y-axis is determined, as follows:</p><p>Let n be the number of spines and let i be the index variable satisfying 0 &lt;= i &lt; n:</p>
<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>For all points other than the first or last: The Y-axis for spine[i] is found by normalizing the vector defined by (spine[i+1]</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>spine[i-1]).</p>
  </dd>

</dl>
<ul>
<li><p>If the spine curve is closed: The SCP for the first and last points is the same and is found using (spine[1] - spine[n-2]) to compute the Y-axis.</p></li>
</ul><ul>
<li><p>If the spine curve is not closed: The Y-axis used for the first point is the vector from spine[0] to spine[1], and for the last it is the vector from spine[n-2] to spine[n-1].</p></li>
</ul><p>The Z-axis is determined as follows:</p><ul>
<li><p>For all points other than the first or last: Take the following cross-product:</p></li>
</ul>
<pre>
Z = (spine[i+1] - spine[i]) × (spine[i-1] - spine[i])
</pre>
<ul>
<li><p>If the spine curve is closed: The SCP for the first and last points is the same and is found by taking the following cross- product:</p></li>
</ul>
<pre>
Z = (spine[1] - spine[0]) × (spine[n-2] - spine[0])
</pre>
<ul>
<li><p>If the spine curve is not closed: The Z-axis used for the first spine point is the same as the Z-axis for spine[1]. The Z- axis used for the last spine point is the same as the Z-axis for spine[n-2].</p></li>
</ul><ul>
<li><p>After determining the Z-axis, its dot product with the Z-axis of the previous spine point is computed. If this value is negative, the Z-axis is flipped (multiplied by -1). In most cases, this prevents small changes in the spine segment angles from flipping the cross-section 180 degrees.</p></li>
</ul><p>Once the Y- and Z-axes have been computed, the X-axis can be calculated as their cross-product.</p><p><em>Special</em> <em>Cases</em></p><p>If the number of scale or orientation values is greater than the number of spine points, the excess values are ignored. If they contain one value, it is applied at all spine points. The results are undefined if the number of scale or orientation values is greater than one but less than the number of spine points. The scale values shall be positive.</p><p>If the three points used in computing the Z-axis are collinear, the cross-product is zero so the value from the previous point is used instead. If the Z-axis of the first point is undefined (because the spine is not closed and the first two spine segments are collinear) then the Z-axis for the first spine point with a defined Z-axis is used.</p><p>If the entire spine is collinear, the SCP is computed by finding the rotation of a vector along the positive Y-axis (v1) to the vector formed by the spine points (v2). The Y=0 plane is then rotated by this value. If two points are coincident, they both have the same SCP. If each point has a different orientation value, then the surface is constructed by connecting edges of the cross-sections as normal. This is useful in creating revolved surfaces.</p><p>Note: combining coincident and non-coincident spine segments, as well as other combinations, can lead to interpenetrating surfaces which the extrusion algorithm makes no attempt to avoid.</p><p><em>Common</em> <em>Cases</em></p><p>The following common cases are among the effects which are supported by the Extrusion node:</p><ul>
<li><p>Surfaces of revolution: If the cross-section is an approximation of a circle and the spine is straight, the Extrusion is equivalent to a surface of revolution, where the scale parameters define the size of the cross-section along the spine.</p></li>
</ul><ul>
<li><p>Uniform extrusions: If the scale is (1, 1) and the spine is straight, the cross-section is extruded uniformly without twisting or scaling along the spine. The result is a cylindrical shape with a uniform cross section.</p></li>
</ul><ul>
<li><p>Bend/twist/taper objects: These shapes are the result of using all fields. The spine curve bends the extruded shape defined by the cross-section, the orientation parameters (given as rotations about the Y-axis) twist it around the spine, and the scale parameters taper it (by scaling about the spine).</p></li>
</ul><p><em>Other</em> <em>Fields</em></p><p>Extrusion has three parts: the sides, the beginCap (the surface at the initial end of the spine) and the endCap (the surface at the final end of the spine). The caps have an associated SFBool field that indicates whether each exists (TRUE) or doesn't exist (FALSE).</p><p>When the beginCap or endCap fields are specified as TRUE, planar cap surfaces will be generated regardless of whether the crossSection is a closed curve. If crossSection is not a closed curve, the caps are generated by adding a final point to crossSection that is equal to the initial point. An open surface can still have a cap, resulting (for a simple case) in a shape analogous to a soda can sliced in half vertically. These surfaces are generated even if spine is also a closed curve. If a field value is FALSE, the corresponding cap is not generated.</p><p>Texture coordinates are automatically generated by Extrusion nodes. Textures are mapped so that the coordinates range in the U direction from 0 to 1 along the crossSection curve (with 0 corresponding to the first point in crossSection and 1 to the last) and in the V direction from 0 to 1 along the spine curve (with 0 corresponding to the first listed spine point and 1 to the last). If either the endCap or beginCap exists, the crossSection curve is uniformly scaled and translated so that the larger dimension of the cross-section (X or Z) produces texture coordinates that range from 0.0 to 1.0. The beginCap and endCap textures' S and T directions correspond to the X and Z directions in which the crossSection coordinates are defined.</p><p>The browser shall automatically generate normals for the Extrusion node,using the creaseAngle field to determine if and how normals are smoothed across the surface. Normals for the caps are generated along the Y-axis of the SCP, with the ordering determined by viewing the cross-section from above (looking along the negative Y-axis of the SCP). By default, a beginCap with a counterclockwise ordering shall have a normal along the negative Y-axis. An endCap with a counterclockwise ordering shall have a normal along the positive Y-axis.</p><p>Each quadrilateral making up the sides of the extrusion are ordered from the bottom cross-section (the one at the earlier spine point) to the top. So, one quadrilateral has the points:</p>
<pre>
spine[0](crossSection[0], crossSection[1])
spine[1](crossSection[1], crossSection[0])
</pre>
<p>in that order. By default, normals for the sides are generated as described in 4.6.3, Shapes and geometry (http://www.web3d.org/x3d/specifications/vrml/ISO-IEC-14772-VRML97/part1/concepts.html#4.6.3).</p><p>For instance, a circular crossSection with counter-clockwise ordering and the default spine form a cylinder. With solid TRUE and ccw TRUE, the cylinder is visible from the outside. Changing ccw to FALSE makes it visible from the inside. The ccw, solid, convex, and creaseAngle fields are described in 4.6.3, Shapes and geometry (http://www.web3d.org/x3d/specifications/vrml/ISO-IEC-14772-VRML97/part1/concepts.html#4.6.3).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoVRMLExtrusion::SoVRMLExtrusion (void)</h3>
<p>Constructor.</p>
<h3>SoVRMLExtrusion::~SoVRMLExtrusion ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoVRMLExtrusion::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Reimplemented from <strong>SoVRMLGeometry</strong>.</p>
<h3>const \fBSoFieldData\fP * SoVRMLExtrusion::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoVRMLGeometry</strong>.</p>
<h3>void SoVRMLExtrusion::GLRender (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGLRenderAction</strong>.</p><p>This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method.</p><p>Reimplemented from <strong>SoShape</strong>.</p>
<h3>void SoVRMLExtrusion::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetPrimitiveCountAction</strong>.</p><p>Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the <em>action</em>.</p><p>Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables.</p><p>Reimplemented from <strong>SoShape</strong>.</p>
<h3>void SoVRMLExtrusion::computeBBox (\fBSoAction\fP *action, \fBSbBox3f\fP &box, \fBSbVec3f\fP &center)\fC [virtual]\fP</h3>
<p>Implemented by <strong>SoShape</strong> subclasses to let the <strong>SoShape</strong> superclass know the exact size and weighted center point of the shape's bounding box.</p><p>The bounding box and center point should be calculated and returned in the local coordinate system.</p><p>The method implements action behavior for shape nodes for <strong>SoGetBoundingBoxAction</strong>. It is invoked from <strong>SoShape::getBoundingBox()</strong>. (Subclasses should <em>not</em> override <strong>SoNode::getBoundingBox()</strong>.)</p><p>The <em>box</em> parameter sent in is guaranteed to be an empty box, while <em>center</em> is undefined upon function entry.</p><p>Implements <strong>SoShape</strong>.</p>
<h3>void SoVRMLExtrusion::notify (\fBSoNotList\fP *l)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Notifies all auditors for this instance when changes are made.</p><p>Reimplemented from <strong>SoVRMLGeometry</strong>.</p>
<h3>void SoVRMLExtrusion::generatePrimitives (\fBSoAction\fP *action)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>The method implements action behavior for shape nodes for <strong>SoCallbackAction</strong>. It is invoked from <strong>SoShape::callback()</strong>. (Subclasses should <em>not</em> override <strong>SoNode::callback()</strong>.)</p><p>The subclass implementations uses the convenience methods <strong>SoShape::beginShape()</strong>, <strong>SoShape::shapeVertex()</strong>, and <strong>SoShape::endShape()</strong>, with <strong>SoDetail</strong> instances, to pass the primitives making up the shape back to the caller.</p><p>Implements <strong>SoShape</strong>.</p>
<h3>\fBSoDetail\fP * SoVRMLExtrusion::createTriangleDetail (\fBSoRayPickAction\fP *action, const \fBSoPrimitiveVertex\fP *v1, const \fBSoPrimitiveVertex\fP *v2, const \fBSoPrimitiveVertex\fP *v3, \fBSoPickedPoint\fP *pp)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Will create triangle detail for a <strong>SoPickedPoint</strong>. This method will only be called internally, when <strong>generatePrimitives()</strong> is used for picking (<strong>SoShape::rayPick()</strong> is not overridden).</p><p>This method returns NULL in Open Inventor, and subclasses will need to override this method to create details for a <strong>SoPickedPoint</strong>.</p><p>This is not necessary with Coin. Of course, if you choose to override it, it will work in the same way as Open Inventor.</p><p>For this to work, you must supply a face or line detail when generating primitives. If you supply NULL for the detail argument in <strong>SoShape::beginShape()</strong>, you'll have to override this method.</p><p>Reimplemented from <strong>SoShape</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoVRMLElevationGrid.3.html"><span aria-hidden="true">&larr;</span> SoVRMLElevationGrid.3: The sovrmlelevationgrid class is used to represent elevation grids.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium:</a></li>
   <li class="next"><a href="SoVRMLFog.3.html">SoVRMLFog.3: The sovrmlfog class is used to specify a global scene fog.  the detailed class documentation is taken verbatim from the vrml97 standard (iso/iec 14772-1:1997). it is copyright the web3d consortium, and is used by permission of the consortium: <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

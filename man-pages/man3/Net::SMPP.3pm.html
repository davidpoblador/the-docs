<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Net::SMPP: Pure perl implementation of smpp 3.4 over tcp</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Pure perl implementation of smpp 3.4 over tcp">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Net::SMPP (3pm) manual">
  <meta name="twitter:description" content="Pure perl implementation of smpp 3.4 over tcp">
  <meta name="twitter:image" content="https://www.carta.tech/images/libnet-smpp-perl-Net::SMPP-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Net::SMPP.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Net::SMPP (3pm) manual" />
  <meta property="og:description" content="Pure perl implementation of smpp 3.4 over tcp" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libnet-smpp-perl-Net::SMPP-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Net::SMPP<small> (3pm)</small></h1>
        <p class="lead">Pure perl implementation of smpp 3.4 over tcp</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Net::SMPP.3pm.html">
      <span itemprop="name">Net::SMPP: Pure perl implementation of smpp 3.4 over tcp</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libnet-smpp-perl/">
      <span itemprop="name">libnet-smpp-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Net::SMPP.3pm.html">
      <span itemprop="name">Net::SMPP: Pure perl implementation of smpp 3.4 over tcp</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Net::SMPP;
  $smpp = Net::SMPP-&gt;new_transceiver($host, port=&gt;$port,
                        system_id =&gt; &apos;yourusername&apos;,
                        password  =&gt; &apos;secret&apos;,
                        ) or die;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Implements Short Message Peer to Peer protocol, which is frequently used to pass short messages between mobile operators implementing short message service (\s-1SMS\s0). This is applicable to both european \s-1GSM\s0 and american \s-1CDMA/TDMA\s0 systems.</p><p>This documentation is not intended to be complete reference to \s-1SMPP\s0 protocol - use the \s-1SMPP\s0 specification documents (see references section) to obtain exact operation and parameter names and their meaning. You may also need to obtain site specific documentation about the remote end and any protocol extensions that it supports or demands before you start a project. This document follows the convention of spelling parameter names exactly as they appear in the \s-1SMPP\s0 v3.4 documentation. \s-1SMPP\s0 v4.0 support also follows the respective documentation, except where v4.0 usage is in conflict with v3.4 usage, in which case the latter prevails (in practise I believe no such conflicts remain in the madule at present). For a complete list of error code and optional parameter enumerations, the reader is encouraged to consult the source code or \s-1SMPP\s0 speciofications.</p><p>Despite its name, \s-1SMPP\s0 protocol defines a client (\s-1ESME\s0) and a server (often called \s-1SMSC\s0 in the mobile operator world). Client usually initiates the \s-1TCP\s0 connection and does <em>bind</em> to log in. After binding, a series of request response pairs, called PDUs (protocol data units) is exchanged. Request can be initiated by either end (hence \*(L"peer-to-peer\*(R"?) and the other end reponds. Requests are numbered with a sequence number and each response has corresponding sequence number. This allows several requests to be pending at the same time. Conceptually this is similar to \s-1IMAP\s0 or \s-1LDAP\s0 message IDs. Usually the $smpp object maintains the sequence numbers by itself and the programmer need not concern himself with their exact values, but should a need to override them arise, the seq argument can be supplied to any request or response method.</p><p>Normally this module operates in synchronous mode, meaning that a method that sends a request will also block until it gets the corresponding response. Internal command used for waiting for response is</p><p>    $resp_pdu = $smpp-&gt;wait_pdu($cmd_id, $seq);</p><p>If, while waiting for a particular response, other PDUs are received they are either handled by handlers (set up by constructor) or discarded. Both command code and sequence number must match. Typically a handler for enquire command is set up while all other commands are silently dropped. This practise may not be very suitable for transceiver mode of operation and certainly is not suitable for implementing a \s-1SMSC\s0.</p><p>Synchronous operation makes it impossible to interleave \s-1SMPP\s0 operations, thus it should be regarded as a simplified programming model for simple tasks. Anyone requiring more advanced control has to use the asynchronous mode and take up the burden of understanding and implementing more of the message flow logic in his own application.</p><p>In synchronous mode request \s-1PDU\s0 methods return a Net::SMPP::PDU object representing the response, if all went well protocolwise, or undef if there was a protocol level error. If undef was returned, the reason for the failure can be extracted from ${*$smpp}{smpperror} and ${*$smpp}{smpperrorcode} (actual codes are undocumented at the moment, but are guaranteed not to change) variables and the global variable $!. These variables are meaningless if anything else than undef was returned. The response itself may be an error response if there was an application level error in the remote end. In this case the application level error can be determined from $pdu-&gt;{status} field. Some responses also have optional parameters that further clarify the failure, see documentation for each operation.</p><p>If a protocol level error happens, probably the only safe action is to destroy the connection object (e.g. undef $smpp). If an application level error happens, then depending on how the remote end has been implemented it may be possible to continue operation.</p><p>Module can also be used asynchronously by specifying async=&gt;1 to the constructor. In this mode command methods return immediately with the sequence number of the \s-1PDU\s0 and user should poll for any responses using</p><p>    $pdu = $smpp-&gt;wait_pdu($cmd_id, $seq);</p><p>Typically <em>wait_pdu()</em> is used to wait for a response, but if <em>wait_pdu()</em> is used to wait for a command, the caller should generate appropriate response.</p><p>If caller wants to receive next available \s-1PDU\s0, he can call</p><p>    $pdu = $smpp-&gt;read_pdu();</p><p>which will block until a \s-1PDU\s0 is received from the stream. The caller would then have to check if the \s-1PDU\s0 is a response or a request and take appropriate action. The smsc.pl example program supplied with this distribution demonstrates a possible framework for handling both requests and responses.</p><p>If the caller does not want to block on <em>wait_pdu()</em> or <em>read_pdu()</em>, he must use <em>select()</em> to determine if the socket is readable (*** what if \s-1SSL\s0 layer gets inserted?). Even if the socket selects for reading, there may not be enough data to complete the \s-1PDU\s0, so the call may still block. Currently there is no reliable mechanism for avoiding this. If this bothers you, you may consider allocating a separate process for each connection so that blocking does not matter, or you may set up some sort of timeout (see <em>perlipc</em>\|(1) man page) or you may rewrite this module and contribute patches.</p><p>Response methods always return the sequence number, irrespective of synchronous or asynchronous mode, or undef if an error happened.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTORS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>new()</em>
  </dt>
  <dd>
    <p>Do not call. Has special internal meaning during accepting connections from listening socket.</p>
  </dd>
  <dt>
    <em>new_connect()</em>
  </dt>
  <dd>
    <p>Create a new \s-1SMPP\s0 client object and open conncetion to \s-1SMSC\s0 host     $smpp = Net::SMPP-&gt;new_connect($host,        system_id =&gt; &apos;username&apos;,   # usually needed (default &apos;&apos;)        password =&gt; &apos;secret&apos;,      # usually needed (default &apos;&apos;)        system_type =&gt; &apos;&apos;,         # default ok, often not needed        interface_version =&gt; 0x34, # default ok, almost never needed        addr_ton =&gt; 0x00,          # default ok, type of number unknwn        addr_npi =&gt; 0x00,          # default ok, number plan indicator        address_range =&gt; &apos;&apos;,       # default ok, regex matching nmbrs        ) or die; Usually this constructor is not called directly. Use <em>new_transceiver()</em>, <em>new_transmitter()</em>, and <em>new_receiver()</em> instead.</p>
  </dd>
  <dt>
    <em>new_transceiver()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>new_transmitter()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>new_receiver()</em>
  </dt>
  <dd>
    <p>These constructors first construct the object using <em>new_connect()</em> and then bind using given type of bind request. See bind family of methods, below. These constructors are usually used to implement \s-1ESME\s0 type functionality.</p>
  </dd>
  <dt>
    new_listen('localhost', port=&gt;2251)
  </dt>
  <dd>
    <p>Create new \s-1SMPP\s0 server object and open socket to listen on given port. This constructor is usually used to implement a \s-1SMSC\s0.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REQUEST PDU METHODS</h2>
        <div class="sectioncontent">
<p>Each request \s-1PDU\s0 method constructs a \s-1PDU\s0 from list of arguments supplied and sends it to the wire.</p><p>If async mode has been enabled (by specifying \*(L"async=&gt;1\*(R" in the constructor or as an argument to the method), the methods return sequence number of the \s-1PDU\s0 just sent. This number can be later used to match up the response, like this:</p><p>    $seq = $smpp-&gt;query_sm(message_id =&gt; $msg_id) or die;     ...     $resp_pdu = $smpp-&gt;wait_pdu(Net::SMPP::CMD_query_sm_resp, $seq)        or die;     die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;</p><p>If async mode is not enabled (i.e. \*(L"async=&gt;1\*(R" was not specified neither in constructor nor the method), the method will wait for the corresponding response and return Net::SMPP::PDU object representing that response. The application should check the outcome of the operation from the status field of the response \s-1PDU\s0, like this:</p><p>    $resp_pdu = $smpp-&gt;query_sm(message_id =&gt; $msg_id) or die;     die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;</p><p>All request \s-1PDU\s0 methods optionally take \*(L"seq=&gt;123\*(R" argument that allows explicit specification of the sequence number. The default is to increment internally stored sequence number by one and use that.</p><p>Most PDUs have mandatory parameters and optional parameters. If mandatory parameter is not supplied, it is inherited from the smpp object. This means that the parameter can either be set as an argument to the constructor or it is inherited from built-in defaults in the innards of Net::SMPP (see \*(C`Default\*(C' table from line 217 onwards). Some mandatory parameters can not be defaulted - if they are missing a die results. In descriptions below, defaultable mandatory parameters are show with the default value and comment indicating that its defaultable.</p><p>Optional parameters can be supplied to all PDUs (although the \s-1SMPP\s0 spec does not allow optional parameters for some PDUs, the module does not check for this) by listing them in the order that they should be appended to the end of the \s-1PDU\s0. Optional parameters can not be defaulted - if the parameter is not supplied, it simply is not included in the \s-1PDU\s0. Optional parameters are not supported by previous versions of the \s-1SMPP\s0 protocol (up to and including 3.3). Applications wishing to be downwards compatible should not make use of optional parameters.</p><p>Standard optional parameters can be supplied by their name (see \*(C`param_tab\*(C' in the Net::SMPP source code, around line 345, for list of known optional parameters), but the programmer still needs to supply the value of the parameter in the expected format (one often has to use pack to construct the value). Consult \s-1SMPP\s0 specifications for the correct format.</p><p>It is possible to supply arbitrary unsupported optional parameters by simply supplying the parameter tag as a decimal number. Consult your site dependent documentation to figure out the correct tags and to determine the correct format for the value.</p><p>When optional parameters are returned in response PDUs, they are decoded and made available under both numeric tag and symbolic tag, if known. For example the delivery_failure_reson of data_sm_resp can be accessed both as $resp-&gt;{delivery_failure_reson} and $resp-&gt;{1061}. The application needs to interpret the formatting of optional parameters itself. The module always assumes they are strings, while often they actually are interpretted as integers. Consult \s-1SMPP\s0 specifications and site dependent documentation for correct format and use unpack to obtain the numbers.</p><p>If an unknown nonnumeric parameter tags are supplied a warning is issued and parameter is skipped.</p><p>In general the Net::SMPP module does not enforce \s-1SMPP\s0 specifications. This means that it will happily accept too long or too short values for manatory or optional parameters. Also the internal formatting of the parameter values is not checked in any way. The programmer should consult the \s-1SMPP\s0 specifications to learn the correct length and format of each mandatory and optional parameter.</p><p>Similarily, if the remote end returns incorrect PDUs and Net::SMPP is able to parse them (usually because length fields match), then Net::SMPP will not perform any further checks. This means that some fields may be longer than allowed for in the specifications.</p><p>I opted to leave the checks out at this stage because I needed a flexible module that allowed me to explore even nonconformant \s-1SMSC\s0 implementations. If the lack of sanity checks bothers you, formulate such checks and submit me a patch. Ideally one could at construction time supply an argument like \*(L"strict=&gt;1\*(R" to enable the sanity checks.</p>
<dl class='dl-vertical'>
  <dt>
    <em>alert_notification()</em> (4.12.1, p.108)
  </dt>
  <dd>
    <p>Sent by \s-1SMSC\s0 to \s-1ESME\s0 when particular mobile subscriber has become available. source_addr specifies which mobile subscriber. esme_addr specifies which esme the message is destined to. Alert notifications can arise if delivery pending flag had been set for the subscriber from previous data_sm operation. There is no response \s-1PDU\s0.     $smpp-&gt;alert_notification(                               source_addr_ton =&gt; 0x00, # default ok                               source_addr_npi =&gt; 0x00, # default ok                               source_addr =&gt; &apos;&apos;,       # default ok                               esme_addr_ton =&gt; 0x00,   # default ok                               esme_addr_npi =&gt; 0x00,   # default ok                               esme_addr =&gt; $esme_addr, # mandatory                               ) or die;</p>
  </dd>
  <dt>
    <em>bind_transceiver()</em> (4.1.5, p.51)
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>bind_transmitter()</em> (4.1.1, p.46)
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>bind_receiver()</em> (4.1.3, p.48)
  </dt>
  <dd>
    <p>Bind family of methods is used to authenticate the client (\s-1ESME\s0) to the server (\s-1SMSC\s0). Usually bind happens as part of corresponding constructor \*(C`new_transceiver()\*(C', \*(C`new_transmitter()\*(C', or \*(C`new_receiver()\*(C' so these methods are rarely called directly. These methods take a plethora of options, which are largely the same as the options taken by the constructors and can safely be defaulted.     $smpp-&gt;bind_transceiver(        system_id =&gt; &apos;username&apos;,   # usually needed (default &apos;&apos;)        password =&gt; &apos;secret&apos;,      # usually needed (default &apos;&apos;)        system_type =&gt; &apos;&apos;,         # default ok, often not needed        interface_version =&gt; 0x34, # default ok, almost never needed        addr_ton =&gt; 0x00,          # default ok, type of number unkwn        addr_npi =&gt; 0x00,          # default ok, number plan indic.        address_range =&gt; &apos;&apos;,       # default ok, regex matching tels        ) or die; Typically it would be called like:     $resp_pdu = $smpp-&gt;bind_transceiver(system_id =&gt; &apos;username&apos;,                                         password =&gt; &apos;secret&apos;) or die;     die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status; or to inform \s-1SMSC\s0 that you can handle all Spanish numbers:     $resp_pdu = $smpp-&gt;bind_transceiver(system_id =&gt; &apos;username&apos;,                                         password =&gt; &apos;secret&apos;,                                         address_range =&gt; &apos;^&#92;+?34&apos;)        or die;     die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;</p>
  </dd>
  <dt>
    <em>cancel_sm()</em> (4.9.1, p.98)
  </dt>
  <dd>
    <p>Issued by \s-1ESME\s0 to cancel one or more short messages. Two principal modes of operation are: 1. if message_id is supplied, other fields can be left at defaults. This mode deletes just one message. 2. if message_id is not supplied (or is empty string), then the other fields must be supplied and all messages matching the criteria reflected by the other fields are deleted.     $smpp-&gt;cancel_sm(                      service_type =&gt; &apos;&apos;,      # default ok                      message_id =&gt; &apos;&apos;, # default ok, but often given                      source_addr_ton =&gt; 0x00, # default ok                      source_addr_npi =&gt; 0x00, # default ok                      source_addr =&gt; &apos;&apos;,       # default ok                      dest_addr_ton =&gt; 0x00,   # default ok                      dest_addr_npi =&gt; 0x00,   # default ok                      destination_addr =&gt; &apos;&apos;,  # default ok                    ) or die; For example    $resp_pdu = $smpp-&gt;submit_sm(destination_addr =&gt; &apos;+447799658372&apos;,                                  short_message =&gt; &apos;test message&apos;)       or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;    $msg_id = $resp_pdu-&gt;{message_id};</p><p>   $resp_pdu = $smpp-&gt;query_sm(message_id =&gt; $msg_id) or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;    print "Message state is $resp_pdu-&gt;{message_state}&#92;n";</p><p>   $resp_pdu = $smpp-&gt;replace_sm(message_id =&gt; $msg_id,                                  short_message =&gt; &apos;another test&apos;)       or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;</p><p>   $resp_pdu = $smpp-&gt;cancel_sm(message_id =&gt; $msg_id) or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;</p>
  </dd>
  <dt>
    <em>data_sm()</em> (4.7.1, p.87)
  </dt>
  <dd>
    <p>Newer alternative to submit_sm and deliver_sm. In addition to that data_sm can be used to pass special messages such as \s-1SMSC\s0 Delivery Receipt, \s-1SME\s0 Delivery Acknowledgement, \s-1SME\s0 Manual/User Acknowledgement, Intermediate notification. Unlike submit_sm and deliver_sm, the short_message parameter is not mandatory. Never-the-less, the optional parameter message_payload must be supplied for things to work correctly.     $smpp-&gt;data_sm(                    service_type =&gt; &apos;&apos;,      # default ok                    source_addr_ton =&gt; 0x00, # default ok                    source_addr_npi =&gt; 0x00, # default ok                    source_addr =&gt; &apos;&apos;,       # default ok                    dest_addr_ton =&gt; 0x00,   # default ok                    dest_addr_npi =&gt; 0x00,   # default ok                    destination_addr =&gt; $tel,  # mandatory                    esm_class =&gt; 0x00,       # default ok                    registered_delivery =&gt; 0x00, #default ok                    data_coding =&gt; 0x00,     # default ok                    message_payload =&gt; &apos;test msg&apos;, # opt, but needed                    ) or die; For example    $resp_pdu = $smpp-&gt;data_sm(destination_addr =&gt; &apos;+447799658372&apos;,                               message_payload =&gt; &apos;test message&apos;)       or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;</p>
  </dd>
  <dt>
    <em>deliver_sm()</em> (4.6.1, p.79)
  </dt>
  <dd>
    <p>Issued by \s-1SMSC\s0 to send message to an \s-1ESME\s0. Further more \s-1SMSC\s0 can transfer following special messages: 1. \s-1SMSC\s0 delivery receipt, 2. \s-1SME\s0 delivery acknowledgement, 3. \s-1SME\s0 Manual/User Acknowledgement, 4. Intermediate notification. These messages are sent in response to \s-1SMS\s0 message whose registered_delivery parameter requested them. If message data is longer than 254 bytes, the optional parameter \*(C`message_payload\*(C' should be used to store the message and \*(C`short_message\*(C' should be set to empty string. N.B. although protocol has mechanism for sending fairly large messages, the underlying mobile network usually does not support very large messages. \s-1GSM\s0 supports only up to 160 characters, other systems 128 or even just 100 characters.     $smpp-&gt;deliver_sm(                    service_type =&gt; &apos;&apos;,      # default ok                    source_addr_ton =&gt; 0x00, # default ok                    source_addr_npi =&gt; 0x00, # default ok                    source_addr =&gt; &apos;&apos;,       # default ok                    dest_addr_ton =&gt; 0x00,   # default ok                    dest_addr_npi =&gt; 0x00,   # default ok                    destination_addr =&gt; $t,  # mandatory                    esm_class =&gt; 0x00,       # default ok                    protocol_id =&gt; 0x00,     # default ok on CDMA,TDMA                                             #   on GSM value needed                    priority_flag =&gt; 0x00,   # default ok                    schedule_delivery_time =&gt; &apos;&apos;, # default ok                    validity_period =&gt; &apos;&apos;,        # default ok                    registered_delivery =&gt; 0x00,  # default ok                    replace_if_present_flag =&gt; 0x00, # default ok                    data_coding =&gt; 0x00,     # default ok                    sm_default_msg_id =&gt; 0x00,    # default ok                    short_message =&gt; &apos;&apos;,     # default ok, but                                             #   usually supplied                    ) or die; For example    $resp_pdu = $smpp-&gt;deliver_sm(destination_addr =&gt; &apos;+447799658372&apos;,                                  short_message =&gt; &apos;test message&apos;)       or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;</p>
  </dd>
  <dt>
    <em>enquire_link()</em> (4.11.1, p.106)
  </dt>
  <dd>
    <p>Used by either \s-1ESME\s0 or \s-1SMSC\s0 to \*(L"ping\*(R" the other side. Takes no parameters.     $smpp-&gt;enquire_link() or die;</p>
  </dd>
  <dt>
    <em>outbind()</em> (4.1.7, p.54, 2.2.1, p.16)
  </dt>
  <dd>
    <p>Used by \s-1SMSC\s0 to signal \s-1ESME\s0 to originate a \*(C`bind_receiver\*(C' request to the \s-1SMSC\s0. \*(C`system_id\*(C' and \*(C`password\*(C' authenticate the \s-1SMSC\s0 to the \s-1ESME\s0.  The \*(C`outbind\*(C' is used when \s-1SMSC\s0 initiates the \s-1TCP\s0 session and needs to trigger \s-1ESME\s0 to perform a \*(C`bind_receiver\*(C'. It is not needed if the \s-1ESME\s0 initiates the \s-1TCP\s0 connection (e.g. sec 2.7.1, p.27). There is not response \s-1PDU\s0 for \*(C`outbind\*(C', instead the \s-1ESME\s0 is expected to issue \*(C`bind_receiver\*(C'.     $smpp-&gt;outbind(                    system_id =&gt; &apos;&apos;,  # default ok, but usually given                    password =&gt; &apos;&apos;,   # default ok, but usually given                    ) or die;</p>
  </dd>
  <dt>
    <em>query_sm()</em> (4.8.1, p.95)
  </dt>
  <dd>
    <p>Used by \s-1ESME\s0 to query status of a submitted short message. Both message_id and source_addr must match (if source_addr was defaulted to \s-1NULL\s0 during submit, it must be \s-1NULL\s0 here, too). See example near \*(C`cancel_sm\*(C'.     $smpp-&gt;query_sm(                    message_id =&gt; $msg_id,   # mandatory                    source_addr_ton =&gt; 0x00, # default ok                    source_addr_npi =&gt; 0x00, # default ok                    source_addr =&gt; &apos;&apos;,       # default ok                    ) or die;</p>
  </dd>
  <dt>
    <em>replace_sm()</em> (4.10.1, p.102)
  </dt>
  <dd>
    <p>Used by \s-1ESME\s0 to replace a previously submitted short message, provided it is still pending delivery. Both message_id and source_addr must match (if source_addr was defaulted to \s-1NULL\s0 during submit, it must be \s-1NULL\s0 here, too). See example near \*(C`cancel_sm\*(C'.     $smpp-&gt;replace_sm(                    message_id =&gt; $msg_id,   # mandatory                    source_addr_ton =&gt; 0x00, # default ok                    source_addr_npi =&gt; 0x00, # default ok                    source_addr =&gt; &apos;&apos;,       # default ok                    schedule_delivery_time =&gt; &apos;&apos;, # default ok                    validity_period =&gt; &apos;&apos;,        # default ok                    registered_delivery =&gt; 0x00,  # default ok                    sm_default_msg_id =&gt; 0x00,    # default ok                    short_message =&gt; &apos;&apos;,     # default ok, but                                             #   usually supplied                    ) or die;</p>
  </dd>
  <dt>
    <em>submit_sm()</em> (4.4.1, p.59)
  </dt>
  <dd>
    <p>Used by \s-1ESME\s0 to submit short message to the \s-1SMSC\s0 for onward transmission to the specified short message entity (\s-1SME\s0). The submit_sm does not support the transaction message mode. If message data is longer than 254 bytes, the optional parameter \*(C`message_payload\*(C' should be used to store the message and \*(C`short_message\*(C' should be set to empty string. N.B. although protocol has mechanism for sending fairly large messages, the underlying mobile network usually does not support very large messages. \s-1GSM\s0 supports only up to 160 characters.     $smpp-&gt;submit_sm(                    service_type =&gt; &apos;&apos;,      # default ok                    source_addr_ton =&gt; 0x00, # default ok                    source_addr_npi =&gt; 0x00, # default ok                    source_addr =&gt; &apos;&apos;,       # default ok                    dest_addr_ton =&gt; 0x00,   # default ok                    dest_addr_npi =&gt; 0x00,   # default ok                    destination_addr =&gt; $t,  # mandatory                    esm_class =&gt; 0x00,       # default ok                    protocol_id =&gt; 0x00,     # default ok on CDMA,TDMA                                             #   on GSM value needed                    priority_flag =&gt; 0x00,   # default ok                    schedule_delivery_time =&gt; &apos;&apos;, # default ok                    validity_period =&gt; &apos;&apos;,        # default ok                    registered_delivery =&gt; 0x00,  # default ok                    replace_if_present_flag =&gt; 0x00, # default ok                    data_coding =&gt; 0x00,     # default ok                    sm_default_msg_id =&gt; 0x00,    # default ok                    short_message =&gt; &apos;&apos;,     # default ok, but                                             #   usually supplied                    ) or die; For example    $resp_pdu = $smpp-&gt;submit_sm(destination_addr =&gt; &apos;+447799658372&apos;,                                  short_message =&gt; &apos;test message&apos;)       or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status; Or    $resp_pdu = $smpp-&gt;submit_sm(destination_addr =&gt; &apos;+447799658372&apos;,                                 short_message =&gt; &apos;&apos;,                                 message_payload =&gt; &apos;a&apos;x500) or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status;</p>
  </dd>
  <dt>
    <em>submit_multi()</em> (4.5.1, p.69)
  </dt>
  <dd>
    <p>Used by \s-1ESME\s0 to submit short message to the \s-1SMSC\s0 for onward transmission to the specified short message entities (SMEs). This command is especially destined for multiple recepients. If message data is longer than 254 bytes, the optional parameter \*(C`message_payload\*(C' should be used to store the message and \*(C`short_message\*(C' should be set to empty string. N.B. although protocol has mechanism for sending fairly large messages, the underlying mobile network usually does not support very large messages. \s-1GSM\s0 supports only up to 160 characters.     $smpp-&gt;submit_multi(                    service_type =&gt; &apos;&apos;,      # default ok                    source_addr_ton =&gt; 0x00, # default ok                    source_addr_npi =&gt; 0x00, # default ok                    source_addr =&gt; &apos;&apos;,       # default ok                    dest_flag =&gt;             # default ok                         [ MULTIDESTFLAG_SME_Address,                           MULTIDESTFLAG_dist_list, ... ],                    dest_addr_ton =&gt;         # default ok                         [ 0x00, 0x00, ... ],                    dest_addr_npi =&gt;         # default ok                         [ 0x00, 0x00, ... ],                    destination_addr =&gt;      # mandatory                         [ $t1, $t2, ... ],                    esm_class =&gt; 0x00,       # default ok                    protocol_id =&gt; 0x00,     # default ok on CDMA,TDMA                                             #   on GSM value needed                    priority_flag =&gt; 0x00,   # default ok                    schedule_delivery_time =&gt; &apos;&apos;, # default ok                    validity_period =&gt; &apos;&apos;,        # default ok                    registered_delivery =&gt; 0x00,  # default ok                    replace_if_present_flag =&gt; 0x00, # default ok                    data_coding =&gt; 0x00,     # default ok                    sm_default_msg_id =&gt; 0x00,    # default ok                    short_message =&gt; &apos;&apos;,     # default ok, but                                             #   usually supplied                    ) or die; For example    $resp_pdu = $smpp-&gt;submit_multi(destination_addr =&gt;                                    [ &apos;+447799658372&apos;, &apos;+447799658373&apos; ],                                    short_message =&gt; &apos;test message&apos;)       or die;    die "Response indicated error: " . $resp_pdu-&gt;explain_status()        if $resp_pdu-&gt;status; The destinations are specified as an array reference. dest_flag, dest_addr_ton, and dest_addr_npi must have same cardinality as destination_addr if they are present. Default for dest_flag is MULTIDESTFLAG_SME_Address, i.e. normal phone number.</p>
  </dd>
  <dt>
    <em>unbind()</em> (4.2, p.56)
  </dt>
  <dd>
    <p>Used by \s-1ESME\s0 to unregisters \s-1ESME\s0 from \s-1SMSC\s0. Does not take any parameters.     $smpp-&gt;unbind() or die;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESPONSE PDU METHODS</h2>
        <div class="sectioncontent">
<p>Response \s-1PDU\s0 methods are used to indicate outcome of requested commands. Typically these methods would be used by someone implementing a server (\s-1SMSC\s0).</p><p>Response PDUs do not have separate asynchronous behaviour pattern.</p>
<dl class='dl-vertical'>
  <dt>
    <em>bind_receiver_resp()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>bind_transmitter_resp()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>bind_transceiver_resp()</em>
  </dt>
  <dd>
    <p>    $smpp-&gt;bind_transceiver_resp(                                  system_id =&gt; &apos;&apos;, # default ok                                  ) or die;</p>
  </dd>
  <dt>
    <em>cancel_sm_resp()</em> (4.9.2, p.100)
  </dt>
  <dd>
    <p>    $smpp-&gt;cancel_sm_resp() or die;</p>
  </dd>
  <dt>
    <em>data_sm_resp()</em>
  </dt>
  <dd>
    <p>    $smpp-&gt;data_sm_resp(message_id =&gt; $msg_id) or die;</p>
  </dd>
  <dt>
    <em>deliver_sm_resp()</em>
  </dt>
  <dd>
    <p>    $smpp-&gt;deliver_sm_resp(message_id =&gt; $msg_id) or die;</p>
  </dd>
  <dt>
    <em>enquire_link_resp()</em> (4.11.2, p.106)
  </dt>
  <dd>
    <p>    $smpp-&gt;enquire_link_resp() or die;</p>
  </dd>
  <dt>
    <em>generic_nack()</em> (4.3.1, p.57)
  </dt>
  <dd>
    <p>    $smpp-&gt;generic_nack() or die;</p>
  </dd>
  <dt>
    <em>query_sm_resp()</em> (4.6.2, p.96)
  </dt>
  <dd>
    <p>    $smpp-&gt;query_sm_resp(                          message_id =&gt; $msg_id,   # mandatory                          final_date =&gt; &apos;&apos;,        # default ok                          message_state =&gt; $state, # mandatory                          error_code =&gt; 0x00,      # default ok                    ) or die;</p>
  </dd>
  <dt>
    <em>replace_sm_resp()</em> (4.10.2, p.104)
  </dt>
  <dd>
    <p>    $smpp-&gt;replace_sm_resp() or die;</p>
  </dd>
  <dt>
    <em>submit_sm_resp()</em> (4.4.2, p.67)
  </dt>
  <dd>
    <p>    $smpp-&gt;submit_sm_resp(message_id =&gt; $msg_id) or die;</p>
  </dd>
  <dt>
    <em>submit_multi_resp()</em> (4.5.2, p.76)
  </dt>
  <dd>
    <p>    $smpp-&gt;submit_multi_resp(message_id =&gt; $msg_id                              dest_addr_ton =&gt; [], # default ok                              dest_addr_npi =&gt; [], # default ok                              destination_addr =&gt; [],  # mandatory                              error_status_code =&gt; [], # mandatory                              ) or die;</p>
  </dd>
  <dt>
    <em>unbind_resp()</em> (4.2.2, p.56)
  </dt>
  <dd>
    <p>    $smpp-&gt;unbind_resp() or die;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MESSAGE ENCODING AND LENGTH</h2>
        <div class="sectioncontent">
<p>Many \s-1SMS\s0 technologies have inherent message length limits. For example \s-1GSM\s0 specifies length to be 140 bytes. Using 7 bit encoding, this holds the 160 characters that people are familiar with. Net::SMPP does not enforce this limit in any way, i.e. if you create too long message, then it is your problem. You should at application layer make sure you stay within limits. Net::SMPP also does not automatically perform the encoding, not even if you set data_encoding parameter. Application layer is responsible for performing the encoding and setting the data_encoding parameter accordingly. To assist in performing the usual 7 bit encoding, following functions are provided (but you have to call them explicitly):</p>
<dl class='dl-vertical'>
  <dt>
    <em>pack_7bit()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>unpack_7bit()</em>
  </dt>
  <dd>
    <p>Example    $resp_pdu = $smpp-&gt;submit_sm(destination_addr =&gt; &apos;+447799658372&apos;,                                 data_encoding =&gt; 0x00,                                 short_message =&gt; pack_7bit(&apos;test message&apos;))       or die;</p>
  </dd>

</dl>
<p>The rationale for leaving encoding and length issues at application layer is two fold: 1. often the data is just copied through to another message or protocol, thus we do not really care how it is encoded or how long it is. Presumably it was valid at origin. 2. This policy avoids underlying technology dependencies in the module. Often local deployments have all the manner of hacks that make this area very difficult to chart. So I leave it to local application developer to find out what is locally needed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>read_pdu()</em>
  </dt>
  <dd>
    <p>Reads a \s-1PDU\s0 from stream and analyzes it into Net::SMPP::PDU object (if \s-1PDU\s0 is of known type). Blocks until \s-1PDU\s0 is available. If you do not want it to block, do select on the socket to make sure some data is available (unfortunately some data may be available, but not enough, so it can still block). <em>read_pdu()</em> is very useful for implementing main loop of \s-1SMSC\s0 where unknown PDUs must be received in random order and processed.     $pdu = $smpp-&gt;read_pdu() or die;</p>
  </dd>
  <dt>
    <em>wait_pdu()</em>
  </dt>
  <dd>
    <p>Reads PDUs from stream and handles or discards them until matching \s-1PDU\s0 is found. Blocks until success. Typically <em>wait_pdu()</em> is used internally by request methods when operating in synchronous mode.  The PDUs to handle are specified by \*(C`${*$me}{handlers}-\*(C'{$command_id}&gt;. The handlers table is initially populated to handle enquire_link PDUs automatically, but this can be altered using \*(C`handlers\*(C' argument to constructor.     $pdu = $smpp-&gt;wait_pdu($cmd_id_to_wait, $seq_to_wait) or die;</p>
  </dd>
  <dt>
    set_version($vers)
  </dt>
  <dd>
    <p>Sets the protocol version of the object either to 0x40 or 0x34. Its important to use this method instead of altering $smpp-&gt;{smpp_version} field directly because there are several other fields that have to be set in tandem.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Typical client:</p><p>  use Net::SMPP;   $smpp = Net::SMPP-&gt;new_transceiver(&apos;smsc.foo.net&apos;, port=&gt;2552) or die;   $resp_pdu = $smpp-&gt;submit_sm(destination_addr =&gt; &apos;447799658372&apos;,                                data =&gt; &apos;test message&apos;) or die;   ***</p><p>Typical server, run from inetd:</p><p>  ***</p><p>See test.pl for good templates with all official parameters, but beware that the actual parameter values are ficticious as is the flow of the dialog.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPART MESSAGE</h2>
        <div class="sectioncontent">
<p>Reportedly (Zeus Panchenko) multipart messages can be gotten to work with</p><p>  while (length ($msgtext)) {     if ($multimsg_maxparts) {       @udh_ar = map { sprintf "%x", $_ } $origref, $multimsg_maxparts, $multimsg_curpart;       $udh = pack("hhhhhh",0x05, 0x00, 0x03 , @udh_ar);       $resp_pdu = $smpp-&gt;submit_sm(destination_addr =&gt; $phone,                            ...                            short_message =&gt; $udh . $msgtext,                          );       ...     }   }</p><p>#4#cut =head1 \s-1VERSION\s0 4.0 \s-1SUPPORT\s0</p><p>Net::SMPP was originally written for version 3.4 of \s-1SMPP\s0 protocol. I have since then gotten specifications for an earlier protocol, the version 4.0 (Logical, eh? (pun intended)). In my understanding the relevant differences are as follows (n.b. (ok) marks difference that has already been implemented):</p><p>1. A reserved (always 0x00000000) field in message</p>
<pre>
   header (v4 p. 21) (ok)
</pre>
<p>2. Connection can not be opened in transceiver mode (this</p>
<pre>
   module will not enforce this restriction) (ok)
</pre>
<p>3. Command versioning. Version 0x01 == V4 (v4 p. 22) (ok)</p><p>4. Support for extended facilities has to be requested</p>
<pre>
   during bind (ok)
</pre>
<p>5. bind_* PDUs have facilities_mask field (v4 p. 25) (ok)</p><p>6. bind_*_resp PDUs have facilities_mask field (v4 p. 27) (ok)</p><p>7. outbind lacks system \s-1ID\s0 field (v4 p.30, v3.4 p. 54) (ok)</p><p>8. submit_sm lacks service_type and adds</p>
<pre>
   message_class (v4 p. 34, v3.4 p. 59) (ok)
</pre>
<p>9. submit_sm: telematic_interworking == protocol_id (ok)</p><p>10. submit_sm: starting from number of destinations and</p>
<pre>
    destination address the message format is substantially
    different. Actually the message format is somewhat
    similar to v3.4 submit_multi. (ok)
</pre>
<p>11. submit_sm: validity period encoded as an integer</p>
<pre>
    relative offset (was absolute time as C string) (ok)
</pre>
<p>12. submit_sm: replace_if_present flag missing (ok)</p><p>13. submit_sm: sm_length field is 2 octets (was one) (ok)</p><p>14. submit_sm_resp is completely different, but actually</p>
<pre>
    equal to v3.4 submit_multi_resp (v4 p. 37,
    v3.4 pp. 67,75) (ok)
</pre>
<p>15. submit_sm vs submit_multi: lacks service_type,</p>
<pre>
    adds message_class (ok)
</pre>
<p>16. submit_sm vs submit_multi: number_of_dests increased</p>
<pre>
    from 1 byte to 4 (ok)
</pre>
<p>17. submit_sm vs submit_multi: esm_class lacking, adds</p>
<pre>
    messaging_mode and msg_reference (ok)
</pre>
<p>18. submit_sm vs submit_multi: telematic_interworking == protocol_id (ok)</p><p>19. submit_sm vs submit_multi: replace_if_present missing (ok)</p><p>20. submit_sm vs submit_multi: sm_length is 2 bytes (was one) (ok)</p><p>21. submit_sm vs submit_multi: lacks dest_flag and distribution_list_name (ok)</p><p>22. deliver_sm: lacks service_type (ok)</p><p>23. deliver_sm: lacks esm_class, adds msg_reference and message_class (ok)</p><p>24. deliver_sm: telematic_interworking == protocol_id (ok)</p><p>25. deliver_sm: priority_level == priority_flag (ok)</p><p>26. deliver_sm: submit_time_stamp == schedule_delivery_time (ok)</p><p>27. deliver_sm: lacks validity_period, registered_delivery,</p>
<pre>
    and replace_if_present_flag (ok)
</pre>
<p>28. deliver_sm: lacks sm_default_msg_id (ok)</p><p>29. deliver_sm: sm_length is now 2 bytes (was one) (ok)</p><p>30. deliver_sm_resp: lacks message_id (v3.4 has the field, but its unused) (ok)</p><p>31. New command: delivery_receipt (ok)</p><p>32. New response: delivery_receipt_resp (ok)</p><p>33. query_sm: dest_addr_* fields added (v4 p. 46, v3.4 p. 95) (ok)</p><p>34. query_sm_resp: error_code renamed to network_error_code</p>
<pre>
    and increased in size from one to 4 bytes (ok)
</pre>
<p>35. cancel_sm: service_type renamed to message_class, also</p>
<pre>
    type changed (ok)
</pre>
<p>36. replace_sm: added dest_addr_* fields (ok)</p><p>37. replace_sm: data type of validity_period changed (ok)</p><p>38. replace_sm: added data_coding field (ok)</p><p>39. replace_sm: sm_length field increased from one to two bytes (ok)</p><p>40. In v3.4 command code 0x0009 means bind_transceiver,</p>
<pre>
    in v4.0 this very same code means delivery_receipt (bummer) (ok)
</pre>
<p>41. In v3.4 enquire_link is 0x0015 where as in v4 it is 0x000a (ok)</p><p>To create version 4 connection, you must specify smpp_version =&gt; 0x40 and you should not bind as transceiver as that is not supported by the specification.</p><p>As v3.4 specification seems more mature, I recommend that where attributes have been renamed between v4 and v3.4 you stick to using v3.4 names. I have tried to provide compatibility code whenever possible.</p><p>#4#end</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MISC. NOTES</h2>
        <div class="sectioncontent">
<p>Unless you wrote your program to be multithreaded or multiprocess, everything will happen in one thread of execution. Thus if you get unbind while doing something else (e.g. checking your spool directory), it stays in operating system level buffers until you actually call <em>read_pdu()</em>. Knowing about unbind or not is of little use. You can write your program to assume the network traffic arrives only exactly when you call <em>read_pdu()</em>.</p><p>Regarding the unbind, it is normally handled by a dispatch table automatically if you use <em>wait_pdu()</em> to receive your traffic. But if you created your own dispatch table, you will have to add it there yourself. If you are calling <em>read_pdu()</em> then you have to handle it yourslef. Even if you are using the supplied table, you may want to double check - there could be a bug.</p><p>One more thing: if your problem is knowing whether <em>wait_pdu()</em> or <em>read_pdu()</em> would block, then you have two possible solutions:</p><p>        1. use <a href="../man2/select.2.html"><strong>select</strong>(2)</a> systemcall to determine for the socket            is ready for reading         2. structure your program as several processes (e.g. one            for sending and one for receiving) so that you            can afford to block</p><p>The above two tricks are not specific to this module. Consult any standard text book on \s-1TCP/IP\s0 network programming.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p>Please consult \*(C`status_code\*(C' table in the beginning of the source code or \s-1SMPP\s0 specification section 5.1.3, table 5-2, pp.112-114.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORT</h2>
        <div class="sectioncontent">
<p>None by default.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TESTS / WHAT IS KNOWN TO WORK</h2>
        <div class="sectioncontent">
<p>Interoperates with itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TO DO AND BUGS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>read_pdu()</em> can block even if socket selects for reading.
  </dt>
  <dd>
    
  </dd>
  <dt>
    The submit_multi command has not been implemented.
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Sampo Kellomaki &lt;sampo@symlabs.com&gt;</p><p>Net::SMPP is copyright (c) 2001-2010 by Sampo Kellomaki, All rights reserved. Portions copyright (c) 2001-2005 by Symlabs, All rights reserved. You may use and distribute Net::SMPP under same terms as perl itself.</p><p>\s-1NET::SMPP\s0 \s-1COMES\s0 \s-1WITH\s0 \s-1ABSOLUTELY\s0 \s-1NO\s0 \s-1WARRANTY\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PLUG</h2>
        <div class="sectioncontent">
<p>This work was sponsored by Symlabs, the \s-1LDAP\s0 and directory experts (www.symlabs.com).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Net::SMPP&hellip;</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    test.pl from this package
  </dt>
  <dd>
    
  </dd>
  <dt>
    Short Message Peer to Peer Protocol Specification v3.4, 12-Oct-1999, Issue 1.2
  </dt>
  <dd>
    
  </dd>
  <dt>
    www.etsi.fr
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1GSM\s0 03.40, v5.7.1
  </dt>
  <dd>
    
  </dd>
  <dt>
    www.wapforum.org
  </dt>
  <dd>
    
  </dd>
  <dt>
    Short Message Peer to Peer (\s-1SMPP\s0) V4 Protocol Specification, 29-Apr-1997, Version 1.1 (from Aldiscon/Logica)  #4
  </dt>
  <dd>
    
  </dd>
  <dt>
    http://www.hsl.uk.com/documents/advserv-sms-smpp.pdf
  </dt>
  <dd>
    
  </dd>
  <dt>
    http://www.mobilesms.com/developers.asp
  </dt>
  <dd>
    
  </dd>
  <dt>
    http://opensmpp.logica.com
  </dt>
  <dd>
    
  </dd>
  <dt>
    www.smpp.org (it appears as of July 2007 domain squatters have taken over the site and it is no longer useful)
  </dt>
  <dd>
    
  </dd>
  <dt>
    http://www.smsforum.net/  \*(-- New place for info (as of 20081214). However, this page announces the death of itself as of July 27, 2007. Great. The \s-1SMS\s0 folks really do not want anyone to implement their protocols from specifications.
  </dt>
  <dd>
    
  </dd>
  <dt>
    http://freshmeat.net/projects/netsmpp/ (announcements about Net::SMPP)
  </dt>
  <dd>
    
  </dd>
  <dt>
    http://zxid.org/smpp/net-smpp.html (home page)
  </dt>
  <dd>
    
  </dd>
  <dt>
    http://cpan.org/modules/by-module/Net/Net-SMPP-1.12.tar.gz (download from \s-1CPAN\s0)
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>perl</em>\|(1)
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Net::SCP::Expect.3pm.html"><span aria-hidden="true">&larr;</span> Net::SCP::Expect.3pm: Wrapper for scp that allows passwords via expect.</a></li>
   <li class="next"><a href="Net::SMTP::SSL.3pm.html">Net::SMTP::SSL.3pm: Ssl support for net::smtp <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

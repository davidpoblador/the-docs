<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>tctdb: The table database api</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The table database api">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="tctdb (3) manual">
  <meta name="twitter:description" content="The table database api">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtokyocabinet-dev-tctdb-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/tctdb.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="tctdb (3) manual" />
  <meta property="og:description" content="The table database api" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtokyocabinet-dev-tctdb-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">tctdb<small> (3)</small></h1>
        <p class="lead">The table database api</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/tctdb.3.html">
      <span itemprop="name">tctdb: The table database api</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtokyocabinet-dev/">
      <span itemprop="name">libtokyocabinet-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/tctdb.3.html">
      <span itemprop="name">tctdb: The table database api</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Table database is a file containing records composed of the primary keys and arbitrary columns and is handled with the table database API.</p><p>To use the table database API, include `<strong>tcutil.h</strong>', `<strong>tctdb.h</strong>', and related standard header files.  Usually, write the following description near the front of a source file.</p><p><strong>#include &lt;tcutil.h&gt;</strong></p><p><strong>#include &lt;tctdb.h&gt;</strong></p><p><strong>#include &lt;stdlib.h&gt;</strong></p><p><strong>#include &lt;stdbool.h&gt;</strong></p><p><strong>#include &lt;stdint.h&gt;</strong></p><p>Objects whose type is pointer to `<strong>TCTDB</strong>' are used to handle table databases.  A table database object is created with the function `<strong>tctdbnew</strong>' and is deleted with the function `<strong>tctdbdel</strong>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p><p>Before operations to store or retrieve records, it is necessary to open a database file and connect the table database object to it.  The function `<strong>tctdbopen</strong>' is used to open a database file and the function `<strong>tctdbclose</strong>' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.  It is forbidden for multible database objects in a process to open the same database at the same time.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API</h2>
        <div class="sectioncontent">
<p>The function `tctdberrmsg' is used in order to get the message string corresponding to an error code.</p><p><strong>const char *tctdberrmsg(int </strong><em>ecode</em><strong>);</strong></p><p>`<em>ecode</em>' specifies the error code.</p><p>The return value is the message string of the error code.</p><p>The function `tctdbnew' is used in order to create a table database object.</p><p><strong>TCTDB *tctdbnew(void);</strong></p><p>The return value is the new table database object.</p><p>The function `tctdbdel' is used in order to delete a table database object.</p><p><strong>void tctdbdel(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</p><p>The function `tctdbecode' is used in order to get the last happened error code of a table database object.</p><p><strong>int tctdbecode(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>The return value is the last happened error code.</p><p>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</p><p>The function `tctdbsetmutex' is used in order to set mutual exclusion control of a table database object for threading.</p><p><strong>bool tctdbsetmutex(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object which is not opened.</p><p>If successful, the return value is true, else, it is false.</p><p>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should be called before the database is opened.</p><p>The function `tctdbtune' is used in order to set the tuning parameters of a table database object.</p><p><strong>bool tctdbtune(TCTDB *</strong><em>tdb</em><strong>, int64_t </strong><em>bnum</em><strong>, int8_t </strong><em>apow</em><strong>, int8_t </strong><em>fpow</em><strong>, uint8_t </strong><em>opts</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object which is not opened.</p><p>`<em>bnum</em>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 131071.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.</p><p>`<em>apow</em>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.</p><p>`<em>fpow</em>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</p><p>`<em>opts</em>' specifies options by bitwise-or: `TDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `TDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `TDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `TDBTTCBS' specifies that each record is compressed with TCBS encoding.</p><p>If successful, the return value is true, else, it is false.</p><p>Note that the tuning parameters should be set before the database is opened.</p><p>The function `tctdbsetcache' is set the caching parameters of a table database object.</p><p><strong>bool tctdbsetcache(TCTDB *</strong><em>tdb</em><strong>, int32_t </strong><em>rcnum</em><strong>, int32_t </strong><em>lcnum</em><strong>, int32_t </strong><em>ncnum</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object which is not opened.</p><p>`<em>rcnum</em>' specifies the maximum number of records to be cached.  If it is not more than 0, the record cache is disabled.  It is disabled by default.</p><p>`<em>lcnum</em>' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 4096.</p><p>`<em>ncnum</em>' specifies the maximum number of non-leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 512.</p><p>If successful, the return value is true, else, it is false.</p><p>Note that the caching parameters should be set before the database is opened.  Leaf nodes and non-leaf nodes are used in column indices.</p><p>The function `tctdbsetxmsiz' is used in order to set the size of the extra mapped memory of a table database object.</p><p><strong>bool tctdbsetxmsiz(TCTDB *</strong><em>tdb</em><strong>, int64_t </strong><em>xmsiz</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object which is not opened.</p><p>`<em>xmsiz</em>' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  The default size is 67108864.</p><p>If successful, the return value is true, else, it is false.</p><p>Note that the mapping parameters should be set before the database is opened.</p><p>The function `tctdbsetdfunit' is used in order to set the unit step number of auto defragmentation of a table database object.</p><p><strong>bool tctdbsetdfunit(TCTDB *</strong><em>tdb</em><strong>, int32_t </strong><em>dfunit</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object which is not opened.</p><p>`<em>dfunit</em>' specifie the unit step number.  If it is not more than 0, the auto defragmentation is disabled.  It is disabled by default.</p><p>If successful, the return value is true, else, it is false.</p><p>Note that the defragmentation parameters should be set before the database is opened.</p><p>The function `tctdbopen' is used in order to open a database file and connect a table database object.</p><p><strong>bool tctdbopen(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>path</em><strong>, int </strong><em>omode</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object which is not opened.</p><p>`<em>path</em>' specifies the path of the database file.</p><p>`<em>omode</em>' specifies the connection mode: `TDBOWRITER' as a writer, `TDBOREADER' as a reader.  If the mode is `TDBOWRITER', the following may be added by bitwise-or: `TDBOCREAT', which means it creates a new database if not exist, `TDBOTRUNC', which means it creates a new database regardless if one exists, `TDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `TDBOREADER' and `TDBOWRITER' can be added to by bitwise-or: `TDBONOLCK', which means it opens the database file without file locking, or `TDBOLCKNB', which means locking is performed without blocking.</p><p>If successful, the return value is true, else, it is false.</p><p>The function `tctdbclose' is used in order to close a table database object.</p><p><strong>bool tctdbclose(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>If successful, the return value is true, else, it is false.</p><p>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</p><p>The function `tctdbput' is used in order to store a record into a table database object.</p><p><strong>bool tctdbput(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, TCMAP *</strong><em>cols</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>cols</em>' specifies a map object containing columns.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, it is overwritten.</p><p>The function `tctdbput2' is used in order to store a string record into a table database object with a zero separated column string.</p><p><strong>bool tctdbput2(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, const void *</strong><em>cbuf</em><strong>, int </strong><em>csiz</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>cbuf</em>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</p><p>`<em>csiz</em>' specifies the size of the region of the column string.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, it is overwritten.</p><p>The function `tctdbput3' is used in order to store a string record into a table database object with a tab separated column string.</p><p><strong>bool tctdbput3(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>pkstr</em><strong>, const char *</strong><em>cstr</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkstr</em>' specifies the string of the primary key.</p><p>`<em>cstr</em>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, it is overwritten.</p><p>The function `tctdbputkeep' is used in order to store a new record into a table database object.</p><p><strong>bool tctdbputkeep(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, TCMAP *</strong><em>cols</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>cols</em>' specifies a map object containing columns.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, this function has no effect.</p><p>The function `tctdbputkeep2' is used in order to store a new string record into a table database object with a zero separated column string.</p><p><strong>bool tctdbputkeep2(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, const void *</strong><em>cbuf</em><strong>, int </strong><em>csiz</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>cbuf</em>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</p><p>`<em>csiz</em>' specifies the size of the region of the column string.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, this function has no effect.</p><p>The function `tctdbputkeep3' is used in order to store a new string record into a table database object with a tab separated column string.</p><p><strong>bool tctdbputkeep3(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>pkstr</em><strong>, const char *</strong><em>cstr</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkstr</em>' specifies the string of the primary key.</p><p>`<em>cstr</em>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, this function has no effect.</p><p>The function `tctdbputcat' is used in order to concatenate columns of the existing record in a table database object.</p><p><strong>bool tctdbputcat(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, TCMAP *</strong><em>cols</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>cols</em>' specifies a map object containing columns.</p><p>If successful, the return value is true, else, it is false.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tctdbputcat2' is used in order to concatenate columns in a table database object with a zero separated column string.</p><p><strong>bool tctdbputcat2(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, const void *</strong><em>cbuf</em><strong>, int </strong><em>csiz</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>cbuf</em>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</p><p>`<em>csiz</em>' specifies the size of the region of the column string.</p><p>If successful, the return value is true, else, it is false.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tctdbputcat3' is used in order to concatenate columns in a table database object with with a tab separated column string.</p><p><strong>bool tctdbputcat3(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>pkstr</em><strong>, const char *</strong><em>cstr</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkstr</em>' specifies the string of the primary key.</p><p>`<em>cstr</em>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</p><p>If successful, the return value is true, else, it is false.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tctdbout' is used in order to remove a record of a table database object.</p><p><strong>bool tctdbout(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>If successful, the return value is true, else, it is false.</p><p>The function `tctdbout2' is used in order to remove a string record of a table database object.</p><p><strong>bool tctdbout2(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>pkstr</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>pkstr</em>' specifies the string of the primary key.</p><p>If successful, the return value is true, else, it is false.</p><p>The function `tctdbget' is used in order to retrieve a record in a table database object.</p><p><strong>TCMAP *tctdbget(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>If successful, the return value is a map object of the columns of the corresponding record.  `NULL' is returned if no record corresponds.</p><p>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</p><p>The function `tctdbget2' is used in order to retrieve a record in a table database object as a zero separated column string.</p><p><strong>char *tctdbget2(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>pkbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>pksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the column string of the corresponding record.  `NULL' is returned if no record corresponds.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tctdbget3' is used in order to retrieve a string record in a table database object as a tab separated column string.</p><p><strong>char *tctdbget3(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>pkstr</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>pkstr</em>' specifies the string of the primary key.</p><p>If successful, the return value is the tab separated column string of the corresponding record.  `NULL' is returned if no record corresponds.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tctdbvsiz' is used in order to get the size of the value of a record in a table database object.</p><p><strong>int tctdbvsiz(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>ksiz</em>' specifies the size of the region of the primary key.</p><p>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</p><p>The function `tctdbvsiz2' is used in order to get the size of the value of a string record in a table database object.</p><p><strong>int tctdbvsiz2(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>pkstr</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>kstr</em>' specifies the string of the primary key.</p><p>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</p><p>The function `tctdbiterinit' is used in order to initialize the iterator of a table database object.</p><p><strong>bool tctdbiterinit(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>If successful, the return value is true, else, it is false.</p><p>The iterator is used in order to access the primary key of every record stored in a database.</p><p>The function `tctdbiternext' is used in order to get the next primary key of the iterator of a table database object.</p><p><strong>void *tctdbiternext(TCTDB *</strong><em>tdb</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the next primary key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</p><p>The function `tctdbiternext2' is used in order to get the next primary key string of the iterator of a table database object.</p><p><strong>char *tctdbiternext2(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>If successful, the return value is the string of the next primary key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</p><p>The function `tctdbiternext3' is used in order to get the columns of the next record of the iterator of a table database object.</p><p><strong>TCMAP *tctdbiternext3(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>If successful, the return value is a map object of the columns of the next record, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.  The primary key is added into the map as a column of an empty string key.</p><p>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</p><p>The function `tctdbfwmkeys' is used in order to get forward matching primary keys in a table database object.</p><p><strong>TCLIST *tctdbfwmkeys(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pbuf</em><strong>, int </strong><em>psiz</em><strong>, int </strong><em>max</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>pbuf</em>' specifies the pointer to the region of the prefix.</p><p>`<em>psiz</em>' specifies the size of the region of the prefix.</p><p>`<em>max</em>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</p><p>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</p><p>The function `tctdbfwmkeys2' is used in order to get forward matching string primary keys in a table database object.</p><p><strong>TCLIST *tctdbfwmkeys2(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>pstr</em><strong>, int </strong><em>max</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>pstr</em>' specifies the string of the prefix.</p><p>`<em>max</em>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</p><p>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</p><p>The function `tctdbaddint' is used in order to add an integer to a column of a record in a table database object.</p><p><strong>int tctdbaddint(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>ksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>num</em>' specifies the additional value.</p><p>If successful, the return value is the summation value, else, it is `INT_MIN'.</p><p>The additional value is stored as a decimal string value of a column whose name is "_num".  If no record corresponds, a new record with the additional value is stored.</p><p>The function `tctdbadddouble' is used in order to add a real number to a column of a record in a table database object.</p><p><strong>double tctdbadddouble(TCTDB *</strong><em>tdb</em><strong>, const void *</strong><em>pkbuf</em><strong>, int </strong><em>pksiz</em><strong>, double </strong><em>num</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the primary key.</p><p>`<em>ksiz</em>' specifies the size of the region of the primary key.</p><p>`<em>num</em>' specifies the additional value.</p><p>If successful, the return value is the summation value, else, it is Not-a-Number.</p><p>The additional value is stored as a decimal string value of a column whose name is "_num".  If no record corresponds, a new record with the additional value is stored.</p><p>The function `tctdbsync' is used in order to synchronize updated contents of a table database object with the file and the device.</p><p><strong>bool tctdbsync(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>If successful, the return value is true, else, it is false.</p><p>This function is useful when another process connects to the same database file.</p><p>The function `tctdboptimize' is used in order to optimize the file of a table database object.</p><p><strong>bool tctdboptimize(TCTDB *</strong><em>tdb</em><strong>, int64_t </strong><em>bnum</em><strong>, int8_t </strong><em>apow</em><strong>, int8_t </strong><em>fpow</em><strong>, uint8_t </strong><em>opts</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>bnum</em>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.</p><p>`<em>apow</em>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</p><p>`<em>fpow</em>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</p><p>`<em>opts</em>' specifies options by bitwise-or: `TDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `TDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `TDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `TDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</p><p>If successful, the return value is true, else, it is false.</p><p>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</p><p>The function `tctdbvanish' is used in order to remove all records of a table database object.</p><p><strong>bool tctdbvanish(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>If successful, the return value is true, else, it is false.</p><p>The function `tctdbcopy' is used in order to copy the database file of a table database object.</p><p><strong>bool tctdbcopy(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>path</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>`<em>path</em>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</p><p>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</p><p>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</p><p>The function `tctdbtranbegin' is used in order to begin the transaction of a table database object.</p><p><strong>bool tctdbtranbegin(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>If successful, the return value is true, else, it is false.</p><p>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  Because all pages are cached on memory while the transaction, the amount of referred records is limited by the memory capacity.  If the database is closed during transaction, the transaction is aborted implicitly.</p><p>The function `tctdbtrancommit' is used in order to commit the transaction of a table database object.</p><p><strong>bool tctdbtrancommit(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>If successful, the return value is true, else, it is false.</p><p>Update in the transaction is fixed when it is committed successfully.</p><p>The function `tctdbtranabort' is used in order to abort the transaction of a table database object.</p><p><strong>bool tctdbtranabort(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>If successful, the return value is true, else, it is false.</p><p>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</p><p>The function `tctdbpath' is used in order to get the file path of a table database object.</p><p><strong>const char *tctdbpath(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</p><p>The function `tctdbrnum' is used in order to get the number of records ccccof a table database object.</p><p><strong>uint64_t tctdbrnum(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>The return value is the number of records or 0 if the object does not connect to any database file.</p><p>The function `tctdbfsiz' is used in order to get the size of the database file of a table database object.</p><p><strong>uint64_t tctdbfsiz(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>The return value is the size of the database file or 0 if the object does not connect to any database file.</p><p>The function `tctdbsetindex' is used in order to set a column index to a table database object.</p><p><strong>bool tctdbsetindex(TCTDB *</strong><em>tdb</em><strong>, const char *</strong><em>name</em><strong>, int </strong><em>type</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>`<em>name</em>' specifies the name of a column.  If the name of an existing index is specified, the index is rebuilt.  An empty string means the primary key.</p><p>`<em>type</em>' specifies the index type: `TDBITLEXICAL' for lexical string, `TDBITDECIMAL' for decimal string, `TDBITTOKEN' for token inverted index, `TDBITQGRAM' for q-gram inverted index.  If it is `TDBITOPT', the index is optimized.  If it is `TDBITVOID', the index is removed.  If `TDBITKEEP' is added by bitwise-or and the index exists, this function merely returns failure.</p><p>If successful, the return value is true, else, it is false.</p><p>Note that the setting indices should be set after the database is opened.</p><p>The function `tctdbgenuid' is used in order to generate a unique ID number of a table database object.</p><p><strong>int64_t tctdbgenuid(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object connected as a writer.</p><p>The return value is the new unique ID number or -1 on failure.</p><p>The function `tctdbqrynew' is used in order to create a query object.</p><p><strong>TDBQRY *tctdbqrynew(TCTDB *</strong><em>tdb</em><strong>);</strong></p><p>`<em>tdb</em>' specifies the table database object.</p><p>The return value is the new query object.</p><p>The function `tctdbqrydel' is used in order to delete a query object.</p><p><strong>void tctdbqrydel(TDBQRY *</strong><em>qry</em><strong>);</strong></p><p>`<em>qry</em>' specifies the query object.</p><p>The function `tctdbqryaddcond' is used in order to add a narrowing condition to a query object.</p><p><strong>void tctdbqryaddcond(TDBQRY *</strong><em>qry</em><strong>, const char *</strong><em>name</em><strong>, int </strong><em>op</em><strong>, const char *</strong><em>expr</em><strong>);</strong></p><p>`<em>qry</em>' specifies the query object.</p><p>`<em>name</em>' specifies the name of a column.  An empty string means the primary key.</p><p>`<em>op</em>' specifies an operation type: `TDBQCSTREQ' for string which is equal to the expression, `TDBQCSTRINC' for string which is included in the expression, `TDBQCSTRBW' for string which begins with the expression, `TDBQCSTREW' for string which ends with the expression, `TDBQCSTRAND' for string which includes all tokens in the expression, `TDBQCSTROR' for string which includes at least one token in the expression, `TDBQCSTROREQ' for string which is equal to at least one token in the expression, `TDBQCSTRRX' for string which matches regular expressions of the expression, `TDBQCNUMEQ' for number which is equal to the expression, `TDBQCNUMGT' for number which is greater than the expression, `TDBQCNUMGE' for number which is greater than or equal to the expression, `TDBQCNUMLT' for number which is less than the expression, `TDBQCNUMLE' for number which is less than or equal to the expression, `TDBQCNUMBT' for number which is between two tokens of the expression, `TDBQCNUMOREQ' for number which is equal to at least one token in the expression, `TDBQCFTSPH' for full-text search with the phrase of the expression, `TDBQCFTSAND' for full-text search with all tokens in the expression, `TDBQCFTSOR' for full-text search with at least one token in the expression, `TDBQCFTSEX' for full-text search with the compound expression.  All operations can be flagged by bitwise-or: `TDBQCNEGATE' for negation, `TDBQCNOIDX' for using no index.</p><p>`<em>expr</em>' specifies an operand exression.</p><p>The function `tctdbqrysetorder' is used in order to set the order of a query object.</p><p><strong>void tctdbqrysetorder(TDBQRY *</strong><em>qry</em><strong>, const char *</strong><em>name</em><strong>, int </strong><em>type</em><strong>);</strong></p><p>`<em>qry</em>' specifies the query object.</p><p>`<em>name</em>' specifies the name of a column.  An empty string means the primary key.</p><p>`<em>type</em>' specifies the order type: `TDBQOSTRASC' for string ascending, `TDBQOSTRDESC' for string descending, `TDBQONUMASC' for number ascending, `TDBQONUMDESC' for number descending.</p><p>The function `tctdbqrysetlimit' is used in order to set the limit number of records of the result of a query object.</p><p><strong>void tctdbqrysetlimit(TDBQRY *</strong><em>qry</em><strong>, int </strong><em>max</em><strong>, int </strong><em>skip</em><strong>);</strong></p><p>`<em>qry</em>' specifies the query object.</p><p>`<em>max</em>' specifies the maximum number of records of the result.  If it is negative, no limit is specified.</p><p>`<em>skip</em>' specifies the number of skipped records of the result.  If it is not more than 0, no record is skipped.</p><p>The function `tctdbqrysearch' is used in order to execute the search of a query object.</p><p><strong>TCLIST *tctdbqrysearch(TDBQRY *</strong><em>qry</em><strong>);</strong></p><p>`<em>qry</em>' specifies the query object.</p><p>The return value is a list object of the primary keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tctdbqrysearchout' is used in order to remove each record corresponding to a query object.</p><p><strong>bool tctdbqrysearchout(TDBQRY *</strong><em>qry</em><strong>);</strong></p><p>`<em>qry</em>' specifies the query object of the database connected as a writer.</p><p>If successful, the return value is true, else, it is false.</p><p>The function `tctdbqryproc' is used in order to process each record corresponding to a query object.</p><p><strong>bool tctdbqryproc(TDBQRY *</strong><em>qry</em><strong>, TDBQRYPROC </strong><em>proc</em><strong>, void *</strong><em>op</em><strong>);</strong></p><p>`<em>qry</em>' specifies the query object of the database connected as a writer.</p><p>`<em>proc</em>' specifies the pointer to the iterator function called for each record.  It receives four parameters.  The first parameter is the pointer to the region of the primary key.  The second parameter is the size of the region of the primary key.  The third parameter is a map object containing columns.  The fourth parameter is the pointer to the optional opaque object.  It returns flags of the post treatment by bitwise-or: `TDBQPPUT' to modify the record, `TDBQPOUT' to remove the record, `TDBQPSTOP' to stop the iteration.</p><p>`<em>op</em>' specifies an arbitrary pointer to be given as a parameter of the iterator function.  If it is not needed, `NULL' can be specified.</p><p>If successful, the return value is true, else, it is false.</p><p>The function `tctdbqryhint' is used in order to get the hint string of a query object.</p><p><strong>const char *tctdbqryhint(TDBQRY *</strong><em>qry</em><strong>);</strong></p><p>`<em>qry</em>' specifies the query object.</p><p>The return value is the hint string.</p><p>The function `tctdbmetasearch' is used in order to retrieve records with multiple query objects and get the set of the result.</p><p><strong>TCLIST *tctdbmetasearch(TDBQRY **</strong><em>qrys</em><strong>, int </strong><em>num</em><strong>, int </strong><em>type</em><strong>);</strong></p><p>`<em>qrys</em>' specifies an array of the query objects.</p><p>`<em>num</em>' specifies the number of elements of the array.</p><p>`<em>type</em>' specifies a set operation type: `TDBMSUNION' for the union set, `TDBMSISECT' for the intersection set, `TDBMSDIFF' for the difference set.</p><p>The return value is a list object of the primary keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</p><p>If the first query object has the order setting, the result array is sorted by the order.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO tctdb&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/tcttest.1.html"><strong>tcttest</strong>(1)</a>, <a href="../man1/tctmttest.1.html"><strong>tctmttest</strong>(1)</a>, <a href="../man1/tctmgr.1.html"><strong>tctmgr</strong>(1)</a>, <a href="../man3/tokyocabinet.3.html"><strong>tokyocabinet</strong>(3)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="tcsetpgrp.3.html"><span aria-hidden="true">&larr;</span> tcsetpgrp.3: Get and set terminal foreground process group</a></li>
   <li class="next"><a href="tctree.3.html">tctree.3: The utility api <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mxml: Mini-xml api</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Mini-xml api">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mxml (3) manual">
  <meta name="twitter:description" content="Mini-xml api">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmxml-dev-mxml-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/mxml.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mxml (3) manual" />
  <meta property="og:description" content="Mini-xml api" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmxml-dev-mxml-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mxml<small> (3)</small></h1>
        <p class="lead">Mini-xml api</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mxml.3.html">
      <span itemprop="name">mxml: Mini-xml api</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmxml-dev/">
      <span itemprop="name">libmxml-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mxml.3.html">
      <span itemprop="name">mxml: Mini-xml api</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INCLUDE FILE</h2>
        <div class="sectioncontent">
<p>#include &lt;mxml.h&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIBRARY</h2>
        <div class="sectioncontent">
<p>-lmxml</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Mini-XML is a small XML parsing library that you can use to read XML and XML-like data files in your application without requiring large non-standard libraries.  Mini-XML only requires an ANSI C compatible compiler (GCC works, as do most vendors' ANSI C compilers) and a "make" program.</p><p>Mini-XML provides the following functionality:</p><ul>
<li><p>Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded XML files and strings.</p></li><li><p>Data is stored in a linked-list tree structure, preserving the XML data hierarchy.</p></li><li><p>Supports arbitrary element names, attributes, and attribute values with no preset limits, just available memory.</p></li><li><p>Supports integer, real, opaque ("cdata"), and text data types in "leaf" nodes.</p></li><li><p>Functions for creating, indexing, and managing trees of data.</p></li><li><p>"Find" and "walk" functions for easily locating and navigating trees of data.</p></li>
</ul><p>Mini-XML doesn't do validation or other types of processing on the data based upon schema files or other sources of definition information, nor does it support character entities other than those required by the XML specification.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USING MINI-XML</h2>
        <div class="sectioncontent">
<p>Mini-XML provides a single header file which you include:</p>
<pre>
    #include &lt;mxml.h&gt;
</pre>
<p>Nodes are defined by the "mxml_node_t" structure; the "type" member defines the node type (element, integer, opaque, real, or text) which determines which value you want to look at in the "value" union.  New nodes can be created using the "mxmlNewElement()", "mxmlNewInteger()", "mxmlNewOpaque()", "mxmlNewReal()", and "mxmlNewText()" functions.  Only elements can have child nodes, and the top node must be an element, usually "?xml".</p><p>You load an XML file using the "mxmlLoadFile()" function:</p>
<pre>
    FILE *fp;
    mxml_node_t *tree;

    fp = fopen("filename.xml", "r");
    tree = mxmlLoadFile(NULL, fp, MXML_NO_CALLBACK);
    fclose(fp);
</pre>
<p>Similarly, you save an XML file using the "mxmlSaveFile()" function:</p>
<pre>
    FILE *fp;
    mxml_node_t *tree;

    fp = fopen("filename.xml", "w");
    mxmlSaveFile(tree, fp, MXML_NO_CALLBACK);
    fclose(fp);
</pre>
<p>The "mxmlLoadString()", "mxmlSaveAllocString()", and "mxmlSaveString()" functions load XML node trees from and save XML node trees to strings:</p>
<pre>
    char buffer[8192];
    char *ptr;
    mxml_node_t *tree;

    ...
    tree = mxmlLoadString(NULL, buffer, MXML_NO_CALLBACK);

    ...
    mxmlSaveString(tree, buffer, sizeof(buffer),
                   MXML_NO_CALLBACK);

    ...
    ptr = mxmlSaveAllocString(tree, MXML_NO_CALLBACK);
</pre>
<p>You can find a named element/node using the "mxmlFindElement()" function:</p>
<pre>
    mxml_node_t *node = mxmlFindElement(tree, tree, "name",
                                        "attr", "value",
                                        MXML_DESCEND);
</pre>
<p>The "name", "attr", and "value" arguments can be passed as NULL to act as wildcards, e.g.:</p>
<pre>
    /* Find the first "a" element */
    node = mxmlFindElement(tree, tree, "a", NULL, NULL,
                           MXML_DESCEND);

    /* Find the first "a" element with "href" attribute */
    node = mxmlFindElement(tree, tree, "a", "href", NULL,
                           MXML_DESCEND);

    /* Find the first "a" element with "href" to a URL */
    node = mxmlFindElement(tree, tree, "a", "href",
                           "http://www.easysw.com/~mike/mxml/",
                           MXML_DESCEND);

    /* Find the first element with a "src" attribute*/
    node = mxmlFindElement(tree, tree, NULL, "src", NULL,
                           MXML_DESCEND);

    /* Find the first element with a "src" = "foo.jpg" */
    node = mxmlFindElement(tree, tree, NULL, "src",
                           "foo.jpg", MXML_DESCEND);
</pre>
<p>You can also iterate with the same function:</p>
<pre>
    mxml_node_t *node;

    for (node = mxmlFindElement(tree, tree, "name", NULL,
                                NULL, MXML_DESCEND);
         node != NULL;
         node = mxmlFindElement(node, tree, "name", NULL,
                                NULL, MXML_DESCEND))
    {
      ... do something ...
    }
</pre>
<p>Finally, once you are done with the XML data, use the "mxmlDelete()" function to recursively free the memory that is used for a particular node or the entire tree:</p>
<pre>
    mxmlDelete(tree);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENUMERATIONS</h2>
        <div class="sectioncontent">
<h3>mxml_sax_event_e</h3>
<p>SAX event type.</p>
<dl class='dl-vertical'>
  <dt>
    <p>MXML_SAX_CDATA</p>
  </dt>
  <dd>
    <p>CDATA node</p>
  </dd>
  <dt>
    <p>MXML_SAX_COMMENT</p>
  </dt>
  <dd>
    <p>Comment node</p>
  </dd>
  <dt>
    <p>MXML_SAX_DATA</p>
  </dt>
  <dd>
    <p>Data node</p>
  </dd>
  <dt>
    <p>MXML_SAX_DIRECTIVE</p>
  </dt>
  <dd>
    <p>Processing directive node</p>
  </dd>
  <dt>
    <p>MXML_SAX_ELEMENT_CLOSE</p>
  </dt>
  <dd>
    <p>Element closed</p>
  </dd>
  <dt>
    <p>MXML_SAX_ELEMENT_OPEN</p>
  </dt>
  <dd>
    <p>Element opened</p>
  </dd>

</dl>

<h3>mxml_type_e</h3>
<p>The XML node type.</p>
<dl class='dl-vertical'>
  <dt>
    <p>MXML_CUSTOM</p>
  </dt>
  <dd>
    <p>Custom data</p>
  </dd>
  <dt>
    <p>MXML_ELEMENT</p>
  </dt>
  <dd>
    <p>XML element with attributes</p>
  </dd>
  <dt>
    <p>MXML_IGNORE</p>
  </dt>
  <dd>
    <p>Ignore/throw away node</p>
  </dd>
  <dt>
    <p>MXML_INTEGER</p>
  </dt>
  <dd>
    <p>Integer value</p>
  </dd>
  <dt>
    <p>MXML_OPAQUE</p>
  </dt>
  <dd>
    <p>Opaque string</p>
  </dd>
  <dt>
    <p>MXML_REAL</p>
  </dt>
  <dd>
    <p>Real value</p>
  </dd>
  <dt>
    <p>MXML_TEXT</p>
  </dt>
  <dd>
    <p>Text fragment</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<h3>mxmlAdd</h3>
<p>Add a node to a tree.</p>
<pre>
void mxmlAdd (
    mxml_node_t *parent,
    int where,
    mxml_node_t *child,
    mxml_node_t *node
);
</pre>
<p>Adds the specified node to the parent. If the child argument is not NULL, puts the new node before or after the specified child depending on the value of the where argument. If the child argument is NULL, puts the new node at the beginning of the child list (MXML_ADD_BEFORE) or at the end of the child list (MXML_ADD_AFTER). The constant MXML_ADD_TO_PARENT can be used to specify a NULL child pointer.</p>
<h3>mxmlDelete</h3>
<p>Delete a node and all of its children.</p>
<pre>
void mxmlDelete (
    mxml_node_t *node
);
</pre>
<p>If the specified node has a parent, this function first removes the node from its parent using the mxmlRemove() function.</p>
<h3>mxmlElementDeleteAttr</h3>
<p>Delete an attribute.</p>
<pre>
void mxmlElementDeleteAttr (
    mxml_node_t *node,
    const char *name
);
</pre>

<h3>mxmlElementGetAttr</h3>
<p>Get an attribute.</p>
<pre>
const char * mxmlElementGetAttr (
    mxml_node_t *node,
    const char *name
);
</pre>
<p>This function returns NULL if the node is not an element or the named attribute does not exist.</p>
<h3>mxmlElementSetAttr</h3>
<p>Set an attribute.</p>
<pre>
void mxmlElementSetAttr (
    mxml_node_t *node,
    const char *name,
    const char *value
);
</pre>
<p>If the named attribute already exists, the value of the attribute is replaced by the new string value. The string value is copied into the element node. This function does nothing if the node is not an element.</p>
<h3>mxmlElementSetAttrf</h3>
<p>Set an attribute with a formatted value.</p>
<pre>
void mxmlElementSetAttrf (
    mxml_node_t *node,
    const char *name,
    const char *format,
    ...
);
</pre>
<p>If the named attribute already exists, the value of the attribute is replaced by the new formatted string. The formatted string value is copied into the element node. This function does nothing if the node is not an element.</p>
<h3>mxmlEntityAddCallback</h3>
<p>Add a callback to convert entities to Unicode.</p>
<pre>
int  mxmlEntityAddCallback (
    mxml_entity_cb_t cb
);
</pre>

<h3>mxmlEntityGetName</h3>
<p>Get the name that corresponds to the character value.</p>
<pre>
const char * mxmlEntityGetName (
    int val
);
</pre>
<p>If val does not need to be represented by a named entity, NULL is returned.</p>
<h3>mxmlEntityGetValue</h3>
<p>Get the character corresponding to a named entity.</p>
<pre>
int  mxmlEntityGetValue (
    const char *name
);
</pre>
<p>The entity name can also be a numeric constant. -1 is returned if the name is not known.</p>
<h3>mxmlEntityRemoveCallback</h3>
<p>Remove a callback.</p>
<pre>
void mxmlEntityRemoveCallback (
    mxml_entity_cb_t cb
);
</pre>

<h3>mxmlFindElement</h3>
<p>Find the named element.</p>
<pre>
mxml_node_t * mxmlFindElement (
    mxml_node_t *node,
    mxml_node_t *top,
    const char *name,
    const char *attr,
    const char *value,
    int descend
);
</pre>
<p>The search is constrained by the name, attribute name, and value; any NULL names or values are treated as wildcards, so different kinds of searches can be implemented by looking for all elements of a given name or all elements with a specific attribute. The descend argument determines whether the search descends into child nodes; normally you will use MXML_DESCEND_FIRST for the initial search and MXML_NO_DESCEND to find additional direct descendents of the node. The top node argument constrains the search to a particular node's children.</p>
<h3>mxmlIndexDelete</h3>
<p>Delete an index.</p>
<pre>
void mxmlIndexDelete (
    mxml_index_t *ind
);
</pre>

<h3>mxmlIndexEnum</h3>
<p>Return the next node in the index.</p>
<pre>
mxml_node_t * mxmlIndexEnum (
    mxml_index_t *ind
);
</pre>
<p>Nodes are returned in the sorted order of the index.</p>
<h3>mxmlIndexFind</h3>
<p>Find the next matching node.</p>
<pre>
mxml_node_t * mxmlIndexFind (
    mxml_index_t *ind,
    const char *element,
    const char *value
);
</pre>
<p>You should call mxmlIndexReset() prior to using this function for the first time with a particular set of "element" and "value" strings. Passing NULL for both "element" and "value" is equivalent to calling mxmlIndexEnum().</p>
<h3>mxmlIndexNew</h3>
<p>Create a new index.</p>
<pre>
mxml_index_t * mxmlIndexNew (
    mxml_node_t *node,
    const char *element,
    const char *attr
);
</pre>
<p>The index will contain all nodes that contain the named element and/or attribute. If both "element" and "attr" are NULL, then the index will contain a sorted list of the elements in the node tree.  Nodes are sorted by element name and optionally by attribute value if the "attr" argument is not NULL.</p>
<h3>mxmlIndexReset</h3>
<p>Reset the enumeration/find pointer in the index and return the first node in the index.</p>
<pre>
mxml_node_t * mxmlIndexReset (
    mxml_index_t *ind
);
</pre>
<p>This function should be called prior to using mxmlIndexEnum() or mxmlIndexFind() for the first time.</p>
<h3>mxmlLoadFd</h3>
<p>Load a file descriptor into an XML node tree.</p>
<pre>
mxml_node_t * mxmlLoadFd (
    mxml_node_t *top,
    int fd,
    mxml_load_cb_t cb
);
</pre>
<p>The nodes in the specified file are added to the specified top node. If no top node is provided, the XML file MUST be well-formed with a single parent node like &lt;?xml&gt; for the entire file. The callback function returns the value type that should be used for child nodes. If MXML_NO_CALLBACK is specified then all child nodes will be either MXML_ELEMENT or MXML_TEXT nodes.</p><p>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK, MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading child nodes of the specified type.</p>
<h3>mxmlLoadFile</h3>
<p>Load a file into an XML node tree.</p>
<pre>
mxml_node_t * mxmlLoadFile (
    mxml_node_t *top,
    FILE *fp,
    mxml_load_cb_t cb
);
</pre>
<p>The nodes in the specified file are added to the specified top node. If no top node is provided, the XML file MUST be well-formed with a single parent node like &lt;?xml&gt; for the entire file. The callback function returns the value type that should be used for child nodes. If MXML_NO_CALLBACK is specified then all child nodes will be either MXML_ELEMENT or MXML_TEXT nodes.</p><p>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK, MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading child nodes of the specified type.</p>
<h3>mxmlLoadString</h3>
<p>Load a string into an XML node tree.</p>
<pre>
mxml_node_t * mxmlLoadString (
    mxml_node_t *top,
    const char *s,
    mxml_load_cb_t cb
);
</pre>
<p>The nodes in the specified string are added to the specified top node. If no top node is provided, the XML string MUST be well-formed with a single parent node like &lt;?xml&gt; for the entire string. The callback function returns the value type that should be used for child nodes. If MXML_NO_CALLBACK is specified then all child nodes will be either MXML_ELEMENT or MXML_TEXT nodes.</p><p>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK, MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading child nodes of the specified type.</p>
<h3>mxmlNewCDATA</h3>
<p>Create a new CDATA node.</p>
<pre>
mxml_node_t * mxmlNewCDATA (
    mxml_node_t *parent,
    const char *data
);
</pre>
<p>The new CDATA node is added to the end of the specified parent's child list. The constant MXML_NO_PARENT can be used to specify that the new CDATA node has no parent. The data string must be nul-terminated and is copied into the new node. CDATA nodes use the MXML_ELEMENT type.</p>
<h3>mxmlNewCustom</h3>
<p>Create a new custom data node.</p>
<pre>
mxml_node_t * mxmlNewCustom (
    mxml_node_t *parent,
    void *data,
    mxml_custom_destroy_cb_t destroy
);
</pre>
<p>The new custom node is added to the end of the specified parent's child list. The constant MXML_NO_PARENT can be used to specify that the new element node has no parent. NULL can be passed when the data in the node is not dynamically allocated or is separately managed.</p>
<h3>mxmlNewElement</h3>
<p>Create a new element node.</p>
<pre>
mxml_node_t * mxmlNewElement (
    mxml_node_t *parent,
    const char *name
);
</pre>
<p>The new element node is added to the end of the specified parent's child list. The constant MXML_NO_PARENT can be used to specify that the new element node has no parent.</p>
<h3>mxmlNewInteger</h3>
<p>Create a new integer node.</p>
<pre>
mxml_node_t * mxmlNewInteger (
    mxml_node_t *parent,
    int integer
);
</pre>
<p>The new integer node is added to the end of the specified parent's child list. The constant MXML_NO_PARENT can be used to specify that the new integer node has no parent.</p>
<h3>mxmlNewOpaque</h3>
<p>Create a new opaque string.</p>
<pre>
mxml_node_t * mxmlNewOpaque (
    mxml_node_t *parent,
    const char *opaque
);
</pre>
<p>The new opaque node is added to the end of the specified parent's child list. The constant MXML_NO_PARENT can be used to specify that the new opaque node has no parent. The opaque string must be nul-terminated and is copied into the new node.</p>
<h3>mxmlNewReal</h3>
<p>Create a new real number node.</p>
<pre>
mxml_node_t * mxmlNewReal (
    mxml_node_t *parent,
    double real
);
</pre>
<p>The new real number node is added to the end of the specified parent's child list. The constant MXML_NO_PARENT can be used to specify that the new real number node has no parent.</p>
<h3>mxmlNewText</h3>
<p>Create a new text fragment node.</p>
<pre>
mxml_node_t * mxmlNewText (
    mxml_node_t *parent,
    int whitespace,
    const char *string
);
</pre>
<p>The new text node is added to the end of the specified parent's child list. The constant MXML_NO_PARENT can be used to specify that the new text node has no parent. The whitespace parameter is used to specify whether leading whitespace is present before the node. The text string must be nul-terminated and is copied into the new node.</p>
<h3>mxmlNewTextf</h3>
<p>Create a new formatted text fragment node.</p>
<pre>
mxml_node_t * mxmlNewTextf (
    mxml_node_t *parent,
    int whitespace,
    const char *format,
    ...
);
</pre>
<p>The new text node is added to the end of the specified parent's child list. The constant MXML_NO_PARENT can be used to specify that the new text node has no parent. The whitespace parameter is used to specify whether leading whitespace is present before the node. The format string must be nul-terminated and is formatted into the new node.</p>
<h3>mxmlNewXML</h3>
<p>Create a new XML document tree.</p>
<pre>
mxml_node_t * mxmlNewXML (
    const char *version
);
</pre>
<p>The "version" argument specifies the version number to put in the ?xml element node. If NULL, version 1.0 is assumed.</p>
<h3>mxmlRelease</h3>
<p>Release a node.</p>
<pre>
int  mxmlRelease (
    mxml_node_t *node
);
</pre>
<p>When the reference count reaches zero, the node (and any children) is deleted via mxmlDelete().</p>
<h3>mxmlRemove</h3>
<p>Remove a node from its parent.</p>
<pre>
void mxmlRemove (
    mxml_node_t *node
);
</pre>
<p>Does not free memory used by the node - use mxmlDelete() for that. This function does nothing if the node has no parent.</p>
<h3>mxmlRetain</h3>
<p>Retain a node.</p>
<pre>
int  mxmlRetain (
    mxml_node_t *node
);
</pre>

<h3>mxmlSAXLoadFd</h3>
<p>Load a file descriptor into an XML node tree using a SAX callback.</p>
<pre>
mxml_node_t * mxmlSAXLoadFd (
    mxml_node_t *top,
    int fd,
    mxml_load_cb_t cb,
    mxml_sax_cb_t sax_cb,
    void *sax_data
);
</pre>
<p>The nodes in the specified file are added to the specified top node. If no top node is provided, the XML file MUST be well-formed with a single parent node like &lt;?xml&gt; for the entire file. The callback function returns the value type that should be used for child nodes. If MXML_NO_CALLBACK is specified then all child nodes will be either MXML_ELEMENT or MXML_TEXT nodes.</p><p>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK, MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading child nodes of the specified type.</p><p>The SAX callback must call mxmlRetain() for any nodes that need to be kept for later use. Otherwise, nodes are deleted when the parent node is closed or after each data, comment, CDATA, or directive node.</p>
<h3>mxmlSAXLoadFile</h3>
<p>Load a file into an XML node tree using a SAX callback.</p>
<pre>
mxml_node_t * mxmlSAXLoadFile (
    mxml_node_t *top,
    FILE *fp,
    mxml_load_cb_t cb,
    mxml_sax_cb_t sax_cb,
    void *sax_data
);
</pre>
<p>The nodes in the specified file are added to the specified top node. If no top node is provided, the XML file MUST be well-formed with a single parent node like &lt;?xml&gt; for the entire file. The callback function returns the value type that should be used for child nodes. If MXML_NO_CALLBACK is specified then all child nodes will be either MXML_ELEMENT or MXML_TEXT nodes.</p><p>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK, MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading child nodes of the specified type.</p><p>The SAX callback must call mxmlRetain() for any nodes that need to be kept for later use. Otherwise, nodes are deleted when the parent node is closed or after each data, comment, CDATA, or directive node.</p>
<h3>mxmlSAXLoadString</h3>
<p>Load a string into an XML node tree using a SAX callback.</p>
<pre>
mxml_node_t * mxmlSAXLoadString (
    mxml_node_t *top,
    const char *s,
    mxml_load_cb_t cb,
    mxml_sax_cb_t sax_cb,
    void *sax_data
);
</pre>
<p>The nodes in the specified string are added to the specified top node. If no top node is provided, the XML string MUST be well-formed with a single parent node like &lt;?xml&gt; for the entire string. The callback function returns the value type that should be used for child nodes. If MXML_NO_CALLBACK is specified then all child nodes will be either MXML_ELEMENT or MXML_TEXT nodes.</p><p>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK, MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading child nodes of the specified type.</p><p>The SAX callback must call mxmlRetain() for any nodes that need to be kept for later use. Otherwise, nodes are deleted when the parent node is closed or after each data, comment, CDATA, or directive node.</p>
<h3>mxmlSaveAllocString</h3>
<p>Save an XML node tree to an allocated string.</p>
<pre>
char * mxmlSaveAllocString (
    mxml_node_t *node,
    mxml_save_cb_t cb
);
</pre>
<p>This function returns a pointer to a string containing the textual representation of the XML node tree.  The string should be freed using the free() function when you are done with it.  NULL is returned if the node would produce an empty string or if the string cannot be allocated.</p><p>The callback argument specifies a function that returns a whitespace string or NULL before and after each element. If MXML_NO_CALLBACK is specified, whitespace will only be added before MXML_TEXT nodes with leading whitespace and before attribute names inside opening element tags.</p>
<h3>mxmlSaveFd</h3>
<p>Save an XML tree to a file descriptor.</p>
<pre>
int  mxmlSaveFd (
    mxml_node_t *node,
    int fd,
    mxml_save_cb_t cb
);
</pre>
<p>The callback argument specifies a function that returns a whitespace string or NULL before and after each element. If MXML_NO_CALLBACK is specified, whitespace will only be added before MXML_TEXT nodes with leading whitespace and before attribute names inside opening element tags.</p>
<h3>mxmlSaveFile</h3>
<p>Save an XML tree to a file.</p>
<pre>
int  mxmlSaveFile (
    mxml_node_t *node,
    FILE *fp,
    mxml_save_cb_t cb
);
</pre>
<p>The callback argument specifies a function that returns a whitespace string or NULL before and after each element. If MXML_NO_CALLBACK is specified, whitespace will only be added before MXML_TEXT nodes with leading whitespace and before attribute names inside opening element tags.</p>
<h3>mxmlSaveString</h3>
<p>Save an XML node tree to a string.</p>
<pre>
int  mxmlSaveString (
    mxml_node_t *node,
    char *buffer,
    int bufsize,
    mxml_save_cb_t cb
);
</pre>
<p>This function returns the total number of bytes that would be required for the string but only copies (bufsize - 1) characters into the specified buffer.</p><p>The callback argument specifies a function that returns a whitespace string or NULL before and after each element. If MXML_NO_CALLBACK is specified, whitespace will only be added before MXML_TEXT nodes with leading whitespace and before attribute names inside opening element tags.</p>
<h3>mxmlSetCDATA</h3>
<p>Set the element name of a CDATA node.</p>
<pre>
int  mxmlSetCDATA (
    mxml_node_t *node,
    const char *data
);
</pre>
<p>The node is not changed if it is not a CDATA element node.</p>
<h3>mxmlSetCustom</h3>
<p>Set the data and destructor of a custom data node.</p>
<pre>
int  mxmlSetCustom (
    mxml_node_t *node,
    void *data,
    mxml_custom_destroy_cb_t destroy
);
</pre>
<p>The node is not changed if it is not a custom node.</p>
<h3>mxmlSetCustomHandlers</h3>
<p>Set the handling functions for custom data.</p>
<pre>
void mxmlSetCustomHandlers (
    mxml_custom_load_cb_t load,
    mxml_custom_save_cb_t save
);
</pre>
<p>The load function accepts a node pointer and a data string and must return 0 on success and non-zero on error.</p><p>The save function accepts a node pointer and must return a malloc'd string on success and NULL on error.</p>
<h3>mxmlSetElement</h3>
<p>Set the name of an element node.</p>
<pre>
int  mxmlSetElement (
    mxml_node_t *node,
    const char *name
);
</pre>
<p>The node is not changed if it is not an element node.</p>
<h3>mxmlSetErrorCallback</h3>
<p>Set the error message callback.</p>
<pre>
void mxmlSetErrorCallback (
    mxml_error_cb_t cb
);
</pre>

<h3>mxmlSetInteger</h3>
<p>Set the value of an integer node.</p>
<pre>
int  mxmlSetInteger (
    mxml_node_t *node,
    int integer
);
</pre>
<p>The node is not changed if it is not an integer node.</p>
<h3>mxmlSetOpaque</h3>
<p>Set the value of an opaque node.</p>
<pre>
int  mxmlSetOpaque (
    mxml_node_t *node,
    const char *opaque
);
</pre>
<p>The node is not changed if it is not an opaque node.</p>
<h3>mxmlSetReal</h3>
<p>Set the value of a real number node.</p>
<pre>
int  mxmlSetReal (
    mxml_node_t *node,
    double real
);
</pre>
<p>The node is not changed if it is not a real number node.</p>
<h3>mxmlSetText</h3>
<p>Set the value of a text node.</p>
<pre>
int  mxmlSetText (
    mxml_node_t *node,
    int whitespace,
    const char *string
);
</pre>
<p>The node is not changed if it is not a text node.</p>
<h3>mxmlSetTextf</h3>
<p>Set the value of a text node to a formatted string.</p>
<pre>
int  mxmlSetTextf (
    mxml_node_t *node,
    int whitespace,
    const char *format,
    ...
);
</pre>
<p>The node is not changed if it is not a text node.</p>
<h3>mxmlSetWrapMargin</h3>
<p>Set the the wrap margin when saving XML data.</p>
<pre>
void mxmlSetWrapMargin (
    int column
);
</pre>
<p>Wrapping is disabled when "column" is 0.</p>
<h3>mxmlWalkNext</h3>
<p>Walk to the next logical node in the tree.</p>
<pre>
mxml_node_t * mxmlWalkNext (
    mxml_node_t *node,
    mxml_node_t *top,
    int descend
);
</pre>
<p>The descend argument controls whether the first child is considered to be the next node. The top node argument constrains the walk to the node's children.</p>
<h3>mxmlWalkPrev</h3>
<p>Walk to the previous logical node in the tree.</p>
<pre>
mxml_node_t * mxmlWalkPrev (
    mxml_node_t *node,
    mxml_node_t *top,
    int descend
);
</pre>
<p>The descend argument controls whether the previous node's last child is considered to be the previous node. The top node argument constrains the walk to the node's children.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STRUCTURES</h2>
        <div class="sectioncontent">
<h3>mxml_attr_s</h3>
<p>An XML element attribute value.</p>
<pre>
struct mxml_attr_s
{
  char *name;
  char *value;
};
</pre>

<h3>mxml_custom_s</h3>
<p>An XML custom value.</p>
<pre>
struct mxml_custom_s
{
  void *data;
  mxml_custom_destroy_cb_t destroy;
};
</pre>

<h3>mxml_element_s</h3>
<p>An XML element value.</p>
<pre>
struct mxml_element_s
{
  mxml_attr_t *attrs;
  char *name;
  int num_attrs;
};
</pre>

<h3>mxml_index_s</h3>
<p>An XML node index.</p>
<pre>
struct mxml_index_s
{
  int alloc_nodes;
  char *attr;
  int cur_node;
  mxml_node_t **nodes;
  int num_nodes;
};
</pre>

<h3>mxml_node_s</h3>
<p>An XML node.</p>
<pre>
struct mxml_node_s
{
  struct mxml_node_s *child;
  struct mxml_node_s *last_child;
  struct mxml_node_s *next;
  struct mxml_node_s *parent;
  struct mxml_node_s *prev;
  int ref_count;
  mxml_type_t type;
  void *user_data;
  mxml_value_t value;
};
</pre>

<h3>mxml_text_s</h3>
<p>An XML text value.</p>
<pre>
struct mxml_text_s
{
  char *string;
  int whitespace;
};
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TYPES</h2>
        <div class="sectioncontent">
<h3>mxml_attr_t</h3>
<p>An XML element attribute value.</p>
<pre>
typedef struct mxml_attr_s mxml_attr_t;
</pre>

<h3>mxml_custom_destroy_cb_t</h3>
<p>Custom data destructor</p>
<pre>
typedef void(*)(void *) mxml_custom_destroy_cb_t;
</pre>

<h3>mxml_custom_load_cb_t</h3>
<p>Custom data load callback function</p>
<pre>
typedef int(*)(mxml_node_t *, const char *) mxml_custom_load_cb_t;
</pre>

<h3>mxml_custom_save_cb_t</h3>
<p>Custom data save callback function</p>
<pre>
typedef char *(*)(mxml_node_t *) mxml_custom_save_cb_t;
</pre>

<h3>mxml_custom_t</h3>
<p>An XML custom value.</p>
<pre>
typedef struct mxml_custom_s mxml_custom_t;
</pre>

<h3>mxml_element_t</h3>
<p>An XML element value.</p>
<pre>
typedef struct mxml_element_s mxml_element_t;
</pre>

<h3>mxml_entity_cb_t</h3>
<p>Entity callback function</p>
<pre>
typedef int(*)(const char *) mxml_entity_cb_t;
</pre>

<h3>mxml_error_cb_t</h3>
<p>Error callback function</p>
<pre>
typedef void(*)(const char *) mxml_error_cb_t;
</pre>

<h3>mxml_index_t</h3>
<p>An XML node index.</p>
<pre>
typedef struct mxml_index_s mxml_index_t;
</pre>

<h3>mxml_load_cb_t</h3>
<p>Load callback function</p>
<pre>
typedef mxml_type_t(*)(mxml_node_t *) mxml_load_cb_t;
</pre>

<h3>mxml_node_t</h3>
<p>An XML node.</p>
<pre>
typedef struct mxml_node_s mxml_node_t;
</pre>

<h3>mxml_save_cb_t</h3>
<p>Save callback function</p>
<pre>
typedef const char *(*)(mxml_node_t *, int) mxml_save_cb_t;
</pre>

<h3>mxml_sax_cb_t</h3>
<p>SAX callback function</p>
<pre>
typedef void(*)(mxml_node_t *, mxml_sax_event_t, void *) mxml_sax_cb_t;
</pre>

<h3>mxml_sax_event_t</h3>
<p>SAX event type.</p>
<pre>
typedef enum mxml_sax_event_e mxml_sax_event_t;
</pre>

<h3>mxml_text_t</h3>
<p>An XML text value.</p>
<pre>
typedef struct mxml_text_s mxml_text_t;
</pre>

<h3>mxml_type_t</h3>
<p>The XML node type.</p>
<pre>
typedef enum mxml_type_e mxml_type_t;
</pre>

<h3>mxml_value_t</h3>
<p>An XML node value.</p>
<pre>
typedef union mxml_value_u mxml_value_t;
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UNIONS</h2>
        <div class="sectioncontent">
<h3>mxml_value_u</h3>
<p>An XML node value.</p>
<pre>
union mxml_value_u
{
  mxml_custom_t custom;
  mxml_element_t element;
  int integer;
  char *opaque;
  double real;
  mxml_text_t text;
};
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO mxml&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/mxmldoc.1.html"><strong>mxmldoc</strong>(1)</a>, Mini-XML Programmers Manual, http://www.minixml.org/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2003-2008 by Michael Sweet.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mvu.hpp.3.html"><span aria-hidden="true">&larr;</span> mvu.hpp.3: Src/mlpack/methods/mvu/mvu.hpp -</a></li>
   <li class="next"><a href="mysub.3.html">mysub.3: Dsecndtst.f - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

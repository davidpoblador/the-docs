<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libcpuset: Library for managing cpu and memory placement.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Library for managing cpu and memory placement.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libcpuset (3) manual">
  <meta name="twitter:description" content="Library for managing cpu and memory placement.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcpuset1-libcpuset-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libcpuset.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libcpuset (3) manual" />
  <meta property="og:description" content="Library for managing cpu and memory placement." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcpuset1-libcpuset-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libcpuset<small> (3)</small></h1>
        <p class="lead">Library for managing cpu and memory placement.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libcpuset.3.html">
      <span itemprop="name">libcpuset: Library for managing cpu and memory placement.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcpuset1/">
      <span itemprop="name">libcpuset1</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libcpuset.3.html">
      <span itemprop="name">libcpuset: Library for managing cpu and memory placement.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<strong>#include &lt;bitmask.h&gt;</strong>
<strong>#include &lt;cpuset.h&gt;</strong>

<strong>cc ... -lcpuset</strong>


</pre>
<h3>Basic cpuset routines</h3>

<pre>
int cpuset_pin(int <em>relcpu</em>);
int cpuset_size();
int cpuset_where();
int cpuset_unpin();

</pre>

<h3>Basic cpuset routines (Fortran interface)</h3>

<pre>
<strong>include 'cpusetf.h'</strong>
<strong>integer </strong><em>relcpu</em>

irtn = cpuset_pin(<em>relcpu</em>)
irtn = cpuset_size()
irtn = cpuset_unpin()
irtn = cpuset_where()

</pre>

<h3>Cpuset library version.</h3>

<pre>
int cpuset_version();

</pre>

<h3>Allocate and free `struct cpuset *`:</h3>

<pre>
struct cpuset *cpuset_alloc();
void cpuset_free(struct cpuset *<em>cp</em>);

</pre>

<h3>Lengths of CPUs and Memory Nodes bitmasks - use to alloc them:</h3>

<pre>
int cpuset_cpus_nbits();
int cpuset_mems_nbits();

</pre>

<h3>Set various attributes of a cpuset:</h3>

<pre>
int cpuset_setcpus(struct cpuset *<em>cp</em>, const struct bitmask *<em>cpus</em>);
void cpuset_setmems(struct cpuset *<em>cp</em>, const struct bitmask *<em>mems</em>);
int cpuset_set_iopt(struct cpuset *<em>cp</em>, const char *<em>optname</em>, int <em>val</em>);
int cpuset_set_sopt(struct cpuset *<em>cp</em>, const char *<em>optname</em>, const char *<em>val</em>);

</pre>

<h3>Query various attributes of a cpuset:</h3>

<pre>
int cpuset_getcpus(const struct cpuset *<em>cp</em>, struct bitmask *<em>cpus</em>);
int cpuset_getmems(const struct cpuset *<em>cp</em>, struct bitmask *<em>mems</em>);
int cpuset_cpus_weight(const struct cpuset *<em>cp</em>);
int cpuset_mems_weight(const struct cpuset *<em>cp</em>);
int cpuset_get_iopt(const struct cpuset *<em>cp</em>, const char *<em>optname</em>);
const char *cpuset_get_sopt(const struct cpuset *<em>cp</em>, const char *<em>optname</em>);

</pre>

<h3>Local CPUs and Memory Nodes:</h3>

<pre>
int cpuset_localcpus(const struct bitmask *<em>mems</em>, struct bitmask *<em>cpus</em>);
int cpuset_localmems(const struct bitmask *<em>cpus</em>, struct bitmask *<em>mems</em>);
unsigned int cpuset_cpumemdist(int <em>cpu</em>, int <em>mem</em>);
int cpuset_cpu2node(int <em>cpu</em>);
int cpuset_addr2node(void *<em>addr</em>);

</pre>

<h3>Create, delete, query, modify, list and examine cpusets:</h3>

<pre>
int cpuset_create(const char *<em>path</em>, const struct *<em>cp</em>);
int cpuset_delete(const char *<em>path</em>);
int cpuset_query(struct cpuset *<em>cp</em>, const char *<em>path</em>);
int cpuset_modify(const char *<em>path</em>, const struct *<em>cp</em>);
char *cpuset_getcpusetpath(pid_t <em>pid</em>, char *<em>buf</em>, size_t <em>size</em>);
int cpuset_cpusetofpid(struct cpuset *<em>cp</em>, int <em>pid</em>);
const char *cpuset_mountpoint();
int cpuset_collides_exclusive(const char *<em>cpusetpath</em>, const struct cpuset *<em>cp</em>);
int cpuset_nuke(const char *<em>path</em>, unsigned int <em>seconds</em>);

</pre>

<h3>List tasks (pids) currently attached to a cpuset:</h3>

<pre>
struct cpuset_pidlist *cpuset_init_pidlist(const char *<em>path</em>, int <em>recurse</em>);
int cpuset_pidlist_length(const struct cpuset_pidlist *<em>pl</em>);
pid_t cpuset_get_pidlist(const struct cpuset_pidlist *<em>pl</em>, int <em>i</em>);
void cpuset_freepidlist(struct cpuset_pidlist *<em>pl</em>);

</pre>

<h3>Attach tasks to cpusets:</h3>

<pre>
int cpuset_move(pid_t p, const char *<em>path</em>);
int cpuset_move_all(struct cpuset_pid_list *<em>pl</em>, const char *<em>path</em>);
int cpuset_move_cpuset_tasks(const char *<em>fromrelpath</em>, const char *<em>torelpath</em>);
int cpuset_migrate(pid_t <em>pid</em>, const char *<em>path</em>);
int cpuset_migrate_all(struct cpuset_pid_list *<em>pl</em>, const char *<em>path</em>);
int cpuset_reattach(const char *<em>path</em>);

</pre>

<h3>Monitor memory pressure caused by tasks in a cpuset:</h3>

<pre>
int cpuset_open_memory_pressure(const char *<em>cpusetpath</em>);
int cpuset_read_memory_pressure(int <em>han</em>);
void cpuset_close_memory_pressure(int <em>han</em>);

</pre>

<h3>Converting relative and system CPU and Memory Node numbers:</h3>

<pre>
int cpuset_c_rel_to_sys_cpu(const struct cpuset *<em>cp</em>, int <em>relcpu</em>);
int cpuset_c_sys_to_rel_cpu(const struct cpuset *<em>cp</em>, int <em>cpu</em>);
int cpuset_c_rel_to_sys_mem(const struct cpuset *<em>cp</em>, int <em>relmem</em>);
int cpuset_c_sys_to_rel_mem(const struct cpuset *<em>cp</em>, int <em>mem</em>);
int cpuset_p_rel_to_sys_cpu(pid_t <em>pid</em>, int <em>relcpu</em>);
int cpuset_p_sys_to_rel_cpu(pid_t <em>pid</em>, int <em>cpu</em>);
int cpuset_p_rel_to_sys_mem(pid_t <em>pid</em>, int <em>relmem</em>);
int cpuset_p_sys_to_rel_mem(pid_t <em>pid</em>, int <em>mem</em>);

</pre>

<h3>Placement operations for detecting cpuset migration:</h3>

<pre>
struct cpuset_placement *cpuset_get_placement(pid_t <em>pid</em>);
int cpuset_equal_placement(const struct cpuset_placement *<em>plc1</em>,
         const struct cpuset_placement *<em>plc2</em>);
void cpuset_free_placement(struct cpuset_placement *<em>plc</em>);

</pre>

<h3>Traverse a cpuset hierarchy:</h3>

<pre>
struct cpuset_fts_tree *cpuset_fts_open(const char *<em>cpusetpath</em>);
const struct cpuset_fts_entry *cpuset_fts_read(
                   struct cpuset_fts_tree *<em>cs_tree</em>);
void cpuset_fts_reverse(struct cpuset_fts_tree *<em>cs_tree</em>);
void cpuset_fts_rewind(struct cpuset_fts_tree *<em>cs_tree</em>);
const char *cpuset_fts_get_path(
                   const struct cpuset_fts_entry *<em>cs_entry</em>);
const struct stat *cpuset_fts_get_stat(
                   const struct cpuset_fts_entry *<em>cs_entry</em>);
const struct cpuset *cpuset_fts_get_cpuset(
                   const struct cpuset_fts_entry *<em>cs_entry</em>);
int cpuset_fts_get_errno(
                   const struct cpuset_fts_entry *<em>cs_entry</em>);
int cpuset_fts_get_info(
                   const struct cpuset_fts_entry *<em>cs_entry</em>);
void cpuset_fts_close(struct cpuset_fts_tree *<em>cs_tree</em>);

</pre>

<h3>Bind to a CPU or Memory Node within the current cpuset:</h3>

<pre>
int cpuset_cpubind(int <em>cpu</em>);
int cpuset_latestcpu(pid_t <em>pid</em>);
int cpuset_membind(int <em>mem</em>);

</pre>

<h3>Export settings to and import from Text Representation:</h3>

<pre>
int cpuset_export(const struct cpuset *<em>cp</em>, char *<em>buf</em>, int <em>buflen</em>);
int cpuset_import(struct cpuset *<em>cp</em>, const char *<em>file</em>,
         int *<em>errlinenum_ptr</em>, char *<em>errmsg_bufptr</em>, int <em>errmsg_buflen</em>);

</pre>

<h3>Calling [optional] cpuset_* API routines:</h3>

<pre>
cpuset_function(const char *<em>function_name</em>);
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Cpusets are named subsets of a systems CPUs and Memory Nodes. On large SMP and NUMA systems, it is commonly necessary to control which processes and threads can run on which CPUs and Memory Nodes.  Such placement can be used to improve overall system performance, and to manage system utilization in accordance with appropriate policies.</p><p>This cpuset library provides the mechanisms needed to create, destroy and manage cpusets, and to control the placement of processes and threads within cpusets.</p><p>Though this library has many functions, most applications using it will only need the few functions in the <em>Basic Cpuset API</em>. These basic functions enable an application to manage CPU and Memory placement on SMP and NUMA systems within existing cpusets.</p><p>The <em>Advanced Cpuset API</em> provides support for creating, destroying and managing cpusets, and for more complex placement within cpusets. Workload managers, batch processors and other system services can use the <em>Advanced Cpuset API</em> in order to manage cpusets across an entire system, or a dedicated portion of a system.</p><p>All functions are part of the same library, and fully interoperable.  A system imposed permission model ensures that one application will not be able to make changes to the cpusets or placement of other applications, outside of its currently allowed cpuset.</p><h3>Basic Cpuset API</h3>
<p>The <em>Basic Cpuset API</em> provides functions usable from <strong>C</strong> for processor and memory placement within a cpuset.</p><p>The basic functions enable an application to place various threads of its execution on specific CPUs within its current cpuset, and perform related functions such as asking how large the current cpuset is, and on which CPU within the current cpuset a thread is currently executing.</p><p>The basic <strong>cpuset_pin(int </strong><em>relcpu</em><strong>)</strong> function uses cpuset relative numbering. In a cpuset of <strong>N</strong> CPUs, <em>relcpu</em> ranges from <strong>zero</strong> to <strong>N</strong>-<strong>1</strong>. All functions in the <em>Advanced Cpuset API</em> use system wide CPU and Memory Node numbering, to provide a consistent numbering regardless of cpuset configuration.</p><p>Memory placement is done automatically by the basic functions, local to the requested CPU. Threads may only be pinned on a single CPU, or unpinned and allowed the run of the entire current cpuset. This avoids the need to allocate and free the bitmasks required to specify a set of several CPUs. The basic functions do not support creating or removing cpusets, only the placement of threads within an existing cpuset. This avoids the need to explicitly allocate and free cpuset structures. Operations only apply to the current thread, avoiding the need to pass the process id of the thread to be affected.</p>
<h3>Basic Functions</h3>
<p>The <em>Basic Cpuset API</em> supports the following functions.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cpuset_pin(int </strong><em>relcpu</em><strong>);</strong></p>
  </dt>
  <dd>
    <p>Pin the current task to execute only on the CPU <em>relcpu</em>, which is a relative CPU number within the current cpuset of that task. Also automatically pin the memory allowed to be used by the current task to the memory on that same node (as determined by the advanced <em>cpuset_cpu2node()</em> function).</p>
  </dd>
  <dt>
    <p><strong>int cpuset_size();</strong></p>
  </dt>
  <dd>
    <p>Return the number of CPUs in the current tasks cpuset. The relative CPU numbers that are passed to the <em>cpuset_pin()</em> function and that are returned by the <em>cpuset_where()</em> function, must be between <strong>0</strong> and <strong>N - 1</strong> inclusive, where <strong>N</strong> is the value returned by <em>cpuset_size()</em>.</p>
  </dd>
  <dt>
    <p><strong>int cpuset_where();</strong></p>
  </dt>
  <dd>
    <p>Return the CPU number, relative to the current tasks cpuset, of the CPU on which the current task most recently executed. If a task is allowed to execute on more than one CPU, then there is no guarantee that the task is still executing on the CPU returned by cpuset_where, by the time that the user code obtains the return value.</p>
  </dd>
  <dt>
    <p><strong>int cpuset_unpin();</strong></p>
  </dt>
  <dd>
    <p>Remove the CPU and Memory pinning affects of any previous cpuset_pin call, allowing the current task to execute on any CPU in its current cpuset and to allocate memory on any Memory Node in its current cpuset.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>ENOSYS</strong></p>
  </dt>
  <dd>
    <p>Invoked on an operating system kernel that does not support cpusets.</p>
  </dd>
  <dt>
    <p><strong>ENODEV</strong></p>
  </dt>
  <dd>
    <p>Invoked on a system that supports cpusets, but when the cpuset file system is not currently mounted at <strong>/dev/cpuset</strong>.</p>
  </dd>
  <dt>
    <p><strong>ENOMEM</strong></p>
  </dt>
  <dd>
    <p>Insufficient memory is available.</p>
  </dd>
  <dt>
    <p><strong>EBUSY</strong></p>
  </dt>
  <dd>
    <p>Attempted <em>cpuset_delete</em>() on a cpuset with attached tasks.</p>
  </dd>
  <dt>
    <p><strong>EBUSY</strong></p>
  </dt>
  <dd>
    <p>Attempted <em>cpuset_delete</em>() on a cpuset with child cpusets.</p>
  </dd>
  <dt>
    <p><strong>ENOENT</strong></p>
  </dt>
  <dd>
    <p>Attempted <em>cpuset_create</em>() in a parent cpuset that doesn't exist.</p>
  </dd>
  <dt>
    <p><strong>EEXIST</strong></p>
  </dt>
  <dd>
    <p>Attempted <em>cpuset_create</em>() for a cpuset that already exists.</p>
  </dd>
  <dt>
    <p><strong>EEXIST</strong></p>
  </dt>
  <dd>
    <p>Attempted to <em>rename</em>() a cpuset to a name that already exists</p>
  </dd>
  <dt>
    <p><strong>ENOTDIR</strong></p>
  </dt>
  <dd>
    <p>Attempted to <em>rename</em>() a non-existant cpuset.</p>
  </dd>
  <dt>
    <p><strong>E2BIG</strong></p>
  </dt>
  <dd>
    <p>Attempted a <a href="../man2/write.2.html"><strong>write</strong>(2)</a> system  call on a special cpuset file with a length larger than some kernel determined upper limit on the length of such writes.</p>
  </dd>
  <dt>
    <p><strong>ESRCH</strong></p>
  </dt>
  <dd>
    <p>Attempted to <em>cpuset_move</em>() a non-existance task.</p>
  </dd>
  <dt>
    <p><strong>EACCES</strong></p>
  </dt>
  <dd>
    <p>Attempted to <em>cpuset_move</em>() a task which one lacks permission to move.</p>
  </dd>
  <dt>
    <p><strong>EACCES</strong></p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a <strong>memory_pressure</strong> file.</p>
  </dd>
  <dt>
    <p><strong>ENOSPC</strong></p>
  </dt>
  <dd>
    <p>Attempted to <em>cpuset_move</em>() a task to an empty cpuset.</p>
  </dd>
  <dt>
    <p><strong>EINVAL</strong></p>
  </dt>
  <dd>
    <p>The <strong>relcpu</strong> argument to <em>cpuset_pin</em>() is out of range (not between <strong>zero </strong>and<strong> cpuset_size() - 1</strong>).</p>
  </dd>
  <dt>
    <p><strong>EINVAL</strong></p>
  </dt>
  <dd>
    <p>Attempted to change a cpuset in a way that would violate a cpu_exclusive or mem_exclusive attribute of that cpuset or any of its siblings.</p>
  </dd>
  <dt>
    <p><strong>EINVAL</strong></p>
  </dt>
  <dd>
    <p>Attempted to write an empty cpus or mems bitmask to the kernel.  The kernel creates new cpusets (via <em>mkdir</em>) with empty <strong>cpus</strong> and <strong>mems</strong>, and the user level cpuset and bitmask code works with empty masks.  But the kernel will not allow an empty bitmask (no bits set) to be written to the special <strong>cpus</strong> and <strong>mems</strong> files of a cpuset.</p>
  </dd>
  <dt>
    <p><strong>EIO</strong></p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a string to a cpuset tasks file that does not begin with an ASCII decimal integer.</p>
  </dd>
  <dt>
    <p><strong>EIO</strong></p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/rename.2.html"><strong>rename</strong>(2)</a> a cpuset outside of its current directory.</p>
  </dd>
  <dt>
    <p><strong>ENOSPC</strong></p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a list to a cpus file that did not include any online cpus.</p>
  </dd>
  <dt>
    <p><strong>ENOSPC</strong></p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a list to a <strong>mems</strong> file that did not include any online memory nodes.</p>
  </dd>
  <dt>
    <p><strong>EACCES</strong></p>
  </dt>
  <dd>
    <p>Attempted to add a cpu or mem to a cpuset that is not already in its parent.</p>
  </dd>
  <dt>
    <p><strong>EACCES</strong></p>
  </dt>
  <dd>
    <p>Attempted to set cpu_exclusive or mem_exclusive on a cpuset whose parent lacks the same setting.</p>
  </dd>
  <dt>
    <p><strong>ENODEV</strong></p>
  </dt>
  <dd>
    <p>The cpuset was removed by another task at the same time as a <a href="../man2/write.2.html"><strong>write</strong>(2)</a> was attempted on one of the special files in the cpuset directory.</p>
  </dd>
  <dt>
    <p><strong>EBUSY</strong></p>
  </dt>
  <dd>
    <p>Attempted to remove a cpu or mem from a cpuset that is also in a child of that cpuset.</p>
  </dd>
  <dt>
    <p><strong>EFAULT</strong></p>
  </dt>
  <dd>
    <p>Attempted to read or write a cpuset file using a buffer that was outside your accessible address space.</p>
  </dd>
  <dt>
    <p><strong>ENAMETOOLONG</strong></p>
  </dt>
  <dd>
    <p>Attempted to read a <strong>/proc/</strong><em>pid</em><strong>/cpuset</strong> file for a cpuset path that was longer than the kernel page size.</p>
  </dd>
  <dt>
    <p><strong>ENAMETOOLONG</strong></p>
  </dt>
  <dd>
    <p>Attempted to create a cpuset whose base directory name was longer than 255 characters.</p>
  </dd>
  <dt>
    <p><strong>ENAMETOOLONG</strong></p>
  </dt>
  <dd>
    <p>Attempted to create a cpuset whose full pathname including "/dev/cpuset" was longer than 4095 characters.</p>
  </dd>
  <dt>
    <p><strong>ENXIO</strong></p>
  </dt>
  <dd>
    <p>Attempted to create a <strong>cpu_exclusive</strong> cpuset whose <strong>cpus</strong> covered just part of one or more physical processor packages, such as including just one of the two Cores on a package.  For Linux kernel version 2.6.16 on i386 and x86_64, this operation is rejected with this error to avoid a fatal kernel bug.  Otherwise, this is a normal and supported operation.</p>
  </dd>
  <dt>
    <p><strong>EINVAL</strong></p>
  </dt>
  <dd>
    <p>Specified a <strong>cpus</strong> or <strong>mems</strong> list to the kernel which included a range with the second number smaller than the first number.</p>
  </dd>
  <dt>
    <p><strong>EINVAL</strong></p>
  </dt>
  <dd>
    <p>Specified a <strong>cpus</strong> or <strong>mems</strong> list to the kernel which included an invalid character in the string.</p>
  </dd>
  <dt>
    <p><strong>ERANGE</strong></p>
  </dt>
  <dd>
    <p>Specified a <strong>cpus</strong> or <strong>mems</strong> list to the kernel which included a number too large for the kernel to set in its bitmasks.</p>
  </dd>
  <dt>
    <p><strong>ETIME</strong></p>
  </dt>
  <dd>
    <p>Time limit for <strong>cpuset_nuke</strong>() operation reached without successful completion of operation.</p>
  </dd>
  <dt>
    <p><strong>ENOTEMPTY</strong></p>
  </dt>
  <dd>
    <p>Tasks remain after multiple attempts by <strong>cpuset_move_cpuset_tasks</strong>() to move them to a different cpuset.</p>
  </dd>
  <dt>
    <p><strong>EPERM</strong></p>
  </dt>
  <dd>
    <p>Lacked permission to <strong>kill</strong> (send a signal to) a task.</p>
  </dd>
  <dt>
    <p><strong>EPERM</strong></p>
  </dt>
  <dd>
    <p>Lacked permission to <strong>read</strong> a cpuset or its files.</p>
  </dd>
  <dt>
    <p><strong>EPERM</strong></p>
  </dt>
  <dd>
    <p>Attempted to <strong>unlink</strong> a per-cpuset file.  Such files can not be unlinked.  They can only be removed by removing (<strong>rmdir</strong>) the directory representing the cpuset that contains these files.</p>
  </dd>

</dl>
<h3>Advanced Cpuset API</h3>
<p>For additional documentation on cpusets, and for details of the all the other, advanced, routines, see /usr/share/doc/packages/libcpuset/libcpuset.html and</p><p>/usr/share/doc/packages/libbitmask/libbitmask.html. These same documents are available in plain text format as /usr/share/doc/packages/libcpuset/libcpuset.txt and /usr/share/doc/packages/libbitmask/libbitmask.txt.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libcpuset&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/libbitmask.3.html"><strong>libbitmask</strong>(3)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>pj@sgi.com (Paul Jackson)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libcap.3.html"><span aria-hidden="true">&larr;</span> libcap.3: Capability data object manipulation</a></li>
   <li class="next"><a href="libcurl.3.html">libcurl.3: Client-side url transfers <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

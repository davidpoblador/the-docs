<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>beagle.h: This file documents the api as well as header for the broad-platform evolutionary analysis general likelihood evaluator.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="This file documents the api as well as header for the broad-platform evolutionary analysis general likelihood evaluator.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="beagle.h (3) manual">
  <meta name="twitter:description" content="This file documents the api as well as header for the broad-platform evolutionary analysis general likelihood evaluator.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhmsbeagle-dev-beagle.h-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/beagle.h.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="beagle.h (3) manual" />
  <meta property="og:description" content="This file documents the api as well as header for the broad-platform evolutionary analysis general likelihood evaluator." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhmsbeagle-dev-beagle.h-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">beagle.h<small> (3)</small></h1>
        <p class="lead">This file documents the api as well as header for the broad-platform evolutionary analysis general likelihood evaluator.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/beagle.h.3.html">
      <span itemprop="name">beagle.h: This file documents the api as well as header for the broad-platform evolutionary analysis general likelihood evaluator.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhmsbeagle-dev/">
      <span itemprop="name">libhmsbeagle-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/beagle.h.3.html">
      <span itemprop="name">beagle.h: This file documents the api as well as header for the broad-platform evolutionary analysis general likelihood evaluator.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include 'libhmsbeagle/platform.h'</p><h3>Classes</h3>
<p>struct <strong>BeagleInstanceDetails</strong></p><p><em>Information about a specific instance. </em> struct <strong>BeagleResource</strong></p><p><em>Description of a hardware resource. </em> struct <strong>BeagleResourceList</strong></p><p><em>List of hardware resources. </em> struct <strong>BeagleOperation</strong></p><p><em>A list of integer indices which specify a partial likelihoods operation. </em></p>
<h3>Enumerations</h3>
<p>enum <strong>BeagleReturnCodes</strong> { <strong>BEAGLE_SUCCESS</strong> = 0, <strong>BEAGLE_ERROR_GENERAL</strong> = -1, <strong>BEAGLE_ERROR_OUT_OF_MEMORY</strong> = -2, <strong>BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION</strong> = -3, <strong>BEAGLE_ERROR_UNINITIALIZED_INSTANCE</strong> = -4, <strong>BEAGLE_ERROR_OUT_OF_RANGE</strong> = -5, <strong>BEAGLE_ERROR_NO_RESOURCE</strong> = -6, <strong>BEAGLE_ERROR_NO_IMPLEMENTATION</strong> = -7, <strong>BEAGLE_ERROR_FLOATING_POINT</strong> = -8 }</p><p><em>Error return codes. </em> enum <strong>BeagleFlags</strong> { <strong>BEAGLE_FLAG_PRECISION_SINGLE</strong> = 1 &lt;&lt; 0, <strong>BEAGLE_FLAG_PRECISION_DOUBLE</strong> = 1 &lt;&lt; 1, <strong>BEAGLE_FLAG_COMPUTATION_SYNCH</strong> = 1 &lt;&lt; 2, <strong>BEAGLE_FLAG_COMPUTATION_ASYNCH</strong> = 1 &lt;&lt; 3, <strong>BEAGLE_FLAG_EIGEN_REAL</strong> = 1 &lt;&lt; 4, <strong>BEAGLE_FLAG_EIGEN_COMPLEX</strong> = 1 &lt;&lt; 5, <strong>BEAGLE_FLAG_SCALING_MANUAL</strong> = 1 &lt;&lt; 6, <strong>BEAGLE_FLAG_SCALING_AUTO</strong> = 1 &lt;&lt; 7, <strong>BEAGLE_FLAG_SCALING_ALWAYS</strong> = 1 &lt;&lt; 8, <strong>BEAGLE_FLAG_SCALING_DYNAMIC</strong> = 1 &lt;&lt; 25, <strong>BEAGLE_FLAG_SCALERS_RAW</strong> = 1 &lt;&lt; 9, <strong>BEAGLE_FLAG_SCALERS_LOG</strong> = 1 &lt;&lt; 10, <strong>BEAGLE_FLAG_INVEVEC_STANDARD</strong> = 1 &lt;&lt; 20, <strong>BEAGLE_FLAG_INVEVEC_TRANSPOSED</strong> = 1 &lt;&lt; 21, <strong>BEAGLE_FLAG_VECTOR_SSE</strong> = 1 &lt;&lt; 11, <strong>BEAGLE_FLAG_VECTOR_AVX</strong> = 1 &lt;&lt; 24, <strong>BEAGLE_FLAG_VECTOR_NONE</strong> = 1 &lt;&lt; 12, <strong>BEAGLE_FLAG_THREADING_OPENMP</strong> = 1 &lt;&lt; 13, <strong>BEAGLE_FLAG_THREADING_NONE</strong> = 1 &lt;&lt; 14, <strong>BEAGLE_FLAG_PROCESSOR_CPU</strong> = 1 &lt;&lt; 15, <strong>BEAGLE_FLAG_PROCESSOR_GPU</strong> = 1 &lt;&lt; 16, <strong>BEAGLE_FLAG_PROCESSOR_FPGA</strong> = 1 &lt;&lt; 17, <strong>BEAGLE_FLAG_PROCESSOR_CELL</strong> = 1 &lt;&lt; 18, <strong>BEAGLE_FLAG_PROCESSOR_PHI</strong> = 1 &lt;&lt; 19, <strong>BEAGLE_FLAG_PROCESSOR_OTHER</strong> = 1 &lt;&lt; 26, <strong>BEAGLE_FLAG_FRAMEWORK_CUDA</strong> = 1 &lt;&lt; 22, <strong>BEAGLE_FLAG_FRAMEWORK_OPENCL</strong> = 1 &lt;&lt; 23, <strong>BEAGLE_FLAG_FRAMEWORK_CPU</strong> = 1 &lt;&lt; 27 }</p><p><em>Hardware and implementation capability flags. </em> enum <strong>BeagleOpCodes</strong> { <strong>BEAGLE_OP_COUNT</strong> = 7, <strong>BEAGLE_OP_NONE</strong> = -1 }</p><p><em>Operation codes. </em></p>
<h3>Functions</h3>
<p>BEAGLE_DLLEXPORT const char * <strong>beagleGetVersion</strong> (void)</p><p><em>Get version. </em> BEAGLE_DLLEXPORT const char * <strong>beagleGetCitation</strong> (void)</p><p><em>Get citation. </em> BEAGLE_DLLEXPORT</p><p><strong>BeagleResourceList</strong> * <strong>beagleGetResourceList</strong> (void)"</p><p><em>Get list of hardware resources. </em> BEAGLE_DLLEXPORT int <strong>beagleCreateInstance</strong> (int tipCount, int partialsBufferCount, int compactBufferCount, int stateCount, int patternCount, int eigenBufferCount, int matrixBufferCount, int categoryCount, int scaleBufferCount, int *resourceList, int resourceCount, long preferenceFlags, long requirementFlags, <strong>BeagleInstanceDetails</strong> *returnInfo)</p><p><em>Create a single instance. </em> BEAGLE_DLLEXPORT int <strong>beagleFinalizeInstance</strong> (int instance)</p><p><em>Finalize this instance. </em> BEAGLE_DLLEXPORT int <strong>beagleFinalize</strong> (void)</p><p><em>Finalize the library. </em> BEAGLE_DLLEXPORT int <strong>beagleSetTipStates</strong> (int instance, int tipIndex, const int *inStates)</p><p><em>Set the compact state representation for tip node. </em> BEAGLE_DLLEXPORT int <strong>beagleSetTipPartials</strong> (int instance, int tipIndex, const double *inPartials)</p><p><em>Set an instance partials buffer for tip node. </em> BEAGLE_DLLEXPORT int <strong>beagleSetPartials</strong> (int instance, int bufferIndex, const double *inPartials)</p><p><em>Set an instance partials buffer. </em> BEAGLE_DLLEXPORT int <strong>beagleGetPartials</strong> (int instance, int bufferIndex, int scaleIndex, double *outPartials)</p><p><em>Get partials from an instance buffer. </em> BEAGLE_DLLEXPORT int <strong>beagleSetEigenDecomposition</strong> (int instance, int eigenIndex, const double *inEigenVectors, const double *inInverseEigenVectors, const double *inEigenValues)</p><p><em>Set an eigen-decomposition buffer. </em> BEAGLE_DLLEXPORT int <strong>beagleSetStateFrequencies</strong> (int instance, int stateFrequenciesIndex, const double *inStateFrequencies)</p><p><em>Set a state frequency buffer. </em> BEAGLE_DLLEXPORT int <strong>beagleSetCategoryWeights</strong> (int instance, int categoryWeightsIndex, const double *inCategoryWeights)</p><p><em>Set a category weights buffer. </em> BEAGLE_DLLEXPORT int <strong>beagleSetCategoryRates</strong> (int instance, const double *inCategoryRates)</p><p><em>Set category rates. </em> BEAGLE_DLLEXPORT int <strong>beagleSetPatternWeights</strong> (int instance, const double *inPatternWeights)</p><p><em>Set pattern weights. </em> BEAGLE_DLLEXPORT int <strong>beagleConvolveTransitionMatrices</strong> (int instance, const int *firstIndices, const int *secondIndices, const int *resultIndices, int matrixCount)</p><p><em>Convolve lists of transition probability matrices. </em> BEAGLE_DLLEXPORT int <strong>beagleUpdateTransitionMatrices</strong> (int instance, int eigenIndex, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const double *edgeLengths, int count)</p><p><em>Calculate a list of transition probability matrices. </em> BEAGLE_DLLEXPORT int <strong>beagleSetTransitionMatrix</strong> (int instance, int matrixIndex, const double *inMatrix, double paddedValue)</p><p><em>Set a finite-time transition probability matrix. </em> BEAGLE_DLLEXPORT int <strong>beagleGetTransitionMatrix</strong> (int instance, int matrixIndex, double *outMatrix)</p><p><em>Get a finite-time transition probability matrix. </em> BEAGLE_DLLEXPORT int <strong>beagleSetTransitionMatrices</strong> (int instance, const int *matrixIndices, const double *inMatrices, const double *paddedValues, int count)</p><p><em>Set multiple transition matrices. </em> BEAGLE_DLLEXPORT int <strong>beagleUpdatePartials</strong> (const int instance, const <strong>BeagleOperation</strong> *operations, int operationCount, int cumulativeScaleIndex)</p><p><em>Calculate or queue for calculation partials using a list of operations. </em> BEAGLE_DLLEXPORT int <strong>beagleWaitForPartials</strong> (const int instance, const int *destinationPartials, int destinationPartialsCount)</p><p><em>Block until all calculations that write to the specified partials have completed. </em> BEAGLE_DLLEXPORT int <strong>beagleAccumulateScaleFactors</strong> (int instance, const int *scaleIndices, int count, int cumulativeScaleIndex)</p><p><em>Accumulate scale factors. </em> BEAGLE_DLLEXPORT int <strong>beagleRemoveScaleFactors</strong> (int instance, const int *scaleIndices, int count, int cumulativeScaleIndex)</p><p><em>Remove scale factors. </em> BEAGLE_DLLEXPORT int <strong>beagleResetScaleFactors</strong> (int instance, int cumulativeScaleIndex)</p><p><em>Reset scalefactors. </em> BEAGLE_DLLEXPORT int <strong>beagleCopyScaleFactors</strong> (int instance, int destScalingIndex, int srcScalingIndex)</p><p><em>Copy scale factors. </em> BEAGLE_DLLEXPORT int <strong>beagleCalculateRootLogLikelihoods</strong> (int instance, const int *bufferIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, int count, double *outSumLogLikelihood)</p><p><em>Calculate site log likelihoods at a root node. </em> BEAGLE_DLLEXPORT int <strong>beagleCalculateEdgeLogLikelihoods</strong> (int instance, const int *parentBufferIndices, const int *childBufferIndices, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, int count, double *outSumLogLikelihood, double *outSumFirstDerivative, double *outSumSecondDerivative)</p><p><em>Calculate site log likelihoods and derivatives along an edge. </em> BEAGLE_DLLEXPORT int <strong>beagleGetSiteLogLikelihoods</strong> (int instance, double *outLogLikelihoods)</p><p><em>Get site log likelihoods for last beagleCalculateRootLogLikelihoods or beagleCalculateEdgeLogLikelihoods call. </em> BEAGLE_DLLEXPORT int <strong>beagleGetSiteDerivatives</strong> (int instance, double *outFirstDerivatives, double *outSecondDerivatives)</p><p><em>Get site derivatives for last beagleCalculateEdgeLogLikelihoods call. </em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>This file documents the API as well as header for the Broad-platform Evolutionary Analysis General Likelihood Evaluator.</p><p>Copyright 2009-2013 Phylogenetic Likelihood Working Group</p><p>This file is part of BEAGLE.</p><p>BEAGLE is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>BEAGLE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p><p>You should have received a copy of the GNU Lesser General Public License along with BEAGLE. If not, see http://www.gnu.org/licenses/.</p><p>KEY CONCEPTS</p><p>The key to BEAGLE performance lies in delivering fine-scale parallelization while minimizing data transfer and memory copy overhead. To accomplish this, the library lacks the concept of data structure for a tree, in spite of the intended use for phylogenetic analysis. Instead, BEAGLE acts directly on flexibly indexed data storage (called buffers) for observed character states and partial likelihoods. The client program can set the input buffers to reflect the data and can calculate the likelihood of a particular phylogeny by invoking likelihood calculations on the appropriate input and output buffers in the correct order. Because of this design simplicity, the library can support many different tree inference algorithms and likelihood calculation on a variety of models. Arbitrary numbers of states can be used, as can nonreversible substitution matrices via complex eigen decompositions, and mixture models with multiple rate categories and/or multiple eigen decompositions. Finally, BEAGLE application programming interface (API) calls can be asynchronous, allowing the calling program to implement other coarse-scale parallelization schemes such as evaluating independent genes or running concurrent Markov chains.</p><p>USAGE</p><p>To use the library, a client program first creates an instance of BEAGLE by calling beagleCreateInstance; multiple instances per client are possible and encouraged. All additional functions are called with a reference to this instance. The client program can optionally request that an instance run on certain hardware (e.g., a GPU) or have particular features (e.g., double-precision math). Next, the client program must specify the data dimensions and specify key aspects of the phylogenetic model. Character state data are then loaded and can be in the form of discrete observed states or partial likelihoods for ambiguous characters. The observed data are usually unchanging and loaded only once at the start to minimize memory copy overhead. The character data can be compressed into unique “site patterns” and associated weights for each. The parameters of the substitution process can then be specified, including the equilibrium state frequencies, the rates for one or more substitution rate categories and their weights, and finally, the eigen decomposition for the substitution process.</p><p>In order to calculate the likelihood of a particular tree, the client program then specifies a series of integration operations that correspond to steps in Felsenstein’s algorithm. Finite-time transition probabilities for each edge are loaded directly if considering a nondiagonalizable model or calculated in parallel from the eigen decomposition and edge lengths specified. This is performed within BEAGLE’s memory space to minimize data transfers. A single function call will then request one or more integration operations to calculate partial likelihoods over some or all nodes. The operations are performed in the order they are provided, typically dictated by a postorder traversal of the tree topology. The client needs only specify nodes for which the partial likelihoods need updating, but it is up to the calling software to keep track of these dependencies. The final step in evaluating the phylogenetic model is done using an API call that yields a single log likelihood for the model given the data.</p><p>Aspects of the BEAGLE API design support both maximum likelihood (ML) and Bayesian phylogenetic tree inference. For ML inference, API calls can calculate first and second derivatives of the likelihood with respect to the lengths of edges (branches). In both cases, BEAGLE provides the ability to cache and reuse previously computed partial likelihood results, which can yield a tremendous speedup over recomputing the entire likelihood every time a new phylogenetic model is evaluated.</p><p><strong>Author:</strong></p><p>Likelihood API Working Group</p><p>Daniel Ayres</p><p>Peter Beerli</p><p>Michael Cummings</p><p>Aaron Darling</p><p>Mark Holder</p><p>John Huelsenbeck</p><p>Paul Lewis</p><p>Michael Ott</p><p>Andrew Rambaut</p><p>Fredrik Ronquist</p><p>Marc Suchard</p><p>David Swofford</p><p>Derrick Zwickl</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Enumeration Type Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBBeagleFlags\fP</h3>
<p>Hardware and implementation capability flags.  This enumerates all possible hardware and implementation capability flags. Each capability is a bit in a 'long'</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_PRECISION_SINGLE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Single precision computation</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_PRECISION_DOUBLE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Double precision computation</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_COMPUTATION_SYNCH </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Synchronous computation (blocking)</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_COMPUTATION_ASYNCH </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Asynchronous computation (non-blocking)</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_EIGEN_REAL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Real eigenvalue computation</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_EIGEN_COMPLEX </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Complex eigenvalue computation</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_SCALING_MANUAL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Manual scaling</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_SCALING_AUTO </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Auto-scaling on (deprecated, may not work correctly)</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_SCALING_ALWAYS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Scale at every updatePartials (deprecated, may not work correctly)</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_SCALING_DYNAMIC </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Manual scaling with dynamic checking (deprecated, may not work correctly)</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_SCALERS_RAW </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Save raw scalers</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_SCALERS_LOG </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Save log scalers</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_INVEVEC_STANDARD </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Inverse eigen vectors passed to BEAGLE have not been transposed</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_INVEVEC_TRANSPOSED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Inverse eigen vectors passed to BEAGLE have been transposed</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_VECTOR_SSE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>SSE computation</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_VECTOR_AVX </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>AVX computation</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_VECTOR_NONE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>No vector computation</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_THREADING_OPENMP </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>OpenMP threading</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_THREADING_NONE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>No threading</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_PROCESSOR_CPU </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use CPU as main processor</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_PROCESSOR_GPU </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use GPU as main processor</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_PROCESSOR_FPGA </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use FPGA as main processor</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_PROCESSOR_CELL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use Cell as main processor</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_PROCESSOR_PHI </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use Intel Phi as main processor</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_PROCESSOR_OTHER </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use other type of processor</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_FRAMEWORK_CUDA </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use CUDA implementation with GPU resources</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_FRAMEWORK_OPENCL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use OpenCL implementation with GPU resources</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_FLAG_FRAMEWORK_CPU </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Use CPU implementation</p>
  </dd>

</dl>

<h3>enum \fBBeagleOpCodes\fP</h3>
<p>Operation codes.  This enumerates all possible BEAGLE operation codes.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>BEAGLE_OP_COUNT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Total number of integers per beagleUpdatePartials operation</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_OP_NONE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Specify no use for indexed buffer</p>
  </dd>

</dl>

<h3>enum \fBBeagleReturnCodes\fP</h3>
<p>Error return codes.  This enumerates all possible BEAGLE return codes. Error codes are always negative.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>BEAGLE_SUCCESS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Success</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_ERROR_GENERAL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Unspecified error</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_ERROR_OUT_OF_MEMORY </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Not enough memory could be allocated</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Unspecified exception</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_ERROR_UNINITIALIZED_INSTANCE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>The instance index is out of range, or the instance has not been created</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_ERROR_OUT_OF_RANGE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>One of the indices specified exceeded the range of the array</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_ERROR_NO_RESOURCE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>No resource matches requirements</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_ERROR_NO_IMPLEMENTATION </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>No implementation matches requirements</p>
  </dd>
  <dt>
    <p><strong></strong><em>BEAGLE_ERROR_FLOATING_POINT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Floating-point range exceeded</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Function Documentation</h2>
        <div class="sectioncontent">
<h3>BEAGLE_DLLEXPORT int beagleAccumulateScaleFactors (intinstance, const int *scaleIndices, intcount, intcumulativeScaleIndex)</h3>
<p>Accumulate scale factors. This function adds (log) scale factors from a list of scaleBuffers to a cumulative scale buffer. It is used to calculate the marginal scaling at a specific node for each site.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>scaleIndices</em> List of scaleBuffers to add (input)</p><p><em>count</em> Number of scaleBuffers in list (input)</p><p><em>cumulativeScaleIndex</em> Index number of scaleBuffer to accumulate factors into (input)</p>
<h3>BEAGLE_DLLEXPORT int beagleCalculateEdgeLogLikelihoods (intinstance, const int *parentBufferIndices, const int *childBufferIndices, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, intcount, double *outSumLogLikelihood, double *outSumFirstDerivative, double *outSumSecondDerivative)</h3>
<p>Calculate site log likelihoods and derivatives along an edge. This function integrates a list of partials at a parent and child node with respect to a set of partials-weights and state frequencies to return the log likelihood and first and second derivative sums</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>parentBufferIndices</em> List of indices of parent partialsBuffers (input)</p><p><em>childBufferIndices</em> List of indices of child partialsBuffers (input)</p><p><em>probabilityIndices</em> List indices of transition probability matrices for this edge (input)</p><p><em>firstDerivativeIndices</em> List indices of first derivative matrices (input)</p><p><em>secondDerivativeIndices</em> List indices of second derivative matrices (input)</p><p><em>categoryWeightsIndices</em> List of weights to apply to each partialsBuffer (input)</p><p><em>stateFrequenciesIndices</em> List of state frequencies for each partialsBuffer (input). There should be one set for each of parentBufferIndices</p><p><em>cumulativeScaleIndices</em> List of scaleBuffers containing accumulated factors to apply to each partialsBuffer (input). There should be one index for each of parentBufferIndices</p><p><em>count</em> Number of partialsBuffers (input)</p><p><em>outSumLogLikelihood</em> Pointer to destination for resulting log likelihood (output)</p><p><em>outSumFirstDerivative</em> Pointer to destination for resulting first derivative (output)</p><p><em>outSumSecondDerivative</em> Pointer to destination for resulting second derivative (output)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleCalculateRootLogLikelihoods (intinstance, const int *bufferIndices, const int *categoryWeightsIndices, const int *stateFrequenciesIndices, const int *cumulativeScaleIndices, intcount, double *outSumLogLikelihood)</h3>
<p>Calculate site log likelihoods at a root node. This function integrates a list of partials at a node with respect to a set of partials-weights and state frequencies to return the log likelihood sum</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>bufferIndices</em> List of partialsBuffer indices to integrate (input)</p><p><em>categoryWeightsIndices</em> List of weights to apply to each partialsBuffer (input). There should be one categoryCount sized set for each of parentBufferIndices</p><p><em>stateFrequenciesIndices</em> List of state frequencies for each partialsBuffer (input). There should be one set for each of parentBufferIndices</p><p><em>cumulativeScaleIndices</em> List of scaleBuffers containing accumulated factors to apply to each partialsBuffer (input). There should be one index for each of parentBufferIndices</p><p><em>count</em> Number of partialsBuffer to integrate (input)</p><p><em>outSumLogLikelihood</em> Pointer to destination for resulting log likelihood (output)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleConvolveTransitionMatrices (intinstance, const int *firstIndices, const int *secondIndices, const int *resultIndices, intmatrixCount)</h3>
<p>Convolve lists of transition probability matrices. This function convolves two lists of transition probability matrices.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>firstIndices</em> List of indices of the first transition probability matrices to convolve (input)</p><p><em>secondIndices</em> List of indices of the second transition probability matrices to convolve (input)</p><p><em>resultIndices</em> List of indices of resulting transition probability matrices (input)</p><p><em>matrixCount</em> Length of lists</p>
<h3>BEAGLE_DLLEXPORT int beagleCopyScaleFactors (intinstance, intdestScalingIndex, intsrcScalingIndex)</h3>
<p>Copy scale factors. This function copies scale factors from one buffer to another.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>destScalingIndex</em> Destination scaleBuffer (input)</p><p><em>srcScalingIndex</em> Source scaleBuffer (input)</p>
<h3>BEAGLE_DLLEXPORT int beagleCreateInstance (inttipCount, intpartialsBufferCount, intcompactBufferCount, intstateCount, intpatternCount, inteigenBufferCount, intmatrixBufferCount, intcategoryCount, intscaleBufferCount, int *resourceList, intresourceCount, longpreferenceFlags, longrequirementFlags, \fBBeagleInstanceDetails\fP *returnInfo)</h3>
<p>Create a single instance. This function creates a single instance of the BEAGLE library and can be called multiple times to create multiple data partition instances each returning a unique identifier.</p><p><strong>Parameters:</strong></p><p><em>tipCount</em> Number of tip data elements (input)</p><p><em>partialsBufferCount</em> Number of partials buffers to create (input)</p><p><em>compactBufferCount</em> Number of compact state representation buffers to create (input)</p><p><em>stateCount</em> Number of states in the continuous-time Markov chain (input)</p><p><em>patternCount</em> Number of site patterns to be handled by the instance (input)</p><p><em>eigenBufferCount</em> Number of rate matrix eigen-decomposition, category weight, and state frequency buffers to allocate (input)</p><p><em>matrixBufferCount</em> Number of transition probability matrix buffers (input)</p><p><em>categoryCount</em> Number of rate categories (input)</p><p><em>scaleBufferCount</em> Number of scale buffers to create, ignored for auto scale or always scale (input)</p><p><em>resourceList</em> List of potential resources on which this instance is allowed (input, NULL implies no restriction)</p><p><em>resourceCount</em> Length of resourceList list (input)</p><p><em>preferenceFlags</em> Bit-flags indicating preferred implementation characteristics, see BeagleFlags (input)</p><p><em>requirementFlags</em> Bit-flags indicating required implementation characteristics, see BeagleFlags (input)</p><p><em>returnInfo</em> Pointer to return implementation and resource details</p><p><strong>Returns:</strong></p><p>the unique instance identifier (&lt;0 if failed, see <strong>BeagleReturnCodes</strong>)</p>
<h3>BEAGLE_DLLEXPORT int beagleFinalize (void)</h3>
<p>Finalize the library. This function finalizes the library and releases all allocated memory. This function is automatically called under GNU C via <strong>attribute</strong> ((destructor)).</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleFinalizeInstance (intinstance)</h3>
<p>Finalize this instance. This function finalizes the instance by releasing allocated memory</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT const char* beagleGetCitation (void)</h3>
<p>Get citation. This function returns a pointer to a string describing the version of the library and how to cite it.</p><p><strong>Returns:</strong></p><p>A string describing the version of the library and how to cite it</p>
<h3>BEAGLE_DLLEXPORT int beagleGetPartials (intinstance, intbufferIndex, intscaleIndex, double *outPartials)</h3>
<p>Get partials from an instance buffer. This function copies an instance buffer into the array outPartials. The outPartials array should be stateCount * patternCount * categoryCount in length.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number from which to get partialsBuffer (input)</p><p><em>bufferIndex</em> Index of source partialsBuffer (input)</p><p><em>scaleIndex</em> Index of scaleBuffer to apply to partialsBuffer (input)</p><p><em>outPartials</em> Pointer to which to receive partialsBuffer (output)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT \fBBeagleResourceList\fP* beagleGetResourceList (void)</h3>
<p>Get list of hardware resources. This function returns a pointer to a <strong>BeagleResourceList</strong> struct, which includes a <strong>BeagleResource</strong> array describing the available hardware resources.</p><p><strong>Returns:</strong></p><p>A list of hardware resources available to the library as a <strong>BeagleResourceList</strong></p>
<h3>BEAGLE_DLLEXPORT int beagleGetSiteDerivatives (intinstance, double *outFirstDerivatives, double *outSecondDerivatives)</h3>
<p>Get site derivatives for last beagleCalculateEdgeLogLikelihoods call. This function returns the derivatives for each site</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>outFirstDerivatives</em> Pointer to destination for resulting first derivatives (output)</p><p><em>outSecondDerivatives</em> Pointer to destination for resulting second derivatives (output)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleGetSiteLogLikelihoods (intinstance, double *outLogLikelihoods)</h3>
<p>Get site log likelihoods for last beagleCalculateRootLogLikelihoods or beagleCalculateEdgeLogLikelihoods call. This function returns the log likelihoods for each site</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>outLogLikelihoods</em> Pointer to destination for resulting log likelihoods (output)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleGetTransitionMatrix (intinstance, intmatrixIndex, double *outMatrix)</h3>
<p>Get a finite-time transition probability matrix. This function copies a finite-time transition matrix buffer into the array outMatrix. The outMatrix array should be of size stateCount * stateCount * categoryCount and will be filled with one matrix for each rate category.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>matrixIndex</em> Index of matrix buffer (input)</p><p><em>outMatrix</em> Pointer to destination transition probability matrix (output)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT const char* beagleGetVersion (void)</h3>
<p>Get version. This function returns a pointer to a string with the library version number.</p><p><strong>Returns:</strong></p><p>A string with the version number</p>
<h3>BEAGLE_DLLEXPORT int beagleRemoveScaleFactors (intinstance, const int *scaleIndices, intcount, intcumulativeScaleIndex)</h3>
<p>Remove scale factors. This function removes (log) scale factors from a cumulative scale buffer. The scale factors to be removed are indicated in a list of scaleBuffers.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>scaleIndices</em> List of scaleBuffers to remove (input)</p><p><em>count</em> Number of scaleBuffers in list (input)</p><p><em>cumulativeScaleIndex</em> Index number of scaleBuffer containing accumulated factors (input)</p>
<h3>BEAGLE_DLLEXPORT int beagleResetScaleFactors (intinstance, intcumulativeScaleIndex)</h3>
<p>Reset scalefactors. This function resets a cumulative scale buffer.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>cumulativeScaleIndex</em> Index number of cumulative scaleBuffer (input)</p>
<h3>BEAGLE_DLLEXPORT int beagleSetCategoryRates (intinstance, const double *inCategoryRates)</h3>
<p>Set category rates. This function sets the vector of category rates for an instance.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>inCategoryRates</em> Array containing categoryCount rate scalers (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetCategoryWeights (intinstance, intcategoryWeightsIndex, const double *inCategoryWeights)</h3>
<p>Set a category weights buffer. This function copies a category weights array into an instance buffer.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>categoryWeightsIndex</em> Index of category weights buffer (input)</p><p><em>inCategoryWeights</em> Category weights array (categoryCount) (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetEigenDecomposition (intinstance, inteigenIndex, const double *inEigenVectors, const double *inInverseEigenVectors, const double *inEigenValues)</h3>
<p>Set an eigen-decomposition buffer. This function copies an eigen-decomposition into an instance buffer.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>eigenIndex</em> Index of eigen-decomposition buffer (input)</p><p><em>inEigenVectors</em> Flattened matrix (stateCount x stateCount) of eigen-vectors (input)</p><p><em>inInverseEigenVectors</em> Flattened matrix (stateCount x stateCount) of inverse-eigen- vectors (input)</p><p><em>inEigenValues</em> Vector of eigenvalues</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetPartials (intinstance, intbufferIndex, const double *inPartials)</h3>
<p>Set an instance partials buffer. This function copies an array of partials into an instance buffer. The inPartials array should be stateCount * patternCount * categoryCount in length.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number in which to set a partialsBuffer (input)</p><p><em>bufferIndex</em> Index of destination partialsBuffer (input)</p><p><em>inPartials</em> Pointer to partials values to set (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetPatternWeights (intinstance, const double *inPatternWeights)</h3>
<p>Set pattern weights. This function sets the vector of pattern weights for an instance.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>inPatternWeights</em> Array containing patternCount weights (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetStateFrequencies (intinstance, intstateFrequenciesIndex, const double *inStateFrequencies)</h3>
<p>Set a state frequency buffer. This function copies a state frequency array into an instance buffer.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>stateFrequenciesIndex</em> Index of state frequencies buffer (input)</p><p><em>inStateFrequencies</em> State frequencies array (stateCount) (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetTipPartials (intinstance, inttipIndex, const double *inPartials)</h3>
<p>Set an instance partials buffer for tip node. This function copies an array of partials into an instance buffer. The inPartials array should be stateCount * patternCount in length. For most applications this will be used to set the partial likelihoods for the observed states. Internally, the partials will be copied categoryCount times.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number in which to set a partialsBuffer (input)</p><p><em>tipIndex</em> Index of destination partialsBuffer (input)</p><p><em>inPartials</em> Pointer to partials values to set (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetTipStates (intinstance, inttipIndex, const int *inStates)</h3>
<p>Set the compact state representation for tip node. This function copies a compact state representation into an instance buffer. Compact state representation is an array of states: 0 to stateCount - 1 (missing = stateCount). The inStates array should be patternCount in length (replication across categoryCount is not required).</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>tipIndex</em> Index of destination compactBuffer (input)</p><p><em>inStates</em> Pointer to compact states (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetTransitionMatrices (intinstance, const int *matrixIndices, const double *inMatrices, const double *paddedValues, intcount)</h3>
<p>Set multiple transition matrices. This function copies multiple transition matrices into matrix buffers. This function is used when the application wishes to explicitly set the transition matrices rather than using the beagleSetEigenDecomposition and beagleUpdateTransitionMatrices functions. The inMatrices array should be of size stateCount * stateCount * categoryCount * count.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>matrixIndices</em> Indices of matrix buffers (input)</p><p><em>inMatrices</em> Pointer to source transition matrices (input)</p><p><em>paddedValues</em> Values to be used for padding for ambiguous states (e.g. 1 for probability matrices, 0 for derivative matrices) (input)</p><p><em>count</em> Number of transition matrices (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleSetTransitionMatrix (intinstance, intmatrixIndex, const double *inMatrix, doublepaddedValue)</h3>
<p>Set a finite-time transition probability matrix. This function copies a finite-time transition probability matrix into a matrix buffer. This function is used when the application wishes to explicitly set the transition probability matrix rather than using the beagleSetEigenDecomposition and beagleUpdateTransitionMatrices functions. The inMatrix array should be of size stateCount * stateCount * categoryCount and will contain one matrix for each rate category.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>matrixIndex</em> Index of matrix buffer (input)</p><p><em>inMatrix</em> Pointer to source transition probability matrix (input)</p><p><em>paddedValue</em> Value to be used for padding for ambiguous states (e.g. 1 for probability matrices, 0 for derivative matrices) (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleUpdatePartials (const intinstance, const \fBBeagleOperation\fP *operations, intoperationCount, intcumulativeScaleIndex)</h3>
<p>Calculate or queue for calculation partials using a list of operations. This function either calculates or queues for calculation a list partials. Implementations supporting ASYNCH may queue these calculations while other implementations perform these operations immediately and in order.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>operations</em> <strong>BeagleOperation</strong> list specifying operations (input)</p><p><em>operationCount</em> Number of operations (input)</p><p><em>cumulativeScaleIndex</em> Index number of scaleBuffer to store accumulated factors (input)</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleUpdateTransitionMatrices (intinstance, inteigenIndex, const int *probabilityIndices, const int *firstDerivativeIndices, const int *secondDerivativeIndices, const double *edgeLengths, intcount)</h3>
<p>Calculate a list of transition probability matrices. This function calculates a list of transition probabilities matrices and their first and second derivatives (if requested).</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>eigenIndex</em> Index of eigen-decomposition buffer (input)</p><p><em>probabilityIndices</em> List of indices of transition probability matrices to update (input)</p><p><em>firstDerivativeIndices</em> List of indices of first derivative matrices to update (input, NULL implies no calculation)</p><p><em>secondDerivativeIndices</em> List of indices of second derivative matrices to update (input, NULL implies no calculation)</p><p><em>edgeLengths</em> List of edge lengths with which to perform calculations (input)</p><p><em>count</em> Length of lists</p><p><strong>Returns:</strong></p><p>error code</p>
<h3>BEAGLE_DLLEXPORT int beagleWaitForPartials (const intinstance, const int *destinationPartials, intdestinationPartialsCount)</h3>
<p>Block until all calculations that write to the specified partials have completed. This function is optional and only has to be called by clients that 'recycle' partials.</p><p>If used, this function must be called after an beagleUpdatePartials call and must refer to indices of 'destinationPartials' that were used in a previous beagleUpdatePartials call. The library will block until those partials have been calculated.</p><p><strong>Parameters:</strong></p><p><em>instance</em> Instance number (input)</p><p><em>destinationPartials</em> List of the indices of destinationPartials that must be calculated before the function returns</p><p><em>destinationPartialsCount</em> Number of destinationPartials (input)</p><p><strong>Returns:</strong></p><p>error code</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for BEAGLE from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="be64toh.3.html"><span aria-hidden="true">&larr;</span> be64toh.3: Convert values between host and big-/little-endian byte order</a></li>
   <li class="next"><a href="ber_alloc_t.3.html">ber_alloc_t.3: Openldap lber simplified basic encoding rules library routines for encoding <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

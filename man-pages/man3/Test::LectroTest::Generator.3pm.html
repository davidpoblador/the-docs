<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Test::LectroTest::Generator: Random value generators and combinators</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Random value generators and combinators">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Test::LectroTest::Generator (3pm) manual">
  <meta name="twitter:description" content="Random value generators and combinators">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtest-lectrotest-perl-Test::LectroTest::Generator-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Test::LectroTest::Generator.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Test::LectroTest::Generator (3pm) manual" />
  <meta property="og:description" content="Random value generators and combinators" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtest-lectrotest-perl-Test::LectroTest::Generator-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Test::LectroTest::Generator<small> (3pm)</small></h1>
        <p class="lead">Random value generators and combinators</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Test::LectroTest::Generator.3pm.html">
      <span itemprop="name">Test::LectroTest::Generator: Random value generators and combinators</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtest-lectrotest-perl/">
      <span itemprop="name">libtest-lectrotest-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Test::LectroTest::Generator.3pm.html">
      <span itemprop="name">Test::LectroTest::Generator: Random value generators and combinators</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>version 0.5001</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Test::LectroTest::Generator qw(:common :combinators);

 my $int_gen = Int;
 my $pct_gen = Int( range=&gt;[0,100] );
 my $flt_gen = Float( range=&gt;[0,1] );
 my $bln_gen = Bool;
 my $chr_gen = Char( charset=&gt;"a-z" );
 my $str_gen = String( charset=&gt;"A-Z0-9", length=&gt;[3,] );
 my $ary_gen = List( Int(sized=&gt;0) );
 my $hsh_gen = Hash( $str_gen, $pct_gen );
 my $uni_gen = Unit( "e" );  # always returns "e"
 my $elm_gen = Elements("e1", "e2", "e3", "e4");

 for my $sizing_guidance (1..100) {
     my $i = $int_gen-&gt;generate( $sizing_guidance );
     print "$i ";
 }
 print "&#92;n";

 # generates single digits
 my $digit_gen  = Elements( 0..9 );  # or Int(range=&gt;[0,9],sized=&gt;0)

 # generates SSNs like "910-77-2236"
 my $ssn_gen    = Paste( Paste( ($digit_gen) x 3 ),
                         Paste( ($digit_gen) x 2 ),
                         Paste( ($digit_gen) x 4 ),
                         glue =&gt; "-"                );

 # print 10 SSNs
 print( map {$ssn_gen-&gt;generate($_)."&#92;n"} 1..10 );

 my $english_dist_vowel_gen =
     Frequency( [8.167,Unit("a")], [12.702,Unit("e")],
                [6.996,Unit("i")], [ 7.507,Unit("o")],
                [2.758,Unit("u")] );
     # Source: http://www.csm.astate.edu/~rossa/datasec/frequency.html
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides random value generators for common data types and provides an interface and tools for creating your own generators.  It also provides generator combinators that can be used to create more-complex generators by combining simple ones.</p><p>A generator is an object having a method \*(C`generate\*(C', which takes a single argument, <em>size</em> and returns a new random value.  The generated value is always a scalar.  Generators that produce data structures return references to them.</p><h3>Sizing guidance</h3>
<p>The \*(C`generate\*(C' method interprets its <em>size</em> argument as guidance about the complexity of the value it should create.  Typically, smaller <em>size</em> values result in smaller generated numbers and shorter generated strings and lists.  Some generators, for which sizing doesn't make sense, ignore sizing guidance altogether; those that do use sizing guidance can be told to ignore it via the <strong>sized</strong> modifier.</p><p>The purpose of sizing is to allow LectroTest to generate simple values at first and then, as testing progresses, to slowly ramp up the complexity.  In this way, counterexamples for obvious problems will be easier for you to understand.</p>
<h3>Generators</h3>
<p>The following functions create fully-formed generators, ready to use. These functions are exported into your code's namespace if you ask for \*(C`:generators\*(C' or \*(C`:all\*(C' when you \*(C`use\*(C' this module.</p><p>Each generator has a \*(C`generate\*(C' method that you can call to extract a new, random value from the generator.</p>
<dl class='dl-vertical'>
  <dt>
    Int
  </dt>
  <dd>
    <p>    my $gen = Int( range=&gt;[0,9], sized=&gt;0 ); Creates a generator for integer values, by default in the range [-32768,32767], inclusive, but this can be changed via the optional <strong>range</strong> modifier.</p>
<dl class='dl-vertical'>
  <dt>
    Int( range=&gt;[<em>low</em>, <em>high</em>] )
  </dt>
  <dd>
    <p>Causes the generated values to be constrained to the range [<em>low</em>, <em>high</em>], inclusive.  By default, the range is [-32768, 32767]. <strong>Note:</strong> If your range is empty (i.e., <em>low</em> &gt; <em>high</em>), LectroTest will complain. <strong>Note:</strong> If zero is not within the range you provide, sizing makes no sense because the intersection of your range and the sizing range can be empty, and thus you must turn off sizing with \*(C`sized=&gt;0\*(C'. If you forget, LectroTest will complain.</p>
  </dd>
  <dt>
    Int( sized=&gt;<em>bool</em> )
  </dt>
  <dd>
    <p>If true (the default), constrains the absolute value of the generated integers to the sizing guidance provided to the \*(C`generate\*(C' method. Otherwise, the generated values are constrained only by the range.</p>
  </dd>

</dl>

  </dd>
  <dt>
    Float
  </dt>
  <dd>
    <p>    my $gen = Float( range=&gt;[-2.0,2.0], sized=&gt;1 ); Creates a generator for floating-point values, by default in the range [-32768.0,32768.0), but this can be changed via the optional <strong>range</strong> modifier. By default Float generators are sized.</p>
<dl class='dl-vertical'>
  <dt>
    Float( range=&gt;[<em>low</em>, <em>high</em>] )
  </dt>
  <dd>
    <p>Causes the generated values to be constrained to the range [<em>low</em>, <em>high</em>).  By default, the range is [-32768.0,32768.0).  (Note that the <em>high</em> value itself can never be generated, but values infinitesimally close to it can.) <strong>Note:</strong> If your range is empty (i.e., <em>low</em> &gt; <em>high</em>), LectroTest will complain. <strong>Note:</strong> If zero is not within the range you provide, sizing makes no sense because the intersection of your range and the sizing range can be empty, and thus you must turn off sizing with \*(C`sized=&gt;0\*(C'. If you forget, LectroTest will complain.</p>
  </dd>
  <dt>
    Float( sized=&gt;<em>bool</em> )
  </dt>
  <dd>
    <p>If true (the default), constrains the absolute value of the generated values to the sizing guidance provided to the \*(C`generate\*(C' method. Otherwise, the generated values are constrained only by the range.</p>
  </dd>

</dl>

  </dd>
  <dt>
    Bool
  </dt>
  <dd>
    <p>    my $gen = Bool; Creates a generator for boolean values: 0 for false, 1 for true. The generator ignores sizing guidance.</p>
  </dd>
  <dt>
    Char
  </dt>
  <dd>
    <p>    my $gen = Char( charset=&gt;"A-Za-z0-9_" ); Creates a generator for characters.  By default the characters are in the \s-1ASCII\s0 range [0,127], inclusive, but this behavior can be changed with the <strong>charset</strong> modifier:</p>
<dl class='dl-vertical'>
  <dt>
    Char( charset=&gt;<em>cset</em> )
  </dt>
  <dd>
    <p>Characters will be drawn from the character set given by the character-set specification <em>cset</em>.  The syntax of <em>cset</em> is similar the Perl \*(C`tr\*(C' built-in and is a string comprised of characters and character ranges:</p>
<dl class='dl-vertical'>
  <dt>
    <em>c</em>
  </dt>
  <dd>
    <p>Adds the character <em>c</em> to the set.</p>
  </dd>
  <dt>
    <em>c</em>-<em>d</em>
  </dt>
  <dd>
    <p>Adds the characters in the range <em>c</em> through <em>d</em> (inclusive) to the set.  Note: If <em>c</em> is lexicographically greater than <em>d</em>, the range is empty, and no characters will be added to the set.</p>
  </dd>

</dl>
<p>Examples: The characters \*(L"a\*(R", \*(L"b\*(R", \*(L"c\*(R", \*(L"d\*(R", \*(L"w\*(R", \*(L"x\*(R", \*(L"y\*(R", and \*(L"z\*(R" are in the set. Shorter version of the previous example. The \s-1ASCII\s0 character set. The character set contains \*(L"-\*(R", \*(L"_\*(R", upper- and lower-case \s-1ASCII\s0 letters, and the digits 0-9.  Notice that the dash must occur first so that it is not misinterpreted as denoting a range of characters.</p>
  </dd>

</dl>

  </dd>
  <dt>
    List(<em>elemgen</em>)
  </dt>
  <dd>
    <p>    my $gen = List( Bool, length=&gt;[1,10] ); Creates a generator for lists (which are returned as array refs).  The elements of the lists are generated by the generator given as <em>elemgen</em>.  The lengths of the generated lists are constrained by sizing guidance at the time of generation.  You can override the default sizing behavior using the optional <strong>length</strong> modifier: When the list generator calls the element generator, it divides the sizing guidance by the length of the list.  For example, if the list being generated will have 7 elements, when the list generator calls the element generator to generate each element, it will scale the sizing guidance by 1/7.  In this way the sizing guidance provides a rough constraint on the total number of elements produced, regardless of the depth of the list structure being generated.</p>
<dl class='dl-vertical'>
  <dt>
    List( ..., length=&gt;<em>N</em> )
  </dt>
  <dd>
    <p>Generated lists are exactly length <em>N</em>.</p>
  </dd>
  <dt>
    List( ..., length=&gt;[<em>M</em>,] )
  </dt>
  <dd>
    <p>Generated lists are at least length <em>M</em>.  (Maximum length is constrained by sizing factor.)</p>
  </dd>
  <dt>
    List( ..., length=&gt;[<em>M</em>,<em>N</em>] )
  </dt>
  <dd>
    <p>Generated lists are of length between <em>M</em> and <em>N</em>, inclusive. Sizing guidance is ignored.</p>
  </dd>

</dl>
<p><strong>Advanced Note:</strong> If more than one <em>elemgen</em> is given, they will be used in turn to create successive elements. In this case, the length of the list will be multiplied by the number of generators given.  For example, providing two generators will create double-length lists.</p>
  </dd>
  <dt>
    Hash(<em>keygen</em>, <em>valgen</em>)
  </dt>
  <dd>
    <p>    my $gen = Hash( String( charset=&gt;"A-Z", length=&gt;3 ),                     Float( range=&gt;[0.0, 100.0] ); Creates a generator for hashes (which are returned as hash refs).  The keys of the hash are generated by the generator given as <em>keygen</em>, and the values are generated by the generator <em>valgen</em>. The Hash generator takes an optional <strong>length</strong> modifier that specifies the desired hash length (= number of keys):</p>
<dl class='dl-vertical'>
  <dt>
    Hash( ..., length=&gt;<em>length-spec</em> )
  </dt>
  <dd>
    <p>Specifies the desired length of the generated hashes, using the same <em>length-spec</em> syntax as for the List generator.  Note that the generated hashes may be smaller than expected because of key collision.</p>
  </dd>

</dl>

  </dd>
  <dt>
    String
  </dt>
  <dd>
    <p>    my $gen = String( length=&gt;[3,], charset=&gt;"A-Z" ); Creates a generator for strings.  By default the strings will be drawn from the \s-1ASCII\s0 character set (0 through 127) and be of length constrained by the sizing factor.  Both defaults can be changed using modifiers:</p>
<dl class='dl-vertical'>
  <dt>
    String( charset=&gt;<em>cset</em> )
  </dt>
  <dd>
    <p>Characters will be drawn from the character set given by the character-set specification <em>cset</em>.  The syntax of <em>cset</em> is similar the Perl \*(C`tr\*(C' operator and is a string comprised of characters and character ranges.  See Char for a full description.</p>
  </dd>
  <dt>
    String( length=&gt;<em>length-spec</em> )
  </dt>
  <dd>
    <p>Specifies the desired length of generated strings, using the same <em>length-spec</em> syntax as for the List generator.</p>
  </dd>

</dl>

  </dd>
  <dt>
    Elements(<em>e1</em>, <em>e2</em>, ...)
  </dt>
  <dd>
    <p>    my $gen = Elements( "alpha", "beta", "gamma" ); Creates a generator that chooses among the given elements <em>e1</em>, <em>e2</em>, ... with equal probability.  Each call to the \*(C`generate\*(C' method will return one of the element values.  Sizing guidance has no effect on this generator. <strong>Note:</strong> This generator builder does not accept modifiers.  If you pass any, they will be interpreted as elements to be added to the pool from which the generator randomly selects, which is probably not what you want.</p>
  </dd>
  <dt>
    Unit(<em>e</em>)
  </dt>
  <dd>
    <p>    my $gen = Unit( "alpha" ); Creates a generator that always returns the value <em>e</em>.  Not too useful on its own but can be handy as a building block for combinators to chew on.  Naturally, sizing guidance has no effect on this generator. <strong>Note:</strong> This generator builder does not accept modifiers.</p>
  </dd>

</dl>

<h3>Generator combinators</h3>
<p>The following combinators allow you to build more complicated generators from simpler ones.  These combinators are exported into your code's namespace if you ask for \*(C`:combinators\*(C' or \*(C`:all\*(C' when you \*(C`use\*(C' this module.</p>
<dl class='dl-vertical'>
  <dt>
    Paste(<em>gens</em>..., glue=&gt;<em>str</em>)
  </dt>
  <dd>
    <p>    my $gen = Paste( (String(charset=&gt;"0-9",length=&gt;4)) x 4,                      glue =&gt; " " );     # gens credit-card numbers like "4592 9459 9023 1369"</p><p>    my $lgen = Paste( List( String(charset=&gt;"0-9",length=&gt;4)                           , length=&gt;4 ), glue =&gt; " " );     # another way of doing the same Creates a combined generator that generates values by joining the values generated by each of the supplied sub-generators <em>gens</em>. (Generated list values will have their elements \*(L"flattened\*(R" into the rest of the generated results before joining.) The resulting string is returned. The values are joined using the given glue string <em>str</em>.  If no <strong>glue</strong> modifier is provided, the default glue is the empty string. The sizing guidance given to the combined generator will be passed unchanged to each of the sub-generators.</p>
  </dd>
  <dt>
    OneOf(<em>gens</em>...)
  </dt>
  <dd>
    <p>    my $gen = OneOf( <strong>Unit</strong>(0), List(Int,length=&gt;3) );     # generates scalar 0 or a 3-element list of integers Creates a combined generator that generates each value by selecting at random (with equal probability) one of the sub-generators in <em>gens</em> and using that generator to generate the output value. The sizing guidance given to the combined generator will be passed unchanged to the selected sub-generator. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>
  <dt>
    Frequency([<em>freq1</em>, <em>gen1</em>], [<em>freq2</em>, <em>gen2</em>], ...)
  </dt>
  <dd>
    <p>    my $gen = Frequency( [50, Unit("common"     )],                          [35, Unit("less common")],                          [15, Unit("uncommon"   )] );     # generates one of "common", "less common", or     # "uncommon" with respective probabilities     # 50%, 35%, and 15%. Creates a combined generator that generates each value by selecting at random one of the generators <em>gen1</em> or <em>gen2</em> or ... and using that generator to generate the output value.  Each generator is selected with probability proportional to its associated frequency.  (If all of the given frequencies are the same, the Frequency combinator effectively becomes OneOf.)  The frequencies can be any non-negative numerical values you want and will be normalized to a 0-to-1 scale internally.  At least one frequency must be greater than zero. The sizing guidance given to the combined generator will be passed unchanged to the selected sub-generator. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>
  <dt>
    Each(<em>gens</em>...)
  </dt>
  <dd>
    <p>    my $gen = Each( <strong>Unit</strong>(1), Unit("X") );     # always generates [ 1, "X" ] Creates a generator that returns a list (array ref) whose successive elements are the successive values generated by the given generators <em>gens</em>. The sizing guidance given to the combined generator will be passed unchanged to each sub-generator. <strong>Note:</strong> This combinator does not accept modifiers. (Note for technical buffs: \*(C`Each(...)\*(C' is exactly equivalent to \*(C`List(..., length=&gt;1)\*(C').</p>
  </dd>
  <dt>
    Apply(<em>fn</em>, <em>gens</em>...)
  </dt>
  <dd>
    <p>    my $gen = Apply( sub { $_[0] x $_[1] }                    , Unit("X"), <strong>Unit</strong>(4) );     # always generates "XXXX" Creates a generator that applies the given function <em>fn</em> to arguments generated from each of the given sub-generators <em>gens</em> and returns the resulting value.  Each sub-generator contributes one value, and the values are passed to <em>fn</em> as arguments in the same order as the sub-generators were given to Apply. The sizing guidance given to the combined generator will be passed unchanged to each sub-generator. <strong>Note:</strong> The function <em>fn</em> is always evaluated in scalar context. If you need to generate an array, return it as an array reference. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>
  <dt>
    Map(<em>fn</em>, <em>gens</em>...)
  </dt>
  <dd>
    <p>    my $gen = Map( sub { "X" x $_[0] }                  , <strong>Unit</strong>(4), <strong>Unit</strong>(3), <strong>Unit</strong>(0) );     # always generates [ "XXXX", "XXX", "" ] Creates a generator that applies the given function <em>fn</em> to the values generated by the given generators <em>gen</em> one at a time and returns a list (array ref) whose elements are each of the successive results. The sizing guidance given to the combined generator will be passed unchanged to each sub-generator. <strong>Note:</strong> The function <em>fn</em> is always evaluated in scalar context. If you need to generate an array, return it as an array reference. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>
  <dt>
    Concat(<em>gens</em>...)
  </dt>
  <dd>
    <p>    my $gen = Concat( List( <strong>Unit</strong>(1),   length=&gt;3 )                     , List( Unit("x"), length=&gt;1 ) );     # always generates [1, 1, 1, "x"] Creates a generator that concatenates the values generated by each of its sub-generators, resulting in a list (which is returned as a array reference).  The values returned by the sub-generators are expected to be lists (array refs).  If a sub-generator returns a scalar value, it will be treated like a single-element list that contains the value. The sizing guidance given to the combined generator will be passed unchanged to each sub-generator. <strong>Note:</strong> If a sub-generator returns something other than a list or scalar, you will get a run-time error. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>
  <dt>
    Flatten(<em>gens</em>...)
  </dt>
  <dd>
    <p>    my $gen = Flatten( Unit( [[[[[[ 1 ]]]]]] ) );     # generates [1] Flatten is just like Concat except that it recursively flattens any sublists generated by the generators <em>gen</em> and then concatenates them to generate a final a list of depth one, regardless of the depth of any sublists. The sizing guidance given to the combined generator will be passed unchanged to each sub-generator. <strong>Note:</strong> If a sub-generator returns something other than a list or scalar, you will get a run-time error. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>
  <dt>
    ConcatMap(<em>fn</em>, <em>gens</em>)
  </dt>
  <dd>
    <p>    sub take_odds { my $x = shift;                     $x % 2 ? [$x] : [] }     my $gen = ConcatMap( &#92;&take_odds                        , <strong>Unit</strong>(1), <strong>Unit</strong>(2), <strong>Unit</strong>(3) );     # generates [1, 3] Creates a generator that applies the function <em>fn</em> to each of the values generated by the given generators <em>gen</em> in turn, and then concatenates the results. The sizing guidance given to the combined generator will be passed unchanged to each sub-generator. <strong>Note:</strong> The function <em>fn</em> is always evaluated in scalar context. If you need to generate an array, return it as an array reference. <strong>Note:</strong> If a sub-generator returns something other than a list or scalar, you will get a run-time error. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>
  <dt>
    FlattenMap(<em>fn</em>, <em>gens</em>)
  </dt>
  <dd>
    <p>    my $gen = FlattenMap( sub { [ ($_[0]) x 3 ] }                         , Unit([1]), Unit([[2]]) );     # generates [1, 1, 1, 2, 2, 2] Creates a generator that applies the function <em>fn</em> to each of the values generated by the given generators <em>gen</em> in turn, and then flattens and concatenates the results. The sizing guidance given to the combined generator will be passed unchanged to each sub-generator. <strong>Note:</strong> The function <em>fn</em> is always evaluated in scalar context. If you need to generate an array, return it as an array reference. <strong>Note:</strong> If a sub-generator returns something other than a list or scalar, you will get a run-time error. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>
  <dt>
    Sized(<em>fn</em>, <em>gen</em>)
  </dt>
  <dd>
    <p>    my $gen = Sized { 2 * $_[0] } List(Int);         # ^ magnify sizing guidance by factor of two     my $gen2 = Sized { 10 } Int;         # ^ use constant guidance of 10 Creates a generator that adjusts sizing guidance by passing it through the function <em>fn</em>. Then it calls the generator <em>gen</em> with the adjusted guidance and returns the result. <strong>Note:</strong> This combinator does not accept modifiers.</p>
  </dd>

</dl>

<h3>Rolling your own generators</h3>
<p>You can create your own generators by creating any object that has a \*(C`generate\*(C' method.  Your method should accept as its first argument sizing guidance <em>size</em> and, if it makes sense, adjust the complexity of the values it generates accordingly.</p><p>The easiest way to create a generator is by using the magic function \*(C`Gen\*(C'.  It promotes a block of code into a generator.  For example, here's a home-brew generator for times in <em>ctime</em>\|(3) format that is built on top of an Int generator:</p><p>  use Test::LectroTest::Generator qw( :common Gen );</p><p>  my $time_gen = Int(range=&gt;[0, 2_147_483_647], sized=&gt;0);   my $ctime_gen = Gen {       scalar localtime $time_gen-&gt;generate( @_ );   };</p><p>  print($ctime_gen-&gt;generate($_), "&#92;n") for 1..5;   # Fri Jun  2 18:13:21 1978   # Thu Mar 28 00:55:51 1974   # Wed Mar 26 06:41:09 2025   # Sun Sep 11 15:39:44 2016   # Fri Dec 26 00:39:31 1975</p><p>Alternatively, we could build the generator using the Apply combinator:</p><p>  my $ctime_gen2 = Apply { localtime $_[0] } $time_gen;</p><p><strong>Note:</strong> \*(C`Gen\*(C' is not exported into your code's namespace by default. If you want to use it, you must import it by name or import \*(C`:all\*(C' when you use this module.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Here are some examples to consider.</p><h3>Simple examples</h3>
<p> use strict;  use Test::LectroTest::Generator qw(:common);</p><p> show("Ints (sized by default)", Int);</p><p> show("Floats (sized by default)", Float);</p><p> show("Percentages (unsized)",       Int( range=&gt;[0,100], sized=&gt;0 ));</p><p> show("Lists (sized by default) of Ints (unsized) in [0,10]",       List( Int( sized=&gt;0, range=&gt;[0,10] ) ));</p><p> show("Uppercase-alpha identifiers at least 3 chars long",       String( length=&gt;[3,], charset=&gt;"A-Z" ));</p><p> show("Hashes (sized by default) of form AAA=&gt;Digit",       Hash( String( length=&gt;3, charset=&gt;"A-Z" ),             Int( sized=&gt;0, range=&gt;[0,9] ) ));</p><p> sub show {      print "&#92;n", shift(), "&#92;n";      my ($gen) = @_;      for (1..10) {          my $val = $gen-&gt;generate($_);          printf "Size %2d:  ", $_;          if (ref $val eq "HASH") {              my @pairs = map {"$_=&gt;$val-&gt;{$_}"} keys %$val;              print "{ @pairs }";          }          elsif (ref $val eq "ARRAY") {              print "[ @$val ]"          }          else {              print $val;          }          print "&#92;n";      }  }</p>
<h3>Advanced examples</h3>
<p>For these examples we use \*(C`Data::Dumper\*(C' to inspect the data structures we generate.  Also, we import not only the common generator constructors (like Int) but also the generic Gen constructor, which lets us build generators out of blocks on the fly.</p><p>    use Data::Dumper;     use Test::LectroTest::Generator qw(:common Gen);</p><p>First, here's a recipe for building a list of lists of integers:</p><p>    my $loloi_gen = List( List( Int(sized=&gt;0) ) );     print Dumper($loloi_gen-&gt;generate(10));</p><p>You may want to run the example several times to get a feel for the distribution of the generated output.</p><p>Now, a more complicated example.  Here we build sized trees of random depth using a recursive set of generators.</p><p>    my $tree_gen = do {         my $density = 0.5;         my $leaf_gen = Int( sized=&gt;0 );         my $tree_helper = &#92;1;         my $branch_gen = List( Gen { $$tree_helper-&gt;generate(@_) } );         $tree_helper = &#92;Gen {             my ($size) = @_;             return rand($size) &lt; $density                 ? $leaf_gen-&gt;generate($size)                 : $branch_gen-&gt;generate($size + 1);         };         $$tree_helper;     };</p><p>    print Dumper($tree_gen-&gt;generate(30));</p><p>We define a tree as either a leaf or a branch, and we randomly decide between the two at each node in the growing tree.  Leaves are just integers and become more likely when the sizing guidance diminishes (which happens as we go deeper).  The code uses $density as a control knob for leaf density.  (Try re-running the above code after changing the value of $density.  Try 0, 1, and 2.)  Branches, on the other hand, are lists of trees.  Because branches generate trees, and trees generate branches, we use a reference trick to set up the mutually recursive relationship.  This we encapsulate within a <strong>do</strong> block for tidiness.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Test::LectroTest::Generator&hellip;</h2>
        <div class="sectioncontent">
<p>Test::LectroTest gives a quick overview of automatic, specification-based testing with LectroTest.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Tom Moertel (tom@moertel.com)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSPIRATION</h2>
        <div class="sectioncontent">
<p>The LectroTest project was inspired by Haskell's QuickCheck module by Koen Claessen and John Hughes: http://www.cs.chalmers.se/~rjmh/QuickCheck/.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT and LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2004-13 by Thomas G Moertel.  All rights reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Test::LectroTest::FailureRecorder.3pm.html"><span aria-hidden="true">&larr;</span> Test::LectroTest::FailureRecorder.3pm: Records/plays failures for regression testing</a></li>
   <li class="next"><a href="Test::LectroTest::Property.3pm.html">Test::LectroTest::Property.3pm: Properties that make testable claims about your software <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

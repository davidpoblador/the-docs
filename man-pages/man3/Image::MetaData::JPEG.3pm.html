<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Image::MetaData::JPEG: Perl extension for showing/modifying jpeg (meta)data.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl extension for showing/modifying jpeg (meta)data.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Image::MetaData::JPEG (3pm) manual">
  <meta name="twitter:description" content="Perl extension for showing/modifying jpeg (meta)data.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libimage-metadata-jpeg-perl-Image::MetaData::JPEG-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Image::MetaData::JPEG.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Image::MetaData::JPEG (3pm) manual" />
  <meta property="og:description" content="Perl extension for showing/modifying jpeg (meta)data." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libimage-metadata-jpeg-perl-Image::MetaData::JPEG-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Image::MetaData::JPEG<small> (3pm)</small></h1>
        <p class="lead">Perl extension for showing/modifying jpeg (meta)data.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Image::MetaData::JPEG.3pm.html">
      <span itemprop="name">Image::MetaData::JPEG: Perl extension for showing/modifying jpeg (meta)data.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libimage-metadata-jpeg-perl/">
      <span itemprop="name">libimage-metadata-jpeg-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Image::MetaData::JPEG.3pm.html">
      <span itemprop="name">Image::MetaData::JPEG: Perl extension for showing/modifying jpeg (meta)data.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use Image::MetaData::JPEG;

    # Create a new JPEG file structure object
    my $image = new Image::MetaData::JPEG(&apos;somepicture.jpg&apos;);
    die &apos;Error: &apos; . Image::MetaData::JPEG::Error() unless $image;

    # Get a list of references to comment segments
    my @segments = $image-&gt;get_segments(&apos;COM&apos;, &apos;INDEXES&apos;);

    # Get the JPEG picture dimensions
    my ($dim_x, $dim_y) = $image-&gt;get_dimensions();

    # Show all JPEG segments and their content
    print $image-&gt;get_description();

    # Retrieve a specific value from Exif meta-data
    my $image_data = $image-&gt;get_Exif_data(&apos;IMAGE_DATA&apos;, &apos;TEXTUAL&apos;);
    print $image_data-&gt;{DateTimeOriginal}-&gt;[0], "&#92;n";

    # Modify the DateTime tag for the main image
    $image-&gt;set_Exif_data({&apos;DateTime&apos; =&gt; &apos;1994:07:23 12:14:51&apos;},
                           &apos;IMAGE_DATA&apos;, &apos;ADD&apos;);

    # Delete all meta-data segments (please, don&apos;t)
    $image-&gt;drop_segments(&apos;METADATA&apos;);

    # Rewrite file to disk after your modifications
    $image-&gt;save(&apos;new_file_name.jpg&apos;);

    # ... and a lot more methods for viewing/modifying meta-data, which
    # are accessed through the $file or $segments[$index] references.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The purpose of this module is to read/modify/rewrite meta-data segments in \s-1JPEG\s0 (Joint Photographic Experts Group format) files, which can contain comments, thumbnails, Exif information (photographic parameters), \s-1IPTC\s0 information (editorial parameters) and similar data.</p><p>Each \s-1JPEG\s0 file is made of consecutive <em>segments</em> (tagged data blocks), and the actual row picture data. Most of these segments specify parameters for decoding the picture data into a bitmap; some of them, namely the <em>\s-1COM\s0</em>ment and <em>\s-1APP\s0</em>lication segments, contain instead meta-data, i.e., information about how the photo was shot (usually added by a digital camera) and additional notes from the photograph. These additional pieces of information are especially valuable for picture databases, since the meta-data can be saved together with the picture without resorting to additional database structures. See the appendix about the structure of \s-1JPEG\s0 files for technical details.</p><p>This module works by breaking a \s-1JPEG\s0 file into individual segments. Each file is associated to an <em>Image::MetaData::JPEG</em> structure object, which contains one <em>Image::MetaData::JPEG::Segment</em> object for each segment. Segments with a known format are then parsed, and their content can be accessed in a structured way for display. Some of them can even be modified and then rewritten to disk. This package variable must be used to inhibit the printing of warnings: if it is false, warnings are silently ignored. Otherwise, warning messages come with a detailed back-trace and description of the warning location.     $Image::MetaData::JPEG::show_warnings = undef;</p><h3>Managing a \s-1JPEG\s0 structure object</h3>

<dl class='dl-vertical'>
  <dt>
    JPEG::new
  </dt>
  <dd>
    <p>[arguments: \*(C`($input, $regex, $options)\*(C'] The first thing you need in order to interact with a \s-1JPEG\s0 picture is to create an <em>Image::MetaData::JPEG</em> structure object. This is done with a call to the <em>new</em> method, whose first argument is an <em>input source</em>, either a <em>scalar</em>, interpreted as a file name to be opened and read, or a <em>scalar reference</em>, interpreted as a pointer to an in-memory buffer containing a \s-1JPEG\s0 stream. This interface is similar to that of Image::Info, but no open file handle is (currently) accepted. The constructor then parses the picture content and stores its segments internally. The memory footprint is close to the size of the disk file plus a few tens of kilobytes.     my $file = new Image::MetaData::JPEG(&apos;a_file_name.jpg&apos;);     my $file = new Image::MetaData::JPEG(&#92; $a_JPEG_stream); The constructor method accepts two optional arguments, a <em>regular</em> expression and an <em>option string</em>. If the regular expression is present, it is matched against segment names, and only those segments with a positive match are parsed (they are nonetheless stored); this allows for some speed-up if you just need partial information, but be sure not to miss something necessary; e.g., \s-1SOF\s0 segments are needed for reading the picture dimensions. For instance, if you just want to manipulate the comments, you could set the string to '\s-1COM\s0'.     my $file = new Image::MetaData::JPEG(&apos;a_file_name.jpg&apos;, &apos;COM&apos;); The third optional argument is an option string. If it matches the string '\s-1FASTREADONLY\s0', only the segments matching the regular expression are actually stored; also, everything which is found after a Start Of Scan is completely neglected. This allows for very large speed-ups, but, obviously, you cannot rebuild the file afterwards, so this is only for getting information fast, e.g., when doing a directory scan.     my $file = new Image::MetaData::JPEG(&apos;a_file.jpg&apos;, &apos;COM&apos;, &apos;FASTREADONLY&apos;); Nota bene: an old version of \*(L"Arles Image Web Page Creator\*(R" had a bug which caused the application to generate \s-1JPEG\s0's with illegal comment segments, reportedly due to a bug in the Intel \s-1JPEG\s0 library the developers used at that time (these segments had to 0x00 bytes appended). It is true that a \s-1JPEG\s0 file with garbage between segments is to be considered invalid, but some libraries like \s-1IJG\s0's try to forgive, so this module tries to forgive too, if the amount of garbage isn't too large (only a warning is printed).</p>
  </dd>
  <dt>
    JPEG::Error
  </dt>
  <dd>
    <p>[arguments: none] If the file reference remains undefined after a call to new, the file is to be considered not parseable by this module, and one should issue some error message and go to another file. An error message explaining the reason of the failure can be retrieved with the <em>Error</em> method:     die &apos;Error: &apos; . Image::MetaData::JPEG::Error() unless $file;</p>
  </dd>
  <dt>
    JPEG::get_segments
  </dt>
  <dd>
    <p>[arguments: \*(C`($regex, $do_indexes)\*(C'] If the <em>new</em> call is successful, the returned reference points to an <em>Image::MetaData::JPEG</em> structure object containing a list of references to Image::MetaData::JPEG::Segment objects, which can be retrieved with the <em>get_segments</em> method. This method returns a list containing the references (or their indexes in the Segment references' list, if the second argument is the string <em>\s-1INDEXES\s0</em>) to those Segments whose name matches the <em></em><strong>$regex</strong><em> regular expression</em>. For instance, if $regex is '\s-1APP\s0', all application Segments will be returned. If you want only \s-1APP1\s0 Segments you need to specify '^APP1$'. The output can become invalid after adding/removing any Segment. If $regex is undefined, all references are returned.     my @segments = $file-&gt;get_segments($regex, $do_indexes);</p>
  </dd>
  <dt>
    JPEG::drop_segments
  </dt>
  <dd>
    <p>[arguments: \*(C`($regex)\*(C'] Similarly, if you are only interested in eliminating some segments, you can use the <em>drop_segments</em> method, which erases from the internal segment list all segments matching a given regular expression. If the regular expression is undefined or evaluates to the empty string, this method throws an exception, because I don't want the user to erase the whole file just because he/she did not understand what he was doing. One should also remember that it is not wise to drop non-meta-data segments, because this in general invalidates the file. As a special case, if $regex == '\s-1METADATA\s0', all APP* and \s-1COM\s0 segments are erased.     $file-&gt;drop_segments(&apos;^APP1$&apos;);</p>
  </dd>
  <dt>
    JPEG::insert_segments
  </dt>
  <dd>
    <p>[arguments: \*(C`($segref, $pos, $overwrite)\*(C'] Inserting a Segment into the picture's segment list is done with the <em>insert_segments</em> method. This method inserts the segments referenced by $segref into the current list of segments at position $pos. If $segref is undefined, the method fails silently. If $pos is undefined, the position is chosen automatically (using find_new_app_segment_position ); if $pos is out of bound, an exception is thrown; this happens also if $pos points to the first segment, and it is an \s-1SOI\s0. $segref may be a reference to a single segment or a reference to a list of segment references; everything else throws an exception. If $overwrite is defined, it must be the number of segments to overwrite during the splice.     $file-&gt;insert_segments([$my_comment_1, $my_comment_2], 3, 1);</p>
  </dd>
  <dt>
    JPEG::get_description
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::get_dimensions
  </dt>
  <dd>
    <p>[arguments: none] Getting a string describing the findings of the parsing stage is as easy as calling the <em>get_description</em> method. Those Segments whose parsing failed have the first line of their description stating the stopping error condition. Non-printable characters are replaced, in the string returned by get_description, by a slash followed by the two digit hexadecimal code of the character. The (x,y) dimensions of the \s-1JPEG\s0 picture are returned by <em>get_dimensions</em> from the <em>Start of Frame</em> (SOF*) Segment:     print $file-&gt;get_description();     my ($dim_x, $dim_y) = $file-&gt;get_dimensions();</p>
  </dd>
  <dt>
    JPEG::find_new_app_segment_position
  </dt>
  <dd>
    <p>[arguments: \*(C`($name)\*(C'] If a new comment or application Segment is to be added to the file, the module provides a standard algorithm for deciding the location of the new Segment, in the <em>find_new_app_segment_position</em> method. The argument is the name of the Segment to be inserted (it defaults to '\s-1COM\s0', producing a warning). The position is chosen immediately before the first (or after the last) element of some list, provided that the list is not empty, otherwise the next list is taken into account: 1) [for \s-1COM\s0 segments only] after '\s-1COM\s0' segments; otherwise after \s-1APP\s0 segments; 2) [for APPx segments only] after APPy's (trying y = x..0, in sequence); otherwise before APPy's (trying y = x+1..15, in sequence); 3) before \s-1DHP\s0 segments; 4) before \s-1SOF\s0 segments. If all these tentatives fail, the position immediately after the \s-1SOI\s0 segment is returned (i.e., 1).     my $new_position = $file-&gt;find_new_app_segment_position(&apos;APP2&apos;);</p>
  </dd>
  <dt>
    JPEG::save
  </dt>
  <dd>
    <p>[arguments: \*(C`($filename)\*(C'] The data areas of each Segment in the in-memory \s-1JPEG\s0 structure object can be rewritten to a disk file or to an in-memory scalar, thus recreating the (possibly modified) \s-1JPEG\s0 picture. This is accomplished by the <em>save</em> method, accepting a <em>filename</em> or a <em>scalar reference</em> as argument; if the file name is undefined, it defaults to the file originally used to create the \s-1JPEG\s0 structure object. This method returns \*(L"true\*(R" (1) if it works, \*(L"false\*(R" (undefined) otherwise. Remember that if the file had initially been opened with the '\s-1FASTREADONLY\s0' option, it is not possible to save it, and this call fails immediately.     print "Creation of $newJPEG failed!" unless $file-&gt;save($newJPEG); An example of how to proficiently use the in-memory feature to read the content of a \s-1JPEG\s0 thumbnail is the following (see later for get_Exif_data, and also do some error checking!):     my $thumbnail = $file-&gt;get_Exif_data(&apos;THUMBNAIL&apos;);     print Image::MetaData::JPEG-&gt;new($thumbnail)-&gt;get_description();</p>
  </dd>

</dl>

<h3>Managing a \s-1JPEG\s0 Segment object</h3>

<dl class='dl-vertical'>
  <dt>
    JPEG::Segment::name
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::Segment::error
  </dt>
  <dd>
    <p>An <em>Image::MetaData::JPEG::Segment</em> object is created for each Segment found in the \s-1JPEG\s0 image during the creation of a \s-1JPEG\s0 object (see JPEG::new), and a parser routine is executed at the same time. The <em>name</em> member of a Segment object identifies the \*(L"nature\*(R" of the Segment (e.g. '\s-1APP0\s0', ..., '\s-1APP15\s0' or '\s-1COM\s0'). If any error occurs (in the Segment or in an underlying class), the parsing of that Segment is interrupted at some point and remains therefore incomplete: the <em>error</em> member of the relevant Segment object is then set to a meaningful error message. If no error occurs, the same variable is left undefined.     printf &apos;Invalid %s!&#92;n&apos;, $segment-&gt;{name} if $segment-&gt;{error};</p>
  </dd>
  <dt>
    JPEG::Segment::records
  </dt>
  <dd>
    <p>The reference to the Segment object is returned in any case. In this way, a <em>faulty Segment</em> cannot inhibit the creation of a \s-1JPEG\s0 structure object; faulty segments cannot be edited or modified, basically because their structure could not be fully understood. They are always rewritten to disk unmodified, so that a file with corrupted or non-standard Segments can be partially edited without fearing of damaging it. Once a Segment has successfully been built, its parsed information can be accessed directly through the <em>records</em> member: this is a reference to an array of JPEG::Record objects, an internal class modelled on Exif records (see the subsection about record management for further details).     my $records = $segment-&gt;{records};     printf &apos;%s has %d records&#92;n&apos;, $segment-&gt;{name}, scalar @$records;</p>
  </dd>
  <dt>
    JPEG::Segment::search_record
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::Segment::search_record_value
  </dt>
  <dd>
    <p>[arguments: \*(C`([$dirref], $keys ...)\*(C'] If a specific record is needed, it can be selected with the help of the <em>search_record</em> method, which searches for a record with a given key (see \*(L"JPEG::Record::key\*(R") in a given record directory, returning a reference to the record if the search was fruitful, the undefined value otherwise. The algorithm for the search is as follows: 1) a start directory is chosen by looking at the last argument: if it is an \s-1ARRAY\s0 ref it is popped out and used, otherwise the top-level directory is selected; 2) a string is created by joining all remaining arguments on '@', then it is exploded into a list of keys on the same character (all undefined or \*(L"false\*(R" arguments are simply discarded); 3) these keys are used for an iterative search starting from the initially chosen directory: all but the last key must correspond to $REFERENCE records. If $key is exactly \*(L"\s-1FIRST_RECORD\s0\*(R" / \*(L"\s-1LAST_RECORD\s0\*(R", the first/last record in the current dir is used.     my $segments = $file-&gt;get_segments(&apos;APP0&apos;);     my $segment = $$segments[0];     print "I found it!&#92;n" if $segment-&gt;search_record(&apos;Identifier&apos;); If you are interested only in the Record's value, you can use the <em>search_record_value</em> method, a simple wrapper around <em>search_record()</em>: it returns the record value (with \*(L"JPEG::Record::get_value\*(R") if the search is successful, undef otherwise.     print "Its value is: ", $segment-&gt;search_record_value(&apos;Identifier&apos;); Nota bene: the returned record is initialised with a \*(L"fake\*(R" $REFERENCE record pointing to the <em>records</em> member of the current segment; this record is therefore returned if <em>search_record</em> is invoked without arguments. For the same reason, search_record_value invoked without arguments returns the <em>records</em> member:     $segment-&gt;search_record_value() eq $this-&gt;{records} || print "error!";</p>
  </dd>
  <dt>
    JPEG::Segment::update
  </dt>
  <dd>
    <p>[arguments: none] If a Segment's content (i.e. its Records' values) is modified, it is necessary to dump it into the private binary data area of the Segment in order to have the modification written to disk at \*(L"JPEG::save\*(R" time. This is accomplished by invoking the <em>update</em> method (necessary only if you changed record values \*(L"by hand\*(R"; all \*(L"high-level\*(R" methods for changing a Segment's content in fact call \*(L"update\*(R" on their own). However, only Segments without errors can be updated (don't try to undef the Segment's error flag, unless you know what you are doing!); trying to update a segment with errors throws an exception. The same happens when trying to update a segment without update support or without records (this catches segments created with the '\s-1NOPARSE\s0' flag). In practise, never use this method unless you are writing an extension for this module. Note that this method preliminarly saves a reference to the old segment data area and restores it if the update process fails (if this happens, a warning is generated). One wonders wheather there are there cleverer ways to handle this case (any suggestion is welcome). It is however better to have a corrupt object in memory, than a corrupt object written over the original. Currently, this is restricted to the possibility that an updated segment becomes too large.     $segment-&gt;update();</p>
  </dd>
  <dt>
    JPEG::Segment::reparse_as
  </dt>
  <dd>
    <p>[arguments: \*(C`($new_name)\*(C'] The <em>reparse_as</em> method re-executes the parsing of a Segment after changing the Segment name. This is very handy if you have a \s-1JPEG\s0 file with a \*(L"correct\*(R" application Segment exception made for its name. I used it the first time for a file having an ICC_profile Segment (normally in \s-1APP2\s0) stored as \s-1APP13\s0. Note that the name of the Segment is permanently changed, so, if the Segment is updated and the file is rewritten to disk, it will be \*(L"correct\*(R".     for my $segment ($file-&gt;get_segments(&apos;APP13&apos;)) {         $segment-&gt;reparse_as(&apos;APP2&apos;) if $segment-&gt;{error} &&              $segment-&gt;search_record(&apos;Identifier&apos;) =~ &apos;ICC_PROFILE&apos;;         $segment-&gt;update(); }</p>
  </dd>
  <dt>
    JPEG::Segment::output_segment_data
  </dt>
  <dd>
    <p>[arguments: none] The current in-memory data area of a Segment can be output to a file through the <em>output_segment_data</em> method (exception made for entropy coded Segments, this includes the initial two bytes with the Segment identifier and the two bytes with the length if present); the argument is a file handle (this is likely to become more general in the future). If there are problems at output time (e.g., the segment content is too large), an exception is thrown     eval { $segment-&gt;output_segment_data($output_handle) } ||         print "A terrible output error occurred! Help me.&#92;n";</p>
  </dd>
  <dt>
    JPEG::Segment::get_description
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::Segment::size
  </dt>
  <dd>
    <p>[arguments: none] A string describing the parsed content of the Segment is obtained through the <em>get_description</em> method (this is the same string used by the get_description method of a \s-1JPEG\s0 structure object). If the Segment parsing stage was interrupted, this string includes the relevant error. The <em>size</em> method returns the size of the internal data area of a Segment object. This can be different from the length of the scalar returned by get_segment_data, because the identifier and the length is not included.     print $segment-&gt;get_description();     print &apos;Size is 4 + &apos; . $segment-&gt;size();</p>
  </dd>

</dl>

<h3>Managing a \s-1JPEG\s0 Record object</h3>

<dl class='dl-vertical'>
  <dt>
    JPEG::Record::key
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::Record::type
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::Record::values
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::Record::extra
  </dt>
  <dd>
    <p>The <em>JPEG::Record</em> class is an internal class for storing parsed information about a \s-1JPEG\s0 Segment, inspired by Exif records. A Record is made up by four fields: <em>key</em>, <em>type</em>, <em>values</em> and <em>extra</em>. The <em>key</em> is the record's identifier; it is either numeric or textual (numeric keys can be translated with the help of the <em></em><strong>%JPEG_lookup</strong><em></em> function in <em>Tables.pm</em>, included in this package). The <em>type</em> is obviously the type of stored info (like unsigned integers, \s-1ASCII\s0 strings and so on ...). <em>extra</em> is a helper field for storing additional information. Last, <em>values</em> is an array reference to the record content (almost always there is just one value). For instance, for a non-IPTC Photoshop record in \s-1APP13:\s0     printf &apos;The numeric key 0x%04x means %s&apos;,       $record-&gt;{key}, JPEG_lookup(&apos;APP13@Photoshop_RECORDS&apos;, $record-&gt;{key});     printf &apos;This record contains %d values&#92;n&apos;, scalar @{$record-&gt;{values}}; A Record's <em>type</em> can be one among the following predefined constants:          0  $NIBBLES    two 4-bit unsigned integers (private)          1  $BYTE       An 8-bit unsigned integer          2  $ASCII      A variable length ASCII string          3  $SHORT      A 16-bit unsigned integer          4  $LONG       A 32-bit unsigned integer          5  $RATIONAL   Two LONGs (numerator and denominator)          6  $SBYTE      An 8-bit signed integer          7  $UNDEF      A generic variable length string          8  $SSHORT     A 16-bit signed integer          9  $SLONG      A 32-bit signed integer (2&apos;s complement)         10  $SRATIONAL  Two SLONGs (numerator and denominator)         11  $FLOAT      A 32-bit float (a single float)         12  $DOUBLE     A 64-bit float (a double float)         13  $REFERENCE  A Perl list reference (internal) $UNDEF is used for not-better-specified binary data. A record of a numeric type can have multiple elements in its <em>@{values}</em> list ($NIBBLES implies an even number); an $UNDEF or $ASCII type record instead has only one element, but its length can vary. Last, a $REFERENCE record holds a single Perl reference to another record list: this allows for the construction of a sort of directory tree in a Segment.</p>
  </dd>
  <dt>
    JPEG::Record::get_category
  </dt>
  <dd>
    <p>[arguments: none] The category of a record can be obtained with the <em>get_category</em> method, which returns 'p' for Perl references, 'I' for integer types, 'S' for $ASCII and $UNDEF, 'R' for rational types and 'F' for floating point types.     for my $record (@{$segment-&gt;{records}}) {         print "Subdir found&#92;n" if $record-&gt;get_category() eq &apos;p&apos;; }</p>
  </dd>
  <dt>
    JPEG::Record::get_description
  </dt>
  <dd>
    <p>[arguments: \*(C`($names)\*(C'] A human-readable description of a Record's content is the output of the <em>get_description</em> method. Its argument is a reference to an array of names, which are to be used as successive keys in a general hash keeping translations of numeric tags. No argument is needed if the key is already non-numeric (see the example of get_value for more details). In the output of <em>get_description</em> unreasonably long strings are trimmed and non-printing characters are replaced with their hexadecimal representation. Strings are then enclosed between delimiters, and null-terminated $ASCII strings have their last character chopped off (but a dot is added after the closing delimiter). $ASCII strings use a " as delimiter, while $UNDEF strings use '.     print $record-&gt;get_description($names);</p>
  </dd>
  <dt>
    JPEG::Record::get_value
  </dt>
  <dd>
    <p>[arguments: \*(C`($index)\*(C'] In absence of \*(L"high-level\*(R" routines for collecting information, a Record's content can be read directly, either by accessing the <em>values</em> member or by calling the <em>get_value</em> method: it returns the $index-th value in the value list; if the index is undefined (not supplied), the sum/concatenation of all values is returned. The index is checked for out-of-bound errors. The following code, an abridged version of get_description, shows how to proficiently use these methods and members.     sub show_directory {       my ($segment, $records, $names) = @_;       my @subdirs = ();       for my $record (@$records) {         print $record-&gt;get_description($names);         push @subdirs, $record if $record-&gt;get_category() eq &apos;p&apos;; }       foreach my $subdir (@subdirs) {         my $directory = $subdir-&gt;get_value();         push @$names, $subdir-&gt;{key};         printf &apos;Subdir %s (%d records)&apos;, $names, scalar @$directory;         show_directory($segment, $directory, $names);         pop @$names; } }     show_directory($segment, $segment-&gt;{records}, [ $segment-&gt;{name} ]);</p>
  </dd>
  <dt>
    JPEG::Record::get
  </dt>
  <dd>
    <p>[arguments: \*(C`($endianness)\*(C'] If the Record structure is needed in detail, one can resort to the <em>get</em> method; in list context this method returns (key, type, count, dataref).  The data reference points to a packed scalar, ready to be written to disk. In scalar context, it returns the dereferenced dataref. This is tricky (but handy for other routines). The argument specifies an endianness (this defaults to big endian).     my ($key, $type, $count, $dataref) = $record-&gt;get();</p>
  </dd>
  <dt>
    JPEG::get_number_of_comments
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::get_comments
  </dt>
  <dd>
    <p>[arguments: none] Each "<em>\s-1COM\s0</em>" Segment in a \s-1JPEG\s0 file contains a user comment, whose content is free format. There is however a limitation, because a \s-1JPEG\s0 Segment cannot be longer than 64KB; this limits the length of a comment to <em></em><strong>$max_length</strong><em></em> = (2^16 - 3) bytes. The number of comment Segments in a file is returned by <em>get_number_of_comments</em>, while <em>get_comments</em> returns a list of strings (each string is the content of a \s-1COM\s0 Segment); if no comments are present, they return zero and the empty list respectively.     my $number = $file-&gt;get_number_of_comments();     my @comments = $file-&gt;get_comments();</p>
  </dd>
  <dt>
    JPEG::add_comment
  </dt>
  <dd>
    <p>[arguments: \*(C`($string)\*(C'] A comment can be added with the <em>add_comment</em> method, whose only argument is a string. Indeed, if the string is too long, it is broken into multiple strings with length smaller or equal to $max_length, and multiple comment Segments are added to the file. If there is already at least one comment Segment, the new Segments are created right after the last one. Otherwise, the standard position search of find_new_app_segment_position  is applied.     $file-&gt;add_comment(&apos;a&apos; x 100000);</p>
  </dd>
  <dt>
    JPEG::set_comment
  </dt>
  <dd>
    <p>[arguments: \*(C`($index, $string)\*(C'] An already existing comment can be replaced with the <em>set_comment</em> method. Its two arguments are an <em></em><strong>$index</strong><em></em> and a <em></em><strong>$string</strong><em></em>: the $index-th comment Segment is replaced with one or more new Segments based on $string (the index of the first comment Segment is 0). If $string is too big, it is broken down as in add_comment. If $string is undefined, the selected comment Segment is erased. If $index is out-of-bound a warning is printed out.     $file-&gt;set_comment(0, &apos;This is the new comment&apos;);</p>
  </dd>
  <dt>
    JPEG::remove_comment
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::remove_all_comments
  </dt>
  <dd>
    <p>[arguments: \*(C`($index)\*(C' for <em>remove_comment</em>] However, if you only need to erase the comment, you can just call <em>remove_comment</em> with just the Segment $index. If you want to remove all comments, just call <em>remove_all_comments</em>.     $file-&gt;<strong>remove_comment</strong>(0);     $file-&gt;remove_all_comments();</p>
  </dd>
  <dt>
    JPEG::join_comments
  </dt>
  <dd>
    <p>[arguments: \*(C`($separation, @selection)\*(C'] It is known that some \s-1JPEG\s0 comment readers out there do not read past the first comment. So, the <em>join_comments</em> method, whose goal is obvious, can be useful. This method creates a string from joining all comments selected by the <em></em><strong>@selection</strong><em></em> index list (the <em></em><strong>$separation</strong><em></em> scalar is a string inserted at each junction point), and overwrites the first selected comment while deleting the others. A exception is thrown for each illegal comment index. Similar considerations as before on the string length apply. If no separation string is provided, it defaults to &#92;n. If no index is provided in @selection, it is assumed that the method must join all the comments into the first one, and delete the others.     $file-&gt;join_comments(&apos;---&apos;, 2, 5, 8); <em>\s-1APP0\s0</em> Segments are written by older cameras adopting the <em>\s-1JFIF\s0</em> (\s-1JPEG\s0 File Interchange Format), or one of its extensions, for storing images. \s-1JFIF\s0 files use the \s-1APP0\s0 application Segment for inserting configuration data and a \s-1JPEG\s0 or \s-1RGB\s0 packed <em>thumbnail</em> image. The format is described in the appendix about the \s-1APP0\s0 structure, including the names of all possible tags. It is of course possible to access each \s-1APP0\s0 Segment individually by means of the get_segments and search_record_value methods. A snippet of code for doing this is the following:</p>
  </dd>

</dl>
<p>    for my $segment ($file-&gt;get_segments(&apos;APP0&apos;)) {         my $iden = $segment-&gt;search_record_value(&apos;Identifier&apos;);         my $xdim = $segment-&gt;search_record_value(&apos;Xthumbnail&apos;);         my $ydim = $segment-&gt;search_record_value(&apos;Ythumbnail&apos;);         printf &apos;Segment type: %s; dimensions: %dx%d&#92;n&apos;,                 substr($iden, 0, -1), $xdim, $ydim;         printf &apos;%15s =&gt; %s&#92;n&apos;, $_-&gt;{key}, $_-&gt;get_value()                 for $segment-&gt;{records}; }</p>
<dl class='dl-vertical'>
  <dt>
    JPEG::get_app0_data
  </dt>
  <dd>
    <p>[arguments: none] However, if you want to avoid to deal directly with Segments, you can use the <em>get_app0_data</em> method, which returns a reference to a hash with a plain translation of the content of the first interesting \s-1APP0\s0 segment (this is the first '\s-1JFXX\s0' \s-1APP0\s0 segment, if present, the first '\s-1JFIF\s0' \s-1APP0\s0 segment otherwise). Segments with errors are excluded. An empty hash means that no valid \s-1APP0\s0 segment is present.     my $data = $file-&gt;get_app0_data();     printf &apos;%15s =&gt; %s&#92;n&apos;, $_, (($_=~/..Thumbnail/)?&apos;...&apos;:$$data{$_}); The \s-1DCT\s0 Exif (Exchangeable Image File format) standard provides photographic meta-data in the \s-1APP1\s0 section. Various tag-values pairs are stored in groups called IFDs (Image File Directories), where each group refers to a different kind of information; one can find data about how the photo was shot, \s-1GPS\s0 data, thumbnail data and so on ... (see the appendix about the \s-1APP1\s0 segment structure for more details). This module provides a number of methods for managing Exif data without dealing with the details of the low level representation. Note that, given the complicated structure of an Exif \s-1APP1\s0 segment (where extensive use of \*(L"pointers\*(R" is made), some digital cameras and graphic programs decide to leave some unused space in the \s-1JPEG\s0 file. The dump routines of this module, on the other hand, leave no unused space, so just calling <em>update()</em> on an Exif \s-1APP1\s0 segment even without modifying its content can give you a smaller file (some tens of kilobytes can be saved).</p>
  </dd>
  <dt>
    JPEG::retrieve_app1_Exif_segment
  </dt>
  <dd>
    <p>[arguments: \*(C`($index)\*(C'] In order to work on Exif data, an Exif \s-1APP1\s0 Segment must be selected. The <em>retrieve_app1_Exif_Segment</em> method returns a reference to the <em></em><strong>$index</strong><em></em>-th such Segment (the first Segment if the index is undefined). If no such Segment exists, the method returns the undefined reference. If $index is (-1), the routine returns the number of available \s-1APP1\s0 Exif Segments (which is non negative).     my $num = $file-&gt;retrieve_app1_Exif_segment(-1);     my $ref = $file-&gt;retrieve_app1_Exif_segment($num - 1);</p>
  </dd>
  <dt>
    JPEG::provide_app1_Exif_segment
  </dt>
  <dd>
    <p>[arguments: none] If you want to be sure to have an Exif \s-1APP1\s0 Segment, use the <em>provide_app1_Exif_segment</em> method instead, which forces the Segment to be present in the file, and returns its reference. The algorithm is the following: 1) if at least one Segment with this properties is already present, we are done; 2) if [1] fails, an \s-1APP1\s0 segment is added and initialised with a big-endian Exif structure (its position is chosen by find_new_app_segment_position, as usual). Note that there is no $index argument here.     my $ref = $file-&gt;provide_app1_Exif_segment();</p>
  </dd>
  <dt>
    JPEG::remove_app1_Exif_info
  </dt>
  <dd>
    <p>[arguments: \*(C`($index)\*(C'] If you want to eliminate the $index-th Exif \s-1APP1\s0 Segment from the \s-1JPEG\s0 file segment list use the <em>remove_app1_Exif_info</em> method. As usual, if $index is (-1), all Exif \s-1APP1\s0 Segments are affected at once; if $index is undefined, it defaults to -1, so both (-1) and undef cause all Exif \s-1APP1\s0 segments to be removed. Be aware that the file won't be a valid Exif file after this.     $file-&gt;remove_app1_Exif_info(-1);</p>
  </dd>

</dl>
<p><em>How to inspect your Exif data</em></p>
<dl class='dl-vertical'>
  <dt>
    JPEG::Segment::get_Exif_data
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::get_Exif_data
  </dt>
  <dd>
    <p>[arguments: \*(C`($what, $type)\*(C'] Once you have a Segment reference pointing to your favourite Exif Segment, you may want to have a look at the records it contains, by using the <em>get_Exif_data</em> method: it accepts two arguments (<em></em><strong>$what</strong><em></em> and <em></em><strong>$type</strong><em></em>) and returns the content of the \s-1APP1\s0 segment packed in various forms. Error conditions (invalid $what's and $type's) manifest themselves through an undefined return value. All Exif records are natively identified by numeric tags (keys), which can be \*(L"translated\*(R" into a human-readable form by using the Exif standard docs; only a few fields in the Exif \s-1APP1\s0 preamble (they are not Exif records) are always identified by this module by means of textual tags. The $type argument selects the output format for the record keys (tags):     * NUMERIC: record tags are native numeric keys     * TEXTUAL: record tags are human-readable (default) Of course, record values are never translated. If a numeric Exif tag is not known, a custom textual key is created with \*(L"Unknown_tag_\*(R" followed by its numerical value (this solves problems with non-standard tags). The subset of Exif tags returned by this method is determined by the value of $what, which can be one of:     $what          returned info                         returned type     ---------------------------------------------------------------------     ALL            (default) everything but THUMBNAIL    ref. to hash of hashes     IMAGE_DATA     a merge of IFD0_DATA and SUBIFD_DATA  ref. to flat hash     THUMB_DATA     this is an alias for IFD1_DATA        ref. to flat hash     THUMBNAIL      the actual (un)compressed thumbnail   ref. to scalar     ROOT_DATA      header records (TIFF and similar)     ref. to flat hash     IFD0_DATA      primary image TIFF tags               ref. to flat hash     SUBIFD_DATA    Exif private tags                     ref. to flat hash     MAKERNOTE_DATA MakerNote tags (if struct. is known)  ref. to flat hash     GPS_DATA       GPS data of the primary image         ref. to flat hash     INTEROP_DATA   interoperability data                 ref. to flat hash     IFD1_DATA      thumbnail-related TIFF tags           ref. to flat hash Setting $what equal to '\s-1ALL\s0' returns a reference to a hash of hashes, whose top-level hash contains the following keys: \s-1ROOT_DATA\s0, \s-1IFD0_DATA\s0, \s-1SUBIFD_DATA\s0, \s-1GPS_DATA\s0, \s-1INTEROP_DATA\s0, \s-1MAKERNOTE_DATA\s0 and \s-1IFD1_DATA\s0; each key corresponds to a second-level hash containing a copy of all Exif records present in the \s-1IFD\s0 (sub)directory corresponding to the key (if this directory is not present or contains no records, the second-level hash exists and is empty). Note that the Exif record values' format is not checked to be valid according to the Exif standard. This is, in some sense, consistent with the fact that also \*(L"unknown\*(R" tags are included in the output. This complicated structure is more easily explained by showing an example (see also the section about valid Exif tags for details on possible records):     my $hash_ref = $segment-&gt;get_Exif_data(&apos;ALL&apos;, &apos;TEXTUAL&apos;);</p><p>                         can give     $hash_ref = {            &apos;ROOT_DATA&apos; =&gt;                 { &apos;Signature&apos;               =&gt; [ 42             ],                   &apos;Endianness&apos;              =&gt; [ &apos;MM&apos;           ],                   &apos;Identifier&apos;              =&gt; [ "Exif&#92;000&#92;000" ],                   &apos;ThumbnailData&apos;           =&gt; [ ... image ...  ], },            &apos;IFD1_DATA&apos; =&gt;                 { &apos;ResolutionUnit&apos;          =&gt; [ 2              ],                   &apos;JPEGInterchangeFormatLength&apos; =&gt; [ 3922       ],                   &apos;JPEGInterchangeFormat&apos;   =&gt; [ 2204           ],                   &apos;Orientation&apos;             =&gt; [ 1              ],                   &apos;XResolution&apos;             =&gt; [ 72, 1          ],                   &apos;Compression&apos;             =&gt; [ 6              ],                   &apos;YResolution&apos;             =&gt; [ 72, 1          ], },            &apos;SubIFD_DATA&apos; =&gt;                 { &apos;ApertureValue&apos;           =&gt; [ 35, 10         ],                   &apos;PixelXDimension&apos;         =&gt; [ 2160           ],                     etc., etc. ....                   &apos;ExifVersion&apos;             =&gt; [ &apos;0210&apos;         ], },            &apos;MAKERNOTE_DATA&apos; =&gt; {},            &apos;IFD0_DATA&apos; =&gt;                 { &apos;Model&apos; =&gt; [ "KODAK DX3900 ZOOM DIGITAL CAMERA&#92;000" ],                   &apos;ResolutionUnit&apos;          =&gt; [ 2              ],                     etc., etc. ...                   &apos;YResolution&apos;             =&gt; [ 230, 1         ], },            &apos;GPS_DATA&apos; =&gt; {},            &apos;INTEROP_DATA&apos; =&gt;                 { &apos;InteroperabilityVersion&apos; =&gt; [ &apos;0100&apos;         ],                   &apos;InteroperabilityIndex&apos;   =&gt; [ "R98&#92;000"      ], }, }; Setting $what equal to '*_DATA' returns a reference to a flat hash, corresponding to one or more \s-1IFD\s0 (sub)dirs. For instance, '\s-1IMAGE_DATA\s0' is a merge of '\s-1IFD0_DATA\s0' and '\s-1SUBIFD_DATA\s0': this interface is simpler for the end-user, because there is only one dereference level; also, he/she does not need to be aware of the partition of records related to the main image into two IFDs. If the (sub)directory is not present or contains no records, the returned hash exists and is empty. With reference to the previous example:     my $hash_ref = $segment-&gt;get_Exif_data(&apos;IMAGE_DATA&apos;, &apos;TEXTUAL&apos;);</p><p>                         gives     $hash_ref = {            &apos;ResolutionUnit&apos;              =&gt; [ 2      ],            &apos;JPEGInterchangeFormatLength&apos; =&gt; [ 3922   ],            &apos;JPEGInterchangeFormat&apos;       =&gt; [ 2204   ],            &apos;Orientation&apos;                 =&gt; [ 1      ],            &apos;XResolution&apos;                 =&gt; [ 72, 1  ],            &apos;Compression&apos;                 =&gt; [ 6      ],            &apos;YResolution&apos;                 =&gt; [ 72, 1  ],            &apos;ApertureValue&apos;               =&gt; [ 35, 10 ],            &apos;PixelXDimension&apos;             =&gt; [ 2160   ],               etc., etc. ....            &apos;ExifVersion&apos;                 =&gt; [ &apos;0210&apos; ], }; Last, setting $what to '\s-1THUMBNAIL\s0' returns a reference to a copy of the actual Exif thumbnail image (this is not included in the set returned by '\s-1THUMB_DATA\s0'); if there is no thumbnail, a reference to the empty string is returned (the undefined value cannot be used, because it is assumed that it corresponds to an error condition here). Note that the pointed scalar may be quite large (~ 10^1 \s-1KB\s0). If the thumbnail is in \s-1JPEG\s0 format (this corresponds to the 'Compression' property, in \s-1IFD1\s0, set to 6), you can create another \s-1JPEG\s0 picture object from it, like in the following example:     my $data_ref = $segment-&gt;get_Exif_data(&apos;THUMBNAIL&apos;);     my $thumb = new Image::MetaData::JPEG($data_ref);     print $thumb-&gt;get_description(); If you are only interested in reading Exif data in a <em>standard</em> configuration, you can skip the segment-search calls and use directly <em>JPEG::get_Exif_data</em> (a method of the \s-1JPEG\s0 class, so you only need a \s-1JPEG\s0 structure object). This is an interface to the method with the same name in the Segment class, acting on the first Exif \s-1APP1\s0 Segment (if no such segment is present, the undefined value is returned) and passing the arguments through. Note that most \s-1JPEG\s0 files with Exif data contain at most one Exif \s-1APP1\s0 segment, so you are not going to loose anything here. A snippet of code for visualising Exif data looks like this:     while (my ($d, $h) = each %{$image-&gt;get_Exif_data(&apos;ALL&apos;)}) {       while (my ($t, $a) = each %$h) {         printf &apos;%-25s&#92;t%-25s&#92;t-&gt; &apos;, $d, $t;         s/([&#92;000-&#92;037&#92;177-&#92;377])/sprintf &apos;&#92;&#92;%02x&apos;,ord($1)/ge,         $_ = (length $_ &gt; 30) ? (substr($_,0,30) . &apos; ... &apos;) : $_,         printf &apos;%-5s&apos;, $_ for @$a; print "&#92;n"; } }</p>
  </dd>

</dl>
<p><em>How to modify your Exif data</em></p>
<dl class='dl-vertical'>
  <dt>
    JPEG::Segment::set_Exif_data
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::set_Exif_data
  </dt>
  <dd>
    <p>[arguments: \*(C`($data, $what, $action)\*(C'] Similarly to the getter case, there is a <em>set_Exif_data</em> method callable from a picture object, which does nothing more than looking for the first Exif \s-1APP1\s0 segment (creating it, if there is none) and invoke the method with the same name in the Segment class, passing its arguments through. So, the remaining of this section will concentrate on the Segment method. The problem of setting a new thumbnail or erasing it is dealt with in the last paragraphs of this section. (The \s-1APP1\s0 Exif structure is quite complicated, and the number of different possible cases when trying to modify it is very large; therefore, designing a clean and intuitive interface for this task is not trivial. Fell free to suggest improvements and cleaner interfaces). Exif records are usually characterised by a numeric key (a <em>tag</em>); this was already discussed in the \*(L"getter\*(R" section. Since these keys, for valid records, can be translated from numeric to textual form and back, the end user has the freedom to use whichever form better fits his needs. The two forms can even be mixed in the same \*(L"setter\*(R" call: the method will take care to translate textual tags to numeric tags when possible, and reject the others; then, it will proceed as if all tags were numeric from the very beginning. Records with unknown textual or numeric tags are always rejected. The arguments to <em>set_Exif_data</em> are $data, $what and $action. The <em></em><strong>$data</strong><em></em> argument must be a hash reference to a flat hash, containing the key - record values pairs supplied by the user. The \*(L"value\*(R" part of each hash element can be an array reference (containing a list of values for the record, remember that some records are multi-valued) or a single scalar (this is internally converted to a reference to an array containing only the supplied scalar). If a record value is supposed to be a null terminated string, the user can supply a Perl scalar without the final null character (it will be inserted automatically). The <em></em><strong>$what</strong><em></em> argument must be a scalar, and it selects the portion of the Exif \s-1APP1\s0 segment concerned by the <em>set_Exif_data</em> call. So, obviously, the end user can modify only one section at a time; this is a simplification (for the developer of course) but also for the end user, because trying to set all Exif-like values in one go would require an offensively complicated data structure to specify the destination of each record (note that some records in different sections can have the same numerical tag, so a plain hash would not trivially work). Valid values for $what are (MakerNote data are not currently modifiable):     $what         modifies ...                          $data type     --------------------------------------------------------------------     IMAGE_DATA    as IFD0_DATA and SUBIFD_DATA          ref. to flat hash     THUMB_DATA    this is an alias for IFD1_DATA        ref. to flat hash     THUMBNAIL     the actual (un)compressed thumbnail   ref. to scalar/object     ROOT_DATA     header records (endianness)           ref. to flat hash     IFD0_DATA     primary image TIFF tags               ref. to flat hash     SUBIFD_DATA   Exif private tags                     ref. to flat hash     GPS_DATA      GPS data of the primary image         ref. to flat hash     INTEROP_DATA  interoperability data in SubIFD       ref. to flat hash     IFD1_DATA     thumbnail-related TIFF tags           ref. to flat hash The <em></em><strong>$action</strong><em></em> argument controls whether the setter adds ($action = '\s-1ADD\s0') records to a given data directory or replaces ($action = '\s-1REPLACE\s0') them. In the first case, each user-supplied record replaces the existing version of that record if present, and simply inserts the record if it was not already present; however, existing records with no counterpart in the user supplied $data hash remain untouched. In the second case, the record directory is cleared before inserting user data. Note that, since Exif and Exif-like records are non-repeatable in nature, there is no need of an '\s-1UPDATE\s0' action, like for \s-1IPTC\s0 (see the \s-1IPTC\s0 section). The <em>set_Exif_data</em> routine first checks that the concerned segment is of the appropriate type (Exif \s-1APP1\s0), that $data is a hash reference (a scalar reference for the thumbnail), and that $action and $what are valid. If $action is undefined, it defaults to '\s-1REPLACE\s0'. Then, an appropriate (sub)IFD is created, if absent, and all user-supplied records are checked for consistency (have a look at the appendixes for this). Last, records are set in increasing (numerical) tag order, and mandatory data are added, if not present. The return value of the setter routine is always a hash reference; in general it contains records rejected by the specialised routines. If an error occurs in a very early stage of the setter, this reference contains a single entry with key='\s-1ERROR\s0' and value set to some meaningful error message. So, returning a reference to an empty hash means that everything was \s-1OK\s0. An example, concerning the much popular task of changing the DateTime record, follows:     $dt = &apos;1994:07:23 12:14:51&apos;;     $hash = $image-&gt;set_Exif_data({&apos;DateTime&apos; =&gt; $dt}, &apos;IMAGE_DATA&apos;, &apos;ADD&apos;);     print "DateTime record rejected&#92;n" if %$hash; Depending on $what, some of the following notes apply:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1ROOT_DATA\s0
  </dt>
  <dd>
    <p>The only modifiable item is the 'Endianness' (and it can only be set to big-endian, '\s-1MM\s0', or little-endian, '\s-1II\s0'); everything else is rejected (see the \s-1APP1\s0 structure for further details). This only influences how the image is written back to disk (the in-memory representation is always native).</p>
  </dd>
  <dt>
    \s-1IMAGE_DATA\s0
  </dt>
  <dd>
    <p>By specifying this target one can address the \s-1IFD0_DATA\s0 and \s-1SUBIFD_DATA\s0 targets at once. First, all records are tried in the \s-1IFD0\s0, then, rejected records are tried into SubIFD (then, they are definitively rejected).</p>
  </dd>
  <dt>
    \s-1IFD0_DATA\s0
  </dt>
  <dd>
    <p>See the canonical, additional and company-assigned tags' sections in the appendixes (this target refers to the primary image). The 'XResolution', 'YResolution', 'ResolutionUnit', and 'YCbCrPositioning' records are forced if not present (to [1,72], [1,72], 2 and 1 respectively). Note that the situation would be more complicated if we were dealing with uncompressed (\s-1TIFF\s0) primary images.</p>
  </dd>
  <dt>
    \s-1SUBIFD_DATA\s0
  </dt>
  <dd>
    <p>See the private Exif section in the appendixes. The 'ExifVersion', 'ComponentsConfiguration', 'FlashpixVersion', 'ColorSpace', and 'Pixel[\s-1XY\s0]Dimension' records are forced if not present (to '0220', '1230', '0100', 1 and 0x0 respectively). Image dimensions can be retrieved from the \s-1SOF\s0 segment with the \s-1JPEG\s0 structure object's method <em>get_dimensions()</em> and set explicitly by the user if necessary (this cannot be done from within the \s-1APP1\s0 segment, because it does not link back to its parent); however, the horizontal field in the SubIFD should not include data padding, while that in the \s-1SOF\s0 segment does, so the meaning is slightly different and these fields cannot be automatically calculated.</p>
  </dd>
  <dt>
    \s-1THUMB_DATA\s0 (or its alias <strong>\s-1IFD1_DATA\s0</strong>)
  </dt>
  <dd>
    <p>See the canonical, additional and company-related tag lists' sections in the appendixes (this target refers to thumbnail properties). The 'XResolution', 'YResolution', 'ResolutionUnit', 'YCbCrSubSampling', 'PhotometricInterpretation' and 'PlanarConfiguration' records are forced if not present (to [1,72], [1,72], 2, [2,1], 2 and 1 respectively). Note that some of these records are not necessary for all types of thumbnails, but \s-1JPEG\s0 readers will probably skip unnecessary information without problems.</p>
  </dd>
  <dt>
    \s-1GPS_DATA\s0
  </dt>
  <dd>
    <p>See the \s-1GPS\s0 tags section in the appendixes. The 'GPSVersionID' record is forced, if it is not present at the end of the process, because it is mandatory (ver 2.2 is chosen).  There are some record inter-correlations which are still neglected here (for instance, the 'GPSAltitude' record can be inserted without providing the corresponding 'GPSAltitudeRef' record).</p>
  </dd>
  <dt>
    \s-1INTEROP_DATA\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    JPEG::forge_interoperability_IFD
  </dt>
  <dd>
    <p>[arguments: none] See the Interoperability directory section in the appendixes. The 'InteroperabilityIndex' and 'InteroperabilityVersion' records are forced, if they are not present at the end of the process, because they are mandatory ('R98' and ver 1.0 are chosen). Note that an Interoperability subIFD should be made as standard as possible: if you just want to add it to the file, it is better to use the <em>forge_interoperability_IFD</em> method, which takes care of all values ('RelatedImageFileFormat' is set to 'Exif \s-1JPEG\s0 Ver. 2.2', and the dimensions are taken from <em></em><em>get_dimensions()</em><em></em>).</p>
  </dd>
  <dt>
    \s-1MAKERNOTE_DATA\s0
  </dt>
  <dd>
    <p>See the appendix on MakerNotes for a detailed discussion on how the content of a MakerNote is managed. If there is an error during the parsing of the MakerNote, only those tags which could be fully decoded before the error are returned. Note that MakerNote structures are often partially known, so many tags will likely be translated as 'Unknown_tag_...'. MakerNotes cannot be currently modified.</p>
  </dd>
  <dt>
    \s-1THUMBNAIL\s0
  </dt>
  <dd>
    <p>$data must be a reference to a scalar containing the new thumbnail or to a valid Image::MetaData::JPEG object; if it points to an empty string, the thumbnail is erased (the undefined value \s-1DOES\s0 \s-1NOT\s0 erase the thumbnail, it generates instead an error). All thumbnail specific records (see the canonical tags section) are removed, and only those corresponding to the newly inserted thumbnail are calculated and written back. Currently, it is not possible to insert an uncompressed thumbnail (this will probably happen in the form of a \s-1TIFF\s0 image), only \s-1JPEG\s0 ones are accepted (automatic records contain the type, length and offset). The following code shows how to set and delete a thumbnail.     my $image = new Image::MetaData::JPEG(&apos;original_image.jpg&apos;);     my $thumb = new Image::MetaData::JPEG(&apos;some_thumbnail.jpg&apos;);     $image-&gt;set_Exif_data($thumb, &apos;THUMBNAIL&apos;);     $image-&gt;save(&apos;modified_image.jpg&apos;);     $image-&gt;set_Exif_data(&#92; &apos;&apos;, &apos;THUMBNAIL&apos;);     $image-&gt;save(&apos;thumbless_image.jpg&apos;);</p>
  </dd>

</dl>
<p>\s-1XMP\s0 (eXtensible Metadata Platform) is a technology, conceived by Adobe Systems, to tag graphic files with metadata, and to manage them during a lifetime made of multiple processing steps. Its serialisation (the actual way metadata are saved in the file) is based on \s-1RDF\s0 (Resource Description Framework) implemented as an application of \s-1XML\s0. Its flexibility allows to accomodate existing, future and private metadata schemas. In a \s-1JPEG\s0 file, \s-1XMP\s0 information is included alongside Exif and \s-1IPTC\s0 data, and is stored in an \s-1APP1\s0 segment on its own starting with the \s-1XMP\s0 namespace \s-1URI\s0 and followed by the actual \s-1XMP\s0 packet (see \s-1XMP\s0 \s-1APP1\s0 segment structure for more details).</p>
  </dd>

</dl>
<p>\s-1XMP\s0 was introduced in 2001 as part of Adobe Acrobat version 5.01. Adobe has a trademark on \s-1XMP\s0, and retains control over its specification. Source code for the \s-1XMP\s0 software-development kit was released by Adobe, but with a custom license, whose compatibility with the \s-1GNU\s0 public license and open-source nature altogether is questioned. Adobe's Photoshop program, a de-facto standard for image manipulation, has, since long, used the \s-1APP13\s0 segment for storing non-graphical information, such as layers, paths, ecc..., including editorial information modelled on <em>\s-1IPTC/NAA\s0</em> recommendations. This module provides a number of methods for managing Photoshop/IPTC data without dealing with the details of the low level representation (although sometimes this means taking some decisions for the end user ....). The structure of the \s-1IPTC\s0 data block(s) is managed in detail and separately from the rest, although this block is a sort of \*(L"sub-case\*(R" of Photoshop information. The interface is intentionally similar to that for Exif data.</p><p>All public methods have a <em></em><strong>$what</strong><em></em> argument selecting which part of the \s-1APP13\s0 segment you are working with. The default is '\s-1IPTC\s0'. If $what is invalid, an exception is always raised. The kind of information you can access with different values of $what is explained in the following (have a look at the appendices about valid Photoshop-style and \s-1IPTC\s0 tags for further details):</p><p>    $what:        Concerned pieces of information:     -----------   --------------------------------     &apos;IPTC&apos; or     Editorial information like caption, abstract, author,     &apos;IPTC_2&apos;      copyright notice, byline, shot site, user defined keywords,                   and many more; in practise, all what is covered by the IPTC                   Application Record 2. This is the most common option; the                   default value of $what, &apos;IPTC&apos;, is a synonym for &apos;IPTC_2&apos;                   for backward compatibility (NOT a merge of &apos;IPTC_1/2&apos;).     &apos;IPTC_1&apos;      This refers to more obscure pieces of information, contained                   in the IPTC Envelope Record 1. One is rarely interested by                   this, exception made for the "Coded Character Set" tag,                   which is necessary to define a character set different                   from ASCII (i.e., when you don&apos;t write or read in English).     &apos;PHOTOSHOP&apos;   Alpha channels, colour information, transfer functions,     or &apos;PS_8BIM&apos;  and many other details concerning the visual rendering of     or &apos;PS_8BPS&apos;  the picture. These fields are most often only modified by     or &apos;PS_PHUT&apos;  an image manipulation program, and not directly by the user.                   Recent versions of Photoshop (&gt;= 4.0) use a resource data                   block type equal to &apos;8BIM&apos;, and this is the default in                   this module (so, &apos;PHOTOSHOP&apos; and &apos;PS_8BIM&apos; are synonyms).                   However, some other older or undocumented resource data                   block types are also allowed.</p>
<dl class='dl-vertical'>
  <dt>
    JPEG::retrieve_app13_segment
  </dt>
  <dd>
    <p>[arguments: \*(C`($index, $what)\*(C'] In order to work on Photoshop/IPTC data, a suitable Photoshop-style \s-1APP13\s0 Segment must first be selected. The <em>retrieve_app13_segment</em> method returns a reference to the <em></em><strong>$index</strong><em></em>-th Segment (the first Segment if the $index is undefined) which contains information matching the $what argument. If such Segment does not exist, the method returns the undefined reference. If $index is (-1), the routine returns the number of available suitable \s-1APP13\s0 Segments (which is non negative). Beware, the meaning of $index is influenced by the value of $what.     my $num_IPTC = $file-&gt;retrieve_app13_segment(-1, &apos;IPTC&apos;);     my $ref_IPTC = $file-&gt;retrieve_app13_segment($num - 1, &apos;IPTC&apos;);</p>
  </dd>
  <dt>
    JPEG::provide_app13_segment
  </dt>
  <dd>
    <p>[arguments: \*(C`($what)\*(C'] If you want to be sure to have an \s-1APP13\s0 Segment suitable for the kind of information you want to write, use the <em>provide_app13_segment</em> method instead, which forces the Segment to be present in the file, and returns its reference. If at least one segment matching $what is already present, the first one is returned. Otherwise, the first Photoshop-like \s-1APP13\s0 is adapted by inserting an appropriate subdirectory record (update is called automatically). If no such segment exists, it is first created and inserted (the \*(L"Photoshop 3.0&#92;000\*(R" identifier is used). Note that there is no $index argument here.     my $ref_Photoshop = $file-&gt;provide_app13_segment(&apos;PHOTOSHOP&apos;);</p>
  </dd>
  <dt>
    JPEG::remove_app13_info
  </dt>
  <dd>
    <p>[arguments: \*(C`($index, $what)\*(C'] If you want to remove all traces of some flavour of \s-1APP13\s0 information from the $index-th \s-1APP13\s0 Photoshop-style Segment, use the <em>remove_app13_info</em> method with $what set to the appropriate value. If, after this, the segment is empty, it is eliminated from the list of segments in the file. If $index is (-1), all \s-1APP13\s0 Segments are affected at once. Beware, the meaning of $index is influenced by the value of $what.     $file-&gt;remove_app13_info(3, &apos;PHOTOSHOP&apos;);     $file-&gt;remove_app13_info(-1, &apos;IPTC&apos;);     $file-&gt;remove_app13_info(0, &apos;IPTC_1&apos;);</p>
  </dd>

</dl>
<p><em>How to inspect and modify your \s-1IPTC\s0 data</em></p>
<dl class='dl-vertical'>
  <dt>
    JPEG::Segment::get_app13_data
  </dt>
  <dd>
    <p>[arguments: \*(C`($type, $what)\*(C'] Once you have a Segment reference pointing to your favourite IPTC-enabled \s-1APP13\s0 Segment, you may want to have a look at the records it contains. Use the <em>get_app13_data</em> method for this: its behaviour is controlled by the <em></em><strong>$type</strong><em></em> and <em></em><strong>$what</strong><em></em> argument (here, $what is '\s-1IPTC_1\s0' or '\s-1IPTC_2\s0' alias '\s-1IPTC\s0', of course). It returns a reference to a hash containing a copy of the list of the appropriate \s-1IPTC\s0 records, if present, undef otherwise: each element of the hash is a pair (key, arrayref), where arrayref points to an array with the real values (some \s-1IPTC\s0 records are repeatable so multiple values are possible). The record keys can be the native numeric keys ($type eq '\s-1NUMERIC\s0') or translated textual keys ($type eq '\s-1TEXTUAL\s0', default); in any case, the record values are untranslated. If a numeric key stored in the \s-1JPEG\s0 file is unknown, and a textual translation is requested, the name of the key becomes \*(L"Unknown_tag_$tag\*(R". Note that there is no check on the validity of \s-1IPTC\s0 records' values: their format is not checked and one or multiple values can be attached to a single tag independently of its repeatability. This is, in some sense, consistent with the fact that also \*(L"unknown\*(R" tags are included in the output. If $type or $what is invalid, an exception is thrown out. An example of how to extract and display \s-1IPTC\s0 data is given here:     my $hash_ref = $segment-&gt;get_app13_data(&apos;TEXTUAL&apos;, &apos;IPTC&apos;);     while (my ($key, $vals) = each %$hash_ref) {        printf "# %20s =", $key; print " &apos;$_&apos;" for @$vals; print "&#92;n"; }</p><p>    ### This could print:     # DateCreated         = &apos;19890207&apos;     # ByLine              = &apos;Interesting picture&apos; &apos;really&apos;     # Category            = &apos;POL&apos;     # Keywords            = &apos;key-1&apos; &apos;key-2&apos; &apos;key-99&apos;     # OriginatingProgram  = &apos;Mapivi&apos;</p>
  </dd>
  <dt>
    JPEG::Segment::set_app13_data
  </dt>
  <dd>
    <p>[arguments: \*(C`($data, $action, $what)\*(C'] The hash returned by get_app13_data can be edited and reinserted with the <em>set_app13_data</em> method, whose arguments are <em></em><strong>$data</strong><em></em>, <em></em><strong>$action</strong><em></em> and, as usual, <em></em><strong>$what</strong><em></em>. If $action or $what is invalid, an exception is generated. This method accepts \s-1IPTC\s0 data in various formats and updates the corresponding subdirectory in the segment. The key type of each entry in the input hash can be numeric or textual, independently of the others (the same key can appear in both forms, the corresponding values will be put together). The value of each entry can be an array reference or a scalar (you can use this as a shortcut for value arrays with only one value). The $action argument can be:    - ADD : new records are added and nothing is deleted; however, if you            try to add a non-repeatable record which is already present,            the newly supplied value ejects (replaces) the pre-existing value.    - UPDATE : new records replace those characterised by the same tags,            but the others are preserved. This makes it possible to modify            some repeatable IPTC records without deleting the other tags.    - REPLACE : all records present in the IPTC subdirectory are deleted            before inserting the new ones (this is the default action). If, after implementing the changes required by $action, any mandatory dataset (according to the \s-1IPTC\s0 standard), is still undefined, it is added automatically. This often concerns version datasets, with numeric index 0. The return value is a reference to a hash containing the rejected key-values entries. The entries of %$data are not modified. An entry in the %$data hash can be rejected for various reasons (you might want to have a look at appendix about valid \s-1IPTC\s0 tags for further information): a) the tag is undefined or not known; b) the entry value is undefined or points to an empty array; c) the non-repeatability constraint is violated; d) the tag is marked as invalid; e) a value is undefined f) the length of a value is invalid; g) a value does not match its mandatory regular expression.     $segment-&gt;set_app13_data($additional_data, &apos;ADD&apos;, &apos;IPTC&apos;); A snippet of code for changing \s-1IPTC\s0 data looks like this:     my $segment = $file-&gt;provide_app13_segment(&apos;IPTC&apos;);     my $hashref_1 = { CodedCharacterSet =&gt; "&#92;033&#92;045G" }; # UTF-8     my $hashref_2 = { ObjectName =&gt; &apos;prova&apos;,                       ByLine     =&gt; &apos;ciao&apos;,                       Keywords   =&gt; [ &apos;donald&apos;, &apos;duck&apos; ],                       SupplementalCategory =&gt; [&apos;arte&apos;, &apos;scienza&apos;, &apos;diporto&apos;] };     $segment-&gt;set_app13_data($hashref_2, &apos;REPLACE&apos;, &apos;IPTC&apos;);     $segment-&gt;provide_app13_subdir(&apos;IPTC_1&apos;);     $segment-&gt;set_app13_data($hashref_1, &apos;ADD&apos;, &apos;IPTC_1&apos;);</p>
  </dd>
  <dt>
    JPEG::get_app13_data
  </dt>
  <dd>
    <p>[arguments: \*(C`($type, $what)\*(C'] If you are only interested in reading \s-1IPTC\s0 data in a <em>standard</em> configuration, you can skip most of the previous calls and use directly <em>JPEG::get_app13_data</em> (a method in the \s-1JPEG\s0 class, so you only need a \s-1JPEG\s0 structure object). This is an interface to the method with the same name in the Segment class, acting on the first relevant \s-1APP13\s0 Segment (if no such segment is present, the undefined value is returned) and passing the arguments through. Note that most \s-1JPEG\s0 files with Photoshop/IPTC data contain at most one \s-1APP13\s0 segment, so you are not going to \*(L"loose\*(R" anything here. A snippet of code for visualising \s-1IPTC\s0 data looks like this:     my $hashref = $file-&gt;get_app13_data(&apos;TEXTUAL&apos;, &apos;IPTC&apos;);     while (my ($tag, $val_arrayref) = each %$hashref) {         printf &apos;%25s --&gt; &apos;, $tag;         print "$_ " for @$val_arrayref; print "&#92;n"; }</p>
  </dd>
  <dt>
    JPEG::set_app13_data
  </dt>
  <dd>
    <p>[arguments: \*(C`($data, $action, $what)\*(C'] There is, of course, a symmetric <em>JPEG::set_app13_data</em> method, which writes data to the \s-1JPEG\s0 object without asking the user to bother about Segments: it uses the first available suitable Segment; if this is not possible, a new Segment is created and initialised (because the method uses \*(L"JPEG::provide_app13_segment\*(R" internally, and not \*(L"JPEG::retrieve_app13_segment\*(R" as \*(L"JPEG::get_app13_data\*(R" does).     $file-&gt;set_app13_data($hashref, &apos;UPDATE&apos;, &apos;IPTC&apos;);</p>
  </dd>

</dl>
<p><em>How to inspect and modify your Photoshop data</em></p><p>The procedure of inspecting and modifying Photoshop data (i.e., non-IPTC data in a Photoshop-style \s-1APP13\s0 segment) is analogous to that for \s-1IPTC\s0 data, but with <em></em><strong>$what</strong><em></em> set to '\s-1PHOTOSHOP\s0' (alias '\s-1PS_8BIM\s0'), or to the seldom used '\s-1PS_8BPS\s0' and '\s-1PS_PHUT\s0'. The whole description will not be repeated here, have a look at the \s-1IPTC\s0 section for it: this section takes only care to point out differences. If you are not acquainted with the structure of an \s-1APP13\s0 segment and its terminology (e.g., \*(L"resource data block\*(R"), have a look at the Photoshop-style tags' section.</p><p>About get_app13_data, it should only be pointed out that resource block names are appended to the list of values for each tag (even if they are undefined), so the list length is alway even. Things are more complicated for set_app13_data: non-IPTC Photoshop specifications are less uniform than \s-1IPTC\s0 ones, and checking the correctness of user supplied data would be an enumerative task. Currently, this module does not perform any syntax check on non-IPTC data, but this could change in the future (any contribution is welcome); only tags (or, how they are called in this case, \*(L"resource block identifiers\*(R") are checked for being in the allowed tags list (see the Photoshop-style tags' table for details). The \s-1IPTC/NAA\s0 tag is of course rejected: \s-1IPTC\s0 data must be inserted with $what set to '\s-1IPTC\s0' or its siblings.</p><p>Although not explicitly stated, it seems that non-IPTC Photoshop tags are non-repeatable (let me know if not so), so two resource blocks with the same tag shouldn't exist. For this reason, the '\s-1UPDATE\s0' action is changed internally to '\s-1ADD\s0'. Moreover, since the resource block structure is not explored, all resource blocks are treated as single-valued and the value type is $UNDEF. So, in the user-supplied data hash, if a tag key returns a data array reference, only the first element (which cannot be undefined) of the array is used as resource block value: if a second element is present, it is used as resource block name (which is otherwise set to the null string). Suppling more than two elements is an error and causes the record to be rejected.</p><p>    my $segment = $file-&gt;provide_app13_segment(&apos;PHOTOSHOP&apos;);     my $hashref = {         GlobalAngle    =&gt; pack(&apos;N&apos;, 0x1e),         GlobalAltitude =&gt; pack(&apos;N&apos;, 0x1e),         CopyrightFlag  =&gt; "&#92;001",         IDsBaseValue   =&gt; [ pack(&apos;N&apos;, 1), &apos;Layer ID Generator Base&apos; ] };     $segment-&gt;set_app13_data($hashref, &apos;ADD&apos;, &apos;PHOTOSHOP&apos;);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<h3>On the subject of year specification in a date</h3>
<p>There are currently eight fields whose purpose is to store a <em>date</em> in a \s-1JPEG\s0 picture, namely 'DateTime', 'DateTimeOriginal' and 'DateTimeDigitized' (in \s-1IFD0/1\s0 or SubIFD), 'GPSDateStamp' (in the \s-1GPS\s0 section), and 'ReleaseDate', 'ExpirationDate', 'DateCreated' and 'DigitalCreationDate' (in the \s-1IPTC\s0 section). Most of these dates refer to some electronic treatment of images, a kind of process which was not available before the late twentieth century. Two of them refer to release and expiration dates in the \s-1IPTC\s0 standard, and should therefore not be set to a date before the introduction of the standard itself. However, there exist users who want to use some of these fields in a non-conventional way to refer to dates when analog photography but not digital photography was available. For this reason, all tags (but one) can be written with a year starting from 1800 (and not from 1900 as in earlier releases). Users are however advised to check the \*(L"specifications\*(R" for these tags before setting the date and take responsibility for their non-conventionality.</p><p>There is one notable exception to the previous considerations, that is the \s-1IPTC\s0 'DateCreated' dataset, which should explicitly refer to the creation date of the object represented in the picture, which can be many centuries in the past. For this dataset a special regular expression is provided which allows a date in the full \s-1ISO-8601\s0 YYYY-MM-DD format (however, it should be noted that even \s-1ISO-8601\s0 does not allow a date before 0AD, so not all masterworks from ancient Greece can be tagged in this way ... let me know if I am wrong). I am, of course, still open to suggestions and reconsiderations on this subject.</p>
<h3>On the problem of MakerNote corruption and ways to overcome it</h3>
<p>A widespread problem with Exif <em>maker notes</em> is that there is no common standard for how to parse and rewrite the information in the <em>MakerNote</em> data area. This is the reason why most programs dealing with Exif \s-1JPEG\s0 files corrupt the MakerNote on saving, or decide to drop it altogether (be aware that there existed programs known to hang when they try to read a corrupt maker note).</p><p>In fact, many maker notes contain a non-standard <em>\s-1IFD\s0</em> structure, with some tags storing file offsets (see the documentation page describing the \s-1IFD\s0 structure). Therefore, saving a maker note without regard for internal offsets' adjustment reduces the note mostly to garbage. Re-dumping a maker note after changing the Exif \s-1APP1\s0 segment endianness incurs the same problem, because no internal byte-swap is performed.</p><p>A few countermeasures have been introduced in this package to try to cure some maker note problems. The first one concerns the correct byte order (the endianness, which is not always the same used in the Exif segment), which needs not to be known in advance; it is in fact determined by using the fact that, if the note is IFD-like (even non-standard), the number of tags is always in the range [1,255], so the two-bytes tag count has always the most significant byte set to zero, and the least significant byte set to non-zero.</p><p>There is also a prediction and correction mechanism for the offsets in the interoperability arrays, based on the simple assumption that the absolute value of offsets can be wrong, but their differences are always right, so, if one can get the first one right ... a good bet is the address of the byte immediately following the next_IFD link (or the tag list, if this link is absent). If the parsing process does not end successfully, this mechanism is enabled and its \*(L"corrected\*(R" findings are stored instead of the original ones if it is able to cure the problems (i.e., if the second try at parsing the note is successful).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CURRENT STATUS</h2>
        <div class="sectioncontent">
<p>A lot of other routines for modifying other meta-data could be added in the future. The following is a list of the current status of various meta-data Segments (only \s-1APP\s0 and \s-1COM\s0 Segments).</p><p>    Segment  Possible content           Status</p><p>    * COM    User comments              parse/read/write     * APP0   JFIF data (+ thumbnail)    parse/read     * APP1   Exif or XMP data           parse/read[Exif]/write[Exif]     * APP1   Maker notes                parse/read     * APP2   FPXR data or ICC profiles  parse     * APP3   additional Exif-like data  parse     * APP4   HPSC                       nothing     * APP12  PreExif ASCII meta         parse     * APP13  IPTC and PhotoShop data    parse/read/write     * APP14  Adobe tags                 parse</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KNOWN BUGS</h2>
        <div class="sectioncontent">
<p><em>\s-1USE\s0 \s-1WITH\s0 \s-1CAUTION\s0! \s-1THIS\s0 \s-1IS\s0 \s-1EXPERIMENTAL\s0 \s-1SOFTWARE\s0!</em></p><p>This module is still <em>experimental</em>, and not yet finished. In particular, it is far from being well tested, and some interfaces could change depending on user feedback. The ability to modify <em>maker notes</em> is not yet implemented (moreover, have a look at the MakerNote appendix for a general note on the problem of MakerNote corruption). \s-1APP13\s0 data spanning <em>multiple Segments</em> are not correctly read/written. Most of \s-1APP12\s0 Segments do not fit the structure parsed by <em>parse_app12()</em>, probably there is some standard I don't know.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER PACKAGES</h2>
        <div class="sectioncontent">
<p>Other packages are available in the free software arena, with a feature set showing a large overlap with that found in this package; a probably incomplete list follows. However, none of them is (or was) completely satisfactory with respect to the package's objectives, which are: being a single package dealing with all types of meta-information in read/write mode in a \s-1JPEG\s0 (and possibly \s-1TIFF\s0) file; depending on the least possible number of non standard packages and/or external programs or libraries; being open-source and written in Perl. Of course, most of these objectives are far from being reached .... <em>ExifTool</em> is a Perl module with an included command-line application for reading and writing meta information in image files. It recognizes \s-1EXIF\s0, \s-1GPS\s0, \s-1IPTC\s0, \s-1XMP\s0, \s-1JFIF\s0, GeoTIFF, \s-1ICC\s0 Profile, Photoshop \s-1IRB\s0 and \s-1ID3\s0 meta information as well as the maker notes of many digital cameras including Canon, Casio, FujiFilm, Kodak, Leaf, Minolta/Konica-Minolta, Nikon, Olympus/Epson, Panasonic/Leica, Pentax/Asahi, Ricoh, Sanyo and Sigma/Foveon. It was started as a highly customisable, read-only report tool, capable of organising the results in various ways. Since version 4.10 (beginning of 2005) it added the ability to modify and rewrite \s-1JPEG\s0 tags. So sad there are now two projects with such a large overlap. This is a \s-1CPAN\s0 module for for extracting \s-1IPTC\s0 image meta-data. It allows reading \s-1IPTC\s0 data (there is an \s-1XML\s0 and also an \s-1HTML\s0 output feature) and manipulating them through native Perl structures. This library does not implement a full parsing of the \s-1JPEG\s0 file, so I did not consider it as a good base for the development of a full-featured module. Moreover, I don't like the separate treatment of keywords and supplemental categories. <em>\s-1JPEG::JFIF\s0</em> is a very small \s-1CPAN\s0 module for reading meta-data in \s-1JFIF/JPEG\s0 format files. In practice, it only recognises a subset of the \s-1IPTC\s0 tags in \s-1APP13\s0, and the parsing code is not suitable for being reused for a generic \s-1JPEG\s0 segment. <em>Image::Exif</em> is just a Perl wrapper around <em>exiftags</em>, which is a program parsing the \s-1APP1\s0 section in \s-1JPEG\s0 files for Exif meta-data (it supports a variety of MakerNotes). <em>exiftags</em> can also rewrite comments and date and time tags. This \s-1CPAN\s0 module extracts meta information from a variety of graphic formats (including \s-1JPEG\s0 and \s-1TIFF\s0). So, it is not specifically about \s-1JPEG\s0 segments: reported information includes media type, extension, width, height, colour type, comments, Interlace, Compression, Gamma, and LastModificationTime. For \s-1JPEG\s0 files, it additionally reports from \s-1JFIF\s0 (\s-1APP0\s0) and Exif (\s-1APP1\s0) segments (including MakerNotes). This module does not allow for editing. These are two basic scripts to extract Exif information from JPEGs. The first script is written in Perl and targets Canon pictures. The second one is written in Python, and it only works on \s-1JPEG\s0 files beginning with an \s-1APP1\s0 section after the \s-1SOI\s0. So, they are much simpler than all other programs/libraries described here. Of course, they cannot modify Exif data. The jhead program (written in C) is used to display \s-1JPEG\s0 comments and Exif data, and to perform limited manipulation of Exif headers (such as changing the internal time-stamps, removing the thumbnail, or transferring headers back into edited images) and comments. Exif header data modification is very limited, as jhead's internal implementation of the file system contained in the Exif header is read-only; there, for instance, no way to replace the thumbnail in the Exif header with another. This is a C program which examines and reports the contents and structure of \s-1JPEG\s0 and \s-1TIFF\s0 image files. It recognises all standard \s-1JPEG\s0 markers and reports the contents of any properly structured \s-1TIFF\s0 \s-1IFD\s0 encountered, even when entry tags are not recognised. Camera MakerNotes are included. \s-1GPS\s0 and GeoTIFF tags are recognised and entries printed in \*(L"raw\*(R" form, but are not expanded. The output is nicely formatted, with indentation and colouration; this program is a great tool for inspecting a \s-1JPEG/TIFF\s0 structure while debugging. This is a library, written in C, for parsing, editing, and saving Exif data. All Exif tags described in Exif standard 2.1 are supported. Libexif can only handle some maker notes, and even those not very well. It is used by a number of front-ends, including: Exif (read-only command-line utility), gexif (a \s-1GTK+\s0 front-end for editing Exif data), gphoto2 (command-line front-end to libgphoto2, a library to access digital cameras), gtkam (a \s-1GTK+\s0 front-end to libgphoto2), thirdeye (a digital photos organiser and driver for eComStation). This is a Java application for manipulating (read/write) \s-1RDF\s0 meta-data in the comment sections of \s-1JPEG\s0 images (is this the same thing which can be found in \s-1APP1\s0 segments in \s-1XMP\s0 format?). It can also access and convert into \s-1RDF\s0 the Exif tags and a few other general properties. However, I don't want to rely on a Java environment being installed in order to be able to access these properties. This is an object-oriented interface written in \*(C+ to Exif formatted \s-1JPEG\s0 image files. It is very complete and sponsored by a large company, so it is to be considered a sort of reference. The toolkit allows creating, reading, and modifying the meta-data in the Exif file. It also provides means of getting and setting the main image and the thumbnail image. OpenExif is also extensible, and Application segments can be added.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Stefano Bettelli, <strong>bettelli@cpan.org</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2004,2005,2006 by Stefano Bettelli</p><p>This library is free software; you can redistribute it and/or modify it under the terms of the \s-1GNU\s0 General Public License. See the \s-1COPYING\s0 and \s-1LICENSE\s0 file for the license terms.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Image::MetaData::JPEG&hellip;</h2>
        <div class="sectioncontent">
<p>Have a look at the technical appendixes of the <em>Image::MetaData::JPEG</em> module [<em>M</em> in the following], packaged as separate documents: they contain a description of segment structures [<em>M::Structures</em>], and lists of valid tags [<em>M::TagLists</em>], including a tentative description of some MakerNote formats [M::MakerNotes]. See also your current <em>perl</em>\|(1) documentation, an explanation for the General Public License and the manual pages of the following optional Perl modules: <em>Image::ExifTool</em>\|(3pm), <em>Image::IPTCInfo</em>\|(3pm), \s-1<em>JPEG::JFIF\s0</em>\|(3pm), <em>Image::EXIF</em>\|(3pm) and <em>Image::Info</em>\|(3pm).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Image::Math::Constrain.3pm.html"><span aria-hidden="true">&larr;</span> Image::Math::Constrain.3pm: Scaling math used in image size constraining (such as thumbnails)</a></li>
   <li class="next"><a href="Image::MetaData::JPEG::MakerNotes.3pm.html">Image::MetaData::JPEG::MakerNotes.3pm: This document contains random information and details on makernotes; it is an appendix to the main manual page of the image::metadata::jpeg module, which the reader should refer to for further details and the general scope. the note on makernote parsing in the main manual page is of particular interest. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

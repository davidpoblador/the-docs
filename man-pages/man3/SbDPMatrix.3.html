<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SbDPMatrix: The sbdpmatrix class is a 4x4 dimensional representation of a double-precision matrix.  this class is like the sbmatrix class, but uses double-precision floating point values for its elements. for more class documentation, see sbmatrix.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sbdpmatrix class is a 4x4 dimensional representation of a double-precision matrix.  this class is like the sbmatrix class, but uses double-precision floating point values for its elements. for more class documentation, see sbmatrix.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SbDPMatrix (3) manual">
  <meta name="twitter:description" content="The sbdpmatrix class is a 4x4 dimensional representation of a double-precision matrix.  this class is like the sbmatrix class, but uses double-precision floating point values for its elements. for more class documentation, see sbmatrix.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SbDPMatrix-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SbDPMatrix.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SbDPMatrix (3) manual" />
  <meta property="og:description" content="The sbdpmatrix class is a 4x4 dimensional representation of a double-precision matrix.  this class is like the sbmatrix class, but uses double-precision floating point values for its elements. for more class documentation, see sbmatrix." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SbDPMatrix-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SbDPMatrix<small> (3)</small></h1>
        <p class="lead">The sbdpmatrix class is a 4x4 dimensional representation of a double-precision matrix.  this class is like the sbmatrix class, but uses double-precision floating point values for its elements. for more class documentation, see sbmatrix.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SbDPMatrix.3.html">
      <span itemprop="name">SbDPMatrix: The sbdpmatrix class is a 4x4 dimensional representation of a double-precision matrix.  this class is like the sbmatrix class, but uses double-precision floating point values for its elements. for more class documentation, see sbmatrix.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SbDPMatrix.3.html">
      <span itemprop="name">SbDPMatrix: The sbdpmatrix class is a 4x4 dimensional representation of a double-precision matrix.  this class is like the sbmatrix class, but uses double-precision floating point values for its elements. for more class documentation, see sbmatrix.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SbDPMatrix.h&gt;</p><h3>Public Member Functions</h3>
<p><strong>SbDPMatrix</strong> (void)</p><p><strong>SbDPMatrix</strong> (const double a11, const double a12, const double a13, const double a14, const double a21, const double a22, const double a23, const double a24, const double a31, const double a32, const double a33, const double a34, const double a41, const double a42, const double a43, const double a44)</p><p><strong>SbDPMatrix</strong> (const SbDPMat &matrix)</p><p><strong>SbDPMatrix</strong> (const SbDPMat *matrix)</p><p><strong>SbDPMatrix</strong> (const <strong>SbMatrix</strong> &matrix)</p><p><strong>~SbDPMatrix</strong> (void)</p><p>void <strong>setValue</strong> (const SbDPMat &m)</p><p>void <strong>setValue</strong> (const <strong>SbMatrix</strong> &m)</p><p>void <strong>setValue</strong> (const double *pMat)</p><p>const SbDPMat & <strong>getValue</strong> (void) const </p><p>void <strong>makeIdentity</strong> (void)</p><p>void <strong>setRotate</strong> (const <strong>SbDPRotation</strong> &q)</p><p><strong>SbDPMatrix</strong> <strong>inverse</strong> (void) const </p><p>double <strong>det3</strong> (int r1, int r2, int r3, int c1, int c2, int c3) const </p><p>double <strong>det3</strong> (void) const </p><p>double <strong>det4</strong> (void) const </p><p>SbBool <strong>equals</strong> (const <strong>SbDPMatrix</strong> &m, double tolerance) const </p><p>void <strong>getValue</strong> (SbDPMat &m) const </p><p>void <strong>setScale</strong> (const double s)</p><p>void <strong>setScale</strong> (const <strong>SbVec3d</strong> &s)</p><p>void <strong>setTranslate</strong> (const <strong>SbVec3d</strong> &t)</p><p>void <strong>setTransform</strong> (const <strong>SbVec3d</strong> &t, const <strong>SbDPRotation</strong> &r, const <strong>SbVec3d</strong> &s)</p><p>void <strong>setTransform</strong> (const <strong>SbVec3d</strong> &t, const <strong>SbDPRotation</strong> &r, const <strong>SbVec3d</strong> &s, const <strong>SbDPRotation</strong> &so)</p><p>void <strong>setTransform</strong> (const <strong>SbVec3d</strong> &translation, const <strong>SbDPRotation</strong> &rotation, const <strong>SbVec3d</strong> &scaleFactor, const <strong>SbDPRotation</strong> &scaleOrientation, const <strong>SbVec3d</strong> &center)</p><p>void <strong>getTransform</strong> (<strong>SbVec3d</strong> &t, <strong>SbDPRotation</strong> &r, <strong>SbVec3d</strong> &s, <strong>SbDPRotation</strong> &so) const </p><p>void <strong>getTransform</strong> (<strong>SbVec3d</strong> &translation, <strong>SbDPRotation</strong> &rotation, <strong>SbVec3d</strong> &scaleFactor, <strong>SbDPRotation</strong> &scaleOrientation, const <strong>SbVec3d</strong> &center) const </p><p>SbBool <strong>factor</strong> (<strong>SbDPMatrix</strong> &r, <strong>SbVec3d</strong> &s, <strong>SbDPMatrix</strong> &u, <strong>SbVec3d</strong> &t, <strong>SbDPMatrix</strong> &proj)</p><p>SbBool <strong>LUDecomposition</strong> (int index[4], double &d)</p><p>void <strong>LUBackSubstitution</strong> (int index[4], double b[4]) const </p><p><strong>SbDPMatrix</strong> <strong>transpose</strong> (void) const </p><p><strong>SbDPMatrix</strong> & <strong>multRight</strong> (const <strong>SbDPMatrix</strong> &m)</p><p><strong>SbDPMatrix</strong> & <strong>multLeft</strong> (const <strong>SbDPMatrix</strong> &m)</p><p>void <strong>multMatrixVec</strong> (const <strong>SbVec3d</strong> &src, <strong>SbVec3d</strong> &dst) const </p><p>void <strong>multVecMatrix</strong> (const <strong>SbVec3d</strong> &src, <strong>SbVec3d</strong> &dst) const </p><p>void <strong>multDirMatrix</strong> (const <strong>SbVec3d</strong> &src, <strong>SbVec3d</strong> &dst) const </p><p>void <strong>multLineMatrix</strong> (const <strong>SbDPLine</strong> &src, <strong>SbDPLine</strong> &dst) const </p><p>void <strong>multVecMatrix</strong> (const <strong>SbVec4d</strong> &src, <strong>SbVec4d</strong> &dst) const </p><p>void <strong>print</strong> (FILE *fp) const </p><p><strong>operator double *</strong> (void)</p><p><strong>operator SbDPMat &</strong> (void)</p><p>double * <strong>operator[]</strong> (int i)</p><p>const double * <strong>operator[]</strong> (int i) const </p><p><strong>SbDPMatrix</strong> & <strong>operator=</strong> (const SbDPMat &m)</p><p><strong>SbDPMatrix</strong> & <strong>operator=</strong> (const <strong>SbDPMatrix</strong> &m)</p><p><strong>SbDPMatrix</strong> & <strong>operator=</strong> (const <strong>SbDPRotation</strong> &q)</p><p><strong>SbDPMatrix</strong> & <strong>operator*=</strong> (const <strong>SbDPMatrix</strong> &m)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SbDPMatrix</strong> <strong>identity</strong> (void)</p>
<h3>Friends</h3>
<p><strong>SbDPMatrix</strong> <strong>operator*</strong> (const <strong>SbDPMatrix</strong> &m1, const <strong>SbDPMatrix</strong> &m2)</p><p>int <strong>operator==</strong> (const <strong>SbDPMatrix</strong> &m1, const <strong>SbDPMatrix</strong> &m2)</p><p>int <strong>operator!=</strong> (const <strong>SbDPMatrix</strong> &m1, const <strong>SbDPMatrix</strong> &m2)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SbDPMatrix</strong> class is a 4x4 dimensional representation of a double-precision matrix.</p><p>This class is like the <strong>SbMatrix</strong> class, but uses double-precision floating point values for its elements. For more class documentation, see <strong>SbMatrix</strong>.</p><p><strong>Since:</strong></p><p>Coin 2.0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SbDPMatrix::SbDPMatrix (void)</h3>
<p>The default constructor does nothing. The matrix will be uninitialized.</p>
<h3>SbDPMatrix::SbDPMatrix (const doublea11, const doublea12, const doublea13, const doublea14, const doublea21, const doublea22, const doublea23, const doublea24, const doublea31, const doublea32, const doublea33, const doublea34, const doublea41, const doublea42, const doublea43, const doublea44)</h3>
<p>Constructs a matrix instance with the given initial elements.</p>
<h3>SbDPMatrix::SbDPMatrix (const SbDPMat &matrixref)</h3>
<p>Constructs a matrix instance with the initial elements from the <em>matrix</em> argument.</p>
<h3>SbDPMatrix::SbDPMatrix (const SbDPMat *matrixptr)</h3>
<p>This constructor is courtesy of the Microsoft Visual C++ compiler.</p>
<h3>SbDPMatrix::SbDPMatrix (const \fBSbMatrix\fP &matrixref)</h3>
<p>This constructor converts a single-precision matrix to a double-precision matrix.</p>
<h3>SbDPMatrix::~SbDPMatrix (void)</h3>
<p>Default destructor does nothing.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SbDPMatrix::setValue (const SbDPMat &m)</h3>
<p>Copies the elements from <em>m</em> into the matrix.</p><p><strong>See also:</strong></p><p><strong>getValue()</strong>.</p>
<h3>void SbDPMatrix::setValue (const \fBSbMatrix\fP &m)</h3>
<p>Copies the elements from <em>m</em> into the matrix.</p><p><strong>See also:</strong></p><p><strong>getValue()</strong>.</p>
<h3>void SbDPMatrix::setValue (const double *m)</h3>
<p>Copies the elements from <em>m</em> into the matrix.</p><p><strong>See also:</strong></p><p><strong>getValue()</strong>.</p>
<h3>const SbDPMat & SbDPMatrix::getValue (void) const</h3>
<p>Returns a pointer to the 2 dimensional double array with the matrix elements.</p><p><strong>See also:</strong></p><p><strong>setValue()</strong>.</p>
<h3>void SbDPMatrix::makeIdentity (void)</h3>
<p>Set the matrix to be the identity matrix.</p><p><strong>See also:</strong></p><p><strong>identity()</strong>.</p>
<h3>void SbDPMatrix::setRotate (const \fBSbDPRotation\fP &q)</h3>
<p>Set matrix to be a rotation matrix with the given rotation.</p><p><strong>See also:</strong></p><p><strong>setTranslate()</strong>, <strong>setScale()</strong>.</p>
<h3>\fBSbDPMatrix\fP SbDPMatrix::inverse (void) const</h3>
<p>Return a new matrix which is the inverse matrix of this.</p><p>The user is responsible for checking that this is a valid operation to execute, by first making sure that the result of <strong>SbDPMatrix::det4()</strong> is not equal to zero.</p>
<h3>double SbDPMatrix::det3 (intr1, intr2, intr3, intc1, intc2, intc3) const</h3>
<p>Returns the determinant of the 3x3 submatrix specified by the row and column indices.</p>
<h3>double SbDPMatrix::det3 (void) const</h3>
<p>Returns the determinant of the upper left 3x3 submatrix.</p>
<h3>double SbDPMatrix::det4 (void) const</h3>
<p>Returns the determinant of the matrix.</p>
<h3>SbBool SbDPMatrix::equals (const \fBSbDPMatrix\fP &m, doubletolerance) const</h3>
<p>Check if the <em>m</em> matrix is equal to this one, within the given tolerance value. The tolerance value is applied in the comparison on a component by component basis.</p>
<h3>void SbDPMatrix::getValue (SbDPMat &m) const</h3>
<p>Return matrix components in the SbDPMat structure.</p><p><strong>See also:</strong></p><p><strong>setValue()</strong>.</p>
<h3>\fBSbDPMatrix\fP SbDPMatrix::identity (void)\fC [static]\fP</h3>
<p>Return the identity matrix.</p><p><strong>See also:</strong></p><p><strong>makeIdentity()</strong>.</p>
<h3>void SbDPMatrix::setScale (const doubles)</h3>
<p>Set matrix to be a pure scaling matrix. Scale factors are specified by <em>s</em>.</p><p><strong>See also:</strong></p><p><strong>setRotate()</strong>, <strong>setTranslate()</strong>.</p>
<h3>void SbDPMatrix::setScale (const \fBSbVec3d\fP &s)</h3>
<p>Set matrix to be a pure scaling matrix. Scale factors in x, y and z is specified by the <em>s</em> vector.</p><p><strong>See also:</strong></p><p><strong>setRotate()</strong>, <strong>setTranslate()</strong>.</p>
<h3>void SbDPMatrix::setTranslate (const \fBSbVec3d\fP &t)</h3>
<p>Make this matrix into a pure translation matrix (no scale or rotation components) with the given vector  as the translation.</p><p><strong>See also:</strong></p><p><strong>setRotate()</strong>, <strong>setScale()</strong>.</p>
<h3>void SbDPMatrix::setTransform (const \fBSbVec3d\fP &t, const \fBSbDPRotation\fP &r, const \fBSbVec3d\fP &s)</h3>
<p>Set translation, rotation and scaling all at once. The resulting matrix gets calculated like this:</p>
<pre>
M = S * R * T
</pre>
<p>where <em>S</em>, <em>R</em> and <em>T</em> is scaling, rotation and translation matrices.</p><p><strong>See also:</strong></p><p><strong>setTranslate()</strong>, <strong>setRotate()</strong>, <strong>setScale()</strong> and <strong>getTransform()</strong>.</p>
<h3>void SbDPMatrix::setTransform (const \fBSbVec3d\fP &t, const \fBSbDPRotation\fP &r, const \fBSbVec3d\fP &s, const \fBSbDPRotation\fP &so)</h3>
<p>Set translation, rotation and scaling all at once with a specified scale orientation. The resulting matrix gets calculated like this:</p>
<pre>
M = Ro-¹ * S * Ro * R * T
</pre>
<p>where <em>Ro</em> is the scale orientation, and <em>S</em>, <em>R</em> and <em>T</em> is scaling, rotation and translation.</p><p><strong>See also:</strong></p><p><strong>setTranslate()</strong>, <strong>setRotate()</strong>, <strong>setScale()</strong> and <strong>getTransform()</strong>.</p>
<h3>void SbDPMatrix::setTransform (const \fBSbVec3d\fP &translation, const \fBSbDPRotation\fP &rotation, const \fBSbVec3d\fP &scaleFactor, const \fBSbDPRotation\fP &scaleOrientation, const \fBSbVec3d\fP &center)</h3>
<p>Set translation, rotation and scaling all at once with a specified scale orientation and center point. The resulting matrix gets calculated like this:</p>
<pre>
M = -Tc * Ro-¹ * S * Ro * R * T * Tc
</pre>
<p>where <em>Tc</em> is the center point, <em>Ro</em> the scale orientation, <em>S</em>, <em>R</em> and <em>T</em> is scaling, rotation and translation.</p><p><strong>See also:</strong></p><p><strong>setTranslate()</strong>, <strong>setRotate()</strong>, <strong>setScale()</strong> and <strong>getTransform()</strong>.</p>
<h3>void SbDPMatrix::getTransform (\fBSbVec3d\fP &t, \fBSbDPRotation\fP &r, \fBSbVec3d\fP &s, \fBSbDPRotation\fP &so) const</h3>
<p>Factor the matrix back into its translation, rotation, scale and scaleorientation components.</p><p><strong>See also:</strong></p><p><strong>factor()</strong></p>
<h3>void SbDPMatrix::getTransform (\fBSbVec3d\fP &translation, \fBSbDPRotation\fP &rotation, \fBSbVec3d\fP &scaleFactor, \fBSbDPRotation\fP &scaleOrientation, const \fBSbVec3d\fP &center) const</h3>
<p>Factor the matrix back into its <em>translation</em>, <em>rotation</em>, <em>scaleFactor</em> and <em>scaleorientation</em> components. Will eliminate the <em>center</em> variable from the matrix.</p><p><strong>See also:</strong></p><p><strong>factor()</strong></p>
<h3>SbBool SbDPMatrix::factor (\fBSbDPMatrix\fP &r, \fBSbVec3d\fP &s, \fBSbDPMatrix\fP &u, \fBSbVec3d\fP &t, \fBSbDPMatrix\fP &proj)</h3>
<p>This function is not implemented in Coin.</p><p><strong>See also:</strong></p><p><strong>getTransform()</strong></p>
<h3>SbBool SbDPMatrix::LUDecomposition (intindex[4], double &d)</h3>
<p>This function produces a permuted LU decomposition of the matrix. It uses the common single-row-pivoting strategy.</p><p><em>FALSE</em> is returned if the matrix is singular, which it never is, because of small adjustment values inserted if a singularity is found (as Open Inventor does too).</p><p>The parity argument is always set to 1.0 or -1.0. Don't really know what it's for, so it's not checked for correctness.</p><p>The index[] argument returns the permutation that was done on the matrix to LU-decompose it. index[i] is the row that row i was swapped with at step i in the decomposition, so index[] is not the actual permutation of the row indexes!</p><p>BUGS: The function does not produce results that are numerically identical with those produced by Open Inventor for the same matrices, because the pivoting strategy in OI was never fully understood.</p><p><strong>See also:</strong></p><p><strong>SbDPMatrix::LUBackSubstitution</strong></p>
<h3>void SbDPMatrix::LUBackSubstitution (intindex[4], doubleb[4]) const</h3>
<p>This function does a solve on the 'Ax = b' system, given that the matrix is LU-decomposed in advance. First, a forward substitution is done on the lower system (Ly = b), and then a backwards substitution is done on the upper triangular system (Ux = y).</p><p>The index[] argument is the one returned from <strong>SbDPMatrix::LUDecomposition()</strong>, so see that function for an explanation.</p><p>The b[] argument must contain the b vector in 'Ax = b' when calling the function. After the function has solved the system, the b[] vector contains the x vector.</p><p>BUGS: As is done by Open Inventor, unsolvable x values will not return NaN but 0.</p>
<h3>\fBSbDPMatrix\fP SbDPMatrix::transpose (void) const</h3>
<p>Returns the transpose of this matrix.</p>
<h3>\fBSbDPMatrix\fP & SbDPMatrix::multRight (const \fBSbDPMatrix\fP &m)</h3>
<p>Let this matrix be right-multiplied by <em>m</em>. Returns reference to self.</p><p><strong>See also:</strong></p><p><strong>multLeft()</strong></p>
<h3>\fBSbDPMatrix\fP & SbDPMatrix::multLeft (const \fBSbDPMatrix\fP &m)</h3>
<p>Let this matrix be left-multiplied by <em>m</em>. Returns reference to self.</p><p><strong>See also:</strong></p><p><strong>multRight()</strong></p>
<h3>void SbDPMatrix::multMatrixVec (const \fBSbVec3d\fP &src, \fBSbVec3d\fP &dst) const</h3>
<p>Multiply <em>src</em> vector with this matrix and return the result in <em>dst</em>. Multiplication is done with the vector on the right side of the expression, i.e. dst = M * src.</p><p><strong>See also:</strong></p><p><strong>multVecMatrix()</strong>, <strong>multDirMatrix()</strong> and <strong>multLineMatrix()</strong>.</p>
<h3>void SbDPMatrix::multVecMatrix (const \fBSbVec3d\fP &src, \fBSbVec3d\fP &dst) const</h3>
<p>Multiply <em>src</em> vector with this matrix and return the result in <em>dst</em>. Multiplication is done with the vector on the left side of the expression, i.e. dst = src * M.</p><p>It is safe to let <em>src</em> and  be the same <strong>SbVec3d</strong> instance.</p><p><strong>See also:</strong></p><p><strong>multMatrixVec()</strong>, <strong>multDirMatrix()</strong> and <strong>multLineMatrix()</strong>.</p>
<h3>void SbDPMatrix::multDirMatrix (const \fBSbVec3d\fP &src, \fBSbVec3d\fP &dst) const</h3>
<p>Multiplies <em>src</em> by the matrix. <em>src</em> is assumed to be a direction vector, and the translation components of the matrix are therefore ignored.</p><p>Multiplication is done with the vector on the left side of the expression, i.e. dst = src * M.</p><p><strong>See also:</strong></p><p><strong>multVecMatrix()</strong>, <strong>multMatrixVec()</strong> and <strong>multLineMatrix()</strong>.</p>
<h3>void SbDPMatrix::multLineMatrix (const \fBSbDPLine\fP &src, \fBSbDPLine\fP &dst) const</h3>
<p>Multiplies line point with the full matrix and multiplies the line direction with the matrix without the translation components.</p><p><strong>See also:</strong></p><p><strong>multVecMatrix()</strong>, <strong>multMatrixVec()</strong> and <strong>multDirMatrix()</strong>.</p>
<h3>void SbDPMatrix::multVecMatrix (const \fBSbVec4d\fP &src, \fBSbVec4d\fP &dst) const</h3>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<h3>void SbDPMatrix::print (FILE *fp) const</h3>
<p>Write out the matrix contents to the given file.</p>
<h3>SbDPMatrix::operator double * (void)</h3>
<p>Return pointer to the matrix' 4x4 double array.</p>
<h3>SbDPMatrix::operator SbDPMat & (void)</h3>
<p>Return pointer to the matrix' 4x4 double array.</p>
<h3>double * SbDPMatrix::operator[] (inti)</h3>
<p>Returns pointer to the 4 element array representing a matrix row. <em>i</em> should be within [0, 3].</p><p><strong>See also:</strong></p><p><strong>getValue()</strong>, <strong>setValue()</strong>.</p>
<h3>const double * SbDPMatrix::operator[] (inti) const</h3>
<p>Returns pointer to the 4 element array representing a matrix row. <em>i</em> should be within [0, 3].</p><p><strong>See also:</strong></p><p><strong>getValue()</strong>, <strong>setValue()</strong>.</p>
<h3>\fBSbDPMatrix\fP & SbDPMatrix::operator= (const SbDPMat &m)</h3>
<p>Assignment operator. Copies the elements from <em>m</em> to the matrix.</p>
<h3>\fBSbDPMatrix\fP & SbDPMatrix::operator= (const \fBSbDPMatrix\fP &m)</h3>
<p>Assignment operator. Copies the elements from <em>m</em> to the matrix.</p>
<h3>\fBSbDPMatrix\fP & SbDPMatrix::operator= (const \fBSbDPRotation\fP &q)</h3>
<p>Set matrix to be a rotation matrix with the given rotation.</p><p><strong>See also:</strong></p><p><strong>setRotate()</strong>.</p>
<h3>\fBSbDPMatrix\fP & SbDPMatrix::operator*= (const \fBSbDPMatrix\fP &m)</h3>
<p>Right-multiply with the <em>m</em> matrix.</p><p><strong>See also:</strong></p><p><strong>multRight()</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Friends And Related Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSbDPMatrix\fP operator* (const \fBSbDPMatrix\fP &m1, const \fBSbDPMatrix\fP &m2)\fC [friend]\fP</h3>
<p>Multiplies matrix <em>m1</em> with matrix <em>m2</em> and returns the resultant matrix.</p>
<h3>int operator== (const \fBSbDPMatrix\fP &m1, const \fBSbDPMatrix\fP &m2)\fC [friend]\fP</h3>
<p>Compare matrices to see if they are equal. For two matrices to be equal, all their individual elements must be equal.</p><p><strong>See also:</strong></p><p><strong>equals()</strong>.</p>
<h3>int operator!= (const \fBSbDPMatrix\fP &m1, const \fBSbDPMatrix\fP &m2)\fC [friend]\fP</h3>
<p>Compare matrices to see if they are not equal. For two matrices to not be equal, it is enough that at least one of their elements are unequal.</p><p><strong>See also:</strong></p><p><strong>equals()</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SbDPLine.3.html"><span aria-hidden="true">&larr;</span> SbDPLine.3: The sbdpline class represents a line in 3d space.  sbdpline is used by many other classes in coin. it provides a way of specifying a directed line (also known as a ray) through a specified point (origin) and a direction in 3d space. note that the line is infinite in both directions from its definition point.</a></li>
   <li class="next"><a href="SbDPPlane.3.html">SbDPPlane.3: The sbdpplane class represents a plane in 3d space.  sbdpplane is used by many other classes in coin. it provides a way of representing a plane, specified by a plane normal vector and a distance from the origin of the coordinate system. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

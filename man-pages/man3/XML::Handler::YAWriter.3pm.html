<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::Handler::YAWriter: Yet another perl sax xml writer</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Yet another perl sax xml writer">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::Handler::YAWriter (3pm) manual">
  <meta name="twitter:description" content="Yet another perl sax xml writer">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-handler-yawriter-perl-XML::Handler::YAWriter-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::Handler::YAWriter.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::Handler::YAWriter (3pm) manual" />
  <meta property="og:description" content="Yet another perl sax xml writer" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-handler-yawriter-perl-XML::Handler::YAWriter-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::Handler::YAWriter<small> (3pm)</small></h1>
        <p class="lead">Yet another perl sax xml writer</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Handler::YAWriter.3pm.html">
      <span itemprop="name">XML::Handler::YAWriter: Yet another perl sax xml writer</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-handler-yawriter-perl/">
      <span itemprop="name">libxml-handler-yawriter-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Handler::YAWriter.3pm.html">
      <span itemprop="name">XML::Handler::YAWriter: Yet another perl sax xml writer</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use XML::Handler::YAWriter;

  my $ya = new XML::Handler::YAWriter( %options );
  my $perlsax = new XML::Parser::PerlSAX( &apos;Handler&apos; =&gt; $ya );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>YAWriter implements Yet Another XML::Handler::Writer. The reasons for this one are that I needed a flexible escaping technique, and want some kind of pretty printing. If an instance of YAWriter is created without any options, the default behavior is to produce an array of strings containing the \s-1XML\s0 in :</p><p>  @{$ya-&gt;{Strings}}</p><h3>Options</h3>
<p>Options are given in the usual 'key' =&gt; 'value' idiom.</p>
<dl class='dl-vertical'>
  <dt>
    Output IO::File
  </dt>
  <dd>
    <p>This option tells YAWriter to use an already open file for output, instead of using $ya-&gt;{Strings} to store the array of strings. It should be noted that the only thing the object needs to implement is the print method. So anything can be used to receive a stream of strings from YAWriter.</p>
  </dd>
  <dt>
    AsFile string
  </dt>
  <dd>
    <p>This option will cause start_document to open named file and end_document to close it. Use the literal dash \*(L"-\*(R" if you want to print on standard output.</p>
  </dd>
  <dt>
    AsPipe string
  </dt>
  <dd>
    <p>This option will cause start_document to open a pipe and end_document to close it. The pipe is a normal shell command. Secure shell comes handy but has a 2GB limit on most systems.</p>
  </dd>
  <dt>
    AsArray boolean
  </dt>
  <dd>
    <p>This option will force storage of the \s-1XML\s0 in $ya-&gt;{Strings}, even if the Output option is given.</p>
  </dd>
  <dt>
    AsString boolean
  </dt>
  <dd>
    <p>This option will cause end_document to return the complete \s-1XML\s0 document in a single string. Most \s-1SAX\s0 drivers return the value of end_document as a result of their parse method. As this may not work with some combinations of \s-1SAX\s0 drivers and filters, a join of $ya-&gt;{Strings} in the controlling method is preferred.</p>
  </dd>
  <dt>
    Encoding string
  </dt>
  <dd>
    <p>This will change the default encoding from \s-1UTF-8\s0 to anything you like. You should ensure that given data are already in this encoding or provide an Escape hash, to tell YAWriter about the recoding.</p>
  </dd>
  <dt>
    Escape hash
  </dt>
  <dd>
    <p>The Escape hash defines substitutions that have to be done to any string, with the exception of the processing_instruction and doctype_decl methods, where I think that escaping of target and data would cause more trouble than necessary. The default value for Escape is     $XML::Handler::YAWriter::escape = {             &apos;&&apos;  =&gt; &apos;&amp;&apos;,             &apos;&lt;&apos;  =&gt; &apos;&lt;&apos;,             &apos;&gt;&apos;  =&gt; &apos;&gt;&apos;,             &apos;"&apos;  =&gt; &apos;&quot;&apos;,             &apos;--&apos; =&gt; &apos;&#45;&#45;&apos;             }; YAWriter will use an evaluated sub to make the recoding based on a given Escape hash reasonably fast. Future versions may use \s-1XS\s0 to improve this performance bottleneck.</p>
  </dd>
  <dt>
    Pretty hash
  </dt>
  <dd>
    <p>Hash of string =&gt; boolean tuples, to define kind of prettyprinting. Default to undef. Possible string values:</p>
<dl class='dl-vertical'>
  <dt>
    AddHiddenNewline boolean
  </dt>
  <dd>
    <p>Add hidden newline before \*(L"&gt;\*(R"</p>
  </dd>
  <dt>
    AddHiddenAttrTab boolean
  </dt>
  <dd>
    <p>Add hidden tabulation for attributes</p>
  </dd>
  <dt>
    CatchEmptyElement boolean
  </dt>
  <dd>
    <p>Catch empty Elements, apply \*(L"/&gt;\*(R" compression</p>
  </dd>
  <dt>
    CatchWhiteSpace boolean
  </dt>
  <dd>
    <p>Catch whitespace with comments</p>
  </dd>
  <dt>
    CompactAttrIndent
  </dt>
  <dd>
    <p>Places Attributes on the same line as the Element</p>
  </dd>
  <dt>
    IsSGML boolean
  </dt>
  <dd>
    <p>This option will cause start_document, processing_instruction and doctype_decl to appear as \s-1SGML\s0. The \s-1SGML\s0 is still well-formed of course, if your \s-1SAX\s0 events are well-formed.</p>
  </dd>
  <dt>
    NoComments boolean
  </dt>
  <dd>
    <p>Supress Comments</p>
  </dd>
  <dt>
    NoDTD boolean
  </dt>
  <dd>
    <p>Supress \s-1DTD\s0</p>
  </dd>
  <dt>
    NoPI boolean
  </dt>
  <dd>
    <p>Supress Processing Instructions</p>
  </dd>
  <dt>
    NoProlog boolean
  </dt>
  <dd>
    <p>Supress &lt;?xml ... ?&gt; Prolog</p>
  </dd>
  <dt>
    NoWhiteSpace boolean
  </dt>
  <dd>
    <p>Supress WhiteSpace to clean documents from prior pretty printing.</p>
  </dd>
  <dt>
    PrettyWhiteIndent boolean
  </dt>
  <dd>
    <p>Add visible indent before any eventstring</p>
  </dd>
  <dt>
    PrettyWhiteNewline boolean
  </dt>
  <dd>
    <p>Add visible newlines before any eventstring</p>
  </dd>
  <dt>
    \s-1SAX1\s0 boolean (not yet implemented)
  </dt>
  <dd>
    <p>Output only \s-1SAX1\s0 compliant eventstrings</p>
  </dd>

</dl>

  </dd>

</dl>

<h3>Notes:</h3>
<p>Correct handling of start_document and end_document is required!</p><p>The YAWriter Object initialises its structures during start_document and does its cleanup during end_document.  If you forget to call start_document, any other method will break during the run. Most likely place is the encode method, trying to eval undef as a subroutine. If you forget to call end_document, you should not use a single instance of YAWriter more than once.</p><p>For small documents AsArray may be the fastest method and AsString the easiest one to receive the output of YAWriter. But AsString and AsArray may run out of memory with infinite \s-1SAX\s0 streams. The only method XML::Handler::Writer calls on a given Output object is the print method. So it's easy to use a self written Output object to improve streaming.</p><p>A single instance of XML::Handler::YAWriter is able to produce more than one file in a single run. Be sure to provide a fresh IO::File as Output before you call start_document and close this File after calling end_document. Or provide a filename in AsFile, so start_document and end_document can open and close its own filehandle.</p><p>Automatic recoding between 8bit and 16bit does not work in any Perl correctly !</p><p>I have Perl-5.00563 at home and here I can specify \*(L"use utf8;\*(R" in the right places to make recoding work. But I dislike saying \*(L"use 5.00555;\*(R" because many systems run 5.00503.</p><p>If you use some 8bit character set internally and want use national characters, either state your character as Encoding to be \s-1ISO-8859-1\s0, or provide an Escape hash similar to the following :</p><p>    $ya-&gt;{&apos;Escape&apos;} = {                     &apos;&&apos;  =&gt; &apos;&amp;&apos;,                     &apos;&lt;&apos;  =&gt; &apos;&lt;&apos;,                     &apos;&gt;&apos;  =&gt; &apos;&gt;&apos;,                     &apos;"&apos;  =&gt; &apos;&quot;&apos;,                     &apos;--&apos; =&gt; &apos;&#45;&#45;&apos;                     &apos;o\*:&apos; =&gt; &apos;&ouml;&apos;                     &apos;a\*:&apos; =&gt; &apos;&auml;&apos;                     &apos;u\*:&apos; =&gt; &apos;&uuml;&apos;                     &apos;O\*:&apos; =&gt; &apos;&Ouml;&apos;                     &apos;A\*:&apos; =&gt; &apos;&Auml;&apos;                     &apos;U\*:&apos; =&gt; &apos;&Uuml;&apos;                     &apos;\*8&apos; =&gt; &apos;&szlig;&apos;                     };</p><p>You may abuse YAWriter to clean whitespace from \s-1XML\s0 documents. Take a look at test.pl, doing just that with an XML::Edifact message, without querying the \s-1DTD\s0. This may work in 99% of the cases where you want to get rid of ignorable whitespace caused by the various forms of pretty printing.</p><p>    my $ya = new XML::Handler::YAWriter(         &apos;Output&apos; =&gt; new IO::File ( "&gt;-" );         &apos;Pretty&apos; =&gt; {             &apos;NoWhiteSpace&apos;=&gt;1,             &apos;NoComments&apos;=&gt;1,             &apos;AddHiddenNewline&apos;=&gt;1,             &apos;AddHiddenAttrTab&apos;=&gt;1,         } );</p><p>XML::Handler::Writer implements any method XML::Parser::PerlSAX wants. This extends the Java \s-1SAX1\s0.0 specification. I have in mind using Pretty=&gt;SAX1=&gt;1 to disable this feature, if abusing YAWriter for a \s-1SAX\s0 proxy.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Michael Koehne, Kraehe@Copyleft.De</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Thanks</h2>
        <div class="sectioncontent">
<p>\*(L"Derksen, Eduard (Enno), \s-1CSCIO\s0\*(R" &lt;enno@att.com&gt; helped me with the Escape hash and gave quite a lot of useful comments.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::Handler::YAWriter&hellip;</h2>
        <div class="sectioncontent">
<p>perl and XML::Parser::PerlSAX</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::Handler::XMLWriter.3pm.html"><span aria-hidden="true">&larr;</span> XML::Handler::XMLWriter.3pm: A perlsax handler for writing readable xml</a></li>
   <li class="next"><a href="XML::LibXML::Debugging.3pm.html">XML::LibXML::Debugging.3pm: Get debugging information from xml::libxml nodes <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

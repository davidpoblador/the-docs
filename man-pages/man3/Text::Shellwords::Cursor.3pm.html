<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Text::Shellwords::Cursor: Parse a string into tokens</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parse a string into tokens">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Text::Shellwords::Cursor (3pm) manual">
  <meta name="twitter:description" content="Parse a string into tokens">
  <meta name="twitter:image" content="https://www.carta.tech/images/libterm-shellui-perl-Text::Shellwords::Cursor-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Text::Shellwords::Cursor.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Text::Shellwords::Cursor (3pm) manual" />
  <meta property="og:description" content="Parse a string into tokens" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libterm-shellui-perl-Text::Shellwords::Cursor-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Text::Shellwords::Cursor<small> (3pm)</small></h1>
        <p class="lead">Parse a string into tokens</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Text::Shellwords::Cursor.3pm.html">
      <span itemprop="name">Text::Shellwords::Cursor: Parse a string into tokens</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libterm-shellui-perl/">
      <span itemprop="name">libterm-shellui-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Text::Shellwords::Cursor.3pm.html">
      <span itemprop="name">Text::Shellwords::Cursor: Parse a string into tokens</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Text::Shellwords::Cursor;
 my $parser = Text::Shellwords::Cursor-&gt;new();
 my $str = &apos;ab cdef "ghi"    j"k&#92;"l "&apos;;
 my ($tok1) = $parser-&gt;parse_line($str);
   $tok1 = [&apos;ab&apos;, &apos;cdef&apos;, &apos;ghi&apos;, &apos;j&apos;, &apos;k"l &apos;]
 my ($tok2, $tokno, $tokoff) = $parser-&gt;parse_line($str, cursorpos =&gt; 6);
    as above, but $tokno=1, $tokoff=3  (under the &apos;f&apos;)
</pre>
<p>\s-1DESCRIPTION\s0</p><p>This module is very similar to Text::Shellwords and Text::ParseWords. However, it has one very significant difference: it keeps track of a character position in the line it's parsing.  For instance, if you pass it (\*(L"zq fmgb\*(R", cursorpos=&gt;6), it would return (['zq', 'fmgb'], 1, 3).  The cursorpos parameter tells where in the input string the cursor resides (just before the 'b'), and the result tells you that the cursor was on token 1 ('fmgb'), character 3 ('b'). This is very useful when computing command-line completions involving quoting, escaping, and tokenizing characters (like '(' or '=').</p><p>A few helper utilities are included as well.  You can escape a string to ensure that parsing it will produce the original string (parse_escape). You can also reassemble the tokens with a visually pleasing amount of whitespace between them (join_line).</p><p>This module started out as an integral part of Term::GDBUI using code loosely based on Text::ParseWords.  However, it is now basically a ground-up reimplementation.  It was split out of Term::GDBUI for version 0.8.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    new
  </dt>
  <dd>
    <p>Creates a new parser.  Takes named arguments on the command line.</p>
<dl class='dl-vertical'>
  <dt>
    keep_quotes
  </dt>
  <dd>
    <p>Normally all unescaped, unnecessary quote marks are stripped. If you specify \*(C`keep_quotes=&gt;1\*(C', however, they are preserved. This is useful if you need to know whether the string was quoted or not (string constants) or what type of quotes was around it (affecting variable interpolation, for instance).</p>
  </dd>
  <dt>
    token_chars
  </dt>
  <dd>
    <p>This argument specifies the characters that should be considered tokens all by themselves.  For instance, if I pass token_chars=&gt;'=', then 'ab=123' would be parsed to ('ab', '=', '123'). Without token_chars, 'ab=123' remains a single string. \s-1NOTE:\s0 you cannot change token_chars after the constructor has been called!  The regexps that use it are compiled once (m//o). Also, until the Gnu Readline library can accept \*(L"=[],\*(R" without diving into an endless loop, we will not tell history expansion to use token_chars (it uses \*(L" &#92;t&#92;fIen()&lt;&gt;;&|\*(R" by default).</p>
  </dd>
  <dt>
    debug
  </dt>
  <dd>
    <p>Turns on rather copious debugging to try to show what the parser is thinking at every step.</p>
  </dd>
  <dt>
    space_none
  </dt>
  <dd>
    
  </dd>
  <dt>
    space_before
  </dt>
  <dd>
    
  </dd>
  <dt>
    space_after
  </dt>
  <dd>
    <p>These variables affect how whitespace in the line is normalized and it is reassembled into a string.  See the join_line routine.</p>
  </dd>
  <dt>
    error
  </dt>
  <dd>
    <p>This is a reference to a routine that should be called to display a parse error.  The routine takes two arguments: a reference to the parser, and the error message to display as a string.</p>
  </dd>
  <dt>
    parsebail(msg)
  </dt>
  <dd>
    <p>If the parsel routine or any of its subroutines runs into a fatal error, they call parsebail to present a very descriptive diagnostic.</p>
  </dd>
  <dt>
    parsel
  </dt>
  <dd>
    <p>This is the heinous routine that actually does the parsing. You should never need to call it directly.  Call parse_line instead.</p>
  </dd>
  <dt>
    parse_line(line, <em>named args</em>)
  </dt>
  <dd>
    <p>This is the entrypoint to this module's parsing functionality.  It converts a line into tokens, respecting quoted text, escaped characters, etc.  It also keeps track of a cursor position on the input text, returning the token number and offset within the token where that position can be found in the output. This routine originally bore some resemblance to Text::ParseWords. It has changed almost completely, however, to support keeping track of the cursor position.  It also has nicer failure modes, modular quoting, token characters (see token_chars in \*(L"new\*(R"), etc.  This routine now does much more. Arguments:</p>
<dl class='dl-vertical'>
  <dt>
    line
  </dt>
  <dd>
    <p>This is a string containing the command-line to parse.</p>
  </dd>

</dl>
<p>This routine also accepts the following named parameters:</p>
<dl class='dl-vertical'>
  <dt>
    cursorpos
  </dt>
  <dd>
    <p>This is the character position in the line to keep track of. Pass undef (by not specifying it) or the empty string to have the line processed with cursorpos ignored. Note that passing undef is <em>not</em> the same as passing some random number and ignoring the result!  For instance, if you pass 0 and the line begins with whitespace, you'll get a 0-length token at the beginning of the line to represent the cursor in the middle of the whitespace.  This allows command completion to work even when the cursor is not near any tokens. If you pass undef, all whitespace at the beginning and end of the line will be trimmed as you would expect. If it is ambiguous whether the cursor should belong to the previous token or to the following one (i.e. if it's between two quoted strings, say \*(L"a\*(R"\*(L"b\*(R" or a token_char), it always gravitates to the previous token.  This makes more sense when completing.</p>
  </dd>
  <dt>
    fixclosequote
  </dt>
  <dd>
    <p>Sometimes you want to try to recover from a missing close quote (for instance, when calculating completions), but usually you want a missing close quote to be a fatal error.  fixclosequote=&gt;1 will implicitly insert the correct quote if it's missing. fixclosequote=&gt;0 is the default.</p>
  </dd>
  <dt>
    messages
  </dt>
  <dd>
    <p>parse_line is capable of printing very informative error messages. However, sometimes you don't care enough to print a message (like when calculating completions).  Messages are printed by default, so pass messages=&gt;0 to turn them off.</p>
  </dd>

</dl>
<p>This function returns a reference to an array containing three items:</p>
<dl class='dl-vertical'>
  <dt>
    tokens
  </dt>
  <dd>
    <p>A the tokens that the line was separated into (ref to an array of strings).</p>
  </dd>
  <dt>
    tokno
  </dt>
  <dd>
    <p>The number of the token (index into the previous array) that contains cursorpos.</p>
  </dd>
  <dt>
    tokoff
  </dt>
  <dd>
    <p>The character offet into tokno of cursorpos.</p>
  </dd>

</dl>
<p>If the cursor is at the end of the token, tokoff will point to 1 character past the last character in tokno, a non-existant character. If the cursor is between tokens (surrounded by whitespace), a zero-length token will be created for it.</p>
  </dd>
  <dt>
    parse_escape(lines)
  </dt>
  <dd>
    <p>Escapes characters that would be otherwise interpreted by the parser. Will accept either a single string or an arrayref of strings (which will be modified in-place).</p>
  </dd>
  <dt>
    join_line(tokens)
  </dt>
  <dd>
    <p>This routine does a somewhat intelligent job of joining tokens back into a command line.  If token_chars (see \*(L"new\*(R") is empty (the default), then it just escapes backslashes and quotes, and joins the tokens with spaces. However, if token_chars is nonempty, it tries to insert a visually pleasing amount of space between the tokens.  For instance, rather than 'a ( b , c )', it tries to produce 'a (b, c)'.  It won't reformat any tokens that aren't found in $self-&gt;{token_chars}, of course. To change the formatting, you can redefine the variables $self-&gt;{space_none}, $self-&gt;{space_before}, and $self-&gt;{space_after}. Each variable is a string containing all characters that should not be surrounded by whitespace, should have whitespace before, and should have whitespace after, respectively.  Any character found in token_chars, but non in any of these space_ variables, will have space placed both before and after.</p>
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>None known.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2003-2011 Scott Bronson, all rights reserved. This program is covered by the \s-1MIT\s0 license.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Scott Bronson &lt;bronson@rinspin.com&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Text::RewriteRules.3pm.html"><span aria-hidden="true">&larr;</span> Text::RewriteRules.3pm: A system to rewrite text using regexp-based rules</a></li>
   <li class="next"><a href="Text::SimpleTable.3pm.html">Text::SimpleTable.3pm: Simple eyecandy ascii tables <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ExtUtils::XSBuilder: Automatic perl xs glue code generation</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Automatic perl xs glue code generation">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ExtUtils::XSBuilder (3pm) manual">
  <meta name="twitter:description" content="Automatic perl xs glue code generation">
  <meta name="twitter:image" content="https://www.carta.tech/images/libextutils-xsbuilder-perl-ExtUtils::XSBuilder-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/ExtUtils::XSBuilder.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ExtUtils::XSBuilder (3pm) manual" />
  <meta property="og:description" content="Automatic perl xs glue code generation" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libextutils-xsbuilder-perl-ExtUtils::XSBuilder-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ExtUtils::XSBuilder<small> (3pm)</small></h1>
        <p class="lead">Automatic perl xs glue code generation</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/ExtUtils::XSBuilder.3pm.html">
      <span itemprop="name">ExtUtils::XSBuilder: Automatic perl xs glue code generation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libextutils-xsbuilder-perl/">
      <span itemprop="name">libextutils-xsbuilder-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/ExtUtils::XSBuilder.3pm.html">
      <span itemprop="name">ExtUtils::XSBuilder: Automatic perl xs glue code generation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>ExtUtils::XSBuilder is a set modules to parse C header files and create \s-1XS\s0 glue code and documentation out of it. Idealy this allows to \*(L"write\*(R" an interface to a C library without coding a line. Since no C \s-1API\s0 is ideal, some adjuments are necessary most of the time. So to use this module you must still be familiar with C and \s-1XS\s0 programming, but it removes a lot of stupid work and copy & paste from you. Also when the C \s-1API\s0 changes, most of the time you only have to rerun XSBuilder to get your new Perl \s-1API\s0.</p><p>The creation process takes place in the following steps:</p><h3>Derive a class from ExtUtils::XSBuilder::ParseSource</h3>
<p>This class must override some methods to tell XSBuilder which C header files to parse and some other necessary parameters. You need at least to override the \*(C`package\*(C' method to give the name of the package you want to create and either the \*(C`find_includes\*(C' method which returns all C header files to parse, or the \*(C`include_dirs\*(C' method to return a list of all directories which should be scanned for C header files.</p><p>Of course there are more methods you can overide. See ExtUtils::XSBuilder::ParseSource for a full list of overrideable methods.</p>
<h3>Scan the source files</h3>
<p>If your derived class is called MyClass::ParseSource you simply start the source scan with</p>
<pre>
    perl -MMyClass::ParseSource -e &apos;MyClass::ParseSource-&gt;run&apos;
</pre>
<p>You may also put this into a small script to ease usage, set the Perl libpath, etc.</p><p>During the source scan, XSBuilder creates a set of tables which contain the results of parsing. If you haven't changed the default locations in your subclass, these tables are created under \*(C`xs/tables\*(C', followed by the name of the module returned by the \*(C`package\*(C' method you created. There you will find four generated modules: \*(C`FunctionTable.pm\*(C', which holds the function declarations; \*(C`StructureTable.pm\*(C', which holds the structures; \*(C`ConstantTable.pm\*(C', which contains constants found in the header files; and \*(C`CallbackTable.pm\*(C', which contains definitions for callback types.</p><p>Since source scanning may take some time, we create intermediate tables and transform them into \s-1XS\s0 code later, rather than creating \s-1XS\s0 code directly. Since we save the result, we can avoid rescanning the source files as long as they don't change.</p>
<h3>Derive a class from ExtUtils::XSBuilder::WrapXS</h3>
<p>The WrapXS class is responsible for taking the information generated both from the source files and from the map files (see below) to create the \s-1XS\s0 code. As with the ParseSource class, you must override this method with your own implementaion, to tell WrapXS what to do.</p><p>See ExtUtils::XSBuilder::WrapXS for a list of overrideable methods.</p>
<h3>Create map files</h3>
<p>XSBuilder will not automatically create \s-1XS\s0 functions for all C functions and structures. You must provide hints in order for the \s-1XS\s0 files to be created properly. The map files are the mechanism to provide these hints. By default, the map files are found under \*(C`xs/maps\*(C'. There are four map types, \*(C`types\*(C', \*(C`functions\*(C', \*(C`structures\*(C', and \*(C`callbacks\*(C'. Each map file is named with a user selectable prefix (e.g. \*(C`foo\*(C',) followed by an underscore, the map type name, and the map extension \*(C`.map\*(C'. For example, hints for functions relating to error processing in your source may be contained in a map file named \*(C`error_functions.map\*(C'.</p>
<dl class='dl-vertical'>
  <dt>
    foo_types.map
  </dt>
  <dd>
    <p>Contains the mapping from C types to Perl classes.</p>
  </dd>
  <dt>
    foo_functions.map
  </dt>
  <dd>
    <p>Contains the mapping from C functions to Perl functions. Can be used to reorder arguments, tell XSBuilder which arguments are actualy return values and in which Perl package the function will be created.</p>
  </dd>
  <dt>
    foo_structures.map
  </dt>
  <dd>
    <p>Contains the mapping from C structures to Perl classes and defines for which classes the access methods should be created. You can also specify if you want a \*(C`new\*(C' method for the class.</p>
  </dd>
  <dt>
    foo_callbacks.map
  </dt>
  <dd>
    <p>Contains the mapping form C callback functions to Perl callback functions. Can be used to reorder arguments, tell XSBuilder which arguments are return values, and in which Perl package the functions will be created.</p>
  </dd>

</dl>
<p>For a detailed description of the map file formats see below.</p><p>To have a starting point, XSBuilder is able to create default map files which simply include all types, functions and structures. You can recreate the map files anytime and XSBuilder will append all items which are not already in the map files.</p><p>First copy the _types.map file from the xsbuilder directory to your maps directory. This file contains the standard mapping for some basic types.</p><p>If, for example, your derived class is called MyClass::WrapXS, you simply start the creation/update of the map files with</p><p>    perl -MMyClass::WrapXS -e &apos;MyClass::WrapXS-&gt;checkmaps(" ")&apos;</p><p>The argument to checkmaps supplies a character to be prepended to the first column of the new map entries. If you do not pass an argument to checkmaps, no map files are written, and checkmaps will only compare what is missing. (You need to print the result somehow e.g. by using Data::Dumper). You may also put this into a small script to ease usage, set the Perl libpath, etc.</p><p>After you have created your default maps, you must edit the \*(C`xs/maps/new_type.map\*(C' file, which contains all types that were found in the source. Append a pipe (\*(C`|\*(C') followed by the class or type name, e.g.</p><p>    int                 | IV     struct request_rec  | Apache::RequestRec</p><p>.</p>
<h3>Create the \s-1XS\s0 files</h3>
<p>Now we can create the code. By running</p><p>    perl -MMyClass::WrapXS -e &apos;MyClass::WrapXS-&gt;run&apos;</p><p>XSBuilder will create the \s-1XS\s0, pm and Makefile.PL files for every module that is mentioned in the maps. The result is placed as a directory hierarchy under WrapXS. To control the content of the \*(C`Makefile.PL\*(C' and the \*(C`pm\*(C' file, you can override the \*(C`makefilepl_text\*(C' and \*(C`pm_text\*(C' methods. You can include additional code in the \s-1XS\s0 files by writing an include file which is included at the top of the \s-1XS\s0 file. This file can contain helper functions that can't be automatically generated. The files must be placed under the \*(C`xs\*(C' directory, with the correct path and name. For example, to have a header file included for the module Apache::DAV, create a file named \*(C`xs/Apache/DAV/Apache_\|_DAV.h\*(C'. The same can be done for inclusion in the pm file. Following the example above, the file name would be \*(C`xs/Apache/DAV/DAV_pm\*(C'.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Format of the map files</h2>
        <div class="sectioncontent">
<p>For all map files blank lines are ignored and lines starting with a \*(C`#\*(C' are treated as comments and are also ignored.</p><h3>Types map file</h3>
<p>Contains the mapping from C type to Perl classes.</p><p>Format is the name of the C type followed by the name of the Perl class or the \s-1XS\s0 type specifier, separated by a \*(C`|\*(C'. Example:</p><p>    int                 | IV     struct request_rec  | Apache::RequestRec</p><p>If you have a Perl class with a single-level namespace (e.g. Apache) you need to postfix it with two colons (e.g. \*(L"Apache::\*(R"). When both a typedef and a structure share the same name, structures must be written as with a \*(L"struct \*(R" prefix (e.g. \*(L"struct foo\*(R".) Addionally, you can give the id for the typemap if you need a special conversion and one or more other names for the struct:</p><p>    struct request_rec  | Apache::RequestRec | T_APACHEOBJ | r</p><p>An optional fifth parameter specifies that the data needs to be copied when assigned to a struct member and selects the way how memory is allocated:</p><p>    char *   | PV | | | strdup</p><p>The actual code for memory allocation is provided inside the structure map, for example:</p><p>    MALLOC=strdup:$dest = ($type)ap_pstrdup(obj -&gt; pool, $src)     MALLOC=malloc:ap_palloc(obj -&gt; pool, $src, sizeof($type)) ; memcpy($dest,$src,sizeof($type))</p><p>This gives two ways to allocate memory and copy the data into it. The fifth parameter in the type map selects which of these two should be used. $src, $dest and $type are replaced by the source, the destination and the type. \*(C`obj\*(C' is a pointer to the C-structure.</p><p><em>Special Types</em></p>
<dl class='dl-vertical'>
  <dt>
    String, \s-1PV\s0 and PVnull
  </dt>
  <dd>
    <p>A string is represented in C as a pointer to an null terminated range of characters. In Perl the it is called \*(C`PV\*(C' (pointer value). When converting a Perl \*(C`undef\*(C' to a C string Perl by default converts it to an empty string. While this is save, this is not always what is required, because many C interfaces treat \s-1NULL\s0 as a special case. For this reason the \*(C`PVnull\*(C' type is introduced, which converts \*(C`undef\*(C' to \*(C`NULL\*(C' and \*(C`NULL\*(C' to \*(C`undef\*(C'. To make it work you need the following line in your type map file:         PVnull          | PVnull | | | strdup Now you can defines any type, structure memeber or function argument as type \*(C`PVnull\*(C'.</p>
  </dd>

</dl>

<h3>Functions map file</h3>
<p>Contains the mapping from C functions to Perl functions. This can be used to reorder arguments, tell XSBuilder which arguments are return values, and in which Perl package the function will be created.</p><p>There are some directives which affect the function mappings that follow it. Each directive may appear in the file more than once.</p>
<dl class='dl-vertical'>
  <dt>
    \s-1MODULE\s0
  </dt>
  <dd>
    <p>the module name (file name) where the function should be defined, e.g.     MODULE=Apache::Connection will define the functions that follow in files named Apache/Connection.{pm,xs}</p>
  </dd>
  <dt>
    \s-1PACKAGE\s0
  </dt>
  <dd>
    <p>The name of the package that functions are defined in. If undefined, \s-1PACKAGE\s0 defaults to the value of \s-1MODULE\s0. A value of 'guess' indicates that package name should be guessed based on first argument found that maps to a Perl class. Falls back on the prefix (ap_ -&gt; Apache, apr_ -&gt; \s-1APR\s0).</p>
  </dd>
  <dt>
    \s-1PREFIX\s0
  </dt>
  <dd>
    <p>The prefix to be stripped from C functions when creating the \s-1XS\s0 stubs. Defaults to the value of \s-1PACKAGE\s0, converted to C naming convention. For example,     PREFIX=APR::Base64 will strip \*(C`apr_base64_\*(C' from the C functions. If the prefix does not match, it defaults to \*(C`ap_\*(C' or \*(C`apr_\*(C'.</p>
  </dd>

</dl>
<p><strong>\s-1NOTE:\s0</strong> You must have at least one \*(C`MODULE\*(C' definition otherwise all functions will be ignored.</p><p>The format of entries is:</p><p>    C function name | dispatch function name (dispatch argspec) | argspec | Perl alias</p><p>The \*(C`dispatch function name\*(C' (the C function that is actually called) defaults to C function name. If the dispatch function name is just a prefix (mpxs_, \s-1MPXS_\s0), the \*(C`C function name\*(C' is appended to it. The return type may be specified before the \*(C`C function name\*(C', and defaults to the \*(C`return_type\*(C' in the \*(C`{foo}::FunctionTable\*(C' module generated by the \*(C`ParseSource\*(C' module.</p><p>The \*(C`dispatch argspec\*(C' is optional. If supplied, it can be used to pass different parameters to the dispatch function then to the \s-1XS\s0 function. If the function name begins with \*(C`DEFINE_\*(C', a new function is defined (for defining functions that are not parsed from the source). \*(C`argspec\*(C' must be supplied. \*(C`DEFINE_\*(C' is not included in the generated function name.</p><p>The \*(C`argspec\*(C' defaults to arguments in \*(C`{foo}::FunctionTable\*(C', as generated by the \*(C`ParseSource\*(C' module. Argument types can be specified to override those in the \*(C`{foo}::FunctionTable\*(C'. Default values can also be specified, e.g. arg=default_value</p><p>For example:</p>
<pre>
  ap_get_client_block   | mpxs_ | r, \s-1SV\s0 *:buffer, bufsiz
  ap_setup_client_block |       | r, read_policy=REQUEST_CHUNKED_ERROR
  ap_make_array      | ap_make_array(r-&gt;pool, nelts, elt_size) | request_rec *:r, nelts, elt_size
</pre>
<p>argspec of '...' indicates passthru, calling the function with</p><p>    (aTHX_ I32 items, SP **sp, SV **MARK)</p><p>To mark an argument as return only you can prefix it with &lt; e.g.</p><p>    dav_open_lockdb | | r, ro, &lt;lockdb</p><p>will be called as ($error get the return value of the C function)</p><p>    ($error, $lockdb) = $r -&gt; open_lockdb (0) ;</p><p>The return argument (e.g. lockdb) will always be passed by address to the function.</p><p>The function alias, if defined, will be created in the current \*(C`PACKAGE\*(C'.</p><p>Function names on lines that do not begin with a word character or a single space are skipped. Function names can be prefixed with the following symbols:</p><p>    &apos;!&apos; =&gt; &apos;disabled or not yet implemented&apos;,     &apos;~&apos; =&gt; &apos;implemented but not auto-generated&apos;,     &apos;-&apos; =&gt; &apos;likely never be available to Perl&apos;,     &apos;&gt;&apos; =&gt; &apos;"private" to your C library&apos;,     &apos;?&apos; =&gt; &apos;unclassified&apos;,</p>
<h3>Structures map file</h3>
<p>Contains the mapping from C structures to Perl classes and defines the members for which access methods should be created. A \*(C`new\*(C' method may be specified, if desired. The format looks like the following:</p><p>    &lt;struct_name&gt;       member1       member2       new     &lt;/struct_name&gt;</p><p>An optional module name can be given, to specify in which module the code should be placed. To place the structure in My::Module, for example, specify:</p><p>    &lt;struct_name MODULE=My::Module&gt;</p><p>For all members that are listed here, XSBuilder will generate an access method to read and write it's content. If you want to name the perl access method differently than the C member, you can write</p><p>   cMemberValue | member_value | type</p><p>this will map the \*(C`cMemberValue\*(C' structure member to the access function \*(C`member_value\*(C'. The default is to use the same name in Perl as in C. As third argument you can give a typename. This defaults to the type of the variable. It can be used to specify a different type, for special conversion needs. (e.g. \s-1PV\s0 versus PVnull) If you give the \*(C`new\*(C' member, XSBuilder will create a new method for that class, which can be used to create a new instance and initialize it with data.</p>
<h3>Callbacks map file</h3>
<p>The format of entries is:</p><p>    C function name | argspec</p><p>The content is the same as function map, it but contains the callbacks.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Additional generated methods</h2>
        <div class="sectioncontent">
<p>For structures, XSBuilder will generate two additional methods: \*(C`new\*(C', and \*(C`init_callbacks\*(C'.</p><h3>new ($initialvalue)</h3>
<p>With \*(C`new\*(C' you can create a new Perl object for an C structure. Optionally, you can pass either a hashref with initial data, or another object, who's data will be copied into the new object.</p>
<h3>init_callbacks</h3>
<p>\*(C`init_callbacks\*(C' should be called during object initialization. It will fill in all callback members of a structure with pointers that cause a method call into the object, when the callback is called from C.</p><p>You can call it either with</p><p>    $obj -&gt; init_callbacks</p><p>or</p><p>    MyModule -&gt; init_callbacks ($obj) ;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Callbacks</h2>
        <div class="sectioncontent">
<p>A callback which is part of a structure will cause a call to the method with the same name as the structure member, prefixed with \*(C`cb_\*(C'. For example, if you have a structure member named \*(C`open\*(C', then the Perl method \*(C`cb_open\*(C' will be called whenever the C code calls the callback.</p><p>If you want to call the callback on your own you need to call the method which is called like the structure member, e.g. \*(C`open\*(C'.</p><p>\s-1NOTE:\s0 You need to call \*(C`init_callbacks\*(C' during your method initialzation to be able to call callbacks.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ExtUtils::F77.3pm.html"><span aria-hidden="true">&larr;</span> ExtUtils::F77.3pm: Simple interface to f77 libs</a></li>
   <li class="next"><a href="ExtUtils::XSBuilder::ParseSource.3pm.html">ExtUtils::XSBuilder::ParseSource.3pm: Parse c source files <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

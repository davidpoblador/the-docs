<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTML::SimpleParse: A bare-bones html parser</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A bare-bones html parser">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="HTML::SimpleParse (3pm) manual">
  <meta name="twitter:description" content="A bare-bones html parser">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhtml-simpleparse-perl-HTML::SimpleParse-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/HTML::SimpleParse.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HTML::SimpleParse (3pm) manual" />
  <meta property="og:description" content="A bare-bones html parser" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhtml-simpleparse-perl-HTML::SimpleParse-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">HTML::SimpleParse<small> (3pm)</small></h1>
        <p class="lead">A bare-bones html parser</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::SimpleParse.3pm.html">
      <span itemprop="name">HTML::SimpleParse: A bare-bones html parser</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhtml-simpleparse-perl/">
      <span itemprop="name">libhtml-simpleparse-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::SimpleParse.3pm.html">
      <span itemprop="name">HTML::SimpleParse: A bare-bones html parser</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use HTML::SimpleParse;

 # Parse the text into a simple tree
 my $p = new HTML::SimpleParse( $html_text );
 $p-&gt;output;                 # Output the HTML verbatim

 $p-&gt;text( $new_text );      # Give it some new HTML to chew on
 $p-&gt;parse                   # Parse the new HTML
 $p-&gt;output;

 my %attrs = HTML::SimpleParse-&gt;parse_args(&apos;A="xx" B=3&apos;);
 # %attrs is now (&apos;A&apos; =&gt; &apos;xx&apos;, &apos;B&apos; =&gt; &apos;3&apos;)
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is a simple \s-1HTML\s0 parser.  It is similar in concept to HTML::Parser, but it differs from HTML::TreeBuilder in a couple of important ways.</p><p>First, HTML::TreeBuilder knows which tags can contain other tags, which start tags have corresponding end tags, which tags can exist only in the &lt;\s-1HEAD\s0&gt; portion of the document, and so forth.  HTML::SimpleParse does not know any of these things.  It just finds tags and text in the \s-1HTML\s0 you give it, it does not care about the specific content of these tags (though it does distiguish between different _types_ of tags, such as comments, starting tags like &lt;b&gt;, ending tags like &lt;/b&gt;, and so on).</p><p>Second, HTML::SimpleParse does not create a hierarchical tree of \s-1HTML\s0 content, but rather a simple linear list.  It does not pay any attention to balancing start tags with corresponding end tags, or which pairs of tags are inside other pairs of tags.</p><p>Because of these characteristics, you can make a very effective \s-1HTML\s0 filter by sub-classing HTML::SimpleParse.  For example, to remove all comments from \s-1HTML:\s0</p><p> package NoComment;  use HTML::SimpleParse;  @ISA = qw(HTML::SimpleParse);  sub output_comment {}</p><p> package main;  NoComment-&gt;new($some_html)-&gt;output;</p><p>Historically, I started the HTML::SimpleParse project in part because of a misunderstanding about HTML::Parser's functionality.  Many aspects of these two modules actually overlap.  I continue to maintain the HTML::SimpleParse module because people seem to be depending on it, and because beginners sometimes find HTML::SimpleParse to be simpler than HTML::Parser's more powerful interface.  People also seem to get a fair amount of usage out of the \*(C`parse_args()\*(C' method directly.</p><h3>Methods</h3>
<ul>
<li><p>new  $p = new HTML::SimpleParse( $some_html ); Creates a new HTML::SimpleParse object.  Optionally takes one argument, a string containing some \s-1HTML\s0 with which to initialize the object.  If you give it a non-empty string, the \s-1HTML\s0 will be parsed into a tree and ready for outputting. Can also take a list of attributes, such as  $p = new HTML::SimpleParse( $some_html, &apos;fix_case&apos; =&gt; -1); See the \*(C`parse_args()\*(C' method below for an explanation of this attribute.</p></li><li><p>text  $text = $p-&gt;text;  $p-&gt;text( $new_text ); Get or set the contents of the \s-1HTML\s0 to be parsed.</p></li><li><p>tree  foreach ($p-&gt;tree) { ... } Returns a list of all the nodes in the tree, in case you want to step through them manually or something.  Each node in the tree is an anonymous hash with (at least) three data members, $node-&gt;{type} (is this a comment, a start tag, an end tag, etc.), $node-&gt;{content} (all the text between the angle brackets, verbatim), and $node-&gt;{offset} (number of bytes from the beginning of the string). The possible values of $node-&gt;{type} are \*(C`text\*(C', \*(C`starttag\*(C', \*(C`endtag\*(C', \*(C`ssi\*(C', and \*(C`markup\*(C'.</p></li><li><p>parse  $p-&gt;parse; Once an object has been initialized with some text, call $p-&gt;parse and a tree will be created.  After the tree is created, you can call $p-&gt;output. If you feed some text to the <em>new()</em> method, parse will be called automatically during your object's construction.</p></li><li><p>parse_args  %hash = $p-&gt;parse_args( $arg_string ); This routine is handy for parsing the contents of an \s-1HTML\s0 tag into key=value pairs.  For instance:   $text = &apos;type=checkbox checked name=flavor value="chocolate or strawberry"&apos;;   %hash = $p-&gt;parse_args( $text );   # %hash is ( TYPE=&gt;&apos;checkbox&apos;, CHECKED=&gt;undef, NAME=&gt;&apos;flavor&apos;,   #            VALUE=&gt;&apos;chocolate or strawberry&apos; ) Note that the position of the last m//g search on the string (the value returned by Perl's <em>pos()</em> function) will be altered by the parse_args function, so make sure you take that into account if (in the above example) you do \*(C`$text =~ m/something/g\*(C'. The <em>parse_args()</em> method can be run as either an object method or as a class method, i.e. as either $p-&gt;parse_args(...) or HTML::SimpleParse-&gt;parse_args(...). \s-1HTML\s0 attribute lists are supposed to be case-insensitive with respect to attribute names.  To achieve this behavior, <em>parse_args()</em> respects the 'fix_case' flag, which can be set either as a package global $FIX_CASE, or as a class member datum 'fix_case'.  If set to 0, no case conversion is done.  If set to 1, all keys are converted to upper case.  If set to -1, all keys are converted to lower case.  The default is 1, i.e. all keys are uppercased. If an attribute takes no value (like \*(L"checked\*(R" in the above example) then it will still have an entry in the returned hash, but its value will be \*(C`undef\*(C'. For example:   %hash = $p-&gt;parse_args(&apos;type=checkbox checked name=banana value=""&apos;);   # $hash{CHECKED} is undef, but $hash{VALUE} is "" This method actually returns a list (not a hash), so duplicate attributes and order will be preserved if you want them to be:  @hash = $p-&gt;parse_args("name=family value=gwen value=mom value=pop");  # @hash is qw(NAME family VALUE gwen VALUE mom VALUE pop)</p></li><li><p>output  $p-&gt;output; This will output the contents of the \s-1HTML\s0, passing the real work off to the output_text, output_comment, etc. functions.  If you do not override any of these methods, this module will output the exact text that it parsed into a tree in the first place.</p></li><li><p>get_output  print $p-&gt;get_output Similar to $p-&gt;<em>output()</em>, but returns its result instead of printing it.</p></li><li><p>execute  foreach ($p-&gt;tree) {     print $p-&gt;execute($_);  } Executes a single node in the \s-1HTML\s0 parse tree.  Useful if you want to loop through the nodes and output them individually.</p></li>
</ul><p>The following methods do the actual outputting of the various parts of the \s-1HTML\s0.  Override some of them if you want to change the way the \s-1HTML\s0 is output.  For instance, to strip comments from the \s-1HTML\s0, override the output_comment method like so:</p><p> # In subclass:  sub output_comment { }  # Does nothing</p><ul>
<li><p>output_text</p></li><li><p>output_comment</p></li><li><p>output_endtag</p></li><li><p>output_starttag</p></li><li><p>output_markup</p></li><li><p>output_ssi</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>Please do not assume that the interface here is stable.  This is a first pass, and I'm still trying to incorporate suggestions from the community.  If you employ this module somewhere, make doubly sure before upgrading that none of your code breaks when you use the newer version.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<ul>
<li><p>Embedded &gt;s are broken Won't handle tags with embedded &gt;s in them, like &lt;input name=expr value=\*(L"x &gt; y\*(R"&gt;.  This will be fixed in a future version, probably by using the parse_args method.  Suggestions are welcome.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TO DO</h2>
        <div class="sectioncontent">
<ul>
<li><p>extensibility Based on a suggestion from Randy Harmon (thanks), I'd like to make it easier for subclasses of SimpleParse to pick out other kinds of \s-1HTML\s0 blocks, i.e. extend the set {text, comment, endtag, starttag, markup, ssi} to include more members.  Currently the only easy way to do that is by overriding the \*(C`parse\*(C' method:  sub parse {  # In subclass     my $self = $_[0];     $self-&gt;SUPER::parse(@_);     foreach ($self-&gt;tree) {        if ($_-&gt;{content} =~ m#^a&#92;s+#i) {           $_-&gt;{type} = &apos;anchor_start&apos;;        }     }  }</p><p> sub output_anchor_start {     # Whatever you want...  } Alternatively, this feature might be implemented by hanging attatchments onto the parsing loop, like this:  my $parser = new SimpleParse( $html_text );  $regex = &apos;&lt;(a&#92;s+.*?)&gt;&apos;;  $parser-&gt;watch_for( &apos;anchor_start&apos;, $regex );</p><p> sub SimpleParse::output_anchor_start {     # Whatever you want...  } I think I like that idea better.  If you wanted to, you could make a subclass with output_anchor_start as one of its methods, and put the -&gt;watch_for stuff in the constructor.</p></li><li><p>reading from filehandles It would be nice if you could initialize an object by giving it a filehandle or filename instead of the text itself.</p></li><li><p>tests I need to write a few tests that run under \*(L"make test\*(R".</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Ken Williams &lt;ken@forum.swarthmore.edu&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 1998 Swarthmore College.  All rights reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="HTML::RewriteAttributes::Resources.3pm.html"><span aria-hidden="true">&larr;</span> HTML::RewriteAttributes::Resources.3pm: Concise resource-link rewriting</a></li>
   <li class="next"><a href="HTML::Stream.3pm.html">HTML::Stream.3pm: Html output stream class, and some markup utilities <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

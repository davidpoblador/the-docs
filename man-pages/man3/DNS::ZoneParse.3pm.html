<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DNS::ZoneParse: Parse and manipulate dns zone files.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parse and manipulate dns zone files.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="DNS::ZoneParse (3pm) manual">
  <meta name="twitter:description" content="Parse and manipulate dns zone files.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdns-zoneparse-perl-DNS::ZoneParse-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/DNS::ZoneParse.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="DNS::ZoneParse (3pm) manual" />
  <meta property="og:description" content="Parse and manipulate dns zone files." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdns-zoneparse-perl-DNS::ZoneParse-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">DNS::ZoneParse<small> (3pm)</small></h1>
        <p class="lead">Parse and manipulate dns zone files.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DNS::ZoneParse.3pm.html">
      <span itemprop="name">DNS::ZoneParse: Parse and manipulate dns zone files.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdns-zoneparse-perl/">
      <span itemprop="name">libdns-zoneparse-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DNS::ZoneParse.3pm.html">
      <span itemprop="name">DNS::ZoneParse: Parse and manipulate dns zone files.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use DNS::ZoneParse;

    my $zonefile = DNS::ZoneParse-&gt;new("/path/to/dns/zonefile.db", $origin);

    # Get a reference to the MX records
    my $mx = $zonefile-&gt;mx;

    # Change the first mailserver on the list
    $mx-&gt;[0] = { host =&gt; &apos;mail.localhost.com&apos;,
                 priority =&gt; 10,
                 name =&gt; &apos;@&apos; };

    # update the serial number
    $zonefile-&gt;new_serial();

    # write the new zone file to disk
    my $newzone;
    open($newzone, &apos;&gt;&apos;, &apos;/path/to/dns/zonefile.db&apos;) or die "error";
    print $newzone $zonefile-&gt;output();
    close $newzone;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTALLATION</h2>
        <div class="sectioncontent">
<p>   perl Makefile.PL    make    make test    make install</p><p>Win32 users substitute \*(L"make\*(R" with \*(L"nmake\*(R" or equivalent. nmake is available at http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/Nmake15.exe</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module will parse a Zone File and put all the Resource Records (RRs) into an anonymous hash structure. Various record types are supported, see the methods section for details. It could be useful for maintaining \s-1DNS\s0 zones, or for transferring \s-1DNS\s0 zones to other servers. If you want to generate an XML-friendly version of your zone files, it is easy to use XML::Simple with this module once you have parsed the zone file.</p><p>DNS::ZoneParse scans the \s-1DNS\s0 zone file - removes comments and seperates the file into its constituent records. It then parses each record and stores the records internally. See below for information on the accessor methods.</p><h3>\s-1METHODS\s0</h3>

<dl class='dl-vertical'>
  <dt>
    new
  </dt>
  <dd>
    <p>This creates the DNS::ZoneParse object and loads the zone file. Example:</p>
<pre>
    my $zonefile = DNS::ZoneParse-&gt;new(\*(L"/path/to/zonefile.db\*(R");
</pre>
<p>You can also initialise the object with the contents of a file:</p>
<pre>
    my $zonefile = DNS::ZoneParse-&gt;new( &#92;$zone_contents );
</pre>
<p>You can pass a second, optional parameter to the constructor to supply an $origin if none can be found in the zone file.     my $zonefile = DNS::ZoneParse-&gt;new( &#92;$zone_contents, $origin ); You can pass a third, optional parameter to the constructor to supply a callback which will be called whenever an unparsable line is encountered in the zone file. See \*(C`on_unparseable_line\*(C' for details on this parameter and how errors are handled when parsing zone files. If you plan to pass a on_unparseable_line callback but do not wish to specify an $origin, pass 'undef' as the $origin parameter.</p>
  </dd>
  <dt>
    a(), <em>cname()</em>, <em>srv()</em>, <em>mx()</em>, <em>ns()</em>, <em>ptr()</em>, <em>txt()</em>, <em>hinfo()</em>, <em>rp()</em>, <em>loc()</em>
  </dt>
  <dd>
    <p>These methods return references to the resource records. For example:     my $mx = $zonefile-&gt;mx; Returns the mx records in an array reference. All records (except \s-1SOA\s0) have the following properties: 'ttl', 'class', 'host', 'name', '\s-1ORIGIN\s0'. \s-1MX\s0 records also have a 'priority' property. \s-1SRV\s0 records also have 'priority', 'weight' and 'port' properties. \s-1TXT\s0 records also have a 'text' property representing the record's 'txt-data' descriptive text. \s-1HINFO\s0 records also have 'cpu' and 'os' properties. \s-1RP\s0 records also have 'mbox' and 'text' properties. \s-1LOC\s0 records also have 'd1', 'm1', 's1', 'NorS', 'd2', 'm2', 's2', 'EorW', 'alt', 'siz', 'hp', and 'vp', as per \s-1RFC\s0 1876. If there are no records of a given type in the zone, the call will croak with an error message about an invalid method. (This is not an ideal behavior, but has been kept for backwards compatibility.) The '\s-1ORIGIN\s0' property is the fully-qualified origin of the record. See fqname for details on constructing a fully qualified domain name. Note: for \s-1SOA\s0 records, the '\s-1ORIGIN\s0' will match the 'origin' property when the \s-1SOA\s0 record is specified as fully qualified.</p>
  </dd>
  <dt>
    <em>soa()</em>
  </dt>
  <dd>
    <p>Returns a hash reference with the following properties: 'serial', 'origin', 'primary', 'refresh', 'retry', 'ttl', 'minimumTTL', 'email', 'expire', 'class', '\s-1ORIGIN\s0'. The '\s-1ORIGIN\s0' property is returned separate from 'origin' property, though the data may be the same. '\s-1ORIGIN\s0' represents the implicit origin for the record while 'origin' represents the origin specified on the \s-1SOA\s0 line in the file. If the 'origin' value is relative (that is, does not end with a '.'), the actual zone for which the \s-1SOA\s0 line applies must be computed by concatenating the 'origin' and '\s-1ORIGIN\s0' values. See fqname for details. If the 'origin' value is absolute, no computation is necessary and 'origin' is the same as '\s-1ORIGIN\s0'.</p>
  </dd>
  <dt>
    <em>generate()</em>
  </dt>
  <dd>
    <p>Returns an array of hashes representing $GENERATE directives present in the zone. Note, $GENERATE directives are BIND-specific additions. They are not expanded by DNS::ZoneParse, but users are able to access and modify these directives. The following properties are returned: 'range', 'lhs', 'ttl', 'class', 'type', 'rhs', '\s-1ORIGIN\s0'. See the \s-1BIND\s0 documentation for details on the syntax and usage of the $GENERATE directive.</p>
  </dd>
  <dt>
    dump
  </dt>
  <dd>
    <p>Returns a copy of the datastructute that stores all the resource records. This might be useful if you want to quickly transform the data into another format, such as \s-1XML\s0.</p>
  </dd>
  <dt>
    fqname
  </dt>
  <dd>
    <p>Takes a single parameter, a hash reference containing a record. Returns the fully qualified name of this record, with a trailing '.'. In most cases this is as simple as concatenating the 'name' and '\s-1ORIGIN\s0' with a '.' unless 'name' is '@', in which case the fqname is simply the '\s-1ORIGIN\s0'. For \s-1SOA\s0 records, the same process is performed on the 'origin' instead of 'name'. Please note, fqname will not expand the right hand side of a record (ie, \s-1CNAME\s0, \s-1SOA\s0, \s-1MX\s0, etc). The user must expand these values via the above method.</p>
  </dd>
  <dt>
    ttl_to_int
  </dt>
  <dd>
    <p>Takes a single parameter, a string representing a valid record \s-1TTL\s0. Returns an integer representing the number of seconds the \s-1TTL\s0 represents. Note, this does not take into account any leap-years, leap-seconds, \s-1DST\s0 changes, etc. It is simply the count of the number of seconds in the specified period of time.</p>
  </dd>
  <dt>
    new_serial
  </dt>
  <dd>
    <p>\*(C`new_serial()\*(C' incriments the Zone serial number. It will generate a date-based serial number. Or you can pass a positive number to add to the current serial number. Examples:     $zonefile-&gt;new_serial();             # generates a new serial number based on date:             # YYYYmmddHH format, incriments current serial             # by 1 if the new serial is still smaller</p><p>    $zonefile-&gt;new_serial(50);             # adds 50 to the original serial number</p>
  </dd>
  <dt>
    output
  </dt>
  <dd>
    <p>\*(C`output()\*(C' returns the new zone file output as a string. If you wish your output formatted differently, you can pass the output of \*(C`dump()\*(C' to your favourite templating module.</p>
  </dd>
  <dt>
    last_parse_error_count
  </dt>
  <dd>
    <p>Returns a count of the number of unparsable lines from the last time a zone file was parsed. If no zone file has been parsed yet, returns 0. If you want to be sure that a zone file was parsed completely and without error, the return value of this method should be checked after the constructor is called (or after a call to _parse).</p>
  </dd>
  <dt>
    on_unparseable_line
  </dt>
  <dd>
    <p>\*(C`on_unparseable_line()\*(C' is an accessor method for the callback used when an unparseable line is encountered while parsing a zone file. If not set, DNS::ZoneParse will \*(C`croak\*(C' when an unparsable line is encountered, but will continue to parse the file. Each time an unparsable line is encountered, an internal counter is incrememnted. See \*(C`last_parse_error_count\*(C' for details. The callback is passed four parameters, a reference to the DNS::ZoneParse object which is doing the parsing, the text of the line that is unable to be parsed, the text of the reason the line could not be parsed, and the text of the last successfully parsed line. If you want to abort parsing when an unparsable line is found, call \*(C`die\*(C' from within your callback and catch that die with an eval block around the DNS::ZoneParse constructor (or call to _parse). The method takes a single optional parameter, a code reference to the function that will be called when an unparsable line is reached. Returns a reference to the last callback. If passed an undefined value, a reference to the current callback is returned. If passed any other value, undef is returned.</p>
  </dd>

</dl>

<h3>\s-1EXAMPLES\s0</h3>
<p>This script will print the A records in a zone file, add a new A record for the name \*(L"new\*(R" and then return the zone file.</p><p>    use strict;     use DNS::ZoneParse;</p><p>    my $zonefile = DNS::ZoneParse-&gt;new("/path/to/zonefile.db");</p><p>    print "Current A Records&#92;n";     my $a_records = $zonefile-&gt;a();</p><p>    foreach my $record (@$a_records) {         print "$record-&gt;{name} resolves at $record-&gt;{host}&#92;n";     }</p><p>    push (@$a_records, { name =&gt; &apos;new&apos;, class =&gt; &apos;IN&apos;,                          host =&gt; &apos;127.0.0.1&apos;, ttl =&gt; &apos;&apos; });</p><p>    $zonefile-&gt;new_serial();     my $newfile = $zonefile-&gt;output();</p><p>This script will convert a \s-1DNS\s0 Zone file to an \s-1XML\s0 file using XML::Simple.</p><p>    use strict;     use DNS::ZoneParse;     use XML::Simple;</p><p>    my $zonefile = DNS::ZoneParse-&gt;new("/path/to/zonefile.db");</p><p>    my $new_xml = XMLout($zonefile-&gt;dump,                          noattr =&gt; 1,                          suppressempty =&gt; 1,                          rootname =&gt; $zonefile-&gt;origin);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHANGES</h2>
        <div class="sectioncontent">
<p>See <em>Changes</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API</h2>
        <div class="sectioncontent">
<p>The DNS::ZoneParse \s-1API\s0 may change in future versions. At present, the parsing is not as strict as it should be and support for $ORIGIN and $TTL is quite basic. It would also be nice to support the \*(C`INCLUDE\*(C' statement. Furthermore, parsing large zone files with thousands of records can use lots of memory - some people have requested a callback interface.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>I can squash more bugs with your help. Please let me know if you spot something that doesn't work as expected.</p><p>You can report bugs via the \s-1CPAN\s0 \s-1RT:\s0 http://rt.cpan.org/NoAuth/Bugs.html?Dist=DNS-ZoneParse &lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=DNS-ZoneParse&gt;</p><p>If possible, please provide a diff against <em>t/dns-zoneparse.t</em> and <em>t/test-zone.db</em> that demonstrates the bug(s).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO DNS::ZoneParse&hellip;</h2>
        <div class="sectioncontent">
<p>Other modules with similar functionality:</p><p>Net::DNS::ZoneParser, Net::DNS::ZoneFile, DNS::ZoneFile</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Simon Flack</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAINTENANCE</h2>
        <div class="sectioncontent">
<p>Maintainers: Mike Schilli (m@perlmeister.com), John Eaglesham (perl@8192.net).</p><p>Bug queue: http://rt.cpan.org/Public/Dist/Display.html?Name=DNS-ZoneParse</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>DNS::ZoneParse is free software which you can redistribute and/or modify under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="DIME::Tools.3pm.html"><span aria-hidden="true">&larr;</span> DIME::Tools.3pm: Modules for parsing and generate dime messages</a></li>
   <li class="next"><a href="DPKG::Log.3pm.html">DPKG::Log.3pm: Parse the dpkg log <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

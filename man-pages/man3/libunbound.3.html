<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libunbound: Unbound dns validating resolver 1.4.22 functions.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Unbound dns validating resolver 1.4.22 functions.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libunbound (3) manual">
  <meta name="twitter:description" content="Unbound dns validating resolver 1.4.22 functions.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libunbound-dev-libunbound-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libunbound.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libunbound (3) manual" />
  <meta property="og:description" content="Unbound dns validating resolver 1.4.22 functions." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libunbound-dev-libunbound-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libunbound<small> (3)</small></h1>
        <p class="lead">Unbound dns validating resolver 1.4.22 functions.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libunbound.3.html">
      <span itemprop="name">libunbound: Unbound dns validating resolver 1.4.22 functions.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libunbound-dev/">
      <span itemprop="name">libunbound-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libunbound.3.html">
      <span itemprop="name">libunbound: Unbound dns validating resolver 1.4.22 functions.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;unbound.h&gt;</strong></p><p><em>struct ub_ctx *</em> <strong>ub_ctx_create</strong>(<em>void</em>);</p><p><em>void</em> <strong>ub_ctx_delete</strong>(<em>struct ub_ctx*</em> ctx);</p><p><em>int</em> <strong>ub_ctx_set_option</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> opt, <em>char*</em> val);</p><p><em>int</em> <strong>ub_ctx_get_option</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> opt, <em>char**</em> val);</p><p><em>int</em> <strong>ub_ctx_config</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> fname);</p><p><em>int</em> <strong>ub_ctx_set_fwd</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> addr);</p><p><em>int</em> <strong>ub_ctx_resolvconf</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> fname);</p><p><em>int</em> <strong>ub_ctx_hosts</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> fname);</p><p><em>int</em> <strong>ub_ctx_add_ta</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> ta);</p><p><em>int</em> <strong>ub_ctx_add_ta_file</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> fname);</p><p><em>int</em> <strong>ub_ctx_trustedkeys</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> fname);</p><p><em>int</em> <strong>ub_ctx_debugout</strong>(<em>struct ub_ctx*</em> ctx, <em>FILE*</em> out);</p><p><em>int</em> <strong>ub_ctx_debuglevel</strong>(<em>struct ub_ctx*</em> ctx, <em>int</em> d);</p><p><em>int</em> <strong>ub_ctx_async</strong>(<em>struct ub_ctx*</em> ctx, <em>int</em> dothread);</p><p><em>int</em> <strong>ub_poll</strong>(<em>struct ub_ctx*</em> ctx);</p><p><em>int</em> <strong>ub_wait</strong>(<em>struct ub_ctx*</em> ctx);</p><p><em>int</em> <strong>ub_fd</strong>(<em>struct ub_ctx*</em> ctx);</p><p><em>int</em> <strong>ub_process</strong>(<em>struct ub_ctx*</em> ctx);</p><p><em>int</em> <strong>ub_resolve</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> name,</p>
<pre>
           <em>int</em> rrtype, <em>int</em> rrclass, <em>struct ub_result**</em> result);
</pre>
<p><em>int</em> <strong>ub_resolve_async</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> name,</p>
<pre>
                 <em>int</em> rrtype, <em>int</em> rrclass, <em>void*</em> mydata,
</pre>

<pre>
                 <em>ub_callback_t</em> callback, <em>int*</em> async_id);
</pre>
<p><em>int</em> <strong>ub_cancel</strong>(<em>struct ub_ctx*</em> ctx, <em>int</em> async_id);</p><p><em>void</em> <strong>ub_resolve_free</strong>(<em>struct ub_result*</em> result);</p><p><em>const char *</em> <strong>ub_strerror</strong>(<em>int</em> err);</p><p><em>int</em> <strong>ub_ctx_print_local_zones</strong>(<em>struct ub_ctx*</em> ctx);</p><p><em>int</em> <strong>ub_ctx_zone_add</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> zone_name, <em>char*</em> zone_type);</p><p><em>int</em> <strong>ub_ctx_zone_remove</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> zone_name);</p><p><em>int</em> <strong>ub_ctx_data_add</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> data);</p><p><em>int</em> <strong>ub_ctx_data_remove</strong>(<em>struct ub_ctx*</em> ctx, <em>char*</em> data);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>Unbound</strong> is an implementation of a DNS resolver, that does caching and DNSSEC validation. This is the library API, for using the -lunbound library. The server daemon is described in <a href="../man8/unbound.8.html"><strong>unbound</strong>(8)</a>. The library can be used to convert hostnames to ip addresses, and back, and obtain other information from the DNS. The library performs public-key validation of results with DNSSEC.</p><p>The library uses a variable of type <em>struct ub_ctx</em> to keep context between calls. The user must maintain it, creating it with <strong>ub_ctx_create</strong> and deleting it with <strong>ub_ctx_delete</strong>. It can be created and deleted at any time. Creating it anew removes any previous configuration (such as trusted keys) and clears any cached results.</p><p>The functions are thread-safe, and a context an be used in a threaded (as well as in a non-threaded) environment. Also resolution (and validation) can be performed blocking and non-blocking (also called asynchronous). The async method returns from the call immediately, so that processing can go on, while the results become available later.</p><p>The functions are discussed in turn below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>ub_ctx_create</strong></p>
  </dt>
  <dd>
    <p>Create a new context, initialised with defaults. The information from /etc/resolv.conf and /etc/hosts is not utilised by default. Use <strong>ub_ctx_resolvconf</strong> and <strong>ub_ctx_hosts</strong> to read them. Before you call this, use the openssl functions CRYPTO_set_id_callback and CRYPTO_set_locking_callback to set up asyncronous operation if you use lib openssl (the application calls these functions once for initialisation).</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_delete</strong></p>
  </dt>
  <dd>
    <p>Delete validation context and free associated resources. Outstanding async queries are killed and callbacks are not called for them.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_set_option</strong></p>
  </dt>
  <dd>
    <p>A power-user interface that lets you specify one of the options from the config file format, see <a href="../man5/unbound.conf.5.html"><strong>unbound.conf</strong>(5)</a>. Not all options are relevant. For some specific options, such as adding trust anchors, special routines exist. Pass the option name with the trailing ':'.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_get_option</strong></p>
  </dt>
  <dd>
    <p>A power-user interface that gets an option value.  Some options cannot be gotten, and others return a newline separated list.  Pass the option name without trailing ':'.  The returned value must be <strong>free</strong>(2)d by the caller.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_config</strong></p>
  </dt>
  <dd>
    <p>A power-user interface that lets you specify an unbound config file, see <a href="../man5/unbound.conf.5.html"><strong>unbound.conf</strong>(5)</a>, which is read for configuration. Not all options are relevant. For some specific options, such as adding trust anchors, special routines exist.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_set_fwd</strong></p>
  </dt>
  <dd>
    <p>Set machine to forward DNS queries to, the caching resolver to use. IP4 or IP6 address. Forwards all DNS requests to that machine, which is expected to run a recursive resolver. If the proxy is not DNSSEC capable, validation may fail. Can be called several times, in that case the addresses are used as backup servers. At this time it is only possible to set configuration before the first resolve is done.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_resolvconf</strong></p>
  </dt>
  <dd>
    <p>By default the root servers are queried and full resolver mode is used, but you can use this call to read the list of nameservers to use from the filename given. Usually "/etc/resolv.conf". Uses those nameservers as caching proxies. If they do not support DNSSEC, validation may fail. Only nameservers are picked up, the searchdomain, ndots and other settings from <a href="../man5/resolv.conf.5.html"><strong>resolv.conf</strong>(5)</a> are ignored. If fname NULL is passed, "/etc/resolv.conf" is used (if on Windows, the system-wide configured nameserver is picked instead). At this time it is only possible to set configuration before the first resolve is done.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_hosts</strong></p>
  </dt>
  <dd>
    <p>Read list of hosts from the filename given. Usually "/etc/hosts". When queried for, these addresses are not marked DNSSEC secure. If fname NULL is passed, "/etc/hosts" is used (if on Windows, etc/hosts from WINDIR is picked instead). At this time it is only possible to set configuration before the first resolve is done.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>ub_ctx_add_ta Add a trust anchor to the given context. At this time it is only possible to add trusted keys before the first resolve is done. The format is a string, similar to the zone-file format, [domainname] [type] [rdata contents]. Both DS and DNSKEY records are accepted.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_add_ta_file</strong></p>
  </dt>
  <dd>
    <p>Add trust anchors to the given context. Pass name of a file with DS and DNSKEY records in zone file format. At this time it is only possible to add trusted keys before the first resolve is done.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_trustedkeys</strong></p>
  </dt>
  <dd>
    <p>Add trust anchors to the given context. Pass the name of a bind-style config file with trusted-keys{}. At this time it is only possible to add trusted keys before the first resolve is done.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_debugout</strong></p>
  </dt>
  <dd>
    <p>Set debug and error log output to the given stream. Pass NULL to disable output. Default is stderr. File-names or using syslog can be enabled using config options, this routine is for using your own stream.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_debuglevel</strong></p>
  </dt>
  <dd>
    <p>Set debug verbosity for the context. Output is directed to stderr. Higher debug level gives more output.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_async</strong></p>
  </dt>
  <dd>
    <p>Set a context behaviour for asynchronous action. if set to true, enables threading and a call to <strong>ub_resolve_async</strong> creates a thread to handle work in the background. If false, a process is forked to handle work in the background. Changes to this setting after <strong>ub_resolve_async</strong> calls have been made have no effect (delete and re-create the context to change).</p>
  </dd>
  <dt>
    <p><strong>ub_poll</strong></p>
  </dt>
  <dd>
    <p>Poll a context to see if it has any new results. Do not poll in a loop, instead extract the fd below to poll for readiness, and then check, or wait using the wait routine. Returns 0 if nothing to read, or nonzero if a result is available. If nonzero, call <strong>ub_process</strong> to do callbacks.</p>
  </dd>
  <dt>
    <p><strong>ub_wait</strong></p>
  </dt>
  <dd>
    <p>Wait for a context to finish with results. Calls <strong>ub_process</strong> after the wait for you. After the wait, there are no more outstanding asynchronous queries.</p>
  </dd>
  <dt>
    <p><strong>ub_fd</strong></p>
  </dt>
  <dd>
    <p>Get file descriptor. Wait for it to become readable, at this point answers are returned from the asynchronous validating resolver. Then call the <strong>ub_process</strong> to continue processing.</p>
  </dd>
  <dt>
    <p><strong>ub_process</strong></p>
  </dt>
  <dd>
    <p>Call this routine to continue processing results from the validating resolver (when the fd becomes readable). Will perform necessary callbacks.</p>
  </dd>
  <dt>
    <p><strong>ub_resolve</strong></p>
  </dt>
  <dd>
    <p>Perform resolution and validation of the target name. The name is a domain name in a zero terminated text string. The rrtype and rrclass are DNS type and class codes. The result structure is newly allocated with the resulting data.</p>
  </dd>
  <dt>
    <p><strong>ub_resolve_async</strong></p>
  </dt>
  <dd>
    <p>Perform asynchronous resolution and validation of the target name. Arguments mean the same as for <strong>ub_resolve</strong> except no data is returned immediately, instead a callback is called later. The callback receives a copy of the mydata pointer, that you can use to pass information to the callback. The callback type is a function pointer to a function declared as</p><ul>
<li><p>void my_callback_function(void* my_arg, int err,</p>
<pre>
                  struct ub_result* result);
</pre>
</li><li><p>The async_id is returned so you can (at your option) decide to track it and cancel the request if needed.  If you pass a NULL pointer the async_id is not returned.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>ub_cancel</strong></p>
  </dt>
  <dd>
    <p>Cancel an async query in progress.  This may return an error if the query does not exist, or the query is already being delivered, in that case you may still get a callback for the query.</p>
  </dd>
  <dt>
    <p><strong>ub_resolve_free</strong></p>
  </dt>
  <dd>
    <p>Free struct ub_result contents after use.</p>
  </dd>
  <dt>
    <p><strong>ub_strerror</strong></p>
  </dt>
  <dd>
    <p>Convert error value from one of the unbound library functions to a human readable string.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_print_local_zones</strong></p>
  </dt>
  <dd>
    <p>Debug printout the local authority information to debug output.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_zone_add</strong></p>
  </dt>
  <dd>
    <p>Add new zone to local authority info, like local-zone <a href="../man5/unbound.conf.5.html"><strong>unbound.conf</strong>(5)</a> statement.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_zone_remove</strong></p>
  </dt>
  <dd>
    <p>Delete zone from local authority info.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_data_add</strong></p>
  </dt>
  <dd>
    <p>Add resource record data to local authority info, like local-data <a href="../man5/unbound.conf.5.html"><strong>unbound.conf</strong>(5)</a> statement.</p>
  </dd>
  <dt>
    <p><strong>ub_ctx_data_remove</strong></p>
  </dt>
  <dd>
    <p>Delete local authority data from the name given.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESULT DATA STRUCTURE</h2>
        <div class="sectioncontent">
<p>The result of the DNS resolution and validation is returned as <em>struct ub_result</em>. The result structure contains the following entries.</p>
<pre>
	struct ub_result {
		char* qname; /* text string, original question */
		int qtype;   /* type code asked for */
		int qclass;  /* class code asked for */
		char** data; /* array of rdata items, NULL terminated*/
		int* len;    /* array with lengths of rdata items */
		char* canonname; /* canonical name of result */
		int rcode;   /* additional error code in case of no data */
		void* answer_packet; /* full network format answer packet */
		int answer_len; /* length of packet in octets */
		int havedata; /* true if there is data */
		int nxdomain; /* true if nodata because name does not exist */
		int secure;  /* true if result is secure */
		int bogus;   /* true if a security failure happened */
		char* why_bogus; /* string with error if bogus */
		int ttl;     /* number of seconds the result is valid */
	};
</pre>
<p>If both secure and bogus are false, security was not enabled for the domain of the query.  Else, they are not both true, one of them is true.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUES</h2>
        <div class="sectioncontent">
<p>Many routines return an error code. The value 0 (zero) denotes no error happened. Other values can be passed to <strong>ub_strerror</strong> to obtain a readable error string. <strong>ub_strerror</strong> returns a zero terminated string. <strong>ub_ctx_create</strong> returns NULL on an error (a malloc failure). <strong>ub_poll</strong> returns true if some information may be available, false otherwise. <strong>ub_fd</strong> returns a file descriptor or -1 on error.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libunbound&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man5/unbound.conf.5.html"><strong>unbound.conf</strong>(5)</a>, <a href="../man8/unbound.8.html"><strong>unbound</strong>(8)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p><strong>Unbound</strong> developers are mentioned in the CREDITS file in the distribution.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libtwofish.3.html"><span aria-hidden="true">&larr;</span> libtwofish.3: Cryptographic library using the twofish algorithm.</a></li>
   <li class="next"><a href="libunwind.3.html">libunwind.3: A (mostly) platform-independent unwind api <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cabin: The utility api of qdbm</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The utility api of qdbm">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="cabin (3) manual">
  <meta name="twitter:description" content="The utility api of qdbm">
  <meta name="twitter:image" content="https://www.carta.tech/images/libqdbm-dev-cabin-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/cabin.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="cabin (3) manual" />
  <meta property="og:description" content="The utility api of qdbm" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libqdbm-dev-cabin-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">cabin<small> (3)</small></h1>
        <p class="lead">The utility api of qdbm</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/cabin.3.html">
      <span itemprop="name">cabin: The utility api of qdbm</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libqdbm-dev/">
      <span itemprop="name">libqdbm-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/cabin.3.html">
      <span itemprop="name">cabin: The utility api of qdbm</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;cabin.h&gt;</strong></p><p><strong>#include &lt;stdlib.h&gt;</strong></p><p><strong>extern void (*cbfatalfunc)(const char *message);</strong></p><p><strong>void *cbmalloc(size_t size);</strong></p><p><strong>void *cbrealloc(void *ptr, size_t size);</strong></p><p><strong>char *cbmemdup(const char *ptr, int size);</strong></p><p><strong>void cbfree(void *ptr);</strong></p><p><strong>void cbglobalgc(void *ptr, void (*func)(void *));</strong></p><p><strong>void cbggcsweep(void);</strong></p><p><strong>int cbvmemavail(size_t size);</strong></p><p><strong>void cbisort(void *base, int nmemb, int size, int(*compar)(const void *, const void *));</strong></p><p><strong>void cbssort(void *base, int nmemb, int size, int(*compar)(const void *, const void *));</strong></p><p><strong>void cbhsort(void *base, int nmemb, int size, int(*compar)(const void *, const void *));</strong></p><p><strong>void cbqsort(void *base, int nmemb, int size, int(*compar)(const void *, const void *));</strong></p><p><strong>int cbstricmp(const char *astr, const char *bstr);</strong></p><p><strong>int cbstrfwmatch(const char *str, const char *key);</strong></p><p><strong>int cbstrfwimatch(const char *str, const char *key);</strong></p><p><strong>int cbstrbwmatch(const char *str, const char *key);</strong></p><p><strong>int cbstrbwimatch(const char *str, const char *key);</strong></p><p><strong>char *cbstrstrkmp(const char *haystack, const char *needle);</strong></p><p><strong>char *cbstrstrbm(const char *haystack, const char *needle);</strong></p><p><strong>char *cbstrtoupper(char *str);</strong></p><p><strong>char *cbstrtolower(char *str);</strong></p><p><strong>char *cbstrtrim(char *str);</strong></p><p><strong>char *cbstrsqzspc(char *str);</strong></p><p><strong>int cbstrcountutf(const char *str);</strong></p><p><strong>char *cbstrcututf(char *str, int num);</strong></p><p><strong>CBDATUM *cbdatumopen(const char *ptr, int size);</strong></p><p><strong>CBDATUM *cbdatumdup(const CBDATUM *datum);</strong></p><p><strong>void cbdatumclose(CBDATUM *datum);</strong></p><p><strong>void cbdatumcat(CBDATUM *datum, const char *ptr, int size);</strong></p><p><strong>const char *cbdatumptr(const CBDATUM *datum);</strong></p><p><strong>int cbdatumsize(const CBDATUM *datum);</strong></p><p><strong>void cbdatumsetsize(CBDATUM *datum, int size);</strong></p><p><strong>void cbdatumprintf(CBDATUM *datum, const char *format, ...);</strong></p><p><strong>char *cbdatumtomalloc(CBDATUM *datum, int *sp);</strong></p><p><strong>CBLIST *cblistopen(void);</strong></p><p><strong>CBLIST *cblistdup(const CBLIST *list);</strong></p><p><strong>void cblistclose(CBLIST *list);</strong></p><p><strong>int cblistnum(const CBLIST *list);</strong></p><p><strong>const char *cblistval(const CBLIST *list, int index, int *sp);</strong></p><p><strong>void cblistpush(CBLIST *list, const char *ptr, int size);</strong></p><p><strong>char *cblistpop(CBLIST *list, int *sp);</strong></p><p><strong>void cblistunshift(CBLIST *list, const char *ptr, int size);</strong></p><p><strong>char *cblistshift(CBLIST *list, int *sp);</strong></p><p><strong>void cblistinsert(CBLIST *list, int index, const char *ptr, int size);</strong></p><p><strong>char *cblistremove(CBLIST *list, int index, int *sp);</strong></p><p><strong>void cblistover(CBLIST *list, int index, const char *ptr, int size);</strong></p><p><strong>void cblistsort(CBLIST *list);</strong></p><p><strong>int cblistlsearch(const CBLIST *list, const char *ptr, int size);</strong></p><p><strong>int cblistbsearch(const CBLIST *list, const char *ptr, int size);</strong></p><p><strong>char *cblistdump(const CBLIST *list, int *sp);</strong></p><p><strong>CBLIST *cblistload(const char *ptr, int size);</strong></p><p><strong>CBMAP *cbmapopen(void);</strong></p><p><strong>CBMAP *cbmapdup(CBMAP *map);</strong></p><p><strong>void cbmapclose(CBMAP *map);</strong></p><p><strong>int cbmapput(CBMAP *map, const char *kbuf, int ksiz, const char *vbuf, int vsiz, int over);</strong></p><p><strong>void cbmapputcat(CBMAP *map, const char *kbuf, int ksiz, const char *vbuf, int vsiz);</strong></p><p><strong>int cbmapout(CBMAP *map, const char *kbuf, int ksiz);</strong></p><p><strong>const char *cbmapget(const CBMAP *map, const char *kbuf, int ksiz, int *sp);</strong></p><p><strong>int cbmapmove(CBMAP *map, const char *kbuf, int ksiz, int head);</strong></p><p><strong>void cbmapiterinit(CBMAP *map);</strong></p><p><strong>const char *cbmapiternext(CBMAP *map, int *sp);</strong></p><p><strong>const char *cbmapiterval(const char *kbuf, int *sp);</strong></p><p><strong>int cbmaprnum(const CBMAP *map);</strong></p><p><strong>CBLIST *cbmapkeys(CBMAP *map);</strong></p><p><strong>CBLIST *cbmapvals(CBMAP *map);</strong></p><p><strong>char *cbmapdump(const CBMAP *map, int *sp);</strong></p><p><strong>CBMAP *cbmapload(const char *ptr, int size);</strong></p><p><strong>char *cbmaploadone(const char *ptr, int size, const char *kbuf, int ksiz, int *sp);</strong></p><p><strong>CBHEAP *cbheapopen(int size, int max, int(*compar)(const void *, const void *));</strong></p><p><strong>CBHEAP *cbheapdup(CBHEAP *heap);</strong></p><p><strong>void cbheapclose(CBHEAP *heap);</strong></p><p><strong>int cbheapnum(CBHEAP *heap);</strong></p><p><strong>int cbheapinsert(CBHEAP *heap, const void *ptr);</strong></p><p><strong>void *cbheapval(CBHEAP *heap, int index);</strong></p><p><strong>void *cbheaptomalloc(CBHEAP *heap, int *np);</strong></p><p><strong>char *cbsprintf(const char *format, ...);</strong></p><p><strong>char *cbreplace(const char *str, CBMAP *pairs);</strong></p><p><strong>CBLIST *cbsplit(const char *ptr, int size, const char *delim);</strong></p><p><strong>char *cbreadfile(const char *name, int *sp);</strong></p><p><strong>int cbwritefile(const char *name, const char *ptr, int size);</strong></p><p><strong>CBLIST *cbreadlines(const char *name);</strong></p><p><strong>CBLIST *cbdirlist(const char *name);</strong></p><p><strong>int cbfilestat(const char *name, int *isdirp, int *sizep, time_t *mtimep);</strong></p><p><strong>int cbremove(const char *name);</strong></p><p><strong>CBMAP *cburlbreak(const char *str);</strong></p><p><strong>char *cburlresolve(const char *base, const char *target);</strong></p><p><strong>char *cburlencode(const char *ptr, int size);</strong></p><p><strong>char *cburldecode(const char *str, int *sp);</strong></p><p><strong>char *cbbaseencode(const char *ptr, int size);</strong></p><p><strong>char *cbbasedecode(const char *str, int *sp);</strong></p><p><strong>char *cbquoteencode(const char *ptr, int size);</strong></p><p><strong>char *cbquotedecode(const char *str, int *sp);</strong></p><p><strong>char *cbmimebreak(const char *ptr, int size, CBMAP *attrs, int *sp);</strong></p><p><strong>CBLIST *cbmimeparts(const char *ptr, int size, const char *boundary);</strong></p><p><strong>char *cbmimeencode(const char *str, const char *encname, int base);</strong></p><p><strong>char *cbmimedecode(const char *str, char *enp);</strong></p><p><strong>CBLIST *cbcsvrows(const char *str);</strong></p><p><strong>CBLIST *cbcsvcells(const char *str);</strong></p><p><strong>char *cbcsvescape(const char *str);</strong></p><p><strong>char *cbcsvunescape(const char *str);</strong></p><p><strong>CBLIST *cbxmlbreak(const char *str, int cr);</strong></p><p><strong>CBMAP *cbxmlattrs(const char *str);</strong></p><p><strong>char *cbxmlescape(const char *str);</strong></p><p><strong>char *cbxmlunescape(const char *str);</strong></p><p><strong>char *cbdeflate(const char *ptr, int size, int *sp);</strong></p><p><strong>char *cbinflate(const char *ptr, int size, int *sp);</strong></p><p><strong>char *cbgzencode(const char *ptr, int size, int *sp);</strong></p><p><strong>char *cbgzdecode(const char *ptr, int size, int *sp);</strong></p><p><strong>unsigned int cbgetcrc(const char *ptr, int size);</strong></p><p><strong>char *cblzoencode(const char *ptr, int size, int *sp);</strong></p><p><strong>char *cblzodecode(const char *ptr, int size, int *sp);</strong></p><p><strong>char *cbbzencode(const char *ptr, int size, int *sp);</strong></p><p><strong>char *cbbzdecode(const char *ptr, int size, int *sp);</strong></p><p><strong>char *cbiconv(const char *ptr, int size, const char *icode, const char *ocode, int *sp, int *mp);</strong></p><p><strong>const char *cbencname(const char *ptr, int size);</strong></p><p><strong>int cbjetlag(void);</strong></p><p><strong>void cbcalendar(time_t t, int jl, int *yearp, int *monp, int *dayp, int *hourp, int *minp, int *secp);</strong></p><p><strong>int cbdayofweek(int year, int mon, int day);</strong></p><p><strong>char *cbdatestrwww(time_t t, int jl);</strong></p><p><strong>char *cbdatestrhttp(time_t t, int jl);</strong></p><p><strong>time_t cbstrmktime(const char *str);</strong></p><p><strong>void cbproctime(double *usrp, double *sysp);</strong></p><p><strong>void cbstdiobin(void);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Cabin is the utility API which provides memory allocating functions, sorting functions, extensible datum, array list, hash map, heap array, and so on for handling records easily on memory.  This API features also parsing MIME, CSV, and XML, and features various types of encoding and decoding.</p><p>In order to use Cabin, you should include `cabin.h' and `stdlib.h' in the source files.  Usually, the following description will be near the beginning of a source file.</p><p><strong>#include &lt;cabin.h&gt;</strong></p><p><strong>#include &lt;stdlib.h&gt;</strong></p><p>A pointer to `CBDATUM' is used as a handle of an extensible datum.  A datum handle is opened with the function `cbdatumopen' and closed with `cbdatumclose'.  A pointer to `CBLIST' is used as a handle of an array list.  A list handle is opened with the function `cblistopen' and closed with `cblistclose'.  A pointer to `CBMAP' is used as a handle of a hash map.  A map handle is opened with the function `cbmapopen' and closed with `cbmapclose'.  A pointer to `CBHEAP' is used as a handle of a heap array.  A heap handle is opened with the function `cbheapopen' and closed with `cbheapclose'.  You should not refer directly to any member of each handles.</p><p>The external variable `cbfatalfunc' is the pointer to call back function for handling a fatal error.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>extern void (*cbfatalfunc)(const char *message);</strong></p>
  </dt>
  <dd>
    <p>The argument specifies the error message.  The initial value of this variable is `NULL'.  If the value is `NULL', the default function is called when a fatal error occurs.  A fatal error occurs when memory allocation is failed.</p>
  </dd>

</dl>
<p>The function `cbmalloc' is used in order to allocate a region on memory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void *cbmalloc(size_t size);</strong></p>
  </dt>
  <dd>
    <p>`size' specifies the size of the region.  The return value is the pointer to the allocated region.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbrealloc' is used in order to re-allocate a region on memory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void *cbrealloc(void *ptr, size_t size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  The return value is the pointer to the re-allocated region.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbmemdup' is used in order to duplicate a region on memory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbmemdup(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is the pointer to the allocated region of the duplicate.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbfree' is used in order to free a region on memory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbfree(void *ptr);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  If it is `NULL', this function has no effect.  Although this function is just a wrapper of `free' call, this is useful in applications using another package of the `malloc' series.</p>
  </dd>

</dl>
<p>The function `cbglobalgc' is used in order to register the pointer or handle of an object to the global garbage collector.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbglobalgc(void *ptr, void (*func)(void *));</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer or handle of an object.  `func' specifies the pointer to a function to release resources of the object.  Its argument is the pointer or handle of the object to release.  This function assures that resources of an object are released when the process exits normally by returning from the `main' function or calling the `exit' function.</p>
  </dd>

</dl>
<p>The function `cbggcsweep' is used in order to exercise the global garbage collector explicitly.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbggcsweep(void);</strong></p>
  </dt>
  <dd>
    <p>Note that you should not use objects registered to the global garbage collector any longer after calling this function.  Because the global garbage collector is initialized and you can register new objects into it.</p>
  </dd>

</dl>
<p>The function `cbvmemavail' is used in order to check availability of allocation of the virtual memory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbvmemavail(size_t size);</strong></p>
  </dt>
  <dd>
    <p>`size' specifies the size of region to be allocated newly.  The return value is true if allocation should be success, or false if not.</p>
  </dd>

</dl>
<p>The function `cbisort' is used in order to sort an array using insert sort.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbisort(void *base, int nmemb, int size, int(*compar)(const void *, const void *));</strong></p>
  </dt>
  <dd>
    <p>`base' specifies the pointer to an array.  `nmemb' specifies the number of elements of the array.  `size' specifies the size of each element.  `compar' specifies the pointer to comparing function.  The two arguments specify the pointers of elements.  The comparing function should returns positive if the former is big, negative if the latter is big, 0 if both are equal.  Insert sort is useful only if most elements have been sorted already.</p>
  </dd>

</dl>
<p>The function `cbssort' is used in order to sort an array using shell sort.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbssort(void *base, int nmemb, int size, int(*compar)(const void *, const void *));</strong></p>
  </dt>
  <dd>
    <p>`base' specifies the pointer to an array.  `nmemb' specifies the number of elements of the array.  `size' specifies the size of each element.  `compar' specifies the pointer to comparing function.  The two arguments specify the pointers of elements.  The comparing function should returns positive if the former is big, negative if the latter is big, 0 if both are equal.  If most elements have been sorted, shell sort may be faster than heap sort or quick sort.</p>
  </dd>

</dl>
<p>The function `cbhsort' is used in order to sort an array using heap sort.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbhsort(void *base, int nmemb, int size, int(*compar)(const void *, const void *));</strong></p>
  </dt>
  <dd>
    <p>`base' specifies the pointer to an array.  `nmemb' specifies the number of elements of the array.  `size' specifies the size of each element. `compar' specifies the pointer to comparing function.  The two arguments specify the pointers of elements.  The comparing function should returns positive if the former is big, negative if the latter is big, 0 if both are equal.  Although heap sort is robust against bias of input, quick sort is faster in most cases.</p>
  </dd>

</dl>
<p>The function `cbqsort' is used in order to sort an array using quick sort.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbqsort(void *base, int nmemb, int size, int(*compar)(const void *, const void *));</strong></p>
  </dt>
  <dd>
    <p>`base' specifies the pointer to an array.  `nmemb' specifies the number of elements of the array.  `size' specifies the size of each element. `compar' specifies the pointer to comparing function.  The two arguments specify the pointers of elements.  The comparing function should returns positive if the former is big, negative if the latter is big, 0 if both are equal.  Being sensitive to bias of input, quick sort is the fastest sorting algorithm.</p>
  </dd>

</dl>
<p>The function `cbstricmp' is used in order to compare two strings with case insensitive evaluation.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbstricmp(const char *astr, const char *bstr);</strong></p>
  </dt>
  <dd>
    <p>`astr' specifies the pointer of one string.  `astr' specifies the pointer of the other string.  The return value is positive if the former is big, negative if the latter is big, 0 if both are equivalent.  Upper cases and lower cases of alphabets in ASCII code are not distinguished.</p>
  </dd>

</dl>
<p>The function `cbstrfwmatch' is used in order to check whether a string begins with a key.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbstrfwmatch(const char *str, const char *key);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a target string.  `key' specifies the pointer of a forward matching key string.  The return value is true if the target string begins with the key, else, it is false.</p>
  </dd>

</dl>
<p>The function `cbstrfwimatch' is used in order to check whether a string begins with a key, with case insensitive evaluation.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbstrfwimatch(const char *str, const char *key);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a target string.  `key' specifies the pointer of a forward matching key string.  The return value is true if the target string begins with the key, else, it is false.  Upper cases and lower cases of alphabets in ASCII code are not distinguished.</p>
  </dd>

</dl>
<p>The function `cbstrbwmatch' is used in order to check whether a string ends with a key.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbstrbwmatch(const char *str, const char *key);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a target string.  `key' specifies the pointer of a backward matching key string.  The return value is true if the target string ends with the key, else, it is false.</p>
  </dd>

</dl>
<p>The function `cbstrbwimatch' is used in order to check whether a string ends with a key, with case insensitive evaluation.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbstrbwimatch(const char *str, const char *key);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a target string.  `key' specifies the pointer of a backward matching key string.  The return value is true if the target string ends with the key, else, it is false.  Upper cases and lower cases of alphabets in ASCII code are not distinguished.</p>
  </dd>

</dl>
<p>The function `cbstrstrkmp' is used in order to locate a substring in a string using KMP method.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbstrstrkmp(const char *haystack, const char *needle);</strong></p>
  </dt>
  <dd>
    <p>`haystack' specifies the pointer of a target string.  `needle' specifies the pointer of a substring to be found.  The return value is the pointer to the beginning of the substring or `NULL' if the substring is not found.  In most cases, `strstr' as a built-in function of the compiler is faster than this function.</p>
  </dd>

</dl>
<p>The function `cbstrstrkmp' is used in order to locate a substring in a string using BM method.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbstrstrbm(const char *haystack, const char *needle);</strong></p>
  </dt>
  <dd>
    <p>`haystack' specifies the pointer of a target string.  `needle' specifies the pointer of a substring to be found.  The return value is the pointer to the beginning of the substring or `NULL' if the substring is not found.  In most cases, `strstr' as a built-in function of the compiler is faster than this function.</p>
  </dd>

</dl>
<p>The function `cbstrtoupper' is used in order to convert the letters of a string to upper case.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbstrtoupper(char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a string to convert.  The return value is the pointer to the string.</p>
  </dd>

</dl>
<p>The function `cbstrtolower' is used in order to convert the letters of a string to lower case.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbstrtolower(char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a string to convert.  The return value is the pointer to the string.</p>
  </dd>

</dl>
<p>The function `cbstrtrim' is used in order to cut space characters at head or tail of a string.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbstrtrim(char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a string to convert.  The return value is the pointer to the string.</p>
  </dd>

</dl>
<p>The function `cbstrsqzspc' is used in order to squeeze space characters in a string and trim it.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbstrsqzspc(char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a string to convert.  The return value is the pointer to the string.</p>
  </dd>

</dl>
<p>The function `cbstrcountutf' is used in order to count the number of characters in a string of UTF-8.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbstrcountutf(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a string of UTF-8.  The return value is the number of characters in the string.</p>
  </dd>

</dl>
<p>The function `cbstrcututf' is used in order to cut a string of UTF-8 at the specified number of characters.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbstrcututf(char *str, int num);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer of a string of UTF-8.  `num' specifies the number of characters to be kept.  The return value is the pointer to the string.</p>
  </dd>

</dl>
<p>The function `cbdatumopen' is used in order to get a datum handle.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBDATUM *cbdatumopen(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to the region of the initial content.  If it is `NULL', an empty datum is created.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is a datum handle.</p>
  </dd>

</dl>
<p>The function `cbdatumdup' is used in order to copy a datum.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBDATUM *cbdatumdup(const CBDATUM *datum);</strong></p>
  </dt>
  <dd>
    <p>`datum' specifies a datum handle.  The return value is a new datum handle.</p>
  </dd>

</dl>
<p>The function `cbdatumclose' is used in order to free a datum handle.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbdatumclose(CBDATUM *datum);</strong></p>
  </dt>
  <dd>
    <p>`datum' specifies a datum handle.  Because the region of a closed handle is released, it becomes impossible to use the handle.</p>
  </dd>

</dl>
<p>The function `cbdatumcat' is used in order to concatenate a datum and a region.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbdatumcat(CBDATUM *datum, const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`datum' specifies a datum handle.  `ptr' specifies the pointer to the region to be appended.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.</p>
  </dd>

</dl>
<p>The function `cbdatumptr' is used in order to get the pointer of the region of a datum.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>const char *cbdatumptr(const CBDATUM *datum);</strong></p>
  </dt>
  <dd>
    <p>`datum' specifies a datum handle.  The return value is the pointer of the region of a datum.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</p>
  </dd>

</dl>
<p>The function `cbdatumsize' is used in order to get the size of the region of a datum.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbdatumsize(const CBDATUM *datum);</strong></p>
  </dt>
  <dd>
    <p>`datum' specifies a datum handle.  The return value is the size of the region of a datum.</p>
  </dd>

</dl>
<p>The function `cbdatumsetsize' is used in order to change the size of the region of a datum.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbdatumsetsize(CBDATUM *datum, int size);</strong></p>
  </dt>
  <dd>
    <p>`datum' specifies a datum handle.  `size' specifies the new size of the region.  If the new size is bigger than the one of old, the surplus region is filled with zero codes.</p>
  </dd>

</dl>
<p>The function `cbdatumprintf' is used in order to perform formatted output into a datum.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbdatumprintf(CBDATUM *datum, const char *format, ...);</strong></p>
  </dt>
  <dd>
    <p>`format' specifies a printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `:', `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `:' works as with `s' but performs MIME encoding as UTF-8.  The other conversion character work as with each original.</p>
  </dd>

</dl>
<p>The function `cbdatumtomalloc' is used in order to convert a datum to an allocated region.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbdatumtomalloc(CBDATUM *datum, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`datum' specifies a datum handle.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the datum.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  Because the region of the original datum is released, it should not be released again.</p>
  </dd>

</dl>
<p>The function `cblistopen' is used in order to get a list handle.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cblistopen(void);</strong></p>
  </dt>
  <dd>
    <p>The return value is a list handle.</p>
  </dd>

</dl>
<p>The function `cblistdup' is used in order to copy a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cblistdup(const CBLIST *list);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  The return value is a new list handle.</p>
  </dd>

</dl>
<p>The function `cblistclose' is used in order to close a list handle.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cblistclose(CBLIST *list);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  Because the region of a closed handle is released, it becomes impossible to use the handle.</p>
  </dd>

</dl>
<p>The function `cblistnum' is used in order to get the number of elements of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cblistnum(const CBLIST *list);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  The return value is the number of elements of the list.</p>
  </dd>

</dl>
<p>The function `cblistval' is used in order to get the pointer to the region of an element of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>const char *cblistval(const CBLIST *list, int index, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `index' specifies the index of an element.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the element.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  If `index' is equal to or more than the number of elements, the return value is `NULL'.</p>
  </dd>

</dl>
<p>The function `cblistpush' is used in order to add an element at the end of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cblistpush(CBLIST *list, const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `ptr' specifies the pointer to the region of an element.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.</p>
  </dd>

</dl>
<p>The function `cblistpop' is used in order to remove an element of the end of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cblistpop(CBLIST *list, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the value.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  If the list is empty, the return value is `NULL'.</p>
  </dd>

</dl>
<p>The function `cblistunshift' is used in order to add an element at the top of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cblistunshift(CBLIST *list, const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `ptr' specifies the pointer to the region of an element.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.</p>
  </dd>

</dl>
<p>The function `cblistshift' is used in order to remove an element of the top of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cblistshift(CBLIST *list, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the value.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  If the list is empty, the return value is `NULL'.</p>
  </dd>

</dl>
<p>The function `cblistinsert' is used in order to add an element at the specified location of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cblistinsert(CBLIST *list, int index, const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `index' specifies the index of an element.  `ptr' specifies the pointer to the region of the element.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.</p>
  </dd>

</dl>
<p>The function `cblistremove' is used in order to remove an element at the specified location of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cblistremove(CBLIST *list, int index, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `index' specifies the index of an element.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the value.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</p>
  </dd>

</dl>
<p>The function `cblistover' is used in order to overwrite an element at the specified location of a list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cblistover(CBLIST *list, int index, const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `index' specifies the index of an element.  `ptr' specifies the pointer to the region of the new content.  `size' specifies the size of the new content.  If it is negative, the size is assigned with `strlen(ptr)'.  If `index' is equal to or more than the number of elements, this function has no effect.</p>
  </dd>

</dl>
<p>The function `cblistsort' is used in order to sort elements of a list in lexical order.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cblistsort(CBLIST *list);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  Quick sort is used for sorting.</p>
  </dd>

</dl>
<p>The function `cblistlsearch' is used in order to search a list for an element using liner search.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cblistlsearch(const CBLIST *list, const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `ptr' specifies the pointer to the region of a key.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is the index of a corresponding element or -1 if there is no corresponding element.  If two or more elements corresponds, the former returns.</p>
  </dd>

</dl>
<p>The function `cblistbsearch' is used in order to search a list for an element using binary search.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cblistbsearch(const CBLIST *list, const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  It should be sorted in lexical order.  `ptr' specifies the pointer to the region of a key.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is the index of a corresponding element or -1 if there is no corresponding element.  If two or more elements corresponds, which returns is not defined.</p>
  </dd>

</dl>
<p>The function `cblistdump' is used in order to serialize a list into a byte array.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cblistdump(const CBLIST *list, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`list' specifies a list handle.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  The return value is the pointer to the region of the result serial region.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cblistload' is used in order to redintegrate a serialized list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cblistload(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a byte array.  `size' specifies the size of the region.  The return value is a new list handle.</p>
  </dd>

</dl>
<p>The function `cbmapopen' is used in order to get a map handle.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBMAP *cbmapopen(void);</strong></p>
  </dt>
  <dd>
    <p>The return value is a map handle.</p>
  </dd>

</dl>
<p>The function `cbmapdup' is used in order to copy a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBMAP *cbmapdup(CBMAP *map);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  The return value is a new map handle.  The iterator of the source map is initialized.</p>
  </dd>

</dl>
<p>The function `cbmapclose' is used in order to close a map handle.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbmapclose(CBMAP *map);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  Because the region of a closed handle is released, it becomes impossible to use the handle.</p>
  </dd>

</dl>
<p>The function `cbmapput' is used in order to store a record into a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbmapput(CBMAP *map, const char *kbuf, int ksiz, const char *vbuf, int vsiz, int over);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  `kbuf' specifies the pointer to the region of a key.  `ksiz' specifies the size of the region of the key.  If it is negative, the size is assigned with `strlen(kbuf)'.  `vbuf' specifies the pointer to the region of a value.  `vsiz' specifies the size of the region of the value.  If it is negative, the size is assigned with `strlen(vbuf)'.  `over' specifies whether the value of the duplicated record is overwritten or not.  If `over' is false and the key is duplicated, the return value is false, else, it is true.</p>
  </dd>

</dl>
<p>The function `cbmapputcat' is used in order to concatenate a value at the end of the value of the existing record.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbmapputcat(CBMAP *map, const char *kbuf, int ksiz, const char *vbuf, int vsiz);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  `kbuf' specifies the pointer to the region of a key.  `ksiz' specifies the size of the region of the key.  If it is negative, the size is assigned with `strlen(kbuf)'.  `vbuf' specifies the pointer to the region of a value.  `vsiz' specifies the size of the region of the value.  If it is negative, the size is assigned with `strlen(vbuf)'.  If there is no corresponding record, a new record is created.</p>
  </dd>

</dl>
<p>The function `cbmapout' is used in order to delete a record in a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbmapout(CBMAP *map, const char *kbuf, int ksiz);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  `kbuf' specifies the pointer to the region of a key.  `ksiz' specifies the size of the region of the key.  If it is negative, the size is assigned with `strlen(kbuf)'.  If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p>
  </dd>

</dl>
<p>The function `cbmapget' is used in order to retrieve a record in a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>const char *cbmapget(const CBMAP *map, const char *kbuf, int ksiz, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  `kbuf' specifies the pointer to the region of a key.  `ksiz' specifies the size of the region of the key.  If it is negative, the size is assigned with `strlen(kbuf)'.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</p>
  </dd>

</dl>
<p>The function `cbmapmove' is used in order to move a record to the edge of a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbmapmove(CBMAP *map, const char *kbuf, int ksiz, int head);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  `kbuf' specifies the pointer to the region of a key.  `ksiz' specifies the size of the region of the key.  If it is negative, the size is assigned with `strlen(kbuf)'.  `head' specifies the destination which is head if it is true or tail if else.  If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p>
  </dd>

</dl>
<p>The function `cbmapiterinit' is used in order to initialize the iterator of a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbmapiterinit(CBMAP *map);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  The iterator is used in order to access the key of every record stored in a map.</p>
  </dd>

</dl>
<p>The function `cbmapiternext' is used in order to get the next key of the iterator of a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>const char *cbmapiternext(CBMAP *map, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be the same of the one of storing.</p>
  </dd>

</dl>
<p>The function `cbmapiterval' is used in order to get the value binded to the key fetched from the iterator of a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>const char *cbmapiterval(const char *kbuf, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`kbuf' specifies the pointer to the region of a iteration key.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the value of the corresponding record.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</p>
  </dd>

</dl>
<p>The function `cbmaprnum' is used in order to get the number of the records stored in a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbmaprnum(const CBMAP *map);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  The return value is the number of the records stored in the map.</p>
  </dd>

</dl>
<p>The function `cbmapkeys' is used in order to get the list handle contains all keys in a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbmapkeys(CBMAP *map);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  The return value is the list handle contains all keys in the map.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbmapvals' is used in order to get the list handle contains all values in a map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbmapvals(CBMAP *map);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  The return value is the list handle contains all values in the map.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbmapdump' is used in order to serialize a map into a byte array.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbmapdump(const CBMAP *map, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`map' specifies a map handle.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  The return value is the pointer to the region of the result serial region.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbmapload' is used in order to redintegrate a serialized map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBMAP *cbmapload(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a byte array.  `size' specifies the size of the region.  The return value is a new map handle.</p>
  </dd>

</dl>
<p>The function `cbmaploadone' is used in order to extract a record from a serialized map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbmaploadone(const char *ptr, int size, const char *kbuf, int ksiz, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a byte array.  `size' specifies the size of the region.  `kbuf' specifies the pointer to the region of a key.  `ksiz' specifies the size of the region of the key.  If it is negative, the size is assigned with `strlen(kbuf)'.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</p>
  </dd>

</dl>
<p>The function `cbheapopen' is used in order to get a heap handle.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBHEAP *cbheapopen(int size, int max, int(*compar)(const void *, const void *));</strong></p>
  </dt>
  <dd>
    <p>`size' specifies the size of each record.  `max' specifies the maximum number of records in the heap.  `compar' specifies the pointer to comparing function.  The two arguments specify the pointers of records.  The comparing function should returns positive if the former is big, negative if the latter is big, 0 if both are equal.  The return value is a heap handle.</p>
  </dd>

</dl>
<p>The function `cbheapdup' is used in order to copy a heap.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBHEAP *cbheapdup(CBHEAP *heap);</strong></p>
  </dt>
  <dd>
    <p>`heap' specifies a heap handle.  The return value is a new heap handle.</p>
  </dd>

</dl>
<p>The function `cbheapclose' is used in order to close a heap handle.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbheapclose(CBHEAP *heap);</strong></p>
  </dt>
  <dd>
    <p>`heap' specifies a heap handle.  Because the region of a closed handle is released, it becomes impossible to use the handle.</p>
  </dd>

</dl>
<p>The function `cbheapnum' is used in order to get the number of the records stored in a heap.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbheapnum(CBHEAP *heap);</strong></p>
  </dt>
  <dd>
    <p>`heap' specifies a heap handle.  The return value is the number of the records stored in the heap.</p>
  </dd>

</dl>
<p>The function `cbheapinsert' is used in order to insert a record into a heap.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbheapinsert(CBHEAP *heap, const void *ptr);</strong></p>
  </dt>
  <dd>
    <p>`heap' specifies a heap handle.  `ptr' specifies the pointer to the region of a record.  The return value is true if the record is added, else false.  If the new record is bigger than the biggest existing regord, the new record is not added.  If the new record is added and the number of records exceeds the maximum number, the biggest existing record is removed.</p>
  </dd>

</dl>
<p>The function `cbheapval' is used in order to get the pointer to the region of a record in a heap.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void *cbheapval(CBHEAP *heap, int index);</strong></p>
  </dt>
  <dd>
    <p>`heap' specifies a heap handle.  `index' specifies the index of a record.  The return value is the pointer to the region of the record.  If `index' is equal to or more than the number of records, the return value is `NULL'.  Note that records are organized by the nagative order the comparing function.</p>
  </dd>

</dl>
<p>The function `cbheaptomalloc' is used in order to convert a heap to an allocated region.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void *cbheaptomalloc(CBHEAP *heap, int *np);</strong></p>
  </dt>
  <dd>
    <p>`heap' specifies a heap handle.  `np' specifies the pointer to a variable to which the number of records of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the heap.  Records are sorted.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  Because the region of the original heap is released, it should not be released again.</p>
  </dd>

</dl>
<p>The function `cbsprintf' is used in order to allocate a formatted string on memory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbsprintf(const char *format, ...);</strong></p>
  </dt>
  <dd>
    <p>`format' specifies a printf-like format string.  The conversion character `%' can be used with such flag characters as `d', `o', `u', `x', `X', `e', `E', `f', `g', `G', `c', `s', and `%'.  Specifiers of the field length and the precision can be put between the conversion characters and the flag characters.  The specifiers consist of decimal characters, `.', `+', `-', and the space character.  The other arguments are used according to the format string.  The return value is the pointer to the allocated region of the result string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbreplace' is used in order to replace some patterns in a string.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbreplace(const char *str, CBMAP *pairs);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to a source string.  `pairs' specifies the handle of a map composed of pairs of replacement.  The key of each pair specifies a pattern before replacement and its value specifies the pattern after replacement.  The return value is the pointer to the allocated region of the result string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbsplit' is used in order to make a list by splitting a serial datum.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbsplit(const char *ptr, int size, const char *delim);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to the region of the source content.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `delim' specifies a string containing delimiting characters.  If it is `NULL', zero code is used as a delimiter.  The return value is a list handle.  If two delimiters are successive, it is assumed that an empty element is between the two.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose'.</p>
  </dd>

</dl>
<p>The function `cbreadfile' is used in order to read whole data of a file.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbreadfile(const char *name, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`name' specifies the name of a file.  If it is `NULL', the standard input is specified.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the allocated region of the read data.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbwritefile' is used in order to write a serial datum into a file.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbwritefile(const char *name, const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`name specifies the name of a file.  If it is `NULL', the standard output is specified.  `ptr' specifies the pointer to the region of the source content.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  If successful, the return value is true, else, it is false.  If the file exists, it is overwritten.  Else, a new file is created.</p>
  </dd>

</dl>
<p>The function `cbreadlines' is used in order to read every line of a file.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbreadlines(const char *name);</strong></p>
  </dt>
  <dd>
    <p>`name' specifies the name of a file.  If it is `NULL', the standard input is specified.  The return value is a list handle of the lines if successful, else it is NULL.  Line separators are cut out.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbdirlist' is used in order to read names of files in a directory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbdirlist(const char *name);</strong></p>
  </dt>
  <dd>
    <p>`name' specifies the name of a directory.  The return value is a list handle of names if successful, else it is NULL.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbfilestat' is used in order to get the status of a file or a directory.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbfilestat(const char *name, int *isdirp, int *sizep, time_t *mtimep);</strong></p>
  </dt>
  <dd>
    <p>`name' specifies the name of a file or a directory.  `dirp' specifies the pointer to a variable to which whether the file is a directory is assigned.  If it is `NULL', it is not used.  `sizep' specifies the pointer to a variable to which the size of the file is assigned.  If it is `NULL', it is not used.  `mtimep' specifies the pointer to a variable to which the last modified time of the file is assigned.  If it is `NULL', it is not used.  If successful, the return value is true, else, false.  False is returned when the file does not exist or the permission is denied.</p>
  </dd>

</dl>
<p>The function `cbremove' is used in order to remove a file or a directory and its sub ones recursively.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbremove(const char *name);</strong></p>
  </dt>
  <dd>
    <p>`name' specifies the name of a file or a directory.  If successful, the return value is true, else, false.  False is returned when the file does not exist or the permission is denied.</p>
  </dd>

</dl>
<p>The function `cburlbreak' is used in order to break up a URL into elements.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBMAP *cburlbreak(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to a string of URL.  The return value is a map handle.  Each key of the map is the name of an element.  The key "self" specifies the URL itself.  The key "scheme" specifies the scheme.  The key "host" specifies the host of the server.  The key "port" specifies the port number of the server.  The key "authority" specifies the authority information.  The key "path" specifies the path of the resource.  The key "file" specifies the file name without the directory section.  The key "query" specifies the query string.  The key "fragment" specifies the fragment string.  Supported schema are HTTP, HTTPS, FTP, and FILE.  Absolute URL and relative URL are supported.  Because the handle of the return value is opened with the function `cbmapopen', it should be closed with the function `cbmapclose' if it is no longer in use.</p>
  </dd>

</dl>
<p>The runction `cburlresolve' is used in order to resolve a relative URL with another absolute URL.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cburlresolve(const char *base, const char *target);</strong></p>
  </dt>
  <dd>
    <p>`base' specifies an absolute URL of a base location.  `target' specifies a URL to be resolved.  The return value is a resolved URL.  If the target URL is relative, a new URL of relative location from the base location is returned.  Else, a copy of the target URL is returned.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cburlencode' is used in order to encode a serial object with URL encoding.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cburlencode(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is the pointer to the result string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cburldecode' is used in order to decode a string encoded with URL encoding.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cburldecode(const char *str, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to a source string.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the result.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbbaseencode' is used in order to encode a serial object with Base64 encoding.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbbaseencode(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is the pointer to the result string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbbasedecode' is used in order to decode a string encoded with Base64 encoding.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbbasedecode(const char *str, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to a source string.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the result.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbquoteencode' is used in order to encode a serial object with quoted-printable encoding.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbquoteencode(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is the pointer to the result string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbquotedecode' is used in order to decode a string encoded with quoted-printable encoding.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbquotedecode(const char *str, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to a source string.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer to the region of the result.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbmimebreak' is used in order to split a string of MIME into headers and the body.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbmimebreak(const char *ptr, int size, CBMAP *attrs, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to the region of MIME data.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `attrs' specifies a map handle to store attributes.  If it is `NULL', it is not used.  Each key of the map is an attribute name uncapitalized.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  The return value is the pointer of the body data.  If the content type is defined, the attribute map has the key "TYPE" specifying the type.  If the character encoding is defined, the key "CHARSET" specifies the encoding name.  If the boundary string of multipart is defined, the key "BOUNDARY" specifies the string.  If the content disposition is defined, the key "DISPOSITION" specifies the direction.  If the file name is defined, the key "FILENAME" specifies the name.  If the attribute name is defined, the key "NAME" specifies the name.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbmimeparts' is used in order to split multipart data of MIME into its parts.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbmimeparts(const char *ptr, int size, const char *boundary);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to the region of multipart data of MIME.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `boundary' specifies the pointer to the region of the boundary string.  The return value is a list handle.  Each element of the list is the string of a part.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbmimeencode' is used in order to encode a string with MIME encoding.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbmimeencode(const char *str, const char *encname, int base);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to a string.  `encname' specifies a string of the name of the character encoding.  The return value is the pointer to the result string.  `base' specifies whether to use Base64 encoding.  If it is false, quoted-printable is used.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbmimedecode' is used in order to decode a string encoded with MIME encoding.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbmimedecode(const char *str, char *enp);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to an encoded string.  `enp' specifies the pointer to a region into which the name of encoding is written.  If it is `NULL', it is not used.  The size of the buffer should be equal to or more than 32 bytes.  The return value is the pointer to the result string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbcsvrows' is used in order to split a string of CSV into rows.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbcsvrows(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to the region of an CSV string.  The return value is a list handle.  Each element of the list is a string of a row.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.  The character encoding of the input string should be US-ASCII, UTF-8, ISO-8859-*, EUC-*, or Shift_JIS.  Being compatible with MS-Excel, these functions for CSV can handle cells including such meta characters as comma, between double quotation marks.</p>
  </dd>

</dl>
<p>The function `cbcsvcells' is used in order to split the string of a row of CSV into cells.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbcsvcells(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to the region of a row of CSV.  The return value is a list handle.  Each element of the list is the unescaped string of a cell of the row.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbcsvescape' is used in order to escape a string with the meta characters of CSV.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbcsvescape(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to the region of a string.  The return value is the pointer to the escaped string sanitized of meta characters.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbcsvunescape' is used in order to unescape a string with the escaped meta characters of CSV.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbcsvunescape(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to the region of a string with meta characters.  The return value is the pointer to the unescaped string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbxmlbreak' is used in order to split a string of XML into tags and text sections.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBLIST *cbxmlbreak(const char *str, int cr);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to the region of an XML string.  `cr' specifies whether to remove comments.  The return value is a list handle.  Each element of the list is the string of a tag or a text section.  Because the handle of the return value is opened with the function `cblistopen', it should be closed with the function `cblistclose' if it is no longer in use.  The character encoding of the input string should be US-ASCII, UTF-8, ISO-8859-*, EUC-*, or Shift_JIS.  Because these functions for XML are not XML parser with validation check, it can handle also HTML and SGML.</p>
  </dd>

</dl>
<p>The function `cbxmlattrs' is used in order to get the map of attributes of an XML tag.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>CBMAP *cbxmlattrs(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to the region of a tag string.  The return value is a map handle.  Each key of the map is the name of an attribute.  Each value is unescaped.  You can get the name of the tag with the key of an empty string.  Because the handle of the return value is opened with the function `cbmapopen', it should be closed with the function `cbmapclose' if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbxmlescape' is used in order to escape a string with the meta characters of XML.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbxmlescape(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to the region of a string.  The return value is the pointer to the escaped string sanitized of meta characters.  This function converts only `&', `&lt;', `&gt;', and `"'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbxmlunescape' is used in order to unescape a string with the entity references of XML.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbxmlunescape(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies the pointer to the region of a string.  The return value is the pointer to the unescaped string.  This function restores only `&amp;', `&lt;', `&gt;', and `&quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbdeflate' is used in order to compress a serial object with ZLIB.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbdeflate(const char *ptr, int size, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with ZLIB enabled.</p>
  </dd>

</dl>
<p>The function `cbinflate' is used in order to decompress a serial object compressed with ZLIB.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbinflate(const char *ptr, int size, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with ZLIB enabled.</p>
  </dd>

</dl>
<p>The function `cbgzencode' is used in order to compress a serial object with GZIP.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbgzencode(const char *ptr, int size, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with ZLIB enabled.</p>
  </dd>

</dl>
<p>The function `cbgzdecode' is used in order to decompress a serial object compressed with GZIP.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbgzdecode(const char *ptr, int size, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with ZLIB enabled.</p>
  </dd>

</dl>
<p>The function `cbgetcrc' is used in order to get the CRC32 checksum of a serial object.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>unsigned int cbgetcrc(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is the CRC32 checksum of the object.  This function is available only if QDBM was built with ZLIB enabled.</p>
  </dd>

</dl>
<p>The function `cblzoencode' is used in order to compress a serial object with LZO.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cblzoencode(const char *ptr, int size, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with LZO enabled.</p>
  </dd>

</dl>
<p>The function `cblzodecode' is used in order to decompress a serial object compressed with LZO.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cblzodecode(const char *ptr, int size, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with LZO enabled.</p>
  </dd>

</dl>
<p>The function `cbbzencode' is used in order to compress a serial object with BZIP2.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbbzencode(const char *ptr, int size, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with BZIP2 enabled.</p>
  </dd>

</dl>
<p>The function `cbbzdecode' is used in order to decompress a serial object compressed with BZIP2.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbbzdecode(const char *ptr, int size, int *sp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with BZIP2 enabled.</p>
  </dd>

</dl>
<p>The function `cbiconv' is used in order to convert the character encoding of a string.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbiconv(const char *ptr, int size, const char *icode, const char *ocode, int *sp, int *mp);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  `icode' specifies the name of encoding of the input string.  `ocode' specifies the name of encoding of the output string.  `sp' specifies the pointer to a variable to which the size of the region of the return value is assigned.  If it is `NULL', it is not used.  `mp' specifies the pointer to a variable to which the number of missing characters by failure of conversion is assigned.  If it is `NULL', it is not used.  If successful, the return value is the pointer to the result object, else, it is `NULL'.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.  This function is available only if QDBM was built with ICONV enabled.</p>
  </dd>

</dl>
<p>The function `cbencname' is used in order to detect the encoding of a string automatically.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>const char *cbencname(const char *ptr, int size);</strong></p>
  </dt>
  <dd>
    <p>`ptr' specifies the pointer to a region.  `size' specifies the size of the region.  If it is negative, the size is assigned with `strlen(ptr)'.  The return value is the string of the encoding name of the string.  As it stands, US-ASCII, ISO-2022-JP, Shift_JIS, CP932, EUC-JP, UTF-8, UTF-16, UTF-16BE, and UTF-16LE are supported.  If none of them matches, ISO-8859-1 is selected.  This function is available only if QDBM was built with ICONV enabled.</p>
  </dd>

</dl>
<p>The function `cbjetlag' is used in order to get the jet lag of the local time in seconds.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbjetlag(void);</strong></p>
  </dt>
  <dd>
    <p>The return value is the jet lag of the local time in seconds.</p>
  </dd>

</dl>
<p>The function `cbcalendar' is used in order to get the Gregorian calendar of a time.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbcalendar(time_t t, int jl, int *yearp, int *monp, int *dayp, int *hourp, int *minp, int *secp);</strong></p>
  </dt>
  <dd>
    <p>`t' specifies a source time.  If it is negative, the current time is specified.  `jl' specifies the jet lag of a location in seconds.  `yearp' specifies the pointer to a variable to which the year is assigned.  If it is `NULL', it is not used.  `monp' specifies the pointer to a variable to which the month is assigned.  If it is `NULL', it is not used.  1 means January and 12 means December.  `dayp' specifies the pointer to a variable to which the day of the month is assigned.  If it is `NULL', it is not used.  `hourp' specifies the pointer to a variable to which the hours is assigned.  If it is `NULL', it is not used.  `minp' specifies the pointer to a variable to which the minutes is assigned.  If it is `NULL', it is not used.  `secp' specifies the pointer to a variable to which the seconds is assigned.  If it is `NULL', it is not used.</p>
  </dd>

</dl>
<p>The function `cbdayofweek' is used in order to get the day of week of a date.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>int cbdayofweek(int year, int mon, int day);</strong></p>
  </dt>
  <dd>
    <p>`year' specifies the year of a date.  `mon' specifies the month of the date.  `day' specifies the day of the date.  The return value is the day of week of the date.  0 means Sunday and 6 means Saturday.</p>
  </dd>

</dl>
<p>The function `cbdatestrwww' is used in order to get the string for a date in W3CDTF.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbdatestrwww(time_t t, int jl);</strong></p>
  </dt>
  <dd>
    <p>`t' specifies a source time.  If it is negative, the current time is specified.  `jl' specifies the jet lag of a location in seconds.  The return value is the string of the date in W3CDTF (YYYY-MM-DDThh:mm:ddTZD).  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbdatestrhttp' is used in order to get the string for a date in RFC 1123 format.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *cbdatestrhttp(time_t t, int jl);</strong></p>
  </dt>
  <dd>
    <p>`t' specifies a source time.  If it is negative, the current time is specified.  `jl' specifies the jet lag of a location in seconds.  The return value is the string of the date in RFC 1123 format (Wdy, DD-Mon-YYYY hh:mm:dd TZD).  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if it is no longer in use.</p>
  </dd>

</dl>
<p>The function `cbstrmktime' is used in order to get the time value of a date string in decimal, hexadecimal, W3CDTF, or RFC 822 (1123).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>time_t cbstrmktime(const char *str);</strong></p>
  </dt>
  <dd>
    <p>`str' specifies a date string in decimal, hexadecimal, W3CDTF, or RFC 822 (1123).  The return value is the time value of the date or -1 if the format is invalid.  Decimal can be trailed by "s" for in seconds, "m" for in minutes, "h" for in hours, and "d" for in days.</p>
  </dd>

</dl>
<p>The function `cbproctime' is used in order to get user and system processing times.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbproctime(double *usrp, double *sysp);</strong></p>
  </dt>
  <dd>
    <p>`usrp' specifies the pointer to a variable to which the user processing time is assigned.  If it is `NULL', it is not used.  The unit of time is seconds.  `sysp' specifies the pointer to a variable to which the system processing time is assigned.  If it is `NULL', it is not used.  The unit of time is seconds.</p>
  </dd>

</dl>
<p>The function `cbstdiobin' is used in order to ensure that the standard I/O is binary mode.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void cbstdiobin(void);</strong></p>
  </dt>
  <dd>
    <p>This function is useful for applications on dosish file systems.</p>
  </dd>

</dl>
<p>Functions of Cabin except for `cbglobalgc' are thread-safe as long as a handle is not accessed by threads at the same time, on the assumption that `errno', `malloc', and so on are thread-safe.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO cabin&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/qdbm.3.html"><strong>qdbm</strong>(3)</a>, <a href="../man3/depot.3.html"><strong>depot</strong>(3)</a>, <a href="../man3/curia.3.html"><strong>curia</strong>(3)</a>, <a href="../man3/relic.3.html"><strong>relic</strong>(3)</a>, <a href="../man3/hovel.3.html"><strong>hovel</strong>(3)</a>, <a href="../man3/villa.3.html"><strong>villa</strong>(3)</a>, <a href="../man3/odeum.3.html"><strong>odeum</strong>(3)</a>, <strong>ndbm</strong>(3), <a href="../man3/gdbm.3.html"><strong>gdbm</strong>(3)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="cWait.3.html"><span aria-hidden="true">&larr;</span> cWait.3: Wait a condition variable signal.</a></li>
   <li class="next"><a href="cabs.3.html">cabs.3: Absolute value of a complex number <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

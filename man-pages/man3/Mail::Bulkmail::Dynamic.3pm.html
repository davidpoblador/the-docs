<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mail::Bulkmail::Dynamic: Platform independent mailing list module for mail merges and dynamically built messages</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Platform independent mailing list module for mail merges and dynamically built messages">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Mail::Bulkmail::Dynamic (3pm) manual">
  <meta name="twitter:description" content="Platform independent mailing list module for mail merges and dynamically built messages">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmail-bulkmail-perl-Mail::Bulkmail::Dynamic-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Mail::Bulkmail::Dynamic.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Mail::Bulkmail::Dynamic (3pm) manual" />
  <meta property="og:description" content="Platform independent mailing list module for mail merges and dynamically built messages" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmail-bulkmail-perl-Mail::Bulkmail::Dynamic-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Mail::Bulkmail::Dynamic<small> (3pm)</small></h1>
        <p class="lead">Platform independent mailing list module for mail merges and dynamically built messages</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::Bulkmail::Dynamic.3pm.html">
      <span itemprop="name">Mail::Bulkmail::Dynamic: Platform independent mailing list module for mail merges and dynamically built messages</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmail-bulkmail-perl/">
      <span itemprop="name">libmail-bulkmail-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::Bulkmail::Dynamic.3pm.html">
      <span itemprop="name">Mail::Bulkmail::Dynamic: Platform independent mailing list module for mail merges and dynamically built messages</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Jim Thomason, jim@jimandkoka.com</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 my $bulk = Mail::Bulkmail::Dynamic-&gt;new(
        "merge_keys"            =&gt; [qw(BULK_EMAIL name id address city state zip)],
        "merge_delimiter"       =&gt; "::",
        "LIST"                          =&gt; "~/my.list.txt",
        "From"                          =&gt; "&apos;Jim Thomason&apos;&lt;jim@jimandkoka.com&gt;",
        "Subject"                       =&gt; "This is a test message",
        "Message"                       =&gt; "Here is my test message"
 ) || die Mail::Bulkmail-&gt;error();
</pre>
<p> $bulk-&gt;bulkmail() || die $bulk-&gt;error;</p><p>Don't forget to set up your conf file!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Mail::Bulkmail 1.00 had a thing called \*(L"filemapping\*(R", it was to allow you to dynamically populate certain variables into your message. Put in people's names, or the like.</p><p>2.00 renamed \*(L"filemapping\*(R" to the correct term - \*(L"mail merging\*(R", and also added in the ability to dynamically create your message, if so desired. So you could very easily send out completely different messages to everyone on your list, if so desired. But 2.00 also added a *lot* of processing overhead, most of which was unfortunately in the form of voodoo. i.e., I seem to recall lots of testing, debugging, etc. until I finally reached a point where the code worked and I sent it off. Not quite sure how it worked, mind you, but happy with the fact that it worked nonetheless.</p><p>3.00 strips that ability out of Mail::Bulkmail, cleans it up, and places it here. This has a few advantages. For one thing, if you're not doing any mailmerging, then you don't have to worry about any of the overhead of building hashes, doing checks, internally handling things, and so on. There wasn't a tremendous amount of useless work done in that case, but it was enough to be noticed. So now use Mail::Bulkmail if you're not doing mail merges, and Mail::Bulkmail::Dynamic if you are.</p><p>And the other thing is that the code is cleaned up a <strong>lot</strong>. I actually know and understand how it all works now, and it functions much better than previous versions did. Faster, more efficient, and so on.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ATTRIBUTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    log_all_data
  </dt>
  <dd>
    <p>boolean flag, 1/0. Mail::Bulkmail has an easy job logging its list items - they're always guaranteed to be single email addresses. Mail::Bulkmail::Dynamic has a harder time, since it's usually an email address and some other data.  &apos;jim@jimandkoka.com::Jim Thomason::24&apos;  or  [&apos;jim@jimandkoka.com&apos;, "Jim Thomason", "24"]  or  {         "BULK_EMAIL" =&gt; &apos;jim@jimandkoka.com&apos;,         "name"           =&gt; "Jim Thomason",         "age"            =&gt; "24"  } Most of that is obviously not simple scalar data and needs to be logged differently. If log_all_data is set to 0, then only the email address will be logged and everything is fine. However, if log_all_data is 1, then a hashref containing all of the data is returned (regardless of the type of data structure you initially handed in). Obviously, you will then need to deal with logging yourself, either by logging to an arrayref or (better) to a function call. Logging to a file with log_all_data set to 1 will just give you a useless list of \*(L"\s-1HASH\s0(0x7482)\*(R" and the like. All pieces may be used simultaneously. So in one mailing, you can use merge_keys, dynamic_message_data, dynamic_header_data, and global_merge.</p>
  </dd>
  <dt>
    merge_keys
  </dt>
  <dd>
    <p>This should be much easier to use and understand than it was in prior versions. Okay, let's start off with the simple case, you have a file that contains a list of email addresses:  foo@bar.com  bob@hope.com  john@junior.com And you set up a list with Mail::Bulkmail to mail to them. Your message is something like this:  "Hi there. Things are great in my world, how&apos;s yours?" This works fine for a while, people are happy, everything's dandy. But then, you decide that it would be nice to personalize your email messages in some fashion. So you switch to Mail::Bulkmail::Dynamic. You'll need more information in your list of addresses now.  foo@bar.com::Mr. Foo  me@there.com::Bob Hope  john@junior.com::John Jr. And then you'll need to define your merge_keys. merge_keys is an arrayref that defines how the data in your file is structured:  merge_keys =&gt; [qw(BULK_EMAIL &lt;&lt;NAME&gt;&gt;)] That tells Mail::Bulkmail::Dynamic that the first item in your list is the email address, and the second one is your name. Please note that the email address <strong>\s-1MUST\s0</strong> be called \*(L"\s-1BULK_EMAIL\s0\*(R", that's the keyword that the module looks for to find the address to send to. The rest of your keys may be named anything you'd like, but avoid naming keys starting with \*(L"\s-1BULK_\s0\*(R", because those are reserved for my use internally and I may add more special keys like that in the future. (You'll also need to make sure that your merge_delimiter is set to \*(L"::\*(R", see merge_delimiter, below). Now you can change your message to the following:  "Hi there, &lt;&lt;NAME&gt;&gt;. Things are great in my world, how&apos;s yours?" This will send out the messages, respectively:  Hi there, Mr. Foo. Things are great in my world, how&apos;s yours?  Hi there, Bob Hope. Things are great in my world, how&apos;s yours?  Hi there, John Junior. Things are great in my world, how&apos;s yours? And voila. Customization. you may include as much data as you'd like:  merge_keys = [qw(&lt;&lt;NAME&gt;&gt; BULK_EMAIL &lt;&lt;STATE&gt;&gt; &lt;&lt;AGE&gt;&gt; &lt;&lt;HOBBY&gt;&gt; &lt;&lt;PREFERRED COMPUTER&gt;&gt;)]  #in your list:  Jim Thomason::jim@jimandkoka.com::IL::24::Programming Perl::titanium powerbook  #and then your message.  Dear &lt;&lt;NAME&gt;&gt;,  How&apos;ve you been? I see that your email address is still BULK_EMAIL.  Are you still living in &lt;&lt;STATE&gt;&gt;? And you&apos;re still &lt;&lt;AGE&gt;&gt;, right?  Do you still enjoy &lt;&lt;HOBBY&gt;&gt;?  Well, email me back a message from your &lt;&lt;PREFERRED COMPUTER&gt;&gt;. And that's all there is to it. Just be sure to remember that any keys you define will get clobbered *anywhere* in the message.  merge_keys =&gt; [qw(BULK_EMAIL name)]  LIST =&gt; [qw(jim@jimandkoka.com::Jim)]  "Hi there, name. I&apos;ve always liked your name." You *probably* want that message to populate as:  "Hi there, Jim. I&apos;ve always liked your name." But it will populate as:  "Hi there, Jim. I&apos;ve always liked your Jim." Which doesn't make sense. So just make sure your keys aren't anywhere else in your message. For example,  merge_keys =&gt; [qw(BULK_EMAIL &lt;name&gt;)]  LIST =&gt; [qw(jim@jimandkoka.com::Jim)]  "Hi there, &lt;name&gt;. I&apos;ve always liked your name." Your list data may be a delimited scalar, as we've been using in our examples:  jim@jimandkoka.com::Jim::24 Or an arrayref:  [&apos;jim@jimandkoka.com&apos;, &apos;Jim&apos;, &apos;24&apos;] In both of those cases, the order of the data is important. Each data element matches up to a particular key. So be sure that your data is actually in the same order as defined in your merge_keys array. Alternatively, you can also just store your data in a hash and pass that in:  {         &apos;BULK_EMAIL&apos;    =&gt; &apos;jim@jimandkoka.com&apos;,         &apos;&lt;name&gt;&apos;                =&gt; &apos;Jim&apos;,         &apos;&lt;age&gt;&apos;                 =&gt; &apos;24&apos;  } This is the one case where your merge_keys values will be ignored, and a mailmerge will be done with the key/value pairs passed in that hashtable. Passing in a hashtable is the fastest in terms of internal processing, but there may be additional work on your end to generate the hash. When reading from a file, you should always use delimited strings (since that's what'd be in your file anyway), but from other sources you can experiment with hashrefs or arrayrefs and see which is faster for your uses. mail merges apply to <strong>both</strong> message <strong>and</strong> header information. So it's valid to do:  $dynamic-&gt;Subject("Hello there, &lt;name&gt;"); And have the mail merge pick that up. Note that the merge will be performed in an arbitrary order, independent of what's specified in merge_keys. So don't expect to have one piece of the merge populate into your message before another one.</p>
  </dd>
  <dt>
    merge_delimiter
  </dt>
  <dd>
    <p>If you're reading in from a file, you can't have arrayrefs, hashrefs, whatever. They don't store nicely in text. So your data will probably be a delimited string. In that case, you need to know the delimiter. Set it with merge_delimiter.  #in your list  jim@jimandkoka.com::Jim  #then  $dynamic-&gt;merge_delimiter("::");  #in your list  jim@jimandkoka.com-+-Jim  #then  $dynamic-&gt;merge_delimiter(&apos;-+-&apos;);  #in your list  jim@jimandkoka.com,Jim  #then  $dynamic-&gt;merge_delimiter(&apos;,&apos;); Just be sure that your delimiting string occurs *only* as the delimiter and is never embedded in your data. No escaping of a delimiter is possible.</p>
  </dd>
  <dt>
    global_merge
  </dt>
  <dd>
    <p>It can be useful to to do a mail merge with non-address specific data. For example, you may want to put today's date in your subject. But it's silly (if not impossible) to populate that data out to all of your addresses. This is where the global_merge comes in.  $dynamic-&gt;global_merge(         {                 "&lt;DATE&gt;" =&gt; scalar localtime         }  );  or, at creation:  my $dynamic = Mail::Bulkmail::Dynamic-&gt;new(         "global_merge" =&gt; {                 "&lt;DATE&gt;" =&gt; scalar localtime         }  ); &lt;\s-1DATE\s0&gt; will now change to today's date in your message.  "Hello, list member. This is the list for &lt;DATE&gt;" This is a hash table that populates merge data <strong>before</strong> individual mail merge items. There is no way to use the same key for both a global_merge and a per-address merge. The global merge will always pick it up and the individual merge will miss it. So, as always, use different keys.</p>
  </dd>
  <dt>
    dynamic_message_data
  </dt>
  <dd>
    <p>Mail merges are all well and good, they store unique information about a unique email address. But sometimes you want to group together several users and send them the same information based upon some other criteria. That's where dynamic_message_data comes in handy. This is probably easiest explained via examples. dynamic_message_data is a hashref of hashrefs, such as this:  $dynamic-&gt;dynamic_message_data(         {                 &apos;&lt;agegroup&gt;&apos; =&gt; {                         &apos;over70&apos;        =&gt; &apos;napping&apos;,                         &apos;40-50&apos;         =&gt; &apos;amassing wealth&apos;,                         &apos;20-40&apos;         =&gt; &apos;working&apos;,                         &apos;under20&apos;       =&gt; &apos;playing&apos;                 },                 &apos;&lt;animallover&gt;&apos; =&gt; {                         &apos;hates_animals&apos; =&gt; "I see you hate animals.",                         "likes_animals" =&gt; "I see you like animals.",                         "loves_animals" =&gt; "I see you love animals."                 },                 &apos;&lt;personalized&gt;&apos; =&gt; {                         &apos;yes&apos;   =&gt; &apos;Hi there, &lt;name&gt;&apos;,                         &apos;no&apos;    =&gt; &apos;Hi there&apos;                 }         }  ); Now then, your merge keys could be defined as such:  -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; &lt;age&gt; BULK_DYNAMIC_MESSAGE)]); Your list would be:  foo@bar.com::Mr. Foo::23::&lt;agegroup&gt;=20-40;&lt;animallover&gt;=hates_animals;&lt;personalized&gt;=yes  me@there.com::Bob Hope::78::&lt;agegroup&gt;=over70;&lt;animallover&gt;=likes_animals;&lt;personalized&gt;=no  john@junior.com::John Jr.::14::&lt;agegroup&gt;=under20;&lt;animallover&gt;=likes_animals;&lt;personalized&gt;=yes And finally, your message would be:  &lt;personalized&gt;. Judging by your age, which is &lt;age&gt;, you should enjoy &lt;agegroup&gt;.  Oh, and &lt;animallover&gt; The messages sent out would be, respectively:  Hi there, Mr. Foo. Judging by your age, which is 23, you should enjoy working.  Oh, and I see you hate animals.  Hi there. Judging by your age, which is 78, you should enjoy napping.  Oh, and I see you like animals.  Hi there, John Jr.. Judging by your age, which is 14, you should enjoy playing.  Oh, and I see you like animals. See? easy as pie. Your dynamic message should be specified in your merge_keys as \s-1BULK_DYNAMIC_MESSAGE\s0, and should be a delimited string (in this case).  agegroup=20-40;&lt;animallover&gt;=hates_animals;&lt;personilized&gt;=yes You can specify what delimiters you'd like to use. In this case, your dynamic_message_delimiter is ';', and your dynamic_message_value_delimiter is '='. More clearly, this information translates to the following:  &lt;agegroup&gt;             =&gt; 20-40  &lt;animallover&gt;  =&gt; hates_animals  &lt;personilized&gt; =&gt; yes Please note that angle brackets are not required, they're just useful for clarity in our example. This is also perfectly acceptable:  $dynamic-&gt;dynamic_message_data(         {                 &apos;agegroup&apos; =&gt; {                         &apos;over70&apos;        =&gt; &apos;napping&apos;,                         &apos;40-50&apos;         =&gt; &apos;amassing wealth&apos;,                         &apos;20-40&apos;         =&gt; &apos;working&apos;,                         &apos;under20&apos;       =&gt; &apos;playing&apos;                 }         }  );   me@there.com::Bob Hope::78::agegroup=over70 As long as you use the same keys, you're fine. So you should be able to easily see that we'll look up the message associated with being in the agegroup of 20-40, the animallover that hates_animals, and then personilized with a choice of 'yes'. Dynamic message creation is done before mail merging, so you are more than welcome to put mail merge tokens inside your dynamic message, as we did above with the \*(L"&lt;personalized&gt;\*(R" token, which may include the mail merge token of \*(L"&lt;name&gt;\*(R". Don't use the same tokens for mailmerges and dynamic messages, since the system may get confused. Alternatively, instead of a delimited string, you may pass in an arrayref of strings:  [qw(agegroup=20-40 &lt;animallover&gt;=hates_animals &lt;personilized&gt;=yes)] or an arrayref of arrayrefs:  [[qw(agegroup 20-40)], [qw(&lt;animallover&gt; hates_animals)], [qw(&lt;personlized&gt; yes)]] or a hashref:  {          agegroup               =&gt; 20-40          animallover    =&gt; hates_animals          personilized   =&gt; yes  } Passing in a hashtable is the fastest in terms of internal processing, but there may be additional work on your end to generate the hash. When reading from a file, you should always use delimited strings (since that's what'd be in your file anyway), but from other sources you can experiment with hashrefs or arrayrefs and see which is faster for your uses. dynamic messages apply to <strong>only</strong> message information. use dynamic_header_data for dynamic pieces in headers. Note that the dynamic message creation will be performed in an arbitrary order. So don't expect to have one piece of the dynamic message populate into your message before another one. There is one special key for dynamic_message_data, \*(L"_default\*(R".  $dynamic-&gt;dynamic_message_data(         {                 &apos;&lt;agegroup&gt;&apos; =&gt; {                         &apos;over70&apos;        =&gt; &apos;napping&apos;,                         &apos;40-50&apos;         =&gt; &apos;amassing wealth&apos;,                         &apos;20-40&apos;         =&gt; &apos;working&apos;,                         &apos;under20&apos;       =&gt; &apos;playing&apos;,                         &apos;_default&apos;      =&gt; &apos;You have not specified an age group&apos;                 },                 &apos;&lt;animallover&gt;&apos; =&gt; {                         &apos;hates_animals&apos; =&gt; "I see you hate animals.",                         "likes_animals" =&gt; "I see you like animals.",                         "loves_animals" =&gt; "I see you love animals.",                         "_default"              =&gt; "I don&apos;t know how you feel about animals"                 },                 &apos;&lt;personalized&gt;&apos; =&gt; {                         &apos;yes&apos;   =&gt; &apos;Hi there, &lt;name&gt;&apos;,                         &apos;no&apos;    =&gt; &apos;Hi there&apos;,                 }         }  ); It should be fairly obvious - if that key is not specified, then the _default value is used. Using our earlier example, with the following list:  foo@bar.com::Mr. Foo::23::&lt;agegroup&gt;=20-40 And the same message of:  &lt;personalized&gt;. Judging by your age, which is &lt;age&gt;, you should enjoy &lt;agegroup&gt;.  Oh, and &lt;animallover&gt; The messages sent out would be, respectively:  . Judging by your age, which is 23, you should enjoy working.  Oh, and I don&apos;t know how you feel about animals. Note that since &lt;agegroup&gt; was specified, we used that value. Since &lt;animallover&gt; was not specified, the default was used, and since &lt;personalized&gt; was not specified and has no default, it was simply wiped out.</p>
  </dd>
  <dt>
    dynamic_message_delimiter
  </dt>
  <dd>
    <p>If you're reading in from a file, you can't have arrayrefs, hashrefs, whatever. They don't store nicely in text. So your data will probably be a delimited string. In that case, you need to know the delimiter. Set it with dynamic_message_delimiter. Note that your dynamic message data is just an entry in your merge data. We'll assume a merge_delimiter of '::' and a dynamic_message_value_delimiter of '=' for these examples  -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; BULK_DYNAMIC_MESSAGE)]);  #in your list  jim@jimandkoka.com::Jim::agegroup=20-40;animallover=yes  #then  $dynamic-&gt;dynamic_message_delimiter(";");  #in your list  jim@jimandkoka.com::Jim::agegroup=20-40&animallover=yes  #then  $dynamic-&gt;dynamic_message_delimiter(&apos;&&apos;);  #in your list  jim@jimandkoka.com::Jim::agegroup=20-40,,animallover=yes  #then  $dynamic-&gt;dynamic_message_delimiter(&apos;,,&apos;); Just be sure that your delimiting string occurs *only* as the delimiter and is never embedded in your data. No escaping of a delimiter is possible.</p>
  </dd>
  <dt>
    dynamic_message_value_delimiter
  </dt>
  <dd>
    <p>If you're reading in from a file, you can't have arrayrefs, hashrefs, whatever. They don't store nicely in text. So your data will probably be a delimited string. In that case, you need to know the delimiter. Set it with dynamic_message_delimiter. Note that your dynamic message data is just an entry in your merge data. We'll assume a merge_delimiter of '::' and a dynamic_message_delimiter of ';' for these examples  -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; BULK_DYNAMIC_MESSAGE)]);  #in your list  jim@jimandkoka.com::Jim::agegroup=20-40;animallover=yes  #then  $dynamic-&gt;dynamic_message_value_delimiter("=");  #in your list  jim@jimandkoka.com::Jim::agegroup:=20-40;animallover:=yes  #then  $dynamic-&gt;dynamic_message_value_delimiter(&apos;:=&apos;);  #in your list  jim@jimandkoka.com::Jim::agegroup--20-40;animallover--yes  #then  $dynamic-&gt;dynamic_message_value_delimiter(&apos;--&apos;); Just be sure that your delimiting string occurs *only* as the delimiter and is never embedded in your data. No escaping of a delimiter is possible.</p>
  </dd>
  <dt>
    dynamic_header_data
  </dt>
  <dd>
    <p>Mail merges are all well and good, they store unique information about a unique email address. But sometimes you want to group together several users and send them the same information based upon some other criteria. That's where dynamic_message_data comes in handy. dynamic_header_data is virtually identical to dynamic_message_data in terms of behavior, but it operates on the message header instead of the message instelf. This is probably easiest explained via examples. dynamic_header_data is a hashref of hashrefs, such as this:  $dynamic-&gt;dynamic_header_data(         {                 &apos;Subject&apos; =&gt; {                         &apos;polite&apos;        =&gt; "Hello, sir",                         "impolite"      =&gt; "Hello",                         "rude"          =&gt; "Hey, jerk-off"                 },                 &apos;Reply-To&apos; =&gt; {                         &apos;useful&apos;                =&gt; &apos;return@myaddress.com&apos;,                         &apos;semiuseful&apos;    =&gt; &apos;filteredreturn@myaddress.com&apos;,                         &apos;useless&apos;               =&gt; &apos;nowhere@noemail.com&apos;                 },                 &apos;X-Type&apos; =&gt; {                         &apos;premium&apos;               =&gt; "All Services are available",                         "gold"                  =&gt; "Most servies are available",                         "none"                  =&gt; "No services are available"                 }         }  ); Now then, your merge keys could be defined as such:  -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; &lt;age&gt; BULK_DYNAMIC_MESSAGE BULK_DYNAMIC_HEADERS)]); Your list would be:  foo@bar.com::Mr. Foo::23::agegroup=20-40;animallover=hates_animals;personalized=yes::Subject=polite;Reply-To:useful;X-Type:gold  me@there.com::Bob Hope::78::agegroup=over70;animallover=likes_animals;personalized=no::Subject=rude;Reply-To:useful;X-Type:premium  john@junior.com::John Jr.::14::agegroup=under20;animallover=likes_animals;personalized=yes::Subject=impolite;Reply-To:useless;X-Type:none The messages sent out would have the following headers, respectively:  Subject : Hello, sir  Reply-To: return@myaddress.com  X-Type  : Most services are available  Subject : Hey, jerk-off  Reply-To: return@myaddress.com  X-Type  : All Services are available  Subject : Hello  Reply-To: nowhere@noemail.com  X-Type  : No services are available See? easy as pie. Your dynamic headers should be specified in your merge_keys as \s-1BULK_DYNAMIC_HEADERS\s0, and should be a delimited string (in this case). Subject=polite;Reply-To=useful;X-Type=gold You can specify what delimiters you'd like to use. In this case, your dynamic_header_delimiter is ';', and your dynamic_header_value_delimiter is '='. More clearly, this information translates to the following:  Subject                =&gt; polite  Reply-To               =&gt; useful  X-Type                 =&gt; gold Note that unlike dynamic_message_data, the key in this case is not used to substitute out a string in your headers (or message), the key is used to name the header that is appended on the message. Dynamic header creation is done before mail merging, so you are more than welcome to put mail merge tokens inside your dynamic headers. Don't use the same tokens for mailmerges and dynamic headers, since the system may get confused. Alternatively, instead of a delimited string, you may pass in an arrayref of strings:  [qw(Subject=polite Reply-To=useful X-Type:gold)] or an arrayref of arrayrefs:  [[qw(Subject polite)], [qw(Reply-To useful)], [qw(X-Type gold)]] or a hashref:  {          Subject                =&gt; polite          Reply-To               =&gt; useful          X-Type                 =&gt; gold  } Passing in a hashtable is the fastest in terms of internal processing, but there may be additional work on your end to generate the hash. When reading from a file, you should always use delimited strings (since that's what'd be in your file anyway), but from other sources you can experiment with hashrefs or arrayrefs and see which is faster for your uses. dynamic headers apply to <strong>only</strong> header information. use dynamic_message_data for dynamic pieces in messages. Note that the dynamic header creation will be performed in an arbitrary order. So don't expect to have one piece of the dynamic header populate into your message before another one. There is one special key for dynamic_header_data, \*(L"_default\*(R".  $dynamic-&gt;dynamic_message_data(         {                 &apos;Subject&apos; =&gt; {                         &apos;polite&apos;        =&gt; "Hello, sir",                         "impolite"      =&gt; "Hello",                         "rude"          =&gt; "Hey, jerk-off",                         &apos;_default&apos;      =&gt; "Default subject",                 },                 &apos;Reply-To&apos; =&gt; {                         &apos;useful&apos;                =&gt; &apos;return@myaddress.com&apos;,                         &apos;semiuseful&apos;    =&gt; &apos;filteredreturn@myaddress.com&apos;,                         &apos;useless&apos;               =&gt; &apos;nowhere@noemail.com&apos;,                         &apos;_default"              =&gt; &apos;reply@to.com&apos;                 },                 &apos;X-Type&apos; =&gt; {                         &apos;premium&apos;               =&gt; "All Services are available",                         "gold"                  =&gt; "Most servies are available",                         "none"                  =&gt; "No services are available"                 }         }  ); Behavior is similar to that of _default in dynamic_message_data. If a header is specified, it is used. If no value is specified, it will attempt to use the _default value. But, in this case, if there is no value passed and no default, then the header just won't be set. Unless it is one of the speciality headers, such as From. In that case, it will attempt a specific dynamic_message_data value for From, then the \*(L"_default\*(R" value in dynamic_message_data for from, and then finally the -&gt;From value itself. If there's a header specified in -&gt;dynamic_header_data, it will be preferred to use over one set via -&gt;header. i.e., the order that a header will be checked is:  1) Is there a specific header key for the header? (Subject =&gt; polite)  2) Is there a default header key for the header? (Subject =&gt; _default)  3) Is this a specialty header (i.e., -&gt;From), and is that set? ($bulk-&gt;From())  4) Is there a generic, non-dynamic header set? (-&gt;header(&apos;Foo&apos;)) Headers will not be set more than once, no matter how many places you specify them.</p>
  </dd>
  <dt>
    dynamic_header_delimiter
  </dt>
  <dd>
    <p>If you're reading in from a file, you can't have arrayrefs, hashrefs, whatever. They don't store nicely in text. So your data will probably be a delimited string. In that case, you need to know the delimiter. Set it with dynamic_header_delimiter. Note that your dynamic header data is just an entry in your merge data. We'll assume a merge_delimiter of '::' and a dynamic_header_value_delimiter of '=' for these examples  -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; BULK_DYNAMIC_HEADERS)]);  #in your list  jim@jimandkoka.com::Jim::Subject=polite;Reply-To=useful  #then  $dynamic-&gt;dynamic_message_delimiter(";");  #in your list  jim@jimandkoka.com::Jim::Subject=polite&Reply-To=useful  #then  $dynamic-&gt;dynamic_message_delimiter(&apos;&&apos;);  #in your list  jim@jimandkoka.com::Jim::Subject=polite,,Reply-To=useful  #then  $dynamic-&gt;dynamic_message_delimiter(&apos;,,&apos;); Just be sure that your delimiting string occurs *only* as the delimiter and is never embedded in your data. No escaping of a delimiter is possible.</p>
  </dd>
  <dt>
    dynamic_header_value_delimiter
  </dt>
  <dd>
    <p>If you're reading in from a file, you can't have arrayrefs, hashrefs, whatever. They don't store nicely in text. So your data will probably be a delimited string. In that case, you need to know the delimiter. Set it with dynamic_header_delimiter. Note that your dynamic header data is just an entry in your merge data. We'll assume a merge_delimiter of '::' and a dynamic_header_delimiter of ';' for these examples  -&gt;merge_keys([qw(BULK_EMAIL &lt;name&gt; BULK_DYNAMIC_HEADERS)]);  #in your list  jim@jimandkoka.com::Jim::Subject=polite;Reply-To=useful  #then  $dynamic-&gt;dynamic_message_value_delimiter("=");  #in your list  jim@jimandkoka.com::Jim::Subject:=polite;Reply-To:=useful  #then  $dynamic-&gt;dynamic_message_value_delimiter(&apos;:=&apos;);  #in your list  jim@jimandkoka.com::Jim::Subject--polite;Reply-To--useful  #then  $dynamic-&gt;dynamic_message_value_delimiter(&apos;--&apos;); Just be sure that your delimiting string occurs *only* as the delimiter and is never embedded in your data. No escaping of a delimiter is possible.</p>
  </dd>
  <dt>
    quotemeta
  </dt>
  <dd>
    <p>boolean flag. 1/0 While mailmerging, you can specify keys that would contain regex meta data. For example:  -&gt;merge_keys [qw(*name* BULK_EMAIL)] Would generate an error, because the * character has special meaning to a regex. With quotemeta turned on, you can use that as a token because it will be quoted when used in the regex. It is <strong>highly</strong> recommended that you leave quotemeta set to 1. Set it to 0 only if you really know what you're doing.</p>
  </dd>
  <dt>
    use_envelope
  </dt>
  <dd>
    <p>In this subclass, use_envelope is a method that will always return 0. For Dynamic messages, it's impossible to use the envelope. Sorry, gang, if you want to use mail merges, then you can't use the added speed that the envelope provides you with. And it only makes sense, because envelope sending sends the exact same message to multiple people. If you're doing a mail merge, then you're customizing each message, so it wouldn't make sense to send that thing to multiple people. For raw speed, use Mail::Bulkmail and use_envelope =&gt; 1. For mail merges, use this.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    extractEmail
  </dt>
  <dd>
    <p>extractEmail is an overridden method from Mail::Bulkmail. Most of the time when you're in Mail::Bulkmail::Dynamic, the data structure that's passed around internally is a hashref, and the email address is at the key \s-1BULK_EMAIL\s0. This extracts that key and returns it. Again, this method is used internally and is not something you need to worry about. This method is known to be able to return:  MBD001 - no BULK_EMAIL defined</p>
  </dd>
  <dt>
    extractSender
  </dt>
  <dd>
    <p>extractSender is an overridden method from Mail::Bulkmail. Most of the time when you're in Mail::Bulkmail::Dynamic, the data structure that's passed around internally is a hashref, and the sender is at the key \s-1BULK_SENDER\s0. This extracts that key and returns it. Again, this method is used internally and is not something you need to worry about. This method is known to be able to return:  MBD015 - no BULK_SENDER defined</p>
  </dd>
  <dt>
    extractReplyTo
  </dt>
  <dd>
    <p>extractReplyTo is an overridden method from Mail::Bulkmail. Most of the time when you're in Mail::Bulkmail::Dynamic, the data structure that's passed around internally is a hashref, and the email address is at the key \s-1BULK_REPLYTO\s0. This extracts that key and returns it. Again, this method is used internally and is not something you need to worry about. This method is known to be able to return:  MBD016 - no BULK_REPLYTO defined</p>
  </dd>
  <dt>
    buildHeaders
  </dt>
  <dd>
    <p>Another overridden method from Mail::Bulkmail. This one constructs headers and also includes any dynamic headers, if they have been specified in \s-1BULK_DYNAMIC_HEADERS\s0. And, finally, it will do a mail merge on all headers (first global, then individual). Still called internally and still something you don't need to worry about. This -&gt;buildHeaders cannot accept the optional second headers_hash parameter This method is known to be able to return:  MBD013 - cannot bulkmail w/o From  MBD014 - cannot bulkmail w/o To</p>
  </dd>
  <dt>
    buildMessage
  </dt>
  <dd>
    <p>Another overridden method from Mail::Bulkmail. This one constructs the message and also includes any dynamic message content, if it has been specified in \s-1BULK_DYNAMIC_MESSAGE\s0. And, finally, it will do a mail merge on the message (first global, then individual). Still called internally and still something you don't need to worry about. This method is known to be able to return:  MBD012 - cannot build message w/o message</p>
  </dd>
  <dt>
    preprocess
  </dt>
  <dd>
    <p>Overridden from Mail::Bulkmail, preprocesses the data returned from getNextLine($bulk-&gt;\s-1LIST\s0) and makes sure that Mail::Bulkmail::Dynamic knows how to work with it. Constructs the internal data structures to handle mail merges, dynamic messages, and dynamic headers, for any of those items that are in use. Still called internally and still not something you need to worry about.</p>
  </dd>
  <dt>
    buildMessageHash
  </dt>
  <dd>
    <p>Given a delimited string, arrayref, or hashref, formats it according to the information contained in merge_keys and returns it. Called internally, and not something you should worry about. This method is known to be able to return:  MBD002 - no merge_delimiter  MBD003 - different number of keys and values  MBD004 - cannot bulid merge hash</p>
  </dd>
  <dt>
    buildDynamicMessageHash
  </dt>
  <dd>
    <p>Given a delimited string, arrayref, or hashref, formats it according to the information contained in dynamic_message_data and returns it. Called internally, and not something you should worry about. This method is known to be able to return:  MBD005 - cannot split w/o dynamic_message_delimiter  MBD006 - cannot split w/o dynamic_message_value_delimiter  MBD007 - invalid dynamic message key  MBD008 - cannot build dynamic message hash</p>
  </dd>
  <dt>
    buildDynamicHeaderHash
  </dt>
  <dd>
    <p>Given a delimited string, arrayref, or hashref, formats it according to the information contained in dynamic_header_data and returns it. Called internally, and not something you should worry about. This method is known to be able to return:  MBD008 - cannot split w/o dynamic_header_delimiter  MBD009 - cannot split w/o dynamic_header_value_delimiter  MBD010 - invalid dynamic header key  MBD011 - cannot build dynamic header hash</p>
  </dd>
  <dt>
    convert_to_scalar
  </dt>
  <dd>
    <p>convert_to_scalar is still used exclusively internally here, and you still don't need to worry about it. The difference is that this time, our data passed in is not just a simple email address - it's a hash. If log_all_data is set to true, then you get back the data in the form that you had originally passed it, arrayref, hashref, or delimited string. Alternatively, the user can decide to just log the email address, if the dynamic and merge information are not important.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>#simple mailing with a list called \*(L"./list.txt\*(R". Note that this is inefficient, since we're not merging we #could just use Mail::Bulkmail instead.</p><p> my $bulk = Mail::Bulkmail::Dynamic-&gt;new(         "LIST"          =&gt; "./list.txt",         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;  ) || die Mail::Bulkmail::Dynamic-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#simple merge example. Assume that this is your list file:</p><p> test1@yourdomain.com::Person #1  test2@yourdomain.com::Person #2  test3@yourdomain.com::Person #3</p><p> my $bulk = Mail::Bulkmail::Dynamic-&gt;new(         "LIST"          =&gt; "./list.txt",         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message just for you. And your name is NAME.",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;,         "merge_keys" =&gt; [qw(BULK_EMAIL NAME)]  ) || die Mail::Bulkmail::Dynamic-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#simple dynamic message example. Assume that this is your list file:</p><p> test1@yourdomain.com::Person #1::personal_message=mess1  test2@yourdomain.com::Person #2::personal_message=mess2  test3@yourdomain.com::Person #3::personal_message=mess3</p><p> my $bulk = Mail::Bulkmail::Dynamic-&gt;new(         "LIST"          =&gt; "./list.txt",         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message. And here&apos;s something personalized for you : personal_message",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;,         "merge_keys" =&gt; [qw(BULK_EMAIL NAME)],         "dynamic_message_data" =&gt; {                 "message" =&gt; {                         "mess1" =&gt; "Greetings, NAME",                         "mess2" =&gt; "Hello there, "NAME",                         "mess3" =&gt; "Hiya, NAME"                 }         }  ) || die Mail::Bulkmail::Dynamic-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#simple dynamic message example with two dynamic components. Assume that this is your list file:</p><p> test1@yourdomain.com::Person #1::personal_message=mess1;addendum=one  test2@yourdomain.com::Person #2::personal_message=mess2;addendum=two  test3@yourdomain.com::Person #3::personal_message=mess3;addendum=three</p><p> my $bulk = Mail::Bulkmail::Dynamic-&gt;new(         "LIST"          =&gt; "./list.txt",         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message. And here&apos;s something personalized for you : personal_message. addendum",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;,         "merge_keys" =&gt; [qw(BULK_EMAIL NAME)],         "dynamic_message_data" =&gt; {                 "message" =&gt; {                         "mess1" =&gt; "Greetings, NAME",                         "mess2" =&gt; "Hello there, "NAME",                         "mess3" =&gt; "Hiya, NAME"                 },                 &apos;addendum&apos; =&gt; {                         &apos;one&apos;   =&gt; &apos;You have received addendum #1&apos;,                         &apos;two&apos;   =&gt; "You&apos;re getting addendum number two",                         "three" =&gt; "3 is what you get"                 }         }  ) || die Mail::Bulkmail::Dynamic-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p><p>#simple dynamic message example with a dynamic message, and a dynamic header component. Assume that this is your list file:</p><p> test1@yourdomain.com::Person #1::personal_message=mess1;addendum=one::Subject=subject1  test2@yourdomain.com::Person #2::personal_message=mess2;addendum=two::Subject=subject1  test3@yourdomain.com::Person #3::personal_message=mess3;addendum=three::Subject=subject3</p><p> my $bulk = Mail::Bulkmail::Dynamic-&gt;new(         "LIST"          =&gt; "./list.txt",         "Subject"       =&gt; "A test message",         "Message"       =&gt; "This is my test message. And here&apos;s something personalized for you : personal_message. addendum",         "From"          =&gt; &apos;me@mydomain.com&apos;,         "Reply-To"      =&gt; &apos;replies@mydomain.com&apos;,         "merge_keys" =&gt; [qw(BULK_EMAIL NAME)],         "dynamic_message_data" =&gt; {                 "message" =&gt; {                         "mess1" =&gt; "Greetings, NAME",                         "mess2" =&gt; "Hello there, "NAME",                         "mess3" =&gt; "Hiya, NAME"                 },                 &apos;addendum&apos; =&gt; {                         &apos;one&apos;   =&gt; &apos;You have received addendum #1&apos;,                         &apos;two&apos;   =&gt; "You&apos;re getting addendum number two",                         "three" =&gt; "3 is what you get"                 }         },         "dynamic_header_data" =&gt; {                 "Subject" =&gt; {                         "subject1" =&gt; "you&apos;re getting test message #1",                         "subject2" =&gt; "you&apos;re getting test message #2",                         "subject3" =&gt; "you&apos;re getting test message #3"                 }         }  ) || die Mail::Bulkmail::Dynamic-&gt;error();</p><p> $bulk-&gt;bulkmail || die $bulk-&gt;error;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Mail::Bulkmail::Dynamic&hellip;</h2>
        <div class="sectioncontent">
<p>Mail::Bulkmail, Mail::Bulkmail::Server</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT (again)</h2>
        <div class="sectioncontent">
<p>Copyright and (c) 1999, 2000, 2001, 2002, 2003 James A Thomason \s-1III\s0 (jim@jimandkoka.com). All rights reserved. Mail::Bulkmail::Dynamic is distributed under the terms of the Perl Artistic License.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTACT INFO</h2>
        <div class="sectioncontent">
<p>So you don't have to scroll all the way back to the top, I'm Jim Thomason (jim@jimandkoka.com) and feedback is appreciated. Bug reports/suggestions/questions/etc.  Hell, drop me a line to let me know that you're using the module and that it's made your life easier.  :-)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Mail::Bulkmail::DummyServer.3pm.html"><span aria-hidden="true">&larr;</span> Mail::Bulkmail::DummyServer.3pm: Dummy class for dummy server objects</a></li>
   <li class="next"><a href="Mail::Bulkmail::Object.3pm.html">Mail::Bulkmail::Object.3pm: Used to create subclasses for mail::bulkmail. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Data::Validate::Domain: Domain validation methods</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Domain validation methods">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Data::Validate::Domain (3pm) manual">
  <meta name="twitter:description" content="Domain validation methods">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdata-validate-domain-perl-Data::Validate::Domain-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Data::Validate::Domain.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Data::Validate::Domain (3pm) manual" />
  <meta property="og:description" content="Domain validation methods" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdata-validate-domain-perl-Data::Validate::Domain-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Data::Validate::Domain<small> (3pm)</small></h1>
        <p class="lead">Domain validation methods</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::Validate::Domain.3pm.html">
      <span itemprop="name">Data::Validate::Domain: Domain validation methods</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdata-validate-domain-perl/">
      <span itemprop="name">libdata-validate-domain-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::Validate::Domain.3pm.html">
      <span itemprop="name">Data::Validate::Domain: Domain validation methods</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Data::Validate::Domain qw(is_domain);

  # as a function
  my $test = is_domain($suspect);
  die "$test is not a domain" unless defined $test;

  or

  my $test = is_domain($suspect,&#92;%options);
  die "$test is not a domain" unless defined $test;


  # or as an object
  my $v = Data::Validate::Domain-&gt;new(%options);

  my $test = $v-&gt;is_domain($suspect);
  die "$test is not a domain" unless defined $test;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module collects domain validation routines to make input validation, and untainting easier and more readable.</p><p>All functions return an untainted value if the test passes, and undef if it fails.  This means that you should always check for a defined status explicitly. Don't assume the return will be true. (e.g. is_username('0'))</p><p>The value to test is always the first (and often only) argument.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>new</strong> - constructor for \s-1OO\s0 usage
  </dt>
  <dd>
    <p>  $obj = Data::Validate::Domain-&gt;new();   my %options = (                 domain_allow_underscore =&gt; 1,   );</p><p>  or</p><p>  my %options = (                 domain_allow_single_label =&gt; 1,                 domain_private_tld =&gt; {                         &apos;privatetld1 &apos;   =&gt;      1,                         &apos;privatetld2&apos;    =&gt;      1,                 }   );</p><p>  or</p><p>  my %options = (                 domain_allow_single_label =&gt; 1,                 domain_private_tld        =&gt; qr /^(?:privatetld1|privatetld2)$/,   );</p><p>  $obj = Data::Validate::Domain-&gt;new(%options);</p>
<dl class='dl-vertical'>
  <dt>
    <em>Description</em>
  </dt>
  <dd>
    <p>Returns a Data::Validator::Domain object.  This lets you access all the validator function calls as methods without importing them into your namespace or using the clumsy <em>Data::Validate::Domain::function_name()</em> format.</p>
  </dd>
  <dt>
    <em>Options</em>
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    <strong>domain_allow_underscore</strong>
  </dt>
  <dd>
    <p>According to \s-1RFC\s0 underscores are forbidden in \*(L"hostnames\*(R" but not \*(L"domainnames\*(R". By default is_domain,is_domain_label,  and is_hostname will fail if you include underscores, setting this to a true value with authorize the use of underscores in all functions.</p>
  </dd>
  <dt>
    <strong>domain_allow_single_label</strong>
  </dt>
  <dd>
    <p>By default is_domain will fail if you ask it to verify a domain that only has a single label i.e. 'neely.cx' is good, but 'com' would fail.  If you set this option to a true value then is_domain will allow single label domains through.  This is most likely to be useful in combination with <strong>domain_private_tld</strong></p>
  </dd>
  <dt>
    <strong>domain_private_tld</strong>
  </dt>
  <dd>
    <p>By default is_domain requires all domains to have a valid \s-1TLD\s0 (i.e. com, net, org, uk, etc), this is verified using the Net::Domain::TLD module.  This behavior can be extended in two different ways.  Either a hash reference can be supplied keyed by the additional \s-1TLD\s0's, or you can supply a precompiled regular expression. \s-1NOTE:\s0  The \s-1TLD\s0 is normalized to the lower case form prior to the check being done.  This is done only for the \s-1TLD\s0 check, and does not alter the output in any way.         The hash reference example:</p><p>                domain_private_tld =&gt; {                         &apos;privatetld1 &apos;   =&gt;      1,                         &apos;privatetld2&apos;    =&gt;      1,                 }</p><p>        The precompiled regualar expression example:</p><p>                domain_private_tld        =&gt; qr /^(?:privatetld1|privatetld2)$/,</p>
  </dd>

</dl>

  </dd>
  <dt>
    <em>Returns</em>
  </dt>
  <dd>
    <p>Returns a Data::Validate::Domain object</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>is_domain</strong> - does the value look like a domain name?
  </dt>
  <dd>
    <p>  is_domain($value);   or   $obj-&gt;is_domain($value);   or   is_domain($value,&#92;%options);   or   $obj-&gt;is_domain($value,&#92;%options);</p>
<dl class='dl-vertical'>
  <dt>
    <em>Description</em>
  </dt>
  <dd>
    <p>Returns the untainted domain name if the test value appears to be a well-formed domain name. Note:  See <strong>new</strong> for list of options and how those alter the behavior of this funciton.</p>
  </dd>
  <dt>
    <em>Arguments</em>
  </dt>
  <dd>
    <p>The potential domain to test.</p>
  </dd>
  <dt>
    <em>Returns</em>
  </dt>
  <dd>
    <p>Returns the untainted domain on success, undef on failure.</p>
  </dd>
  <dt>
    <em>Notes, Exceptions, & Bugs</em>
  </dt>
  <dd>
    <p>The function does not make any attempt to check whether a domain actually exists. It only looks to see that the format is appropriate. A dotted quad (such as 127.0.0.1) is not considered a domain and will return false. See <em>Data::Validate::IP</em>\|(3) for \s-1IP\s0 Validation. Performs a lookup via Net::Domain::TLD to verify that the \s-1TLD\s0 is valid for this domain. Does not consider \*(L"domain.com.\*(R" a valid format.</p>
  </dd>
  <dt>
    <em>From \s-1RFC\s0 952</em>
  </dt>
  <dd>
    <p>   A "name" (Net, Host, Gateway, or Domain name) is a text string up    to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus    sign (-), and period (.).  Note that periods are only allowed when    they serve to delimit components of "domain style names".</p><p>   No blank or space characters are permitted as part of a    name. No distinction is made between upper and lower case.  The first    character must be an alpha character [Relaxed in RFC 1123] .  The last    character must not be a minus sign or period.</p>
  </dd>
  <dt>
    <em>From \s-1RFC\s0 1035</em>
  </dt>
  <dd>
    <p>    labels          63 octets or less     names           255 octets or less</p><p>    [snip] limit the label to 63 octets or less.</p><p>    To simplify implementations, the total length of a domain name (i.e.,     label octets and label length octets) is restricted to 255 octets or     less.</p>
  </dd>
  <dt>
    <em>From \s-1RFC\s0 1123</em>
  </dt>
  <dd>
    <p>    One aspect of host name syntax is hereby changed: the     restriction on the first character is relaxed to allow either a     letter or a digit.  Host software MUST support this more liberal     syntax.</p><p>    Host software MUST handle host names of up to 63 characters and     SHOULD handle host names of up to 255 characters.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>is_hostname</strong> - does the value look like a hostname
  </dt>
  <dd>
    <p>  is_hostname($value);   or   $obj-&gt;is_hostname($value);   or   is_hostname($value,&#92;%options);   or   $obj-&gt;is_hostname($value,&#92;%options);</p>
<dl class='dl-vertical'>
  <dt>
    <em>Description</em>
  </dt>
  <dd>
    <p>Returns the untainted hostname if the test value appears to be a well-formed hostname. Note:  See <strong>new</strong> for list of options and how those alter the behavior of this funciton.</p>
  </dd>
  <dt>
    <em>Arguments</em>
  </dt>
  <dd>
    <p>The potential hostname to test.</p>
  </dd>
  <dt>
    <em>Returns</em>
  </dt>
  <dd>
    <p>Returns the untainted hostname on success, undef on failure.</p>
  </dd>
  <dt>
    <em>Notes, Exceptions, & Bugs</em>
  </dt>
  <dd>
    <p>The function does not make any attempt to check whether a hostname actually exists. It only looks to see that the format is appropriate. Functions much like is_domain, except that it does not verify whether or not a valid \s-1TLD\s0 has been supplied and allows for there to only be a single component of the hostname (i.e www) Hostnames might or might not have a valid \s-1TLD\s0 attached.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>is_domain_label</strong> - does the value look like a domain label?
  </dt>
  <dd>
    <p>  is_domain_label($value);   or   $obj-&gt;is_domain_label($value);   or   is_domain_label($value,&#92;%options);   or   $obj-&gt;is_domain_label($value,&#92;%options);</p>
<dl class='dl-vertical'>
  <dt>
    <em>Description</em>
  </dt>
  <dd>
    <p>Returns the untainted domain label if the test value appears to be a well-formed domain label. Note:  See <strong>new</strong> for list of options and how those alter the behavior of this funciton.</p>
  </dd>
  <dt>
    <em>Arguments</em>
  </dt>
  <dd>
    <p>The potential ip to test.</p>
  </dd>
  <dt>
    <em>Returns</em>
  </dt>
  <dd>
    <p>Returns the untainted domain label on success, undef on failure.</p>
  </dd>
  <dt>
    <em>Notes, Exceptions, & Bugs</em>
  </dt>
  <dd>
    <p>The function does not make any attempt to check whether a domain label actually exists. It only looks to see that the format is appropriate.</p>
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Data::Validate::Domain&hellip;</h2>
        <div class="sectioncontent">
<p><strong>[\s-1RFC\s0 1034] [\s-1RFC\s0 1035] [\s-1RFC\s0 2181] [\s-1RFC\s0 1123]</strong></p>
<dl class='dl-vertical'>
  <dt>
    <em>Data::Validate</em>\|(3)
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>Data::Validate::IP</em>\|(3)
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Neil Neely &lt;<em>neil@neely.cx</em>&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>Thanks to Richard Sonnen &lt;<em>sonnen@richardsonnen.com</em>&gt; for writing the Data::Validate module.</p><p>Thanks to Len Reed &lt;<em>lreed@levanta.com</em>&gt; for helping develop the options mechanism for Data::Validate modules.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2005-2007 Neil Neely.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.2 or, at your option, any later version of Perl 5 you may have available.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Data::Types.3pm.html"><span aria-hidden="true">&larr;</span> Data::Types.3pm: Validate and convert data types.</a></li>
   <li class="next"><a href="Data::Validate::Email.3pm.html">Data::Validate::Email.3pm: Common email validation methods <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoTextureCubeMap: The sotexturecubemap class is used to map a cube map onto subsequent shape nodes.  shape nodes within the scope of sotexturecubemap nodes in the scenegraph (ie below the same soseparator and to the righthand side of the sotexturecubemap) will have the texture applied according to each shape type's individual characteristics. see the documentation of the various shape types (sofaceset, socube, sosphere, etc etc) for information about the specifics of how the textures will be applied.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sotexturecubemap class is used to map a cube map onto subsequent shape nodes.  shape nodes within the scope of sotexturecubemap nodes in the scenegraph (ie below the same soseparator and to the righthand side of the sotexturecubemap) will have the texture applied according to each shape type's individual characteristics. see the documentation of the various shape types (sofaceset, socube, sosphere, etc etc) for information about the specifics of how the textures will be applied.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoTextureCubeMap (3) manual">
  <meta name="twitter:description" content="The sotexturecubemap class is used to map a cube map onto subsequent shape nodes.  shape nodes within the scope of sotexturecubemap nodes in the scenegraph (ie below the same soseparator and to the righthand side of the sotexturecubemap) will have the texture applied according to each shape type's individual characteristics. see the documentation of the various shape types (sofaceset, socube, sosphere, etc etc) for information about the specifics of how the textures will be applied.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoTextureCubeMap-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoTextureCubeMap.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoTextureCubeMap (3) manual" />
  <meta property="og:description" content="The sotexturecubemap class is used to map a cube map onto subsequent shape nodes.  shape nodes within the scope of sotexturecubemap nodes in the scenegraph (ie below the same soseparator and to the righthand side of the sotexturecubemap) will have the texture applied according to each shape type's individual characteristics. see the documentation of the various shape types (sofaceset, socube, sosphere, etc etc) for information about the specifics of how the textures will be applied." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoTextureCubeMap-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoTextureCubeMap<small> (3)</small></h1>
        <p class="lead">The sotexturecubemap class is used to map a cube map onto subsequent shape nodes.  shape nodes within the scope of sotexturecubemap nodes in the scenegraph (ie below the same soseparator and to the righthand side of the sotexturecubemap) will have the texture applied according to each shape type's individual characteristics. see the documentation of the various shape types (sofaceset, socube, sosphere, etc etc) for information about the specifics of how the textures will be applied.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoTextureCubeMap.3.html">
      <span itemprop="name">SoTextureCubeMap: The sotexturecubemap class is used to map a cube map onto subsequent shape nodes.  shape nodes within the scope of sotexturecubemap nodes in the scenegraph (ie below the same soseparator and to the righthand side of the sotexturecubemap) will have the texture applied according to each shape type's individual characteristics. see the documentation of the various shape types (sofaceset, socube, sosphere, etc etc) for information about the specifics of how the textures will be applied.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoTextureCubeMap.3.html">
      <span itemprop="name">SoTextureCubeMap: The sotexturecubemap class is used to map a cube map onto subsequent shape nodes.  shape nodes within the scope of sotexturecubemap nodes in the scenegraph (ie below the same soseparator and to the righthand side of the sotexturecubemap) will have the texture applied according to each shape type's individual characteristics. see the documentation of the various shape types (sofaceset, socube, sosphere, etc etc) for information about the specifics of how the textures will be applied.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/nodes/SoTextureCubeMap.h&gt;</p><p>Inherits SoTexture.</p><h3>Public Types</h3>
<p>enum <strong>Model</strong> { <strong>MODULATE</strong> = SoMultiTextureImageElement::MODULATE, <strong>DECAL</strong> = SoMultiTextureImageElement::DECAL, <strong>BLEND</strong> = SoMultiTextureImageElement::BLEND, <strong>REPLACE</strong> = SoMultiTextureImageElement::REPLACE }</p><p>enum <strong>Wrap</strong> { <strong>REPEAT</strong> = SoMultiTextureImageElement::REPEAT, <strong>CLAMP</strong> = SoMultiTextureImageElement::CLAMP }</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> <strong>SoTextureCubeMap</strong> (void)</p><p>virtual void <strong>doAction</strong> (<strong>SoAction</strong> *action)</p><p>virtual void <strong>GLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>callback</strong> (<strong>SoCallbackAction</strong> *action)</p><p>virtual void <strong>rayPick</strong> (<strong>SoRayPickAction</strong> *action)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p><p>static SbBool <strong>readImage</strong> (const <strong>SbString</strong> &fname, int &w, int &h, int &nc, unsigned char *&bytes)</p>
<h3>Public Attributes</h3>
<p><strong>SoMFString</strong> <strong>filenames</strong></p><p><strong>SoSFImage</strong> <strong>imagePosX</strong></p><p><strong>SoSFImage</strong> <strong>imageNegX</strong></p><p><strong>SoSFImage</strong> <strong>imagePosY</strong></p><p><strong>SoSFImage</strong> <strong>imageNegY</strong></p><p><strong>SoSFImage</strong> <strong>imagePosZ</strong></p><p><strong>SoSFImage</strong> <strong>imageNegZ</strong></p><p><strong>SoSFEnum</strong> <strong>wrapS</strong></p><p><strong>SoSFEnum</strong> <strong>wrapT</strong></p><p><strong>SoSFEnum</strong> <strong>model</strong></p><p><strong>SoSFColor</strong> <strong>blendColor</strong></p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual <strong>~SoTextureCubeMap</strong> ()</p><p>virtual SbBool <strong>readInstance</strong> (<strong>SoInput</strong> *in, unsigned short flags)</p><p>virtual void <strong>notify</strong> (<strong>SoNotList</strong> *list)</p><p>int <strong>getReadStatus</strong> (void)</p><p>void <strong>setReadStatus</strong> (int s)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoTextureCubeMap</strong> class is used to map a cube map onto subsequent shape nodes.</p><p>Shape nodes within the scope of <strong>SoTextureCubeMap</strong> nodes in the scenegraph (ie below the same <strong>SoSeparator</strong> and to the righthand side of the <strong>SoTextureCubeMap</strong>) will have the texture applied according to each shape type's individual characteristics. See the documentation of the various shape types (<strong>SoFaceSet</strong>, <strong>SoCube</strong>, <strong>SoSphere</strong>, etc etc) for information about the specifics of how the textures will be applied.</p><p><strong>FILE FORMAT/DEFAULTS:</strong></p>
<pre>
TextureCubeMap {
    filenames [  ]
    imagePosX 0 0 0
    imageNegX 0 0 0
    imagePosY 0 0 0
    imageNegY 0 0 0
    imagePosZ 0 0 0
    imageNegZ 0 0 0
    wrapS REPEAT
    wrapT REPEAT
    model MODULATE
    blendColor 0 0 0
}

</pre>
<p><strong>Since:</strong></p><p>Coin 3.0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoTextureCubeMap::Model\fP</h3>
<p>Texture mapping model, for deciding how to 'merge' the texturemap with the object it is mapped onto.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>MODULATE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Texture color is multiplied by the polygon color. The result will be Phong shaded (if light model is PHONG).</p>
  </dd>
  <dt>
    <p><strong></strong><em>DECAL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Texture image overwrites polygon shading. Textured pixels will not be Phong shaded. Has undefined behaviour for grayscale and grayscale-alpha textures.</p>
  </dd>
  <dt>
    <p><strong></strong><em>BLEND </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>This model is normally used with monochrome textures (i.e. textures with one or two components). The first component, the intensity, is then used to blend between the shaded color of the polygon and the <strong>SoTextureCubeMap::blendColor</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong><em>REPLACE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Texture image overwrites polygon shading. Textured pixels will not be Phong shaded. Supports grayscale and grayscale alpha textures. This feature requires OpenGL 1.1. MODULATE will be used if OpenGL version &lt; 1.1 is detected.</p>
  </dd>

</dl>
<p>Please note that using this texture model will make your Inventor files incompatible with older versions of Coin and Inventor. You need Coin &gt;= 2.2 or TGS Inventor 4.0 to load Inventor files that uses the REPLACE texture model.</p>
<h3>enum \fBSoTextureCubeMap::Wrap\fP</h3>
<p>Enumeration of wrapping strategies which can be used when the texturemap doesn't cover the full extent of the geometry.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>REPEAT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Repeat texture when coordinate is not between 0 and 1.</p>
  </dd>
  <dt>
    <p><strong></strong><em>CLAMP </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Clamp coordinate between 0 and 1.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoTextureCubeMap::SoTextureCubeMap (void)</h3>
<p>Constructor.</p>
<h3>SoTextureCubeMap::~SoTextureCubeMap ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor. Frees up internal resources used to store texture image data.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoTextureCubeMap::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Implements <strong>SoBase</strong>.</p>
<h3>const \fBSoFieldData\fP * SoTextureCubeMap::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoFieldContainer</strong>.</p>
<h3>void SoTextureCubeMap::doAction (\fBSoAction\fP *action)\fC [virtual]\fP</h3>
<p>This function performs the typical operation of a node for any action.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoTextureCubeMap::GLRender (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGLRenderAction</strong>.</p><p>This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoTextureCubeMap::callback (\fBSoCallbackAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoCallbackAction</strong>.</p><p>Simply updates the state according to how the node behaves for the render action, so the application programmer can use the <strong>SoCallbackAction</strong> for extracting information about the scene graph.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoTextureCubeMap::rayPick (\fBSoRayPickAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoRayPickAction</strong>.</p><p>Checks the ray specification of the <em>action</em> and tests for intersection with the data of the node.</p><p>Nodes influencing relevant state variables for how picking is done also overrides this method.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>SbBool SoTextureCubeMap::readImage (const \fBSbString\fP &fname, int &w, int &h, int &nc, unsigned char *&bytes)\fC [static]\fP</h3>
<p>Not implemented in Coin; should probably not have been public in the original SGI Open Inventor API. We'll consider to implement it if requested.</p>
<h3>SbBool SoTextureCubeMap::readInstance (\fBSoInput\fP *in, unsigned shortflags)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method is mainly intended for internal use during file import operations.</p><p>It reads a definition of an instance from the input stream <em>in</em>. The input stream state points to the start of a serialized / persistant representation of an instance of this class type.</p><p>TRUE or FALSE is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not. The import process should be robust and handle corrupted input streams by returning FALSE.</p><p><em>flags</em> is used internally during binary import when reading user extension nodes, group nodes or engines.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoTextureCubeMap::notify (\fBSoNotList\fP *l)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Notifies all auditors for this instance when changes are made.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>int SoTextureCubeMap::getReadStatus (void)\fC [protected]\fP</h3>
<p>Returns read status. 1 for success, 0 for failure.</p>
<h3>void SoTextureCubeMap::setReadStatus (ints)\fC [protected]\fP</h3>
<p>Sets read status.</p><p><strong>See also:</strong></p><p><strong>getReadStatus()</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoSFString\fP SoTextureCubeMap::filenames</h3>
<p>The filenames in this order: negx, posx, negy, posy, negz, posz.</p>
<h3>\fBSoSFImage\fP SoTextureCubeMap::imagePosX</h3>
<p>The pos-x image.</p>
<h3>\fBSoSFImage\fP SoTextureCubeMap::imageNegX</h3>
<p>The neg-x image.</p>
<h3>\fBSoSFImage\fP SoTextureCubeMap::imagePosY</h3>
<p>The neg-y image.</p>
<h3>\fBSoSFImage\fP SoTextureCubeMap::imageNegY</h3>
<p>The neg-y image.</p>
<h3>\fBSoSFImage\fP SoTextureCubeMap::imagePosZ</h3>
<p>The pos-z image.</p>
<h3>\fBSoSFImage\fP SoTextureCubeMap::imageNegZ</h3>
<p>The neg-z image.</p>
<h3>\fBSoSFEnum\fP SoTextureCubeMap::wrapS</h3>
<p>Wrapping strategy for the S coordinate when the texturemap is narrower than the object to map onto.</p><p>Default value is <strong>SoTextureCubeMap::REPEAT</strong>.</p>
<h3>\fBSoSFEnum\fP SoTextureCubeMap::wrapT</h3>
<p>Wrapping strategy for the T coordinate when the texturemap is shorter than the object to map onto.</p><p>Default value is <strong>SoTextureCubeMap::REPEAT</strong>.</p>
<h3>\fBSoSFEnum\fP SoTextureCubeMap::model</h3>
<p>Texturemapping model for how the texturemap is 'merged' with the polygon primitives it is applied to. Default value is <strong>SoTextureCubeMap::MODULATE</strong>.</p>
<h3>\fBSoSFColor\fP SoTextureCubeMap::blendColor</h3>
<p>Blend color. Used when <strong>SoTextureCubeMap::model</strong> is <strong>SoTextureCubeMap::BLEND</strong>.</p><p>Default color value is [0, 0, 0], black, which means no contribution to the blending is made.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoTextureCoordinateSphere.3.html"><span aria-hidden="true">&larr;</span> SoTextureCoordinateSphere.3: The sotexturecoordinatesphere class autogenerates spheremapped texture coordinated for shapes.  file format/defaults:</a></li>
   <li class="next"><a href="SoTextureMatrixTransform.3.html">SoTextureMatrixTransform.3: The sotexturematrixtransform class is used to define a texture matrix transformation.  textures applied to shapes in the scene can be transformed by 'prefixing' in the state with instances of this node type. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

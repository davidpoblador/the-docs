<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libunwind: A (mostly) platform-independent unwind api</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A (mostly) platform-independent unwind api">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libunwind (3) manual">
  <meta name="twitter:description" content="A (mostly) platform-independent unwind api">
  <meta name="twitter:image" content="https://www.carta.tech/images/libunwind-dev-libunwind-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libunwind.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libunwind (3) manual" />
  <meta property="og:description" content="A (mostly) platform-independent unwind api" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libunwind-dev-libunwind-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libunwind<small> (3)</small></h1>
        <p class="lead">A (mostly) platform-independent unwind api</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libunwind.3.html">
      <span itemprop="name">libunwind: A (mostly) platform-independent unwind api</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libunwind-dev/">
      <span itemprop="name">libunwind-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libunwind.3.html">
      <span itemprop="name">libunwind: A (mostly) platform-independent unwind api</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;libunwind.h&gt;</p><p>int unw_getcontext(unw_context_t *);</p><p>int unw_init_local(unw_cursor_t *, unw_context_t *);</p><p>int unw_init_remote(unw_cursor_t *, unw_addr_space_t, void *);</p><p>int unw_step(unw_cursor_t *);</p><p>int unw_get_reg(unw_cursor_t *, unw_regnum_t, unw_word_t *);</p><p>int unw_get_fpreg(unw_cursor_t *, unw_regnum_t, unw_fpreg_t *);</p><p>int unw_set_reg(unw_cursor_t *, unw_regnum_t, unw_word_t);</p><p>int unw_set_fpreg(unw_cursor_t *, unw_regnum_t, unw_fpreg_t);</p><p>int unw_resume(unw_cursor_t *);</p><p>unw_addr_space_t unw_local_addr_space;</p><p>unw_addr_space_t unw_create_addr_space(unw_accessors_t, int);</p><p>void unw_destroy_addr_space(unw_addr_space_t);</p><p>unw_accessors_t unw_get_accessors(unw_addr_space_t);</p><p>void unw_flush_cache(unw_addr_space_t, unw_word_t, unw_word_t);</p><p>int unw_set_caching_policy(unw_addr_space_t, unw_caching_policy_t);</p><p>const char *unw_regname(unw_regnum_t);</p><p>int unw_get_proc_info(unw_cursor_t *, unw_proc_info_t *);</p><p>int unw_get_save_loc(unw_cursor_t *, int, unw_save_loc_t *);</p><p>int unw_is_fpreg(unw_regnum_t);</p><p>int unw_is_signal_frame(unw_cursor_t *);</p><p>int unw_get_proc_name(unw_cursor_t *, char *, size_t, unw_word_t *);</p><p>void _U_dyn_register(unw_dyn_info_t *);</p><p>void _U_dyn_cancel(unw_dyn_info_t *);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOCAL UNWINDING</h2>
        <div class="sectioncontent">
<p>Libunwind is very easy to use when unwinding a stack from within a running program. This is called <em>local</em> unwinding. Say you want to unwind the stack while executing in some function F(). In this function, you would call unw_getcontext() to get a snapshot of the CPU registers (machine-state). Then you initialize an <em>unwind cursor</em> based on this snapshot. This is done with a call to unw_init_local(). The cursor now points to the current frame, that is, the stack frame that corresponds to the current activation of function F(). The unwind cursor can then be moved ``up'' (towards earlier stack frames) by calling unw_step(). By repeatedly calling this routine, you can uncover the entire call-chain that led to the activation of function F(). A positive return value from unw_step() indicates that there are more frames in the chain, zero indicates that the end of the chain has been reached, and any negative value indicates that some sort of error has occurred.</p><p>While it is not possible to directly move the unwind cursor in the ``down'' direction (towards newer stack frames), this effect can be achieved by making copies of an unwind cursor. For example, a program that sometimes has to move ``down'' by one stack frame could maintain two cursor variables: ``curr'' and ``prev''. The former would be used as the current cursor and prev would be maintained as the ``previous frame'' cursor by copying the contents of curr to prev right before calling unw_step(). With this approach, the program could move one step ``down'' simply by copying back prev to curr whenever that is necessary. In the most extreme case, a program could maintain a separate cursor for each call frame and that way it could move up and down the callframe-chain at will.</p><p>Given an unwind cursor, it is possible to read and write the CPU registers that were preserved for the current stack frame (as identified by the cursor). Libunwind provides several routines for this purpose: unw_get_reg() reads an integer (general) register, unw_get_fpreg() reads a floating-point register, unw_set_reg() writes an integer register, and unw_set_fpreg() writes a floating-point register. Note that, by definition, only the <em>preserved</em> machine state can be accessed during an unwind operation. Normally, this state consists of the <em>callee-saved</em> (``preserved'') registers. However, in some special circumstances (e.g., in a signal handler trampoline), even the <em>caller-saved</em> (``scratch'') registers are preserved in the stack frame and, in those cases, libunwind will grant access to them as well. The exact set of registers that can be accessed via the cursor depends, of course, on the platform. However, there are two registers that can be read on all platforms: the instruction pointer (IP), sometimes also known as the ``program counter'', and the stack pointer (SP). In libunwind, these registers are identified by the macros UNW_REG_IP and UNW_REG_SP, respectively.</p><p>Besides just moving the unwind cursor and reading/writing saved registers, libunwind also provides the ability to resume execution at an arbitrary stack frame. As you might guess, this is useful for implementing non-local gotos and the exception handling needed by some high-level languages such as Java. Resuming execution with a particular stack frame simply requires calling unw_resume() and passing the cursor identifying the target frame as the only argument.</p><p>Normally, libunwind supports both local and remote unwinding (the latter will be explained in the next section). However, if you tell libunwind that your program only needs local unwinding, then a special implementation can be selected which may run much faster than the generic implementation which supports both kinds of unwinding. To select this optimized version, simply define the macro UNW_LOCAL_ONLY before including the headerfile &lt;libunwind.h&gt;. It is perfectly OK for a single program to employ both local-only and generic unwinding. That is, whether or not UNW_LOCAL_ONLY is defined is a choice that each source-file (compilation-unit) can make on its own. Independent of the setting(s) of UNW_LOCAL_ONLY, you'll always link the same library into the program (normally <strong>-l</strong>unwind). Furthermore, the portion of libunwind that manages unwind-info for dynamically generated code is not affected by the setting of UNW_LOCAL_ONLY.</p><p>If we put all of the above together, here is how we could use libunwind to write a function ``show_backtrace()'' which prints a classic stack trace:</p>
<pre>
#define UNW_LOCAL_ONLY
#include &lt;libunwind.h&gt;

void show_backtrace (void) {
  unw_cursor_t cursor; unw_context_t uc;
  unw_word_t ip, sp;

  unw_getcontext(&uc);
  unw_init_local(&cursor, &uc);
  while (unw_step(&cursor) &gt; 0) {
    unw_get_reg(&cursor, UNW_REG_IP, &ip);
    unw_get_reg(&cursor, UNW_REG_SP, &sp);
    printf ("ip = %lx, sp = %lx&#92;n", (long) ip, (long) sp);
  }
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REMOTE UNWINDING</h2>
        <div class="sectioncontent">
<p>Libunwind can also be used to unwind a stack in a ``remote'' process. Here, ``remote'' may mean another process on the same machine or even a process on a completely different machine from the one that is running libunwind. Remote unwinding is typically used by debuggers and instruction-set simulators, for example.</p><p>Before you can unwind a remote process, you need to create a new address-space object for that process. This is achieved with the unw_create_addr_space() routine. The routine takes two arguments: a pointer to a set of <em>accessor</em> routines and an integer that specifies the byte-order of the target process. The accessor routines provide libunwind with the means to communicate with the remote process. In particular, there are callbacks to read and write the process's memory, its registers, and to access unwind information which may be needed by libunwind.</p><p>With the address space created, unwinding can be initiated by a call to unw_init_remote(). This routine is very similar to unw_init_local(), except that it takes an address-space object and an opaque pointer as arguments. The routine uses these arguments to fetch the initial machine state. Libunwind never uses the opaque pointer on its own, but instead just passes it on to the accessor (callback) routines. Typically, this pointer is used to select, e.g., the thread within a process that is to be unwound.</p><p>Once a cursor has been initialized with unw_init_remote(), unwinding works exactly like in the local case. That is, you can use unw_step() to move ``up'' in the call-chain, read and write registers, or resume execution at a particular stack frame by calling unw_resume.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CROSS-PLATFORM AND MULTI-PLATFORM UNWINDING</h2>
        <div class="sectioncontent">
<p>Libunwind has been designed to enable unwinding across platforms (architectures). Indeed, a single program can use libunwind to unwind an arbitrary number of target platforms, all at the same time!</p><p>We call the machine that is running libunwind the <em>host</em> and the machine that is running the process being unwound the <em>target</em>. If the host and the target platform are the same, we call it <em>native</em> unwinding. If they differ, we call it <em>cross-platform</em> unwinding.</p><p>The principle behind supporting native, cross-platform, and multi-platform unwinding is very simple: for native unwinding, a program includes &lt;libunwind.h&gt; and uses the linker switch <strong>-l</strong>unwind. For cross-platform unwinding, a program includes &lt;libunwind-PLAT.h&gt; and uses the linker switch <strong>-l</strong>unwind-PLAT, where PLAT is the name of the target platform (e.g., ia64 for IA-64, hppa-elf for ELF-based HP PA-RISC, or x86 for 80386). Multi-platform unwinding works exactly like cross-platform unwinding, the only limitation is that a single source file (compilation unit) can include at most one libunwind header file. In other words, the platform-specific support for each supported target needs to be isolated in separate source files---a limitation that shouldn't be an issue in practice.</p><p>Note that, by definition, local unwinding is possible only for the native case. Attempting to call, e.g., unw_local_init() when targeting a cross-platform will result in a link-time error (unresolved references).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THREAD- AND SIGNAL-SAFETY</h2>
        <div class="sectioncontent">
<p>All libunwind routines are thread-safe. What this means is that multiple threads may use libunwind simulatenously. However, any given cursor may be accessed by only one thread at any given time.</p><p>To ensure thread-safety, some libunwind routines may have to use locking. Such routines <em>must not</em> be called from signal handlers (directly or indirectly) and are therefore <em>not</em> signal-safe. The manual page for each libunwind routine identifies whether or not it is signal-safe, but as a general rule, any routine that may be needed for <em>local</em> unwinding is signal-safe (e.g., unw_step() for local unwinding is signal-safe). For remote-unwinding, <em>none</em> of the libunwind routines are guaranteed to be signal-safe.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UNWINDING THROUGH DYNAMICALLY GENERATED CODE</h2>
        <div class="sectioncontent">
<p>Libunwind provides the routines _U_dyn_register() and _U_dyn_cancel() to register/cancel the information required to unwind through code that has been generated at runtime (e.g., by a just-in-time (JIT) compiler). It is important to register the information for <em>all</em> dynamically generated code because otherwise, a debugger may not be able to function properly or high-level language exception handling may not work as expected.</p><p>The interface for registering and canceling dynamic unwind info has been designed for maximum efficiency, so as to minimize the performance impact on JIT-compilers. In particular, both routines are guaranteed to execute in ``constant time'' (O(1)) and the data-structure encapsulating the dynamic unwind info has been designed to facilitate sharing, such that similar procedures can share much of the underlying information.</p><p>For more information on the libunwind support for dynamically generated code, see <a href="../man3/libunwind-dynamic.3.html"><strong>libunwind-dynamic</strong>(3)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CACHING OF UNWIND INFO</h2>
        <div class="sectioncontent">
<p>To speed up execution, libunwind may aggressively cache the information it needs to perform unwinding. If a process changes during its lifetime, this creates a risk of libunwind using stale data. For example, this would happen if libunwind were to cache information about a shared library which later on gets unloaded (e.g., via <a href="../man3/dlclose.3.html"><strong>dlclose</strong>(3)</a>).</p><p>To prevent the risk of using stale data, libunwind provides two facilities: first, it is possible to flush the cached information associated with a specific address range in the target process (or the entire address space, if desired). This functionality is provided by unw_flush_cache(). The second facility is provided by unw_set_caching_policy(), which lets a program select the exact caching policy in use for a given address-space object. In particular, by selecting the policy UNW_CACHE_NONE, it is possible to turn off caching completely, therefore eliminating the risk of stale data alltogether (at the cost of slower execution). By default, caching is enabled for local unwinding only.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>libunwind.h</p>
  </dt>
  <dd>
    <p> Headerfile to include for native (same platform) unwinding.</p>
  </dd>
  <dt>
    <p>libunwind-PLAT.h</p>
  </dt>
  <dd>
    <p> Headerfile to include when the unwind target runs on platform PLAT. For example, to unwind an IA-64 program, the header file libunwind-ia64.h should be included.</p>
  </dd>
  <dt>
    <p><strong>-l</strong>unwind</p>
  </dt>
  <dd>
    <p> Linker-switch to add when building a program that does native (same platform) unwinding.</p>
  </dd>
  <dt>
    <p><strong>-l</strong>unwind-PLAT</p>
  </dt>
  <dd>
    <p> Linker-switch to add when building a program that unwinds a program on platform PLAT. For example, to (cross-)unwind an IA-64 program, the linker switch -lunwind-ia64 should be added. Note: multiple such switches may need to be specified for programs that can unwind programs on multiple platforms.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libunwind&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/libunwind-dynamic.3.html"><strong>libunwind-dynamic</strong>(3)</a>, <a href="../man3/libunwind-ia64.3.html"><strong>libunwind-ia64</strong>(3)</a>, <a href="../man3/libunwind-ptrace.3.html"><strong>libunwind-ptrace</strong>(3)</a>, <a href="../man3/libunwind-setjmp.3.html"><strong>libunwind-setjmp</strong>(3)</a>, <a href="../man3/unw_create_addr_space.3.html"><strong>unw_create_addr_space</strong>(3)</a>, <a href="../man3/unw_destroy_addr_space.3.html"><strong>unw_destroy_addr_space</strong>(3)</a>, <a href="../man3/unw_flush_cache.3.html"><strong>unw_flush_cache</strong>(3)</a>, <a href="../man3/unw_get_accessors.3.html"><strong>unw_get_accessors</strong>(3)</a>, <a href="../man3/unw_get_fpreg.3.html"><strong>unw_get_fpreg</strong>(3)</a>, <a href="../man3/unw_get_proc_info.3.html"><strong>unw_get_proc_info</strong>(3)</a>, <a href="../man3/unw_get_proc_name.3.html"><strong>unw_get_proc_name</strong>(3)</a>, <a href="../man3/unw_get_reg.3.html"><strong>unw_get_reg</strong>(3)</a>, <a href="../man3/unw_getcontext.3.html"><strong>unw_getcontext</strong>(3)</a>, <a href="../man3/unw_init_local.3.html"><strong>unw_init_local</strong>(3)</a>, <a href="../man3/unw_init_remote.3.html"><strong>unw_init_remote</strong>(3)</a>, <a href="../man3/unw_is_fpreg.3.html"><strong>unw_is_fpreg</strong>(3)</a>, <a href="../man3/unw_is_signal_frame.3.html"><strong>unw_is_signal_frame</strong>(3)</a>, <a href="../man3/unw_regname.3.html"><strong>unw_regname</strong>(3)</a>, <a href="../man3/unw_resume.3.html"><strong>unw_resume</strong>(3)</a>, <a href="../man3/unw_set_caching_policy.3.html"><strong>unw_set_caching_policy</strong>(3)</a>, <a href="../man3/unw_set_fpreg.3.html"><strong>unw_set_fpreg</strong>(3)</a>, <a href="../man3/unw_set_reg.3.html"><strong>unw_set_reg</strong>(3)</a>, <a href="../man3/unw_step.3.html"><strong>unw_step</strong>(3)</a>, <strong>unw_strerror</strong>(3), <a href="../man3/_U_dyn_register.3.html"><strong>_U_dyn_register</strong>(3)</a>, <a href="../man3/_U_dyn_cancel.3.html"><strong>_U_dyn_cancel</strong>(3)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David Mosberger-Tang</p><p>Email: <strong>dmosberger@gmail.com</strong></p><p>WWW: <strong>http://www.nongnu.org/libunwind/</strong>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libunbound.3.html"><span aria-hidden="true">&larr;</span> libunbound.3: Unbound dns validating resolver 1.4.22 functions.</a></li>
   <li class="next"><a href="libunwind-dynamic.3.html">libunwind-dynamic.3: Libunwind-support for runtime-generated code <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cgraph: Abstract graph library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Abstract graph library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="cgraph (3) manual">
  <meta name="twitter:description" content="Abstract graph library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libgraphviz-dev-cgraph-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/cgraph.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="cgraph (3) manual" />
  <meta property="og:description" content="Abstract graph library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libgraphviz-dev-cgraph-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">cgraph<small> (3)</small></h1>
        <p class="lead">Abstract graph library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/cgraph.3.html">
      <span itemprop="name">cgraph: Abstract graph library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libgraphviz-dev/">
      <span itemprop="name">libgraphviz-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/cgraph.3.html">
      <span itemprop="name">cgraph: Abstract graph library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
5
#include &lt;graphviz/cgraph.h&gt;

</pre>
<h3>TYPES</h3>
<p>Agraph_t; Agnode_t; Agedge_t; Agdesc_t; Agdisc_t; Agsym_t; Agrec_t; Agcbdisc_t;</p>
<h3>GLOBALS</h3>
<p>Agmemdisc_t AgMemDisc; Agiddisc_t  AgIdDisc; Agiodisc_t  AgIoDisc; Agdisc_t    AgDefaultDisc;</p>
<h3>GRAPHS</h3>
<p>Agraph_t	*agopen(char *name, Agdesc_t kind, Agdisc_t *disc); int		agclose(Agraph_t *g); Agraph_t	*agread(void *channel, Agdisc_t *); Agraph_t	*agmemread(char *); void		agreadline(int line_no); void		agsetfile(char *file_name); Agraph_t	*agconcat(Agraph_t *g, void *channel, Agdisc_t *disc) int		agwrite(Agraph_t *g, void *channel); int		agnnodes(Agraph_t *g),agnedges(Agraph_t *g), agnsubg(Agraph_t * g); int		agisdirected(Agraph_t * g),agisundirected(Agraph_t * g),agisstrict(Agraph_t * g), agissimple(Agraph_t * g);</p>
<h3>SUBGRAPHS</h3>
<p>Agraph_t	*agsubg(Agraph_t *g, char *name, int createflag); Agraph_t	*agidsubg(Agraph_t * g, unsigned long id, int cflag); Agraph_t	*agfstsubg(Agraph_t *g), agnxtsubg(Agraph_t *); Agraph_t	*agparent(Agraph_t *g); int		agdelsubg(Agraph_t * g, Agraph_t * sub);    /* same as agclose() */</p>
<h3>NODES</h3>
<p>Agnode_t	*agnode(Agraph_t *g, char *name, int createflag); Agnode_t	*agidnode(Agraph_t *g, ulong id, int createflag); Agnode_t	*agsubnode(Agraph_t *g, Agnode_t *n, int createflag); Agnode_t	*agfstnode(Agraph_t *g); Agnode_t	*agnxtnode(Agraph_t *g, Agnode_t *n); Agnode_t	*agprvnode(Agraph_t *g, Agnode_t *n); Agnode_t	*aglstnode(Agraph_t *g); int		agdelnode(Agraph_t *g, Agnode_t *n); int		agdegree(Agraph_t *g, Agnode_t *n, int use_inedges, int use_outedges); int		agcountuniqedges(Agraph_t * g, Agnode_t * n, int in, int out);</p>
<h3>EDGES</h3>
<p>Agedge_t	*agedge(Agraph_t* g, Agnode_t *t, Agnode_t *h, char *name, int createflag); Agedge_t	*agidedge(Agraph_t * g, Agnode_t * t, Agnode_t * h, unsigned long id, int createflag); Agedge_t	*agsubedge(Agraph_t *g, Agedge_t *e, int createflag); Agnode_t	*aghead(Agedge_t *e), *agtail(Agedge_t *e); Agedge_t	*agfstedge(Agraph_t* g, Agnode_t *n); Agedge_t	*agnxtedge(Agraph_t* g, Agedge_t *e, Agnode_t *n); Agedge_t	*agfstin(Agraph_t* g, Agnode_t *n); Agedge_t	*agnxtin(Agraph_t* g, Agedge_t *e); Agedge_t	*agfstout(Agraph_t* g, Agnode_t *n); Agedge_t	*agnxtout(Agraph_t* g, Agedge_t *e); int		agdeledge(Agraph_t *g, Agedge_t *e); Agedge_t	*agopp(Agedge_t *e); int		ageqedge(Agedge_t *e0, Agedge_t *e1);</p>
<h3>STRING ATTRIBUTES</h3>
<p>Agsym_t	*agattr(Agraph_t *g, int kind, char *name, char *value); Agsym_t	*agattrsym(void *obj, char *name); Agsym_t	*agnxtattr(Agraph_t *g, int kind, Agsym_t *attr); char		*agget(void *obj, char *name); char		*agxget(void *obj, Agsym_t *sym); int		agset(void *obj, char *name, char *value); int		agxset(void *obj, Agsym_t *sym, char *value); int		agsafeset(void *obj, char *name, char *value, char *def); int		agcopyattr(void *, void *);</p>
<h3>RECORDS</h3>
<p>void		*agbindrec(void *obj, char *name, unsigned int size, move_to_front); Agrec_t		*aggetrec(void *obj, char *name, int move_to_front); int		agdelrec(Agraph_t *g, void *obj, char *name); void		aginit(Agraph_t * g, int kind, char *rec_name, int rec_size, int move_to_front); void		agclean(Agraph_t * g, int kind, char *rec_name);</p>
<h3>CALLBACKS</h3>
<p>int			*agpopdisc(Agraph_t *g); void		agpushdisc(Agraph_t *g, Agcbdisc_t *disc); int			agcallbacks(Agraph_t * g, int flag);</p>
<h3>MEMORY</h3>
<p>void		*agalloc(Agraph_t *g, size_t request); void		*agrealloc(Agraph_t *g, void *ptr, size_t oldsize, size_t newsize); void		agfree(Agraph_t *g, void *ptr);</p>
<h3>STRINGS</h3>
<p>char		*agstrdup(Agraph_t *, char *); char		*agstrdup_html(Agraph_t *, char *); int		aghtmlstr(char *); char		*agstrbind(Agraph_t * g, char *); int		strfree(Agraph_t *, char *); char		*agcanonStr(char *); char		*agstrcanon(char *, char *); char		*agcanon(char *, int);</p>
<h3>GENERIC OBJECTS</h3>
<p>Agraph_t	*agraphof(void*); Agraph_t	*agroot(void*); int		agcontains(Agraph_t*, void*); char		*agnameof(void*); void		agdelete(Agraph_t *g, void *obj); int		agobjkind(void *obj); Agrec_t		*AGDATA(void *obj); ulong		AGID(void *obj); int		AGTYPE(void *obj);</p>
<h3>ERROR REPORTING</h3>
<p>typedef enum { AGWARN, AGERR, AGMAX, AGPREV } agerrlevel_t; typedef int (*agusererrf) (char*); agerrlevel_t	agerrno; agerrlevel_t	agseterr(agerrlevel_t); char		*aglasterr(void); int		agerr(agerrlevel_t level, char *fmt, ...); void		agerrorf(char *fmt, ...); void		agwarningf(char *fmt, ...); int		agerrors(void); agusererrf	agseterrf(agusererrf);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Libcgraph supports graph programming by maintaining graphs in memory and reading and writing graph files. Graphs are composed of nodes, edges, and nested subgraphs. These graph objects may be attributed with string name-value pairs and programmer-defined records (see Attributes).</p><p>All of Libcgraph's global symbols have the prefix <strong>ag</strong> (case varying). In the following, if a function has a parameter <strong>int createflag</strong> and the object does not exist, the function will create the specified object if <strong>createflag</strong> is non-zero; otherwise, it will return NULL.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GRAPH AND SUBGRAPHS</h2>
        <div class="sectioncontent">
<p>A ``main'' or ``root'' graph defines a namespace for a collection of graph objects (subgraphs, nodes, edges) and their attributes. Objects may be named by unique strings or by integer IDs.</p><p><strong>agopen</strong> creates a new graph with the given name and kind. (Graph kinds are <strong>Agdirected</strong>, <strong>Agundirected</strong>, <strong>Agstrictdirected</strong>, and <strong>Agstrictundirected</strong>. A strict graph cannot have multi-edges or self-arcs.) The final argument points to a discpline structure which can be used to tailor I/O, memory allocation, and ID allocation. Typically, a NULL value will be used to indicate the default discipline <strong>AgDefaultDisc</strong>. <strong>agclose</strong> deletes a graph, freeing its associated storage. <strong>agread</strong>, <strong>agwrite</strong>, and <strong>agconcat</strong> perform file I/O using the graph file language described below. <strong>agread</strong> constructs a new graph while <strong>agconcat</strong> merges the file contents with a pre-existing graph.  Though I/O methods may be overridden, the default is that the channel argument is a stdio FILE pointer. <strong>agmemread</strong> attempts to read a graph from the input string. <strong>agsetfile</strong> and <strong>agreadline</strong> are helper functions that simply set the current file name and input line number for subsequent error reporting.</p><p>The functions <strong>agisdirected</strong>, <strong>agisundirected</strong>, <strong>agisstrict</strong>, and <strong>agissimple</strong> can be used to query if a graph is directed, undirected, strict (at most one edge with a given tail and head), or simple (strict with no loops), respectively,</p><p><strong>agsubg</strong> finds or creates a subgraph by name. <strong>agidsubg</strong> allows a programmer to specify the subgraph by a unique integer ID. A new subgraph is initially empty and is of the same kind as its parent.  Nested subgraph trees may be created. A subgraph's name is only interpreted relative to its parent. A program can scan subgraphs under a given graph using <strong>agfstsubg</strong> and agnxtsubg.  A subgraph is deleted with <strong>agdelsubg</strong> (or <strong>agclose</strong>). The <strong>agparent</strong> function returns the immediate parent graph of a subgraph, or itself if the graph is already a root graph.</p><p>By default, nodes are stored in ordered sets for efficient random access to insert, find, and delete nodes. The edges of a node are also stored in ordered sets. The sets are maintained internally as splay tree dictionaries using Phong Vo's cdt library.</p><p><strong>agnnodes</strong>, <strong>agnedges</strong>, and <strong>agnsubg</strong> return the sizes of node, edge and subgraph sets of a graph. The function <strong>agdegree</strong> returns the size of the edge set of a nodes, and takes flags to select in-edges, out-edges, or both. The function <strong>agcountuniqedges</strong> returns the size of the edge set of a nodes, and takes flags to select in-edges, out-edges, or both. Unlike <strong>agdegree</strong>, each loop is only counted once.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NODES</h2>
        <div class="sectioncontent">
<p>A node is created by giving a unique string name or programmer defined integer ID, and is represented by a unique internal object. (Node equality can checked by pointer comparison.)</p><p><strong>agnode</strong> searches in a graph or subgraph for a node with the given name, and returns it if found. <strong>agidnode</strong> allows a programmer to specify the node by a unique integer ID. <strong>agsubnode</strong> performs a similar operation on an existing node and a subgraph.</p><p><strong>agfstnode</strong> and <strong>agnxtnode</strong> scan node lists. <strong>agprvnode</strong> and <strong>aglstnode</strong> are symmetric but scan backward. The default sequence is order of creation (object timestamp.) <strong>agdelnode</strong> removes a node from a graph or subgraph.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EDGES</h2>
        <div class="sectioncontent">
<p>An abstract edge has two endpoint nodes called tail and head where all outedges of the same node have it as the tail value and similarly all inedges have it as the head. In an undirected graph, head and tail are interchangeable. If a graph has multi-edges between the same pair of nodes, the edge's string name behaves as a secondary key.</p><p><strong>agedge</strong> searches in a graph or subgraph for an edge between the given endpoints (with an optional multi-edge selector name) and returns it if found or created. Note that, in undirected graphs, a search tries both orderings of the tail and head nodes. If the <strong>name</strong> is NULL, then an anonymous internal value is generated. <strong>agidedge</strong> allows a programmer to create an edge by giving its unique integer ID. <strong>agsubedge</strong> performs a similar operation on an existing edge and a subgraph. <strong>agfstin</strong>, <strong>agnxtin</strong>, <strong>agfstout</strong>, and <strong>agnxtout</strong> visit directed in- and out- edge lists, and ordinarily apply only in directed graphs. <strong>agfstedge</strong> and <strong>agnxtedge</strong> visit all edges incident to a node.  <strong>agtail</strong> and <strong>aghead</strong> get the endpoint of an edge. <strong>agdeledge</strong> removes an edge from a graph or subgraph.</p><p>Note that an abstract edge has two distinct concrete representations: as an in-edge and as an out-edge. In particular, the pointer as an out-edge is different from the pointer as an in-edge. The function <strong>ageqedge</strong> canonicalizes the pointers before doing a comparison and so can be used to test edge equality. The sense of an edge can be flipped using <strong>agopp</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNAL ATTRIBUTES</h2>
        <div class="sectioncontent">
<p>Programmer-defined values may be dynamically attached to graphs, subgraphs, nodes, and edges. Such values are either character string data (for I/O) or uninterpreted binary records (for implementing algorithms efficiently).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STRING ATTRIBUTES</h2>
        <div class="sectioncontent">
<p>String attributes are handled automatically in reading and writing graph files. A string attribute is identified by name and by an internal symbol table entry (<strong>Agsym_t</strong>) created by Libcgraph. Attributes of nodes, edges, and graphs (with their subgraphs) have separate namespaces.  The contents of an <strong>Agsym_t</strong> have a <strong>char* name</strong> for the attribute's name, a <strong>char* defval</strong> field for the attribute's default value, and an <strong>int id</strong> field containing the index of the attribute's specific value for an object in the object's array of attribute values.</p><p><strong>agattr</strong> creates or looks up attributes. <strong>kind</strong> may be <strong>AGRAPH</strong>, <strong>AGNODE</strong>, or <strong>AGEDGE</strong>. If <strong>value</strong> is <strong>(char*)0)</strong>, the request is to search for an existing attribute of the given kind and name. Otherwise, if the attribute already exists, its default for creating new objects is set to the given value; if it does not exist, a new attribute is created with the given default, and the default is applied to all pre-existing objects of the given kind. If <strong>g</strong> is NULL, the default is set for all graphs created subsequently. <strong>agattrsym</strong> is a helper function that looks up an attribute for a graph object given as an argument. <strong>agnxtattr</strong> permits traversing the list of attributes of a given type.  If <strong>NULL</strong> is passed as an argument it gets the first attribute; otherwise it returns the next one in succession or returns <strong>NULL</strong> at the end of the list. <strong>agget</strong> and <strong>agset</strong> allow fetching and updating a string attribute for an object taking the attribute name as an argument. <strong>agxget</strong> and <strong>agxset</strong> do this but with an attribute symbol table entry as an argument (to avoid the cost of the string lookup). Note that agset will fail unless the attribute is first defined using <strong>agattr</strong>. <strong>agsafeset</strong> is a convenience function that ensures the given attribute is declared before setting it locally on an object.</p><p>It is sometimes convenient to copy all of the attributes from one object to another. This can be done using <strong>agcopyattr</strong>. This fails and returns non-zero of argument objects are different kinds, or if all of the attributes of the source object have not been declared for the target object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STRINGS</h2>
        <div class="sectioncontent">
<p>Libcgraph performs its own storage management of strings as reference-counted strings. The caller does not need to dynamically allocate storage.</p><p><strong>agstrdup</strong> returns a pointer to a reference-counted copy of the argument string, creating one if necessary. <strong>agstrbind</strong> returns a pointer to a reference-counted string if it exists, or NULL if not. All uses of cgraph strings need to be freed using <strong>agstrfree</strong> in order to correctly maintain the reference count.</p><p>The cgraph parser handles HTML-like strings. These should be indistinguishable from other strings for most purposes. To create an HTML-like string, use <strong>agstrdup_html</strong>. The <strong>aghtmlstr</strong> function can be used to query if a string is an ordinary string or an HTML-like string.</p><p><strong>agcanonStr</strong> returns a pointer to a version of the input string canonicalized for output for later re-parsing. This includes quoting special characters and keywords. It uses its own internal buffer, so the value will be lost on the next call to <strong>agcanonStr</strong>. <strong>agstrcanon</strong> is an unsafe version of <strong>agcanonStr</strong>, in which the application passes in a buffer as the second argument. Note that the buffer may not be used; if the input string is in canonical form, the function will just return a pointer to it. For both of the functions, the input string must have been created using <strong>agstrdup</strong> or <strong>agstrdup_html</strong>. Finally, <strong>agcanonStr</strong> is identical with <strong>agcanonStr</strong> except it can be used with any character string. The second argument indicates whether or not the string should be canonicalized as an HTML-like string.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RECORDS</h2>
        <div class="sectioncontent">
<p>Uninterpreted records may be attached to graphs, subgraphs, nodes, and edges for efficient operations on values such as marks, weights, counts, and pointers needed by algorithms.  Application programmers define the fields of these records, but they must be declared with a common header as shown below.</p><p>typedef struct {</p>
<pre>
    Agrec_t        header;
    /* programmer-defined fields follow */
</pre>
<p>} user_data_t;</p><p>Records are created and managed by Libcgraph. A programmer must explicitly attach them to the objects in a graph, either to individual objects one at a time via <strong>agbindrec</strong>, or to all the objects of the same class in a graph via <strong>aginit</strong>. (Note that for graphs, aginit is applied recursively to the graph and its subgraphs if rec_size is negative (of the actual rec_size.)) The <strong>name</strong> argument of a record distinguishes various types of records, and is programmer defined (Libcgraph reserves the prefix <strong>_ag</strong>). If size is 0, the call to <strong>agbindrec</strong> is simply a lookup. The function <strong>aggetrec</strong> can also be used for lookup. <strong>agdelrec</strong> deletes a named record from one object. <strong>agclean</strong> does the same for all objects of the same class in an entire graph.</p><p>Internally, records are maintained in circular linked lists attached to graph objects. To allow referencing application-dependent data without function calls or search, Libcgraph allows setting and locking the list pointer of a graph, node, or edge on a particular record. This pointer can be obtained with the macro <strong>AGDATA(obj)</strong>. A cast, generally within a macro or inline function, is usually applied to convert the list pointer to an appropriate programmer-defined type.</p><p>To control the setting of this pointer, the <strong>move_to_front</strong> flag may be <strong>TRUE</strong> or <strong>FALSE</strong>. If <strong>move_to_front</strong> is <strong>TRUE</strong>, the record will be locked at the head of the list, so it can be accessed directly by <strong>AGDATA(obj)</strong>. The lock can be subsequently released or reset by a call to <strong>aggetrec</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISCIPLINES</h2>
        <div class="sectioncontent">
<p>(This section is not intended for casual users.) Programmer-defined disciplines customize certain resources- ID namespace, memory, and I/O - needed by Libcgraph. A discipline struct (or NULL) is passed at graph creation time.</p><p>struct Agdisc_s {            /* user's discipline */</p>
<pre>
    Agmemdisc_t            *mem;
    Agiddisc_t            *id;
    Agiodisc_t            *io;
</pre>
<p>} ;</p><p>A default discipline is supplied when NULL is given for any of these fields.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ID DISCIPLINE</h2>
        <div class="sectioncontent">
<p>An ID allocator discipline allows a client to control assignment of IDs (uninterpreted integer values) to objects, and possibly how they are mapped to and from strings.</p><p>struct Agiddisc_s {             /* object ID allocator */</p>
<pre>
    void *(*open) (Agraph_t * g, Agdisc_t*);       /* associated with a graph */
    long (*map) (void *state, int objtype, char *str, unsigned long *id, int createflag);
    long (*alloc) (void *state, int objtype, unsigned long id);
    void (*free) (void *state, int objtype, unsigned long id);
    char *(*print) (void *state, int objtype, unsigned long id);
    void (*close) (void *state);
</pre>
<p>};</p><p><em>open</em> permits the ID discipline to initialize any data structures that it maintains per individual graph. Its return value is then passed as the first argument (void *state) to all subsequent ID manager calls.</p><p><em>alloc</em> informs the ID manager that Libcgraph is attempting to create an object with a specific ID that was given by a client. The ID manager should return TRUE (nonzero) if the ID can be allocated, or FALSE (which aborts the operation).</p><p><em>free</em> is called to inform the ID manager that the object labeled with the given ID is about to go out of existence.</p><p><em>map</em> is called to create or look-up IDs by string name (if supported by the ID manager).  Returning TRUE (nonzero) in all cases means that the request succeeded (with a valid ID stored through 5result.  There are four cases:</p><p><em>name != NULL</em> and 5createflag == 1<em>:</em> This requests mapping a string (e.g. a name in a graph file) into a new ID. If the ID manager can comply, then it stores the result and returns TRUE. It is then also responsible for being able to 5print the ID again as a string.  Otherwise the ID manager may return FALSE but it must implement the following (at least for graph file reading and writing to work):</p><p>5name == NULL and 5createflag == 1: The ID manager creates a unique new ID of its own choosing. Although it may return FALSE if it does not support anonymous objects, but this is strongly discouraged (to support "local names" in graph files.)</p><p>5name != NULL and 5createflag == 0: This is a namespace probe.  If the name was previously mapped into an allocated ID by the ID manager, then the manager must return this ID. Otherwise, the ID manager may either return FALSE, or may store any unallocated ID into result. (This is convenient, for example, if names are known to be digit strings that are directly converted into integer values.)</p><p>5name == NULL and 5createflag == 0: forbidden.</p><p>5print is allowed to return a pointer to a static buffer; a caller must copy its value if needed past subsequent calls. 5NULL should be returned by ID managers that do not map names.</p><p>The 5map and 5alloc calls do not pass a pointer to the newly allocated object.  If a client needs to install object pointers in a handle table, it can obtain them via new object callbacks.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IO DISCIPLINE</h2>
        <div class="sectioncontent">
<p>The I/O discipline provides an abstraction for the reading and writing of graphs. struct Agiodisc_s {</p>
<pre>
    int        (*fread)(void *chan, char *buf, int bufsize);
    int        (*putstr)(void *chan, char *str);
    int        (*flush)(void *chan);    /* sync */
</pre>
<p>} ; Normally, the <strong>FILE</strong> structure and its related functions are used for I/O. At times, though, an application may need to use a totally different type of character source. The associated state or stream information is provided by the <em>chan</em> argument to <strong>agread</strong> or <strong>agwrite</strong>. The discipline function <em>fread</em> and <em>putstr</em> provide the corresponding functions for read and writing.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMORY DISCIPLINE</h2>
        <div class="sectioncontent">
<p>Memory management in Libcgraph is handled on a per graph basis using the memory discipline. struct Agmemdisc_s {    /* memory allocator */</p>
<pre>
    void    *(*open)(Agdisc_t*);        /* independent of other resources */
    void    *(*alloc)(void *state, size_t req);
    void    *(*resize)(void *state, void *ptr, size_t old, size_t req);
    void    (*free)(void *state, void *ptr);
    void    (*close)(void *state);
</pre>
<p>} ; The <strong>open</strong> function is used to initialize the memory subsystem, returning state information that is passed to the calls to <strong>alloc</strong>, <strong>resize</strong>, and <strong>free</strong>. The semantics of these should be comparable to the standard C library functions <strong>malloc</strong>, <strong>realloc</strong>, and <strong>free</strong>, except that new space created by <strong>agalloc</strong> and <strong>agrealloc</strong> should be zeroed out. The <strong>close</strong> function is used to terminate the memory subsystem, freeing any additional open resources. For actual allocation, the library uses the functions <strong>agalloc</strong>, <strong>agrealloc</strong>, and <strong>agfree</strong>, which provide simple wrappers for the underlying discipline functions <strong>alloc</strong>, <strong>resize</strong>, and <strong>free</strong>.</p><p>When Libcgraph is compiled with Vmalloc (which is not the default), each graph has its own heap. Programmers may allocate application-dependent data within the same heap as the rest of the graph.  The advantage is that a graph can be deleted by atomically freeing its entire heap without scanning each individual node and edge.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACKS</h2>
        <div class="sectioncontent">
<p>An <strong>Agcbdisc_t</strong> defines callbacks to be invoked by Libcgraph when initializing, modifying, or finalizing graph objects. Disciplines are kept on a stack.  Libcgraph automatically calls the methods on the stack, top-down.  Callbacks are installed with <strong>agpushdisc</strong>, uninstalled with <strong>agpopdisc</strong>, and can be held pending or released via <strong>agcallbacks</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GENERIC OBJECTS</h2>
        <div class="sectioncontent">
<p><strong>agroot</strong> takes any graph object (graph, subgraph, node, edge) and returns the root graph in which it lives. <strong>agraphof</strong> does the same, except it is the identity function on graphs and subgraphs. Note that there is no function to return the least subgraph containing an object, in part because this is not well-defined as nodes and edges may be in incomparable subgraphs.</p><p><strong>agcontains</strong>(<em>g</em>,<em>obj</em>) returns non-zero if <em>obj</em> is a member of (sub)graph <em>g</em>. <strong>agdelete</strong>(<em>g</em>,<em>obj</em>) is equivalent to <strong>agclose</strong>, <strong>agdelnode</strong>, and <strong>agdeledge</strong> for <em>obj</em> being a graph, node or edge, respectively. It returns -1 if <em>obj</em> does not belong to <em>g</em>.</p><p><strong>AGDATA</strong>, <strong>AGID</strong>, and <strong>AGTYPE</strong> are macros returning the specified fields of the argument object. The first is described in the <strong>RECORDS</strong> section above. The second returns the unique integer ID associated with the object. The last returns <strong>AGRAPH</strong>, <strong>AGNODE</strong>, and <strong>AGEDGE</strong> depending on the type of the object.</p><p><strong>agnameof</strong> returns a string descriptor for the object. It returns the name of the node or graph, and the key of an edge. <strong>agobjkind</strong> is a synonym for <strong>AGTYPE</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERROR REPORTING</h2>
        <div class="sectioncontent">
<p>The library provides a variety of mechanisms to control the reporting of errors and warnings. At present, there are basically two types of messages: warnings and errors. A message is only written if its type has higher priority than a programmer-controlled minimum, which is <strong>AGWARN</strong> by default. The programmer can set this value using <strong>agseterr</strong>, which returns the previous value. Calling <strong>agseterr(AGMAX)</strong> turns off the writing of messages.</p><p>The function <strong>agerr</strong> if the main entry point for reporting an anomaly. The first argument indicates the type of message. Usually, the first argument in <strong>AGWARN</strong> or <strong>AGERR</strong> to indicate warnings and errors, respectively. Sometimes additional context information is only available in functions calling the function where the error is actually caught. In this case, the calling function can indicate that it is continuing the current error by using <strong>AGPREV</strong> as the first argument. The remaining arguments to <strong>agerr</strong> are the same as the arguments to <strong>printf</strong>.</p><p>The functions <strong>agwarningf</strong> and <strong>agerrorf</strong> are shorthand for <strong>agerr(AGERR,...)</strong> and <strong>agerr(AGWARN,...)</strong>, respectively.</p><p>Some applications desire to directly control the writing of messages. Such an application can use the function <strong>agseterrf</strong> to register the function that the library should call to actually write the message. The previous error function is returned. By default, the message is written to <strong>stderr</strong>.</p><p>Errors not written are stored in a log file. The last recorded error can be retreived by calling <strong>aglasterr</strong>.</p><p>The function <strong>agerrors</strong> returns non-zero if errors have been reported.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE PROGRAM</h2>
        <div class="sectioncontent">
<p>#include &lt;cgraph.h&gt; typedef struct {Agrec_t hdr; int x,y,z;} mydata;</p><p>main(int argc, char **argv) {</p>
<pre>
    Agraph_t    *g;
    Agnode_t    *v;
    Agedge_t    *e;
    Agsym_t     *attr;
    Dict_t      *d
    int         cnt;
    mydata      *p;
</pre>

<pre>
    if (g = agread(stdin,NIL(Agdisc_t*))) {
        cnt = 0; attr = 0;
        while (attr = agnxtattr(g, AGNODE, attr)) cnt++;
        printf("The graph %s has %d attributes\n",agnameof(g),cnt);
</pre>

<pre>
        /* make the graph have a node color attribute, default is blue */
        attr = agattr(g,AGNODE,"color","blue");
</pre>

<pre>
        /* create a new graph of the same kind as g */
        h = agopen("tmp",g-&gt;desc);
</pre>

<pre>
        /* this is a way of counting all the edges of the graph */
        cnt = 0;
        for (v = agfstnode(g); v; v = agnxtnode(g,v))
            for (e = agfstout(g,v); e; e = agnxtout(g,e))
                cnt++;
</pre>

<pre>
        /* attach records to edges */
        for (v = agfstnode(g); v; v = agnxtnode(g,v))
            for (e = agfstout(g,v); e; e; = agnxtout(g,e)) {
                p = (mydata*) agbindrec(g,e,"mydata",sizeof(mydata),TRUE);
                p-&gt;x = 27;  /* meaningless data access example */
                ((mydata*)(AGDATA(e)))-&gt;y = 999; /* another example */
        }
    }
</pre>
<p>}</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE GRAPH FILES</h2>
        <div class="sectioncontent">
<p>digraph G {</p>
<pre>
    a -&gt; b;
    c [shape=box];
    a -&gt; c [weight=29,label="some text];
    subgraph anything {
        /* the following affects only x,y,z */
        node [shape=circle];
        a; x; y -&gt; z; y -&gt; z;  /* multiple edges */
    }
</pre>
<p>}</p><p>strict graph H {</p>
<pre>
    n0 -- n1 -- n2 -- n0;  /* a cycle */
    n0 -- {a b c d};       /* a star */
    n0 -- n3;
    n0 -- n3 [weight=1];   /* same edge because graph is strict */
</pre>
<p>}</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO cgraph&hellip;</h2>
        <div class="sectioncontent">
<p><strong>Libcdt</strong>(3)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>It is difficult to change endpoints of edges, delete string attributes or modify edge keys.  The work-around is to create a new object and copy the contents of an old one (but new object obviously has a different ID, internal address, and object creation timestamp).</p><p>The API lacks convenient functions to substitute programmer-defined ordering of nodes and edges but in principle this can be supported.</p><p>The library is not thread safe.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Stephen North, north@research.att.com, AT&T Research.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="cgiwrap_writevf.3.html"><span aria-hidden="true">&larr;</span> cgiwrap_writevf.3: A wrapper for vprintf</a></li>
   <li class="next"><a href="cgsi_plugin.h.3.html">cgsi_plugin.h.3: Header file for the gsi gsoap plugin. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

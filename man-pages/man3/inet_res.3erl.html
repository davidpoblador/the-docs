<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>inet_res: A rudimentary dns client</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A rudimentary dns client">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="inet_res (3erl) manual">
  <meta name="twitter:description" content="A rudimentary dns client">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-inet_res-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/inet_res.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="inet_res (3erl) manual" />
  <meta property="og:description" content="A rudimentary dns client" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-inet_res-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">inet_res<small> (3erl)</small></h1>
        <p class="lead">A rudimentary dns client</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/inet_res.3erl.html">
      <span itemprop="name">inet_res: A rudimentary dns client</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/inet_res.3erl.html">
      <span itemprop="name">inet_res: A rudimentary dns client</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Performs DNS name resolving towards recursive name servers</p><p>See also <strong> ERTS User's Guide: Inet configuration </strong> for more information on how to configure an Erlang runtime system for IP communication and how to enable this DNS client by defining <em>'dns'</em> as a lookup method. It then acts as a backend for the resolving functions in <strong>inet</strong>.</p><p>This DNS client can resolve DNS records even if it is not used for normal name resolving in the node.</p><p>This is not a full-fledged resolver. It is just a DNS client that relies on asking trusted recursive nameservers.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAME RESOLVING</h2>
        <div class="sectioncontent">
<p>UDP queries are used unless resolver option <em>usevc</em> is <em>true</em>, which forces TCP queries. If the query is to large for UDP, TCP is used instead. For regular DNS queries 512 bytes is the size limit. When EDNS is enabled (resolver option <em>edns</em> is set to the EDNS version i.e <em>0</em> instead of <em>false</em>), resolver option <em>udp_payload_size</em> sets the limit. If a nameserver replies with the TC bit set (truncation), indicating the answer is incomplete, the query is retried to that nameserver using TCP. The resolver option <em>udp_payload_size</em> also sets the advertised size for the max allowed reply size, if EDNS is enabled, otherwise the nameserver uses the limit 512 byte. If the reply is larger it gets truncated, forcing a TCP re-query.</p><p>For UDP queries, the resolver options <em>timeout</em> and <em>retry</em> control retransmission. Each nameserver in the <em>nameservers</em> list is tried with a timeout of <em>timeout</em> / <em>retry</em>. Then all nameservers are tried again doubling the timeout, for a total of <em>retry</em> times.</p><p>For queries that not use the <em>search</em> list, if the query to all <em>nameservers</em> results in <em>{error,nxdomain}</em>or an empty answer, the same query is tried for the <em>alt_nameservers</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">
<p>Resolver types:</p>
<pre>
<strong>res_option()</strong> = {alt_nameservers, [<strong>nameserver()</strong>]}

             | {edns, 0 | false}

             | {inet6, boolean()}

             | {nameservers, [<strong>nameserver()</strong>]}

             | {recurse, boolean()}

             | {retry, integer()}

             | {timeout, integer()}

             | {udp_payload_size, integer()}

             | {usevc, boolean()}

</pre>

<pre>
<strong>nameserver()</strong> = {<strong>inet:ip_address()</strong>, Port :: 1..65535}

</pre>

<pre>
<strong>res_error()</strong> = formerr

            | qfmterror

            | servfail

            | nxdomain

            | notimp

            | refused

            | badvers

            | timeout

</pre>
<p>DNS types:</p>
<pre>
<strong>dns_name()</strong> = string()

</pre>
<p>A string with no adjacent dots.</p>
<pre>
<strong>rr_type()</strong> = a

          | aaaa

          | cname

          | gid

          | hinfo

          | ns

          | mb

          | md

          | mg

          | mf

          | minfo

          | mx

          | naptr

          | null

          | ptr

          | soa

          | spf

          | srv

          | txt

          | uid

          | uinfo

          | unspec

          | wks

</pre>

<pre>
<strong>dns_class()</strong> = in | chaos | hs | any

</pre>

<pre>
<strong>dns_msg()</strong> = term()

</pre>
<p>This is the start of a hiearchy of opaque data structures that can be examined with access functions in inet_dns that return lists of {Field,Value} tuples. The arity 2 functions just return the value for a given field.</p>
<pre>
dns_msg() = DnsMsg
    inet_dns:msg(DnsMsg) -&gt;
        [ {header, dns_header()}
        | {qdlist, dns_query()}
        | {anlist, dns_rr()}
        | {nslist, dns_rr()}
        | {arlist, dns_rr()} ]
    inet_dns:msg(DnsMsg, header) -&gt; dns_header() % for example
    inet_dns:msg(DnsMsg, Field) -&gt; Value

dns_header() = DnsHeader
    inet_dns:header(DnsHeader) -&gt;
        [ {id, integer()}
        | {qr, boolean()}
        | {opcode, 'query' | iquery | status | integer()}
        | {aa, boolean()}
        | {tc, boolean()}
        | {rd, boolean()}
        | {ra, boolean()}
        | {pr, boolean()}
        | {rcode, integer(0..16)} ]
    inet_dns:header(DnsHeader, Field) -&gt; Value

query_type() = axfr | mailb | maila | any | rr_type()

dns_query() = DnsQuery
    inet_dns:dns_query(DnsQuery) -&gt;
        [ {domain, dns_name()}
        | {type, query_type()}
        | {class, dns_class()} ]
    inet_dns:dns_query(DnsQuery, Field) -&gt; Value

dns_rr() = DnsRr
    inet_dns:rr(DnsRr) -&gt; DnsRrFields | DnsRrOptFields
    DnsRrFields = [ {domain, dns_name()}
                  | {type, rr_type()}
                  | {class, dns_class()}
                  | {ttl, integer()}
                  | {data, dns_data()} ]
    DnsRrOptFields = [ {domain, dns_name()}
                     | {type, opt}
                     | {udp_payload_size, integer()}
                     | {ext_rcode, integer()}
                     | {version, integer()}
                     | {z, integer()}
                     | {data, dns_data()} ]
    inet_dns:rr(DnsRr, Field) -&gt; Value

There is an info function for the types above:

inet_dns:record_type(dns_msg()) -&gt; msg;
inet_dns:record_type(dns_header()) -&gt; header;
inet_dns:record_type(dns_query()) -&gt; dns_query;
inet_dns:record_type(dns_rr()) -&gt; rr;
inet_dns:record_type(_) -&gt; undefined.

So; inet_dns:(inet_dns:record_type(X))(X) will convert
any of these data structures into a {Field,Value} list.
</pre>

<pre>
<strong>dns_data()</strong> = <strong>dns_name()</strong>

           | <strong>inet:ip4_address()</strong>

           | <strong>inet:ip6_address()</strong>

           | {MName :: <strong>dns_name()</strong>,

              RName :: <strong>dns_name()</strong>,

              Serial :: integer(),

              Refresh :: integer(),

              Retry :: integer(),

              Expiry :: integer(),

              Minimum :: integer()}

           | {<strong>inet:ip4_address()</strong>,

              Proto :: integer(),

              BitMap :: binary()}

           | {CpuString :: string(), OsString :: string()}

           | {RM :: <strong>dns_name()</strong>, EM :: <strong>dns_name()</strong>}

           | {Prio :: integer(), <strong>dns_name()</strong>}

           | {Prio :: integer(),

              Weight :: integer(),

              Port :: integer(),

              <strong>dns_name()</strong>}

           | {Order :: integer(),

              Preference :: integer(),

              Flags :: string(),

              Services :: string(),

              Regexp :: string(),

              <strong>dns_name()</strong>}

           | [string()]

           | binary()

</pre>
<p><em>Regexp</em> is a string with characters encoded in the UTF-8 coding standard.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
getbyname(Name, Type) -&gt; {ok, Hostent} | {error, Reason}

</pre>

<pre>
<strong></strong>
getbyname(Name, Type, Timeout) -&gt; {ok, Hostent} | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>dns_name()</strong></p><p>Type = <strong>rr_type()</strong></p><p>Timeout = timeout()</p><p>Hostent = <strong>inet:hostent()</strong></p><p>Reason = <strong>inet:posix()</strong> | <strong>res_error()</strong></p><p>Resolve a DNS record of the given type for the given host, of class <em>in</em>. On success returns a <em>hostent()</em> record with <em>dns_data()</em> elements in the address list field.</p><p>This function uses the resolver option <em>search</em> that is a list of domain names. If the name to resolve contains no dots, it is prepended to each domain name in the search list, and they are tried in order. If the name contains dots, it is first tried as an absolute name and if that fails the search list is used. If the name has a trailing dot it is simply supposed to be an absolute name and the search list is not used.</p>
<pre>
<strong></strong>
gethostbyaddr(Address) -&gt; {ok, Hostent} | {error, Reason}

</pre>

<pre>
<strong></strong>
gethostbyaddr(Address, Timeout) -&gt; {ok, Hostent} | {error, Reason}

</pre>
<p>Types:</p><p>Address = <strong>inet:ip_address()</strong></p><p>Timeout = timeout()</p><p>Hostent = <strong>inet:hostent()</strong></p><p>Reason = <strong>inet:posix()</strong> | <strong>res_error()</strong></p><p>Backend functions used by <strong> inet:gethostbyaddr/1 </strong>.</p>
<pre>
<strong></strong>
gethostbyname(Name) -&gt; {ok, Hostent} | {error, Reason}

</pre>

<pre>
<strong></strong>
gethostbyname(Name, Family) -&gt; {ok, Hostent} | {error, Reason}

</pre>

<pre>
<strong></strong>
gethostbyname(Name, Family, Timeout) -&gt;
<strong></strong>
                 {ok, Hostent} | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>dns_name()</strong></p><p>Hostent = <strong>inet:hostent()</strong></p><p>Timeout = timeout()</p><p>Family = <strong>inet:address_family()</strong></p><p>Reason = <strong>inet:posix()</strong> | <strong>res_error()</strong></p><p>Backend functions used by <strong> inet:gethostbyname/1,2 </strong>.</p><p>This function uses the resolver option <em>search</em> just like <strong>getbyname/2,3</strong>.</p><p>If the resolver option <em>inet6</em> is <em>true</em>, an IPv6 address is looked up, and if that fails the IPv4 address is looked up and returned on IPv6 mapped IPv4 format.</p>
<pre>
<strong></strong>
lookup(Name, Class, Type) -&gt; [dns_data()]

</pre>

<pre>
<strong></strong>
lookup(Name, Class, Type, Opts) -&gt; [dns_data()]

</pre>

<pre>
<strong></strong>
lookup(Name, Class, Type, Opts, Timeout) -&gt; [dns_data()]

</pre>
<p>Types:</p><p>Name = <strong>dns_name()</strong> | <strong>inet:ip_address()</strong></p><p>Class = <strong>dns_class()</strong></p><p>Type = <strong>rr_type()</strong></p><p>Opts = [<strong>res_option()</strong> | verbose]</p><p>Timeout = timeout()</p><p>Resolve the DNS data for the record of the given type and class for the given name. On success filters out the answer records with the correct <em>Class</em> and <em>Type</em> and returns a list of their data fields. So a lookup for type <em>any</em> will give an empty answer since the answer records have specific types that are not <em>any</em>. An empty answer as well as a failed lookup returns an empty list.</p><p>Calls <strong>resolve/2..4</strong> with the same arguments and filters the result, so <em>Opts</em> is explained there.</p>
<pre>
<strong></strong>
resolve(Name, Class, Type) -&gt; {ok, dns_msg()} | Error

</pre>

<pre>
<strong></strong>
resolve(Name, Class, Type, Opts) -&gt; {ok, dns_msg()} | Error

</pre>

<pre>
<strong></strong>
resolve(Name, Class, Type, Opts, Timeout) -&gt;
<strong></strong>
           {ok, dns_msg()} | Error

</pre>
<p>Types:</p><p>Name = <strong>dns_name()</strong> | <strong>inet:ip_address()</strong></p><p>Class = <strong>dns_class()</strong></p><p>Type = <strong>rr_type()</strong></p><p>Opts = [Opt]</p><p>Opt = <strong>res_option()</strong> | verbose | atom()</p><p>Timeout = timeout()</p><p>Error = {error, Reason} | {error, {Reason, <strong>dns_msg()</strong>}}</p><p>Reason = <strong>inet:posix()</strong> | <strong>res_error()</strong></p><p>Resolve a DNS record of the given type and class for the given name. The returned <em>dns_msg()</em> can be examined using access functions in <em>inet_db</em> as described in <strong>DNS types</strong>.</p><p>If <em>Name</em> is an <em>ip_address()</em>, the domain name to query for is generated as the standard reverse ".IN-ADDR.ARPA." name for an IPv4 address, or the ".IP6.ARPA." name for an IPv6 address. In this case you most probably want to use <em>Class = in</em> and <em>Type = ptr</em> but it is not done automatically.</p><p><em>Opts</em> override the corresponding resolver options. If the option <em>nameservers</em> is given, it is also assumed that it is the complete list of nameserves, so the resolver option <em>alt_nameserves</em> is ignored. Of course, if that option is also given to this function, it is used.</p><p>The <em>verbose</em> option (or rather <em>{verbose,true}</em>), causes diagnostics printout through <strong>io:format/2</strong> of queries, replies retransmissions, etc, similar to from utilities like <em>dig</em>, <em>nslookup</em> et.al.</p><p>If <em>Opt</em> is an arbitrary atom it is interpreted as <em>{Opt,true}</em> unless the atom string starts with <em>"no"</em> making the interpretation <em>{Opt,false}</em>. For example: <em>usevc</em> is an alias for <em>{usevc,true}</em>, and <em>nousevc</em> an alias for <em>{usevc,false}</em>.</p><p>The <em>inet6</em> option currently has no effect on this function. You probably want to use <em>Type = a | aaaa</em> instead.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Access functions example: how <strong>lookup/3</strong> could have been implemented using <strong>resolve/3</strong> from outside the module.</p>
<pre>
    example_lookup(Name, Class, Type) -&gt;
        case inet_res:resolve(Name, Class, Type) of
            {ok,Msg} -&gt;
                [inet_dns:rr(RR, data)
                 || RR &lt;- inet_dns:msg(Msg, anlist),
                    inet_dns:rr(RR, type) =:= Type,
                    inet_dns:rr(RR, class) =:= Class];
            {error,_} -&gt;
                []
        end.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LEGACY FUNCTIONS</h2>
        <div class="sectioncontent">
<p>These have been deprecated due to the annoying double meaning of the nameservers/timeout argument, and because they had no decent place for a resolver options list.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
nslookup(Name, Class, Type) -&gt; {ok, dns_msg()} | {error, Reason}

</pre>

<pre>
<strong></strong>
nslookup(Name, Class, Type, Timeout) -&gt;
<strong></strong>
            {ok, dns_msg()} | {error, Reason}

</pre>

<pre>
<strong></strong>
nslookup(Name, Class, Type, Nameservers) -&gt;
<strong></strong>
            {ok, dns_msg()} | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>dns_name()</strong> | <strong>inet:ip_address()</strong></p><p>Class = <strong>dns_class()</strong></p><p>Type = <strong>rr_type()</strong></p><p>Timeout = timeout()</p><p>Nameservers = [<strong>nameserver()</strong>]</p><p>Reason = <strong>inet:posix()</strong> | <strong>res_error()</strong></p><p>Resolve a DNS record of the given type and class for the given name.</p>
<pre>
<strong></strong>
nnslookup(Name, Class, Type, Nameservers) -&gt;
<strong></strong>
             {ok, dns_msg()} | {error, Reason}

</pre>

<pre>
<strong></strong>
nnslookup(Name, Class, Type, Nameservers, Timeout) -&gt;
<strong></strong>
             {ok, dns_msg()} | {error, Reason}

</pre>
<p>Types:</p><p>Name = <strong>dns_name()</strong> | <strong>inet:ip_address()</strong></p><p>Class = <strong>dns_class()</strong></p><p>Type = <strong>rr_type()</strong></p><p>Timeout = timeout()</p><p>Nameservers = [<strong>nameserver()</strong>]</p><p>Reason = <strong>inet:posix()</strong></p><p>Resolve a DNS record of the given type and class for the given name.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="inet.3erl.html"><span aria-hidden="true">&larr;</span> inet.3erl: Access to tcp/ip protocols</a></li>
   <li class="next"><a href="inets.3erl.html">inets.3erl: The inets services api <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

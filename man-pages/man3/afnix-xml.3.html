<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>afnix-xml: Standard xml module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Standard xml module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="afnix-xml (3) manual">
  <meta name="twitter:description" content="Standard xml module">
  <meta name="twitter:image" content="https://www.carta.tech/images/afnix-afnix-xml-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/afnix-xml.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="afnix-xml (3) manual" />
  <meta property="og:description" content="Standard xml module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/afnix-afnix-xml-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">afnix-xml<small> (3)</small></h1>
        <p class="lead">Standard xml module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-xml.3.html">
      <span itemprop="name">afnix-xml: Standard xml module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/afnix/">
      <span itemprop="name">afnix</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-xml.3.html">
      <span itemprop="name">afnix-xml: Standard xml module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD XML MODULE</h2>
        <div class="sectioncontent">
<p>The Standard XML module is an original implementation of the XML markup language. The module provides the necessary objects for parsing a xml description as well as manipulating the parsed tree. The module can be extended to a service as a mean to act as a XML processor. The module also provides the support for a simple model which enable the quick parsing of documents with a relaxed rule checking approach.</p><p><strong>XML tree representation</strong></p><p>A xml document is represented with a tree. At the top of the tree is the XmlRoot object. The root object is not part of the document, but acts as the primary container for other objects. A xml document starts with a root node and all other child elements are XmlNode objects.</p><p><em>Node base object</em></p><p>The xml tree is built with the XmlNode object. The node object has different derivation depending on the required representation. For example, the XmlRoot object is derived from the XmlNode object. A node object can have child object unless the node is marked as an empty node. Trying to add node to an empty node results in an exception. A node can also be marked empty by the user. This situation typically arises with tag node which are used alone such like the &lt;br/&gt; xhtml empty tag or an empty paragraph &lt;p/&gt;. Although a xml node cannot be constructed directly, there is a predicate node-p that can be used to assert the node type.</p>
<pre>
# check a node
assert true (afnix:xml:node-p node)
</pre>
<p>The add-child method adds a child node to the calling node. If the calling node is marked empty, an exception is raised when attempting to add the node. There is no limit for the number of nodes to add. In particular, when a text is to be added, care should be taken that there is no markup within that text. In doubt, the parse method should be used.</p>
<pre>
# parse a text and add 3 child nodes
p:parse "The quick brown &lt;b&gt;fox&lt;/b&gt;
jumps over the lazy dog"
</pre>
<p>In the previous example, the first child node is a XmlText node with the value The quick brown . The second node is a XmlTag node with name b. Finally, the third node is also a XmlText node with the value  jumps over the lazy dog. It should be noted that the tag node has a child XmlText node with the value fox. This example also illustrates the power of the parse method which considerably simplify the creation of a xml tree. Finally, there is a subtle subject to be treated later which concerns the use of character reference with the parse method. Like any other xml parser, character references are evaluated during the parsing phase, thus providing no mechanism to create such reference. For this reason, a special class called XmlCref is provided in the module.</p><p><em>Tag object</em></p><p>The XmlTag class is one of the most important class as it holds most of the xml constructs. A tag is defined by a name, a set of attributes and eventually a content. In its simplest form, a tag is created by name. With an additional boolean parameter, the tag can be marked as an empty node.</p>
<pre>
# create an empty paragraph tag
const p (afnix:xml:XmlTag "p" true)
</pre>
<p>Adding attributes to a tag is imply a matter of method call. The add-attribute method operates with a Property object while the set-attribute operates with a name and a literal value. As a matter of fact, the attributes are stored internally as a property list.</p>
<pre>
# &lt;p class="text"&gt;
# create a paragraph tag
const p (afnix:xml:XmlTag "p")
# set the class attribute
p:set-attribute "class" "text"
</pre>
<p>The node empty flag determines whether or not there is a end tag associated with a tag. If the empty flag is false, the node can have children nodes and is associated with a end tag. With the empty flag set, there is no child nodes. Such situation corresponds to the xml /&gt; notation.</p>
<pre>
# &lt;br/&gt;
# create a br empty tag
const br (afnix:xml:XmlTag "br" true)
</pre>
<p><em>Text objects</em></p><p>The xml module provides two types of xml text node. The basic object is the XmlText node which is designed to hold some text without markup. It is this kind of nodes which is automatically instantiated by the parse method, as described earlier. The other object is the XmlData which corresponds to the xml CDATA special markup. With a character data node, the characters are not interpreted, including those that indicate markup starts like &lt; or end like &gt;. The XmlData is particularly used to store scripts or other program text inside a xml description. As an example, it is recommended to use a character data node inside a script tag with xhtml.</p><p><strong>Document reading</strong></p><p>A xml document is read by scanning an input stream an building a representation of the xml tree.</p><p><em>The document object</em></p><p>The XmlDocument object is a special object is designed to ease the reading process of an xml document. The process of creating a xml document consists of creating a document object, then binding a xml reader, parsing the input stream and finally storing the root node. When the operation is completed, the root node is available in the document object.</p>
<pre>
# create a xml document
const xdoc (afnix:xml:XmlDocument "example.xml")
# get the root node
const rppt (xdoc:get-root)
</pre>
<p><em>The root node content</em></p><p>When a document is parsed, the root node holds all the elements and markup sequentially. At this stage, it shall be noted that the element data are not expanded. Unlike a normal XML reader, the parameter entity are kept in the node data, are expended later by the XML processor.</p><p><strong>Node tree operations</strong></p><p>The class XneTree provides a single framework to operate on a node and its associated tree. Since a node always carries a sub-tree, the node tree term will be used to reference it.</p><p><em>Creating a node tree</em></p><p>A node tree is created either from a node at construction or with the help of the set-node method.</p>
<pre>
# create a node tree at construction
const tree (afnix:xml:XneTree root)
# change the node tree
tree:set-node node
</pre>
<p>Once a tree is created, various methods are provided to operate on the whole tree. The depth method returns the depth of the node tree. The get-node methods returns the the node associated with the tree.</p>
<pre>
# get the tree depth
println (tree:depth)
</pre>
<p><em>Namespace operations</em></p><p>The concept of namespace is an extension to the xml standard. Unlike other programming language, the concept of namespace is designed to establish a binding between a name and an uri. Such binding permits to establish a scope for tags without too much burden. In the xml namespace terminology, an expanded name is composed of a prefix and a local name. The basic operations provided at the tree level is the prefix cancellation and the tree prefix setting.</p>
<pre>
# clear the prefix for the whole tree
tree:clear-prefix
# set a prefix for the whole tree
tree:set-prefix "afnix"
</pre>
<p>The set-prefix changes the prefix for the whole tree. It is not necessary to clear first the prefix.</p><p><em>Attribute operations</em></p><p>Each node in the node tree can have its attribute list modified in a single operation. The first operation is to clear all attributes for all nodes. Although this operation might be useful, it should be carried with caution. The attributes can also cleared more selectively by using the tag name as a filter. For more complex operation, the clear-attribute method of the XmlTag is the definitive answer.</p>
<pre>
# clear all attributes
tree:clear-attribute
# clear all attributes by tag name
tree:clear-attribute "p"
</pre>
<p>The set-attribute method sets an attribute to the whole tree. The first argument is the attribute name and the second is a literal value. For more selective operations, the set-attribute method can be also called at the tag level.</p>
<pre>
# clear all attributes
tree:set-attribute "class" "text"
</pre>
<p>When it comes to set attributes, there is a special operation related to the "id" attribute. Such attribute is supposed to be unique for the whole tree. For this reason, the generate-id generates a unique id for each node and assign the id attribute. The attribute is unique at the time of the call. If the tree is modified, and in particular, if new node are added, the method must be called again to regenerate the node id.</p>
<pre>
# set a unique id for all nodes
tree:generate-id
</pre>
<p><strong>Node location and searching</strong></p><p>The node location is the ability to locate one or several nodes in a xml tree. A node is generally located by name, path or id. Once a node has been located, it can be processed. Note that the node locator operates operates almost exclusively with XmlTag node, although it might not be always the case.</p><p><em>Node selection</em></p><p>The process of finding a child node is obtained with the help of the XneCond class combined with the select method of the XneTree Object. The select method traverses the whole tree and attempts to match a condition for each node. If the condition is evaluated successfully for a node, the node is added in the result vector. Note that the tree can be traversed entirely or with only the first layer of children.</p>
<pre>
# creating a condition node
const xcnd (afnix:xml:XneCond)
# create a tree with a root node
const tree (afnix:xml:XneTree root)
# select all nodes for that condition
trans result (tree:select xcnd)
</pre>
<p>In the previous example, the condition object is empty. This means that there is no condition, and thus works for all nodes. This previous example will return all nodes in the tree.</p><p><em>Node condition</em></p><p>The XmlCond class provides several method to add a conditions. The add method is the method of choice to add a condition. The method operates with a condition type and a literal. Note that the object can contain several conditions.</p>
<pre>
# creating a condition node
const xcnd (afnix:xml:XneCond)
# add a condition by name
xcnd:add afnix:xml:xne:NAME "p"
</pre>
<p>In the previous example, a condition is designed to operate with a tag name. Upon a call to the select method with this condition, all nodes in the tree that have the tag name p will be selected.</p>
<pre>
# creating a condition node
const xcnd (afnix:xml:XneCond)
# add a condition by name
xcnd:add afnix:xml:xne:NAME "p"
# add an index condition
xcnd:add afnix:xml:xne:INDEX 0
</pre>
<p>In the previous example, a condition is designed to operate with a tag name and index. Upon a call to the select method with this condition, all nodes in the tree that have the tag name p and those child index is 0 will be selected.</p><p><em>Selection result</em></p><p>The node selection operates by default on the whole tree. The select method, when called with a second boolean argument can restrict the search to the child nodes.</p>
<pre>
# creating a condition node
const xcnd (afnix:xml:XneCond)
# create a tree with a root node
const tree (afnix:xml:XneTree root)
# select all nodes for that condition
trans result (tree:select xcnd false)
</pre>
<p>The selection results is stored in a vector object. The node order corresponds to the tree order obtained with a depth first search approach.</p><p><strong>Simple model node</strong></p><p>The XML simple model is designed to simplify the interpretation of a general sgml document such like, html or xhtml document. In the simple model approach, there is no tree. Instead, a vector of simple nodes is built, and a document interface can be used to access the nodes. Therefore, this simple model should be considered as a mean to quickly parse document, but should not be used when tree operations come into play. In such case, the xml model is by far more appropriate. The simple model can be used to parse a html document for instance. Note also that the simple model is a relaxed model in terms of parsing rules. For example, the tag start/end consistency is not checked and the attribute parsing is not aggressive as it can be found generally in poorly written html document. In the simple model, a XsmNode is just a text place holder. The node transports its type which can be either text, tag, reference of end node. For the tag node, a subtype that identifies reserved nodes versus normal type is also available.</p><p><em>Creating a node</em></p><p>A xsm node is created by name or byte and name. In the first case, the node is a text node. In the second case, the node subtype is automatically detected for tag node.</p>
<pre>
# create a xsm text node
const ntxt (afnix:xml:XsmNode "afnix"&gt;
  # create a xsm tag node
  const ntag (
    afnix:xml:XsmNode afnix:xml:XsmNode:TAG "afnix"&gt;
</pre>
<p>Note that the text corresponds to the node content. For example, the string "!-- example --" might corresponds to a comment in html which is to say a reserved tag when the type is tag or a simple text if the type is a text node. A reserved tag is defined by a string which start either with the '!' character or the '[' character.</p>
<pre>
# create a reserved tag
const rtag (
  afnix:xml:XsmNode afnix:xml:XsmNode:TAG
  "!-- example --")
</pre>
<p><em>Node representation</em></p><p>The xsm node is a literal node. This means that the to-string and to-literal methods are available. When the to-literal method is called, the node text is automatically formatted to reflect the node type.</p>
<pre>
# create a reserved tag
const rtag (
  afnix:xml:XsmNode afnix:xml:XsmNode:TAG
  "!-- example --")
# print the node literal
rtag:to-literal # &lt;!-- example --&gt;
</pre>
<p>If the node is a reference node, the node literal is represented with the original definition while the to-string method will produce the corresponding character if it known.</p><p><em>Node information</em></p><p>With a xsm node, the operation are a limited number of node information operations. The get-name method returns the first name found in a node. If the node is a normal tag, the get-name will return the tag name. For the other node, the method will return the first available string. This also means, that the method will behave correctly with end tag node.</p>
<pre>
# create a tag node
const ntag (
  afnix:xml:XsmNode afnix:xml:XsmNode:TAG "afnix"&gt;
  # get the tag name
  ntag:get-name
</pre>
<p>There is a predicate for all types. For example, the text-p predicate returns true if the node is a text node. The tag-p predicate returns true if the node is a normal or reserved tag.</p><p><strong>Document reading</strong></p><p>A document is read in a way similar to the XmlDocument with the help of the XsmDocument object. Once created, the document holds a vector of nodes.</p><p><em>The document object</em></p><p>The XsmDocument object is a special xsm object designed to ease the reading process of a document. The process of creating a document consists of creating a document object, then binding a xsm reader, parsing the input stream and storing the nodes in a vector. When the operation is completed, the vector can be accessed by index.</p>
<pre>
# create a xms document
const xdoc (afnix:xml:XsmDocument "example.htm")
# get the document length
xdoc:length
</pre>
<p><em>Node information object</em></p><p>The XsoInfo object is a node information object designed to hold a node name, an attributes list and eventually a text associated with the node. For example, if a html document contains a anchor node, the associated information node, will have the anchoring text stored as the node information text.</p>
<pre>
# create a xso node by name and text
const info (afnix:xml:XsoInfo "a" "click here")
</pre>
<p><em>Simple model operations</em></p><p>The XsmDocument is designed to perform simple operations such like searching all nodes that matches a particular name. While this operation can be done easily, it is done in such a way that a vector of node information is returned instead of a vector of nodes which can always be constructed with a simple loop.</p>
<pre>
# create a xsm document
const xdoc (afnix:xml:XsmDocument "example.htm")
# get all node named "a" - forcing lower case
xdoc:get-info-vector "a" true
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD XML REFERENCE</h2>
        <div class="sectioncontent">
<p><strong>XmlNode</strong></p><p>The XmlNode class is the base class used to represent the xml tree. The tree is built as a vector of nodes. Each node owns as well its parent node. Walking in the tree is achieved by taking the child node and then moving to the child and/or next node. The node also manages an empty flags. It the empty flag is set, it is an error to add child nodes.</p><p><em>Predicate</em></p><p>node-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Methods</em></p><p><strong>to-text -&gt; String (none)</strong></p><p>The to-text method returns a text representation of the tree content. Unlike the write method, the tag are not generated, but rather the text content is accumulated. This method is useful tor read the node content. If a node does not have text, the nil string is returned.</p><p><strong>write -&gt; none (none|OutputStream|Buffer)</strong></p><p>The write method write the node contents as well as the child nodes to an output stream argument or a buffer. When node is written, the method attempts to use the stream encoding in such way that the contents fits into the requested output encoding. Without argument, the node is written to the interpreter output stream. with one argument, the node is written to the specified stream or buffer.</p><p><strong>name-p -&gt; Boolean (String)</strong></p><p>The name-p predicate checks if the name matches the node name. Care should be taken that not all node have a name, and in such case, the false value is returned. This method is useful when the node is a tag.</p><p><strong>attribute-p -&gt; Boolean (String| String String)</strong></p><p>The attribute-p predicate checks if there is a node attribute that matches the string argument name. In the first form, the predicate returns true is an attribute exists with the name argument. In the second form, the predicate returns true if the attribute name and value matches the arguments. The first argument is the attribute name. The second argument is the attribute value. Not all nodes have attributes. In such case, the predicate always returns false.</p><p><strong>parse -&gt; none (String)</strong></p><p>The parse method parses the string argument and adds the results as a set of child node to the calling node. If the node is an empty node, the method will almost fail. This method should be used when an attempt is made to add some text that may contain some xml tags.</p><p><strong>get-parent -&gt; XmlNode (none)</strong></p><p>The get-parent method returns the parent node. If the node is the root node, nil is returned.</p><p><strong>set-parent -&gt; none (XmlNode)</strong></p><p>The set-parent method sets the parent node.</p><p><strong>copy -&gt; XmlNode (none)</strong></p><p>The copy method copy the node tree by regenerating a new tree.</p><p><strong>del-child -&gt; none (Integer | String | String String | String String String)</strong></p><p>The del-child method deletes one or several child nodes. In the first form, the children is deleted either by index or by name. When a string argument is used, several node might be removed. In the second form, the child node name and attribute name must be matched. In the third form, the child node name, attribute name and value must be matched.</p><p><strong>del-attribute-child -&gt; none (String | String String)</strong></p><p>The del-attribute-child method deletes one or several child nodes. In the first form, the children are deleted by attribute name. In the second form, the children are delete by attribute name and value.</p><p><strong>clear-child -&gt; none (none)</strong></p><p>The clear-child method clear the child node list, leaving the node without child node.</p><p><strong>add-child -&gt; none (XmlNode|XmlNode Integer)</strong></p><p>The add-child method adds a node argument as a child node to the calling node. In the first form, the node is added at the end of the node list. In the second form, the node is added by index and all subsequent nodes are shifted by one position.</p><p><strong>get-child -&gt; XmlNode (Integer String)</strong></p><p>The get-child method returns a child node by index or by name. If the calling argument is an integer, the node is returned by index. If the calling argument is a string, the node is returned by name. If the node cannot be found, nil is returned raised.</p><p><strong>get-index -&gt; Integer (XmlNode)</strong></p><p>The gett-index method returns a child node index. The node argument is the node to find as a child node. If the node is not found, an exception is raised.</p><p><strong>merge -&gt; none (XmlNode Integer)</strong></p><p>The merge method merge an existing node with another one. The first argument is the source node used for merging. The second argument the child node index to merge. The method operates by first removing the child node at the specified index and then add in position, the child nodes of the source node.</p><p><strong>nil-child-p -&gt; Boolean (none)</strong></p><p>The nil-child-p predicate returns true if the node does not have a child node.</p><p><strong>child-p -&gt; Boolean (String | String String | String String String)</strong></p><p>The child-p predicate returns true if the node has a child with a node name argument. In the first form, the name is to be matched by the predicate. In the second form, the node nae and the attribute name must be matched. In the third form, the node name, attribute name and value must be matched.</p><p><strong>attribute-child-p -&gt; Boolean (String String | String String String)</strong></p><p>The attribute-child-p predicate returns true if the node has a child with an attribute name argument. In the first form, the attribute name must be matched. In the second form, the attribute name and value must be matched.</p><p><strong>lookup-child -&gt; XmlNode (String)</strong></p><p>The lookup-child method returns a child node by name. Unlike the get-child method, the method raises an exception if the node cannot be found.</p><p><strong>child-length -&gt; Integer (none)</strong></p><p>The child-length method returns the number of children nodes.</p><p><strong>get-source-line -&gt; Integer (none)</strong></p><p>The get-source-line method returns the node source line number if any.</p><p><strong>set-source-line -&gt; none (Integer)</strong></p><p>The set-source-line method sets the node source line number.</p><p><strong>get-source-name -&gt; String (none)</strong></p><p>The get-source-name method returns the node source name if any.</p><p><strong>set-source-name -&gt; none (String)</strong></p><p>The set-source-name method sets the node source name.</p><p><strong>XmlTag</strong></p><p>The XmlTag class is the base class used to represent a xml tag. A tag is defined with a name and an attribute list. The tag is derived from the xml node class and is not marked empty by default.</p><p><em>Predicate</em></p><p>tag-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlTag (String)</strong></p><p>The XmlTag constructor creates a tag node. The node is not marked empty.</p><p><strong>XmlTag (String Boolean)</strong></p><p>The XmlTag constructor creates a tag node. The first argument is the tag name. The second argument is the empty flag.</p><p><em>Methods</em></p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the tag name.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the tag name.</p><p><strong>clear-attribute -&gt; none (node)</strong></p><p>The clear-attribute method clear the node attribute list.</p><p><strong>add-attribute -&gt; none (Property)</strong></p><p>The add-attribute method adds a new attribute to the tag. The attribute must be new for this method to succeed. In doubt, the set-attribute is preferable.</p><p><strong>set-attribute -&gt; none (String Literal)</strong></p><p>The set-attribute method sets an attribute to the tag. The first argument is the attribute name. The second argument is the attribute value. If the attribute already exists, the old value is replaced with the new one.</p><p><strong>get-attribute -&gt; Property (Integer|String)</strong></p><p>The get-attribute method returns a tag attribute in the form o a property object. With an integer object, the attribute is returned by index. With a string object, the property is return by name. If the property is not found, nil is returned.</p><p><strong>get-attribute-value -&gt; String (String)</strong></p><p>The get-attribute-value method returns a tag attribute value by name. The string argument is the attribute name. If the property is not found, an exception is raised.</p><p><strong>lookup-attribute -&gt; Property (String)</strong></p><p>The lookup-attribute method returns a tag attribute by name in the form of a property. The string argument is the attribute name. If the property is not found, an exception is raised.</p><p><strong>attribute-length -&gt; Integer (none)</strong></p><p>The attribute-length method returns the number of attributes.</p><p><strong>XmlText</strong></p><p>The XmlText class is the xml text node. A text node is directly built by the xml reader and the content placed into a string. By definition, a text node is an empty node.</p><p><em>Predicate</em></p><p>text-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlText (none)</strong></p><p>The XmlText constructor creates a default text node. By definition, a text node is an empty node.</p><p><strong>XmlText (String)</strong></p><p>The XmlText constructor creates a text node with the string argument.</p><p><em>Methods</em></p><p><strong>set-xval -&gt; none (String)</strong></p><p>The set-xval method sets the text node value.</p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the text node value.</p><p><strong>to-normal -&gt; String (none)</strong></p><p>The to-normal method returns the normalized text node value.</p><p><strong>XmlData</strong></p><p>The XmlData class is the xml CDATA node. A data node differs from the text node in the sense that the data node contains characters that could be reserved characters such like markup delimiters. The data node is most of the time used to hold text used for scripting. The data node is an empty node.</p><p><em>Predicate</em></p><p>data-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlData (none)</strong></p><p>The XmlData constructor creates a default data node. By definition, a data node is an empty node.</p><p><strong>XmlData (String)</strong></p><p>The XmlData constructor creates a data node with the string argument.</p><p><em>Methods</em></p><p><strong>set-xval -&gt; none (String)</strong></p><p>The set-xval method sets the data node value.</p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the data node value.</p><p><strong>XmlComment</strong></p><p>The XmlComment class is the xml comment node. The comment node is a special node that holds the comment text. The comment node is an empty node.</p><p><em>Predicate</em></p><p>comment-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlComment (none)</strong></p><p>The XmlComment constructor creates a default comment node. By definition, a comment node is an empty node.</p><p><strong>XmlComment (String)</strong></p><p>The XmlComment constructor creates a comment node with the string argument.</p><p><em>Methods</em></p><p><strong>set-xval -&gt; none (String)</strong></p><p>The set-xval method sets the comment node value.</p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the comment node value.</p><p><strong>XmlDoctype</strong></p><p>The XmlDoctype class is the xml document type node. In its simplest form, the document type has just a name which acts the starting tag for the document. The document type can also be associated with a system or a public identifier. Note also that a local root node can be attached to this node.</p><p><em>Predicate</em></p><p>doctype-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlDoctype (String)</strong></p><p>The XmlDoctype constructor creates a document type with a starting tag name as the string argument. This is the simplest form of a document type definition.</p><p><strong>XmlDoctype (String String)</strong></p><p>The XmlDoctype constructor creates a document type with a starting tag name and a system identifier. The first string argument is the tag name. The second argument is the system identifier.</p><p><strong>XmlDoctype (String String String)</strong></p><p>The XmlDoctype constructor creates a document type with a starting tag name, a public and a system identifier. The first string argument is the tag name. The second argument is the public identifier. The third argument is the system identifier.</p><p><em>Methods</em></p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the document type starting tag name.</p><p><strong>get-public-id -&gt; String (none)</strong></p><p>The get-public-id method returns the document type public identifier.</p><p><strong>get-system-id -&gt; String (none)</strong></p><p>The get-system-id method returns the document type system identifier.</p><p><strong>XmlPi</strong></p><p>The XmlPi class is the xml processing node. The processing node is a tag node. Although a processing node is seen as tag with attributes, the specification describes the processing node as a special tag with a string value. The processing node is an empty node.</p><p><em>Predicate</em></p><p>pi-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlPi (String)</strong></p><p>The XmlPi constructor creates a processing node with the name string argument.</p><p><strong>XmlPi (String String)</strong></p><p>The XmlPi constructor creates a processing node with the name string argument and the string value. The first argument is the tag name. The second argument is the processing node value.</p><p><em>Methods</em></p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the xml pi node name.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the pi node name.</p><p><strong>set-xval -&gt; none (String)</strong></p><p>The set-xval method sets the processing node value.</p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the processing node value.</p><p><strong>map-xval -&gt; Plist (String)</strong></p><p>The map-xval method map the processing node value to a property list.</p><p><strong>XmlDecl</strong></p><p>The XmlDecl class is the xml declaration node. The declaration node is a processing node. A declaration node is defined with a version id, an encoding string and a standalone flag. Each value is represented by an attribute at the tag level.</p><p><em>Predicate</em></p><p>decl-p</p><p><em>Inheritance</em></p><p>XmlPi</p><p><em>Constructors</em></p><p><strong>XmlDecl (none)</strong></p><p>The XmlDecl constructor creates a default declaration node. By default, the declaration node is set with the xml version 1.0, the UTF-8 encoding and the standalone flag is not set.</p><p><strong>XmlDecl (String)</strong></p><p>The XmlDecl constructor creates a declaration node with a version. The string argument is the xml version version which must be a supported one.</p><p><strong>XmlDecl (String String)</strong></p><p>The XmlDecl constructor creates a declaration node with a version and an encoding. The string argument is the xml version version which must be a supported one. The second argument is the xml encoding.</p><p><strong>XmlDecl (String String String)</strong></p><p>The XmlDecl constructor creates a declaration node with a version, an encoding and a standalone flag. The string argument is the xml version version which must be a supported one. The second argument is the xml encoding. The third argument is the standalone flag.</p><p><strong>XmlRef</strong></p><p>The XmlRef class is the xml reference node class. This class is a base class which cannot be instantiated directly. The class is designed to hold reference, the only element which is in common is the string representation.</p><p><em>Predicate</em></p><p>ref-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Methods</em></p><p><strong>set-xref -&gt; none (String)</strong></p><p>The set-xref method sets the node reference name.</p><p><strong>get-xref -&gt; String (none)</strong></p><p>The get-xref method returns the node reference name.</p><p><strong>XmlCref</strong></p><p>The XmlCref class is the xml character reference node class. Normally this class should only be used when building a xml tree manually. During a parsing process, the character reference is automatically expanded.</p><p><em>Predicate</em></p><p>cref-p</p><p><em>Inheritance</em></p><p>XmlRef</p><p><em>Constructors</em></p><p><strong>XmlCref (none)</strong></p><p>The XmlCref constructor creates a default character reference those value is the null character.</p><p><strong>XmlCref (Character|Integer)</strong></p><p>The XmlCref constructor creates a character reference those value is the character or integer argument.</p><p><em>Methods</em></p><p><strong>set-value -&gt; none (Character|Integer)</strong></p><p>The set-value method sets the character reference value by character or integer.</p><p><strong>get-value -&gt; Character (none)</strong></p><p>The get-value method returns the character reference value.</p><p><strong>XmlEref</strong></p><p>The XmlEref class is the xml entity reference node class. The entity reference is defined with a reference name.</p><p><em>Predicate</em></p><p>eref-p</p><p><em>Inheritance</em></p><p>XmlRef</p><p><em>Constructors</em></p><p><strong>XmlEref (none)</strong></p><p>The XmlCref constructor creates an empty entity reference.</p><p><strong>XmlCref (String)</strong></p><p>The XmlEref constructor creates an entity reference those value is the string argument.</p><p><strong>XmlSection</strong></p><p>The XmlSection class is the xml section type node. A section node is used to model conditional section that are part of a DTD. The section value is a string that is evaluated by the xml processor. Most of the time, it is a parameter entity reference which corresponds to the keyword INCLUDE or IGNORE , but it could be anything else. A node is also attached to this section.</p><p><em>Predicate</em></p><p>section-p</p><p><em>Inheritance</em></p><p>xmlNode</p><p><em>Constructors</em></p><p><strong>XmlSection (String)</strong></p><p>The XmlSection constructor creates a xml section node by value.</p><p><em>Methods</em></p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the section node value.</p><p><strong>XmlAttlist</strong></p><p>The XmlAttlist class is the xml attribute list node class. A xml attribute list is primarily defined with two names. The first name is the element and the second name is the attribute name. There are 3 types of attribute list. The string type, the token type and the enumeration type. The class manages each type by associating a type descriptor which is detected at construction.</p><p><em>Predicate</em></p><p>attlist-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlAttlist (String String)</strong></p><p>The XmlAttlist constructor creates an attribute list by element name and attribute name. The first argument is the element name. The second argument is the attribute name.</p><p><em>Methods</em></p><p><strong>set-element-name -&gt; none (String)</strong></p><p>The set-element-name method sets the attribute list element name.</p><p><strong>get-element-name -&gt; String (none)</strong></p><p>The get-element-name method returns the attribute list element name.</p><p><strong>set-attribute-name -&gt; none (String)</strong></p><p>The set-attribute-name method sets the attribute list name.</p><p><strong>get-attribute-name -&gt; String (none)</strong></p><p>The get-attribute-name method returns the attribute list name.</p><p><strong>set-type -&gt; none (String | Vector Boolean)</strong></p><p>The set-type method set the attribute type by string or enumeration vector. In its first form, the attribute type is defined by a string. The type can be either, "CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN" or "NMTOKENS". In the second form, the attribute type is an enumeration those values are defined in the argument vector. The boolean argument controls the notation flag for that enumeration.</p><p><strong>set-default -&gt; none (String)</strong></p><p>The set-default method set the attribute value by string. The string can be any value or the special value "#IMPLIED" and "#REQUIRED". If the default value is fixed, the set-fixed is the preferred method.</p><p><strong>set-fixed -&gt; none (String)</strong></p><p>The set-fixed method set the fixed attribute default value by string.</p><p><strong>XmlRoot</strong></p><p>The XmlRoot class is the top level root instantiated by the xml reader when starting to parse a stream. There should be only one root node in a tree. The root node does not have a parent node.</p><p><em>Predicate</em></p><p>root-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlRoot (none)</strong></p><p>The XmlRoot constructor creates a default xml root node which is empty.</p><p><em>Methods</em></p><p><strong>dup-body -&gt; XmlBody (none)</strong></p><p>The dup-body method duplicates the root node by duplicating the root body without the declaration node.</p><p><strong>declaration-p -&gt; Boolean (none)</strong></p><p>The declaration-p predicate returns true if a declaration node exists in the root node.</p><p><strong>get-declaration -&gt; XmlDecl (none)</strong></p><p>The get-declaration method returns the declaration node associated with the root node. Normally, the declaration node is the first child node. If the declaration node does not exist, an exception is raised.</p><p><strong>get-encoding -&gt; String (none)</strong></p><p>The get-encoding method returns the root encoding mode. The root encoding mode is extracted from the declaration node, if such node exists, or the default xml system encoding is returned.</p><p><strong>XmlDocument</strong></p><p>The XmlDocument class is the xml document class. The document class is the root document class that maintains a xml document along with its associated tree and other useful information. Generally the class is constructed with a file name or a name and an input stream that is used for parsing the input data. The document can also be designed by constructing manually the document tree. In that case, the document name must be set explicitly.</p><p><em>Predicate</em></p><p>document-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Constructors</em></p><p><strong>XmlDocument (none)</strong></p><p>The XmlDocument constructor creates a default xml document.</p><p><strong>XmlDocument (String)</strong></p><p>The XmlDocument constructor creates a xml document by parsing the file. The file name is the string argument.</p><p><strong>XmlDocument (String InputStream)</strong></p><p>The XmlDocument constructor creates a xml document by name and by parsing the input stream. The first argument is the xml document name. The second argument is the input stream to parse.</p><p><strong>XmlDocument (String XmlRoot)</strong></p><p>The XmlDocument constructor creates a xml document by name and root node. The first argument is the xml document name. The second argument is the xml root node.</p><p><em>Methods</em></p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the xml document name. The get-name method is available from the nameable base class.</p><p><strong>get-root -&gt; XmlRoot (none)</strong></p><p>The get-root method returns the document xml root node.</p><p><strong>get-body -&gt; XmlRoot (none)</strong></p><p>The get-body method returns the document xml root node body without the declaration node.</p><p><strong>XmlElement</strong></p><p>The XmlElement class is the xml element class node. A xml element is represented with a name and a value. It is during the processing phase that the element value is interpreted. An element is built with a name and a value.</p><p><em>Predicate</em></p><p>element-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Constructors</em></p><p><strong>XmlElement (String String)</strong></p><p>The XmlElement constructor creates a xml element by name and value. The first argument is the element name. The second argument is the argument value.</p><p><em>Methods</em></p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the xml element name.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the element name.</p><p><strong>set-xval -&gt; none (String)</strong></p><p>The set-xval method sets the xml element value.</p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the element value.</p><p><strong>XmlEntity</strong></p><p>The XmlEntity class is the base class for the xml entity representation. A xml entity can be either a general entity or a parameter entity. They differ initially with the presence of the '%' character. Both entity model have a name which is path of the base class.</p><p><em>Predicate</em></p><p>entity-p</p><p><em>Inheritance</em></p><p>XmlNode</p><p><em>Methods</em></p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the entity name.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the entity name.</p><p><strong>XmlGe</strong></p><p>The XmlGe class is the xml general entity node. In its simplest form, the general entity has a name and a value. The entity type can also be associated with a system or a public identifier with or without an extra type name.</p><p><em>Predicate</em></p><p>ge-p</p><p><em>Inheritance</em></p><p>XmlEntity</p><p><em>Constructors</em></p><p><strong>XmlGe (String String)</strong></p><p>The XmlGe constructor creates a xml entity by name and value. The first argument is the entity name. The second argument is the entity value. Most of the time, the entity value is a parameter entity.</p><p><strong>XmlGe (String String String)</strong></p><p>The XmlGe constructor creates a xml entity by name and identifier. The first argument is the entity name. The second argument is the entity public identifier. The third argument is the entity system identifier.</p><p><strong>XmlGe (String String String String)</strong></p><p>The XmlGe constructor creates a xml entity by name, identifier and data type. The first argument is the entity name. The second argument is the entity public identifier. the third argument is the entity system identifier. The fourth argument is the entity type name.</p><p><em>Methods</em></p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the entity value.</p><p><strong>get-data -&gt; String (none)</strong></p><p>The get-data method returns the entity data type.</p><p><strong>get-public-id -&gt; String (none)</strong></p><p>The get-public-id method returns the entity public identifier.</p><p><strong>get-system-id -&gt; String (none)</strong></p><p>The get-system-id method returns the entity system identifier.</p><p><strong>XmlPe</strong></p><p>The XmlPe class is the xml parameter entity node. In its simplest form, the parameter entity has a name and a value. The entity type can also be associated with a system or a public identifier.</p><p><em>Predicate</em></p><p>ge-p</p><p><em>Inheritance</em></p><p>XmlEntity</p><p><em>Constructors</em></p><p><strong>XmlPe (String String)</strong></p><p>The XmlGe constructor creates a xml entity by name and value. The first argument is the entity name. The second argument is the entity value.</p><p><strong>XmlPe (String String String)</strong></p><p>The XmlGe constructor creates a xml entity by name and identifier. The first argument is the entity name. The second argument is the entity public identifier. The third argument is the entity system identifier.</p><p><em>Methods</em></p><p><strong>get-xval -&gt; String (none)</strong></p><p>The get-xval method returns the entity value.</p><p><strong>get-public-id -&gt; String (none)</strong></p><p>The get-public-id method returns the entity public identifier.</p><p><strong>get-system-id -&gt; String (none)</strong></p><p>The get-system-id method returns the entity system identifier.</p><p><strong>XmlReader</strong></p><p>The XmlReader class is the xml parser that operates on an input stream. The reader creates a tree of nodes by reading the input stream and returns the root node when an end-of-stream is reached. Multiple read can be done sequentially. If the reset method is not called between multiple read passes, the reader will accumulate the nodes in the current tree.</p><p><em>Predicate</em></p><p>reader-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>XmlReader (none)</strong></p><p>The XmlReader constructor creates a default xml reader.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method resets the xml reader. In particular, the root node is restored to the nil node.</p><p><strong>parse -&gt; none (InputStream|String)</strong></p><p>The parse method parses an input stream or a file. During the parsing process, the root node is filled with the parsed nodes.</p><p><strong>get-root -&gt; XmlRoot (none)</strong></p><p>The get-root method returns the parsed root node.</p><p><strong>get-node -&gt; XmlNode (String)</strong></p><p>The get-node method parse a string and returns a node.</p><p><strong>Xne</strong></p><p>The Xne is a nameset that binds constants used by the xne system.</p><p><em>Constants</em></p><p><strong>ID</strong></p><p>The ID constant defines a node access by id.</p><p><strong>PI</strong></p><p>The PI constant defines an access selector for a processing instruction node.</p><p><strong>GE</strong></p><p>The GE constant defines an access selector for a general entity node.</p><p><strong>TAG</strong></p><p>The TAG constant defines an access selector for a tag node.</p><p><strong>ENT</strong></p><p>The ENT constant defines an access selector for an entity node.</p><p><strong>EREF</strong></p><p>The EREF constant defines an access selector for an entity reference node.</p><p><strong>CREF</strong></p><p>The CREF constant defines an access selector for an character reference node.</p><p><strong>ELEM</strong></p><p>The ELEM constant defines an access selector for an element node.</p><p><strong>TEXT</strong></p><p>The TEXT constant defines an access selector for a text node.</p><p><strong>NAME</strong></p><p>The NAME constant defines a node access by name.</p><p><strong>CDATA</strong></p><p>The CDATA constant defines an access selector for a character data node.</p><p><strong>INDEX</strong></p><p>The INDEX constant defines a node access by child index. The child index is node index seen from the parent.</p><p><strong>XneTree</strong></p><p>The XneTree is the xne node tree manipulation class. The class operates with a node and provides numerous methods to manipulate the tree as well as changing it. Before a tree is manipulated, it is recommended to make a copy of such tree with the help of the node copy method.</p><p><em>Predicate</em></p><p>xne-tree-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>XmlTree (none)</strong></p><p>The XmlTree constructor creates a default tree without a node.</p><p><strong>XmlTree (XmlNode)</strong></p><p>The XmlTree constructor creates a tree with a xml node. The node stored in the object is the root of the tree subject to the operations.</p><p><em>Methods</em></p><p><strong>depth -&gt; Integer (none)</strong></p><p>The depth method returns the depth of the tree.</p><p><strong>generate-id -&gt; Integer (none)</strong></p><p>The generate-id method generate a unique id for all node in the tree. The id attribute is set by this method.</p><p><strong>set-node -&gt; none (XmlNode)</strong></p><p>The set-node method sets the root tree node.</p><p><strong>get-node -&gt; XmlNode (none)</strong></p><p>The get-node method returns the root tree node.</p><p><strong>set-attribute -&gt; none (none|String)</strong></p><p>The set-attribute method sets an attribute to the whole tree. In the first form, the attribute is set to the whole tree. In the second form with a string argument, the attribute is set only on the tag node those name matches the name argument.</p><p><strong>clear-attribute -&gt; none (none|String)</strong></p><p>The clear-attribute method clear all attributes of the nodes in the tree. In the first form, the node attributes are cleared for all nodes in the tree. In the second form with a string argument, the attributes are cleared only with the tag node those name matches the name argument.</p><p><strong>set-prefix -&gt; none (String)</strong></p><p>The set-prefix method sets a prefix on all nodes in the tree.</p><p><strong>clear-prefix -&gt; none (none)</strong></p><p>The clear-prefix method clear the prefix for all nodes in the tree.</p><p><strong>select -&gt; Vector (XneCond [Boolean])</strong></p><p>The select method selects the node in the tree that matches the condition argument. In the first form, with one argument, the whole tree is searched. In the second form, with a boolean argument, the whole tree is searched if the second argument is false. If the boolean argument is true, the method call behaves like a call with the condition only.</p><p><strong>XneChild</strong></p><p>The XneCond is the xne condition class. The sole purpose of this class is to define one or several condition that a node must satisfy in order to be selected. The condition are accumulated in a list and later checked for a particular node. Note that an empty condition always succeeds.</p><p><em>Predicate</em></p><p>xne-cond-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>XneCond (none)</strong></p><p>The XneCond constructor creates a default condition. The default condition is empty. The empty condition always succeeds.</p><p><em>Methods</em></p><p><strong>add -&gt; none (Xne [String|Integer])</strong></p><p>The add adds a condition by type. The first argument is the condition type. The second argument is a condition information such like a string or an integer.</p><p><strong>valid-p -&gt; Boolean (XmlNode)</strong></p><p>The valid-p predicate checks that a node matches a condition. If the condition succeeds, the predicate returns true.</p><p><strong>XsmNode</strong></p><p>The XsmNode is a base class which is part of the xml simple model (xsm). In this model, a xml (or sgml, or html) text is represented by a node which can be either a tag, a text or a reference node. There is no concept of tree. The node content is stored in the form of a text string. This simple model is designed to parse weak data representation such like html text and later process it at the user discretion. The default representation is an empty text node.</p><p><em>Predicate</em></p><p>xsm-node-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constants</em></p><p><strong>TXT</strong></p><p>The TXT constant defines a xsm text node.</p><p><strong>TAG</strong></p><p>The TAG constant defines a xsm tag node.</p><p><strong>REF</strong></p><p>The REF constant defines a xsm reference node.</p><p><strong>END</strong></p><p>The END constant defines a xsm end node.</p><p><em>Constructors</em></p><p><strong>XsmNode (none)</strong></p><p>The XsmNode constructor creates a default xsm node which is an empty text node.</p><p><strong>XsmNode (String)</strong></p><p>The XsmNode constructor creates a xsm text node by value. The string argument is the text node value</p><p><strong>XsmNode (Item String)</strong></p><p>The XsmNode constructor creates a xsm text node by type and value. The first argument is the node type. The second argument is the node text value.</p><p><em>Methods</em></p><p><strong>text-p -&gt; Boolean (none)</strong></p><p>The text-p predicate returns true if the node is a text node.</p><p><strong>tag-p -&gt; Boolean (none)</strong></p><p>The tag-p predicate returns true if the node is a tag node.</p><p><strong>ref-p -&gt; Boolean (none)</strong></p><p>The reference-p predicate returns true if the node is a reference node.</p><p><strong>end-p -&gt; Boolean (none)</strong></p><p>The end-p predicate returns true if the node is a reference node.</p><p><strong>normal-p -&gt; Boolean (none)</strong></p><p>The normal-p predicate returns true if the node is a normal tag node.</p><p><strong>reserved-p -&gt; Boolean (none)</strong></p><p>The reserved-p predicate returns true if the node is a reserved tag node.</p><p><strong>textable-p -&gt; Boolean (none)</strong></p><p>The textable-p predicate returns true if the node is a textable node, that is a text node or a reference node.</p><p><strong>get-source-line -&gt; Integer (none)</strong></p><p>The get-source-line method returns the node source line number if any.</p><p><strong>set-source-line -&gt; none (Integer)</strong></p><p>The set-source-line method sets the node source line number.</p><p><strong>get-source-name -&gt; String (none)</strong></p><p>The get-source-name method returns the node source name if any.</p><p><strong>set-source-name -&gt; none (String)</strong></p><p>The set-source-name method sets the node source name.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the next available name. name.</p><p><strong>XsmReader</strong></p><p>The XmlReader class is the simple model node reader. The reader operates with the parse method and returns a node or nil if the end of stream is reached. Unlike the xml reader, this reader does not build a tree and the node content is not even parsed. In this model, the node content is to be interpreted at the user discretion.</p><p><em>Predicate</em></p><p>xsm-reader-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>XsmReader (none)</strong></p><p>The XsmReader constructor creates a default xsm reader. The reader is not bound to any stream.</p><p><strong>XsmReader (InputStream)</strong></p><p>The XsmReader constructor creates a xsm reader with an input stream. The argument is the input bound to the reader.</p><p><strong>XsmReader (String)</strong></p><p>The XsmReader constructor creates a xsm reader with an input string stream. The argument is a string which is used to create an input string stream bound to the reader.</p><p><em>Methods</em></p><p><strong>set-input-stream -&gt; none (InputStream)</strong></p><p>The set-input-stream method bind a new input stream to the reader. Subsequent read will use the newly bound stream</p><p><strong>get-node -&gt; XsmNode (none)</strong></p><p>The get-node method parses the input stream and returns the available node.</p><p><strong>XsmDocument</strong></p><p>The XsmDocument class is the document class that maintains a xsm document along with its associated list of nodes and other useful information. Generally the class is constructed with a file name or a name and an input stream that is used for parsing the input data. When the input stream has been parsed, the nodes are stored in a vector which can be access by index.</p><p><em>Predicate</em></p><p>document-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Constructors</em></p><p><strong>XsmDocument (none)</strong></p><p>The XsmDocument constructor creates a default xsm document.</p><p><strong>XsmDocument (String)</strong></p><p>The XsmDocument constructor creates a xsm document by name. The string argument is the file name to parse.</p><p><strong>XsmDocument (String InputStream)</strong></p><p>The XsmDocument constructor creates a xsm document by name and by parsing the input stream. The first argument is the xsm document name. The second argument is the input stream to parse.</p><p><em>Methods</em></p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the xsm document name. The get-name method is available from the nameable base class.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the xsm document length. The document length is the number of nodes parsed and stored in the document.</p><p><strong>get-node -&gt; XsmNode (Integer)</strong></p><p>The get-node method returns a document node by index.</p><p><strong>get-info -&gt; XsoInfo (Integer [Boolean])</strong></p><p>The get-info method returns a node info object by index. The info object is evaluated dynamically from the document node. In the first form, the node name is used to find the node end tag in order to construct the info text value. In the second form, the boolean argument, if true, forces the node name to be converted to lower case prior any comparison.</p><p><strong>get-info-vector -&gt; XsoInfo (String [Boolean])</strong></p><p>The get-info-vetcor method returns an info object vector by name. Each info object have their name that matches the string argument. The info object is evaluated dynamically from the document node. In the first form, the node name is used to match a tag node and then find the node end tag in order to construct the info text value. In the second form, the boolean argument, if true, forces the node name to be converted to lower case prior any comparison.</p><p><strong>XsoInfo</strong></p><p>The XsoInfo class is a xml/xsm information node used to carry simple information about a tag. The node is constructed by name, with a set of attributes and eventually a text associated with the node. The text information is generally the one associated between the start tag and the end tag. In the case of complex tree, such text data might be empty.</p><p><em>Predicate</em></p><p>xso-info-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Constructors</em></p><p><strong>XsoInfo (none)</strong></p><p>The XsoInfo constructor creates a default info object.</p><p><strong>XsoInfo (String)</strong></p><p>The XsoInfo constructor creates an info object by name. The string argument is the node info name.</p><p><strong>XsoInfo (String String)</strong></p><p>The XsoInfo constructor creates an info object by name and text. The first argument is the node info name. The second argument is the node text information.</p><p><em>Methods</em></p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the info object name.</p><p><strong>set-attribute -&gt; none (String Literal)</strong></p><p>The set-attribute method sets an attribute by name and value. The first argument is the attribute name. The second argument is the attribute value.</p><p><strong>get-attribute-list -&gt; Plist (none)</strong></p><p>The get-attribute-list method returns the node attribute list in the form of a property list object.</p><p><strong>get-attribute-value -&gt; String (String)</strong></p><p>The get-attribute-value method returns the attribute value by name. The string argument is the attribute name.</p><p><strong>set-text -&gt; none (String)</strong></p><p>The set-text method sets the info object text.</p><p><strong>get-text -&gt; String (none)</strong></p><p>The get-text method returns the text information.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="afnix-txt.3.html"><span aria-hidden="true">&larr;</span> afnix-txt.3: Standard text processing module</a></li>
   <li class="next"><a href="aio_cancel.3.html">aio_cancel.3: Cancel an outstanding asynchronous i/o request <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::Factory: Base class for dynamic factory classes</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Base class for dynamic factory classes">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::Factory (3pm) manual">
  <meta name="twitter:description" content="Base class for dynamic factory classes">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-factory-perl-Class::Factory-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::Factory.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::Factory (3pm) manual" />
  <meta property="og:description" content="Base class for dynamic factory classes" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-factory-perl-Class::Factory-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::Factory<small> (3pm)</small></h1>
        <p class="lead">Base class for dynamic factory classes</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Factory.3pm.html">
      <span itemprop="name">Class::Factory: Base class for dynamic factory classes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-factory-perl/">
      <span itemprop="name">libclass-factory-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Factory.3pm.html">
      <span itemprop="name">Class::Factory: Base class for dynamic factory classes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  package My::Factory;
  use base qw( Class::Factory );
</pre>
<p>  # Add our default types</p><p>  # This type is loaded when the statement is run</p><p>  __PACKAGE__-&gt;add_factory_type( perl =&gt; &apos;My::Factory::Perl&apos; );</p><p>  # This type is loaded on the first request for type &apos;blech&apos;</p><p>  __PACKAGE__-&gt;register_factory_type( blech =&gt; &apos;My::Factory::Blech&apos; );</p><p>  1;</p><p>  # Adding a new factory type in code -- &apos;Other::Custom::Class&apos; is   # brought in via &apos;require&apos; immediately</p><p>  My::Factory-&gt;add_factory_type( custom =&gt; &apos;Other::Custom::Class&apos; );   my $custom_object = My::Factory-&gt;new( &apos;custom&apos;, { this =&gt; &apos;that&apos; } );</p><p>  # Registering a new factory type in code; &apos;Other::Custom::ClassTwo&apos;   # isn&apos;t brought in yet...</p><p>  My::Factory-&gt;register_factory_type( custom_two =&gt; &apos;Other::Custom::ClassTwo&apos; );</p><p>  # ...it&apos;s only &apos;require&apos;d when the first instance of the type is   # created</p><p>  my $custom_object = My::Factory-&gt;new( &apos;custom_two&apos;, { this =&gt; &apos;that&apos; } );</p><p>  # Get all the loaded and registered classes and types</p><p>  my @loaded_classes     = My::Factory-&gt;get_loaded_classes;   my @loaded_types       = My::Factory-&gt;get_loaded_types;   my @registered_classes = My::Factory-&gt;get_registered_classes;   my @registered_types   = My::Factory-&gt;get_registered_types;</p><p>  # Get a registered class by it&apos;s factory type</p><p>  my $registered_class = My::Factory-&gt;get_registered_class( &apos;type&apos; );</p><p>  # Ask the object created by the factory: Where did I come from?</p><p>  my $custom_object = My::Factory-&gt;new( &apos;custom&apos; );   print "Object was created by factory: ",        $custom_object-&gt;get_my_factory, " ",        "and is of type: ",        $custom_object-&gt;get_my_factory_type;</p><p>  # Remove a factory type</p><p>  My::Factory-&gt;remove_factory_type(&apos;perl&apos;);</p><p>  # Unregister a factory type</p><p>  My::Factory-&gt;unregister_factory_type(&apos;blech&apos;);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is a simple module that factory classes can use to generate new types of objects on the fly, providing a consistent interface to common groups of objects.</p><p>Factory classes are used when you have different implementations for the same set of tasks but may not know in advance what implementations you will be using. Configuration files are a good example of this. There are four basic operations you would want to do with any configuration: read the file in, lookup a value, set a value, write the file out. There are also many different types of configuration files, and you may want users to be able to provide an implementation for their own home-grown configuration format.</p><p>With a factory class this is easy. To create the factory class, just subclass \*(C`Class::Factory\*(C' and create an interface for your configuration serializer. \*(C`Class::Factory\*(C' even provides a simple constructor for you. Here's a sample interface and our two built-in configuration types:</p><p> package My::ConfigFactory;</p><p> use strict;  use base qw( Class::Factory );</p><p> sub read  { die "Define read() in implementation" }  sub write { die "Define write() in implementation" }  sub get   { die "Define get() in implementation" }  sub set   { die "Define set() in implementation" }</p><p> __PACKAGE__-&gt;add_factory_type( ini  =&gt; &apos;My::IniReader&apos; );  __PACKAGE__-&gt;add_factory_type( perl =&gt; &apos;My::PerlReader&apos; );</p><p> 1;</p><p>And then users can add their own subclasses:</p><p> package My::CustomConfig;</p><p> use strict;  use base qw( My::ConfigFactory );</p><p> sub init {      my ( $self, $filename, $params ) = @_;      if ( $params-&gt;{base_url} ) {          $self-&gt;read_from_web( join( &apos;/&apos;, $params-&gt;{base_url}, $filename ) );      }      else {          $self-&gt;read( $filename );      }      return $self;  }</p><p> sub read  { ... implementation to read a file ... }  sub write { ... implementation to write a file ...  }  sub get   { ... implementation to get a value ... }  sub set   { ... implementation to set a value ... }</p><p> sub read_from_web { ... implementation to read via http ... }</p><p> # Now register my type with the factory</p><p> My::ConfigFactory-&gt;add_factory_type( &apos;mytype&apos; =&gt; __PACKAGE__ );</p><p> 1;</p><p>(You may not wish to make your factory the same as your interface, but this is an abbreviated example.)</p><p>So now users can use the custom configuration with something like:</p><p> #!/usr/bin/perl</p><p> use strict;  use My::ConfigFactory;  use My::CustomConfig;   # this adds the factory type &apos;custom&apos;...</p><p> my $config = My::ConfigFactory-&gt;new( &apos;custom&apos;, &apos;myconf.dat&apos; );  print "Configuration is a: ", ref( $config ), "&#92;n";</p><p>Which prints:</p><p> Configuration is a My::CustomConfig</p><p>And they can even add their own:</p><p> My::ConfigFactory-&gt;register_factory_type( &apos;newtype&apos; =&gt; &apos;My::New::ConfigReader&apos; );</p><p>This might not seem like a very big win, and for small standalone applications probably isn't. But when you develop large applications the \*(C`(add|register)_factory_type()\*(C' step will almost certainly be done at application initialization time, hidden away from the eyes of the application developer. That developer will only know that she can access the different object types as if they are part of the system.</p><p>As you see in the example above implementation for subclasses is very simple \*(-- just add \*(C`Class::Factory\*(C' to your inheritance tree and you are done.</p><p><strong>&#92;$1</strong></p><p>All type-to-class mapping information is stored under the original subclass name. So the following will not do what you expect:</p><p> package My::Factory;  use base qw( Class::Factory );  ...</p><p> package My::Implementation;  use base qw( My::Factory );  ...  My::Implementation-&gt;register_factory_type( impl =&gt; &apos;My::Implementation&apos; );</p><p>This does not register 'My::Implementation' under 'My::Factory' as you would like, it registers the type under 'My::Implementation' because that's the class we used to invoke the 'register_factory_type' method. Make all \*(C`add_factory_type()\*(C' and \*(C`register_factory_type()\*(C' invocations with the original factory class name and you'll be golden. As an additional feature, you can have your class accept registered types that get brought in only when requested. This lazy loading feature can be very useful when your factory offers many choices and users will only need one or two of them at a time, or when some classes the factory generates use libraries that some users may not have installed.</p><p>For example, say I have a factory that generates an object which parses \s-1GET/POST\s0 parameters. One type uses the ubiquitous \s-1CGI\s0 module, the other uses the faster but rarer Apache::Request. Many systems do not have Apache::Request installed so we do not want to 'use' the module whenever we create the factory.</p><p>Instead, we will register these types with the factory and only when that type is requested will we bring that implementation in. To extend our configuration example above we'll change the configuration factory to use \*(C`register_factory_type()\*(C' instead of \*(C`add_factory_type()\*(C':</p><p> package My::ConfigFactory;</p><p> use strict;  use base qw( Class::Factory );</p><p> sub read  { die "Define read() in implementation" }  sub write { die "Define write() in implementation" }  sub get   { die "Define get() in implementation" }  sub set   { die "Define set() in implementation" }</p><p> __PACKAGE__-&gt;register_factory_type( ini  =&gt; &apos;My::IniReader&apos; );  __PACKAGE__-&gt;register_factory_type( perl =&gt; &apos;My::PerlReader&apos; );</p><p> 1;</p><p>This way you can leave the actual inclusion of the module for people who would actually use it. For our configuration example we might have:</p><p> My::ConfigFactory-&gt;register_factory_type( SOAP =&gt; &apos;My::Config::SOAP&apos; );</p><p>So the \*(C`My::Config::SOAP\*(C' class will only get included at the first request for a configuration object of that type:</p><p> my $config = My::ConfigFactory-&gt;new( &apos;SOAP&apos;, &apos;http://myco.com/&apos;,                                               { port =&gt; 8080, ... } ); Piece of cake:</p><p> package My::Factory;  use base qw( Class::Factory );</p><p>or the old-school:</p><p> package My::Factory;  use Class::Factory;  @My::Factory::ISA = qw( Class::Factory );</p><p>You can also override two methods for logging/error handling. There are a few instances where \*(C`Class::Factory\*(C' may generate a warning message, or even a fatal error.  Internally, these are handled using \*(C`warn\*(C' and \*(C`die\*(C', respectively.</p><p>This may not always be what you want though.  Maybe you have a different logging facility you wish to use.  Perhaps you have a more sophisticated method of handling errors (like Log::Log4perl.  If this is the case, you are welcome to override either of these methods.</p><p>Currently, these two methods are implemented like the following:</p><p> sub factory_log   { shift; warn @_, "&#92;n" }  sub factory_error { shift; die @_, "&#92;n" }</p><p>Assume that instead of using \*(C`warn\*(C', you wish to use Log::Log4perl.  So, in your subclass, you might override \*(C`factory_log\*(C' like so:</p><p> sub factory_log {      shift;      my $logger = get_logger;      $logger-&gt;warn( @_ );  } This is a very common pattern: Subclasses create an \*(C`init()\*(C' method that gets called when the object is created:</p><p> package My::Factory;</p><p> use strict;  use base qw( Class::Factory );</p><p> 1;</p><p>And here is what a subclass might look like \*(-- note that it doesn't have to subclass \*(C`My::Factory\*(C' as our earlier examples did:</p><p> package My::Subclass;</p><p> use strict;  use base qw( Class::Accessor );</p><p> my @CONFIG_FIELDS = qw( status created_on created_by updated_on updated_by );  my @FIELDS = ( &apos;filename&apos;, @CONFIG_FIELDS );  My::Subclass-&gt;mk_accessors( @FIELDS );</p><p> # Note: we have taken the flattened C&lt;@params&gt; passed in and assigned  # the first element as C&lt;$filename&gt; and the other element as a  # hashref C&lt;$params&gt;</p><p> sub init {      my ( $self, $filename, $params ) = @_;      unless ( -f $filename ) {          die "Filename [$filename] does not exist. Object cannot be created";      }      $self-&gt;filename( filename );      $self-&gt;read_file_contents;      foreach my $field ( @CONFIG_FIELDS ) {          $self-&gt;{ $field } = $params-&gt;{ $field } if ( $params-&gt;{ $field } );      }      return $self;  }</p><p>The parent class (\*(C`My::Factory\*(C') has made as part of its definition that the only parameters to be passed to the \*(C`init()\*(C' method are $filename and $params, in that order. It could just as easily have specified a single hashref parameter.</p><p>These sorts of specifications are informal and not enforced by this \*(C`Class::Factory\*(C'. Many times you will want the parent class to automatically register the types it knows about:</p><p> package My::Factory;</p><p> use strict;  use base qw( Class::Factory );</p><p> My::Factory-&gt;register_factory_type( type1 =&gt; &apos;My::Impl::Type1&apos; );  My::Factory-&gt;register_factory_type( type2 =&gt; &apos;My::Impl::Type2&apos; );</p><p> 1;</p><p>This allows the default types to be registered when the factory is initialized. So you can use the default implementations without any more registering/adding:</p><p> #!/usr/bin/perl</p><p> use strict;  use My::Factory;</p><p> my $impl1 = My::Factory-&gt;new( &apos;type1&apos; );  my $impl2 = My::Factory-&gt;new( &apos;type2&apos; );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p><strong>new( </strong><strong>$type</strong><strong>, </strong><strong>@params</strong><strong> )</strong></p><p>This is a default constructor you can use. It is quite simple:</p><p> sub new {      my ( $pkg, $type, @params ) = @_;      my $class = $pkg-&gt;get_factory_class( $type );      return undef unless ( $class );      my $self = bless( {}, $class );      return $self-&gt;init( @params );  }</p><p>We just create a new object as a blessed hashref of the class associated (from an earlier call to \*(C`add_factory_type()\*(C' or \*(C`register_factory_type()\*(C') with $type and then call the \*(C`init()\*(C' method of that object. The \*(C`init()\*(C' method should return the object, or die on error.</p><p>If we do not get a class name from \*(C`get_factory_class()\*(C' we issue a \*(C`factory_error()\*(C' message which typically means we throw a \*(C`die\*(C'. However, if you've overridden \*(C`factory_error()\*(C' and do not die, this factory call will return \*(C`undef\*(C'.</p><p><strong>get_factory_class( </strong><strong>$object_type</strong><strong> )</strong></p><p>Usually called from a constructor when you want to lookup a class by a type and create a new object of $object_type. If $object_type is associated with a class and that class has already been included, the class is returned. If $object_type is registered with a class (not yet included), then we try to \*(C`require\*(C' the class. Any errors on the \*(C`require\*(C' bubble up to the caller. If there are no errors, the class is returned.</p><p>Returns: name of class. If a class matching $object_type is not found or cannot be \*(C`require\*(C'd, then a \*(C`die()\*(C' (or more specifically, a \*(C`factory_error()\*(C') is thrown.</p><p><strong>add_factory_type( </strong><strong>$object_type</strong><strong>, </strong><strong>$object_class</strong><strong> )</strong></p><p>Tells the factory to dynamically add a new type to its stable and brings in the class implementing that type using \*(C`require\*(C'. After running this the factory class will be able to create new objects of type $object_type.</p><p>Returns: name of class added if successful. If the proper parameters are not given or if we cannot find $object_class in @INC, then we call \*(C`factory_error()\*(C'. A \*(C`factory_log()\*(C' message is issued if the type has already been added.</p><p><strong>register_factory_type( </strong><strong>$object_type</strong><strong>, </strong><strong>$object_class</strong><strong> )</strong></p><p>Tells the factory to register a new factory type. This type will be dynamically included (using \*(C`add_factory_type()\*(C' at the first request for an instance of that type.</p><p>Returns: name of class registered if successful. If the proper parameters are not given then we call \*(C`factory_error()\*(C'. A \*(C`factory_log()\*(C' message is issued if the type has already been registered.</p><p><strong>remove_factory_type( </strong><strong>@object_types</strong><strong> )</strong></p><p>Removes a factory type from the factory. This is the opposite of \*(C`add_factory_type()\*(C'. No return value.</p><p>Removing a factory type is useful if a subclass of the factory wants to redefine the mapping for the factory type. \*(C`add_factory_type()\*(C' doesn't allow overriding a factory type, so you have to remove it first.</p><p><strong>unregister_factory_type( </strong><strong>@object_types</strong><strong> )</strong></p><p>Unregisters a factory type from the factory. This is the opposite of \*(C`register_factory_type()\*(C'. No return value.</p><p>Unregistering a factory type is useful if a subclass of the factory wants to redefine the mapping for the factory type. \*(C`register_factory_type()\*(C' doesn't allow overriding a factory type, so you have to unregister it first.</p><p><strong>get_factory_type_for( </strong><strong>$class</strong><strong> )</strong></p><p>Takes an object or a class name string and returns the factory type that is used to construct that class. Returns undef if there is no such factory type.</p><p><strong></strong><strong>get_loaded_classes()</strong><strong></strong></p><p>Returns a sorted list of the currently loaded classes. If no classes have been loaded yet, returns an empty list.</p><p><strong></strong><strong>get_loaded_types()</strong><strong></strong></p><p>Returns a sorted list of the currently loaded types. If no classes have been loaded yet, returns an empty list.</p><p><strong></strong><strong>get_registered_classes()</strong><strong></strong></p><p>Returns a sorted list of the classes that were ever registered. If no classes have been registered yet, returns an empty list.</p><p>Note that a class can be both registered and loaded since we do not clear out the registration once a registered class has been loaded on demand.</p><p><strong>get_registered_class( </strong><strong>$factory_type</strong><strong> )</strong></p><p>Returns a registered class given a factory type. If no class of type $factory_type is registered, returns undef. If no classes have been registered yet, returns undef.</p><p><strong></strong><strong>get_registered_types()</strong><strong></strong></p><p>Returns a sorted list of the types that were ever registered. If no types have been registered yet, returns an empty list.</p><p>Note that a type can be both registered and loaded since we do not clear out the registration once a registered type has been loaded on demand.</p><p><strong>factory_log( </strong><strong>@message</strong><strong> )</strong></p><p>Used internally instead of \*(C`warn\*(C' so subclasses can override. Default implementation just uses \*(C`warn\*(C'.</p><p><strong>factory_error( </strong><strong>@message</strong><strong> )</strong></p><p>Used internally instead of \*(C`die\*(C' so subclasses can override. Default implementation just uses \*(C`die\*(C'. If your implementations \*(-- objects the factory creates \*(-- also inherit from the factory they can do a little introspection and tell you where they came from. (Inheriting from the factory is a common usage: the \s-1SYNOPSIS\s0 example does it.)</p><p>All methods here can be called on either a class or an object.</p><p><strong></strong><strong>get_my_factory()</strong><strong></strong></p><p>Returns the factory class used to create this object or instances of this class. If this class (or object class) hasn't been registered with the factory it returns undef.</p><p>So with our \s-1SYNOPSIS\s0 example we could do:</p><p> my $custom_object = My::Factory-&gt;new( &apos;custom&apos; );  print "Object was created by factory ",        "&apos;", $custom_object-&gt;get_my_factory, "&apos;;</p><p>which would print:</p><p> Object was created by factory &apos;My::Factory&apos;</p><p><strong></strong><strong>get_my_factory_type()</strong><strong></strong></p><p>Returns the type used to by the factory create this object or instances of this class. If this class (or object class) hasn't been registered with the factory it returns undef.</p><p>So with our \s-1SYNOPSIS\s0 example we could do:</p><p> my $custom_object = My::Factory-&gt;new( &apos;custom&apos; );  print "Object is of type ",        "&apos;", $custom_object-&gt;get_my_factory_type, "&apos;";</p><p>which would print:</p><p> Object is of type &apos;custom&apos;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2002-2007 Chris Winters. All rights reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Class::Factory&hellip;</h2>
        <div class="sectioncontent">
<p>\*(L"Design Patterns\*(R", by Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides. Addison Wesley Longman, 1995. Specifically, the 'Factory Method' pattern, pp. 107-116.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Fred Moyer &lt;fred@redhotpenguin.com&gt; is the current maintainer.</p><p>Chris Winters &lt;chris@cwinters.com&gt;</p><p>Eric Andreychek &lt;eric@openthought.net&gt; implemented overridable log/error capability and prodded the module into a simpler design.</p><p>Srdjan Jankovic &lt;srdjan@catalyst.net.nz&gt; contributed the idea for '<em>get_my_factory()</em>' and '<em>get_my_factory_type()</em>'</p><p>Sebastian Knapp &lt;giftnuss@netscape.net&gt; contributed the idea for '<em>get_registered_class()</em>'</p><p>Marcel Gruenauer &lt;marcel@cpan.org&gt; contributed the methods <em>remove_factory_type()</em> and <em>unregister_factory_type()</em>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::Default.3pm.html"><span aria-hidden="true">&larr;</span> Class::Default.3pm: Static calls apply to a default instantiation</a></li>
   <li class="next"><a href="Class::Factory::Util.3pm.html">Class::Factory::Util.3pm: Provide utility methods for factory classes <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

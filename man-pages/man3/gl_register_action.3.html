<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gl_register_action: Allow the user to compose an input line</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Allow the user to compose an input line">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gl_register_action (3) manual">
  <meta name="twitter:description" content="Allow the user to compose an input line">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtecla-dev-gl_register_action-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/gl_register_action.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gl_register_action (3) manual" />
  <meta property="og:description" content="Allow the user to compose an input line" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtecla-dev-gl_register_action-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gl_register_action<small> (3)</small></h1>
        <p class="lead">Allow the user to compose an input line</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/gl_register_action.3.html">
      <span itemprop="name">gl_register_action: Allow the user to compose an input line</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtecla-dev/">
      <span itemprop="name">libtecla-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/gl_register_action.3.html">
      <span itemprop="name">gl_register_action: Allow the user to compose an input line</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;stdio.h&gt;
#include &lt;libtecla.h&gt;

GetLine *new_GetLine(size_t linelen, size_t histlen);

GetLine *del_GetLine(GetLine *gl);

char *gl_get_line(GetLine *gl, const char *prompt,
                  const char *start_line, int start_pos);

int gl_query_char(GetLine *gl, const char *prompt,
                  char defchar);

int gl_read_char(GetLine *gl);

int gl_customize_completion(GetLine *gl, void *data,
                            CplMatchFn *match_fn);

int gl_change_terminal(GetLine *gl, FILE *input_fp,
                       FILE *output_fp, const char *term);

int gl_configure_getline(GetLine *gl,
                         const char *app_string,
                         const char *app_file,
                         const char *user_file);

int gl_bind_keyseq(GetLine *gl, GlKeyOrigin origin,
                   const char *keyseq, const char *action);

int gl_save_history(GetLine *gl, const char *filename,
                    const char *comment, int max_lines);

int gl_load_history(GetLine *gl, const char *filename,
                    const char *comment);

int gl_watch_fd(GetLine *gl, int fd, GlFdEvent event,
                GlFdEventFn *callback, void *data);

int gl_inactivity_timeout(GetLine *gl, GlTimeoutFn *callback,
                   void *data, unsigned long sec,
                   unsigned long nsec);

int gl_group_history(GetLine *gl, unsigned stream);

int gl_show_history(GetLine *gl, FILE *fp,
                    const char *fmt, int all_groups,
                    int max_lines);

int gl_resize_history(GetLine *gl, size_t bufsize);

void gl_limit_history(GetLine *gl, int max_lines);

void gl_clear_history(GetLine *gl, int all_groups);

void gl_toggle_history(GetLine *gl, int enable);

GlTerminalSize gl_terminal_size(GetLine *gl,
                                int def_ncolumn,
                                int def_nline);

int gl_set_term_size(GetLine *gl, int ncolumn, int nline);

int gl_lookup_history(GetLine *gl, unsigned long id,
                      GlHistoryLine *hline);

void gl_state_of_history(GetLine *gl,
                         GlHistoryState *state);

void gl_range_of_history(GetLine *gl,
                         GlHistoryRange *range);

void gl_size_of_history(GetLine *gl, GlHistorySize *size);

void gl_echo_mode(GetLine *gl, int enable);

void gl_replace_prompt(GetLine *gl, const char *prompt);

void gl_prompt_style(GetLine *gl, GlPromptStyle style);

int gl_ignore_signal(GetLine *gl, int signo);

int gl_trap_signal(GetLine *gl, int signo, unsigned flags,
                   GlAfterSignal after, int errno_value);

int gl_last_signal(GetLine *gl);

int gl_completion_action(GetLine *gl,
                         void *data, CplMatchFn *match_fn,
                         int list_only, const char *name,
                         const char *keyseq);

int gl_register_action(GetLine *gl, void *data,
                       GlActionFn *fn, const char *name,
                       const char *keyseq);

int gl_display_text(GetLine *gl, int indentation,
                    const char *prefix,
                    const char *suffix, int fill_char,
                    int def_width, int start,
                    const char *string);

GlReturnStatus gl_return_status(GetLine *gl);

const char *gl_error_message(GetLine *gl, char *buff,
                             size_t n);

void gl_catch_blocked(GetLine *gl);

int gl_list_signals(GetLine *gl, sigset_t *set);

int gl_append_history(GetLine *gl, const char *line);

int gl_automatic_history(GetLine *gl, int enable);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>gl_get_line()</strong> function is part of the tecla library (see the <a href="../man3/libtecla.3.html"><strong>libtecla</strong>(3)</a></strong> man page). If the user is typing at a terminal, each call prompts them for an line of input, then provides interactive editing facilities, similar to those of the unix <strong>tcsh</strong> shell. In addition to simple command-line editing, it supports recall of previously entered command lines, TAB completion of file names, and in-line wild-card expansion of filenames. Documentation of both the user-level command-line editing features and all user configuration options, can be found in the <a href="../man7/tecla.7.html"><strong>tecla</strong>(7)</a></strong> man page. This man page concerns itself with documentation for programmers interested in using this library in their application.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AN EXAMPLE</h2>
        <div class="sectioncontent">
<p>The following shows a complete example of how to use the <strong>gl_get_line()</strong> function to get input from the user:</p>
<pre>
  #include &lt;stdio.h&gt;
  #include &lt;locale.h&gt;
  #include &lt;libtecla.h&gt;

  int main(int argc, char *argv[])
  {
    char *line;    /* The line that the user typed */
    GetLine *gl;   /* The gl_get_line() resource object */

    setlocale(LC_CTYPE, ""); /* Adopt the user's choice */
                             /* of character set. */

    gl = new_GetLine(1024, 2048);
    if(!gl)
      return 1;

    while((line=gl_get_line(gl, "$ ", NULL, -1)) != NULL &&
           strcmp(line, "exit&#92;n") != 0)
      printf("You typed: %s&#92;n", line);

    gl = del_GetLine(gl);
    return 0;
  }
</pre>
<p>In the example, first the resources needed by the <strong>gl_get_line()</strong> function are created by calling <strong>new_GetLine()</strong>. This allocates the memory used in subsequent calls to the <strong>gl_get_line()</strong> function, including the history buffer for recording previously entered lines. Then one or more lines are read from the user, until either an error occurs, or the user types <strong>exit</strong>. Then finally the resources that were allocated by <strong>new_GetLine()</strong>, are returned to the system by calling <strong>del_GetLine()</strong>. Note the use of the <strong>NULL</strong> return value of <strong>del_GetLine()</strong> to make <strong>gl</strong> <strong>NULL</strong>. This is a safety precaution. If the program subsequently attempts to pass <strong>gl</strong> to <strong>gl_get_line()</strong>, said function will complain, and return an error, instead of attempting to use the deleted resource object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE FUNCTIONS USED IN THE EXAMPLE</h2>
        <div class="sectioncontent">
<p>The descriptions of the functions used in the example are as follows:</p>
<pre>
  GetLine *new_GetLine(size_t linelen, size_t histlen)
</pre>
<p>This function creates the resources used by the <strong>gl_get_line()</strong> function and returns an opaque pointer to the object that contains them.  The maximum length of an input line is specified via the <strong>linelen</strong> argument, and the number of bytes to allocate for storing history lines is set by the <strong>histlen</strong> argument. History lines are stored back-to-back in a single buffer of this size. Note that this means that the number of history lines that can be stored at any given time, depends on the lengths of the individual lines.  If you want to place an upper limit on the number of lines that can be stored, see the <strong>gl_limit_history()</strong> function described later. If you don't want history at all, specify <strong>histlen</strong> as zero, and no history buffer will be allocated.</p><p>On error, a message is printed to <strong>stderr</strong> and <strong>NULL</strong> is returned.</p>
<pre>
  GetLine *del_GetLine(GetLine *gl)
</pre>
<p>This function deletes the resources that were returned by a previous call to <strong>new_GetLine()</strong>. It always returns <strong>NULL</strong> (ie a deleted object). It does nothing if the <strong>gl</strong> argument is <strong>NULL</strong>.</p>
<pre>
  char *gl_get_line(GetLine *gl, const char *prompt,
                   const char *start_line, int start_pos);
</pre>
<p>The <strong>gl_get_line()</strong> function can be called any number of times to read input from the user. The <strong>gl</strong> argument must have been previously returned by a call to <strong>new_GetLine()</strong>. The <strong>prompt</strong> argument should be a normal <strong>NUL</strong> terminated string, specifying the prompt to present the user with. By default prompts are displayed literally, but if enabled with the <strong>gl_prompt_style()</strong> function (see later), prompts can contain directives to do underlining, switch to and from bold fonts, or turn highlighting on and off.</p><p>If you want to specify the initial contents of the line, for the user to edit, pass the desired string via the <strong>start_line</strong> argument. You can then specify which character of this line the cursor is initially positioned over, using the <strong>start_pos</strong> argument. This should be -1 if you want the cursor to follow the last character of the start line. If you don't want to preload the line in this manner, send <strong>start_line</strong> as <strong>NULL</strong>, and set <strong>start_pos</strong> to -1. Note that the line pointer returned by one call to <strong>gl_get_line()</strong> can be passed back to the next call to <strong>gl_get_line()</strong> via the <strong>start_line</strong>. This allows the application to take the last entered line, and if it contains an error, to then present it back to the user for re-editing, with the cursor initially positioned where the error was encountered.</p><p>The <strong>gl_get_line()</strong> function returns a pointer to the line entered by the user, or <strong>NULL</strong> on error or at the end of the input. The returned pointer is part of the specified <strong>gl</strong> resource object, and thus should not be free'd by the caller, or assumed to be unchanging from one call to the next. When reading from a user at a terminal, there will always be a newline character at the end of the returned line.  When standard input is being taken from a pipe or a file, there will similarly be a newline unless the input line was too long to store in the internal buffer. In the latter case you should call <strong>gl_get_line()</strong> again to read the rest of the line. Note that this behavior makes <strong>gl_get_line()</strong> similar to <strong>fgets()</strong>.  In fact when <strong>stdin</strong> isn't connected to a terminal,<strong>gl_get_line()</strong> just calls <strong>fgets()</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE RETURN STATUS OF GL_GET_LINE</h2>
        <div class="sectioncontent">
<p>As described above, the <strong>gl_get_line()</strong> function has two possible return values; a pointer to the completed input line, or <strong>NULL</strong>. Extra information about what caused <strong>gl_get_line()</strong> to return is available both by inspecting <strong>errno</strong>, and by calling the <strong>gl_return_status()</strong> function.</p>
<pre>
  GlReturnStatus gl_return_status(GetLine *gl);
</pre>
<p>The following are the possible enumerated values that this function returns.</p>
<pre>
  GLR_NEWLINE     -  The last call to <strong>gl_get_line()</strong>
                     successfully returned a completed
                     input line.

  GLR_BLOCKED     -  <strong>gl_get_line()</strong> was in non-blocking
                     server mode, and returned early to
                     avoid blocking the process while
                     waiting for terminal I/O. The
                     <strong>gl_pending_io()</strong> function can be
                     used to see what type of I/O
                     <strong>gl_get_line()</strong> was waiting for.
                     (see the <a href="../man3/gl_io_mode.3.html"><strong>gl_io_mode</strong>(3)</a></strong> man page
                     for details).

  GLR_SIGNAL      -  A signal was caught by
                     <strong>gl_get_line()</strong> that had an
                     after-signal disposition of
                     <strong>GLS_ABORT</strong> (See <strong>gl_trap_signal()</strong>).

  GLR_TIMEOUT     -  The inactivity timer expired while
                     <strong>gl_get_line()</strong> was waiting for
                     input, and the timeout callback
                     function returned <strong>GLTO_ABORT</strong>.
                     See <strong>gl_inactivity_timeout()</strong> for
                     information about timeouts.

  GLR_FDABORT     -  An application I/O callack returned
                     <strong>GLFD_ABORT</strong> (see <strong>gl_watch_fd()</strong>).

  GLR_EOF         -  End of file reached. This can happen
                     when input is coming from a file or a
                     pipe, instead of the terminal. It also
                     occurs if the user invokes the
                     <strong>list-or-eof</strong> or <strong>del-char-or-list-or-eof</strong>
                     actions at the start of a new line.

  GLR_ERROR       -  An unexpected error caused
                     <strong>gl_get_line()</strong> to abort (consult
                     <strong>errno</strong> and/or
                     <strong>gl_error_message()</strong> for details.
</pre>
<p>When <strong>gl_return_status()</strong> returns <strong>GLR_ERROR</strong>, and the value of <strong>errno</strong> isn't sufficient to explain what happened, you can use the <strong>gl_error_message()</strong> function to request a description of the last error that occurred.</p>
<pre>
  const char *gl_error_message(GetLine *gl, char *buff,
                               size_t n);
</pre>
<p>The return value is a pointer to the message that occurred. If the <strong>buff</strong> argument is <strong>NULL</strong>, this will be a pointer to a buffer within <strong>gl</strong>, who's value will probably change on the next call to any function associated with <strong>gl_get_line()</strong>. Otherwise, if a non-<strong>NULL</strong> <strong>buff</strong> argument is provided, the error message, including a <strong>'&#92;0'</strong> terminator, will be written within the first <strong>n</strong> elements of this buffer, and the return value will be a pointer to the first element of this buffer. If the message won't fit in the provided buffer, it will be truncated to fit.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONAL PROMPT FORMATTING</h2>
        <div class="sectioncontent">
<p>Whereas by default the prompt string that you specify is displayed literally, without any special interpretation of the characters within it, the <strong>gl_prompt_style()</strong> function can be used to enable optional formatting directives within the prompt.</p>
<pre>
  void gl_prompt_style(GetLine *gl, GlPromptStyle style);
</pre>
<p>The <strong>style</strong> argument, which specifies the formatting style, can take any of the following values:</p>
<pre>
  GL_FORMAT_PROMPT   -  In this style, the formatting
                        directives described below, when
                        included in prompt strings, are
                        interpreted as follows:

                          %B  -  Display subsequent
                                 characters with a bold
                                 font.
                          %b  -  Stop displaying characters
                                 with the bold font.
                          %F  -  Make subsequent characters
                                 flash.
                          %f  -  Turn off flashing
                                 characters.
                          %U  -  Underline subsequent
                                 characters.
                          %u  -  Stop underlining
                                 characters.
                          %P  -  Switch to a pale (half
                                 brightness) font.
                          %p  -  Stop using the pale font.
                          %S  -  Highlight subsequent
                                 characters (also known as
                                 standout mode).
                          %s  -  Stop highlighting
                                 characters.
                          %V  -  Turn on reverse video.
                          %v  -  Turn off reverse video.
                          %%  -  Display a single %
                                 character.

                        For example, in this mode, a prompt
                        string like <strong>"%UOK%u$ "</strong> would
                        display the prompt <strong>"OK$ "</strong>,
                        but with the <strong>OK</strong> part
                        underlined.

                        Note that although a pair of
                        characters that starts with a %
                        character, but doesn't match any of
                        the above directives is displayed
                        literally, if a new directive is
                        subsequently introduced which does
                        match, the displayed prompt will
                        change, so it is better to always
                        use %% to display a literal %.

                        Also note that not all terminals
                        support all of these text
                        attributes, and that some substitute
                        a different attribute for missing
                        ones.

  GL_LITERAL_PROMPT  -  In this style, the prompt string is
                        printed literally. This is the
                        default style.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ALTERNATE CONFIGURATION SOURCES</h2>
        <div class="sectioncontent">
<p>As mentioned above, by default users have the option of configuring the behavior of <strong>gl_get_line()</strong> via a configuration file called <strong>.teclarc</strong> in their home directories. The fact that all applications share this same configuration file is both an advantage and a disadvantage.  In most cases it is an advantage, since it encourages uniformity, and frees the user from having to configure each application separately.  In some applications, however, this single means of configuration is a problem. This is particularly true of embedded software, where there's no filesystem to read a configuration file from, and also in applications where a radically different choice of keybindings is needed to emulate a legacy keyboard interface.  To cater for such cases, the following function allows the application to control where configuration information is read from.</p>
<pre>
  int gl_configure_getline(GetLine *gl,
                           const char *app_string,
                           const char *app_file,
                           const char *user_file);
</pre>
<p>It allows the configuration commands that would normally be read from a user's <strong>~/.teclarc</strong> file, to be read from any or none of, a string, an application specific configuration file, and/or a user-specific configuration file. If this function is called before the first call to <strong>gl_get_line()</strong>, the default behavior of reading <strong>~/.teclarc</strong> on the first call to <strong>gl_get_line()</strong> is disabled, so all configuration must be achieved using the configuration sources specified with this function.</p><p>If <strong>app_string != NULL</strong>, then it is interpreted as a string containing one or more configuration commands, separated from each other in the string by embedded newline characters. If <strong>app_file !=</strong> NULL then it is interpreted as the full pathname of an application-specific configuration file. If <strong>user_file != NULL</strong> then it is interpreted as the full pathname of a user-specific configuration file, such as <strong>~/.teclarc</strong>. For example, in the following call,</p>
<pre>
  gl_configure_getline(gl, "edit-mode vi &#92;n nobeep",
                           "/usr/share/myapp/teclarc",
                           "~/.teclarc");
</pre>
<p>the <strong>app_string</strong> argument causes the calling application to start in vi edit-mode, instead of the default emacs mode, and turns off the use of the terminal bell by the library. It then attempts to read system-wide configuration commands from an optional file called <strong>/usr/share/myapp/teclarc</strong>, then finally reads user-specific configuration commands from an optional <strong>.teclarc</strong> file in the user's home directory. Note that the arguments are listed in ascending order of priority, with the contents of <strong>app_string</strong> being potentially overriden by commands in <strong>app_file</strong>, and commands in <strong>app_file</strong> potentially being overriden by commands in <strong>user_file</strong>.</p><p>You can call this function as many times as needed, the results being cumulative, but note that copies of any filenames specified via the <strong>app_file</strong> and <strong>user_file</strong> arguments are recorded internally for subsequent use by the <strong>read-init-files</strong> key-binding function, so if you plan to call this function multiple times, be sure that the last call specifies the filenames that you want re-read when the user requests that the configuration files be re-read.</p><p>Individual key sequences can also be bound and unbound using the <strong>gl_bind_keyseq()</strong> function.</p>
<pre>
  int gl_bind_keyseq(GetLine *gl, GlKeyOrigin origin,
                     const char *keyseq,
                     const char *action);
</pre>
<p>The <strong>origin</strong> argument specifies the priority of the binding, according to who it is being established for, and must be one of the following two values.</p>
<pre>
  GL_USER_KEY   -   The user requested this key-binding.
  GL_APP_KEY    -   This is a default binding set by the
                    application.
</pre>
<p>When both user and application bindings for a given key-sequence have been specified, the user binding takes precedence. The application's binding is subsequently reinstated if the user's binding is later unbound via either another to this function, or a call to <strong>gl_configure_getline()</strong>.</p><p>The <strong>keyseq</strong> argument specifies the key-sequence to be bound or unbound, and is expressed in the same way as in a <strong>~/.teclarc</strong> configuration file. The <strong>action</strong> argument must either be a string containing the name of the action to bind the key-sequence to, or it must be <strong>NULL</strong> or "" to unbind the key-sequence.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CUSTOMIZED WORD COMPLETION</h2>
        <div class="sectioncontent">
<p>If in your application, you would like to have TAB completion complete other things in addition to or instead of filenames, you can arrange this by registering an alternate completion callback function, via a call to the <strong>gl_customize_completion()</strong> function.</p>
<pre>
  int gl_customize_completion(GetLine *gl, void *data,
                              CplMatchFn *match_fn);
</pre>
<p>The <strong>data</strong> argument provides a way for your application to pass arbitrary, application-specific information to the callback function. This is passed to the callback every time that it is called. It might for example, point to the symbol table from which possible completions are to be sought. The <strong>match_fn</strong> argument specifies the callback function to be called. The <strong>CplMatchFn</strong> function type is defined in <strong>libtecla.h</strong>, as is a <strong>CPL_MATCH_FN()</strong> macro that you can use to declare and prototype callback functions. The declaration and responsibilities of callback functions are described in depth in the <a href="../man3/cpl_complete_word.3.html"><strong>cpl_complete_word</strong>(3)</a> man page.</p><p>In brief, the callback function is responsible for looking backwards in the input line, back from the point at which the user pressed TAB, to find the start of the word being completed. It then must lookup possible completions of this word, and record them one by one in the <strong>WordCompletion</strong> object that is passed to it as an argument, by calling the <strong>cpl_add_completion()</strong> function. If the callback function wishes to provide filename completion in addition to its own specific completions, it has the option of itself calling the builtin file-name completion callback. This also, is documented in the <a href="../man3/cpl_complete_word.3.html"><strong>cpl_complete_word</strong>(3)</a></strong> man page.</p><p>Note that if you would like <strong>gl_get_line()</strong> to return the current input line when a successful completion is been made, you can arrange this when you call <strong>cpl_add_completion()</strong>, by making the last character of the continuation suffix a newline character. If you do this, the input line will be updated to display the completion, together with any contiuation suffix up to the newline character, then <strong>gl_get_line()</strong> will return this input line.</p><p>If, for some reason, your callback function needs to write something to the terminal, it must call <strong>gl_normal_io()</strong> before doing so. This will start a new line after the input line that is currently being edited, reinstate normal terminal I/O, and tell <strong>gl_get_line()</strong> that the input line will need to be redrawn when the callback returns.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADDING COMPLETION ACTIONS</h2>
        <div class="sectioncontent">
<p>In the previous section the ability to customize the behavior of the only default completion action, <strong>complete-word</strong>, was described. In this section the ability to install additional action functions, so that different types of word completion can be bound to different key-sequences, is described. This is achieved by using the <strong>gl_completion_action()</strong> function.</p>
<pre>
  int gl_completion_action(GetLine *gl,
                           void *data, CplMatchFn *match_fn,
                           int list_only, const char *name,
                           const char *keyseq);
</pre>
<p>The <strong>data</strong> and <strong>match_fn</strong> arguments are as described in the <strong>cpl_complete_word</strong> man page, and specify the callback function that should be invoked to identify possible completions.  The <strong>list_only</strong> argument determines whether the action that is being defined should attempt to complete the word as far as possible in the input line before displaying any possible ambiguous completions, or whether it should simply display the list of possible completions without touching the input line. The former option is selected by specifying a value of <strong>0</strong>, and the latter by specifying a value of <strong>1</strong>. The <strong>name</strong> argument specifies the name by which configuration files and future invokations of this function should refer to the action. This must either be the name of an existing completion action to be changed, or be a new unused name for a new action. Finally, the <strong>keyseq</strong> argument specifies the default key-sequence to bind the action to. If this is <strong>NULL</strong>, no new keysequence will be bound to the action.</p><p>Beware that in order for the user to be able to change the key-sequence that is bound to actions that are installed in this manner, when you call <strong>gl_completion_action()</strong> to install a given action for the first time, you should do this between calling <strong>new_GetLine()</strong> and the first call to <strong>gl_get_line()</strong>.  Otherwise, when the user's configuration file is read on the first call to <strong>gl_get_line()</strong>, the name of the your additional action won't be known, and any reference to it in the configuration file will generate an error.</p><p>As discussed for <strong>gl_customize_completion()</strong>, if your callback function, for some reason, needs to write anything to the terminal, it must call <strong>gl_normal_io()</strong> before doing so.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEFINING CUSTOM ACTIONS</h2>
        <div class="sectioncontent">
<p>Although the built-in key-binding actions are sufficient for the needs of most applications, occasionally a specialized application may need to define one or more custom actions, bound to application-specific key-sequences. For example, a sales application would benefit from having a key-sequence that displayed the part name that corresponded to a part number preceding the cursor. Such a feature is clearly beyond the scope of the built-in action functions. So for such special cases, the <strong>gl_register_action()</strong> function is provided.</p>
<pre>
  int gl_register_action(GetLine *gl, void *data,
			 GlActionFn *fn, const char *name,
			 const char *keyseq);
</pre>
<p>This function lets the application register an external function, <strong>fn</strong>, that will thereafter be called whenever either the specified key-sequence, <strong>keyseq</strong>, is entered by the user, or the user enters any other key-sequence that the user subsequently binds to the specified action name, <strong>name</strong>, in their configuration file. The <strong>data</strong> argument can be a pointer to anything that the application wishes to have passed to the action function, <strong>fn</strong>, whenever that function is invoked.</p><p>The action function, <strong>fn</strong>, should be declared using the following macro, which is defined in <strong>libtecla.h</strong>.</p>
<pre>
  #define GL_ACTION_FN(fn) GlAfterAction (fn)(GetLine *gl, &#92;
              void *data, int count, size_t curpos, &#92;
              const char *line)
</pre>
<p>The <strong>gl</strong> and <strong>data</strong> arguments are those that were previously passed to <strong>gl_register_action()</strong> when the action function was registered. The <strong>count</strong> argument is a numeric argument which the user has the option of entering using the <strong>digit-argument</strong> action, before invoking the action. If the user doesn't enter a number, then the <strong>count</strong> argument is set to 1. Nominally this argument is interpreted as a repeat count, meaning that the action should be repeated that many times. In practice however, for some actions a repeat count makes little sense. In such cases, actions can either simply ignore the <strong>count</strong> argument, or use its value for a different purpose.</p><p>A copy of the current input line is passed in the read-only <strong>line</strong> argument. The current cursor position within this string is given by the index contained in the <strong>curpos</strong> argument. Note that direct manipulation of the input line and the cursor position is not permitted. This is because the rules dicated by various modes, such as vi mode versus emacs mode, no-echo mode, and insert mode versus overstrike mode etc, make it too complex for an application writer to write a conforming editing action, as well as constrain future changes to the internals of <strong>gl_get_line()</strong>. A potential solution to this dilema would be to allow the action function to edit the line using the existing editing actions. This is currently under consideration.</p><p>If the action function wishes to write text to the terminal, without this getting mixed up with the displayed text of the input line, or read from the terminal without having to handle raw terminal I/O, then before doing either of these operations, it must temporarily suspend line editing by calling the <strong>gl_normal_io()</strong> function. This function flushes any pending output to the terminal, moves the cursor to the start of the line that follows the last terminal line of the input line, then restores the terminal to a state that is suitable for use with the C stdio facilities. The latter includes such things as restoring the normal mapping of <strong>&#92;n</strong> to <strong>&#92;r&#92;n</strong>, and, when in server mode, restoring the normal blocking form of terminal I/O. Having called this function, the action function can read from and write to the terminal without the fear of creating a mess.  It isn't necessary for the action function to restore the original editing environment before it returns. This is done automatically by <strong>gl_get_line()</strong> after the action function returns.  The following is a simple example of an action function which writes the sentence "Hello world" on a new terminal line after the line being edited. When this function returns, the input line is redrawn on the line that follows the "Hello world" line, and line editing resumes.</p>
<pre>
  static GL_ACTION_FN(say_hello_fn)
  {
    if(gl_normal_io(gl))   /* Temporarily suspend editing */
      return GLA_ABORT;
    printf("Hello world&#92;n");
    return GLA_CONTINUE;
  }
</pre>
<p>Action functions must return one of the following values, to tell <strong>gl_get_line()</strong> how to procede.</p>
<pre>
  GLA_ABORT     -   Cause gl_get_line() to return NULL.
  GLA_RETURN    -   Cause gl_get_line() to return the
                    completed input line.
  GLA_CONTINUE  -   Resume command-line editing.
</pre>
<p>Note that the <strong>name</strong> argument of <strong>gl_register_action()</strong> specifies the name by which a user can refer to the action in their configuration file. This allows them to re-bind the action to an alternate key-seqeunce. In order for this to work, it is necessary to call <strong>gl_register_action()</strong> between calling <strong>new_GetLine()</strong> and the first call to <strong>gl_get_line()</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY FILES</h2>
        <div class="sectioncontent">
<p>To save the contents of the history buffer before quitting your application, and subsequently restore them when you next start the application, the following functions are provided.</p>
<pre>
 int gl_save_history(GetLine *gl, const char *filename,
                     const char *comment, int max_lines);
 int gl_load_history(GetLine *gl, const char *filename,
                     const char *comment);
</pre>
<p>The <strong>filename</strong> argument specifies the name to give the history file when saving, or the name of an existing history file, when loading. This may contain home-directory and environment variable expressions, such as "~/.myapp_history" or "$HOME/.myapp_history".</p><p>Along with each history line, extra information about it, such as when it was entered by the user, and what its nesting level is, is recorded as a comment preceding the line in the history file. Writing this as a comment allows the history file to double as a command file, just in case you wish to replay a whole session using it. Since comment prefixes differ in different languages, the <strong>comment</strong> argument is provided for specifying the comment prefix. For example, if your application were a unix shell, such as the bourne shell, you would specify "#" here. Whatever you choose for the comment character, you must specify the same prefix to <strong>gl_load_history()</strong> that you used when you called <strong>gl_save_history()</strong> to write the history file.</p><p>The <strong>max_lines</strong> must be either -1 to specify that all lines in the history list be saved, or a positive number specifying a ceiling on how many of the most recent lines should be saved.</p><p>Both fuctions return non-zero on error, after writing an error message to stderr. Note that <strong>gl_load_history()</strong> does not consider the non-existence of a file to be an error.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPLE HISTORY LISTS</h2>
        <div class="sectioncontent">
<p>If your application uses a single <strong>GetLine</strong> object for entering many different types of input lines, you may wish <strong>gl_get_line()</strong> to distinguish the different types of lines in the history list, and only recall lines that match the current type of line. To support this requirement, <strong>gl_get_line()</strong> marks lines being recorded in the history list with an integer identifier chosen by the application. Initially this identifier is set to 0<strong> by </strong><strong>new_GetLine()</strong>, but it can be changed subsequently by calling <strong>gl_group_history()</strong>.</p>
<pre>
  int gl_group_history(GetLine *gl, unsigned id);
</pre>
<p>The integer identifier <strong>id</strong> can be any number chosen by the application, but note that <strong>gl_save_history()</strong> and <strong>gl_load_history()</strong> preserve the association between identifiers and historical input lines between program invokations, so you should choose fixed identifiers for the different types of input line used by your application.</p><p>Whenever <strong>gl_get_line()</strong> appends a new input line to the history list, the current history identifier is recorded with it, and when it is asked to recall a historical input line, it only recalls lines that are marked with the current identifier.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISPLAYING HISTORY</h2>
        <div class="sectioncontent">
<p>The history list can be displayed by calling <strong>gl_show_history()</strong>.</p>
<pre>
  int gl_show_history(GetLine *gl, FILE *fp,
                      const char *fmt,
                      int all_groups,
                      int max_lines);
</pre>
<p>This displays the current contents of the history list to the stdio output stream <strong>fp</strong>. If the <strong>max_lines</strong> argument is greater than or equal to zero, then no more than this number of the most recent lines will be displayed. If the <strong>all_groups</strong> argument is non-zero, lines from all history groups are displayed. Otherwise just those of the currently selected history group are displayed. The format string argument, <strong>fmt</strong>, determines how the line is displayed. This can contain arbitrary characters which are written verbatim, interleaved with any of the following format directives:</p>
<pre>
  %D  -  The date on which the line was originally
         entered, formatted like 2001-11-20.
  %T  -  The time of day when the line was entered,
         formatted like 23:59:59.
  %N  -  The sequential entry number of the line in
         the history buffer.
  %G  -  The number of the history group which the
         line belongs to.
  %%  -  A literal % character.
  %H  -  The history line itself.
</pre>
<p>Thus a format string like <strong>"%D %T  %H\n"</strong> would output something like:</p>
<pre>
  2001-11-20 10:23:34  Hello world
</pre>
<p>Note the inclusion of an explicit newline character in the format string.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOOKING UP HISTORY</h2>
        <div class="sectioncontent">
<p>The <strong>gl_lookup_history()</strong> function allows the calling application to look up lines in the history list.</p>
<pre>
  typedef struct {
    const char *line;    /* The requested historical */
                         /*  line. */
    unsigned group;      /* The history group to which */
                         /*  the line belongs. */
    time_t timestamp;    /* The date and time at which */
                         /*  the line was originally */
                         /*  entered. */
  } GlHistoryLine;

  int gl_lookup_history(GetLine *gl, unsigned long id,
                        GlHistoryLine *hline);
</pre>
<p>The <strong>id</strong> argument indicates which line to look up, where the first line that was entered in the history list after <strong>new_GetLine()</strong> was called, is denoted by 0, and subsequently entered lines are denoted with successively higher numbers. Note that the range of lines currently preserved in the history list can be queried by calling the <strong>gl_range_of_history()</strong> function, described later. If the requested line is in the history list, the details of the line are recorded in the variable pointed to by the <strong>hline</strong> argument, and <strong>1</strong> is returned. Otherwise <strong>0</strong> is returned, and the variable pointed to by <strong>hline</strong> is left unchanged.</p><p>Beware that the string returned in <strong>hline-&gt;line</strong> is part of the history buffer, so it must not be modified by the caller, and will be recycled on the next call to any function that takes <strong>gl</strong> as its argument. Therefore you should make a private copy of this string if you need to keep it around.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MANUAL HISTORY ARCHIVAL</h2>
        <div class="sectioncontent">
<p>By default, whenever a line is entered by the user, it is automatically appended to the history list, just before <strong>gl_get_line()</strong> returns the line to the caller. This is convenient for the majority of applications, but there are also applications that need finer grained control over what gets added to the history list. In such cases, the automatic addition of entered lines to the history list can be turned off by calling the <strong>gl_automatic_history()</strong> function.</p>
<pre>
  int gl_automatic_history(GetLine *gl, int enable);
</pre>
<p>If this function is called with its <strong>enable</strong> argument set to <strong>0</strong>, <strong>gl_get_line()</strong> won't automatically archive subsequently entered lines. Automatic archiving can be reenabled at a later time, by calling this function again, with its <strong>enable</strong> argument set to 1.  While automatic history archiving is disabled, the calling application can use the <strong>gl_append_history()</strong> to append lines to the history list as needed.</p>
<pre>
  int gl_append_history(GetLine *gl, const char *line);
</pre>
<p>The <strong>line</strong> argument specifies the line to be added to the history list. This must be a normal <strong>'&nbsp;'</strong> terminated string. If this string contains any newline characters, the line that gets archived in the history list will be terminated by the first of these. Otherwise it will be terminated by the <strong>'&nbsp;'</strong> terminator.  If the line is longer than the maximum input line length, that was specified when <strong>new_GetLine()</strong> was called, when the line is recalled, it will get truncated to the actual <strong>gl_get_line()</strong> line length.</p><p>If successful, <strong>gl_append_history()</strong> returns 0. Otherwise it returns non-zero, and sets <strong>errno</strong> to one of the following values.</p>
<pre>
   EINVAL  -  One of the arguments passed to
              gl_append_history() was NULL.
   ENOMEM  -  The specified line was longer than the allocated
              size of the history buffer (as specified when
              new_GetLine() was called), so it couldn't be
              archived.
</pre>
<p>A textual description of the error can optionally be obtained by calling <strong>gl_error_message()</strong>. Note that after such an error, the history list remains in a valid state to receive new history lines, so there is little harm in simply ignoring the return status of <strong>gl_append_history()</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MISCELLANEOUS HISTORY CONFIGURATION</h2>
        <div class="sectioncontent">
<p>If you wish to change the size of the history buffer that was originally specified in the call to <strong>new_GetLine()</strong>, you can do so with the <strong>gl_resize_history()</strong> function.</p>
<pre>
  int gl_resize_history(GetLine *gl, size_t histlen);
</pre>
<p>The <strong>histlen</strong> argument specifies the new size in bytes, and if you specify this as 0, the buffer will be deleted.</p><p>As mentioned in the discussion of <strong>new_GetLine()</strong>, the number of lines that can be stored in the history buffer, depends on the lengths of the individual lines. For example, a 1000 byte buffer could equally store 10 lines of average length 100 bytes, or 2 lines of average length 50 bytes. Although the buffer is never expanded when new lines are added, a list of pointers into the buffer does get expanded when needed to accomodate the number of lines currently stored in the buffer. To place an upper limit on the number of lines in the buffer, and thus a ceiling on the amount of memory used in this list, you can call the <strong>gl_limit_history()</strong> function.</p>
<pre>
  void gl_limit_history(GetLine *gl, int max_lines);
</pre>
<p>The <strong>max_lines</strong> should either be a positive number <strong>&gt;= 0</strong>, specifying an upper limit on the number of lines in the buffer, or be <strong>-1</strong> to cancel any previously specified limit. When a limit is in effect, only the <strong>max_lines</strong> most recently appended lines are kept in the buffer. Older lines are discarded.</p><p>To discard lines from the history buffer, use the <strong>gl_clear_history()</strong> function.</p>
<pre>
  void gl_clear_history(GetLine *gl, int all_groups);
</pre>
<p>The <strong>all_groups</strong> argument tells the function whether to delete just the lines associated with the current history group (see <strong>gl_group_history()</strong>), or all historical lines in the buffer.</p><p>The <strong>gl_toggle_history()</strong> function allows you to toggle history on and off without losing the current contents of the history list.</p>
<pre>
  void gl_toggle_history(GetLine *gl, int enable);
</pre>
<p>Setting the <strong>enable</strong> argument to 0 turns off the history mechanism, and setting it to 1 turns it back on. When history is turned off, no new lines will be added to the history list, and history lookup key-bindings will act as though there is nothing in the history buffer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUERYING HISTORY INFORMATION</h2>
        <div class="sectioncontent">
<p>The configured state of the history list can be queried with the <strong>gl_history_state()</strong> function.</p>
<pre>
  typedef struct {
    int enabled;     /* True if history is enabled */
    unsigned group;  /* The current history group */
    int max_lines;   /* The current upper limit on the */
                     /*  number of lines in the history */
                     /*  list, or -1 if unlimited. */
  } GlHistoryState;

  void gl_state_of_history(GetLine *gl,
                           GlHistoryState *state);
</pre>
<p>On return, the status information is recorded in the variable pointed to by the <strong>state</strong> argument.</p><p>The <strong>gl_range_of_history()</strong> function returns the number and range of lines in the history list.</p>
<pre>
typedef struct {
  unsigned long oldest;  /* The sequential entry number */
                         /*  of the oldest line in the */
                         /*  history list. */
  unsigned long newest;  /* The sequential entry number */
                         /*  of the newest line in the */
                         /*  history list. */
  int nlines;            /* The number of lines in the */
                         /*  history list. */
} GlHistoryRange;

void gl_range_of_history(GetLine *gl, GlHistoryRange *range);
</pre>
<p>The return values are recorded in the variable pointed to by the <strong>range</strong> argument. If the <strong>nlines</strong> member of this structure is greater than zero, then the <strong>oldest</strong> and <strong>newest</strong> members report the range of lines in the list, and <strong>newest=oldest+nlines-1</strong>. Otherwise they are both zero.</p><p>The <strong>gl_size_of_history()</strong> function returns the total size of the history buffer and the amount of the buffer that is currently occupied.</p>
<pre>
  typedef struct {
    size_t size;      /* The size of the history buffer */
                      /*  (bytes). */
    size_t used;      /* The number of bytes of the */
                      /*  history buffer that are */
                      /*  currently occupied. */
  } GlHistorySize;

  void gl_size_of_history(GetLine *gl, GlHistorySize *size);
</pre>
<p>On return, the size information is recorded in the variable pointed to by the <strong>size</strong> argument.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHANGING TERMINALS</h2>
        <div class="sectioncontent">
<p>The <strong>new_GetLine()</strong> constructor function assumes that input is to be read from <strong>stdin</strong>, and output written to <strong>stdout</strong>. The following function allows you to switch to different input and output streams.</p>
<pre>
  int gl_change_terminal(GetLine *gl, FILE *input_fp,
                         FILE *output_fp, const char *term);
</pre>
<p>The <strong>gl</strong> argument is the object that was returned by <strong>new_GetLine()</strong>.  The <strong>input_fp</strong> argument specifies the stream to read from, and <strong>output_fp</strong> specifies the stream to be written to. Only if both of these refer to a terminal, will interactive terminal input be enabled.  Otherwise <strong>gl_get_line()</strong> will simply call <strong>fgets()</strong> to read command input. If both streams refer to a terminal, then they must refer to the same terminal, and the type of this terminal must be specified via the <strong>term</strong> argument. The value of the <strong>term</strong> argument is looked up in the terminal information database (terminfo or termcap), in order to determine which special control sequences are needed to control various aspects of the terminal. <strong>new_GetLine()</strong> for example, passes the return value of <strong>getenv("TERM")</strong> in this argument. Note that if one or both of <strong>input_fp</strong> and <strong>output_fp</strong> don't refer to a terminal, then it is legal to pass <strong>NULL</strong> instead of a terminal type.</p><p>Note that if you want to pass file descriptors to <strong>gl_change_terminal()</strong>, you can do this by creating stdio stream wrappers using the POSIX <strong>fdopen()</strong> function.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTERNAL EVENT HANDLING</h2>
        <div class="sectioncontent">
<p>By default, <strong>gl_get_line()</strong> doesn't return until either a complete input line has been entered by the user, or an error occurs. In programs that need to watch for I/O from other sources than the terminal, there are two options.</p>
<pre>
  1. Use the functions described in the
     <a href="../man3/gl_io_mode.3.html"><strong>gl_io_mode</strong>(3)</a></strong> man page to switch
     <strong>gl_get_line()</strong> into non-blocking server mode. In this mode,
     <strong>gl_get_line()</strong> becomes a non-blocking, incremental
     line-editing function that can safely be called from
     an external event loop. Although this is a very
     versatile method, it involves taking on some
     responsibilities that are normally performed behind
     the scenes by <strong>gl_get_line()</strong>.

  2. While <strong>gl_get_line()</strong> is waiting for keyboard
     input from the user, you can ask it to also watch for
     activity on arbitrary file descriptors, such as
     network sockets, pipes etc, and have it call functions
     of your choosing when activity is seen. This works on
     any system that has the <strong>select()</strong> system call,
     which is most, if not all flavors of unix.
</pre>
<p>Registering a file descriptor to be watched by <strong>gl_get_line()</strong> involves calling the <strong>gl_watch_fd()</strong> function.</p>
<pre>
  int gl_watch_fd(GetLine *gl, int fd, GlFdEvent event,
                  GlFdEventFn *callback, void *data);
</pre>
<p>If this returns non-zero, then it means that either your arguments are invalid, or that this facility isn't supported on the host system.</p><p>The <strong>fd</strong> argument is the file descriptor to be watched. The <strong>event</strong> argument specifies what type of activity is of interest, chosen from the following enumerated values:</p>
<pre>
  GLFD_READ   -  Watch for the arrival of data to be read.
  GLFD_WRITE  -  Watch for the ability to write to the file
                 descriptor without blocking.
  GLFD_URGENT -  Watch for the arrival of urgent
                 out-of-band data on the file descriptor.
</pre>
<p>The <strong>callback</strong> argument is the function to call when the selected activity is seen. It should be defined with the following macro, which is defined in libtecla.h.</p>
<pre>
  #define GL_FD_EVENT_FN(fn) GlFdStatus (fn)(GetLine *gl, &#92;
                                      void *data, int fd, &#92;
                                      GlFdEvent event)
</pre>
<p>The <strong>data</strong> argument of the <strong>gl_watch_fd()</strong> function is passed to the callback function for its own use, and can point to anything you like, including <strong>NULL</strong>. The file descriptor and the event argument are also passed to the callback function, and this potentially allows the same callback function to be registered to more than one type of event and/or more than one file descriptor. The return value of the callback function should be one of the following values.</p>
<pre>
  GLFD_ABORT    -  Tell gl_get_line() to abort. When this
                   happens, <strong>gl_get_line()</strong> returns
                   <strong>NULL</strong>, and a following call to
                   <strong>gl_return_status()</strong> will return
                   <strong>GLR_FDABORT</strong>. Note that if the
                   application needs <strong>errno</strong> always to
                   have a meaningful value when
                   <strong>gl_get_line()</strong> returns <strong>NULL</strong>,
                   the callback function should set
                   <strong>errno</strong> appropriately.
  GLFD_REFRESH  -  Redraw the input line then continue
                   waiting for input. Return this if
                   your callback wrote to the terminal.
  GLFD_CONTINUE -  Continue to wait for input, without
                   redrawing the line.
</pre>
<p>Note that before calling the callback, <strong>gl_get_line()</strong> blocks most signals, and leaves its own signal handlers installed, so if you need to catch a particular signal you will need to both temporarily install your own signal handler, and unblock the signal. Be sure to re-block the signal (if it was originally blocked) and reinstate the original signal handler, if any, before returning.</p><p>If the callback function needs to read or write to the terminal, it should ideally first call <strong>gl_normal_io(gl)</strong> to temporarily suspend line editing. This will restore the terminal to canonical, blocking-I/O, mode, and move the cursor to the start of a new terminal line. Later, when the callback returns, <strong>gl_get_line()</strong> will notice that <strong>gl_normal_io()</strong> was called, redisplay the input line and resume editing. Note that in this case the return values, <strong>GLFD_REFRESH</strong> and <strong>GLFD_CONTINUE</strong> are equivalent.</p><p>To support cases where the callback function calls a third-party function which occasionally and unpredictably writes to the terminal, the automatic conversion of <strong>"\n"</strong> to <strong>"\r\n"</strong> is re-enabled before the callback function is called. If the callack knows that the third-party function wrote to the terminal, it should then return the <strong>GLFD_REFRESH</strong> return value, to tell <strong>gl_get_line()</strong> to redisplay the input line.</p><p>To remove a callback function that you previously registered for a given file descriptor and event, simply call <strong>gl_watch_fd()</strong> with the same file descriptor and <strong>event</strong> arguments, but with a <strong>callback</strong> argument of <strong>0</strong>. The <strong>data</strong> argument is ignored in this case.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SETTING AN INACTIVITY TIMEOUT</h2>
        <div class="sectioncontent">
<p>On systems with the <strong>select()</strong> system call, the <strong>gl_inactivity_timeout()</strong> function can be used to set or cancel an inactivity timeout. Inactivity in this case refers both to keyboard input, and to I/O on any file descriptors registered by prior and subsequent calls to <strong>gl_watch_fd()</strong>. On oddball systems that don't have <strong>select()</strong>, this call has no effect.</p>
<pre>
  int gl_inactivity_timeout(GetLine *gl, GlTimeoutFn *callback,
                     void *data, unsigned long sec,
                     unsigned long nsec);
</pre>
<p>The timeout is specified in the form of an integral number of seconds and an integral number of nanoseconds, via the <strong>sec</strong> and <strong>nsec</strong> arguments respectively. Subsequently, whenever no activity is seen for this time period, the function specified via the <strong>callback</strong> argument is called. The <strong>data</strong> argument of <strong>gl_inactivity_timeout()</strong> is passed verbatim to this callback function whenever it is invoked, and can thus be used to pass arbitrary application-specific information to the callback. The following macro is provided in <strong>libtecla.h</strong> for applications to use to declare and prototype timeout callback functions.</p>
<pre>
  #define GL_TIMEOUT_FN(fn) &#92;
               GlAfterTimeout (fn)(GetLine *gl, void *data)
</pre>
<p>On returning, the application's callback is expected to return one of the following enumerators to tell <strong>gl_get_line()</strong> how to procede after the timeout has been handled by the callback.</p>
<pre>
  GLTO_ABORT    -  Tell gl_get_line() to abort. When
                   this happens, <strong>gl_get_line()</strong> will
                   return <strong>NULL</strong>, and a following call
                   to <strong>gl_return_status()</strong> will return
                   <strong>GLR_TIMEOUT</strong>. Note that if the
                   application needs <strong>errno</strong> always to
                   have a meaningful value when
                   <strong>gl_get_line()</strong> returns <strong>NULL</strong>,
                   the callback function should set
                   <strong>errno</strong> appropriately.
  GLTO_REFRESH  -  Redraw the input line, then continue
                   waiting for input. You should return
                   this value if your callback wrote to the
                   terminal without having first called
                   <strong>gl_normal_io(gl)</strong>.
  GLTO_CONTINUE -  In normal blocking-I/O mode, continue to
                   wait for input, without redrawing the
                   user's input line.
                   In non-blocking server I/O mode (see
                   <a href="../man3/gl_io_mode.3.html"><strong>gl_io_mode</strong>(3)</a>), cause <strong>gl_get_line()</strong>
                   to act as though I/O blocked. This means
                   that <strong>gl_get_line()</strong> will immediately
                   return <strong>NULL</strong>, and a following call
                   to <strong>gl_return_status()</strong> will return
                   <strong>GLR_BLOCKED</strong>.
</pre>
<p>Note that before calling the callback, <strong>gl_get_line()</strong> blocks most signals, and leaves its own signal handlers installed, so if you need to catch a particular signal you will need to both temporarily install your own signal handler, and unblock the signal. Be sure to re-block the signal (if it was originally blocked) and reinstate the original signal handler, if any, before returning.</p><p>If the callback function needs to read or write to the terminal, it should ideally first call <strong>gl_normal_io(gl)</strong> to temporarily suspend line editing. This will restore the terminal to canonical, blocking-I/O, mode, and move the cursor to the start of a new terminal line. Later, when the callback returns, <strong>gl_get_line()</strong> will notice that <strong>gl_normal_io()</strong> was called, redisplay the input line and resume editing. Note that in this case the return values, <strong>GLTO_REFRESH</strong> and <strong>GLTO_CONTINUE</strong> are equivalent.</p><p>To support cases where the callback function calls a third-party function which occasionally and unpredictably writes to the terminal, the automatic conversion of <strong>"\n"</strong> to <strong>"\r\n"</strong> is re-enabled before the callback function is called. If the callack knows that the third-party function wrote to the terminal, it should then return the <strong>GLTO_REFRESH</strong> return value, to tell <strong>gl_get_line()</strong> to redisplay the input line.</p><p>Note that although the timeout argument includes a nano-second component, few computer clocks presently have resolutions that are finer than a few milliseconds, so asking for less than a few milliseconds is equivalent to requesting zero seconds on a lot of systems. If this would be a problem, you should base your timeout selection on the actual resolution of the host clock (eg. by calling <strong>sysconf(_SC_CLK_TCK)</strong>).</p><p>To turn off timeouts, simply call <strong>gl_inactivity_timeout()</strong> with a <strong>callback</strong> argument of <strong>0</strong>. The <strong>data</strong> argument is ignored in this case.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNAL HANDLING DEFAULTS</h2>
        <div class="sectioncontent">
<p>By default, the <strong>gl_get_line()</strong> function intercepts a number of signals. This is particularly important for signals which would by default terminate the process, since the terminal needs to be restored to a usable state before this happens. In this section, the signals that are trapped by default, and how <strong>gl_get_line()</strong> responds to them, is described. Changing these defaults is the topic of the following section.</p><p>When the following subset of signals are caught, <strong>gl_get_line()</strong> first restores the terminal settings and signal handling to how they were before <strong>gl_get_line()</strong> was called, resends the signal, to allow the calling application's signal handlers to handle it, then if the process still exists, <strong>gl_get_line()</strong> returns <strong>NULL</strong> and sets <strong>errno</strong> as specified below.</p>
<pre>
 SIGINT  -  This signal is generated both by the keyboard
            interrupt key (usually ^C), and the keyboard
            break key.

            errno=EINTR

 SIGHUP  -  This signal is generated when the controlling
            terminal exits.

            errno=ENOTTY

 SIGPIPE -  This signal is generated when a program attempts
            to write to a pipe who's remote end isn't being
            read by any process. This can happen for example
            if you have called <strong>gl_change_terminal()</strong> to
            redirect output to a pipe hidden under a pseudo
            terminal.

            errno=EPIPE

 SIGQUIT -  This signal is generated by the keyboard quit
            key (usually ^&#92;).

            errno=EINTR

 SIGABRT -  This signal is generated by the standard C,
            abort() function. By default it both
            terminates the process and generates a core
            dump.

            errno=EINTR

 SIGTERM -  This is the default signal that the UN*X
            kill command sends to processes.

            errno=EINTR
</pre>
<p>Note that in the case of all of the above signals, POSIX mandates that by default the process is terminated, with the addition of a core dump in the case of the <strong>SIGQUIT</strong> signal. In other words, if the calling application doesn't override the default handler by supplying its own signal handler, receipt of the corresponding signal will terminate the application before <strong>gl_get_line()</strong> returns.</p><p>If gl_get_line() aborts with errno set to EINTR, you can find out what signal caused it to abort, by calling the following function.</p>
<pre>
  int gl_last_signal(const GetLine *gl);
</pre>
<p>This returns the numeric code (eg. <strong>SIGINT</strong>) of the last signal that was received during the most recent call to <strong>gl_get_line()</strong>, or <strong>-1</strong> if no signals were received.</p><p>On systems that support it, when a SIGWINCH (window change) signal is received, <strong>gl_get_line()</strong> queries the terminal to find out its new size, redraws the current input line to accomodate the new size, then returns to waiting for keyboard input from the user. Unlike other signals, this signal isn't resent to the application.</p><p>Finally, the following signals cause <strong>gl_get_line()</strong> to first restore the terminal and signal environment to that which prevailed before <strong>gl_get_line()</strong> was called, then resend the signal to the application. If the process still exists after the signal has been delivered, then <strong>gl_get_line()</strong> then re-establishes its own signal handlers, switches the terminal back to raw mode, redisplays the input line, and goes back to awaiting terminal input from the user.</p>
<pre>
 SIGCONT    -  This signal is generated when a suspended
               process is resumed.

 SIGPOLL    -  On SVR4 systems, this signal notifies the
               process of an asynchronous I/O event. Note
               that under 4.3+BSD, SIGIO and SIGPOLL are
               the same. On other systems, SIGIO is ignored
               by default, so <strong>gl_get_line()</strong> doesn't
               trap it by default.

 SIGPWR     -  This signal is generated when a power failure
               occurs (presumably when the system is on a
               UPS).

 SIGALRM    -  This signal is generated when a timer
               expires.

 SIGUSR1    -  An application specific signal.

 SIGUSR2    -  Another application specific signal.

 SIGVTALRM  -  This signal is generated when a virtual
               timer expires (see man <a href="../man2/setitimer.2.html"><strong>setitimer</strong>(2)</a>).

 SIGXCPU    -  This signal is generated when a process
               exceeds its soft CPU time limit.

 SIGXFSZ    -  This signal is generated when a process
               exceeds its soft file-size limit.

 SIGTSTP    -  This signal is generated by the terminal
               suspend key, which is usually ^Z, or the
               delayed terminal suspend key, which is
               usually ^Y.

 SIGTTIN    -  This signal is generated if the program
               attempts to read from the terminal while the
               program is running in the background.

 SIGTTOU    -  This signal is generated if the program
               attempts to write to the terminal while the
               program is running in the background.
</pre>
<p>Obviously not all of the above signals are supported on all systems, so code to support them is conditionally compiled into the tecla library.</p><p>Note that if <strong>SIGKILL</strong> or <strong>SIGPOLL</strong>, which by definition can't be caught, or any of the hardware generated exception signals, such as <strong>SIGSEGV</strong>, <strong>SIGBUS</strong> and <strong>SIGFPE</strong>, are received and unhandled while <strong>gl_get_line()</strong> has the terminal in raw mode, the program will be terminated without the terminal having been restored to a usable state. In practice, job-control shells usually reset the terminal settings when a process relinquishes the controlling terminal, so this is only a problem with older shells.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CUSTOMIZED SIGNAL HANDLING</h2>
        <div class="sectioncontent">
<p>The previous section listed the signals that <strong>gl_get_line()</strong> traps by default, and described how it responds to them. This section describes how to both add and remove signals from the list of trapped signals, and how to specify how <strong>gl_get_line()</strong> should respond to a given signal.</p><p>If you don't need <strong>gl_get_line()</strong> to do anything in response to a signal that it normally traps, you can tell to <strong>gl_get_line()</strong> to ignore that signal by calling <strong>gl_ignore_signal()</strong>.</p>
<pre>
  int gl_ignore_signal(GetLine *gl, int signo);
</pre>
<p>The <strong>signo</strong> argument is the number of the signal (eg. <strong>SIGINT</strong>) that you want to have ignored. If the specified signal isn't currently one of those being trapped, this function does nothing.</p><p>The <strong>gl_trap_signal()</strong> function allows you to either add a new signal to the list that <strong>gl_get_line()</strong> traps, or modify how it responds to a signal that it already traps.</p>
<pre>
  int gl_trap_signal(GetLine *gl, int signo, unsigned flags,
                     GlAfterSignal after, int errno_value);
</pre>
<p>The <strong>signo</strong> argument is the number of the signal that you wish to have trapped. The <strong>flags</strong> argument is a set of flags which determine the environment in which the application's signal handler is invoked, the <strong>after</strong> argument tells <strong>gl_get_line()</strong> what to do after the application's signal handler returns, and <strong>errno_value</strong> tells <strong>gl_get_line()</strong> what to set <strong>errno</strong> to if told to abort.</p><p>The <strong>flags</strong> argument is a bitwise OR of zero or more of the following enumerators:</p>
<pre>
  GLS_RESTORE_SIG  -  Restore the caller's signal
                      environment while handling the
                      signal.

  GLS_RESTORE_TTY  -  Restore the caller's terminal settings
                      while handling the signal.

  GLS_RESTORE_LINE -  Move the cursor to the start of the
                      line following the input line before
                      invoking the application's signal
                      handler.

  GLS_REDRAW_LINE  -  Redraw the input line when the
                      application's signal handler returns.

  GLS_UNBLOCK_SIG  -  Normally, if the calling program has
                      a signal blocked (man sigprocmask),
                      gl_get_line() does not trap that
                      signal. This flag tells gl_get_line()
                      to trap the signal and unblock it for
                      the duration of the call to
                      gl_get_line().

  GLS_DONT_FORWARD -  If this flag is included, the signal
                      will not be forwarded to the signal
                      handler of the calling program.
</pre>
<p>Two commonly useful flag combinations are also enumerated as follows:</p>
<pre>
  GLS_RESTORE_ENV   = GLS_RESTORE_SIG | GLS_RESTORE_TTY |
                      GLS_REDRAW_LINE

  GLS_SUSPEND_INPUT = GLS_RESTORE_ENV | GLS_RESTORE_LINE
</pre>
<p>If your signal handler, or the default system signal handler for this signal, if you haven't overridden it, never either writes to the terminal, nor suspends or terminates the calling program, then you can safely set the <strong>flags</strong> argument to <strong>0</strong>.</p><p>If your signal handler always writes to the terminal, reads from it, or suspends or terminates the program, you should specify the <strong>flags</strong> argument as <strong>GL_SUSPEND_INPUT</strong>, so that:</p>
<pre>
1. The cursor doesn't get left in the middle of the input
   line.
2. So that the user can type in input and have it echoed.
3. So that you don't need to end each output line with
   <strong>&#92;r&#92;n</strong>, instead of just <strong>&#92;n</strong>.
</pre>
<p>The <strong>GL_RESTORE_ENV</strong> combination is the same as <strong>GL_SUSPEND_INPUT</strong>, except that it doesn't move the cursor, and if your signal handler doesn't read or write anything to the terminal, the user won't see any visible indication that a signal was caught. This can be useful if you have a signal handler that only occasionally writes to the terminal, where using <strong>GL_SUSPEND_LINE</strong> would cause the input line to be unnecessarily duplicated when nothing had been written to the terminal.  Such a signal handler, when it does write to the terminal, should be sure to start a new line at the start of its first write, by writing a <strong>&#92;n</strong> character, and should be sure to leave the cursor on a new line before returning. If the signal arrives while the user is entering a line that only occupies a signal terminal line, or if the cursor is on the last terminal line of a longer input line, this will have the same effect as <strong>GL_SUSPEND_INPUT</strong>. Otherwise it will start writing on a line that already contains part of the displayed input line. This doesn't do any harm, but it looks a bit ugly, which is why the <strong>GL_SUSPEND_INPUT</strong> combination is better if you know that you are always going to be writting to the terminal.</p><p>The <strong>after</strong> argument, which determines what <strong>gl_get_line()</strong> does after the application's signal handler returns (if it returns), can take any one of the following values:</p>
<pre>
  GLS_RETURN   - Return the completed input line, just as
                 though the user had pressed the return
                 key.

  GLS_ABORT    - Cause <strong>gl_get_line()</strong> to abort. When
                 this happens, <strong>gl_get_line()</strong> returns
                 <strong>NULL</strong>, and a following call to
                 <strong>gl_return_status()</strong> will return
                 <strong>GLR_SIGNAL</strong>. Note that if the
                 application needs <strong>errno</strong> always to
                 have a meaningful value when
                 <strong>gl_get_line()</strong> returns <strong>NULL</strong>,
                 the callback function should set
                 <strong>errno</strong> appropriately.
  GLS_CONTINUE - Resume command line editing.
</pre>
<p>The <strong>errno_value</strong> argument is intended to be combined with the <strong>GLS_ABORT</strong> option, telling <strong>gl_get_line()</strong> what to set the standard <strong>errno</strong> variable to before returning <strong>NULL</strong> to the calling program. It can also, however, be used with the <strong>GL_RETURN</strong> option, in case you wish to have a way to distinguish between an input line that was entered using the return key, and one that was entered by the receipt of a signal.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELIABLE SIGNAL HANDLING</h2>
        <div class="sectioncontent">
<p>Signal handling is suprisingly hard to do reliably without race conditions. In <strong>gl_get_line()</strong> a lot of care has been taken to allow applications to perform reliable signal handling around <strong>gl_get_line()</strong>. This section explains how to make use of this.</p><p>As an example of the problems that can arise if the application isn't written correctly, imagine that one's application has a SIGINT signal handler that sets a global flag. Now suppose that the application tests this flag just before invoking <strong>gl_get_line()</strong>. If a SIGINT signal happens to be received in the small window of time between the statement that tests the value of this flag, and the statement that calls <strong>gl_get_line()</strong>, then <strong>gl_get_line()</strong> will not see the signal, and will not be interrupted. As a result, the application won't be able to respond to the signal until the user gets around to finishing entering the input line and <strong>gl_get_line()</strong> returns. Depending on the application, this might or might not be a disaster, but at the very least it would puzzle the user.</p><p>The way to avoid such problems is to do the following.</p><p>1. If needed, use the <strong>gl_trap_signal()</strong> function to</p>
<pre>
   configure <strong>gl_get_line()</strong> to abort when important
   signals are caught.
</pre>
<p>2. Configure <strong>gl_get_line()</strong> such that if any of the</p>
<pre>
   signals that it catches are blocked when
   <strong>gl_get_line()</strong> is called, they will be unblocked
   automatically during times when <strong>gl_get_line()</strong> is
   waiting for I/O. This can be done either
   on a per signal basis, by calling the
   <strong>gl_trap_signal()</strong> function, and specifying the
   <strong>GLS_UNBLOCK</strong> attribute of the signal, or globally by
   calling the <strong>gl_catch_blocked()</strong> function.
</pre>

<pre>
     void gl_catch_blocked(GetLine *gl);
</pre>

<pre>
   This function simply adds the <strong>GLS_UNBLOCK</strong> attribute
   to all of the signals that it is currently configured to
   trap.
</pre>
<p>3. Just before calling <strong>gl_get_line()</strong>, block delivery</p>
<pre>
   of all of the signals that <strong>gl_get_line()</strong> is
   configured to trap. This can be done using the POSIX
   <strong>sigprocmask()</strong> function in conjunction with the
   <strong>gl_list_signals()</strong> function.
</pre>

<pre>
      int gl_list_signals(GetLine *gl, sigset_t *set);
</pre>

<pre>
   This function returns the set of signals that it is
   currently configured to catch in the <strong>set</strong> argument,
   which is in the form required by <strong>sigprocmask()</strong>.
</pre>
<p>4. In the example, one would now test the global flag that</p>
<pre>
   the signal handler sets, knowing that there is now no
   danger of this flag being set again until
   <strong>gl_get_line()</strong> unblocks its signals while performing
   I/O.
</pre>
<p>5. Eventually <strong>gl_get_line()</strong> returns, either because</p>
<pre>
   a signal was caught, an error occurred, or the user
   finished entering their input line.
</pre>
<p>6. Now one would check the global signal flag again, and if</p>
<pre>
   it is set, respond to it, and zero the flag.
</pre>
<p>7. Use <strong>sigprocmask()</strong> to unblock the signals that were</p>
<pre>
   blocked in step 3.
</pre>
<p>The same technique can be used around certain POSIX signal-aware functions, such as <strong>sigsetjmp()</strong> and <strong>sigsuspend()</strong>, and in particular, the former of these two functions can be used in conjunction with <strong>siglongjmp()</strong> to implement race-condition free signal handling around other long-running system calls. The way to do this, is explained next, by showing how <strong>gl_get_line()</strong> manages to reliably trap signals around calls to functions like <strong>read()</strong> and <strong>select()</strong> without race conditions.</p><p>The first thing that <strong>gl_get_line()</strong> does, whenever it is called, is to use the POSIX <strong>sigprocmask()</strong> function to block the delivery of all of the signals that it is currently configured to catch. This is redundant if the application has already blocked them, but it does no harm. It undoes this step just before returning.</p><p>Whenever <strong>gl_get_line()</strong> needs to call <strong>read()</strong> or <strong>select()</strong> to wait for input from the user, it first calls the POSIX <strong>sigsetjmp()</strong> function, being sure to specify a non-zero value for its <strong>savesigs</strong> argument. The reason for the latter argument will become clear shortly.</p><p>If <strong>sigsetjmp()</strong> returns zero, <strong>gl_get_line()</strong> then does the following.</p>
<pre>
a. It uses the POSIX <strong>sigaction()</strong> function to register
   a temporary signal handler to all of the signals that it
   is configured to catch. This signal handler does two
   things.

   1. It records the number of the signal that was received
      in a file-scope variable.

   2. It then calls the POSIX <strong>siglongjmp()</strong>
      function using the buffer that was passed to
      <strong>sigsetjmp()</strong> for its first argument, and
      a non-zero value for its second argument.

   When this signal handler is registered, the <strong>sa_mask</strong>
   member of the <strong>struct sigaction act</strong> argument of the
   call to <strong>sigaction()</strong> is configured to contain all of
   the signals that <strong>gl_get_line()</strong> is catching. This
   ensures that only one signal will be caught at once by
   our signal handler, which in turn ensures that multiple
   instances of our signal handler don't tread on each
   other's toes.

b. Now that the signal handler has been set up,
   <strong>gl_get_line()</strong> unblocks all of the signals that it
   is configured to catch.

c. It then calls the <strong>read()</strong> or <strong>select()</strong> system
   calls to wait for keyboard input.

d. If this system call returns (ie. no signal is received),
   <strong>gl_get_line()</strong> blocks delivery of the signals of
   interest again.

e. It then reinstates the signal handlers that were
   displaced by the one that was just installed.
</pre>
<p>Alternatively, if <strong>sigsetjmp()</strong> returns non-zero, this means that one of the signals being trapped was caught while the above steps were executing. When this happens, <strong>gl_get_line()</strong> does the following.</p><p>First, note that when a call to <strong>siglongjmp()</strong> causes <strong>sigsetjmp()</strong> to return, provided that the <strong>savesigs</strong> argument of <strong>sigsetjmp()</strong> was non-zero, as specified above, the signal process mask is restored to how it was when <strong>sigsetjmp()</strong> was called. This is the important difference between <strong>sigsetjmp()</strong> and the older problematic <strong>setjmp()</strong>, and is the essential ingredient that makes it possible to avoid signal handling race conditions.  Because of this we are guaranteed that all of the signals that we blocked before calling <strong>sigsetjmp()</strong> are blocked again as soon as any signal is caught. The following statements, which are then executed, are thus guaranteed to be executed without any further signals being caught.</p><p>1. If so instructed by the <strong>gl_get_line()</strong> configuration</p>
<pre>
   attributes of the signal that was caught,
   <strong>gl_get_line()</strong> restores the terminal attributes to
   the state that they had when <strong>gl_get_line()</strong> was
   called. This is particularly important for signals that
   suspend or terminate the process, since otherwise the
   terminal would be left in an unusable state.
</pre>
<p>2. It then reinstates the application's signal handlers.</p><p>3. Then it uses the C standard-library <strong>raise()</strong></p>
<pre>
   function to re-send the application the signal that
   was caught.
</pre>
<p>3. Next it unblocks delivery of the signal that we just</p>
<pre>
   sent. This results in the signal that was just sent
   via <strong>raise()</strong>, being caught by the application's
   original signal handler, which can now handle it as it
   sees fit.
</pre>
<p>4. If the signal handler returns (ie. it doesn't terminate</p>
<pre>
   the process), <strong>gl_get_line()</strong> blocks delivery of the
   above signal again.
</pre>
<p>5. It then undoes any actions performed in the first of the</p>
<pre>
   above steps, and redisplays the line, if the signal
   configuration calls for this.
</pre>
<p>6. <strong>gl_get_line()</strong> then either resumes trying to</p>
<pre>
   read a character, or aborts, depending on the
   configuration of the signal that was caught.
</pre>
<p>What the above steps do in essence is to take asynchronously delivered signals and handle them synchronously, one at a time, at a point in the code where <strong>gl_get_line()</strong> has complete control over its environment.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE TERMINAL SIZE</h2>
        <div class="sectioncontent">
<p>On most systems the combination of the <strong>TIOCGWINSZ</strong> ioctl and the <strong>SIGWINCH</strong> signal is used to maintain an accurate idea of the terminal size. The terminal size is newly queried every time that <strong>gl_get_line()</strong> is called and whenever a <strong>SIGWINCH</strong> signal is received.</p><p>On the few systems where this mechanism isn't available, at startup <strong>new_GetLine()</strong> first looks for the <strong>LINES</strong> and <strong>COLUMNS</strong> environment variables.  If these aren't found, or they contain unusable values, then if a terminal information database like terminfo or termcap is available, the default size of the terminal is looked up in this database. If this too fails to provide the terminal size, a default size of 80 columns by 24 lines is used.</p><p>Even on systems that do support <strong>ioctl(TIOCGWINSZ)</strong>, if the terminal is on the other end of a serial line, the terminal driver generally has no way of detecting when a resize occurs or of querying what the current size is. In such cases no <strong>SIGWINCH</strong> is sent to the process, and the dimensions returned by <strong>ioctl(TIOCGWINSZ)</strong> aren't correct. The only way to handle such instances is to provide a way for the user to enter a command that tells the remote system what the new size is. This command would then call the <strong>gl_set_term_size()</strong> function to tell <strong>gl_get_line()</strong> about the change in size.</p>
<pre>
  int gl_set_term_size(GetLine *gl, int ncolumn, int nline);
</pre>
<p>The <strong>ncolumn</strong> and <strong>nline</strong> arguments are used to specify the new dimensions of the terminal, and must not be less than 1. On systems that do support <strong>ioctl(TIOCGWINSZ)</strong>, this function first calls <strong>ioctl(TIOCSWINSZ)</strong> to tell the terminal driver about the change in size. In non-blocking server-I/O mode, if a line is currently being input, the input line is then redrawn to accomodate the changed size. Finally the new values are recorded in <strong>gl</strong> for future use by <strong>gl_get_line()</strong>.</p><p>The <strong>gl_terminal_size()</strong> function allows you to query the current size of the terminal, and install an alternate fallback size for cases where the size isn't available. Beware that the terminal size won't be available if reading from a pipe or a file, so the default values can be important even on systems that do support ways of finding out the terminal size.</p>
<pre>
  typedef struct {
    int nline;        /* The terminal has nline lines */
    int ncolumn;      /* The terminal has ncolumn columns */
  } GlTerminalSize;

  GlTerminalSize gl_terminal_size(GetLine *gl,
                                  int def_ncolumn,
                                  int def_nline);
</pre>
<p>This function first updates <strong>gl_get_line()</strong>'s fallback terminal dimensions, then records its findings in the return value.</p><p>The <strong>def_ncolumn</strong> and <strong>def_nline</strong> specify the default number of terminal columns and lines to use if the terminal size can't be determined via <strong>ioctl(TIOCGWINSZ)</strong> or environment variables.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HIDING WHAT YOU TYPE</h2>
        <div class="sectioncontent">
<p>When entering sensitive information, such as passwords, it is best not to have the text that you are entering echoed on the terminal. Furthermore, such text should not be recorded in the history list, since somebody finding your terminal unattended could then recall it, or somebody snooping through your directories could see it in your history file. With this in mind, the <strong>gl_echo_mode()</strong> function allows you to toggle on and off the display and archival of any text that is subsequently entered in calls to <strong>gl_get_line()</strong>.</p>
<pre>
  int gl_echo_mode(GetLine *gl, int enable);
</pre>
<p>The <strong>enable</strong> argument specifies whether entered text should be visible or not. If it is <strong>0</strong>, then subsequently entered lines will not be visible on the terminal, and will not be recorded in the history list. If it is <strong>1</strong>, then subsequent input lines will be displayed as they are entered, and provided that history hasn't been turned off via a call to <strong>gl_toggle_history()</strong>, then they will also be archived in the history list. Finally, if the <strong>enable</strong> argument is <strong>-1</strong>, then the echoing mode is left unchanged, which allows you to non-destructively query the current setting via the return value. In all cases, the return value of the function is <strong>0</strong> if echoing was disabled before the function was called, and <strong>1</strong> if it was enabled.</p><p>When echoing is turned off, note that although tab completion will invisibly complete your prefix as far as possible, ambiguous completions will not be displayed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SINGLE CHARACTER QUERIES</h2>
        <div class="sectioncontent">
<p>Using <strong>gl_get_line()</strong> to query the user for a single character reply, is inconvenient for the user, since they must hit the enter or return key before the character that they typed is returned to the program. Thus the <strong>gl_query_char()</strong> function has been provided for single character queries like this.</p>
<pre>
  int gl_query_char(GetLine *gl, const char *prompt,
                    char defchar);
</pre>
<p>This function displays the specified prompt at the start of a new line, and waits for the user to type a character. When the user types a character, <strong>gl_query_char()</strong> displays it to the right of the prompt, starts a newline, then returns the character to the calling program. The return value of the function is the character that was typed. If the read had to be aborted for some reason, <strong>EOF</strong> is returned instead. In the latter case, the application can call the previously documented <strong>gl_return_status()</strong>, to find out what went wrong. This could, for example, have been the reception of a signal, or the optional inactivity timer going off.</p><p>If the user simply hits enter, the value of the <strong>defchar</strong> argument is substituted. This means that when the user hits either newline or return, the character specified in <strong>defchar</strong>, is displayed after the prompt, as though the user had typed it, as well as being returned to the calling application. If such a replacement is not important, simply pass <strong>'\n'</strong> as the value of <strong>defchar</strong>.</p><p>If the entered character is an unprintable character, it is displayed symbolically. For example, control-A is displayed as ^A, and characters beyond 127 are displayed in octal, preceded by a backslash.</p><p>As with <strong>gl_get_line()</strong>, echoing of the entered character can be disabled using the <strong>gl_echo_mode()</strong> function.</p><p>If the calling process is suspended while waiting for the user to type their response, the cursor is moved to the line following the prompt line, then when the process resumes, the prompt is redisplayed, and <strong>gl_query_char()</strong> resumes waiting for the user to type a character.</p><p>Note that in non-blocking server mode, (see <a href="../man3/gl_io_mode.3.html"><strong>gl_io_mode</strong>(3)</a>), if an incomplete input line is in the process of being read when <strong>gl_query_char()</strong> is called, the partial input line is discarded, and erased from the terminal, before the new prompt is displayed. The next call to <strong>gl_get_line()</strong> will thus start editing a new line.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">READING RAW CHARACTERS</h2>
        <div class="sectioncontent">
<p>Whereas the <strong>gl_query_char()</strong> function visibly prompts the user for a character, and displays what they typed, the <strong>gl_read_char()</strong> function reads a signal character from the user, without writing anything to the terminal, or perturbing any incompletely entered input line. This means that it can be called not only from between calls to <strong>gl_get_line()</strong>, but also from callback functions that the application has registered to be called by <strong>gl_get_line()</strong>.</p>
<pre>
  int gl_read_char(GetLine *gl);
</pre>
<p>On success, the return value of <strong>gl_read_char()</strong> is the character that was read. On failure, <strong>EOF</strong> is returned, and the <strong>gl_return_status()</strong> function can be called to find out what went wrong. Possibilities include the optional inactivity timer going off, the receipt of a signal that is configured to abort gl_get_line(), or terminal I/O blocking, when in non-blocking server-I/O mode.</p><p>Beware that certain keyboard keys, such as function keys, and cursor keys, usually generate at least 3 characters each, so a single call to <strong>gl_read_char()</strong> won't be enough to identify such keystrokes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLEARING THE TERMINAL</h2>
        <div class="sectioncontent">
<p>The calling program can clear the terminal by calling <strong>gl_erase_terminal()</strong>. In non-blocking server-I/O mode, this function also arranges for the current input line to be redrawn from scratch when <strong>gl_get_line()</strong> is next called.</p>
<pre>
  int gl_erase_terminal(GetLine *gl);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISPLAYING TEXT DYNAMICALLY</h2>
        <div class="sectioncontent">
<p>Between calls to <strong>gl_get_line()</strong>, the <strong>gl_display_text()</strong> function provides a convenient way to display paragraphs of text, left-justified and split over one or more terminal lines according to the constraints of the current width of the terminal. Examples of the use of this function may be found in the demo programs, where it is used to display introductions. In those examples the advanced use of optional prefixes, suffixes and filled lines to draw a box around the text is also illustrated.</p>
<pre>
  int gl_display_text(GetLine *gl, int indentation,
                      const char *prefix,
                      const char *suffix, int fill_char,
                      int def_width, int start,
                      const char *string);
</pre>
<p>If <strong>gl</strong> isn't currently connected to a terminal, for example if the output of a program that uses <strong>gl_get_line()</strong> is being piped to another program or redirected to a file, then the value of the <strong>def_width</strong> parameter is used as the terminal width.</p><p>The <strong>indentation</strong> argument specifies the number of characters to use to indent each line of ouput. The <strong>fill_char</strong> argument specifies the character that will be used to perform this indentation.</p><p>The <strong>prefix</strong> argument can either be <strong>NULL</strong>, or be a string to place at the beginning of each new line (after any indentation). Similarly, the <strong>suffix</strong> argument can either be <strong>NULL</strong>, or be a string to place at the end of each line. The suffix is placed flush against the right edge of the terminal, and any space between its first character and the last word on that line is filled with the character specified via the <strong>fill_char</strong> argument.  Normally the fill-character is a space.</p><p>The <strong>start</strong> argument tells <strong>gl_display_text()</strong> how many characters have already been written to the current terminal line, and thus tells it the starting column index of the cursor.  Since the return value of <strong>gl_display_text()</strong> is the ending column index of the cursor, by passing the return value of one call to the <strong>start</strong> argument of the next call, a paragraph that is broken between more than one string can be composed by calling <strong>gl_display_text()</strong> for each successive portion of the paragraph. Note that literal newline characters are necessary at the end of each paragraph to force a new line to be started.</p><p>On error, <strong>gl_display_text()</strong> returns -1.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACK FUNCTION FACILITIES</h2>
        <div class="sectioncontent">
<p>Unless otherwise stated, callback functions, such as tab completion callbacks and event callbacks should not call any functions in this module. The following functions, however, are designed specifically to be used by callback functions.</p><p>Calling the <strong>gl_replace_prompt()</strong> function from a callback tells <strong>gl_get_line()</strong> to display a different prompt when the callback returns. Except in non-blocking server mode, it has no effect if used between calls to <strong>gl_get_line()</strong>. In non-blocking server mode (see the <a href="../man3/gl_io_mode.3.html"><strong>gl_io_mode</strong>(3)</a></strong> man page, when used between two calls to <strong>gl_get_line()</strong> that are operating on the same input line, the current input line will be re-drawn with the new prompt on the following call to <strong>gl_get_line()</strong>.</p>
<pre>
  void gl_replace_prompt(GetLine *gl, const char *prompt);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNATIONAL CHARACTER SETS</h2>
        <div class="sectioncontent">
<p>Since libtecla version 1.4.0, <strong>gl_get_line()</strong> has been 8-bit clean. This means that all 8-bit characters that are printable in the user's current locale are now displayed verbatim and included in the returned input line.  Assuming that the calling program correctly contains a call like the following,</p>
<pre>
  setlocale(LC_CTYPE, "");
</pre>
<p>then the current locale is determined by the first of the environment variables <strong>LC_CTYPE</strong>, <strong>LC_ALL</strong>, and <strong>LANG</strong>, that is found to contain a valid locale name. If none of these variables are defined, or the program neglects to call setlocale, then the default <strong>C</strong> locale is used, which is US 7-bit ASCII. On most unix-like platforms, you can get a list of valid locales by typing the command:</p>
<pre>
  locale -a
</pre>
<p>at the shell prompt. Further documentation on how the user can make use of this to enter international characters can be found in the <a href="../man7/tecla.7.html"><strong>tecla</strong>(7)</a></strong> man page.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THREAD SAFETY</h2>
        <div class="sectioncontent">
<p>In a multi-threaded program, you should use the libtecla_r.a version of the library. This uses reentrant versions of system functions, where available. Unfortunately neither terminfo nor termcap were designed to be reentrant, so you can't safely use the functions of the getline module in multiple threads (you can use the separate file-expansion and word-completion modules in multiple threads, see the corresponding man pages for details). However due to the use of POSIX reentrant functions for looking up home directories etc, it is safe to use this module from a single thread of a multi-threaded program, provided that your other threads don't use any termcap or terminfo functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<pre>
libtecla.a      -    The tecla library
libtecla.h      -    The tecla header file.
~/.teclarc      -    The personal tecla customization file.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO gl_register_action&hellip;</h2>
        <div class="sectioncontent">

<pre>
<a href="../man3/libtecla.3.html"><strong>libtecla</strong>(3)</a>, <a href="../man3/gl_io_mode.3.html"><strong>gl_io_mode</strong>(3)</a>, <a href="../man7/tecla.7.html"><strong>tecla</strong>(7)</a>, <a href="../man3/ef_expand_file.3.html"><strong>ef_expand_file</strong>(3)</a>,
<a href="../man3/cpl_complete_word.3.html"><strong>cpl_complete_word</strong>(3)</a>, <a href="../man3/pca_lookup_file.3.html"><strong>pca_lookup_file</strong>(3)</a>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Martin Shepherd  (mcs@astro.caltech.edu)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gl_read_char.3.html"><span aria-hidden="true">&larr;</span> gl_read_char.3: Allow the user to compose an input line</a></li>
   <li class="next"><a href="gl_resize_history.3.html">gl_resize_history.3: Allow the user to compose an input line <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

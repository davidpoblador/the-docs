<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>std::unordered_set: Std::unordered_set _value, _hash, _pred, _alloc  -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Std::unordered_set _value, _hash, _pred, _alloc  -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="std::unordered_set (3cxx) manual">
  <meta name="twitter:description" content="Std::unordered_set _value, _hash, _pred, _alloc  -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libstdc++-4.8-doc-std::unordered_set-3cxx.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3cxx/libstdc++-4.8-doc-std::unordered_set.3cxx.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="std::unordered_set (3cxx) manual" />
  <meta property="og:description" content="Std::unordered_set _value, _hash, _pred, _alloc  -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libstdc++-4.8-doc-std::unordered_set-3cxx.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">std::unordered_set<small> (3cxx)</small></h1>
        <p class="lead">Std::unordered_set _value, _hash, _pred, _alloc  -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::unordered_set.3cxx.html">
      <span itemprop="name">std::unordered_set: Std::unordered_set _value, _hash, _pred, _alloc  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libstdc++-4.8-doc/">
      <span itemprop="name">libstdc++-4.8-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3cxx/std::unordered_set.3cxx.html">
      <span itemprop="name">std::unordered_set: Std::unordered_set _value, _hash, _pred, _alloc  -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<h3>Public Types</h3>
<p><strong></strong></p><p>typedef _Hashtable::key_type <strong>key_type</strong></p><p>typedef _Hashtable::value_type <strong>value_type</strong></p><p>typedef _Hashtable::hasher <strong>hasher</strong></p><p>typedef _Hashtable::key_equal <strong>key_equal</strong></p><p>typedef _Hashtable::allocator_type <strong>allocator_type</strong></p><p><strong></strong></p><p>typedef _Hashtable::pointer <strong>pointer</strong></p><p>typedef _Hashtable::const_pointer <strong>const_pointer</strong></p><p>typedef _Hashtable::reference <strong>reference</strong></p><p>typedef _Hashtable::const_reference <strong>const_reference</strong></p><p>typedef <strong>_Hashtable::iterator</strong> <strong>iterator</strong></p><p>typedef <strong>_Hashtable::const_iterator</strong> <strong>const_iterator</strong></p><p>typedef <strong>_Hashtable::local_iterator</strong> <strong>local_iterator</strong></p><p>typedef</p><p><strong>_Hashtable::const_local_iterator</strong> <strong>const_local_iterator</strong>"</p><p>typedef _Hashtable::size_type <strong>size_type</strong></p><p>typedef _Hashtable::difference_type <strong>difference_type</strong></p>
<h3>Public Member Functions</h3>
<p><strong>unordered_set</strong> (<strong>size_type</strong> __n=10, const <strong>hasher</strong> &__hf=<strong>hasher</strong>(), const <strong>key_equal</strong> &__eql=<strong>key_equal</strong>(), const <strong>allocator_type</strong> &__a=<strong>allocator_type</strong>())</p><p>template&lt;typename _InputIterator &gt; <strong>unordered_set</strong> (_InputIterator __f, _InputIterator __l, <strong>size_type</strong> __n=0, const <strong>hasher</strong> &__hf=<strong>hasher</strong>(), const <strong>key_equal</strong> &__eql=<strong>key_equal</strong>(), const <strong>allocator_type</strong> &__a=<strong>allocator_type</strong>())</p><p><strong>unordered_set</strong> (const <strong>unordered_set</strong> &)=default</p><p><strong>unordered_set</strong> (<strong>unordered_set</strong> &&)=default</p><p><strong>unordered_set</strong> (const <strong>allocator_type</strong> &__a)</p><p><strong>unordered_set</strong> (const <strong>unordered_set</strong> &__uset, const <strong>allocator_type</strong> &__a)</p><p><strong>unordered_set</strong> (<strong>unordered_set</strong> &&__uset, const <strong>allocator_type</strong> &__a)</p><p><strong>unordered_set</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l, <strong>size_type</strong> __n=0, const <strong>hasher</strong> &__hf=<strong>hasher</strong>(), const <strong>key_equal</strong> &__eql=<strong>key_equal</strong>(), const <strong>allocator_type</strong> &__a=<strong>allocator_type</strong>())</p><p><strong>size_type</strong> <strong>bucket</strong> (const <strong>key_type</strong> &__key) const </p><p><strong>size_type</strong> <strong>bucket_count</strong> () const noexcept</p><p><strong>size_type</strong> <strong>bucket_size</strong> (<strong>size_type</strong> __n) const </p><p><strong>const_iterator</strong> <strong>cbegin</strong> () const noexcept</p><p><strong>const_iterator</strong> <strong>cend</strong> () const noexcept</p><p>void <strong>clear</strong> () noexcept</p><p><strong>size_type</strong> <strong>count</strong> (const <strong>key_type</strong> &__x) const </p><p>template&lt;typename... _Args&gt; <strong>std::pair</strong>&lt; <strong>iterator</strong>, bool &gt; <strong>emplace</strong> (_Args &&...__args)</p><p>template&lt;typename... _Args&gt; <strong>iterator</strong> <strong>emplace_hint</strong> (<strong>const_iterator</strong> __pos, _Args &&...__args)</p><p>bool <strong>empty</strong> () const noexcept</p><p><strong>size_type</strong> <strong>erase</strong> (const <strong>key_type</strong> &__x)</p><p><strong>iterator</strong> <strong>erase</strong> (<strong>const_iterator</strong> __first, <strong>const_iterator</strong> __last)</p><p><strong>allocator_type</strong> <strong>get_allocator</strong> () const noexcept</p><p><strong>hasher</strong> <strong>hash_function</strong> () const </p><p>template&lt;typename _InputIterator &gt; void <strong>insert</strong> (_InputIterator __first, _InputIterator __last)</p><p>void <strong>insert</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l)</p><p><strong>key_equal</strong> <strong>key_eq</strong> () const </p><p>float <strong>load_factor</strong> () const noexcept</p><p><strong>size_type</strong> <strong>max_bucket_count</strong> () const noexcept</p><p>float <strong>max_load_factor</strong> () const noexcept</p><p>void <strong>max_load_factor</strong> (float __z)</p><p><strong>size_type</strong> <strong>max_size</strong> () const noexcept</p><p><strong>unordered_set</strong> & <strong>operator=</strong> (const <strong>unordered_set</strong> &)=default</p><p><strong>unordered_set</strong> & <strong>operator=</strong> (<strong>unordered_set</strong> &&)=default</p><p><strong>unordered_set</strong> & <strong>operator=</strong> (initializer_list&lt; <strong>value_type</strong> &gt; __l)</p><p>void <strong>rehash</strong> (<strong>size_type</strong> __n)</p><p>void <strong>reserve</strong> (<strong>size_type</strong> __n)</p><p><strong>size_type</strong> <strong>size</strong> () const noexcept</p><p>void <strong>swap</strong> (<strong>unordered_set</strong> &__x) noexcept(noexcept(_M_h.swap(__x._M_h)))</p><p><strong></strong></p><p><strong>iterator</strong> <strong>begin</strong> () noexcept</p><p><strong>const_iterator</strong> <strong>begin</strong> () const noexcept</p><p><strong></strong></p><p><strong>iterator</strong> <strong>end</strong> () noexcept</p><p><strong>const_iterator</strong> <strong>end</strong> () const noexcept</p><p><strong></strong></p><p><strong>std::pair</strong>&lt; <strong>iterator</strong>, bool &gt; <strong>insert</strong> (const <strong>value_type</strong> &__x)</p><p><strong>std::pair</strong>&lt; <strong>iterator</strong>, bool &gt; <strong>insert</strong> (<strong>value_type</strong> &&__x)</p><p><strong></strong></p><p><strong>iterator</strong> <strong>insert</strong> (<strong>const_iterator</strong> __hint, const <strong>value_type</strong> &__x)</p><p><strong>iterator</strong> <strong>insert</strong> (<strong>const_iterator</strong> __hint, <strong>value_type</strong> &&__x)</p><p><strong></strong></p><p><strong>iterator</strong> <strong>erase</strong> (<strong>const_iterator</strong> __position)</p><p><strong>iterator</strong> <strong>erase</strong> (<strong>iterator</strong> __it)</p><p><strong></strong></p><p><strong>iterator</strong> <strong>find</strong> (const <strong>key_type</strong> &__x)</p><p><strong>const_iterator</strong> <strong>find</strong> (const <strong>key_type</strong> &__x) const </p><p><strong></strong></p><p><strong>std::pair</strong>&lt; <strong>iterator</strong>, <strong>iterator</strong> &gt; <strong>equal_range</strong> (const <strong>key_type</strong> &__x)</p><p><strong>std::pair</strong>&lt; <strong>const_iterator</strong>,</p><p><strong>const_iterator</strong> &gt; <strong>equal_range</strong> (const <strong>key_type</strong> &__x) const "</p><p><strong></strong></p><p><strong>local_iterator</strong> <strong>begin</strong> (<strong>size_type</strong> __n)</p><p><strong>const_local_iterator</strong> <strong>begin</strong> (<strong>size_type</strong> __n) const </p><p><strong>const_local_iterator</strong> <strong>cbegin</strong> (<strong>size_type</strong> __n) const </p><p><strong></strong></p><p><strong>local_iterator</strong> <strong>end</strong> (<strong>size_type</strong> __n)</p><p><strong>const_local_iterator</strong> <strong>end</strong> (<strong>size_type</strong> __n) const </p><p><strong>const_local_iterator</strong> <strong>cend</strong> (<strong>size_type</strong> __n) const </p>
<h3>Friends</h3>
<p>template&lt;typename _Value1 , typename _Hash1 , typename _Pred1 , typename _Alloc1 &gt; bool <strong>operator==</strong> (const <strong>unordered_set</strong>&lt; _Value1, _Hash1, _Pred1, _Alloc1 &gt; &, const <strong>unordered_set</strong>&lt; _Value1, _Hash1, _Pred1, _Alloc1 &gt; &)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<h3>template&lt;class _Value, class _Hash = hash&lt;_Value&gt;, class _Pred = std::equal_to&lt;_Value&gt;, class _Alloc = std::allocator&lt;_Value&gt;&gt;class std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc &gt;</h3>
<p>A standard container composed of unique keys (containing at most one of each key value) in which the elements' keys are the elements themselves.</p><p><strong>Template Parameters:</strong></p><p><em>_Value</em> Type of key objects.</p><p><em>_Hash</em> Hashing function object type, defaults to hash&lt;_Value&gt;.</p><p><em>_Pred</em> Predicate function object type, defaults to equal_to&lt;_Value&gt;.</p><p><em>_Alloc</em> Allocator type, defaults to allocator&lt;_Key&gt;.</p><p>Meets the requirements of a container, and unordered associative container</p><p>Base is _Hashtable, dispatched at compile time via template alias __uset_hashtable.</p><p>Definition at line 93 of file unordered_set.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::allocator_type \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBallocator_type\fP</h3>
<p>Public typedefs.</p><p>Definition at line 106 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef \fB_Hashtable::const_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBconst_iterator\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 116 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef \fB_Hashtable::const_local_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBconst_local_iterator\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 118 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::const_pointer \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBconst_pointer\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 112 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::const_reference \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBconst_reference\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 114 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::difference_type \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBdifference_type\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 120 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::hasher \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBhasher\fP</h3>
<p>Public typedefs.</p><p>Definition at line 104 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef \fB_Hashtable::iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBiterator\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 115 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::key_equal \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBkey_equal\fP</h3>
<p>Public typedefs.</p><p>Definition at line 105 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::key_type \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBkey_type\fP</h3>
<p>Public typedefs.</p><p>Definition at line 102 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef \fB_Hashtable::local_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBlocal_iterator\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 117 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::pointer \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBpointer\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 111 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::reference \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBreference\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 113 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::size_type \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBsize_type\fP</h3>
<p>Iterator-related typedefs.</p><p>Definition at line 119 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; typedef _Hashtable::value_type \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBvalue_type\fP</h3>
<p>Public typedefs.</p><p>Definition at line 103 of file unordered_set.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBunordered_set\fP (\fBsize_type\fP__n = \fC10\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP, \fC [explicit]\fP</h3>
<p>Default constructor creates no elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> Initial number of buckets.</p><p><em>__hf</em> A hash functor.</p><p><em>__eql</em> A key equality functor.</p><p><em>__a</em> An allocator object.</p><p>Definition at line 132 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; template&lt;typename _InputIterator &gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBunordered_set\fP (_InputIterator__f, _InputIterator__l, \fBsize_type\fP__n = \fC0\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP</h3>
<p>Builds an unordered_set from a range.</p><p><strong>Parameters:</strong></p><p><em>__first</em> An input iterator.</p><p><em>__last</em> An input iterator.</p><p><em>__n</em> Minimal initial number of buckets.</p><p><em>__hf</em> A hash functor.</p><p><em>__eql</em> A key equality functor.</p><p><em>__a</em> An allocator object.</p><p>Create an unordered_set consisting of copies of the elements from [__first,__last). This is linear in N (where N is distance(__first,__last)).</p><p>Definition at line 153 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBunordered_set\fP (const \fBunordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt; &)\fC [default]\fP</h3>
<p>Copy constructor.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBunordered_set\fP (\fBunordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt; &&)\fC [default]\fP</h3>
<p>Move constructor.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBunordered_set\fP (const \fBallocator_type\fP &__a)\fC [inline]\fP, \fC [explicit]\fP</h3>
<p>Creates an unordered_set with no elements.</p><p><strong>Parameters:</strong></p><p><em>__a</em> An allocator object.</p><p>Definition at line 172 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::\fBunordered_set\fP (initializer_list&lt; \fBvalue_type\fP &gt;__l, \fBsize_type\fP__n = \fC0\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP</h3>
<p>Builds an unordered_set from an initializer_list.</p><p><strong>Parameters:</strong></p><p><em>__l</em> An initializer_list.</p><p><em>__n</em> Minimal initial number of buckets.</p><p><em>__hf</em> A hash functor.</p><p><em>__eql</em> A key equality functor.</p><p><em>__a</em> An allocator object.</p><p>Create an unordered_set consisting of copies of the elements in the list. This is linear in N (where N is <em>__l.size()</em>).</p><p>Definition at line 207 of file unordered_set.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::begin ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_set.</p><p>Definition at line 272 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::begin () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_set.</p><p>Definition at line 276 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBlocal_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::begin (\fBsize_type\fP__n)\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to the first bucket element.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 623 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_local_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::begin (\fBsize_type\fP__n) const\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to the first bucket element.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 627 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBsize_type\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::bucket_count () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the number of buckets of the unordered_set.</p><p>Definition at line 589 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_set.</p><p>Definition at line 299 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_local_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::cbegin (\fBsize_type\fP__n) const\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to the first bucket element.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 631 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::cend () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_set.</p><p>Definition at line 307 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_local_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::cend (\fBsize_type\fP__n) const\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 651 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; void \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::clear ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Erases all elements in an unordered_set. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 500 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBsize_type\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::count (const \fBkey_type\fP &__x) const\fC [inline]\fP</h3>
<p>Finds the number of elements.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Element to located.</p><p><strong>Returns:</strong></p><p>Number of elements with specified key.</p><p>This function only makes sense for unordered_multisets; for unordered_set the result will either be 0 (not present) or 1 (present).</p><p>Definition at line 564 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; template&lt;typename... _Args&gt; \fBstd::pair\fP&lt;\fBiterator\fP, bool&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::emplace (_Args &&...__args)\fC [inline]\fP</h3>
<p>Attempts to build and insert an element into the unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__args</em> Arguments used to generate an element.</p><p><strong>Returns:</strong></p><p>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</p><p>This function attempts to build and insert an element into the unordered_set. An unordered_set relies on unique keys and thus an element is only inserted if it is not already present in the unordered_set.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 329 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; template&lt;typename... _Args&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::emplace_hint (\fBconst_iterator\fP__pos, _Args &&...__args)\fC [inline]\fP</h3>
<p>Attempts to insert an element into the unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__pos</em> An iterator that serves as a hint as to where the element should be inserted.</p><p><em>__args</em> Arguments used to generate the element to be inserted.</p><p><strong>Returns:</strong></p><p>An iterator that points to the element with key equivalent to the one generated from <em>__args</em> (may or may not be the element itself).</p><p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument emplace() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p><p>For more on <em>hinting</em>, see: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html</p><p>Insertion requires amortized constant time.</p><p>Definition at line 355 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; bool \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::empty () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns true if the unordered_set is empty.</p><p>Definition at line 251 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::end ()\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_set.</p><p>Definition at line 286 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::end () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_set.</p><p>Definition at line 290 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBlocal_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::end (\fBsize_type\fP__n)\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 643 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_local_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::end (\fBsize_type\fP__n) const\fC [inline]\fP</h3>
<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The bucket index.</p><p><strong>Returns:</strong></p><p>A read-only local iterator.</p><p>Definition at line 647 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::pair\fP&lt;\fBiterator\fP, \fBiterator\fP&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::equal_range (const \fBkey_type\fP &__x)\fC [inline]\fP</h3>
<p>Finds a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key to be located.</p><p><strong>Returns:</strong></p><p>Pair of iterators that possibly points to the subsequence matching given key.</p><p>This function probably only makes sense for multisets.</p><p>Definition at line 577 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::pair\fP&lt;\fBconst_iterator\fP, \fBconst_iterator\fP&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::equal_range (const \fBkey_type\fP &__x) const\fC [inline]\fP</h3>
<p>Finds a subsequence matching given key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key to be located.</p><p><strong>Returns:</strong></p><p>Pair of iterators that possibly points to the subsequence matching given key.</p><p>This function probably only makes sense for multisets.</p><p>Definition at line 581 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::erase (\fBconst_iterator\fP__position)\fC [inline]\fP</h3>
<p>Erases an element from an unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator pointing to the element to be erased.</p><p><strong>Returns:</strong></p><p>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</p><p>This function erases an element, pointed to by the given iterator, from an unordered_set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 450 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::erase (\fBiterator\fP__it)\fC [inline]\fP</h3>
<p>Erases an element from an unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__position</em> An iterator pointing to the element to be erased.</p><p><strong>Returns:</strong></p><p>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</p><p>This function erases an element, pointed to by the given iterator, from an unordered_set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 455 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBsize_type\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::erase (const \fBkey_type\fP &__x)\fC [inline]\fP</h3>
<p>Erases elements according to the provided key.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Key of element to be erased.</p><p><strong>Returns:</strong></p><p>The number of elements erased.</p><p>This function erases all the elements located by the given key from an unordered_set. For an unordered_set the result of this function can only be 0 (not present) or 1 (present). Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 472 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::erase (\fBconst_iterator\fP__first, \fBconst_iterator\fP__last)\fC [inline]\fP</h3>
<p>Erases a [__first,__last) range of elements from an unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__first</em> Iterator pointing to the start of the range to be erased.</p><p><em>__last</em> Iterator pointing to the end of the range to be erased.</p><p><strong>Returns:</strong></p><p>The iterator <em>__last</em>.</p><p>This function erases a sequence of elements from an unordered_set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.</p><p>Definition at line 490 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::find (const \fBkey_type\fP &__x)\fC [inline]\fP</h3>
<p>Tries to locate an element in an unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Element to be located.</p><p><strong>Returns:</strong></p><p>Iterator pointing to sought-after element, or end() if not found.</p><p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( end() ) iterator.</p><p>Definition at line 546 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBconst_iterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::find (const \fBkey_type\fP &__x) const\fC [inline]\fP</h3>
<p>Tries to locate an element in an unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Element to be located.</p><p><strong>Returns:</strong></p><p>Iterator pointing to sought-after element, or end() if not found.</p><p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( end() ) iterator.</p><p>Definition at line 550 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBallocator_type\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::get_allocator () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the allocator object with which the unordered_set was constructed.</p><p>Definition at line 244 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBhasher\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::hash_function () const\fC [inline]\fP</h3>
<p>Returns the hash functor object with which the unordered_set was constructed.</p><p>Definition at line 522 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::pair\fP&lt;\fBiterator\fP, bool&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::insert (const \fBvalue_type\fP &__x)\fC [inline]\fP</h3>
<p>Attempts to insert an element into the unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Element to be inserted.</p><p><strong>Returns:</strong></p><p>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</p><p>This function attempts to insert an element into the unordered_set. An unordered_set relies on unique keys and thus an element is only inserted if it is not already present in the unordered_set.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 373 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBstd::pair\fP&lt;\fBiterator\fP, bool&gt; \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::insert (\fBvalue_type\fP &&__x)\fC [inline]\fP</h3>
<p>Attempts to insert an element into the unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__x</em> Element to be inserted.</p><p><strong>Returns:</strong></p><p>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</p><p>This function attempts to insert an element into the unordered_set. An unordered_set relies on unique keys and thus an element is only inserted if it is not already present in the unordered_set.</p><p>Insertion requires amortized constant time.</p><p>Definition at line 377 of file unordered_set.h.</p><p>References std::move().</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::insert (\fBconst_iterator\fP__hint, const \fBvalue_type\fP &__x)\fC [inline]\fP</h3>
<p>Attempts to insert an element into the unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__hint</em> An iterator that serves as a hint as to where the element should be inserted.</p><p><em>__x</em> Element to be inserted.</p><p><strong>Returns:</strong></p><p>An iterator that points to the element with key of <em>__x</em> (may or may not be the element passed in).</p><p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p><p>For more on <em>hinting</em>, see: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html</p><p>Insertion requires amortized constant.</p><p>Definition at line 402 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBiterator\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::insert (\fBconst_iterator\fP__hint, \fBvalue_type\fP &&__x)\fC [inline]\fP</h3>
<p>Attempts to insert an element into the unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__hint</em> An iterator that serves as a hint as to where the element should be inserted.</p><p><em>__x</em> Element to be inserted.</p><p><strong>Returns:</strong></p><p>An iterator that points to the element with key of <em>__x</em> (may or may not be the element passed in).</p><p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p><p>For more on <em>hinting</em>, see: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html</p><p>Insertion requires amortized constant.</p><p>Definition at line 406 of file unordered_set.h.</p><p>References std::move().</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; template&lt;typename _InputIterator &gt; void \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::insert (_InputIterator__first, _InputIterator__last)\fC [inline]\fP</h3>
<p>A template function that attempts to insert a range of elements.</p><p><strong>Parameters:</strong></p><p><em>__first</em> Iterator pointing to the start of the range to be inserted.</p><p><em>__last</em> Iterator pointing to the end of the range.</p><p>Complexity similar to that of the range constructor.</p><p>Definition at line 421 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; void \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::insert (initializer_list&lt; \fBvalue_type\fP &gt;__l)\fC [inline]\fP</h3>
<p>Attempts to insert a list of elements into the unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__l</em> A std::initializer_list&lt;value_type&gt; of elements to be inserted.</p><p>Complexity similar to that of the range constructor.</p><p>Definition at line 432 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBkey_equal\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::key_eq () const\fC [inline]\fP</h3>
<p>Returns the key comparison object with which the unordered_set was constructed.</p><p>Definition at line 528 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; float \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::load_factor () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the average number of elements per bucket.</p><p>Definition at line 659 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBsize_type\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::max_bucket_count () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the maximum number of buckets of the unordered_set.</p><p>Definition at line 594 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; float \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::max_load_factor () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns a positive number that the unordered_set tries to keep the load factor less than or equal to.</p><p>Definition at line 665 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; void \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::max_load_factor (float__z)\fC [inline]\fP</h3>
<p>Change the unordered_set maximum load factor.</p><p><strong>Parameters:</strong></p><p><em>__z</em> The new maximum load factor.</p><p>Definition at line 673 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBsize_type\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::max_size () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the maximum size of the unordered_set.</p><p>Definition at line 261 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBunordered_set\fP& \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::operator= (const \fBunordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt; &)\fC [default]\fP</h3>
<p>Copy assignment operator.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBunordered_set\fP& \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::operator= (\fBunordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt; &&)\fC [default]\fP</h3>
<p>Move assignment operator.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBunordered_set\fP& \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::operator= (initializer_list&lt; \fBvalue_type\fP &gt;__l)\fC [inline]\fP</h3>
<p>Unordered_set list assignment operator.</p><p><strong>Parameters:</strong></p><p><em>__l</em> An initializer_list.</p><p>This function fills an unordered_set with copies of the elements in the initializer list <em>__l</em>.</p><p>Note that the assignment completely changes the unordered_set and that the resulting unordered_set's size is the same as the number of elements assigned. Old data may be lost.</p><p>Definition at line 235 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; void \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::rehash (\fBsize_type\fP__n)\fC [inline]\fP</h3>
<p>May rehash the unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__n</em> The new number of buckets.</p><p>Rehash will occur only if the new number of buckets respect the unordered_set maximum load factor.</p><p>Definition at line 684 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; void \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::reserve (\fBsize_type\fP__n)\fC [inline]\fP</h3>
<p>Prepare the unordered_set for a specified number of elements.</p><p><strong>Parameters:</strong></p><p><em>__n</em> Number of elements required.</p><p>Same as rehash(ceil(n / max_load_factor())).</p><p>Definition at line 695 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; \fBsize_type\fP \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::size () const\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Returns the size of the unordered_set.</p><p>Definition at line 256 of file unordered_set.h.</p>
<h3>template&lt;class _Value , class _Hash  = hash&lt;_Value&gt;, class _Pred  = std::equal_to&lt;_Value&gt;, class _Alloc  = std::allocator&lt;_Value&gt;&gt; void \fBstd::unordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt;::swap (\fBunordered_set\fP&lt; _Value, _Hash, _Pred, _Alloc &gt; &__x)\fC [inline]\fP, \fC [noexcept]\fP</h3>
<p>Swaps data with another unordered_set.</p><p><strong>Parameters:</strong></p><p><em>__x</em> An unordered_set of the same element and allocator types.</p><p>This exchanges the elements between two sets in constant time. Note that the global std::swap() function is specialized such that std::swap(s1,s2) will feed to this function.</p><p>Definition at line 513 of file unordered_set.h.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for libstdc++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libstdc++-4.9-doc-std::unordered_multiset.3cxx.html"><span aria-hidden="true">&larr;</span> std::unordered_multiset.3cxx: Std::unordered_multiset _value, _hash, _pred, _alloc  -</a></li>
   <li class="next"><a href="libstdc++-4.9-doc-std::unordered_set.3cxx.html">std::unordered_set.3cxx: Std::unordered_set _value, _hash, _pred, _alloc  - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Data::TreeDumper: Improved replacement for data::dumper. powerful filtering capability.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Improved replacement for data::dumper. powerful filtering capability.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Data::TreeDumper (3pm) manual">
  <meta name="twitter:description" content="Improved replacement for data::dumper. powerful filtering capability.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdata-treedumper-perl-Data::TreeDumper-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Data::TreeDumper.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Data::TreeDumper (3pm) manual" />
  <meta property="og:description" content="Improved replacement for data::dumper. powerful filtering capability." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdata-treedumper-perl-Data::TreeDumper-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Data::TreeDumper<small> (3pm)</small></h1>
        <p class="lead">Improved replacement for data::dumper. powerful filtering capability.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::TreeDumper.3pm.html">
      <span itemprop="name">Data::TreeDumper: Improved replacement for data::dumper. powerful filtering capability.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdata-treedumper-perl/">
      <span itemprop="name">libdata-treedumper-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::TreeDumper.3pm.html">
      <span itemprop="name">Data::TreeDumper: Improved replacement for data::dumper. powerful filtering capability.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Data::TreeDumper ;

  my $sub = sub {} ;

  my $s =
  {
  A =&gt;
        {
        a =&gt;
                {
                }
        , bbbbbb =&gt; $sub
        , c123 =&gt; $sub
        , d =&gt; &#92;$sub
        }

  , C =&gt;
        {
        b =&gt;
                {
                a =&gt;
                        {
                        a =&gt;
                                {
                                }

                        , b =&gt; sub
                                {
                                }
                        , c =&gt; 42
                        }

                }
        }
  , ARRAY =&gt; [qw(elment_1 element_2 element_3)]
  } ;


  #-------------------------------------------------------------------
  # package setup data
  #-------------------------------------------------------------------

  $Data::TreeDumper::Useascii = 0 ;
  $Data::TreeDumper::Maxdepth = 2 ;

  print DumpTree($s, &apos;title&apos;) ;
  print DumpTree($s, &apos;title&apos;, MAX_DEPTH =&gt; 1) ;
  print DumpTrees
          (
            [$s, "title", MAX_DEPTH =&gt; 1]
          , [$s2, "other_title", DISPLAY_ADDRESS =&gt; 0]
          , USE_ASCII =&gt; 1
          , MAX_DEPTH =&gt; 5
          ) ;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Output</h2>
        <div class="sectioncontent">
<p>  title:   |- A [H1]   |  |- a [H2]   |  |- bbbbbb = CODE(0x8139fa0) [C3]   |  |- c123 [C4 -&gt; C3]   |  &#96;- d [R5]   |     &#96;- REF(0x8139fb8) [R5 -&gt; C3]   |- ARRAY [A6]   |  |- 0 [S7] = elment_1   |  |- 1 [S8] = element_2   |  &#96;- 2 [S9] = element_3   &#96;- C [H10]      &#96;- b [H11]         &#96;- a [H12]            |- a [H13]            |- b = CODE(0x81ab130) [C14]            &#96;- c [S15] = 42</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Data::Dumper and other modules do a great job of dumping data structures.  Their output, however, often takes more brain power to understand than the data itself.  When dumping large amounts of data, the output can be overwhelming and it can be difficult to see the relationship between each piece of the dumped data.</p><p>Data::TreeDumper also dumps data in a tree-like fashion but <em>hopefully</em> in a format more easily understood.</p><h3>Label</h3>
<p>Each node in the tree has a label. The label contains a type and an address. The label is displayed to the right of the entry name within square brackets.</p><p>  |  |- bbbbbb = CODE(0x8139fa0) [C3]   |  |- c123 [C4 -&gt; C3]   |  &#96;- d [R5]   |     &#96;- REF(0x8139fb8) [R5 -&gt; C3]</p><p><em>Address</em></p><p>The addresses are linearly incremented which should make it easier to locate data. If the entry is a reference to data already displayed, a <strong>-</strong>&gt; followed with the address of the already displayed data is appended within the label.</p><p>  ex: c123 [C4 -&gt; C3]              ^     ^              |     | address of the data refered to              |              | current element address</p><p><em>Types</em></p><p><strong>S</strong>: Scalar, <strong>H</strong>: Hash, <strong>A</strong>: Array, <strong>C</strong>: Code,</p><p><strong>R</strong>: Reference, <strong>\s-1RS\s0</strong>: Scalar reference. <strong>Ox</strong>: Object, where x is the object undelying type</p>
<h3>Empty Hash or Array</h3>
<p>No structure is displayed for empty hashes or arrays, the string \*(L"no elements\*(R" is added to the display.</p><p>  |- A [S10] = string   |- EMPTY_ARRAY (no elements) [A11]   |- B [S12] = 123</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Configuration and Overrides</h2>
        <div class="sectioncontent">
<p>Data::TreeDumper has configuration options you can set to modify the output it generates. <em>DumpTree</em> and <em>PrintTree</em> take overrides as trailing arguments. Those overrides are active within the current dump call only.</p><p>  ex:   $Data::TreeDumper::Maxdepth = 2 ;</p><p>  # maximum depth set to 1 for the duration of the call only   print DumpTree($s, &apos;title&apos;, MAX_DEPTH =&gt; 1) ;   PrintTree($s, &apos;title&apos;, MAX_DEPTH =&gt; 1) ; # shortcut for the above call</p><p>  # maximum depth is 2   print DumpTree($s, &apos;title&apos;) ; This package variable is very useful when you use <strong>Data::TreeDumper</strong> and don't know where you called <strong>PrintTree</strong> or <strong>DumpTree</strong>, ie when debugging. It displays the filename and line of call on \s-1STDOUT\s0. It can't also be set as an override,  \s-1DISPLAY_CALLER_LOCATION\s0 =&gt; 1.</p><h3>\s-1NO_PACKAGE_SETUP\s0</h3>
<p>Sometimes, the package setup you have is not what you want to use. resetting the variable, making a call and setting the variables back is borring. You can set <strong>\s-1NO_PACKAGE_SETUP\s0</strong> to 1 and <em>DumpTree</em> will ignore the package setup for the call.</p><p>  print Data::TreeDumper::DumpTree($s, "Using package data") ;   print Data::TreeDumper::DumpTree($s, "Not Using package data", NO_PACKAGE_SETUP =&gt; 1) ;</p>
<h3>\s-1DISPLAY_ROOT_ADDRESS\s0</h3>
<p>By default, <strong>Data::TreeDumper</strong> doesn't display the address of the root.</p><p>  DISPLAY_ROOT_ADDRESS =&gt; 1 # show the root address</p>
<h3>\s-1DISPLAY_ADDRESS\s0</h3>
<p>When the dumped data is not self-referential, displaying the address of each node clutters the display. You can direct <strong>Data::TreeDumper</strong> to not display the node address by using:</p><p>  DISPLAY_ADDRESS =&gt; 0</p>
<h3>\s-1DISPLAY_PATH\s0</h3>
<p>Add the path of the element to the its address.</p><p>  DISPLAY_PATH =&gt; 1</p><p>  ex: &apos;- CopyOfARRAY  [A39 -&gt; A18 /{&apos;ARRAY&apos;}]</p>
<h3>\s-1DISPLAY_OBJECT_TYPE\s0</h3>
<p><strong>Data::TreeDumper</strong> displays the package in which an object is blessed.  You can suppress this display by using:</p><p>  DISPLAY_OBJECT_TYPE =&gt; 0</p>
<h3>\s-1DISPLAY_INHERITANCE\s0</h3>
<p><strong>Data::TreeDumper</strong> will display the inheritance hierarchy for the object:</p><p>  |- object =  blessed in &apos;SuperObject&apos; &lt;- Potatoe [OH55]   |  &#96;- Data = 0  [S56]</p>
<h3>\s-1DISPLAY_AUTOLOAD\s0</h3>
<p>if set, <strong>Data::TreeDumper</strong> will tag the object type with '[A]' if the package has an \s-1AUTOLOAD\s0 function.</p><p>  |- object_with_autoload = blessed in &apos;[A]SuperObjectWithAutoload&apos; &lt;- Potatoe &lt;- [A] Vegetable   [O58]   |  &#96;- Data = 0  [S56]</p>
<h3>\s-1DISPLAY_TIE\s0</h3>
<p>if \s-1DISPLAY_TIE\s0 is set, <strong>Data::TreeDumper</strong> will display which packae the variable is tied to. This works for hashes and arrays as well as for object which are based on hashes and arrays.</p><p>  |- tied_hash (tied to &apos;TiedHash&apos;)  [H57]   |  &#96;- x = 1  [S58]</p><p>  |- tied_hash_object = (tied to &apos;TiedHash&apos;) blessed in &apos;SuperObject&apos; &lt;- [A]Potatoe &lt;- Vegetable   [O59]   |  |- m1 = 1  [S60]   |  &#96;- m2 = 2  [S61]</p>
<h3>\s-1PERL\s0 \s-1DATA\s0</h3>
<p>Setting one of the options below will show internal perl data:</p><p>  Cells: &lt;2234&gt; HASH(0x814F20c)   |- A1 [H1] &lt;204&gt; HASH(0x824620c)   |  &#96;- VALUE [S2] = datadatadatadatadatadatadatadatadatadata &lt;85&gt;   |- A8 [H11] &lt;165&gt; HASH(0x8243d68)   |  &#96;- VALUE [S12] = C &lt;46&gt;   &#96;- C2 [H19] &lt;165&gt; HASH(0x8243dc0)      &#96;- VALUE [S20] = B &lt;46&gt;</p><p><em>\s-1DISPLAY_PERL_SIZE\s0</em></p><p>Setting this option will show the size of the memory allocated for each element in the tree within angle brackets.</p><p>  DISPLAY_PERL_SIZE =&gt; 1</p><p>The excellent Devel::Size is used to compute the size of the perl data. If you have deep circular data structures, expect the dump time to be slower, 50 times slower or more.</p><p><em>\s-1DISPLAY_PERL_ADDRESS\s0</em></p><p>Setting this option will show the perl-address of the dumped data.</p><p>  DISPLAY_PERL_ADDRESS =&gt; 1</p>
<h3>\s-1REPLACEMENT_LIST\s0</h3>
<p>Scalars may contain non printable characters that you rather not see in a dump. One of the most common is \*(L"&#92;r\*(R" embedded in text string from dos files. <strong>Data::TreeDumper</strong>, by default, replaces \*(L"&#92;n\*(R" by '[&#92;n]' and \*(L"&#92;r\*(R" by '[&#92;r]'. You can set \s-1REPLACEMENT_LIST\s0 to an array ref containing elements which are themselves array references. The first element is the character(s) to match and the second is the replacement.</p><p>  # a fancy and stricter replacement for &#92;n and &#92;r   my $replacement = [ ["&#92;n" =&gt; &apos;[**Fancy &#92;n replacement**]&apos;], ["&#92;r" =&gt; &apos;&#92;r&apos;] ] ;   print DumpTree($smed-&gt;{TEXT}, &apos;Text:&apos;, REPLACEMENT_LIST =&gt; $replacement) ;</p>
<h3>\s-1QUOTE_HASH_KEYS\s0</h3>
<p><strong>\s-1QUOTE_HASH_KEYS\s0</strong> and its package variable <strong></strong><strong>$Data::TreeDumper::Quotehashkeys</strong><strong></strong> can be set if you wish to single quote the hash keys. Hash keys are not quoted by default.</p><p>  DumpTree(&#92;$s, &apos;some data:&apos;, QUOTE_HASH_KEYS =&gt; 1) ;</p><p>  # output   some data:   &#96;- REF(0x813da3c) [H1]      |- &apos;A&apos; [H2]      |  |- &apos;a&apos; [H3]      |  |- &apos;b&apos; [H4]      |  |  |- &apos;a&apos; = 0 [S5]</p>
<h3>\s-1QUOTE_VALUES\s0</h3>
<p><strong>\s-1QUOTE_VALUES\s0</strong> and its package variable <strong></strong><strong>$Data::TreeDumper::Quotevalues</strong><strong></strong> can be set if you wish to single quote the scalar values.</p><p>  DumpTree(&#92;$s, &apos;Cells:&apos;, QUOTE_VALUES=&gt; 1) ;</p>
<h3>\s-1NO_NO_ELEMENTS\s0</h3>
<p>If this option is set, <strong>Data::TreeDumper</strong> will not add 'no elements' to empty hashes and arrays</p>
<h3>\s-1NO_OUTPUT\s0</h3>
<p>This option suppresses all output generated by Data::TreeDumper. This is useful when you want to iterate through your data structures and display the data yourself, manipulate the data structure, or do a search (see \*(L"using filter as iterators\*(R" below)</p>
<h3>Filters</h3>
<p>Data::TreeDumper can sort the tree nodes with a user defined subroutine. By default, hash keys are sorted.</p><p>  FILTER =&gt; &#92;&ReverseSort   FILTER_ARGUMENT =&gt; [&apos;your&apos;, &apos;arguments&apos;]</p><p>The filter routine is passed these arguments:</p>
<dl class='dl-vertical'>
  <dt>
    1 - a reference to the node which is going to be displayed
  </dt>
  <dd>
    
  </dd>
  <dt>
    2 - the nodes depth (this allows you to selectively display elements at a certain depth)
  </dt>
  <dd>
    
  </dd>
  <dt>
    3 - the path to the reference from the start of the dump.
  </dt>
  <dd>
    
  </dd>
  <dt>
    5 - the dumpers setup
  </dt>
  <dd>
    
  </dd>
  <dt>
    5 - the filter arguments (see below)
  </dt>
  <dd>
    
  </dd>

</dl>
<p>The filter returns the node's type, an eventual new structure (see below) and a list of 'keys' to display. The keys are hash keys or array indexes.</p><p>In Perl:</p><p>  ($tree_type, $replacement_tree, @nodes_to_display) = $your_filter-&gt;($tree, $level, $path, $nodes_to_display, $setup) ;</p><p>Filter are not as complicated as they sound and they are very powerful, especially when using the path argument.  The path idea was given to me by another module writer but I forgot whom. If this writer will contact me, I will give him the proper credit.</p><p>Lots of examples can be found in <em>filters.pl</em> and I'll be glad to help if you want to develop a specific filter.</p><p><em>\s-1FILTER_ARGUMENT\s0</em></p><p>it is possible to pass arguments to your filter, passing a reference allows you to modify the arguments when the filter is run (that happends for each node).</p><p> sub SomeSub  {  my $counter = 0 ;  my $data_structure = {.....} ;</p><p> DumpTree($data_structure, &apos;title&apos;, FILTER =&gt; &#92;&CountNodes, FILTER_ARGUMENT =&gt; &#92;$counter) ;</p><p> print "&#92;$counter = $counter&#92;n" ;  }</p><p> sub CountNodes  {  my ($structure, $level, $path, $nodes_to_display, $setup, $counter) = @_ ;  $$counter++ ; # remember to pass references if you want them to be changed by the filter</p><p> return(DefaultNodesToDisplay($structure)) ;  }</p><p><em>Key removal</em></p><p>Entries can be removed from the display by not returning their keys.</p><p>  my $s = {visible =&gt; &apos;&apos;, also_visible =&gt; &apos;&apos;, not_visible =&gt; &apos;&apos;} ;   my $OnlyVisible = sub         {         my $s = shift ;</p><p>        if(&apos;HASH&apos; eq ref $s)                 {                 return(&apos;HASH&apos;, undef, grep {! /^not_visible/} keys %$s) ;                 }</p><p>        return(Data::TreeDumper::DefaultNodesToDisplay($s)) ;         }</p><p>  DumpTree($s, &apos;title&apos;, FILTER =&gt; $OnlyVisible) ;</p><p><em>Label changing</em></p><p>The label for a hash keys or an array index can be altered. This can be used to add visual information to the tree dump. Instead of returning the key name, return an array reference containing the key name and the label you want to display. You only need to return such a reference for the entries you want to change, thus a mix of scalars and array ref is acceptable.</p><p>  sub StarOnA   {   # hash entries matching /^a/i have &apos;*&apos; prepended</p><p>  my $tree = shift ;</p><p>  if(&apos;HASH&apos; eq ref $tree)         {         my @keys_to_dump ;</p><p>        for my $key_name (keys %$tree)                 {                 if($key_name =~ /^a/i)                         {                         $key_name = [$key_name, "* $key_name"] ;                         }</p><p>                push @keys_to_dump, $key_name ;                 }</p><p>        return (&apos;HASH&apos;, undef, @keys_to_dump) ;         }</p><p>  return (Data::TreeDumper::DefaultNodesToDisplay($tree)) ;   }</p><p>  print DumpTree($s, "Entries matching /^a/i have &apos;*&apos; prepended", FILTER =&gt; &#92;&StarOnA) ;</p><p>If you use an \s-1ANSI\s0 terminal, you can also change the color of the label. This can greatly improve visual search time. See the <em>label coloring</em> example in <em>colors.pl</em>.</p><p><em>Structure replacement</em></p><p>It is possible to replace the whole data structure in a filter. This comes handy when you want to display a <em>\*(L"worked\*(R"</em> version of the structure. You can even change the type of the data structure, for example changing an array to a hash.</p><p>  sub ReplaceArray   {   # replace arrays with hashes!!!</p><p>  my $tree = shift ;</p><p>  if(&apos;ARRAY&apos; eq ref $tree)         {         my $multiplication = $tree-&gt;[0] * $tree-&gt;[1] ;         my $replacement = {MULTIPLICATION =&gt; $multiplication} ;         return(&apos;HASH&apos;, $replacement, keys %$replacement) ;         }</p><p>  return (Data::TreeDumper::DefaultNodesToDisplay($tree)) ;   }</p><p>  print DumpTree($s, &apos;replace arrays with hashes!&apos;, FILTER =&gt; &#92;&ReplaceArray) ;</p><p>Here is a real life example. <strong>Tree::Simple</strong> (http://search.cpan.org/dist/Tree-Simple/ &lt;http://search.cpan.org/dist/Tree-Simple/&gt;) allows one to build tree structures. The child nodes are not directly in the parent object (hash). Here is an unfiltered dump of a tree with seven nodes:</p><p>  Tree::Simple through Data::TreeDumper   |- _children   |  |- 0   |  |  |- _children   |  |  |  &#96;- 0   |  |  |     |- _children   |  |  |     |- _depth = 1   |  |  |     |- _node = 1.1   |  |  |     &#96;- _parent   |  |  |- _depth = 0   |  |  |- _node = 1   |  |  &#96;- _parent   |  |- 1   |  |  |- _children   |  |  |  |- 0   |  |  |  |  |- _children   |  |  |  |  |- _depth = 1   |  |  |  |  |- _node = 2.1   |  |  |  |  &#96;- _parent   |  |  |  |- 1   |  |  |  |  |- _children   |  |  |  |  |- _depth = 1   |  |  |  |  |- _node = 2.1a   |  |  |  |  &#96;- _parent   |  |  |  &#96;- 2   |  |  |     |- _children   |  |  |     |- _depth = 1   |  |  |     |- _node = 2.2   |  |  |     &#96;- _parent   |  |  |- _depth = 0   |  |  |- _node = 2   |  |  &#96;- _parent   |  &#96;- 2   |     |- _children   |     |- _depth = 0   |     |- _node = 3   |     &#96;- _parent   |- _depth = -1   |- _node = 0   &#96;- _parent = root</p><p>This is nice for the developer but not for a user wanting to oversee the node hierarchy. One of the possible filters would be:</p><p>  FILTER =&gt; sub                 {                 my $s = shift ;</p><p>                if(&apos;Tree::Simple&apos; eq ref $s)                         {                         my $counter = 0 ;</p><p>                        return                                 (                                 &apos;ARRAY&apos;                                 , $s-&gt;{_children}                                 , map{[$counter++, $_-&gt;{_node}]} @{$s-&gt;{_children}} # index generation                                 ) ;                         }</p><p>                return(Data::TreeDumper::DefaultNodesToDisplay($s)) ;                 }</p><p>Which would give this much more readable output:</p><p>  Tree::Simple through Data::TreeDumper2   |- 1   |  &#96;- 1.1   |- 2   |  |- 2.1   |  |- 2.1a   |  &#96;- 2.2   &#96;- 3</p><p>What about counting the children nodes? The index generating code becomes:</p><p>  map{[$counter++, "$_-&gt;{_node} [" . @{$_-&gt;{_children}} . "]"]} @{$s-&gt;{_children}}</p><p>  Tree::Simple through Data::TreeDumper4   |- 1 [1]   |  &#96;- 1.1 [0]   |- 2 [3]   |  |- 2.1 [0]   |  |- 2.1a [0]   |  &#96;- 2.2 [0]   &#96;- 3 [0]</p><p><em>Filter chaining</em></p><p>It is possible to chain filters. <em>CreateChainingFilter</em> takes a list of filtering sub references. The filters must properly handle the third parameter passed to them.</p><p>Suppose you want to chain a filter that adds a star before each hash key label, with a filter that removes all (original) keys that match /^a/i.</p><p>  sub AddStar         {         my $s = shift ;         my $level = shift ;         my $path = shift ;         my $keys = shift ;</p><p>        if(&apos;HASH&apos; eq ref $s)                 {                 $keys = [keys %$s] unless defined $keys ;</p><p>                my @new_keys ;</p><p>                for (@$keys)                         {                         if(&apos;&apos; eq ref $_)                                 {                                 push @new_keys, [$_, "* $_"] ;                                 }                         else                                 {                                 # another filter has changed the label                                 push @new_keys, [$_-&gt;[0], "* $_-&gt;[1]"] ;                                 }                         }</p><p>                return(&apos;HASH&apos;, undef, @new_keys) ;                 }</p><p>        return(Data::TreeDumper::DefaultNodesToDisplay($s)) ;         } ;</p><p>  sub RemoveA         {         my $s = shift ;         my $level = shift ;         my $path = shift ;         my $keys = shift ;</p><p>        if(&apos;HASH&apos; eq ref $s)                 {                 $keys = [keys %$s] unless defined $keys ;                 my @new_keys ;</p><p>                for (@$keys)                         {                         if(&apos;&apos; eq ref $_)                                 {                                 push @new_keys, $_ unless /^a/i ;                                 }                         else                                 {                                 # another filter has changed the label                                 push @new_keys, $_ unless $_-&gt;[0] =~ /^a/i ;                                 }                         }</p><p>                return(&apos;HASH&apos;, undef, @new_keys) ;                 }</p><p>        return(Data::TreeDumper::DefaultNodesToDisplay($s)) ;         } ;</p><p>  DumpTree($s, &apos;Chained filters&apos;, FILTER =&gt; CreateChainingFilter(&#92;&AddStar, &#92;&RemoveA)) ;</p>
<h3>level Filters</h3>
<p>It is possible to define one filter for a specific level. If a filter for a specific level exists it is used instead of the global filter.</p><p>\s-1LEVEL_FILTERS\s0 =&gt; {1 =&gt; &#92;&FilterForLevelOne, 5 =&gt; &#92;&FilterForLevelFive ... } ;</p>
<h3>Type Filters</h3>
<p>You can define filters for specific types of references. This filter type has the highest priority.</p><p>here's a very simple filter that will display the specified keys for the types</p><p>        print DumpTree                 (                 $data,                 &apos;title&apos;,                 TYPE_FILTERS =&gt;                         {                         &apos;Config::Hierarchical&apos; =&gt; sub {&apos;HASH&apos;, undef, qw(CATEGORIES) },                         &apos;PBS2::Node&apos; =&gt; sub {&apos;HASH&apos;, undef, qw(CONFIG DEPENDENCIES MATCH) },,                         }                 ) ;</p>
<h3>Using filters as iterators</h3>
<p>You can iterate through your data structures and display data yourself, manipulate the data structure, or do a search. While iterating through the data structure, you can prune arbitrary branches to speedup processing.</p><p>  # this example counts the nodes in a tree (hash based)   # a node is counted if it has a &apos;_\|_NAME&apos; key   # any field that starts with &apos;_\|_&apos; is considered rivate and we prune so we don&apos;t recurse in it   # anything that is not a hash (the part of the tree that interests us in this case) is pruned</p><p>  my $number_of_nodes_in_the_dependency_tree = 0 ;   my $node_counter =         sub         {         my $tree = shift ;         if(&apos;HASH&apos; eq ref $tree && exists $tree-&gt;{_\|_NAME})                 {                 $number_of_nodes_in_the_dependency_tree++ if($tree-&gt;{_\|_NAME} !~ /^_\|_/) ;</p><p>                return(&apos;HASH&apos;, $tree, grep {! /^_\|_/} keys %$tree) ; # prune to run faster                 }         else                 {                 return(&apos;SCALAR&apos;, 1) ; # prune                 }         } ;</p><p>  DumpTree($dependency_tree, &apos;&apos;, NO_OUTPUT =&gt; 1, FILTER =&gt; $node_counter) ;</p><p>See the example under \s-1FILTER\s0 which passes arguments through Data::TreeDumper instead for using a closure as above</p>
<h3>Start level</h3>
<p>This configuration option controls whether the tree trunk is displayed or not.</p><p>\s-1START_LEVEL\s0 =&gt; 1:</p><p>  $tree:   |- A [H1]   |  |- a [H2]   |  |- bbbbbb = CODE(0x8139fa0) [C3]   |  |- c123 [C4 -&gt; C3]   |  &#96;- d [R5]   |     &#96;- REF(0x8139fb8) [R5 -&gt; C3]   |- ARRAY [A6]   |  |- 0 [S7] = element_1   |  |- 1 [S8] = element_2</p><p>\s-1START_LEVEL\s0 =&gt; 0:</p><p>  $tree:   A [H1]   |- a [H2]   |- bbbbbb = CODE(0x8139fa0) [C3]   |- c123 [C4 -&gt; C3]   &#96;- d [R5]      &#96;- REF(0x8139fb8) [R5 -&gt; C3]   ARRAY [A6]   |- 0 [S7] = element_1   |- 1 [S8] = element_2</p>
<h3>\s-1ASCII\s0 vs \s-1ANSI\s0</h3>
<p>You can direct Data:TreeDumper to output \s-1ANSI\s0 codes instead of \s-1ASCII\s0 characters. The display will be much nicer but takes slightly longer (not significant for small data structures).</p><p>  USE_ASCII =&gt; 0 # will use ANSI codes instead</p>
<h3>Display number of elements</h3>
<p>  DISPLAY_NUMBER_OF_ELEMENTS =&gt; 1</p><p>When set, the number of elements of every array and hash is displayed (not for objects based on hashes and arrays).</p>
<h3>Maximum depth of the dump</h3>
<p>Controls the depth beyond which which we don't recurse into a structure. Default is -1, which means there is no maximum depth. This is useful to limit the amount of data displayed.</p><p>  MAX_DEPTH =&gt; 1</p>
<h3>Number of elements not displayed because of maximum depth limit</h3>
<p>Data::TreDumper will display the number of elements a hash or array has but that can not be displayed because of the maximum depth setting.</p><p>  DISPLAY_NUMBER_OF_ELEMENTS_OVER_MAX_DEPTH =&gt; 1</p>
<h3>Indentation</h3>
<p>Every line of the tree dump will be appended with the value of <em>\s-1INDENTATION\s0</em>.</p><p>  INDENTATION =&gt; &apos;   &apos; ;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Custom glyphs</h2>
        <div class="sectioncontent">
<p>You can  change the glyphs used by <strong>Data::TreeDumper</strong>.</p><p>  DumpTree(&#92;$s, &apos;s&apos;, , GLYPHS =&gt; [&apos;.  &apos;, &apos;.  &apos;, &apos;.  &apos;, &apos;.  &apos;]) ;</p><p>  # output   s   .  REF(0x813da3c) [H1]   .  .  A [H2]   .  .  .  a [H3]   .  .  .  b [H4]   .  .  .  .  a = 0 [S5]   .  .  .  .  b = 1 [S6]   .  .  .  .  c [H7]   .  .  .  .  .  a = 1 [S8]</p><p>Four glyphs must be given. They replace the standard glyphs ['|  ', '|- ', '`- ', '   ']. It is also possible to set the package variable <strong></strong><strong>$Data::TreeDumper::Glyphs</strong><strong></strong>. <strong>\s-1USE_ASCII\s0</strong> should be set, which it is by default.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Level numbering and tagging</h2>
        <div class="sectioncontent">
<p>Data:TreeDumper can prepend the level of the current line to the tree glyphs. This can be very useful when searching in tree dump either visually or with a pager.</p><p>  NUMBER_LEVELS =&gt; 2   NUMBER_LEVELS =&gt; &#92;&NumberingSub</p><p>\s-1NUMBER_LEVELS\s0 can be assigned a number or a sub reference. When assigned a number, Data::TreeDumper will use that value to define the width of the field where the level is displayed. For more control, you can define a sub that returns a string to be displayed on the left side of the tree glyphs. The example below tags all the nodes whose level is zero.</p><p>  print DumpTree($s, "Level numbering", NUMBER_LEVELS =&gt; 2) ;</p><p>  sub GetLevelTagger   {   my $level_to_tag = shift ;</p><p>  sub         {         my ($element, $level, $setup) = @_ ;</p><p>        my $tag = "Level $level_to_tag =&gt; ";</p><p>        if($level == 0)                 {                 return($tag) ;                 }         else                 {                 return(&apos; &apos; x length($tag)) ;                 }         } ;   }</p><p>  print DumpTree($s, "Level tagging", NUMBER_LEVELS =&gt; <strong>GetLevelTagger</strong>(0)) ;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Level coloring</h2>
        <div class="sectioncontent">
<p>Another way to enhance the output for easier searching is to colorize it. Data::TreeDumper can colorize the glyph elements or whole levels. If your terminal supports \s-1ANSI\s0 codes, using Term::ANSIColors and Data::TreeDumper together can greatly ease the reading of large dumps. See the examples in '<strong>color.pl</strong>'.</p><p>  COLOR_LEVELS =&gt; [&#92;@color_codes, $reset_code]</p><p>When passed an array reference, the first element is an array containing coloring codes. The codes are indexed with the node level modulo the size of the array. The second element is used to reset the color after the glyph is displayed. If the second element is an empty string, the glyph and the rest of the level is colorized.</p><p>  COLOR_LEVELS =&gt; &#92;&LevelColoringSub</p><p>If \s-1COLOR_LEVEL\s0 is assigned a sub, the sub is called for each glyph element. It is passed the following elements:</p>
<dl class='dl-vertical'>
  <dt>
    1 - the nodes depth (this allows you to selectively display elements at a certain depth)
  </dt>
  <dd>
    
  </dd>

</dl>
<p>It should return a coloring code and a reset code. If you return an empty string for the reset code, the whole node is displayed using the last glyph element color.</p><p>If level numbering is on, it is also colorized.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Wrapping</h2>
        <div class="sectioncontent">
<p><strong>Data::TreeDumper</strong> uses the Text::Wrap module to wrap your data to fit your display. Entries can be wrapped multiple times so they snuggly fit your screen.</p><p>  |  |        |- 1 [S21] = 1   |  |        &#96;- 2 [S22] = 2   |  &#96;- 3 [OH23 -&gt; R17]   |- ARRAY_ZERO [A24]   |- B [S25] = scalar   |- Long_name Long_name Long_name Long_name Long_name Long_name   |    Long_name Long_name Long_name Long_name Long_name Long_name   |    Long_name Long_name Long_name Long_name Long_name [S26] = 0</p><p>You can direct \s-1DTD\s0 to not wrap your text by setting <strong>\s-1NO_WRAP\s0 =</strong> 1&gt;.</p><h3>\s-1WRAP_WIDTH\s0</h3>
<p>if this option is set, <strong>Data::TreeDumper</strong> will use it instead for the console width.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Custom Rendering</h2>
        <div class="sectioncontent">
<p><strong>Data::TreeDumper</strong> has a plug-in interface for other rendering formats. The renderer callbacks are set by overriding the native renderer. Thanks to Stevan Little author of Tree::Simple::View for getting <strong>Data::TreeDumper</strong> on this track. Check <strong>Data::TreeDumper::Renderer::DHTML</strong>.</p><p> DumpTree         (           $s         , &apos;Tree&apos;         , RENDERER =&gt;                 {                   BEGIN =&gt; &#92;&RenderDhtmlBegin                 , NODE  =&gt; &#92;&RenderDhtmlNode                 , END   =&gt; &#92;&RenderDhtmlEnd</p><p>                # data needed by the renderer                 , PREVIOUS_LEVEL =&gt; -1                 , PREVIOUS_ADDRESS =&gt; &apos;ROOT&apos;                 }         ) ;</p><h3>Callbacks</h3>
<ul>
<li><p>{\s-1RENDERER\s0}{\s-1BEGIN\s0} is called before the traversal of the data structure starts. This allows you to setup the document (ex:: html header). my ($title, $type_address, $element, $size, $perl_address, $setup) = @_ ;</p></li><li><p>{\s-1RENDERER\s0}{\s-1NODE\s0} is called for each node in the data structure. The following arguments are passed to the callback</p></li><li><p>{\s-1RENDERER\s0}{\s-1END\s0} is called after the last node has been processed.</p></li><li><p>{\s-1RENDERER\s0}{ ... }Arguments to the renderer can be stores within the {\s-1RENDERER\s0} hash.</p></li>
</ul>
<h3>Renderer modules</h3>
<p>Renderers should be defined in modules under <strong>Data::TreeDumper::Renderer</strong> and should define a function called <em>GetRenderer</em>. <em>GetRenderer</em> can be passed whatever arguments the developer whishes. It is acceptable for the modules to also export a specifc sub.</p><p>  print DumpTree($s, &apos;Tree&apos;, Data::TreeDumper::Renderer::DHTML::GetRenderer()) ;   or   print DumpTree($s, &apos;Tree&apos;, GetDhtmlRenderer()) ;</p><p>If <strong>{\s-1RENDERER\s0}</strong> is set to a scalar, <strong>Data::TreeDumper</strong> will load the specified module if it exists. <em>GetRenderer</em> will be called without arguments.</p><p>  print DumpTree($s, &apos;Tree&apos;, RENDERER =&gt; &apos;DHTML&apos;) ;</p><p>If <strong>{\s-1RENDERER\s0}{\s-1NAME\s0}</strong> is set to a scalar, <strong>Data::TreeDumper</strong> will load the specified module if it exists. <em>GetRenderer</em> will be called without arguments. Arguments to the renderer can aither be passed to the GetRenderer sub or as elements in the {\s-1RENDERER\s0} hash.</p><p>  print DumpTree($s, &apos;Tree&apos;, RENDERER =&gt; {NAME =&gt; &apos;DHTML&apos;, STYLE =&gt; &#92;$style) ;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Zero width console</h2>
        <div class="sectioncontent">
<p>When no console exists, while redirecting to a file for example, Data::TreeDumper uses the variable <strong>\s-1VIRTUAL_WIDTH\s0</strong> instead. Default is 120.</p><p>        VIRTUAL_WIDTH =&gt; 120 ;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERRIDE list</h2>
        <div class="sectioncontent">
<ul>
<li><p>\s-1COLOR_LEVELS\s0</p></li><li><p>\s-1DISPLAY_ADDRESS\s0</p></li><li><p>\s-1DISPLAY_PATH\s0</p></li><li><p>\s-1DISPLAY_PERL_SIZE\s0</p></li><li><p>\s-1DISPLAY_ROOT_ADDRESS\s0</p></li><li><p>\s-1DISPLAY_PERL_ADDRESS\s0</p></li><li><p>\s-1FILTER\s0</p></li><li><p>\s-1GLYPHS\s0</p></li><li><p>\s-1INDENTATION\s0</p></li><li><p>\s-1LEVEL_FILTERS\s0</p></li><li><p>\s-1MAX_DEPTH\s0</p></li><li><p>\s-1DISPLAY_NUMBER_OF_ELEMENTS_OVER_MAX_DEPTH\s0</p></li><li><p>\s-1NUMBER_LEVELS\s0</p></li><li><p>\s-1QUOTE_HASH_KEYS\s0</p></li><li><p>\s-1QUOTE_VALUES\s0</p></li><li><p>\s-1REPLACEMENT_LIST\s0</p></li><li><p>\s-1START_LEVEL\s0</p></li><li><p>\s-1USE_ASCII\s0</p></li><li><p>\s-1WRAP_WIDTH\s0</p></li><li><p>\s-1VIRTUAL_WIDTH\s0</p></li><li><p>\s-1NO_OUTPUT\s0</p></li><li><p>\s-1DISPLAY_OBJECT_TYPE\s0</p></li><li><p>\s-1DISPLAY_INHERITANCE\s0</p></li><li><p>\s-1DISPLAY_TIE\s0</p></li><li><p>\s-1DISPLAY_AUTOLOAD\s0</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Interface</h2>
        <div class="sectioncontent">
<h3>Package Data (a\*` la Data::Dumper (as is the silly naming scheme))</h3>
<p><em>Configuration Variables</em></p><p>  $Data::TreeDumper::Startlevel            = 1 ;   $Data::TreeDumper::Useascii              = 1 ;   $Data::TreeDumper::Maxdepth              = -1 ;   $Data::TreeDumper::Indentation           = &apos;&apos; ;   $Data::TreeDumper::Virtualwidth          = 120 ;   $Data::TreeDumper::Displayrootaddress    = 0 ;   $Data::TreeDumper::Displayaddress        = 1 ;   $Data::TreeDumper::Displaypath           = 0 ;   $Data::TreeDumper::Displayobjecttype     = 1 ;   $Data::TreeDumper::Displayinheritance    = 0 ;   $Data::TreeDumper::Displaytie            = 0 ;   $Data::TreeDumper::Displayautoload       = 0 ;   $Data::TreeDumper::Displayperlsize       = 0 ;   $Data::TreeDumper::Displayperladdress    = 0 ;   $Data::TreeDumper::Filter                = &#92;&FlipEverySecondOne ;   $Data::TreeDumper::Levelfilters          = {1 =&gt; &#92;&Filter_1, 5 =&gt; &#92;&Filter_5} ;   $Data::TreeDumper::Numberlevels          = 0 ;   $Data::TreeDumper::Glyphs                = [&apos;|  &apos;, &apos;|- &apos;, &apos;&#96;- &apos;, &apos;   &apos;] ;   $Data::TreeDumper::Colorlevels           = undef ;   $Data::TreeDumper::Nooutput              = 0 ; # generate an output   $Data::TreeDumper::Quotehashkeys         = 0 ;   $Data::TreeDumper::Displaycallerlocation = 0 ;</p><p><em>\s-1API\s0</em></p><p><strong>PrintTree</strong>prints on \s-1STDOUT\s0 the output of <strong>DumpTree</strong>.</p><p><strong>DumpTree</strong> uses the configuration variables defined above. It takes the following arguments:</p>
<dl class='dl-vertical'>
  <dt>
    [1] structure_to_dump
  </dt>
  <dd>
    
  </dd>
  <dt>
    [2] title, a string to prepended to the tree (optional)
  </dt>
  <dd>
    
  </dd>
  <dt>
    [3] overrides (optional)
  </dt>
  <dd>
    
  </dd>

</dl>
<p>  print DumpTree($s, "title", MAX_DEPTH =&gt; 1) ;</p><p><strong>DumpTrees</strong> uses the configuration variables defined above. It takes the following arguments</p>
<dl class='dl-vertical'>
  <dt>
    [1] One or more array references containing
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    [a] structure_to_dump
  </dt>
  <dd>
    
  </dd>
  <dt>
    [b] title, a string to prepended to the tree (optional)
  </dt>
  <dd>
    
  </dd>
  <dt>
    [c] overrides (optional)
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>
  <dt>
    [2] overrides (optional)
  </dt>
  <dd>
    
  </dd>

</dl>
<p>  print DumpTrees           (             [$s, "title", MAX_DEPTH =&gt; 1]           , [$s2, "other_title", DISPLAY_ADDRESS =&gt; 0]           , USE_ASCII =&gt; 1           , MAX_DEPTH =&gt; 5           ) ;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Bugs</h2>
        <div class="sectioncontent">
<p>None that I know of in this release but plenty, lurking in the dark corners, waiting to be found.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Examples</h2>
        <div class="sectioncontent">
<p>Four examples files are included in the distribution.</p><p><em>usage.pl</em> shows you how you can use <strong>Data::TreeDumper</strong>.</p><p><em>filters.pl</em> shows you how you how to do advance filtering.</p><p><em>colors.pl</em> shows you how you how to colorize a dump.</p><p><em>try_it.pl</em> is meant as a scratch pad for you to try <strong>Data::TreeDumper</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEPENDENCY</h2>
        <div class="sectioncontent">
<p><strong>Text::Wrap</strong>.</p><p><strong>Term::Size</strong> or <strong>Win32::Console</strong>.</p><p>Optional <strong>Devel::Size</strong> if you want Data::TreeDumper to show perl sizes for the tree elements.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORT</h2>
        <div class="sectioncontent">
<p><em>DumpTree</em>, <em>DumpTrees</em> and  <em>CreateChainingFilter</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Khemir Nadim ibn Hamouda. &lt;nadim@khemir.net&gt;</p><p>Thanks to Ed Avis for showing interest and pushing me to re-write the documentation.</p><p>  Copyright (c) 2003-2010 Nadim Ibn Hamouda el Khemir. All rights   reserved.  This program is free software; you can redis-   tribute it and/or modify it under the same terms as Perl   itself.</p><p>If you find any value in this module, mail me!  All hints, tips, flames and wishes are welcome at &lt;nadim@khemir.net&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Data::TreeDumper&hellip;</h2>
        <div class="sectioncontent">
<p><strong>Data::TreeDumper::00</strong>. <strong>Data::Dumper</strong>.</p><p><strong>Data::TreeDumper::Renderer::DHTML</strong>.</p><p><strong>Devel::Size::Report</strong>.<strong>Devel::Size</strong>.</p><p><strong>\s-1PBS\s0</strong>: the Perl Build System from which <strong>Data::TreeDumper</strong> was extracted.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Data::Transformer.3pm.html"><span aria-hidden="true">&larr;</span> Data::Transformer.3pm: Traverse a data structure, altering it in place</a></li>
   <li class="next"><a href="Data::TreeDumper::Renderer::DHTML.3pm.html">Data::TreeDumper::Renderer::DHTML.3pm: Dhtml renderer for data::treedumper <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

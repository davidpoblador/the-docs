<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::XQL::Tutorial: Describes the xql query syntax</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Describes the xql query syntax">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::XQL::Tutorial (3pm) manual">
  <meta name="twitter:description" content="Describes the xql query syntax">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-xql-perl-XML::XQL::Tutorial-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::XQL::Tutorial.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::XQL::Tutorial (3pm) manual" />
  <meta property="og:description" content="Describes the xql query syntax" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-xql-perl-XML::XQL::Tutorial-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::XQL::Tutorial<small> (3pm)</small></h1>
        <p class="lead">Describes the xql query syntax</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::XQL::Tutorial.3pm.html">
      <span itemprop="name">XML::XQL::Tutorial: Describes the xql query syntax</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-xql-perl/">
      <span itemprop="name">libxml-xql-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::XQL::Tutorial.3pm.html">
      <span itemprop="name">XML::XQL::Tutorial: Describes the xql query syntax</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This document describes basic the features of the \s-1XML\s0 Query Language (\s-1XQL\s0.) A proposal for the \s-1XML\s0 Query Language (\s-1XQL\s0) specification was submitted to the \s-1XSL\s0 Working Group in September 1998. The spec can be found at &lt;http://www.w3.org/TandS/QL/QL98/pp/xql.html&gt;. Since it is only a proposal at this point, things may change, but it is very likely that the final version will be close to the proposal. Most of this document was copied straight from the spec.</p><p>See also the \s-1XML::XQL\s0 man page.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>\s-1XQL\s0 (\s-1XML\s0 Query Language) provides a natural extension to the \s-1XSL\s0 pattern language. It builds upon the capabilities \s-1XSL\s0 provides for identifying classes of nodes, by adding Boolean logic, filters, indexing into collections of nodes, and more.</p><p>\s-1XQL\s0 is designed specifically for \s-1XML\s0 documents. It is a general purpose query language, providing a single syntax that can be used for queries, addressing, and patterns. \s-1XQL\s0 is concise, simple, and powerful.</p><p>\s-1XQL\s0 is designed to be used in many contexts. Although it is a superset of \s-1XSL\s0 patterns, it is also applicable to providing links to nodes, for searching repositories, and for many other applications.</p><p>Note that the term \s-1XQL\s0 is a working term for the language described in this proposal. It is not their intent that this term be used permanently. Also, beware that another query language exists called XML-QL, which uses a syntax very similar to \s-1SQL\s0.</p><p>The \s-1XML::XQL\s0 module has added functionality to the \s-1XQL\s0 spec, called <em>\s-1XQL+\s0</em>. To allow only \s-1XQL\s0 functionality as described in the spec, use the XML::XQL::Strict module. Note that the \s-1XQL\s0 spec makes the distinction between core \s-1XQL\s0 and \s-1XQL\s0 extensions. This implementation makes no distinction and the Strict module, therefore, implements everything described in the \s-1XQL\s0 spec. See the \s-1XML::XQL\s0 man page for more information about the Strict module. This tutorial will clearly indicate when referring to \s-1XQL+\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">XQL Patterns</h2>
        <div class="sectioncontent">
<p>This section describes the core \s-1XQL\s0 notation. These features should be part of every \s-1XQL\s0 implementation, and serve as the base level of functionality for its use in different technologies.</p><p>The basic syntax for \s-1XQL\s0 mimics the \s-1URI\s0 directory navigation syntax, but instead of specifying navigation through a physical file structure, the navigation is through elements in the \s-1XML\s0 tree.</p><p>For example, the following \s-1URI\s0 means find the foo.jpg file within the bar directory:</p>
<pre>
     bar/foo.jpg
</pre>
<p>Similarly, in \s-1XQL\s0, the following means find the collection of fuz elements within baz elements:</p><p>     baz/fuz</p><p>Throughout this document you will find numerous samples. They refer to the data shown in the sample file at the end of this man page.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Context</h2>
        <div class="sectioncontent">
<p>A <em>context</em> is the set of nodes against which a query operates. For the entire query, which is passed to the XML::XQL::Query constructor through the <em>Expr</em> option, the context is the list of input nodes that is passed to the <em>query()</em> method.</p><p>\s-1XQL\s0 allows a query to select between using the current context as the input context and using the 'root context' as the input context. The 'root context' is a context containing only the root-most element of the document. When using \s-1XML::DOM\s0, this is the Document object.</p><p>By default, a query uses the current context. A query prefixed with '/' (forward slash) uses the root context. A query may optionally explicitly state that it is using the current context by using the './' (dot, forward slash) prefix. Both of these notations are analogous to the notations used to navigate directories in a file system.</p><p>The './' prefix is only required in one situation. A query may use the '//' operator to indicate recursive descent. When this operator appears at the beginning of the query, the initial '/' causes the recursive decent to perform relative to the root of the document or repository. The prefix './/' allows a query to perform a recursive descent relative to the current context.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all author elements within the current context. Since the period is really not used alone, this example forward-references other features:      ./author Note that this is equivalent to:      author Find the root element (bookstore) of this document:      /bookstore Find all author elements anywhere within the current document:      //author Find all books where the value of the style attribute on the book is equal to the value of the specialty attribute of the bookstore element at the root of the document:      book[/bookstore/@specialty = @style]</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Query Results</h2>
        <div class="sectioncontent">
<p>The collection returned by an \s-1XQL\s0 expression preserves document order, hierarchy, and identity, to the extent that these are defined. That is, a collection of elements will always be returned in document order without repeats. Note that the spec states that the order of attributes within an element is undefined, but that this implementation does keep attributes in document order. See the \s-1XML::XQL\s0 man page for more details regarding <em>Document Order</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Collections - 'element' and '.'</h2>
        <div class="sectioncontent">
<p>The collection of all elements with a certain tag name is expressed using the tag name itself. This can be qualified by showing that the elements are selected from the current context './', but the current context is assumed and often need not be noted explicitly.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all first-name elements. These examples are equivalent:      ./first-name</p><p>     first-name Find all unqualified book elements:      book Find all first.name elements:      first.name</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Selecting children and descendants - '/' and '//'</h2>
        <div class="sectioncontent">
<p>The collection of elements of a certain type can be determined using the path operators ('/' or '//'). These operators take as their arguments a collection (left side) from which to query elements, and a collection indicating which elements to select (right side). The child operator ('/')selects from immediate children of the left-side collection, while the descendant operator ('//') selects from arbitrary descendants of the left-side collection. In effect, the '//' can be thought of as a substitute for one or more levels of hierarchy. Note that the path operators change the context as the query is performed. By stringing them together users can 'drill down' into the document.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all first-name elements within an author element. Note that the author children of the current context are found, and then first-name children are found relative to the context of the author elements:      author/first-name Find all title elements, one or more levels deep in the bookstore (arbitrary descendants):      bookstore//title Note that this is different from the following query, which finds all title elements that are grandchildren of bookstore elements:      bookstore/*/title Find emph elements anywhere inside book excerpts, anywhere inside the bookstore:      bookstore//book/excerpt//emph Find all titles, one or more levels deep in the current context. Note that this situation is essentially the only one where the period notation is required:      .//title</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Collecting element children - '*'</h2>
        <div class="sectioncontent">
<p>An element can be referenced without using its name by substituting the '*' collection. The '*' collection returns all elements that are children of the current context, regardless of their tag name.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all element children of author elements:      author/* Find all last-names that are grand-children of books:      book/*/last-name Find the grandchildren elements of the current context:      */* Find all elements with specialty attributes. Note that this example uses subqueries, which are covered in Filters, and attributes, which are discussed in Finding an attribute:      *[@specialty]</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Finding an attribute - '@'</h2>
        <div class="sectioncontent">
<p>Attribute names are preceded by the '@' symbol. \s-1XQL\s0 is designed to treat attributes and sub-elements impartially, and capabilities are equivalent between the two types wherever possible.</p><p>Note: attributes cannot contain subelements. Thus, attributes cannot have path operators applied to them in a query. Such expressions will result in a syntax error. The \s-1XQL\s0 spec states that attributes are inherently unordered and indices cannot be applied to them, but this implementation allows it.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find the style attribute of the current element context:      @style Find the exchange attribute on price elements within the current context:      price/@exchange The following example is not valid:      price/@exchange/total Find all books with style attributes. Note that this example uses subqueries, which are covered in Filters:      book[@style] Find the style attribute for all book elements:      book/@style</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">XQL Literals</h2>
        <div class="sectioncontent">
<p>\s-1XQL\s0 query expressions may contain literal values (i.e. constants.) Numbers (integers and floats) are wrapped in XML::XQL::Number objects and strings in XML::XQL::Text objects. Booleans (as returned by <em>true()</em> and <em>false()</em>) are wrapped in XML::XQL::Boolean objects.</p><p>Strings must be enclosed in single or double quotes. Since \s-1XQL\s0 does not allow escaping of special characters, it's impossible to create a string with both a single and a double quote in it. To remedy this, \s-1XQL+\s0 has added the q// and qq// string delimiters which behave just like they do in Perl.</p><p>For Numbers, exponential notation is not allowed. Use the \s-1XQL+\s0 function <em>eval()</em> to circumvent this problem. See \s-1XML::XQL\s0 man page for details.</p><p>The empty list or undef is represented by [] (i.e. reference to empty array) in this implementation.</p>
<dl class='dl-vertical'>
  <dt>
    Example
  </dt>
  <dd>
    <p>Integer Numbers:      234      -456 Floating point Numbers:      1.23      -0.99 Strings:      "some text with &apos;single&apos; quotes"      &apos;text with "double" quotes&apos; Not allowed:      1.23E-4         (use eval("1.23E-4", "Number") in XQL+)</p><p>     "can&apos;t use &#92;"double &#92;"quotes"  (use q/can&apos;t use "double" quotes/ in XQL+)</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Grouping - '()'</h2>
        <div class="sectioncontent">
<p>Parentheses can be used to group collection operators for clarity or where the normal precedence is inadequate to express an operation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Filters - '[]'</h2>
        <div class="sectioncontent">
<p>Constraints and branching can be applied to any collection by adding a filter clause '[ ]' to the collection. The filter is analogous to the \s-1SQL\s0 \s-1WHERE\s0 clause with \s-1ANY\s0 semantics. The filter contains a query within it, called the subquery. The subquery evaluates to a Boolean, and is tested for each element in the collection. Any elements in the collection failing the subquery test are omitted from the result collection.</p><p>For convenience, if a collection is placed within the filter, a Boolean \s-1TRUE\s0 is generated if the collection contains any members, and a \s-1FALSE\s0 is generated if the collection is empty. In essence, an expression such as author/degree implies a collection-to-Boolean conversion function like the following mythical 'there-exists-a' method.</p><p>     author[.there-exists-a(degree)]</p><p>Note that any number of filters can appear at a given level of an expression. Empty filters are not allowed.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all books that contain at least one excerpt element:      book[excerpt] Find all titles of books that contain at least one excerpt element:      book[excerpt]/title Find all authors of books where the book contains at least one excerpt, and the author has at least one degree:      book[excerpt]/author[degree] Find all books that have authors with at least one degree:      book[author/degree] Find all books that have an excerpt and a title:      book[excerpt][title]</p>
  </dd>

</dl>
<h3>Any and all semantics - '$any$' and '$all$'</h3>
<p>Users can explicitly indicate whether to use any or all semantics through the $any$ and $all$ keywords.</p><p>$any$ flags that a condition will hold true if any item in a set meets that condition. $all$ means that all elements in a set must meet the condition for the condition to hold true.</p><p>$any$ and $all$ are keywords that appear before a subquery expression within a filter.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all author elements where one of the last names is Bob:      author[last-name = &apos;Bob&apos;]</p><p>     author[$any$ last-name = &apos;Bob&apos;] Find all author elements where none of the last-name elements are Bob:      author[$all$ last-name != &apos;Bob&apos;] Find all author elements where the first last name is Bob:      author[last-name[0] = &apos;Bob&apos;]</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Indexing into a collection - '[]' and '$to$'</h2>
        <div class="sectioncontent">
<p>\s-1XQL\s0 makes it easy to find a specific node within a set of nodes. Simply enclose the index ordinal within square brackets. The ordinal is 0 based.</p><p>A range of elements can be returned. To do so, specify an expression rather than a single value inside of the subscript operator (square brackets). Such expressions can be a comma separated list of any of the following:</p><p>  n             Returns the nth element   -n            Returns the element that is n-1 units from the last element.                 E.g., -1 means the last element. -2 is the next to last element.   m $to$ n      Returns elements m through n, inclusive</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find the first author element:      author[0] Find the third author element that has a first-name:      author[first-name][2] Note that indices are relative to the parent. In other words, consider the following data:      &lt;x&gt;        &lt;y/&gt;        &lt;y/&gt;      &lt;/x&gt;      &lt;x&gt;        &lt;y/&gt;        &lt;y/&gt;      &lt;/x&gt; The following expression will return the first y from each of the x's:      x/y[0] The following will return the first y from the entire set of y's within x's:      (x/y)[0] The following will return the first y from the first x:      x[0]/y[0] Find the first and fourth author elements:      author[0,3] Find the first through fourth author elements:      author[0 $to$ 3] Find the first, the third through fifth, and the last author elements:      author[0, 2 $to$ 4, -1] Find the last author element:      author[-1]</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Boolean Expressions</h2>
        <div class="sectioncontent">
<p>Boolean expressions can be used within subqueries. For example, one could use Boolean expressions to find all nodes of a particular value, or all nodes with nodes in particular ranges. Boolean expressions are of the form ${op}$, where {op} may be any expression of the form {b|a} - that is, the operator takes lvalue and rvalue arguments and returns a Boolean result.</p><p>Note that the \s-1XQL\s0 Extensions section defines additional Boolean operations.</p><h3>Boolean \s-1AND\s0 and \s-1OR\s0 - '$and$' and '$or$'</h3>
<p>$and$ and $or$ are used to perform Boolean ands and ors.</p><p>The Boolean operators, in conjunction with grouping parentheses, can be used to build very sophisticated logical expressions.</p><p>Note that spaces are not significant and can be omitted, or included for clarity as shown here.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all author elements that contain at least one degree and one award.      author[degree $and$ award] Find all author elements that contain at least one degree or award and at least one publication.      author[(degree $or$ award) $and$ publication]</p>
  </dd>

</dl>

<h3>Boolean \s-1NOT\s0 - '$not$'</h3>
<p>$not$ is a Boolean operator that negates the value of an expression within a subquery.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all author elements that contain at least one degree element and that contain no publication elements.      author[degree $and$ $not$ publication] Find all author elements that contain publications elements but do not contain either degree elements or award elements.      author[$not$ (degree $or$ award) $and$ publication]</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Union and intersection - '$union$', '|' and '$intersect$'</h2>
        <div class="sectioncontent">
<p>The $union$ operator (shortcut is '|') returns the combined set of values from the query on the left and the query on the right. Duplicates are filtered out. The resulting list is sorted in document order.</p><p>Note: because this is a union, the set returned may include 0 or more elements of each element type in the list. To restrict the returned set to nodes that contain at least one of each of the elements in the list, use a filter, as discussed in Filters.</p><p>The $intersect$ operator returns the set of elements in common between two sets.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all first-names and last-names:      first-name $union$ last-name Find all books and magazines from a bookstore:      bookstore/(book | magazine) Find all books and all authors:      book $union$ book/author Find the first-names, last-names, or degrees from authors within either books or magazines:      (book $union$ magazine)/author/(first-name $union$ last-name $union$ degree) Find all books with author/first-name equal to 'Bob' and all magazines with price less than 10:      book[author/first-name = &apos;Bob&apos;] $union$ magazine[price $lt$ 10]</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Equivalence - '$eq$', '=', '$ne$' and '!='</h2>
        <div class="sectioncontent">
<p>The '=' sign is used for equality; '!=' for inequality. Alternatively, $eq$ and  $ne$ can be used for equality and inequality.</p><p>Single or double quotes can be used for string delimiters in expressions. This makes it easier to construct and pass \s-1XQL\s0 from within scripting languages.</p><p>For comparing values of elements, the <em>value()</em> method is implied. That is, last-name &lt; 'foo' really means last-name!<em>value()</em> &lt; 'foo'.</p><p>Note that filters are always with respect to a context. That is, the expression book[author] means for every book element that is found, see if it has an author subelement. Likewise, book[author = 'Bob'] means for every book element that is found, see if it has a subelement named author whose value is 'Bob'. One can examine the value of the context as well, by using the . (period). For example, book[. = 'Trenton'] means for every book that is found, see if its value is 'Trenton'.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all author elements whose last name is Bob:      author[last-name = &apos;Bob&apos;]</p><p>     author[last-name $eq$ &apos;Bob&apos;] Find all authors where the from attribute is not equal to 'Harvard':      degree[@from != &apos;Harvard&apos;]</p><p>     degree[@from $ne$ &apos;Harvard&apos;] Find all authors where the last-name is the same as the /guest/last-name element:      author[last-name = /guest/last-name] Find all authors whose text is 'Matthew Bob':      author[. = &apos;Matthew Bob&apos;]</p><p>     author = &apos;Matthew Bob&apos;</p>
  </dd>

</dl>
<h3>Comparison - '&lt;', '&lt;=', '&gt;', '&gt;=', '$lt', '$ilt$' etc.</h3>
<p>A set of binary comparison operators is available for comparing numbers and strings and returning Boolean results. $lt$, $le$, $gt$, $ge$ are used for less than, less than or equal, greater than, or greater than or equal. These same operators are also available in a case insensitive form: $ieq$, $ine$, $ilt$, $ile$, $igt$, $ige$.</p><p>&lt;, &lt;=, &gt; and &gt;= are allowed short cuts for $lt$, $le$, $gt$ and $ge$.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all author elements whose last name is bob and whose price is &gt; 50      author[last-name = &apos;Bob&apos; $and$ price $gt$ 50] Find all authors where the from attribute is not equal to 'Harvard':      degree[@from != &apos;Harvard&apos;] Find all authors whose last name begins with 'M' or greater:      author[last-name $ge$ &apos;M&apos;] Find all authors whose last name begins with 'M', 'm' or greater:      author[last-name $ige$ &apos;M&apos;] Find the first three books:      book[index() $le$ 2] Find all authors who have more than 10 publications:      author[publications!count() $gt$ 10]</p>
  </dd>

</dl>

<h3>\s-1XQL+\s0 Match operators - '$match$', '$no_match$', '=~' and '!~'</h3>
<p>\s-1XQL+\s0 defines additional operators for pattern matching. The $match$ operator (shortcut is '=~') returns \s-1TRUE\s0 if the lvalue matches the pattern described by the rvalue. The $no_match$ operator (shortcut is '!~') returns \s-1FALSE\s0 if they match. Both lvalue and rvalue are first cast to strings.</p><p>The rvalue string should have the syntax of a Perl rvalue, that is the delimiters should be included and modifiers are allowed. When using delimiters other than slashes '/', the 'm' should be included. The rvalue should be a string, so don't forget the quotes! (Or use the q// or qq// delimiters in \s-1XQL+\s0, see \s-1XML::XQL\s0 man page.)</p><p>Note that you can't use the Perl substitution operator s/// here. Try using the \s-1XQL+\s0 <em>subst()</em> function instead.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all authors whose name contains bob or Bob:     author[first-name =~ &apos;/[Bb]ob/&apos;] Find all book titles that don't contain 'Trenton' (case-insensitive):     book[title !~ &apos;m!trenton!i&apos;]</p>
  </dd>

</dl>

<h3>Oher \s-1XQL+\s0 comparison operators - '$isa', '$can$'</h3>
<p>See the \s-1XML::XQL\s0 man page for other operators available in \s-1XQL+\s0.</p>
<h3>Comparisons and vectors</h3>
<p>The lvalue of a comparison can be a vector or a scalar. The rvalue of a comparison must be a scalar or a value that can be cast at runtime to a scalar.</p><p>If the lvalue of a comparison is a set, then any (exists) semantics are used for the comparison operators. That is, the result of a comparison is true if any item in the set meets the condition.</p>
<h3>Comparisons and literals</h3>
<p>The spec states that the lvalue of an expression cannot be a literal. That is, <em>'1' = a</em> is not allowed. This implementation allows it, but it's not clear how useful that is.</p>
<h3>Casting of literals during comparison</h3>
<p>Elements, attributes and other \s-1XML\s0 node types are casted to strings (Text) by applying the <em>value()</em> method. The <em>value()</em> method calls the <em>text()</em> method by default, but this behavior can be altered by the user, so the <em>value()</em> method may return other \s-1XQL\s0 data types.</p><p>When two values are compared, they are first casted to the same type. See the \s-1XML::XQL\s0 man page for details on casting.</p><p>Note that the \s-1XQL\s0 spec is not very clear on how values should be casted for comparison. Discussions with the authors of the \s-1XQL\s0 spec revealed that there was some disagreement and their implementations differed on this point. This implementation is closest to that of Joe Lapp from webMethods, Inc.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Methods - '\fImethod()\fP' or 'query!\fImethod()\fP'</h2>
        <div class="sectioncontent">
<p>\s-1XQL\s0 makes a distinction between functions and methods. See the \s-1XML::XQL\s0 man page for details.</p><p>\s-1XQL\s0 provides methods for advanced manipulation of collections. These methods provide specialized collections of nodes (see Collection methods), as well as information about sets and nodes.</p><p>Methods are of the form <em>method(arglist)</em></p><p>Consider the query book[author]. It will find all books that have authors. Formally, we call the book corresponding to a particular author the reference node for that author. That is, every author element that is examined is an author for one of the book elements. (See the Annotated \s-1XQL\s0 \s-1BNF\s0 Appendix for a much more thorough definition of reference node and other terms. See also the \s-1XML::XQL\s0 man page.) Methods always apply to the reference node.</p><p>For example, the <em>text()</em> method returns the text contained within a node, minus any structure. (That is, it is the concatenation of all text nodes contained with an element and its descendants.) The following expression will return all authors named 'Bob':</p><p>     author[text() = &apos;Bob&apos;]</p><p>The following will return all authors containing a first-name child whose text is 'Bob':</p><p>     author[first-name!text() = &apos;Bob&apos;]</p><p>The following will return all authors containing a child named Bob:</p><p>     author[*!text() = &apos;Bob&apos;]</p><p>Method names are case sensitive. See the \s-1XML::XQL\s0 man page on how to define your own methods and functions.</p><h3>Information methods</h3>
<p>The following methods provide information about nodes in a collection. These methods return strings or numbers, and may be used in conjunction with comparison operators within subqueries.</p>
<dl class='dl-vertical'>
  <dt>
    Method: <em>text()</em>
  </dt>
  <dd>
    <p>The <em>text()</em> method concatenates text of the descendents of a node, normalizing white space along the way. White space will be preserved for a node if the node has the xml:space attribute set to 'preserve', or if the nearest ancestor with the xml:space attribute has the attribute set to 'preserve'. When white space is normalized, it is normalized across the entire string. Spaces are used to separate the text between nodes. When entity references are used in a document, spacing is not inserted around the entity refs when they are expanded. In this implementation, the method may receive an optional parameter to indicate whether the <em>text()</em> of Element nodes should include the <em>text()</em> of its Element descendants. See \s-1XML::XQL\s0 man page for details. Examples: Find the authors whose last name is 'Bob':      author[last-name!text() = &apos;Bob&apos;] Note this is equivalent to:      author[last-name = &apos;Bob&apos;] Find the authors with value 'Matthew Bob':      author[text() = &apos;Matthew Bob&apos;]</p><p>     author[. = &apos;Matthew Bob&apos;]</p><p>     author = &apos;Matthew Bob&apos;</p>
  </dd>
  <dt>
    Method: <em>rawText()</em>
  </dt>
  <dd>
    <p>The <em>rawText()</em> method is similar to the <em>text()</em> method, but it does not normalize whitespace. In this implementation, the method may receive an optional parameter to indicate whether the <em>rawText()</em> of Element nodes should include the <em>rawText()</em> of its Element descendants. See \s-1XML::XQL\s0 man page for details.</p>
  </dd>
  <dt>
    Method: <em>value()</em>
  </dt>
  <dd>
    <p>Returns a type cast version of the value of a node. If no data type is provided, returns the same as <em>text()</em>.</p>
<dl class='dl-vertical'>
  <dt>
    Shortcuts
  </dt>
  <dd>
    <p>For the purposes of comparison, value( )is implied if omitted. In other words, when two items are compared, the comparison is between the value of the two items. Remember that in absence of type information, <em>value()</em> returns <em>text()</em>. The following examples are equivalent:      author[last-name!value() = &apos;Bob&apos; $and$ first-name!value() = &apos;Joe&apos;]</p><p>     author[last-name = &apos;Bob&apos; $and$ first-name = &apos;Joe&apos;]</p><p>     price[@intl!value() = &apos;canada&apos;]</p><p>     price[@intl = &apos;canada&apos;]</p>
  </dd>

</dl>

  </dd>
  <dt>
    Method: <em>nodeType()</em>
  </dt>
  <dd>
    <p>Returns a number to indicate the type of the node. The values were based on the node type values in the \s-1DOM:\s0         element         1         attribute       2         text            3         entity          6       (not in XQL spec)         PI              7         comment         8         document        9         doc. fragment   10      (not in XQL spec)         notation        11      (not in XQL spec) Note that in \s-1XQL\s0, CDATASection nodes and EntityReference nodes also return 3, whereas in the \s-1DOM\s0 CDATASection returns 4 and EntityReference returns 5. Use the \s-1XQL+\s0 method <em>DOM_nodeType()</em> to get \s-1DOM\s0 node type values. See the \s-1XML::DOM\s0 man page for node type values of nodes not mentioned here.</p>
  </dd>
  <dt>
    Method: nodeTypeString
  </dt>
  <dd>
    <p>Returns the name of the node type in lowercase or an empty string. The following node types are currently supported 1 (element), 2 (attribute), 3 (text), 7 (processing_instruction), 8 (comment), 9 (document)</p>
  </dd>
  <dt>
    Method: <em>nodeName()</em>
  </dt>
  <dd>
    <p>Returns the tag name for Element nodes and the attribute name of attributes.</p>
  </dd>

</dl>

<h3>Collection index methods</h3>

<dl class='dl-vertical'>
  <dt>
    Method: <em>index()</em>
  </dt>
  <dd>
    <p>Returns the index of the value within the search context (i.e. with the input list of the subquery.) This is not necessarily the same as the index of a node within its parent node. Note that the \s-1XQL\s0 spec doesn't explain it well.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find the first 3 degrees:      degree[index() $lt$ 3] Note that it skips over other nodes that may exist between the degree elements. Consider the following data:      &lt;x&gt;        &lt;y/&gt;        &lt;y/&gt;      &lt;/x&gt;      &lt;x&gt;        &lt;y/&gt;        &lt;y/&gt;      &lt;/x&gt; The following expression will return the first y from each x:      x/y[index() = 0] This could also be accomplished by (see Indexing into a Collection):      x/y[0]</p>
  </dd>

</dl>

  </dd>
  <dt>
    Method: <em>end()</em>
  </dt>
  <dd>
    <p>The <em>end()</em> method returns true for the last element in the search context. Again, the \s-1XQL\s0 spec does not explain it well.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find the last book:      book[end()] Find the last author for each book:      book/author[end()] Find the last author from the entire set of authors of books:      (book/author)[end()]</p>
  </dd>

</dl>

  </dd>

</dl>

<h3>Aggregate methods</h3>

<dl class='dl-vertical'>
  <dt>
    Method: count( [\s-1QUERY\s0] )
  </dt>
  <dd>
    <p>Returns the number of values inside the search context. In \s-1XQL+\s0, when the optional \s-1QUERY\s0 parameter is supplied, it returns the number of values returned by the \s-1QUERY\s0.</p>
  </dd>

</dl>

<h3>Namespace methods</h3>
<p>The following methods can be applied to a node to return namespace information.</p>
<dl class='dl-vertical'>
  <dt>
    Method: <em>baseName()</em>
  </dt>
  <dd>
    <p>Returns the local name portion of the node, excluding the prefix. Local names are defined only for element nodes and attribute nodes. The local name of an element node is the local portion of the node's element type name. The local name of an attribute node is the local portion of the node's attribute name. If a local name is not defined for the reference node, the method evaluates to the empty set.</p>
  </dd>
  <dt>
    Method: <em>namespace()</em>
  </dt>
  <dd>
    <p>Returns the \s-1URI\s0 for the namespace of the node. Namespace URIs are defined only for element nodes and attribute nodes. The namespace \s-1URI\s0 of an element node is the namespace \s-1URI\s0 associated with the node's element type name. The namespace \s-1URI\s0 of an attribute node is the namespace \s-1URI\s0 associated with the node's attribute name. If a namespace \s-1URI\s0 is not defined for the reference node, the method evaluates to the empty set.</p>
  </dd>
  <dt>
    Method: <em>prefix()</em>
  </dt>
  <dd>
    <p>Returns the prefix for the node. Namespace prefixes are defined only for element nodes and attribute nodes. The namespace prefix of an element node is the shortname for the namespace of the node's element type name. The namespace prefix of an attribute node is the shortname for the namespace of the node's attribute name. If a namespace prefix is not defined for the reference node, the method evaluates to the empty set. The spec states: A node's namespace prefix may be defined within the query expression, within the document under query, or within both the query expression and the document under query. If it is defined in both places the prefixes may not agree. In this case, the prefix assigned by the query expression takes precedence. In this implementation you cannot define the namespace for a query, so this can never happen.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all unqualified book elements. Note that this does not return my:book elements:      book Find all book elements with the prefix 'my'. Note that this query does not return unqualified book elements:      my:book Find all book elements with a 'my' prefix that have an author subelement:      my:book[author] Find all book elements with a 'my' prefix that have an author subelement with a my prefix:      my:book[my:author] Find all elements with a prefix of 'my':      my:* Find all book elements from any namespace:      *:book Find any element from any namespace:      * Find the style attribute with a 'my' prefix within a book element:      book/@my:style</p>
  </dd>

</dl>
<p>All attributes of an element can be returned using @*. This is potentially useful for applications that treat attributes as fields in a record.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find all attributes of the current element context:      @* Find style attributes from any namespace:      @*:style Find all attributes from the 'my' namespace, including unqualified attributes on elements from the 'my' namespace:      @my:*</p>
  </dd>

</dl>

  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Functions</h2>
        <div class="sectioncontent">
<p>This section defines the functions of \s-1XQL\s0. The spec states that: \s-1XQL\s0 defines two kinds of functions: collection functions and pure functions. Collection functions use the search context of the Invocation instance, while pure functions ignore the search context, except to evaluate the function's parameters. A collection function evaluates to a subset of the search context, and a pure function evaluates to either a constant value or to a value that depends only on the function's parameters.</p><p>Don't worry if you don't get it. Just use them!</p><h3>Collection functions</h3>
<p>The collection functions provide access to the various types of nodes in a document. Any of these collections can be constrained and indexed. The collections return the set of children of the reference node meeting the particular restriction.</p>
<dl class='dl-vertical'>
  <dt>
    Function: <em>textNode()</em>
  </dt>
  <dd>
    <p>The collection of text nodes.</p>
  </dd>
  <dt>
    Function: <em>comment()</em>
  </dt>
  <dd>
    <p>The collection of comment nodes.</p>
  </dd>
  <dt>
    Function: <em>pi()</em>
  </dt>
  <dd>
    <p>The collection of processing instruction nodes.</p>
  </dd>
  <dt>
    Function: element( [\s-1NAME\s0] )
  </dt>
  <dd>
    <p>The collection of all element nodes. If the optional text parameter is provided, it only returns element children matching that particular name.</p>
  </dd>
  <dt>
    Function: attribute( [\s-1NAME\s0] )
  </dt>
  <dd>
    <p>The collection of all attribute nodes. If the optional text parameter is provided, it only returns attributes matching that particular name.</p>
  </dd>
  <dt>
    Function: <em>node()</em>
  </dt>
  <dd>
    <p>The collection of all non-attribute nodes.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find the second text node in each p element in the current context:      p/textNode()[1] Find the second comment anywhere in the document. See Context for details on setting the context to the document root:      //comment()[1]</p>
  </dd>

</dl>

  </dd>

</dl>

<h3>Other \s-1XQL\s0 Functions</h3>

<dl class='dl-vertical'>
  <dt>
    Function: ancestor(\s-1QUERY\s0)
  </dt>
  <dd>
    <p>Finds the nearest ancestor matching the provided query. It returns either a single element result or an empty set []. Note that this node is never the reference node itself.</p>
<dl class='dl-vertical'>
  <dt>
    Examples:
  </dt>
  <dd>
    <p>Find the nearest book ancestor of the current element:      ancestor(book) Find the nearest ancestor author element that is contained in a book element:      ancestor(book/author)</p>
  </dd>

</dl>

  </dd>
  <dt>
    Function: id(\s-1NAME\s0)
  </dt>
  <dd>
    <p>Pure function that evaluates to a set. The set contains an element node that has an 'id' attribute whose value is identical to the string that the Text parameter quotes. The element node may appear anywhere within the document under query. If more than one element node meets these criteria, the function evaluates to a set that contains the first node appearing in a document ordering of the nodes.</p>
  </dd>
  <dt>
    Function: <em>true()</em> and <em>false()</em>
  </dt>
  <dd>
    <p>Pure functions that each evaluate to a Boolean. \*(L"<em>true()</em>\*(R" evaluates to 'true', and \*(L"<em>false()</em>\*(R" evaluates to 'false'. These functions are useful in expressions that are constructed using entity references or variable substitution, since they may replace an expression found in an instance of Subquery without violating the syntax required by the instance of Subquery. They return an object of type XML::XQL::Boolean.</p>
  </dd>
  <dt>
    Function: date(\s-1QUERY\s0)
  </dt>
  <dd>
    <p>\*(L"date\*(R" is a pure function that typecasts the value of its parameter to a set of dates. If the parameter matches a single string, the value of the function is a set containing a single date. If the parameter matches a \s-1QUERY\s0, the value of the function is a set of dates, where the set contains one date for each member of the set to which the parameter evaluates. \s-1XQL\s0 does not define the representation of the date value, nor does it define how the function translates parameter values into dates. This implementation uses the Date::Manip module to parse dates, which accepts almost any imaginable format. See \s-1XML::XQL\s0 to plug in your own Date implementation. Include the XML::XQL::Date package to add the \s-1XQL\s0 date type and the <em>date()</em> function, like this:  use XML::XQL::Date;</p>
  </dd>
  <dt>
    Perl builtin functions and other \s-1XQL+\s0 functions
  </dt>
  <dd>
    <p>\s-1XQL+\s0 provides \s-1XQL\s0 function wrappers for most Perl builtin functions. It also provides other cool functions like <em>subst()</em>, <em>map()</em>, and <em>eval()</em> that allow you to modify documents and embed perl code. If this is still not enough, you can add your own function and methods. See \s-1XML::XQL\s0 man page for details.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Sequence Operators - ';' and ';;'</h2>
        <div class="sectioncontent">
<p>The whitepaper 'The Design of \s-1XQL\s0' by Jonathan Robie, which can be found at &lt;http://www.texcel.no/whitepapers/xql-design.html&gt; describes the sequence operators ';;' (precedes) and ';' (immediately precedes.) Although these operators are not included in the \s-1XQL\s0 spec, I thought I'd add them anyway.</p><h3>Immediately Precedes - ';'</h3>

<dl class='dl-vertical'>
  <dt>
    Example:
  </dt>
  <dd>
    <p>With the following input:  &lt;TABLE&gt;   &lt;ROWS&gt;    &lt;TR&gt;     &lt;TD&gt;Shady Grove&lt;/TD&gt;     &lt;TD&gt;Aeolian&lt;/TD&gt;    &lt;/TR&gt;    &lt;TR&gt;     &lt;TD&gt;Over the River, Charlie&lt;/TD&gt;     &lt;TD&gt;Dorian&lt;/TD&gt;    &lt;/TR&gt;   &lt;/ROWS&gt;  &lt;/TABLE&gt; Find the \s-1TD\s0 node that contains \*(L"Shady Grove\*(R" and the \s-1TD\s0 node that immediately follows it:         //(TD="Shady Grove" ; TD)</p>
  </dd>

</dl>
<p>Note that in \s-1XML::DOM\s0 there is actually a text node with whitespace between the two \s-1TD\s0 nodes, but those are ignored by this operator, unless the text node has 'xml:space' set to 'preserve'. See ??? for details.</p>
<h3>Precedes - ';;'</h3>

<dl class='dl-vertical'>
  <dt>
    Example:
  </dt>
  <dd>
    <p>With the following input (from Hamlet):  &lt;SPEECH&gt;   &lt;SPEAKER&gt;MARCELLUS&lt;/SPEAKER&gt;   &lt;LINE&gt;Tis gone!&lt;/LINE&gt;   &lt;STAGEDIR&gt;Exit Ghost&lt;/STAGEDIR&gt;   &lt;LINE&gt;We do it wrong, being so majestical,&lt;/LINE&gt;   &lt;LINE&gt;To offer it the show of violence;&lt;/LINE&gt;   &lt;LINE&gt;For it is, as the air, invulnerable,&lt;/LINE&gt;   &lt;LINE&gt;And our vain blows malicious mockery.&lt;/LINE&gt;  &lt;/SPEECH&gt; Return the \s-1STAGEDIR\s0 and all the LINEs that follow it:         SPEECH//( STAGEDIR ;; LINE ) Suppose an actor playing the ghost wants to know when to exit; that is, he wants to know who says what line just before he is supposed to exit. The line immediately precedes the stagedir, but the speaker may occur at any time before the line. In this query, we will use the \*(L"precedes\*(R" operator (\*(L";;\*(R") to identify a speaker that precedes the line somewhere within a speech. Our ghost can find the required information with the following query, which selects the speaker, the line, and the stagedir:         SPEECH//( SPEAKER ;; LINE ; STAGEDIR="Exit Ghost")</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Operator Precedence</h2>
        <div class="sectioncontent">
<p>The following table lists operators in precedence order, highest precedence first, where operators of a given row have the same precedence. The table also lists the associated productions:</p><p>        Production      Operator(s)         ----------      -----------         Grouping        ( )         Filter          [ ]         Subscript       [ ]         Bang            !         Path            / //         Match           $match$ $no_match$ =~ !~ (XQL+ only)         Comparison      = != &lt; &lt;= &gt; &gt;= $eq$ $ne$ $lt$ $le$ $gt$                         $ge$ $ieq$ $ine$ $ilt$ $ile$ $igt$ $ige$         Intersection    $intersect$         Union           $union$ |         Negation        $not$         Conjunction     $and$         Disjunction     $or$         Sequence        ; ;;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Sample XML Document - bookstore.xml</h2>
        <div class="sectioncontent">
<p>This file is also stored in samples/bookstore.xml that comes with the \s-1XML::XQL\s0 distribution.</p><p> &lt;?xml version=&apos;1.0&apos;?&gt;  &lt;!-- This file represents a fragment of a book store inventory database --&gt;  &lt;bookstore specialty=&apos;novel&apos;&gt;    &lt;book style=&apos;autobiography&apos;&gt;      &lt;title&gt;Seven Years in Trenton&lt;/title&gt;      &lt;author&gt;        &lt;first-name&gt;Joe&lt;/first-name&gt;        &lt;last-name&gt;Bob&lt;/last-name&gt;        &lt;award&gt;Trenton Literary Review Honorable Mention&lt;/award&gt;      &lt;/author&gt;      &lt;price&gt;12&lt;/price&gt;    &lt;/book&gt;    &lt;book style=&apos;textbook&apos;&gt;      &lt;title&gt;History of Trenton&lt;/title&gt;      &lt;author&gt;        &lt;first-name&gt;Mary&lt;/first-name&gt;        &lt;last-name&gt;Bob&lt;/last-name&gt;        &lt;publication&gt;          Selected Short Stories of          &lt;first-name&gt;Mary&lt;/first-name&gt; &lt;last-name&gt;Bob&lt;/last-name&gt;        &lt;/publication&gt;      &lt;/author&gt;      &lt;price&gt;55&lt;/price&gt;    &lt;/book&gt;    &lt;magazine style=&apos;glossy&apos; frequency=&apos;monthly&apos;&gt;      &lt;title&gt;Tracking Trenton&lt;/title&gt;      &lt;price&gt;2.50&lt;/price&gt;      &lt;subscription price=&apos;24&apos; per=&apos;year&apos;/&gt;    &lt;/magazine&gt;    &lt;book style=&apos;novel&apos; id=&apos;myfave&apos;&gt;      &lt;title&gt;Trenton Today, Trenton Tomorrow&lt;/title&gt;      &lt;author&gt;        &lt;first-name&gt;Toni&lt;/first-name&gt;        &lt;last-name&gt;Bob&lt;/last-name&gt;        &lt;degree from=&apos;Trenton U&apos;&gt;B.A.&lt;/degree&gt;        &lt;degree from=&apos;Harvard&apos;&gt;Ph.D.&lt;/degree&gt;        &lt;award&gt;Pulizer&lt;/award&gt;        &lt;publication&gt;Still in Trenton&lt;/publication&gt;        &lt;publication&gt;Trenton Forever&lt;/publication&gt;      &lt;/author&gt;      &lt;price intl=&apos;canada&apos; exchange=&apos;0.7&apos;&gt;6.50&lt;/price&gt;      &lt;excerpt&gt;        &lt;p&gt;It was a dark and stormy night.&lt;/p&gt;        &lt;p&gt;But then all nights in Trenton seem dark and        stormy to someone who has gone through what        &lt;emph&gt;I&lt;/emph&gt; have.&lt;/p&gt;        &lt;definition-list&gt;          &lt;term&gt;Trenton&lt;/term&gt;          &lt;definition&gt;misery&lt;/definition&gt;        &lt;/definition-list&gt;      &lt;/excerpt&gt;    &lt;/book&gt;    &lt;my:book style=&apos;leather&apos; price=&apos;29.50&apos; xmlns:my=&apos;http://www.placeholder-name-here.com/schema/&apos;&gt;      &lt;my:title&gt;Who&apos;s Who in Trenton&lt;/my:title&gt;      &lt;my:author&gt;Robert Bob&lt;/my:author&gt;    &lt;/my:book&gt;  &lt;/bookstore&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::XQL::Tutorial&hellip;</h2>
        <div class="sectioncontent">
<p>The Japanese version of this document can be found on-line at &lt;http://member.nifty.ne.jp/hippo2000/perltips/xml/xql/tutorial.htm&gt;</p><p>\s-1XML::XQL\s0, XML::XQL::Date, XML::XQL::Query and \s-1XML::XQL::DOM\s0</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::XQL::Query.3pm.html"><span aria-hidden="true">&larr;</span> XML::XQL::Query.3pm: Creates an xql query evaluater from a xql expression</a></li>
   <li class="next"><a href="XML::XSLT.3pm.html">XML::XSLT.3pm: A perl module for processing xslt <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

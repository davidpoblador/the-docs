<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Aspect: Aspect-oriented programming (aop) for perl</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Aspect-oriented programming (aop) for perl">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Aspect (3pm) manual">
  <meta name="twitter:description" content="Aspect-oriented programming (aop) for perl">
  <meta name="twitter:image" content="https://www.carta.tech/images/libaspect-perl-Aspect-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Aspect.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Aspect (3pm) manual" />
  <meta property="og:description" content="Aspect-oriented programming (aop) for perl" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libaspect-perl-Aspect-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Aspect<small> (3pm)</small></h1>
        <p class="lead">Aspect-oriented programming (aop) for perl</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Aspect.3pm.html">
      <span itemprop="name">Aspect: Aspect-oriented programming (aop) for perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libaspect-perl/">
      <span itemprop="name">libaspect-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Aspect.3pm.html">
      <span itemprop="name">Aspect: Aspect-oriented programming (aop) for perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Aspect;

  # Run some code "Advice" before a particular function
  before {
      print "About to call create&#92;n";
  } call &apos;Person::create&apos;;

  # Run Advice after several methods and hijack their return values
  after {
      print "Called getter/setter " . $_-&gt;sub_name . "&#92;n";
      $_-&gt;return_value(undef);
  } call qr/^Person::[gs]et_/;

  # Run Advice conditionally based on multiple factors
  before {
      print "Calling a get method in void context within Tester::run_tests";
  } wantvoid
  & ( call qr/^Person::get_/ & ! call &apos;Person::get_not_trapped&apos; )
  & cflow &apos;Tester::run_tests&apos;;

  # Context-aware runtime hijacking of a method if certain condition is true
  around {
      if ( $_-&gt;self-&gt;customer_name eq &apos;Adam Kennedy&apos; ) {
          # Ensure I always have cash
          $_-&gt;return_value(&apos;One meeeelion dollars&apos;);
      } else {
          # Take a dollar off everyone else
          $_-&gt;proceed;
          $_-&gt;return_value( $_-&gt;return_value - 1 );
      }
  } call &apos;Bank::Account::balance&apos;;

  # Catch and handle unexpected exceptions in a function into a formal object
  after {
      $_-&gt;exception(
          Exception::Unexpected-&gt;new($_-&gt;exception)
      );
  } throwing()
  & ! throwing(&apos;Exception::Expected&apos;)
  & ! throwing(&apos;Exception::Unexpected&apos;);

  # Run Advice only on the outmost of a recursive series of calls
  around {
    print "Starting recursive child search&#92;n";
    $_-&gt;proceed;
    print "Finished recursive child search&#92;n";
  } call &apos;Person::find_child&apos; & highest;

  # Run Advice only during the current lexical scope
  SCOPE: {
      my $hook = before {
          print "About to call create&#92;n";
      } call &apos;Person::create&apos;;
      Person-&gt;create(&apos;Bob&apos;); # Advice will run
  }
  Person-&gt;create(&apos;Tom&apos;); # Advice won&apos;t run

  # Use a pre-packaged collection "Aspect" of Advice rules to change a class
  aspect Singleton =&gt; &apos;Foo::new&apos;;

  # Define debugger breakpoints with high precision and conditionality
  aspect Breakpoint =&gt; call qr/^Foo::.+::Bar::when_/ & wantscalar & highest;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<h3>What is Aspect-Oriented Programming?</h3>
<p>Aspect-Oriented Programming (\s-1AOP\s0) is a programming paradigm which aims to increase modularity by allowing the separation of \*(L"cross-cutting \*(R"concerns.</p><p>It includes programming methods and tools that support the modularization of concerns at the level of the source code, while \*(L"aspect-oriented software development\*(R" refers to a whole engineering discipline.</p><p>Aspect-Oriented Programming (\s-1AOP\s0) allows you to modularise code for issues that would otherwise be spread across many parts of a program and be problematic to both implement and maintain.</p><p>Logging exemplifies a crosscutting concern because a logging strategy necessarily affects every logged part of the system. Logging thereby \*(L"crosscuts\*(R" all logged classes and methods.</p><p>Typically, an aspect is scattered or tangled as code, making it harder to understand and maintain. It is scattered by virtue of the function (such as logging) being spread over a number of unrelated functions that might use its function, possibly in entirely unrelated systems</p><p>That means to change logging can require modifying all affected modules. Aspects become tangled not only with the mainline function of the systems in which they are expressed but also with each other. That means changing one concern entails understanding all the tangled concerns or having some means by which the effect of changes can be inferred.</p><p>Because Aspect-Oritented Programming moves this scattered code into a single module which is loaded as a single unit, another major benefit of this method is conditional compilation.</p><p>Features implemented via Aspects can be compiled and added to you program only in certain situations, and because of this Aspects are useful when debugging or testing large or complex programs.</p><p>Aspects can implement features necessary for correctness of programs such as reactivity or synchronisation, and can be used to add checking assertions to your or other people's modules.</p><p>They can cause code to emit useful side effects not considered by the original author of a module, without changing the original function of the module.</p><p>And, if necessary (although not recommended), they can do various types of \*(L"Monkey Patching\*(R", hijacking the functionality of some other module in an unexpected (by the original author) way so that the module acts differently when used in your program, when those changes might otherwise be dangerous or if encountered by other programs.</p><p>Aspects can be used to implement space or time optimisations. One popular use case of \s-1AOP\s0 is to add caching to a module or function that does not natively implement caching itself.</p><p>For more details on Aspect-Oriented Programming in general, http://en.wikipedia.org/wiki/Aspect-oriented_programming &lt;http://en.wikipedia.org/wiki/Aspect-oriented_programming&gt; and &lt;http://www.aosd.net&gt;.</p>
<h3>About This Implementation</h3>
<p>The Perl <strong>Aspect</strong> module tries to closely follow the terminology of the basic Java AspectJ project wherever possible and reasonable (&lt;http://eclipse.org/aspectj&gt;).</p><p>However due to the dynamic nature of the Perl language, several \*(C`AspectJ\*(C' features are useless for us: exception softening, mixin support, out-of-class method declarations, annotations, and others.</p><p>Currently the Perl <strong>Aspect</strong> module is focused exclusively on subroutine matching and wrapping.</p><p>It allows you to select collections of subroutines and conditions using a flexible pointcut language, and modify their behavior in any way you want.</p><p>In this regard it provides a similar set of functionality to the venerable Hook::LexWrap, but with much more precision and with much more control and maintainability as the complexity of the problems you are solving increases.</p><p>In addition, where the Java implementation of Aspect-Oriented Programming is limited to concepts expressable at compile time, the more fluid nature of Perl means that the <strong>Aspect</strong> module can weave in aspect code at run-time. Pointcuts in Perl can also take advantage of run-time information and Perl-specific features like closures to implement more sophisticated pointcuts than are possible in Java.</p><p>This allows the Perl implementation of Aspect-Oriented Programming to be stateful and adaptive in a way that Java cannot (although the added power can come with a significant speed cost if not used carefully).</p>
<h3>Terminology</h3>
<p>One of the more opaque aspects (no pun intended) of Aspect-Oriented programming is that it has an entire unique set of terms that can be confusing for people learning to use the <strong>Aspect</strong> module.</p><p>In this section, we will attempt to define all the major terms in a way that will hopefully make sense to Perl programmers.</p><p><em>What is an Aspect?</em></p><p>An <em>Aspect</em> is a modular unit of cross-cutting implementation, consisting of \*(L"Advice\*(R" on \*(L"Pointcuts\*(R" (we'll define those two shortly, don't worry if they don't make sense for now).</p><p>In Perl, this would typically mean a package or module containing declarations of where to inject code, the code to run at these points, and any variables or support functions needed by the injected functionality.</p><p>The most critical point here is that the Aspect represents a collection of many different injection points which collectively implement a single function or feature and which should be enabled on an all or nothing basis.</p><p>For example, you might implement the Aspect <strong>My::SecurityMonitor</strong> as a module which will inject hooks into a dozen different strategic places in your program to watch for valid-but-suspicious values and report these values to an external network server.</p><p>Aspects can often written to be highly reusable, and be released via the \s-1CPAN\s0. When these generic aspects are written in the special namespace Aspect::Library they can be called using the following special shorthand.</p><p>  use Aspect;</p><p>  # Load and enable the Aspect::Library::NYTProf aspect to constrain profiling   # to only the object constructors for each class in your program.   aspect NYTProf =&gt; call qr/^MyProgram&#92;b.*::new$/;</p><p><em>What is a Pointcut?</em></p><p>A <em>Join Point</em> is a well-defined location at a point in the execution of a program at which Perl can inject functionality, in effect joining two different bits of code together.</p><p>In the Perl <strong>Aspect</strong> implementation, this consists only of the execution of named subroutines on the symbol table such as \*(C`Foo::Bar::function_name\*(C'.</p><p>In other languages, additional join points can exist such as the instantiation or destruction of an object or the static initialisation of a class.</p><p>A <em>Pointcut</em> is a well-defined set of join points, and any conditions that must be true when at these join points.</p><p>Example include "All public methods in class \*(C`Foo::Bar\*(C'\*(L" or \*(R"Any non-recursive call to the function \*(C`Some::recursive_search\*(C'".</p><p>We will discuss each of the available pointcut types later in this document.</p><p>In addition to the default pointcut types it is possible to write your own specialised pointcut types, although this is challenging due to the complex \s-1API\s0 they follow to allow aggressive multi-pass optimisation.</p><p>See Aspect::Pointcut for more information.</p><p><em>What is Advice?</em></p><p><em>Advice</em> is code designed to run automatically at all of the join points in a particular pointcut. Advice comes in several types, instructing that the code be run \*(C`before\*(C', \*(C`after\*(C' or \*(C`around\*(C' (in place of) the different join points in the pointcut.</p><p>Advice code is introduced lexically to the target join points. That is, the new functionality is injected in place to the existing program rather the class being extended into some new version.</p><p>For example, function \*(C`Foo::expensive_calculation\*(C' may not support caching because it is unsafe to do so in the general case. But you know that in the case of your program, the reasons it is unsafe in the general case don't apply.</p><p>So for your program you might use the Aspect::Library::Memoise aspect to \*(L"Weave\*(R" Advice code into the \*(C`Foo\*(C' class which adds caching to the function by integrating it with Memoise.</p><p>Each of the different advice types needs to be used slightly differently, and are best employed for different types of jobs. We will discuss the use of each of the different advice types later in this document.</p><p>But in general, the more specific advice type you use, the more optimisation can be applied to your advice declaration, and the less impact the advice will have on the speed of your program.</p><p>In addition to the default pointcut types, it is (theoretically) possible to write your own specialised Advice types, although this would be extremely difficult and probably involve some form of \s-1XS\s0 programming.</p><p>For the brave, see Aspect::Advice and the source for the different advice classes for more information.</p><p><em>What is Weaving?</em></p><p><em>Weaving</em> is the installation of advice code to the subs that match a pointcut, or might potentially match depending on certain run-time conditions.</p><p>In the Perl <strong>Aspect</strong> module, weaving happens on the declaration of each advice block. Unweaving happens when a lexically-created advice variable goes out of scope.</p><p>Unfortunately, due to the nature of the mechanism <strong>Aspect</strong> uses to hook into function calls, unweaving can never be guarenteed to be round-trip clean.</p><p>While the pointcut matching logic and advice code will never be run for unwoven advice, it may be necessary to leave the underlying hooking artifact in place on the join point indefinitely (imposing a small performance penalty and preventing clean up of the relevant advice closure from memory).</p><p>Programs that repeatedly weave and unweave during execution will thus gradually slow down and leak memory, and so is discouraged despite being permitted.</p><p>If advice needs to be repeatedly enabled and disabled you should instead consider using the \*(C`true\*(C' pointcut and a variable in the aspect package or a closure to introduce a remote \*(L"on/off\*(R" switch for the aspect.</p><p>into the advice code.</p><p>  package My::Aspect;</p><p>  my $switch = 1;</p><p>  before {       print "Calling Foo::bar&#92;n";   } call &apos;Foo::bar&apos; & true { $switch };</p><p>  sub enable {       $switch = 1;   }</p><p>  sub disable {       $switch = 0;   }</p><p>  1;</p><p>Under the covers weaving is done using a mechanism that is very similar to the venerable Hook::LexWrap, although in some areas <strong>Aspect</strong> will try to make use of faster mechanisms if it knows these are safe.</p>
<h3>Feature Summary</h3>
<ul>
<li><p>Create permanent pointcuts, advice, and aspects at compile time or run-time.</p></li><li><p>Flexible pointcut language: select subs to match using string equality, regexp, or \*(C`CODE\*(C' ref. Match currently running sub, a sub in the call flow, calls in particular void, scalar, or array contexts, or only the highest call in a set of recursive calls.</p></li><li><p>Build pointcuts composed of a logical expression of other pointcuts, using conjunction, disjunction, and negation.</p></li><li><p>In advice code, you can modify parameter list for matched sub, modify return value, throw or supress exceptions, decide whether or not to proceed to matched sub, access a \*(C`CODE\*(C' ref for matched sub, and access the context of any call flow pointcuts that were matched, if they exist.</p></li><li><p>Add/remove advice and entire aspects lexically during run-time. The scope of advice and aspect objects, is the scope of their effect (This does, however, come with some caveats).</p></li><li><p>A basic library of reusable aspects. A base class makes it easy to create your own reusable aspects. The Aspect::Library::Memoize aspect is an example of how to interface with AOP-like modules from \s-1CPAN\s0.</p></li>
</ul>
<h3>Using Aspect.pm</h3>
<p>The <strong>Aspect</strong> package allows you to create pointcuts, advice, and aspects in a simple declarative fashion. This declarative form is a simple facade on top of the Perl \s-1AOP\s0 framework, which you can also use directly if you need the increased level of control or you feel the declarative form is not clear enough.</p><p>For example, the following two examples are equivalent.</p><p>  use Aspect;</p><p>  # Declarative advice creation   before {       print "Calling " . $_-&gt;sub_name . "&#92;n";   } call &apos;Function::one&apos;   | call &apos;Function::two&apos;;</p><p>  # Longhand advice creation   Aspect::Advice::Before-&gt;new(       Aspect::Pointcut::Or-&gt;new(           Aspect::Pointcut::Call-&gt;new(&apos;Function::one&apos;),           Aspect::Pointcut::Call-&gt;new(&apos;Function::two&apos;),       ),       sub {           print "Calling " . $_-&gt;sub_name . "&#92;n";       },   );</p><p>You will be mostly working with this package (<strong>Aspect</strong>) and the Aspect::Point package, which provides the methods for getting information about the call to the join point within advice code.</p><p>When you \*(C`use Aspect;\*(C' you will import a family of around fifteen functions. These are all factories that allow you to create pointcuts, advice, and aspects.</p>
<h3>Back Compatibility</h3>
<p>The various APIs in <strong>Aspect</strong> have changed a few times between older versions and the current implementation.</p><p>By default, none of these changes are available in the current version of the <strong>Aspect</strong> module. They can, however, be accessed by providing one of two flags when loading <strong>Aspect</strong>.</p><p>  # Support for pre-1.00 Aspect usage   use Aspect &apos;:deprecated&apos;;</p><p>The \*(C`:deprecated\*(C' flag loads in all alternative and deprecated function and method names, and exports the deprecated \*(C`after_returning\*(C', \*(C`after_throwing\*(C' advice constructors, and the deprecated \*(C`if_true\*(C' alias for the \*(C`true\*(C' pointcut.</p><p>  # Support for pre-2010 Aspect usage (both usages are equivalent)   use Aspect &apos;:legacy&apos;;   use Aspect::Legacy;</p><p>The \*(C`:legacy\*(C' flag loads in all alternative and deprecated functions as per the \*(C`:deprecated\*(C' flag.</p><p>Instead of exporting all available functions and pointcut declarators it exports \*(C`only\*(C' the set of functions that were available in <strong>Aspect</strong> 0.12.</p><p>Finally, it changes the behaviour of the exported version of \*(C`after\*(C' to add an implicit \*(C`& returning\*(C' to all pointcuts, as the original implementation did not trap exceptions.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The following functions are exported by default (and are documented as such) but are also available directly in Aspect:: namespace as well if needed.</p><p>They are documented in order from the simplest and and most common pointcut declarator to the highest level declarator for enabling complete aspect classes.</p><h3>call</h3>
<p>  my $single   = call &apos;Person::get_address&apos;;   my $multiple = call qr/^Person::get_/;   my $complex  = call sub { lc($_[0]) eq &apos;person::get_address&apos; };   my $object   = Aspect::Pointcut::Call-&gt;new(&apos;Person::get_address&apos;);</p><p>The most common pointcut is \*(C`call\*(C'. All three of the examples will match the calling of \*(C`Person::get_address()\*(C' as defined in the symbol table at the time an advice is declared.</p><p>The \*(C`call\*(C' declarator takes a single parameter which is the pointcut spec, and can be provided in three different forms.</p><p><strong>string</strong></p><p>Select only the specific full resolved subroutine whose name is equal to the specification string.</p><p>For example \*(C`call &apos;Person::get&apos;\*(C' will only match the plain \*(C`get\*(C' method and will not match the longer \*(C`get_address\*(C' method.</p><p><strong>regexp</strong></p><p>Select all subroutines whose name matches the regular expression.</p><p>The following will match all the subs defined on the \*(C`Person\*(C' class, but not on the \*(C`Person::Address\*(C' or any other child classes.</p><p>  $p = call qr/^Person::&#92;w+$/;</p><p><strong>\s-1CODE\s0</strong></p><p>Select all subroutines where the supplied code returns true when passed a full resolved subroutine name as the only parameter.</p><p>The following will match all calls to subroutines whose names are a key in the hash %subs_to_match:</p><p>  $p = call sub {       exists $subs_to_match{$_[0]};   }</p><p>For more information on the \*(C`call\*(C' pointcut see Aspect::Pointcut::Call.</p>
<h3>cflow</h3>
<p>  before {      print "Called My::foo somewhere within My::bar&#92;n";   } call &apos;My::foo&apos;   & cflow &apos;My::bar&apos;;</p><p>The \*(C`cflow\*(C' declarator is used to specify that the join point must be somewhere within the control flow of the \*(C`My::bar\*(C' function. That is, at the time \*(C`My::foo\*(C' is being called somewhere up the call stack is \*(C`My::bar\*(C'.</p><p>The parameters to \*(C`cflow\*(C' are identical to the parameters to \*(C`call\*(C'.</p><p>Due to an idiosyncracy in the way \*(C`cflow\*(C' is implemented, they do not always parse properly well when joined with an operator. In general, you should use any \*(C`cflow\*(C' operator last in your pointcut specification, or use explicit braces for it.</p><p>  # This works fine   my $x = call &apos;My::foo&apos; & cflow &apos;My::bar&apos;;</p><p>  # This will error   my $y = cflow &apos;My::bar&apos; & call &apos;My::foo&apos;;</p><p>  # Use explicit braces if you can&apos;t have the flow last   my $z = cflow(&apos;My::bar&apos;) & call &apos;My::foo&apos;;</p><p>For more information on the \*(C`cflow\*(C' pointcut, see Aspect::Pointcut::Cflow.</p>
<h3>wantlist</h3>
<p>  my $pointcut = call &apos;Foo::bar&apos; & wantlist;</p><p>The \*(C`wantlist\*(C' pointcut traps a condition based on Perl \*(C`wantarray\*(C' context, when a function is called in list context. When used with \*(C`call\*(C', this pointcut can be used to trap list-context calls to one or more functions, while letting void or scalar context calls continue as normal.</p><p>For more information on the \*(C`wantlist\*(C' pointcut see Aspect::Pointcut::Wantarray.</p>
<h3>wantscalar</h3>
<p>  my $pointcut = call &apos;Foo::bar&apos; & wantscalar;</p><p>The \*(C`wantscalar\*(C' pointcut traps a condition based on Perl \*(C`wantarray\*(C' context, when a function is called in scalar context. When used with \*(C`call\*(C', this pointcut can be used to trap scalar-context calls to one or more functions, while letting void or list context calls continue as normal.</p><p>For more information on the \*(C`wantscalar\*(C' pointcut see Aspect::Pointcut::Wantarray.</p>
<h3>wantvoid</h3>
<p>  my $bug = call &apos;Foo::get_value&apos; & wantvoid;</p><p>The \*(C`wantvoid\*(C' pointcut traps a condition based on Perl \*(C`wantarray\*(C' context, when a function is called in void context. When used with \*(C`call\*(C', this pointcut can be used to trap void-context calls to one or more functions, while letting scalar or list context calls continue as normal.</p><p>This is particularly useful for methods which make no sense to call in void context, such as getters or other methods calculating and returning a useful result.</p><p>For more information on the \*(C`wantvoid\*(C' pointcut see Aspect::Pointcut::Wantarray.</p>
<h3>highest</h3>
<p>  my $entry = call &apos;Foo::recurse&apos; & highest;</p><p>The \*(C`highest\*(C' pointcut is used to trap the first time a particular function is encountered, while ignoring any subsequent recursive calls into the same pointcut.</p><p>It is unusual in that unlike all other types of pointcuts it is stateful, and so some detailed explaination is needed to understand how it will behave.</p><p>Pointcut declarators follow normal Perl precedence and shortcutting in the same way that a typical set of \*(C`foo() and bar()\*(C' might do for regular code.</p><p>When the \*(C`highest\*(C' is evaluated for the first time it returns true and a counter is to track the depth of the call stack. This counter is bound to the join point itself, and will decrement back again once we exit the advice code.</p><p>If we encounter another function that is potentially contained in the same pointcut, then \*(C`highest\*(C' will always return false.</p><p>In this manner, you can trigger functionality to run only at the outermost call into a recursive series of functions, or you can negate the pointcut with \*(C`! highest\*(C' and look for recursive calls into a function when there shouldn't be any recursion.</p><p>In the current implementation, the semantics and behaviour of pointcuts containing multiple highest declarators is not defined (and the current implementation is also not amenable to supporting it).</p><p>For these reasons, the usage of multiple highest declarators such as in the following example is not support, and so the following will throw an exception.</p><p>  before {       print "This advice will not compile&#92;n";   } wantscalar & (       (call &apos;My::foo&apos; & highest)       |       (call &apos;My::bar&apos; & highest)   );</p><p>This limitation may change in future releases. Feedback welcome.</p><p>For more information on the \*(C`highest\*(C' pointcut see Aspect::Pointcut::Highest.</p>
<h3>throwing</h3>
<p>  my $string = throwing qr/does not exist/;   my $object = throwing &apos;Exception::Class&apos;;</p><p>The \*(C`throwing\*(C' pointcut is used with the \*(C`after\*(C' to restrict the pointcut so advice code is only fired for a specific die message or a particular exception class (or subclass).</p><p>The \*(C`throwing\*(C' declarator takes a single parameter which is the pointcut spec, and can be provided in two different forms.</p><p><strong>regexp</strong></p><p>If a regular expression is passed to \*(C`throwing\*(C' it will be matched against the exception if and only if the exception is a plain string.</p><p>Thus, the regexp form can be used to trap unstructured errors emitted by \*(C`die\*(C' or \*(C`croak\*(C' while <strong>\s-1NOT\s0</strong> trapping any formal exception objects of any kind.</p><p><strong>string</strong></p><p>If a string is passed to \*(C`throwing\*(C' it will be treated as a class name and will be matched against the exception via an \*(C`isa\*(C' method call if and only if the exception is an object.</p><p>Thus, the string form can be used to trap and handle specific types of exceptions while allowing other types of exceptions or raw string errors to pass through.</p><p>For more information on the \*(C`throwing\*(C' pointcut see Aspect::Pointcut::Throwing.</p>
<h3>returning</h3>
<p>  after {       print "No exception&#92;n";   } call &apos;Foo::bar&apos; & returning;</p><p>The \*(C`returning\*(C' pointcut is used with \*(C`after\*(C' advice types to indicate the join point should only occur when a function is returning <strong>without</strong> throwing an exception.</p>
<h3>true</h3>
<p>  # Intercept an adjustable random percentage of calls to a function   our $RATE = 0.01;</p><p>  before {       print "The few, the brave, the 1%&#92;n";   } call &apos;My::foo&apos;   & true {       rand() &lt; $RATE   };</p><p>Because of the lengths that <strong>Aspect</strong> goes to internally to optimise the selection and interception of calls, writing your own custom pointcuts can be very difficult.</p><p>When a custom or unusual pattern of interception is needed, often all that is desired is to extend a relatively normal pointcut with an extra caveat.</p><p>To allow for this scenario, <strong>Aspect</strong> provides the \*(C`true\*(C' pointcut.</p><p>This pointcut allows you to specify any arbitrary code to match on. This code will be executed at run-time if the join point matches all previous conditions.</p><p>The join point matches if the function or closure returns true, and does not match if the code returns false or nothing at all.</p>
<h3>before</h3>
<p>  before {       # Don&apos;t call the function, return instead       $_-&gt;<strong>return_value</strong>(1);   } call &apos;My::foo&apos;;</p><p>The <strong>before</strong> advice declaration is used to defined advice code that will be run instead of the code originally at the join points, but continuing on to the real function if no action is taken to say otherwise.</p><p>When called in void context, as shown above, \*(C`before\*(C' will install the advice permanently into your program.</p><p>When called in scalar context, as shown below, \*(C`before\*(C' will return a guard object and enable the advice for as long as that guard object continues to remain in scope or otherwise avoid being destroyed.</p><p>  SCOPE: {       my $guard = before {           print "Hello World!&#92;n";       } call &apos;My::foo&apos;;</p><p>      # This will print       My::foo();   }</p><p>  # This will NOT print   My::foo();</p><p>Because the end result of the code at the join points is irrelevant to this type of advice and the Aspect system does not need to hang around and maintain control during the join point, the underlying implementation is done in a way that is by far the fastest and with the least impact (essentially none) on the execution of your program.</p><p>You are <strong>strongly</strong> encouraged to use \*(C`before\*(C' advice wherever possible for the current implementation, resorting to the other advice types when you truly need to be there are the end of the join point execution (or on both sides of it).</p><p>For more information, see Aspect::Advice::Before.</p>
<h3>after</h3>
<p>  # Confuse a program by bizarely swapping return values and exceptions   after {       if ( $_-&gt;exception ) {           $_-&gt;return_value($_-&gt;exception);       } else {           $_-&gt;exception($_-&gt;return_value);       }   } call &apos;My::foo&apos; & wantscalar;</p><p>The \*(C`after\*(C' declarator is used to create advice in which the advice code will be run after the join point has run, regardless of whether the function return correctly or throws an exception.</p><p>For more information, see Aspect::Advice::After.</p>
<h3>around</h3>
<p>  # Trace execution time for a function   around {       my @start   = Time::HiRes::gettimeofday();       $_-&gt;proceed;       my @stop    = Time::HiRes::gettimeofday();       my $elapsed = Time::HiRes::tv_interval( &#92;@start, &#92;@stop );       print "My::foo executed in $elapsed seconds&#92;n";   } call &apos;My::foo&apos;;</p><p>The \*(C`around\*(C' declarator is used to create the most general form of advice, and can be used to implement the most high level functionality.</p><p>It allows you to make changes to the calling parameters, to change the result of the function, to subvert or prevent the calling altogether, and to do so while storing extra lexical state of your own across the join point.</p><p>For example, the code shown above tracks the time at which a single function is called and returned, and then uses the two pieces of information to track the execution time of the call.</p><p>Similar functionality to the above is used to implement the \s-1CPAN\s0 modules Aspect::Library::Timer and the more complex Aspect::Library::ZoneTimer.</p><p>Within the \*(C`around\*(C' advice code, the \*(C`$_-&gt;proceed\*(C' method is used to call the original function with whatever the current parameter context is, storing the result (whether return values or an exception) in the context as well.</p><p>Alternatively, you can use the \*(C`original\*(C' method to get access to a reference to the original function and call it directly without using context parameters and without storing the function results.</p><p>  around {       $_-&gt;original-&gt;(&apos;alternative param&apos;);       $_-&gt;return_value(&apos;fake result&apos;);   } call &apos;My::foo&apos;;</p><p>The above example calls the original function directly with an alternative parameter in void context (regardless of the original \*(C`wantarray\*(C' context) ignoring any return values. It then sets an entirely made up return value of it's own.</p><p>Although it is the most powerful advice type, \*(C`around\*(C' is also the slowest advice type with the highest memory cost per join point. Where possible, you should try to use a more specific advice type.</p><p>For more information, see Aspect::Advice::Around.</p>
<h3>aspect</h3>
<p>  aspect Singleton =&gt; &apos;Foo::new&apos;;</p><p>The \*(C`aspect\*(C' declarator is used to enable complete reusable aspects.</p><p>The first parameter to \*(C`aspect\*(C' identifies the aspect library class. If the parameter is a fully resolved class name (i.e. it contains double colons like Foo::Bar) the value it will be used directly. If it is a simple \*(C`Identifier\*(C' without colons then it will be interpreted as \*(C`Aspect::Library::Identifier\*(C'.</p><p>If the aspect class is not loaded, it will be loaded for you and validated as being a subclass of \*(C`Aspect::Library\*(C'.</p><p>And further parameters will be passed on to the constructor for that class. See the documentation for each class for more information on the appropriate parameters for that class.</p><p>As with each individual advice type complete aspects can be defined globally by using \*(C`aspect\*(C' in void context, or lexically via a guard object by calling \*(C`aspect\*(C' in scalar context.</p><p>  # Break on the topmost call to function for a limited time   SCOPE: {       my $break = aspect Breakpoint =&gt; call &apos;My::foo&apos; & highest;</p><p>      do_something();   }</p><p>For more information on writing reusable aspects, see Aspect::Library.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPERATORS</h2>
        <div class="sectioncontent">
<h3>&</h3>
<p>Overloading of bitwise \*(C`&\*(C' for pointcut declarations allows a natural looking boolean \*(L"and\*(R" logic for pointcuts. When using the \*(C`&\*(C' operator the combined pointcut expression will match if all pointcut subexpressions match.</p><p>In the original Java AspectJ framework, the subexpressions are considered to be a union without an inherent order at all. In Perl you may treat them as ordered since they are ordered internally, but since all subexpressions run anyway you should probably not do anything that relies on this order. The optimiser may do interesting things with order in future, or we may move to an unordered implementation.</p><p>For more information, see Aspect::Pointcut::And.</p>
<h3>|</h3>
<p>Overloading of bitwise \*(C`|\*(C' for pointcut declarations allows a natural looking boolean \*(L"or\*(R" logic for pointcuts. When using the \*(C`|\*(C' operator the combined pointcut expression will match if either pointcut subexpressions match.</p><p>The subexpressions are ostensibly considered without any inherent order, and you should treat them that way when you can. However, they are internally ordered and shortcutting will be applied as per normal Perl expressions. So for speed reasons, you may with to put cheap pointcut declarators before expensive ones where you can.</p><p>The optimiser may do interesting things with order in future, or we may move to an unordered implementation. So as a general rule, avoid things that require order while using order to optimise where you can.</p><p>For more information, see Aspect::Pointcut::Or.</p>
<h3>!</h3>
<p>Overload of negation \*(C`!\*(C' for pointcut declarations allows a natural looking boolean \*(L"not\*(R" logic for pointcuts. When using the \*(C`!\*(C' operator the resulting pointcut expression will match if the single subexpression does <strong>not</strong> match.</p><p>For more information, see Aspect::Pointcut::Not.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>A range of different methods are available within each type of advice code.</p><p>The are summarised below, and described in more detail in Aspect::Point.</p><h3>type</h3>
<p>The \*(C`type\*(C' method is a convenience provided in the situation advice code is used in more than one type of advice, and wants to know the advice declarator is was made form.</p><p>Returns "before", "after" or "around".</p>
<h3>pointcut</h3>
<p>  my $pointcut = $_-&gt;pointcut;</p><p>The \*(C`pointcut\*(C' method provides access to the original join point specification (as a tree of Aspect::Pointcut objects) that the current join point matched against.</p>
<h3>original</h3>
<p>  $_-&gt;original-&gt;( 1, 2, 3 );</p><p>In a pointcut, the \*(C`original\*(C' method returns a \*(C`CODE\*(C' reference to the original function before it was hooked by the Aspect weaving process.</p><p>  # Prints "Full::Function::name"   before {       print $_-&gt;sub_name . "&#92;n";   } call &apos;Full::Function::name&apos;;</p><p>The \*(C`sub_name\*(C' method returns a string with the full resolved function name at the join point the advice code is running at.</p>
<h3>package_name</h3>
<p>  # Prints "Just::Package"   before {       print $_-&gt;package_name . "&#92;n";   } call &apos;Just::Package::name&apos;;</p><p>The \*(C`package_name\*(C' parameter is a convenience wrapper around the \*(C`sub_name\*(C' method. Where \*(C`sub_name\*(C' will return the fully resolved function name, the \*(C`package_name\*(C' method will return just the namespace of the package of the join point.</p>
<h3>short_name</h3>
<p>  # Prints "name"   before {       print $_-&gt;short_name . "&#92;n";   } call &apos;Just::Package::name&apos;;</p><p>The \*(C`short_name\*(C' parameter is a convenience wrapper around the \*(C`sub_name\*(C' method. Where \*(C`sub_name\*(C' will return the fully resolved function name, the \*(C`short_name\*(C' method will return just the name of the function.</p>
<h3>args</h3>
<p>  # Get the parameters as a list   my @list = $_-&gt;args;</p><p>  # Set the parameters   $_-&gt;args( 1, 2, 3 );</p><p>  # Append a parameter   $_-&gt;args( $_-&gt;args, &apos;more&apos; );</p><p>The \*(C`args\*(C' method allows you to get or set the list of parameters to a function. It is the method equivalent of manipulating the @_ array.</p>
<h3>self</h3>
<p>  after {       $_-&gt;self-&gt;save;   } My::Foo::set;</p><p>The \*(C`self\*(C' method is a convenience provided for when you are writing advice that will be working with object-oriented Perl code. It returns the first parameter to the method (which should be object), which you can then call methods on.</p>
<h3>wantarray</h3>
<p>  # Return differently depending on the calling context   if ( $_-&gt;wantarray ) {       $_-&gt;<strong>return_value</strong>(5);   } else {       $_-&gt;return_value(1, 2, 3, 4, 5);   }</p><p>The \*(C`wantarray\*(C' method returns the \*(L"wantarray\*(R" in perlfunc context of the call to the function for the current join point.</p><p>As with the core Perl \*(C`wantarray\*(C' function, returns true if the function is being called in list context, false if the function is being called in scalar context, or \*(C`undef\*(C' if the function is being called in void context.</p>
<h3>exception</h3>
<p>  unless ( $_-&gt;exception ) {       $_-&gt;exception(&apos;Kaboom&apos;);   }</p><p>The \*(C`exception\*(C' method is used to get the current die message or exception object, or to set the die message or exception object.</p>
<h3>return_value</h3>
<p>  # Add an extra value to the returned list   $_-&gt;return_value( $_-&gt;return_value, &apos;thing&apos; );</p><p>  # Return null (equivalent to "return;")   $_-&gt;return_value;</p><p>The \*(C`return_value\*(C' method is used to get or set the return value for the join point function, in a similar way to the normal Perl \*(C`return\*(C' keyword.</p>
<h3>proceed</h3>
<p>  around {       my $before = time;       $_-&gt;proceed;       my $elapsed = time - $before;       print "Call to " . $_-&gt;sub_name . " took $elapsed seconds&#92;n";   } call &apos;My::function&apos;;</p><p>Available only in \*(C`around\*(C' advice, the \*(C`proceed\*(C' method is used to run the join point function with the current join point context (parameters, scalar vs list call, etc) and store the result of the original call in the join point context (return values, exceptions etc).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIBRARY</h2>
        <div class="sectioncontent">
<p>The main Aspect distribution ships with the following set of libraries. These are not necesarily recommended or the best on offer. The are shipped with <strong>Aspect</strong> for convenience, because they have no additional \s-1CPAN\s0 dependencies.</p><p>Their purpose is summarised below, but see their own documentation for more information.</p><h3>Aspect::Library::Singleton</h3>
<p>Aspect::Library::Singleton can be used to convert an existing class to function as a singleton and return the same object for every constructor call.</p>
<h3>Aspect::Library::Breakpoint</h3>
<p>Aspect::Library::Breakpoint allows you to inject debugging breakpoints into a program using the full power and complexity of the \*(C`Aspect\*(C' pointcuts.</p>
<h3>Aspect::Library::Wormhole</h3>
<p>Aspect::Library::Wormhole is a tool for passing objects down a call flow, without adding extra arguments to the frames between the source and the target, letting a function implicit context.</p>
<h3>Aspect::Library::Listenable</h3>
<p>Aspect::Library::Listenable assysts in the implementation of the \*(L"Listenable\*(R" design pattern. It lets you define a function as emitting events that can be registed for by subscribers, and then add/remove subscribers for these events over time.</p><p>When the functions that are listenable are called, registered subscribers will be notified. This lets you build a general event subscription system for your program. This could be as part of a plugin \s-1API\s0 or just for your own convenience.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNALS</h2>
        <div class="sectioncontent">
<p>Due to the dynamic nature of Perl, there is no need for processing of source or byte code, as required in the Java and .NET worlds.</p><p>The implementation is conceptually very simple: when you create advice, its pointcut is matched to find every sub defined in the symbol table that might match against the pointcut (potentially subject to further runtime conditions).</p><p>Those that match, will get a special wrapper installed. The wrapper only executes if, during run-time, a compiled context test for the pointcut returns true.</p><p>The wrapper code creates an advice context, and gives it to the advice code.</p><p>Most of the complexity comes from the extensive optimisation that is used to reduce the impact of both weaving of the advice and the run-time costs of the wrappers added to your code.</p><p>Some pointcuts like \*(C`call\*(C' are static and their full effect is known at weave time, so the compiled run-time function can be optimised away entirely.</p><p>Some pointcuts like \*(C`cflow\*(C' are dynamic, so they are not used to select the functions to hook, but impose a run-time cost to determine whether or not they match.</p><p>To make this process faster, when the advice is installed, the pointcut will not use itself directly for the compiled run-time function but will additionally generate a \*(L"curried\*(R" (optimised) version of itself.</p><p>This curried version uses the fact that the run-time check will only be called if it matches the \*(C`call\*(C' pointcut pattern, and so no \*(C`call\*(C' pointcuts needed to be tested at run-time unless they are in deep and complex nested coolean logic. It also handles collapsing any boolean logic impacted by the safe removal of the \*(C`call\*(C' pointcuts.</p><p>Further, where possible the pointcuts will be expressed as Perl source (including logic operators) and compiled into a single Perl expression. This not only massively reduces the number of functions to be called, but allows further optimisation of the pointcut by the opcode optimiser in perl itself.</p><p>If you use only \*(C`call\*(C' pointcuts (alone or in boolean combinations) the currying results in a null test (the pointcut is optimised away entirely) and so the need to make a run-time point test will be removed altogether from the generated advice hooks, reducing call overheads significantly.</p><p>If your pointcut does not have any static conditions (i.e. \*(C`call\*(C') then the wrapper code will need to be installed into every function on the symbol table. This is highly discouraged and liable to result in hooks on unusual functions and unwanted side effects, potentially breaking your program.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<h3>Inheritance Support</h3>
<p>Support for inheritance is lacking. Consider the following two classes:</p><p>  package Automobile;</p><p>  sub compute_mileage {       # ...   }</p><p>  package Van;</p><p>  use base &apos;Automobile&apos;;</p><p>And the following two advice:</p><p>  before {       print "Automobile!&#92;n";   } call &apos;Automobile::compute_mileage&apos;;</p><p>  before {       print "Van!&#92;n";   } call &apos;Van::compute_mileage&apos;;</p><p>Some join points one would expect to be matched by the call pointcuts above, do not:</p><p>  $automobile = Automobile-&gt;new;   $van = Van-&gt;new;   $automobile-&gt;compute_mileage; # Automobile!   $van-&gt;compute_mileage;        # Automobile!, should also print Van!</p><p>\*(C`Van!\*(C' will never be printed. This happens because <strong>Aspect</strong> installs advice code on symbol table entries. \*(C`Van::compute_mileage\*(C' does not have one, so nothing happens. Until this is solved, you have to do the thinking about inheritance yourself.</p>
<h3>Performance</h3>
<p>You may find it very easy to shoot yourself in the foot with this module. Consider this advice:</p><p>  # Do not do this!   before {       print $_-&gt;sub_name;   } cflow &apos;MyApp::Company::make_report&apos;;</p><p>The advice code will be installed on <strong>every</strong> sub loaded. The advice code will only run when in the specified call flow, which is the correct behavior, but it will be <em>installed</em> on every sub in the system. This can be extremely slow because the run-time cost of checking \*(C`cflow\*(C' will occur on every single function called in your program.</p><p>It happens because the \*(C`cflow\*(C' pointcut matches <em>all</em> subs during weave-time. It matches the correct sub during run-time. The solution is to narrow the pointcut:</p><p>  # Much better   before {       print $_-&gt;sub_name;   } call qr/^MyApp::/   & cflow &apos;MyApp::Company::make_report&apos;;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TO DO</h2>
        <div class="sectioncontent">
<p>There are a many things that could be added, if people have an interest in contributing to the project.</p><h3>Documentation</h3>
<p>* cookbook</p><p>* tutorial</p><p>* example of refactoring a useful \s-1CPAN\s0 module using aspects</p>
<h3>Pointcuts</h3>
<p>* New pointcuts: execution, cflowbelow, within, advice, calledby. Sure</p>
<pre>
  you can implement them today with Perl treachery, but it is too much
  work.
</pre>
<p>* We need a way to match subs with an attribute, <em>attributes::get()</em></p>
<pre>
  will currently not work.
</pre>
<p>* <em>isa()</em> support for method pointcuts as Gaal Yahas suggested: match</p>
<pre>
  methods on class hierarchies without callbacks
</pre>
<p>* Perl join points: phasic- \s-1BEGIN/INIT/CHECK/END\s0</p>
<h3>Weaving</h3>
<p>* The current optimation has gone as far as it can, next we need to look into</p>
<pre>
  \s-1XS\s0 acceleration and byte code manipulation with B:: modules.
</pre>
<p>* A debug flag to print out subs that were matched during weaving</p><p>* Warnings when over 1000 methods wrapped</p><p>* Allow finer control of advice execution order</p><p>* Centralised hooking in wrappers so that each successive advice won't need</p>
<pre>
  to wrap around the previous one.
</pre>
<p>* Allow lexical aspects to be safely removed completely, rather than being left</p>
<pre>
  in place and disabled as in the current implementation.
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>Please report any bugs or feature requests through the web interface at &lt;http://rt.cpan.org/Public/Dist/Display.html?Name=Aspect&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTALLATION</h2>
        <div class="sectioncontent">
<p>See perlmodinstall for information and options on installing Perl modules.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AVAILABILITY</h2>
        <div class="sectioncontent">
<p>The latest version of this module is available from the Comprehensive Perl Archive Network (\s-1CPAN\s0). Visit &lt;http://www.perl.com/CPAN/&gt; to find a \s-1CPAN\s0 site near you. Or see &lt;http://search.cpan.org/perldoc?Aspect&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Adam Kennedy &lt;adamk@cpan.org&gt;</p><p>Marcel Gru\*:nauer &lt;marcel@cpan.org&gt;</p><p>Ran Eilam &lt;eilara@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Aspect&hellip;</h2>
        <div class="sectioncontent">
<p>You can find \s-1AOP\s0 examples in the \*(C`examples/\*(C' directory of the distribution.</p><p>Aspect::Library::Memoize</p><p>Aspect::Library::Profiler</p><p>Aspect::Library::Trace</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2001 by Marcel Gru\*:nauer</p><p>Some parts copyright 2009 - 2013 Adam Kennedy.</p><p>Parts of the initial introduction courtesy Wikipedia.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Array::Unique.3pm.html"><span aria-hidden="true">&larr;</span> Array::Unique.3pm: Tie-able array that allows only unique values</a></li>
   <li class="next"><a href="Aspect::Advice.3pm.html">Aspect::Advice.3pm: Change how perl code is run at a pointcut <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

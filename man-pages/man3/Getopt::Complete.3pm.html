<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Getopt::Complete: Programmable shell completion for perl apps</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Programmable shell completion for perl apps">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Getopt::Complete (3pm) manual">
  <meta name="twitter:description" content="Programmable shell completion for perl apps">
  <meta name="twitter:image" content="https://www.carta.tech/images/libgetopt-complete-perl-Getopt::Complete-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Getopt::Complete.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Getopt::Complete (3pm) manual" />
  <meta property="og:description" content="Programmable shell completion for perl apps" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libgetopt-complete-perl-Getopt::Complete-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Getopt::Complete<small> (3pm)</small></h1>
        <p class="lead">Programmable shell completion for perl apps</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Getopt::Complete.3pm.html">
      <span itemprop="name">Getopt::Complete: Programmable shell completion for perl apps</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libgetopt-complete-perl/">
      <span itemprop="name">libgetopt-complete-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Getopt::Complete.3pm.html">
      <span itemprop="name">Getopt::Complete: Programmable shell completion for perl apps</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes Getopt::Complete 0.26.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>In the Perl program \*(L"myprogram\*(R":</p>
<pre>
  use Getopt::Complete (
      &apos;frog&apos;        =&gt; [&apos;ribbit&apos;,&apos;urp&apos;,&apos;ugh&apos;],
      &apos;fraggle&apos;     =&gt; sub { return [&apos;rock&apos;,&apos;roll&apos;] },
      &apos;quiet!&apos;      =&gt; undef,
      &apos;name&apos;        =&gt; undef,
      &apos;age=n&apos;       =&gt; undef,
      &apos;outfile=s@&apos;  =&gt; &apos;files&apos;,
      &apos;outdir&apos;      =&gt; &apos;directories&apos;
      &apos;runthis&apos;     =&gt; &apos;commands&apos;,
      &apos;username&apos;    =&gt; &apos;users&apos;,
      &apos;&lt;&gt;&apos;          =&gt; &apos;directories&apos;,
  );

  print "the frog says " . $ARGS{frog} . "&#92;n";
</pre>
<p>In ~/.bashrc or ~/.bash_profile, or directly in bash:</p><p>  function _getopt_complete () {     COMPREPLY=($( COMP_CWORD=$COMP_CWORD perl &#96;which ${COMP_WORDS[0]}&#96; ${COMP_WORDS[@]:0} ));   }   complete -F _getopt_complete myprogram</p><p>Thereafter in the terminal (after next login, or sourcing the updated .bashrc):</p><p>  $ myprogram --f&lt;TAB&gt;   $ myprogram --fr</p><p>  $ myprogram --fr&lt;TAB&gt;&lt;TAB&gt;   frog fraggle</p><p>  $ myprogram --fro&lt;TAB&gt;   $ myprogram --frog</p><p>  $ myprogram --frog &lt;TAB&gt;   ribbit urp ugh</p><p>  $ myprogram --frog r&lt;TAB&gt;   $ myprogram --frog ribbit</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module makes it easy to add custom command-line completion to Perl applications.  It also does additional validation of arguments, when the program is actually executed, based on completion lists.</p><p>Support is also present for apps which are an entry point for a hierarchy of sub-commands (in the style of cvs and git).</p><p>Getopt::Complete also wraps the standard options processing and exports it as a %ARGS hash at compile time, making using the arguments hassle-free.</p><p>The completion features currently work with the bash shell, which is the default on most Linux and Mac systems.  Patches for other shells are welcome.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS PROCESSING</h2>
        <div class="sectioncontent">
<p>Getopt::Complete processes the command-line options at compile time.</p><p>The results are avaialble in the %ARGS hash, which is intended as a companion to the @ARGV array generated natively by Perl.</p><p>  use Getopt::Complete (     &apos;mydir&apos;     =&gt; &apos;d&apos;,     &apos;myfile&apos;    =&gt; &apos;f&apos;,     &apos;&lt;&gt;&apos;        =  [&apos;monkey&apos;, &apos;taco&apos;, &apos;banana&apos;]   );</p><p>  for $opt (keys %ARGS) {     $val = $ARGS{$opt};     print "$opt has value $val&#92;n";   }</p><p>Errors in shell argumentes result in messages to \s-1STDERR\s0 via <em>warn()</em>, and cause the program to exit during \*(L"use\*(R" call.  Getopt::Complete verifies that the option values specified match their own completion list, and will otherwise add additional errors explaining the problem.</p><p>The %ARGS hash is an alias for %Getopt::Complete::ARGS.  The alias is not created in the caller's namespaces if a hash named %ARGS already exists with data, but the results are always available from %Getopt::Complete::ARGS.</p><p>They keys of the hash are the option names, minus any specifiers like \*(L"=s\*(R" or \*(L"!\*(R". The key is only present if the option was specified on the command-line.</p><p>The values of the hash are the values from the command-line.  For multi-value options the hash value is an arrayref.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT API</h2>
        <div class="sectioncontent">
<p>An object $ARGS is also created in the caller's namespace (class Getopt::Complete::Args) with a more detailed \s-1API\s0 for argument interrogation.  See the documentation for that module, and also for the underlying Getopt::Complete::Options module.</p><p>It is possible to override any part of the default process, including doing custom parsing, doing processing at run-time, and and preventing exit when there are errors.</p><p>See \s-1OVERRIDING\s0 COMPILE-TIME \s-1OPTION\s0 \s-1PARSING\s0 for more information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROGRAMMABLE COMPLETION BACKGROUND</h2>
        <div class="sectioncontent">
<p>The bash shell supports smart completion of words when the &lt;\s-1TAB\s0&gt; key is pressed. By default, after the program name is specified, bash will presume the word the user is typing a is a file name, and will attempt to complete the word accordingly.  Where completion is ambiguous, the shell will go as far as it can and beep.  Subsequent completion attempts at that position result in a list being shown of possible completions.</p><p>Bash can be configured to run a specific program to handle the completion task, allowing custom completions to be done for different appliations. The \*(L"complete\*(R" built-in bash command instructs the shell as-to how to handle tab-completion for a given command.</p><p>This module allows a program to be its own word-completer.  It detects that the \s-1COMP_LINE\s0 and \s-1COMP_POINT\s0 environment variables are set, indicating that it is being used as a completion program, and responds by returning completion values suitable for the shell _instead_ of really running the application.</p><p>See the manual page for \*(L"bash\*(R", the heading \*(L"Programmable Completion\*(R" for full details on the general topic.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HOW TO CONFIGURE PROGRAMMABLE COMPLETION</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Put a \*(L"use Getopt::Complete\*(R" statement into your app as shown in the synopsis. The key-value pairs describe the command-line options available, and their completions. This should be at the \s-1TOP\s0 of the app, before any real processing is done. The only modules used before it should be those needed for custom callbacks, if there are any.  No code should print to standard output during compile time, or it will confuse bash. Subsequent code can use %ARGS or the $ARGS object to check on command-line option values. Existing apps using Getopt::Long should use their option spec in the use declaration instead. If they bind variables directly the code should to be updated to get values from the %ARGS hash instead.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Put the following in your .bashrc or .bash_profile:   function _getopt_complete () {     COMPREPLY=($( COMP_CWORD=$COMP_CWORD perl &#96;which ${COMP_WORDS[0]}&#96; ${COMP_WORDS[@]:0} ));   }   complete -F _getopt_complete myprogram</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>New logins will automatically run the above and become aware that your program has programmable completion.  For shells you already have open, run this to alert bash to your that your program has custom tab-completion.   source ~/.bashrc</p>
  </dd>

</dl>
<p>Type the name of your app (\*(L"myprogram\*(R" in the example), and experiment with using the &lt;\s-1TAB\s0&gt; key to get various completions to test it.  Every time you hit &lt;\s-1TAB\s0&gt;, bash sets certain environment variables, and then runs your program.  The Getopt::Complete module detects these variables, responds to the completion request, and then forces the program to exit before really running your regular application code.</p><p>\s-1IMPORTANT:\s0 Do not do steps #2 and #3 w/o doing step #1, or your application will actually run \*(L"normally\*(R" every time you press &lt;\s-1TAB\s0&gt; with it on the command-line! The module will not be present to detect that this is not a \*(L"real\*(R" execution of the program, and you may find your program is running when it should not.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KEYS IN THE OPTIONS SPECIFICATION</h2>
        <div class="sectioncontent">
<p>Each key in the list decribes an option which can be completed.  Any key usable in a Getopt:::Long GetOptions specification works here, (except as noted in \s-1BUGS\s0 below):</p>
<dl class='dl-vertical'>
  <dt>
    an option name
  </dt>
  <dd>
    <p>A normal word is interpreted as an option name. The '=s' specifier is presumed if no specifier is present.   &apos;p1&apos; =&gt; [...]</p>
  </dd>
  <dt>
    a complete option specifier
  </dt>
  <dd>
    <p>Any specification usable by Getopt::Long is valid as the key. For example:   &apos;p1=s&apos; =&gt; [...]       # the same as just &apos;p1&apos;   &apos;p2=s@&apos; =&gt; [...]      # expect multiple values This special key specifies how to complete non-option (bare) arguments. It presumes multiple values are possible (like '=s@'): Have an explicit list:  '&lt;&gt;' = ['value1','value2','value3'] Do normal file completion:  '&lt;&gt;' = 'files' Take arbitrary values with no expectations:  '&lt;&gt;' = undef If there is no '&lt;&gt;' key specified, bare arguments will be treated as an error.</p>
  </dd>
  <dt>
    a sub-command specifier, starting with '&gt;'
  </dt>
  <dd>
    <p>When a key in the options specification starts with '&gt;', it indicates a that word maps to a distinct sub-command with its own options.  The array to the right is itself a full options specification, following the same format as the one above it, including possible further sub-commands. See SUB-COMMAND \s-1TREES\s0 for more details.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VALUES IN THE OPTIONS SPECIFICATION</h2>
        <div class="sectioncontent">
<p>Each value describes how the option in question should be completed.</p>
<dl class='dl-vertical'>
  <dt>
    array reference
  </dt>
  <dd>
    <p>An array reference expliciitly lists the valid values for the option.   In the app:</p><p>    use Getopt::Complete (         &apos;color&apos;    =&gt; [&apos;red&apos;,&apos;green&apos;,&apos;blue&apos;],     );</p><p>  In the shell:</p><p>    $ myprogram --color &lt;TAB&gt;     red green blue</p><p>    $ myprogram --color blue     (runs with no errors) The list of value is also used to validate the user's choice after options are processed:     myprogram --color purple     ERROR: color has invalid value purple: select from red green blue See below for details on how to permit values which aren't shown in completions to be used and not generate errors.</p>
  </dd>
  <dt>
    undef
  </dt>
  <dd>
    <p>An undefined value indicates that the option is not completable.  No completions will be offered by the application, though any value provided by the user will be considered valid. Note that this is distinct from returning an empty arrayref from a callback, which implies that there \s-1ARE\s0 known completions but the user has failed to match any of them. Also note: this is the only valid completion for boolean parameters, since there is no value to specify on the command-line.   use Getopt::Complete (     &apos;name&apos;      =&gt; undef,   # take --name "anyting"     &apos;perky!&apos;    =&gt; undef,   # take --perky or --no-perky   );</p>
  </dd>
  <dt>
    subroutine callback
  </dt>
  <dd>
    <p>When the list of valid values must be determined dynamically, a subroutine reference or name can be specified.  If a name is specified, it should be fully qualified.  (If it is not, it will be presumed to refer to one of the bash builtin completions types. See \s-1BUILTIN\s0 \s-1COMPLETION\s0 \s-1TYPES\s0 below.) The subroutine will be called, and is expected to return an arrayref of possiible matches. The arrayref will be treated as though it were specified directly in the specification. As with explicit values, an empty arrayref indicated that there are no valid matches for this option, given the other params on the command-line, and the text already typed. An undef value indicates that any value is valid for this parameter. Parameters to the callback are described below.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING SUBROUTINE CALLBACKS</h2>
        <div class="sectioncontent">
<p>A subroutine callback is useful when the list of options to match must be dynamically generated.</p><p>It is also useful when knowing what the user has already typed helps narrow the search for valid completions, or when iterative completion needs to occur (see \s-1PARTIAL\s0 \s-1COMPLETIONS\s0 below).</p><p>The callback is expected to return an arrayref of valid completions.  If it is empty, no completions are considered valid.  If an undefined value is returned, no completions are specified, but \s-1ANY\s0 arbitrary value entered is considered valid as far as error checking is concerned.</p><p>The callback registered in the completion specification will receive the following parameters:</p>
<dl class='dl-vertical'>
  <dt>
    command name
  </dt>
  <dd>
    <p>Contains the name of the command for which options are being parsed.  This is $0 in most cases, though hierarchical commands may have a name \*(L"svn commit\*(R" or \*(L"foo bar baz\*(R" etc.</p>
  </dd>
  <dt>
    current word
  </dt>
  <dd>
    <p>This is the word the user is trying to complete.  It may be an empty string, if the user hits &lt;Tab&gt; without typing anything first.</p>
  </dd>
  <dt>
    option name
  </dt>
  <dd>
    <p>This is the name of the option for which we are resolving a value.  It is typically ignored unless you use the same subroutine to service multiple options. A value of '&lt;&gt;' indicates an unnamed argument (a.k.a \*(L"bare argument\*(R" or \*(L"non-option\*(R" argument).</p>
  </dd>
  <dt>
    other opts
  </dt>
  <dd>
    <p>It is the hashref resulting from Getopt::Long processing of all of the \s-1OTHER\s0 arguments. This is useful when one option limits the valid values for another option. In some cases, the options which should be available change depending on what other options are present, or the values available change depending on other options or their values.</p>
  </dd>

</dl>
<p>The environment variables \s-1COMP_LINE\s0 and \s-1COMP_POINT\s0 have the exact text of the command-line and also the exact character position, if more detail is needed in raw form than the parameters provide.</p><p>The return value is a list of possible matches.  The callback is free to narrow its results by examining the current word, but is not required to do so.  The module will always return only the appropriate matches.</p><h3>\s-1EXAMPLE\s0</h3>
<p>This app takes 2 parameters, one of which is dependent on the other:</p><p>  use Getopt::Complete (     type =&gt; [&apos;names&apos;,&apos;places&apos;,&apos;things&apos;],     instance =&gt; sub {             my ($command, $value, $option, $other_opts) = @_;             if ($other_opts{type} eq &apos;names&apos;) {                 return [qw/larry moe curly/],             }             elsif ($other_opts{type} eq &apos;places&apos;) {                 return [qw/here there everywhere/],             }             elsif ($other_opts{type} eq &apos;things&apos;) {                 return [ query_database_matching("${value}%") ]             }             elsif ($otper_opts{type} eq &apos;surprsing&apos;) {                 # no defined list: take anything typed                 return undef;             }             else {                 # invalid type: no matches                 return []             }         }    );</p><p>   $ myprogram --type people --instance &lt;TAB&gt;    larry moe curly</p><p>   $ myprogram --type places --instance &lt;TAB&gt;    here there everywhere</p><p>   $ myprogram --type surprising --instance &lt;TAB&gt;    (no completions appear)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUILTIN COMPLETIONS</h2>
        <div class="sectioncontent">
<p>Bash has a list of built-in value types which it knows how to complete.  Any of the default shell completions supported by bash's \*(L"compgen\*(R" are supported by this module.</p><p>The list of builtin types supported as-of this writing are:</p><p>    files     directories     commands     users     groups     environment     services     aliases     builtins</p><p>To indicate that an argument's valid values are one of the above, use the exact string after Getopt::Complete:: as the completion callback.  For example:</p><p>  use Getopt::Complete (     infile  =&gt; &apos;Getopt::Complete::files&apos;,     outdir  =&gt; &apos;Getopt::Complete::directories&apos;,     myuser  =&gt; &apos;Getopt::Complete::users&apos;,   );</p><p>The full name is alissed as the single-character compgen parameter name for convenience. Further, because Getopt::Complete is the default namespace during processing, it can be omitted from callback function names.</p><p>The following are all equivalent.  They effectively produce the same list as 'compgen -f':</p><p>   file1 =&gt; &#92;&Getopt::Complete::files    file1 =&gt; &#92;&Getopt::Complete::f    file1 =&gt; &apos;Getopt::Complete::files&apos;    file1 =&gt; &apos;Getopt::Complete::f&apos;    file1 =&gt; &apos;files&apos;    file1 =&gt; &apos;f&apos;</p><p>See Getopt::Complete::Compgen for specifics on using builtin completions.</p><p>See \*(L"man bash\*(R", in the Programmable Complete secion, and the \*(L"compgen\*(R" builtin command for more details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UNLISTED VALID VALUES</h2>
        <div class="sectioncontent">
<p>If there are options which should not be part of completion lists, but still count as valid if passed-into the app, they can be in a final sub-array at the end.  This list doesn't affect the completion system at all, just prevents errors in the \s-1ERRORS\s0 array described above.</p><p>    use Getopt::Complete (         &apos;color&apos;    =&gt; [&apos;red&apos;,&apos;green&apos;,&apos;blue&apos;, [&apos;yellow&apos;,&apos;orange&apos;]],     );</p><p>    myprogram --color &lt;TAB&gt;     red green blue</p><p>    myprogram --color orange     # no errors</p><p>    myprogram --color purple     # error</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARTIAL COMPLETIONS</h2>
        <div class="sectioncontent">
<h3>\s-1BASICS\s0</h3>
<p>Any returned value ending in a &lt;\s-1TAB\s0&gt; character (\*(L"&#92;t\*(R") will be considered a \*(L"partial\*(R" completion.  This means that the shell will be instructed to leave the cursor at the end of that word even if there is no ambiguity in the rest of the returned list.</p><p>Partial completions are only usable from callbacks.  From a hard-coded array of values, it would be impossible to ever fuly complete the partial completion.</p>
<h3>\s-1BACKGROUND\s0</h3>
<p>Sometimes, the entire list of completions is too big to reasonable resolve and return.  The most obvious example is filename completion at the root of a large filesystem.  In these cases, the completion of is handled in pieces, allowing the user to gradually \*(L"drill down\*(R" to the complete value directory by directory. It is even possible to hit &lt;\s-1TAB\s0&gt; to get one completion, then hit it again and get more completion, in the case of single-sub-directory directories.</p><p>The Getopt::Complete module supports iterative drill-down completions from any parameter configured with a callback.  It is completely valid to complete \*(L"a\*(R" with \*(L"aa\*(R" \*(L"ab\*(R" and \*(L"ac\*(R", but then to complete \*(L"ab\*(R" with yet more text.</p><p>Unless the shell knows, however that your \*(L"aa\*(R", \*(L"ab\*(R", and \*(L"ac\*(R" completions are in fact only partial completions, an inconvenient space will be added after the word on the terminal line, as the shell happily moves on to helping the user enter the next argument.</p>
<h3>\s-1DETAILS\s0</h3>
<p>Because partial completions are indicated in Getopt::Complete by adding a \*(L"&#92;t\*(R" tab character to the end of the returned string, an application can return a mix of partial and full completions, and it will respect each correctly.</p><p>Note: The \*(L"&#92;t\*(R" is actually stripped-off before going to the shell and internal hackery is used to force the shell to not put a space where it isn't needed.  This is not part of the bash programmable completion specification, but is used to simulate features typically only available with bash for builtin completions like files/directories.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUB-COMMAND TREES</h2>
        <div class="sectioncontent">
<p>It is common for a given appliction to actually be an entry point for several different tools. Popular exmples are the big version control suites (cvs,svn,svk,git), which use the form:</p><p> cvs SUBCOMMAND [ARGS]</p><p>Each sub-command has its own options specification.  Those may in turn have further sub-commands.</p><p>Sub-commands are identified by an initial '&gt;' in the options specification key.  The value is interpreted as a complete, isolated options spec, using the same general syntax.  This applies recursively.</p><h3>\s-1EXAMPLE\s0 \s-1COMMAND\s0 \s-1TREE\s0 \s-1SPEC\s0</h3>
<p>    use Getopt::Complete (         &apos;&gt;animal&apos; =&gt; [             &apos;&gt;dog&apos; =&gt; [                 &apos;&gt;bark&apos; =&gt; [                     &apos;ferocity&apos;  =&gt; [&apos;yip&apos;,&apos;wail&apos;,&apos;ruf&apos;,&apos;grrrr&apos;],                     &apos;count&apos;  =&gt; [&apos;1&apos;,&apos;2&apos;,&apos;one too many&apos;],                 ],                 &apos;&gt;drool&apos; =&gt; [                     &apos;buckets=n&apos; =&gt; undef,                     &apos;lick&apos;      =&gt; &apos;users&apos;,                 ],                 &apos;list!&apos; =&gt; undef,             ],             &apos;&gt;cat&apos; =&gt; [                 &apos;&gt;purr&apos; =&gt; [],                 &apos;&gt;meow&apos; =&gt; [                     &apos;volume=n&apos; =&gt; undef,                     &apos;bass&apos; =&gt; [&apos;low&apos;,&apos;medium&apos;,&apos;high&apos;],                 ]             ],         ],         &apos;&gt;plant&apos; =&gt; [             &apos;&gt;taters&apos; =&gt; [                 &apos;&gt;fry&apos; =&gt; [                     &apos;greasiness&apos;    =&gt; [&apos;crispy&apos;,&apos;drippy&apos;],                     &apos;width&apos;         =&gt; [&apos;fat&apos;,&apos;thin&apos;,&apos;frite&apos;],                 ],                 &apos;&gt;bake&apos; =&gt; [                     &apos;hard!&apos;     =&gt; undef,                     &apos;temp=n&apos;    =&gt; undef,                 ],             ],             &apos;&gt;dasies&apos; =&gt; [                 &apos;&gt;pick&apos; =&gt; [                     &apos;&lt;&gt;&apos;            =&gt; [&apos;mine&apos;,&apos;yours&apos;,&apos;theirs&apos;],                 ],                 &apos;&gt;plant&apos; =&gt; [                     &apos;season&apos;        =&gt; [&apos;winter&apos;,&apos;spring&apos;,&apos;summer&apos;,&apos;fall&apos;],                     &apos;seeds=n&apos;       =&gt; undef,                     &apos;deep!&apos;         =&gt; undef,                 ]             ]         ]     );</p><p>    my ($word1,$word2,$word3) = $ARGS-&gt;parent_sub_commands;     # (the above is also in $ARGS{&apos;&gt;&apos;} for non-OO access)</p><p>    # your program probably has something smarter to decide where to go     # for a given command     if ($word1 eq &apos;animal&apos;) {         if ($word2 eq &apos;dog&apos;) {             if ($word3 eq &apos;bark&apos;) {                 # work with %ARGS for barking dogs...                 # ....             }         }     }     elsif ($path[0] eq &apos;plant&apos;) {         ...     }</p><p>The above example specifies two sub-commands \*(L"animal\*(R" and "plant, each of which has its own two sub-commands, dog/cat and taters/dasies.  Each of those, in turn, have two sub-commands, for a total of 8 complete commands possible, each with different arguments.  Each of the 8 has thier own options specification.</p><p>When the program executes, the %ARGS hash contains option/value pairs for the specific command chosen.  The the series of sub-command choices in $ARGS{'&gt;'}, separate from the regular bare arguments in '&lt;&gt;'. (The method name on an $ARGS object for this is \*(L"parent_sub_commands\*(R", a companion to the \*(L"bare_args\*(R" method.</p><p>The method to determine the next available sub-commands is just \*(L"sub_commands\*(R".)</p><p>Note that, since the user can hit &lt;\s-1ENTER\s0&gt; at any time, it is possible that the parent_sub_commands will be a partial drill-down.  It isn't uncommon to have something like this in place:</p><p> if (my @next = $ARGS-&gt;sub_commands) {     print STDERR "Please select a sub-command:&#92;n";     print STDERR join("&#92;n", @sub_commands),"&#92;n";     exit 1;  }</p><p>The above checking is not done automatically, since a sub-command may have further sub-commands, but still also be used directly, possibly with other option and bare arguments.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE LONE DASH</h2>
        <div class="sectioncontent">
<p>A lone dash is often used to represent using \s-1STDIN\s0 instead of a file for applications which otherwise take filenames.</p><p>This is supported by all options which complete with the \*(L"files\*(R" builtin, though it does not appear in completion hint displays.</p><p>To disable this, set $Getopt::Complete::LONE_DASH = 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERRIDING COMPILE-TIME OPTION PARSING</h2>
        <div class="sectioncontent">
<p>Getopt::Complete makes a lot of assumptions in order to be easy to use in the default case.  Here is how to override that behavior if it's not what you want.</p><h3>\s-1OPTION\s0 1: \s-1DOING\s0 \s-1CUSTOM\s0 \s-1ERROR\s0 \s-1HANDLING\s0</h3>
<p>To prevent Getopt::Complete from exiting at compile time if there are errors, the \s-1EXIT_ON_ERRORS\s0 flag should be set to 0 first, at compile time, before using the Getopt::Complete module as follows:</p><p> BEGIN { $Getopt:Complete::EXIT_ON_ERRORS = 0; }</p><p>This should not affect completions in any way (it will still exit if it realizes it is talking to bash, to prevent accidentally running your program).</p><p>Errors are retained in:</p><p> $Getopt::Complete::ARGS-&gt;errors;</p><p>It is then up to the application to not run with invalid parameters. This module restores @ARGV to its original state after processing, so independent option processing can be done if necessary.  The full spec imported by Getopt::Complete is stored as:</p><p> $Getopt::Complete::ARGS-&gt;option_specs;</p><p>This is an easy option when upgrading old applications.</p><p>Combined with disabling the \s-1EXIT_ON_ERROS\s0 flag  above, set, you can completely ignore, or partially ignore, the options processing which happens automatically.</p>
<h3>\s-1OPTION\s0 3: \s-1CHANGING\s0 COMPILE-TIME \s-1PROCESSING\s0</h3>
<p>You can also adjust how option processing happens inside of Getopt::Complete. Getopt::Complete wraps Getopt::Long to do the underlying option parsing.  It uses GetOptions(&#92;%h, @specification) to produce the %ARGS hash.  Customization of Getopt::Long should occur in a \s-1BEGIN\s0 block before using Getopt::Complete.</p>
<h3>\s-1OPTION\s0 4: \s-1USE\s0 \s-1THE\s0 \s-1OBJECTS\s0 \s-1AND\s0 \s-1WRITE\s0 \s-1YOUR\s0 \s-1OWN\s0 \s-1LOGIC\s0</h3>
<p>The logic in <em>import()</em> is very short, and is simple to modify.  It is best to do it in a \s-1BEGIN\s0 {} block so that bash can use 'perl -c myprogram' to get completions at compile time.</p><p>    BEGIN {</p><p>        my $options = Getopt::Complete::Options-&gt;new(             &apos;myfile&apos; =&gt; &apos;f&apos;,             &apos;mychoice&apos; =&gt; [&apos;small&apos;,&apos;medium&apos;,&apos;huge&apos;]         );</p><p>        $options-&gt;handle_shell_completion();</p><p>        my $args = Getopt::Complete::Args-&gt;new(             options =&gt; $options,             argv =&gt; [@ARGV]         );</p><p>        if (my @errors = $ARGS-&gt;errors) {             for my $error ($ARGS-&gt;errors) {                 chomp $error;                 warn _\|_PACKAGE_\|_ . &apos; ERROR:&apos; . $error . "&#92;n";             }             exit 1;         }</p><p>        # make the %ARGS available to all of the app         $args-&gt;_\|_install_as_default_\|_;</p><p>        # if you also want %ARGS and $ARGS here when you&apos;re finished...         Getopt:Complete-&gt;export_aliases(_\|_PACKAGE_\|_);     };</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTENSIVE USAGE EXAMPLE</h2>
        <div class="sectioncontent">
<p>Cut-and-paste this into a script called \*(L"myprogram\*(R" in your path, make it executable, and then run this in the shell:</p><p>  function _getopt_complete () {     COMPREPLY=($( COMP_CWORD=$COMP_CWORD perl &#96;which ${COMP_WORDS[0]}&#96; ${COMP_WORDS[@]:0} ));   }   complete -F _getopt_complete myprogram</p><p>Then try it out. It does one of everything, besides command trees.</p><p>    #!/usr/bin/env perl     use strict;     use warnings;</p><p>    use Getopt::Complete (         # list the explicit values which are valid for this option         &apos;frog&apos;    =&gt; [&apos;ribbit&apos;,&apos;urp&apos;,&apos;ugh&apos;],</p><p>        # you can add any valid Getopt::Long specification to the key on the left         # ...if you put nothing: "=s" is assumed         &apos;names=s@&apos; =&gt; [&apos;eenie&apos;,&apos;meanie&apos;,&apos;miney&apos;],</p><p>        # support for Bash "compgen" builtins is present with some pre-made callbacks         &apos;myfile&apos;    =&gt; &apos;Getopt::Complete::Compgen::files&apos;,         &apos;mydir&apos;     =&gt; &apos;Getopt::Complete::Compgen::directories&apos;,</p><p>        # the plain name or first letter of the compgen builtins also work         &apos;myfile2&apos;   =&gt; &apos;files&apos;,         &apos;myfile3&apos;   =&gt; &apos;f&apos;,</p><p>        # handle unnamed arguments from the command-line ("non-option" arguments) with a special key:         &apos;&lt;&gt;&apos;      =&gt; [&apos;some&apos;,&apos;raw&apos;,&apos;words&apos;],</p><p>        # CODE callbacks allow a the completion list to be dynamically resolved         &apos;fraggle&apos; =&gt; sub { return [&apos;rock&apos;,&apos;roll&apos;,&apos;fried fish&apos;,&apos;fried taters&apos;,&apos;fries and squid&apos;] },</p><p>        # callbacks get extra info to help them, including the part of the         # word already typed, and the remainder of the options already processed for context         &apos;type&apos;    =&gt; [&apos;people&apos;,&apos;places&apos;],         &apos;instance&apos;=&gt; sub {                             my ($command, $partial_word, $option_name, $other_opts_hashref) = @_;                             # be lazy and ignore the partial word: bash will compensate                             if (my $type = $other_opts_hashref-&gt;{type}) {                                 if ($type eq &apos;people&apos;) {                                     return [qw/larry moe curly/]                                 }                                 elsif ($type eq &apos;places&apos;) {                                     return [qw/here there everywhere/],                                 }                             }                             return [];                         },</p><p>        # undef means we don&apos;t know how to complete the value: any value specified will do         # this will result in no shell ompletions, but will still expect a value to be entered         &apos;name=s&apos;  =&gt; undef,</p><p>        # boolean values never have a completion list, and will yell if you are that foolish         # this will give you --no-fast for free as well         &apos;fast!&apos;     =&gt; undef,</p><p>    );</p><p>    use Data::Dumper;     print "The arguments are: " . Dumper(&#92;%ARGS);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEVELOPMENT</h2>
        <div class="sectioncontent">
<p>Patches are welcome.</p><p> http://github.com/sakoht/Getopt--Complete-for-Perl/</p><p> git clone git://github.com/sakoht/Getopt--Complete-for-Perl.git</p><p>As are complaints.  Help us find bugs by sending an email to the address below, or using \s-1CPAN\s0's bug tracking system:</p><p> https://rt.cpan.org/</p><p>The latest version of this module is always availabe on \s-1CPAN:\s0</p><p> http://search.cpan.org/search?query=Getopt%3A%3AComplete&mode=all</p><p>And is readily installable with the \s-1CPAN\s0 shell on Mac, Linux, and other Unix-like systems:</p><p> sudo cpan Getopt::Complete</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Completions with whitespace work, but they do so by escaping whitespace characters instead of quoting. Support should be present for completing quoted text.  It should also be the default, since it is more attractive.</p><p>The logic to \*(L"shorten\*(R" the completion options shown in some cases is still in development. This means that filename completion shows full paths as options instead of just the last word in the file path.</p><p>Some uses of Getopt::Long will not work currently: multi-name options (though standard shortening works), +, :, %.</p><p>Currently this module only supports bash, though other shells could be added easily.</p><p>There is logic in development to have the tool possibly auto-update the user's .bashrc / .bash_profile, but this is incomplete.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Getopt::Complete&hellip;</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Getopt::Complete::Args
  </dt>
  <dd>
    <p>the object \s-1API\s0 for the option/value argument set</p>
  </dd>
  <dt>
    Getopt::Complete::Options
  </dt>
  <dd>
    <p>the object \s-1API\s0 for the options specification</p>
  </dd>
  <dt>
    Getopt::Complete::Compgen
  </dt>
  <dd>
    <p>supplies builtin completions like file lists</p>
  </dd>
  <dt>
    Getopt::Long
  </dt>
  <dd>
    <p>the definitive options parser, wrapped by this module</p>
  </dd>
  <dt>
    bash
  </dt>
  <dd>
    <p>the manual page for bash has lots of info on how tab-completion works</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2010, 2011 Washington University School of Medicine</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Scott Smith (sakoht at cpan .org) Nathan Nutter Andrei Benea</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>The full text of the license can be found in the \s-1LICENSE\s0 file included with this module.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Getopt::ArgvFile.3pm.html"><span aria-hidden="true">&larr;</span> Getopt::ArgvFile.3pm: Interpolates script options from files into @argv or another array</a></li>
   <li class="next"><a href="Getopt::Complete::Args.3pm.html">Getopt::Complete::Args.3pm: A set of option/value pairs <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

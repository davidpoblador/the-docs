<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::LibXML::Iterator: Xml::libxml's tree iteration class</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Xml::libxml's tree iteration class">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::LibXML::Iterator (3pm) manual">
  <meta name="twitter:description" content="Xml::libxml's tree iteration class">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-libxml-iterator-perl-XML::LibXML::Iterator-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::LibXML::Iterator.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::LibXML::Iterator (3pm) manual" />
  <meta property="og:description" content="Xml::libxml's tree iteration class" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-libxml-iterator-perl-XML::LibXML::Iterator-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::LibXML::Iterator<small> (3pm)</small></h1>
        <p class="lead">Xml::libxml's tree iteration class</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::LibXML::Iterator.3pm.html">
      <span itemprop="name">XML::LibXML::Iterator: Xml::libxml's tree iteration class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-libxml-iterator-perl/">
      <span itemprop="name">libxml-libxml-iterator-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::LibXML::Iterator.3pm.html">
      <span itemprop="name">XML::LibXML::Iterator: Xml::libxml's tree iteration class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use XML::LibXML;
  use XML::LibXML::Iterator;

  my $doc = XML::LibXML-&gt;new-&gt;parse_string( $somedata );
  my $iter= XML::LibXML::Iterator-&gt;new( $doc );

  $iter-&gt;iterator_function( &#92;&iterator_function );

  # more control on the flow
  while ( $iter-&gt;nextNode ) {
      # do something
  }

  # operate on the entire tree
  $iter-&gt;iterate( &#92;&callback_function );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>XML::LibXML::Iterator is an iterator class for XML::LibXML parsed documents. This class allows to iterate the document tree as it were a linear data structure. It is possible to step back and forth between the nodes of the tree and do certain operations on that nodes. Different to XPath the nodes are not prefetched but will be calculated for each step. Therefore an iterator is sensible towards the current state of a document tree on each step, while XPath is only per query executed.</p><h3>What is an iterator?</h3>
<p>XML::LibXML offers by default a W3C \s-1DOM\s0 interface on the parsed \s-1XML\s0 documents. This tree has per definition four directions to be traversed: Up, down, foreward and backward. Therefore a tree can be considered two dimensional. Although a tree is still one more simple datastructure it is way to complex for some operations. So the XML::LibXML::Iterator class breaks the for operations down to only two: backward and forward. For some people this easier to understand than \s-1DOM\s0 or \s-1SAX\s0 as this follows more the way one actually reads an \s-1XML\s0 document.</p><p>Therefore an iterator has three basic functions:</p><ul>
<li><p><em>nextNode()</em></p></li><li><p><em>current()</em></p></li><li><p><em>previousNode()</em></p></li>
</ul><p>That's it. With an iterator one does not have to decide when to dive into a subtree or find a parent. It is not even required to care about the boundaries of a certain level. The iterator will get the next node for you until there is no node left to handle.</p><p>In short: An iterator will answer the question about what to do next.</p>
<h3>How to use XML::LibXML::Iterator?</h3>
<p>XML::LibXML::Iterator requires a parsed document or at least a node to operate on. This node is passed to the iterator class and will be used as the <strong>first</strong> node of the iteration. One can allways reset the iterator to the first node by using the <em>first()</em>-function.</p><p>Once XML::LibXML::Iterator is initialized the tree can be traversed by using either <em>next()</em> or <em>previous()</em>. Both function will return a XML::LibXML::Node object if there is such object available.</p><p>Since the current object hold by the iterator class is always available via the <em>current()</em> function.</p><p>The following example may clearify this:</p><p>  # get the document from wherever you like   my $doc = XML::LibXML-&gt;new-&gt;parse_stream( *SOMEINPUT );</p><p>  # get the iterator for the document root.   my $iter = XML::LibXML::Iterator-&gt;new( $doc-&gt;documentElement );</p><p>  # walk through the document   while ( $iter-&gt;nextNode() ) {      my $curnode = $iter-&gt;current();      print $curnode-&gt;nodeType();   }</p><p>  # now get back to the beginning   $iter-&gt;first();   my $curnode = $iter-&gt;current();   print $curnode-&gt;nodeType();</p><p>Actually the functions <em>nextNode()</em>, <em>previousNode()</em>, <em>first()</em>, <em>last()</em> and <em>current()</em> do return the node which is current after the operation. E.g. <em>nextNode()</em> moves to the next node if possible and then returns the node. Thus the while-loop in the example can be written as</p><p>  while ( $iter-&gt;nextNode() ) {      print $_-&gt;nodeType();   }</p><p>Note, that just relieing on the return value of <em>next()</em> and <em>previous()</em> is somewhat dangerous, because both functions return <strong>undef</strong> in case of reaching the iteration boundaries. That means it is not possible to iterate past the last element or before the first one.</p>
<h3>Node Filters</h3>
<p>XML::LibXML::Iterator accepts XML::NodeFilters to limit the nodes made available to the caller. Any nodefilter applied to XML::LibXML::Iterator will test if a node returned by the iteration function is visible to the caller.</p><p>Different to the \s-1DOM\s0 Traversal Specification, XML::LibXML::Iterator allows filter stacks. This means it is possible to apply more than a single node filter to your node iterator.</p>
<h3>Complex Iterations</h3>
<p>By default XML::LibXML::Iterator will access all nodes of a given \s-1DOM\s0 tree. An interation based on the default iterator will access each single node in the given subtree once. The order how the nodes will be accessed is given by the following order:</p><p>  node -&gt; node&apos;s childnodes -&gt; node&apos;s next sibling</p><p>In combination with XML::Nodefilter this is best for a wide range of scripts and applications. Nevertheless this is still to restrictive for some applications. XML::LibXML::Iterator allows to change that behaviour. This is done by resetting XML::LibXML::Iterator's iterator function. By using the method <em>iterator_function()</em> to override the default iterator function, it is possible to implement iterations based on any iteration rule imaginable.</p><p>A valid iterator function has to take two parameters: As the first parameter it will recieve the iterator object itself, as second the direction of the iteration will be passed. The direction is either 1 (for <em>next()</em>) or -1 (for <em>previous()</em>). As the iterator-function is called by <em>next()</em> and <em>previous()</em> the interator-function has to be aware about the iteration boundaries. In case the iteration would pass the boundary for that operation, the function has to return undefined. Also the iterator function has to return the new current node, instead of setting it itself.</p><p>*DEVELOPER NOTE* In order a single stepping is rather limited, the direction is given by the sign of the passed integer value. The value of the passed parameter will be used as an indication how many steps should be done.  Therefor the interation direction should be tested relative to '0' and not as a equation. A basic template for a iterator function therefore will look like this:</p><p>   sub iterator_func_templ {       my $iter = shift;       my $step = shift;       my $node = undef;       my $current = $iter-&gt;current();</p><p>      if ( $step &gt; 0 ) {           # move forward       }       else {           # move backward           $step *= -1; # remove the sign       }</p><p>      return $node;    }</p>
<h3>Repeated Operation</h3>
<p>Another feature of XML::LibXML::Iterator is the ability to repeat a single operation on all nodes in scope. Instead of writing a loop one can specify the opeation as a function, that it applied on each node found. The function that does the trick, is named <em>iterate()</em>.</p><p><em>iterate()</em> takes again two parameter: First the iterator object, second the node to operate on. <em>iterate()</em> will iterate through the entire document starting with the first node. If one has already started an iteration, the internal position will be reset to the first node.</p><p>The following example will show how this works:</p><p>  $iter-&gt;iterate( sub {my ($iter,$node)=@_; map {$iter-&gt;setNodeName( lc $iter-&gt;nodeName ) if $iter-&gt;nodeType != NAMESPACE_DECLARATION } ($node, $node-&gt;attributes);  } );</p><p>This extra long line lowercases all tagnames and the names of the attributes in a given subtree.</p>
<h3>Functions</h3>

<dl class='dl-vertical'>
  <dt>
    new($first_node)
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>first()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>nextNode()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>previousNode()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>last()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>current()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>index()</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    iterator_function($funcion_ref)
  </dt>
  <dd>
    
  </dd>
  <dt>
    set_filter(@filter_list)
  </dt>
  <dd>
    
  </dd>
  <dt>
    add_filter(@filter_list)
  </dt>
  <dd>
    
  </dd>
  <dt>
    iterate($function_ref)
  </dt>
  <dd>
    
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::LibXML::Iterator&hellip;</h2>
        <div class="sectioncontent">
<p>XML::LibXML::Node, XML::NodeFilter</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Christian Glahn, &lt;phish@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>(c) 2002-2007, Christian Glahn. All rights reserved.</p><p>This package is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::LibXML::Debugging.3pm.html"><span aria-hidden="true">&larr;</span> XML::LibXML::Debugging.3pm: Get debugging information from xml::libxml nodes</a></li>
   <li class="next"><a href="XML::LibXML::LazyBuilder.3pm.html">XML::LibXML::LazyBuilder.3pm: Easy and lazy way to create xml documents for xml::libxml <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

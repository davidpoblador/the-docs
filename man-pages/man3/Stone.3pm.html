<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Stone: In-memory storage for hierarchical tag/value data structures</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="In-memory storage for hierarchical tag/value data structures">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Stone (3pm) manual">
  <meta name="twitter:description" content="In-memory storage for hierarchical tag/value data structures">
  <meta name="twitter:image" content="https://www.carta.tech/images/libboulder-perl-Stone-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Stone.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Stone (3pm) manual" />
  <meta property="og:description" content="In-memory storage for hierarchical tag/value data structures" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libboulder-perl-Stone-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Stone<small> (3pm)</small></h1>
        <p class="lead">In-memory storage for hierarchical tag/value data structures</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Stone.3pm.html">
      <span itemprop="name">Stone: In-memory storage for hierarchical tag/value data structures</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libboulder-perl/">
      <span itemprop="name">libboulder-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Stone.3pm.html">
      <span itemprop="name">Stone: In-memory storage for hierarchical tag/value data structures</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Stone;
 my $stone = Stone-&gt;new( Jim =&gt; { First_name =&gt; &apos;James&apos;,
                                  Last_name  =&gt; &apos;Hill&apos;,
                                  Age        =&gt; 34,
                                  Address    =&gt; {
                                         Street =&gt; [&apos;The Manse&apos;,
                                                    &apos;19 Chestnut Ln&apos;],
                                         City  =&gt; &apos;Garden City&apos;,
                                         State =&gt; &apos;NY&apos;,
                                         Zip   =&gt; 11291 }
                                },
                          Sally =&gt; { First_name =&gt; &apos;Sarah&apos;,
                                     Last_name  =&gt; &apos;James&apos;,
                                     Age        =&gt; 30,
                                     Address    =&gt; {
                                         Street =&gt; &apos;Hickory Street&apos;,
                                         City  =&gt; &apos;Katonah&apos;,
                                         State =&gt; &apos;NY&apos;,
                                         Zip  =&gt; 10578 }
                                }
                         );

 @tags    = $stone-&gt;tags;          # yields (&apos;James&apos;,&apos;Sally&apos;);
 $address = $stone-&gt;Jim-&gt;Address;  # gets the address subtree
 @street  = $address-&gt;Street;      # yeilds (&apos;The Manse&apos;,&apos;19 Chestnut Ln&apos;)

 $address = $stone-&gt;get(&apos;Jim&apos;)-&gt;get(&apos;Address&apos;); # same as $stone-&gt;Jim-&gt;Address
 $address = $stone-&gt;get(&apos;Jim.Address&apos;); # another way to express same thing

 # first Street tag in Jim&apos;s address
 $address = $stone-&gt;get(&apos;Jim.Address.Street[0]&apos;);
 # second Street tag in Jim&apos;s address
 $address = $stone-&gt;get(&apos;Jim.Address.Street[1]&apos;);
 # last Street tag in Jim&apos;s address
 $address = $stone-&gt;get(&apos;Jim.Address.Street[#]&apos;);

 # insert a tag/value pair
 $stone-&gt;insert(Martha =&gt; { First_name =&gt; &apos;Martha&apos;, Last_name =&gt; &apos;Steward&apos;} );

 # find the first Address
 $stone-&gt;search(&apos;Address&apos;);

 # change an existing subtree
 $martha = $stone-&gt;Martha;
 $martha-&gt;replace(Last_name =&gt; &apos;Stewart&apos;);  # replace a value

 # iterate over the tree with a cursor
 $cursor = $stone-&gt;cursor;
 while (my ($key,$value) = $cursor-&gt;each) {
   print "$value: Go Bluejays!&#92;n" if $key eq &apos;State&apos; and $value eq &apos;Katonah&apos;;
 }

 # various format conversions
 print $stone-&gt;asTable;
 print $stone-&gt;asString;
 print $stone-&gt;asHTML;
 print $stone-&gt;asXML(&apos;Person&apos;);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A Stone consists of a series of tag/value pairs.  Any given tag may be single-valued or multivalued.  A value can be another Stone, allowing nested components.  A big Stone can be made up of a lot of little stones (pebbles?).  You can obtain a Stone from a Boulder::Stream or Boulder::Store persistent database. Alternatively you can build your own Stones bit by bit.</p><p>Stones can be exported into string, \s-1XML\s0 and \s-1HTML\s0 representations.  In addition, they are flattened into a linearized representation when reading from or writing to a Boulder::Stream or one of its descendents.</p><p>Stone was designed for subclassing.  You should be able to create subclasses which create or require particular tags and data formats. Currently only Stone::GB_Sequence subclasses Stone.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTORS</h2>
        <div class="sectioncontent">
<p>Stones are either created by calling the <em>new()</em> method, or by reading them from a Boulder::Stream or persistent database. This is the main constructor for the Stone class.  It can be called without any parameters, in which case it creates an empty Stone object (no tags or values), or it may passed an associative array in order to initialize it with a set of tags.  A tag's value may be a scalar, an anonymous array reference (constructed using [] brackets), or a hash references (constructed using {} brackets).  In the first case, the tag will be single-valued.  In the second, the tag will be multivalued. In the third case, a subsidiary Stone will be generated automatically and placed into the tree at the specified location.</p><p>Examples:</p><p>        $myStone = new Stone;         $myStone = new Stone(Name=&gt;&apos;Fred&apos;,Age=&gt;30);         $myStone = new Stone(Name=&gt;&apos;Fred&apos;,                              Friend=&gt;[&apos;Jill&apos;,&apos;John&apos;,&apos;Jerry&apos;]);         $myStone = new Stone(Name=&gt;&apos;Fred&apos;,                              Friend=&gt;[&apos;Jill&apos;,                                       &apos;John&apos;,                                       &apos;Gerald&apos;                                       ],                              Attributes =&gt; { Hair =&gt; &apos;blonde&apos;,                                              Eyes =&gt; &apos;blue&apos; }                              );</p><p>In the last example, a Stone with the following structure is created:</p><p> Name        Fred  Friend      Jill  Friend      John  Friend      Gerald  Attributes  Eyes    blue              Hair    blonde</p><p>Note that the value corresponding to the tag \*(L"Attributes\*(R" is itself a Stone with two tags, \*(L"Eyes\*(R" and \*(L"Hair\*(R".</p><p>The \s-1XML\s0 representation (which could be created with <em>asXML()</em>) looks like this:</p><p> &lt;?xml version="1.0" standalone="yes"?&gt;  &lt;Stone&gt;     &lt;Attributes&gt;        &lt;Eyes&gt;blue&lt;/Eyes&gt;        &lt;Hair&gt;blonde&lt;/Hair&gt;     &lt;/Attributes&gt;     &lt;Friend&gt;Jill&lt;/Friend&gt;     &lt;Friend&gt;John&lt;/Friend&gt;     &lt;Friend&gt;Gerald&lt;/Friend&gt;     &lt;Name&gt;Fred&lt;/Name&gt;  &lt;/Stone&gt;</p><p>More information on Stone initialization is given in the description of the <em>insert()</em> method.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT METHODS</h2>
        <div class="sectioncontent">
<p>Once a Stone object is created or retrieved, you can manipulate it with the following methods. This is the main method for adding tags to a Stone.  This method expects an associative array as an argument or a reference to one. The contents of the associative array will be inserted into the Stone. If a particular tag is already present in the Stone, the tag's current value will be appended to the list of values for that tag.  Several types of values are legal:</p><ul>
<li><p>A <strong>scalar</strong> value The value will be inserted into the \*(C`Stone\*(C'.         $stone-&gt;insert(name=&gt;Fred,                        age=&gt;30,                        sex=&gt;M);         $stone-&gt;dump;</p><p>        name[0]=Fred         age[0]=30         sex[0]=M</p></li><li><p>An <strong>\s-1ARRAY\s0</strong> reference A multi-valued tag will be created:         $stone-&gt;insert(name=&gt;Fred,                        children=&gt;[Tom,Mary,Angelique]);         $stone-&gt;dump;</p><p>        name[0]=Fred         children[0]=Tom         children[1]=Mary         children[2]=Angelique</p></li><li><p>A <strong>\s-1HASH\s0</strong> reference A subsidiary \*(C`Stone\*(C' object will be created and inserted into the object as a nested structure.         $stone-&gt;insert(name=&gt;Fred,                        wife=&gt;{name=&gt;Agnes,age=&gt;40});         $stone-&gt;dump;</p><p>        name[0]=Fred         wife[0].name[0]=Agnes         wife[0].age[0]=40</p></li><li><p>A \*(C`Stone\*(C' object or subclass The \*(C`Stone\*(C' object will be inserted into the object as a nested structure.         $wife = new Stone(name=&gt;agnes,                           age=&gt;40);         $husband = new Stone;         $husband-&gt;insert(name=&gt;fred,                          wife=&gt;$wife);         $husband-&gt;dump;</p><p>        name[0]=fred         wife[0].name[0]=agnes         wife[0].age[0]=40 The <strong></strong><strong>replace()</strong><strong></strong> method behaves exactly like \*(C`insert()\*(C' with the exception that if the indicated key already exists in the <strong>Stone</strong>, its value will be replaced.  Use <strong></strong><strong>replace()</strong><strong></strong> when you want to enforce a single-valued tag/value relationship. These are primitives used by the \*(C`insert()\*(C' and \*(C`replace()\*(C' methods. Override them if you need to modify the default behavior. This removes the indicated tag from the Stone. This returns the value at the indicated tag and optional index.  What you get depends on whether it is called in a scalar or list context. In a list context, you will receive all the values for that tag.  You may receive a list of scalar values or (for a nested record) or a list of Stone objects. If called in a scalar context, you will either receive the first or the last member of the list of values assigned to the tag.  Which one you receive depends on the value of the package variable $Stone::Fetchlast.  If undefined, you will receive the first member of the list. If nonzero, you will receive the last member.</p></li>
</ul><p>You may provide an optional index in order to force <em>get()</em> to return a particular member of the list.  Provide a 0 to return the first member of the list, or '#' to obtain the last member.</p><p>If the tag contains a period (.), <em>get()</em> will call <em>index()</em> on your behalf (see below).</p><p>If the tag begins with an uppercase letter, then you can use the autogenerated method to access it:</p><p>  $stone-&gt;Tag_name([$index])</p><p>This is exactly equivalent to:</p><p>  $stone-&gt;get(&apos;Teg_name&apos; [,$index]) Searches for the first occurrence of the tag, traversing the tree in a breadth-first manner, and returns it.  This allows you to retrieve the value of a tag in a deeply nested structure without worrying about all the intermediate nodes.  For example:</p><p> $myStone = new Stone(Name=&gt;&apos;Fred&apos;,                       Friend=&gt;[&apos;Jill&apos;,                                &apos;John&apos;,                                &apos;Gerald&apos;                               ],                       Attributes =&gt; { Hair =&gt; &apos;blonde&apos;,                                       Eyes =&gt; &apos;blue&apos; }                     );</p><p>   $hair_colour = $stone-&gt;search(&apos;Hair&apos;);</p><p>The disadvantage of this is that if there is a tag named \*(L"Hair\*(R" higher in the hierarchy, this tag will be retrieved rather than the lower one.  In an array context this method returns the complete list of values from the matching tag.  In a scalar context, it returns either the first or the last value of multivalued tags depending as usual on the value of $Stone::Fetchlast.</p><p>$Stone::Fetchlast is also consulted during the depth-first traversal.  If $Fetchlast is set to a true value, multivalued intermediate tags will be searched from the last to the first rather than the first to the last.</p><p>The Stone object has an \s-1AUTOLOAD\s0 method that invokes <em>get()</em> when you call a method that is not predefined.  This allows a very convenient type of shortcut:</p><p>  $name        = $stone-&gt;Name;   @friends     = $stone-&gt;Friend;   $eye_color   = $stone-&gt;Attributes-&gt;Eyes</p><p>In the first example, we retrieve the value of the top-level tag Name. In the second example, we retrieve the value of the Friend tag..  In the third example, we retrieve the attributes stone first, then the Eyes value.</p><p>\s-1NOTE:\s0 By convention, methods are only autogenerated for tags that begin with capital letters.  This is necessary to avoid conflict with hard-coded methods, all of which are lower case. You can access the contents of even deeply-nested <strong>Stone</strong> objects with the \*(C`index\*(C' method.  You provide a <strong>tag path</strong>, and receive a value or list of values back.</p><p>Tag paths look like this:</p><p>        tag1[index1].tag2[index2].tag3[index3]</p><p>Numbers in square brackets indicate which member of a multivalued tag you're interested in getting.  You can leave the square brackets out in order to return just the first or the last tag of that name, in a scalar context (depending on the setting of <strong></strong><strong>$Stone::Fetchlast</strong><strong></strong>).  In an array context, leaving the square brackets out will return <strong>all</strong> multivalued members for each tag along the path.</p><p>You will get a scalar value in a scalar context and an array value in an array context following the same rules as <strong></strong><strong>get()</strong><strong></strong>.  You can provide an index of '#' in order to get the last member of a list or a [?] to obtain a randomly chosen member of the list (this uses the <em>rand()</em> call, so be sure to call <em>srand()</em> at the beginning of your program in order to get different sequences of pseudorandom numbers.  If there is no tag by that name, you will receive undef or an empty list. If the tag points to a subrecord, you will receive a <strong>Stone</strong> object.</p><p>Examples:</p><p>        # Here&apos;s what the data structure looks like.         $s-&gt;insert(person=&gt;{name=&gt;Fred,                             age=&gt;30,                             pets=&gt;[Fido,Rex,Lassie],                             children=&gt;[Tom,Mary]},                    person=&gt;{name=&gt;Harry,                             age=&gt;23,                             pets=&gt;[Rover,Spot]});</p><p>        # Return all of Fred&apos;s children         @children = $s-&gt;index(&apos;person[0].children&apos;);</p><p>        # Return Harry&apos;s last pet         $pet = $s-&gt;index(&apos;person[1].pets[#]&apos;);</p><p>        # Return first person&apos;s first child         $child = $s-&gt;index(&apos;person.children&apos;);</p><p>        # Return children of all person&apos;s         @children = $s-&gt;index(&apos;person.children&apos;);</p><p>        # Return last person&apos;s last pet         $Stone::Fetchlast++;         $pet = $s-&gt;index(&apos;person.pets&apos;);</p><p>        # Return any pet from any person         $pet = $s-&gt;index(&apos;person[?].pet[?]&apos;);</p><p><em>Note</em> that <strong></strong><strong>index()</strong><strong></strong> may return a <strong>Stone</strong> object if the tag path points to a subrecord. This returns an \s-1ARRAY\s0 \s-1REFERENCE\s0 for the tag.  It is useful to prevent automatic dereferencing.  Use with care.  It is equivalent to:</p><p>        $stone-&gt;{&apos;tag&apos;}</p><p><em>at()</em> will always return an array reference.  Single-valued tags will return a reference to an array of size 1. Return all the tags in the Stone.  You can then use this list with <em>get()</em> to retrieve values or recursively traverse the stone. Return the data structure as a tab-delimited table suitable for printing. Return the data structure in \s-1XML\s0 format.  The entire data structure will be placed inside a top-level tag called &lt;Stone&gt;.  If you wish to change this top-level tag, pass it as an argument to <em>asXML()</em>.</p><p>An example follows:</p><p> print $stone-&gt;asXML(&apos;Address_list&apos;);  # yields:  &lt;?xml version="1.0" standalone="yes"?&gt;</p><p> &lt;Address_list&gt;     &lt;Sally&gt;        &lt;Address&gt;           &lt;Zip&gt;10578&lt;/Zip&gt;           &lt;City&gt;Katonah&lt;/City&gt;           &lt;Street&gt;Hickory Street&lt;/Street&gt;           &lt;State&gt;NY&lt;/State&gt;        &lt;/Address&gt;        &lt;Last_name&gt;Smith&lt;/Last_name&gt;        &lt;Age&gt;30&lt;/Age&gt;        &lt;First_name&gt;Sarah&lt;/First_name&gt;     &lt;/Sally&gt;     &lt;Jim&gt;        &lt;Address&gt;           &lt;Zip&gt;11291&lt;/Zip&gt;           &lt;City&gt;Garden City&lt;/City&gt;           &lt;Street&gt;The Manse&lt;/Street&gt;           &lt;Street&gt;19 Chestnut Ln&lt;/Street&gt;           &lt;State&gt;NY&lt;/State&gt;        &lt;/Address&gt;        &lt;Last_name&gt;Hill&lt;/Last_name&gt;        &lt;Age&gt;34&lt;/Age&gt;        &lt;First_name&gt;James&lt;/First_name&gt;     &lt;/Jim&gt;  &lt;/Address_list&gt; <em>attributes()</em> returns the \*(L"attributes\*(R" of a tag.  Attributes are a series of unique tag/value pairs which are associated with a tag, but are not contained within it.  Attributes can only be expressed in the \s-1XML\s0 representation of a Stone:</p><p>   &lt;Sally id="sally_tate" version="2.0"&gt;      &lt;Address type="postal"&gt;           &lt;Zip&gt;10578&lt;/Zip&gt;           &lt;City&gt;Katonah&lt;/City&gt;           &lt;Street&gt;Hickory Street&lt;/Street&gt;           &lt;State&gt;NY&lt;/State&gt;        &lt;/Address&gt;    &lt;/Sally&gt;</p><p>Called with no arguments, <em>attributes()</em> returns the current attributes as a hash ref:</p><p>    my $att = $stone-&gt;Address-&gt;attributes;     my $type = $att-&gt;{type};</p><p>Called with a single argument, <em>attributes()</em> returns the value of the named attribute, or undef if not defined:</p><p>    my $type = $stone-&gt;Address-&gt;attributes(&apos;type&apos;);</p><p>Called with two arguments, <em>attributes()</em> sets the named attribute:</p><p>    my $type = $stone-&gt;Address-&gt;attributes(type =&gt; &apos;Rural Free Delivery&apos;);</p><p>You may also change all attributes in one fell swoop by passing a hash reference as the single argument:</p><p>    $stone-&gt;attributes({id=&gt;&apos;Sally Mae&apos;,version=&gt;&apos;2.1&apos;}); <em>toString()</em> returns a simple version of the Stone that shows just the topmost tags and the number of each type of tag.  For example:</p><p>  print $stone-&gt;Jim-&gt;Address;       #yields =&gt; <a href="../man1/zip.1.html"><strong>Zip</strong>(1)</a>,<strong>City</strong>(1),<strong>Street</strong>(2),<strong>State</strong>(1)</p><p>This method is used internally for string interpolation.  If you try to print or otherwise manipulate a Stone object as a string, you will obtain this type of string as a result. Return the data structure as a nicely-formatted \s-1HTML\s0 3.2 table, suitable for display in a Web browser.  You may pass this method a callback routine which will be called for every tag/value pair in the object.  It will be passed a two-item list containing the current tag and value.  It can make any modifications it likes and return the modified tag and value as a return result.  You can use this to modify tags or values on the fly, for example to turn them into \s-1HTML\s0 links.</p><p>For example, this code fragment will turn all tags named \*(L"Sequence\*(R" blue:</p><p>  my $callback = sub {         my ($tag,$value) = @_;         return ($tag,$value) unless $tag eq &apos;Sequence&apos;;         return ( qq(&lt;FONT COLOR="blue"&gt;$tag&lt;/FONT&gt;),$value );   }   print $stone-&gt;asHTML($callback);</p><h3>\fIStone::dump()\fP</h3>
<p>This is a debugging tool.  It iterates through the <strong>Stone</strong> object and prints out all the tags and values.</p><p>Example:</p><p>        $s-&gt;dump;</p><p>        person[0].children[0]=Tom         person[0].children[1]=Mary         person[0].name[0]=Fred         person[0].pets[0]=Fido         person[0].pets[1]=Rex         person[0].pets[2]=Lassie         person[0].age[0]=30         person[1].name[0]=Harry         person[1].pets[0]=Rover         person[1].pets[1]=Spot         person[1].age[0]=23 Retrieves an iterator over the object.  You can call this several times in order to return independent iterators. The following brief example is described in more detail in Stone::Cursor.</p><p> my $curs = $stone-&gt;cursor;  while (my($tag,$value) = $curs-&gt;next_pair) {    print "$tag =&gt; $value&#92;n";  }  # yields:    Sally[0].Address[0].Zip[0] =&gt; 10578    Sally[0].Address[0].City[0] =&gt; Katonah    Sally[0].Address[0].Street[0] =&gt; Hickory Street    Sally[0].Address[0].State[0] =&gt; NY    Sally[0].Last_name[0] =&gt; James    Sally[0].Age[0] =&gt; 30    Sally[0].First_name[0] =&gt; Sarah    Jim[0].Address[0].Zip[0] =&gt; 11291    Jim[0].Address[0].City[0] =&gt; Garden City    Jim[0].Address[0].Street[0] =&gt; The Manse    Jim[0].Address[0].Street[1] =&gt; 19 Chestnut Ln    Jim[0].Address[0].State[0] =&gt; NY    Jim[0].Last_name[0] =&gt; Hill    Jim[0].Age[0] =&gt; 34    Jim[0].First_name[0] =&gt; James</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Lincoln D. Stein &lt;lstein@cshl.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 1997-1999, Cold Spring Harbor Laboratory, Cold Spring Harbor \s-1NY\s0.  This module can be used and distributed on the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Stone&hellip;</h2>
        <div class="sectioncontent">
<p>Boulder::Blast, Boulder::Genbank, Boulder::Medline, Boulder::Unigene, Boulder::Omim, Boulder::SwissProt</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Statistics::Test::Sequence.3pm.html"><span aria-hidden="true">&larr;</span> Statistics::Test::Sequence.3pm: Sequence correlation test for random numbers</a></li>
   <li class="next"><a href="Stone::Cursor.3pm.html">Stone::Cursor.3pm: Traverse tags and values of a stone <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

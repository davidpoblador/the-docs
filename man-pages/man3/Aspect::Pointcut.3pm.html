<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Aspect::Pointcut: Api for determining which events should be hooked</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Api for determining which events should be hooked">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Aspect::Pointcut (3pm) manual">
  <meta name="twitter:description" content="Api for determining which events should be hooked">
  <meta name="twitter:image" content="https://www.carta.tech/images/libaspect-perl-Aspect::Pointcut-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Aspect::Pointcut.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Aspect::Pointcut (3pm) manual" />
  <meta property="og:description" content="Api for determining which events should be hooked" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libaspect-perl-Aspect::Pointcut-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Aspect::Pointcut<small> (3pm)</small></h1>
        <p class="lead">Api for determining which events should be hooked</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Aspect::Pointcut.3pm.html">
      <span itemprop="name">Aspect::Pointcut: Api for determining which events should be hooked</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libaspect-perl/">
      <span itemprop="name">libaspect-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Aspect::Pointcut.3pm.html">
      <span itemprop="name">Aspect::Pointcut: Api for determining which events should be hooked</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Aspect-Oriented Programming implementations draw much of their power from the flexibility that can be applied to when a function call should or should not be hooked.</p><p><strong>Aspec::Pointcut</strong> provides a robust and powerful \s-1API\s0 for defining the rules for when a function call should be hooked, and then applying the rules as optimally as possible. This optimisation is particularly important for any pure-Perl implementation, which cannot hook deeply into the underlying virtual machine as you might with a Java or Perl XS-based implementation.</p><p>A running program can be seen as a collection of events. Events like a sub returning from a call, or a package being used. These are called join points. A pointcut defines a set of join points, taken from all the join points in the program. Different pointcut classes allow you to define the set in different ways, so you can target the exact join points you need.</p><p>Pointcuts are constructed as trees; logical operations on pointcuts with one or two arguments (not, and, or) are themselves pointcut operators. You can construct them explicitly using object syntax, or you can use the convenience functions exported by Aspect and the overloaded operators \*(C`!\*(C', \*(C`&\*(C' and \*(C`|\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>new</h3>
<p>The \*(C`new\*(C' constructor creates new pointcut objects.</p><p>All pointcut classes define their own rules around the parameters that are provided, but once created these pointcuts can then all be mixed together in an arbitrary fashion.</p><p>Note: Unlike most Perl objects the default and recommended underlying datatype for pointcut objects is an \*(C`ARRAY\*(C' reference rather than \*(C`HASH\*(C' references. This is done because pointcut code can directly impact the speed of function calls, and so is extremely performance sensitive.</p>
<h3>match_all</h3>

<pre>
  my @fully_resolved_function_names = $pointcut-&gt;match_all;
</pre>
<p>The \*(C`match_all\*(C' method is the primary compile-time function called on the pointcut model by the core Aspect library.</p><p>It will examine the list of all loaded functions and identify those which could potentially match, and will need to have hooks installed to intercept calls to those functions.</p><p>These functions will not necesarily all result in Aspect code being run. Some functions may be called in all cases, but often further run-time analyis needs to be done before we can be sure the particular function call respresents a match.</p><p>Returns a list of fully-resolved function names (e.g. \*(L"Module::Name::function\*(R")</p>
<h3>match_define</h3>
<p>  my $should_hook = $pointcut-&gt;match_define;</p><p>At compile time, the only common factor in predicting the future state of a function call is the name of the function itself.</p><p>The \*(C`match_define\*(C' method is called on the pointcut for each theoretically-matchable function in the entire Perl namespace that part of an ignored namespace, passing a single parameter of the fully-resolved function name.</p><p>The method will determine if the function <strong>might</strong> match, and needs to be hooked for further checking at run-time, potentially calling \*(C`match_define\*(C' on child objects as well.</p><p>Returns true if the function might match the pointcut, or false if the function can never possibly match the pointcut and should never be checked at run-time.</p>
<h3>compile_weave</h3>
<p>The \*(C`compile_weave\*(C' method generates a custom function that is used to test if a particular named function should be hooked as a potential join point.</p>
<h3>compile_runtime</h3>
<p>The \*(C`compile_runtime\*(C' method generates a custom function that is used to test if a particular named function should be hooked as a potential join point.</p>
<h3>match_contains</h3>
<p>  my $calls = $pointcut-&gt;match_contains(&apos;Aspect::Pointcut::Call&apos;);</p><p>The \*(C`match_contains\*(C' method provides a convenience for the validation and optimisation systems. It is used to check for the existance of a particular condition type anywhere within the pointcut object tree.</p><p>Returns the number of instances of a particular pointcut type within the tree.</p>
<h3>match_always</h3>
<p>  my $always = $pointcut-&gt;match_contains(&apos;Aspect::Pointcut::Throwing&apos;);</p><p>The \*(C`match_always\*(C' method provides a convenience for the validation and optimisation systems. It is used to check that a particular condition type will be tested at least once for a matching join point, regardless of which path the match takes through branching pointcut logic.</p><p>Returns true if an expression type is encounter at least once in all branches, or false if there is any branch path that can be taken in which the condition won't be encountered.</p>
<h3>curry_runtime</h3>
<p>  my $optimized_pointcut = $raw_pointcut-&gt;curry_runtime;</p><p>In a production system, pointcut declarations can result in large and complex <strong>Aspect::Pointcut</strong> object trees.</p><p>Because this tree can contain a large amount of structure that is no longer relevant at run-time, it can end up making a long series of prohibitively expensive cascading method or function calls before every single regular function call.</p><p>To reduce this cost down to something more reasonable, pointcuts are run through a currying process (see &lt;http://en.wikipedia.org/wiki/Currying&gt;).</p><p>A variety of optimisations are used to simplify boolean nesting, to remove tests that are irrelevant once the compile-time hooks have all been set up, and to remove other tests that the currying process can determine will never need to be tested.</p><p>The currying process will generate and return a new pointcut tree that is independent from the original, and that can perform a match test at the structurally minimum computational cost.</p><p>Returns a new optimised <strong>Aspect::Pointcut</strong> object if any further testing needs to be done at run-time for the pointcut. Returns null (\*(C`undef\*(C' in scalar context or \*(C`()\*(C' in list context) if the pointcut can be curried away to nothing, and no further testing needs to be done at run-time.</p>
<h3>curry_weave</h3>
<p>The \*(C`curry_weave\*(C' method is similar to the \*(C`curry_runtime\*(C' method, except that instead of reducing the pointcut to only elements that are relevant at run-time, it reduces the pointcut to only elements that are relevant at weave time.</p><p>By remove purely run-time elements, the compile weave test code is made both faster and more accurate (some complicated situations can occur when there is a Aspect::Pointcut::Not in the tree).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Adam Kennedy &lt;adamk@cpan.org&gt;</p><p>Marcel Gru\*:nauer &lt;marcel@cpan.org&gt;</p><p>Ran Eilam &lt;eilara@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2001 by Marcel Gru\*:nauer</p><p>Some parts copyright 2009 - 2013 Adam Kennedy.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Aspect::Point::Static.3pm.html"><span aria-hidden="true">&larr;</span> Aspect::Point::Static.3pm: The join point context for join point static parts</a></li>
   <li class="next"><a href="Aspect::Pointcut::And.3pm.html">Aspect::Pointcut::And.3pm: Logical 'and' pointcut <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

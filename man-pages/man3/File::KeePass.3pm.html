<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>File::KeePass: Interface to keepass v1 and v2 database files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Interface to keepass v1 and v2 database files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="File::KeePass (3pm) manual">
  <meta name="twitter:description" content="Interface to keepass v1 and v2 database files">
  <meta name="twitter:image" content="https://www.carta.tech/images/libfile-keepass-perl-File::KeePass-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/File::KeePass.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="File::KeePass (3pm) manual" />
  <meta property="og:description" content="Interface to keepass v1 and v2 database files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libfile-keepass-perl-File::KeePass-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">File::KeePass<small> (3pm)</small></h1>
        <p class="lead">Interface to keepass v1 and v2 database files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/File::KeePass.3pm.html">
      <span itemprop="name">File::KeePass: Interface to keepass v1 and v2 database files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libfile-keepass-perl/">
      <span itemprop="name">libfile-keepass-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/File::KeePass.3pm.html">
      <span itemprop="name">File::KeePass: Interface to keepass v1 and v2 database files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use File::KeePass;
    use Data::Dumper qw(Dumper);

    my $k = File::KeePass-&gt;new;

    # read a version 1 or version 2 database
    $k-&gt;load_db($file, $master_pass); # errors die

    print Dumper $k-&gt;header;
    print Dumper $k-&gt;groups; # passwords are locked

    $k-&gt;unlock;
    print Dumper $k-&gt;groups; # passwords are now visible

    $k-&gt;clear; # delete current db from memory


    my $group = $k-&gt;add_group({
        title =&gt; &apos;Foo&apos;,
    }); # root level group
    my $gid = $group-&gt;{&apos;id&apos;};

    my $group = $k-&gt;find_group({id =&gt; $gid});
    # OR
    my $group = $k-&gt;find_group({title =&gt; &apos;Foo&apos;});


    my $group2 = $k-&gt;add_group({
        title =&gt; &apos;Bar&apos;,
        group =&gt; $gid,
        # OR group =&gt; $group,
    }); # nested group


    my $e = $k-&gt;add_entry({
        title    =&gt; &apos;Something&apos;,
        username =&gt; &apos;someuser&apos;,
        password =&gt; &apos;somepass&apos;,
        group    =&gt; $gid,
        # OR group =&gt; $group,
    });
    my $eid = $e-&gt;{&apos;id&apos;};

    my $e = $k-&gt;find_entry({id =&gt; $eid});
    # OR
    my $e = $k-&gt;find_entry({title =&gt; &apos;Something&apos;});

    $k-&gt;lock;
    print $e-&gt;{&apos;password&apos;}; # eq undef
    print $k-&gt;locked_entry_password($e); # eq &apos;somepass&apos;

    $k-&gt;unlock;
    print $e-&gt;{&apos;password&apos;}; # eq &apos;somepass&apos;


    # save out a version 1 database
    $k-&gt;save_db("/some/file/location.kdb", $master_pass);

    # save out a version 2 database
    $k-&gt;save_db("/some/file/location.kdbx", $master_pass);

    # save out a version 1 database using a password and key file
    $k-&gt;save_db("/some/file/location.kdb", [$master_pass, $key_filename]);


    # read database from a file
    $k-&gt;parse_db($pass_db_string, $pass);

    # generate a keepass version 1 database string
    my $pass_db_string = $k-&gt;gen_db($pass);

    # generate a keepass version 2 database string
    my $pass_db_string = $k-&gt;gen_db($pass);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>File::KeePass gives access to KeePass version 1 (kdb) and version 2 (kdbx) databases.</p><p>The version 1 and version 2 databases are very different in construction, but the majority of information overlaps and many algorithms are similar.  File::KeePass attempts to iron out as many of the differences.</p><p>File::KeePass gives nearly raw data access.  There are a few utility methods for manipulating groups and entries.  More advanced manipulation can easily be layered on top by other modules.</p><p>File::KeePass is only used for reading and writing databases and for keeping passwords scrambled while in memory.  Programs dealing with \s-1UI\s0 or using of auto-type features are the domain of other modules on \s-1CPAN\s0.  File::KeePass::Agent is one example.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    new
  </dt>
  <dd>
    <p>Takes a hashref or hash of arguments.  Returns a new File::KeePass object.  Any named arguments are added to self.</p>
  </dd>
  <dt>
    load_db
  </dt>
  <dd>
    <p>Takes a kdb filename, a master password, and an optional argument hashref.  Returns the File::KeePass object on success (can be called as a class method).  Errors die.  The resulting database can be accessed via various methods including $k-&gt;groups.     my $k = File::KeePass-&gt;new;     $k-&gt;load_db($file, $pwd);</p><p>    my $k = File::KeePass-&gt;load_db($file, $pwd);</p><p>    my $k = File::KeePass-&gt;load_db($file, $pwd, {auto_lock =&gt; 0}); The contents are read from file and passed to parse_db. The password passed to load_db may be a composite key in any of the following forms:     "password"                   # password only     ["password"]                 # same     ["password", "keyfilename"]  # password and key file     [undef, "keyfilename"]       # key file only     ["password", &#92;"keycontent"]  # password and reference to key file content     [undef, &#92;"keycontent"]       # reference to key file content only The key file is optional.  It may be passed as a filename, or as a scalar reference to the contents of the key file.  If a filename is passed it will be read in.  The key file can contain any of the following three types:     length 32         # treated as raw key     length 64         # must be 64 hexidecimal characters     any-other-length  # a SHA256 sum will be taken of the data</p>
  </dd>
  <dt>
    save_db
  </dt>
  <dd>
    <p>Takes a kdb filename and a master password.  Stores out the current groups in the object.  Writes attempt to write first to $file.new.$epoch and are then renamed into the correct location. You will need to unlock the db via $k-&gt;unlock before calling this method if the database is currently locked. The same master password types passed to load_db can be used here.</p>
  </dd>
  <dt>
    parse_db
  </dt>
  <dd>
    <p>Takes a string or a reference to a string containting an encrypted kdb database, a master password, and an optional argument hashref. Returns the File::KeePass object on success (can be called as a class method).  Errors die.  The resulting database can be accessed via various methods including $k-&gt;groups.     my $k = File::KeePass-&gt;new;     $k-&gt;parse_db($loaded_kdb, $pwd);</p><p>    my $k = File::KeePass-&gt;parse_db($kdb_buffer, $pwd);</p><p>    my $k = File::KeePass-&gt;parse_db($kdb_buffer, $pwd, {auto_lock =&gt; 0}); The same master password types passed to load_db can be used here.</p>
  </dd>
  <dt>
    parse_header
  </dt>
  <dd>
    <p>Used by parse_db.  Reads just the header information.  Can be used as a basic KeePass file check.  The returned hash will contain version =&gt; 1 or version =&gt; 2 depending upon which type of header is found.  Can be called as a class method.     my $head = File::KeePass-&gt;parse_header($kdb_buffer); # errors die     printf "This is a version %d database&#92;n", $head-&gt;{&apos;version&apos;};</p>
  </dd>
  <dt>
    gen_db
  </dt>
  <dd>
    <p>Takes a master password.  Optionally takes a \*(L"groups\*(R" arrayref and a \*(L"headers\*(R" hashref.  If groups are not passed, it defaults to using the currently loaded groups.  If headers are not passed, a fresh set of headers are generated based on the groups and the master password. The headers can be passed in to test round trip portability. You will need to unlock the db via $k-&gt;unlock before calling this method if the database is currently locked. The same master password types passed to load_db can be used here.</p>
  </dd>
  <dt>
    header
  </dt>
  <dd>
    <p>Returns a hashref representing the combined current header and meta information for the currently loaded database. The following fields are present in both version 1 and version 2 style databases (from the header):     enc_iv               =&gt; "123456789123456", # rand     enc_type             =&gt; "rijndael",     header_size          =&gt; 222,     seed_key             =&gt; "1234567890123456", # rand (32 bytes on v2)     seed_rand            =&gt; "12345678901234567890123456789012", # rand     rounds               =&gt; 6000,     sig1                 =&gt; "2594363651",     sig2                 =&gt; "3041655655", # indicates db version     ver                  =&gt; 196608,     version              =&gt; 1, # or 2 The following keys will be present after the reading of a version 2 database (from the header):     cipher               =&gt; "aes",     compression          =&gt; 1,     protected_stream     =&gt; "salsa20",     protected_stream_key =&gt; "12345678901234567890123456789012", # rand     start_bytes          =&gt; "12345678901234567890123456789012", # rand Additionally, items parsed from the Meta section of a version 2 database will be added.  The following are the available fields.     color                         =&gt; "#4FFF00",     custom_data                   =&gt; {key1 =&gt; "val1"},     database_description          =&gt; "database desc",     database_description_changed  =&gt; "2012-08-17 00:30:56",     database_name                 =&gt; "database name",     database_name_changed         =&gt; "2012-08-17 00:30:56",     default_user_name             =&gt; "",     default_user_name_changed     =&gt; "2012-08-17 00:30:34",     entry_templates_group         =&gt; "VL5nOpzlFUevGhqL71/OTA==",     entry_templates_group_changed =&gt; "2012-08-21 14:05:32",     generator                     =&gt; "KeePass",     history_max_items             =&gt; 10,     history_max_size              =&gt; 6291456, # bytes     last_selected_group           =&gt; "SUgL30QQqUK3tOWuNKUYJA==",     last_top_visible_group        =&gt; "dC1sQ1NO80W7klmRhfEUVw==",     maintenance_history_days      =&gt; 365,     master_key_change_force       =&gt; -1,     master_key_change_rec         =&gt; -1,     master_key_changed            =&gt; "2012-08-17 00:30:34",     protect_notes                 =&gt; 0,     protect_password              =&gt; 1,     protect_title                 =&gt; 0,     protect_url                   =&gt; 0,     protect_username              =&gt; 0     recycle_bin_changed           =&gt; "2012-08-17 00:30:34",     recycle_bin_enabled           =&gt; 1,     recycle_bin_uuid              =&gt; "SUgL30QQqUK3tOWuNKUYJA==" When writing a database via either save_db or gen_db, these fields can be set and passed along.  Optionally, it is possible to pass along a key called reuse_header to let calls to save_db and gen_db automatically use the contents of the previous header.</p>
  </dd>
  <dt>
    clear
  </dt>
  <dd>
    <p>Clears any currently loaded database.</p>
  </dd>
  <dt>
    auto_lock
  </dt>
  <dd>
    <p>Default true.  If true, passwords are automatically hidden when a database loaded via parse_db or load_db.     $k-&gt;<strong>auto_lock</strong>(0); # turn off auto locking</p>
  </dd>
  <dt>
    is_locked
  </dt>
  <dd>
    <p>Returns true if the current database is locked.</p>
  </dd>
  <dt>
    lock
  </dt>
  <dd>
    <p>Locks the database.  This moves all passwords into a protected, in memory, encrypted storage location.  Returns 1 on success.  Returns 2 if the db is already locked.  If a database is loaded via parse_db or load_db and auto_lock is true, the newly loaded database will start out locked.</p>
  </dd>
  <dt>
    unlock
  </dt>
  <dd>
    <p>Unlocks a previously locked database.  You will need to unlock a database before calling save_db or gen_db.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GROUP/ENTRY METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    dump_groups
  </dt>
  <dd>
    <p>Returns a simplified string representation of the currently loaded database.     print $k-&gt;dump_groups; You can optionally pass a match argument hashref.  Only entries matching the criteria will be returned.</p>
  </dd>
  <dt>
    groups
  </dt>
  <dd>
    <p>Returns an arrayref of groups from the currently loaded database. Groups returned will be hierarchal.  Note, groups simply returns a reference to all of the data.  It makes no attempts at cleaning up the data (find_groups will make sure the data is groomed).     my $g = $k-&gt;groups; Groups will look similar to the following:     $g = [{          expanded =&gt; 0,          icon     =&gt; 0,          id       =&gt; 234234234, # under v1 this is a 32 bit int, under v2 it is a 16 char id          title    =&gt; &apos;Foo&apos;,          level    =&gt; 0,          entries =&gt; [{              accessed =&gt; "2010-06-24 15:09:19",              comment  =&gt; "",              created  =&gt; "2010-06-24 15:09:19",              expires  =&gt; "2999-12-31 23:23:59",              icon     =&gt; 0,              modified =&gt; "2010-06-24 15:09:19",              title    =&gt; "Something",              password =&gt; &apos;somepass&apos;, # will be hidden if the database is locked              url      =&gt; "",              username =&gt; "someuser",              id       =&gt; "0a55ac30af68149f", # v1 is any hex char, v2 is any 16 char          }],          groups =&gt; [{              expanded =&gt; 0,              icon     =&gt; 0,              id       =&gt; 994414667,              level    =&gt; 1,              title    =&gt; "Bar"          }],      }];</p>
  </dd>
  <dt>
    add_group
  </dt>
  <dd>
    <p>Adds a new group to the database.  Returns a reference to the new group.  If a database isn't loaded, it begins a new one.  Takes a hashref of arguments for the new entry including title, icon, expanded.  A new random group id will be generated.  An optional group argument can be passed.  If a group is passed the new group will be added under that parent group.     my $group = $k-&gt;add_group({title =&gt; &apos;Foo&apos;});     my $gid = $group-&gt;{&apos;id&apos;};</p><p>    my $group2 = $k-&gt;add_group({title =&gt; &apos;Bar&apos;, group =&gt; $gid}); The group argument's value may also be a reference to a group - such as that returned by find_group.</p>
  </dd>
  <dt>
    finder_tests {
  </dt>
  <dd>
    <p>Used by find_groups and find_entries.  Takes a hashref of arguments and returns a list of test code refs.     {title =&gt; &apos;Foo&apos;} # will check if title equals Foo     {&apos;title !&apos; =&gt; &apos;Foo&apos;} # will check if title does not equal Foo     {&apos;title =~&apos; =&gt; qr{^Foo$}} # will check if title does matches the regex     {&apos;title !~&apos; =&gt; qr{^Foo$}} # will check if title does not match the regex</p>
  </dd>
  <dt>
    find_groups
  </dt>
  <dd>
    <p>Takes a hashref of search criteria and returns all matching groups. Can be passed id, title, icon, and level.  Search arguments will be parsed by finder_tests.     my @groups = $k-&gt;find_groups({title =&gt; &apos;Foo&apos;});</p><p>    my @all_groups_flattened = $k-&gt;find_groups({}); The find_groups method also checks to make sure group ids are unique and that all needed values are defined.</p>
  </dd>
  <dt>
    find_group
  </dt>
  <dd>
    <p>Calls find_groups and returns the first group found.  Dies if multiple results are found.  In scalar context it returns only the group.  In list context it returns the group, and its the arrayref in which it is stored (either the root level group or a sub groups group item).</p>
  </dd>
  <dt>
    delete_group
  </dt>
  <dd>
    <p>Passes arguments to find_group to find the group to delete.  Then deletes the group.  Returns the group that was just deleted.</p>
  </dd>
  <dt>
    add_entry
  </dt>
  <dd>
    <p>Adds a new entry to the database.  Returns a reference to the new entry.  An optional group argument can be passed.  If a group is not passed, the entry will be added to the first group in the database.  A new entry id will be created if one is not passed or if it conflicts with an existing group. The following fields can be passed to both v1 and v2 databases.     accessed =&gt; "2010-06-24 15:09:19", # last accessed date     auto_type =&gt; [{keys =&gt; "{USERNAME}{TAB}{PASSWORD}{ENTER}", window =&gt; "Foo*"}],     binary   =&gt; {foo =&gt; &apos;content&apos;}; # hashref of filename/content pairs     comment  =&gt; "", # a comment for the system - auto-type info is normally here     created  =&gt; "2010-06-24 15:09:19", # entry creation date     expires  =&gt; "2999-12-31 23:23:59", # date entry expires     icon     =&gt; 0, # icon number for use with agents     modified =&gt; "2010-06-24 15:09:19", # last modified     title    =&gt; "Something",     password =&gt; &apos;somepass&apos;, # will be hidden if the database is locked     url      =&gt; "http://",     username =&gt; "someuser",     id       =&gt; "0a55ac30af68149f", # auto generated if needed, v1 is any hex char, v2 is any 16 char     group    =&gt; $gid, # which group to add the entry to For compatibility with earlier versions of File::KeePass, it is possible to pass in a binary and binary_name when creating an entry. They will be automatically converted to the hashref of filename/content pairs     binary_name =&gt; "foo", # description of the stored binary - typically a filename     binary   =&gt; "content", # raw data to be stored in the system - typically a file</p><p>    # results in     binary =&gt; {"foo" =&gt; "content"} Typically, version 1 databases store their Auto-Type information inside of the comment.  They are also limited to having only one key sequence per entry.  File::KeePass 2+ will automatically parse Auto-Type values passed in the entry comment and store them out as the auto_type arrayref.  This arrayref is serialized back into the comment section when saving as a version 1 database.  Version 2 databases have a separate storage mechanism for Auto-Type.     If you passed in:     comment =&gt; "        Auto-Type: {USERNAME}{TAB}{PASSWORD}{ENTER}        Auto-Type-Window: Foo*        Auto-Type-Window: Bar*     ",</p><p>    Will result in:     auto_type =&gt; [{         keys =&gt; "{USERNAME}{TAB}{PASSWORD}{ENTER}",         window =&gt; "Foo*"      }, {         keys =&gt; "{USERNAME}{TAB}{PASSWORD}{ENTER}",         window =&gt; "Bar*"      }], The group argument value may be either an existing group id, or a reference to a group - such as that returned by find_group. When using a version 2 database, the following additional fields are also available:     expires_enabled   =&gt; 0,     location_changed  =&gt; "2012-08-05 12:12:12",     usage_count       =&gt; 0,     tags              =&gt; {},     background_color  =&gt; &apos;#ff0000&apos;,     foreground_color  =&gt; &apos;#ffffff&apos;,     custom_icon_uuid  =&gt; &apos;234242342aa&apos;,     history           =&gt; [], # arrayref of previous entry changes     override_url      =&gt; $node-&gt;{&apos;OverrideURL&apos;},     auto_type_enabled =&gt; 1,     auto_type_munge   =&gt; 0, # whether or not to attempt two channel auto typing     protected         =&gt; {password =&gt; 1}, # indicating which strings were/should be salsa20 protected     strings           =&gt; {&apos;other key&apos; =&gt; &apos;other value&apos;},</p>
  </dd>
  <dt>
    find_entries
  </dt>
  <dd>
    <p>Takes a hashref of search criteria and returns all matching groups. Can be passed an entry id, title, username, comment, url, active, group_id, group_title, or any other entry property.  Search arguments will be parsed by finder_tests.     my @entries = $k-&gt;find_entries({title =&gt; &apos;Something&apos;});</p><p>    my @all_entries_flattened = $k-&gt;find_entries({});</p>
  </dd>
  <dt>
    find_entry
  </dt>
  <dd>
    <p>Calls find_entries and returns the first entry found.  Dies if multiple results are found.  In scalar context it returns only the entry.  In list context it returns the entry, and its group.</p>
  </dd>
  <dt>
    delete_entry
  </dt>
  <dd>
    <p>Passes arguments to find_entry to find the entry to delete.  Then deletes the entry.  Returns the entry that was just deleted.</p>
  </dd>
  <dt>
    locked_entry_password
  </dt>
  <dd>
    <p>Allows access to individual passwords for a database that is locked. Dies if the database is not locked.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UTILITY METHODS</h2>
        <div class="sectioncontent">
<p>The following methods are general purpose methods used during the parsing and generating of kdb databases.</p>
<dl class='dl-vertical'>
  <dt>
    now
  </dt>
  <dd>
    <p>Returns the current localtime datetime stamp.</p>
  </dd>
  <dt>
    default_exp
  </dt>
  <dd>
    <p>Returns the string representing the default expires time of an entry. Will use $self-&gt;{'default_exp'} or fails to the string '2999-12-31 23:23:59'.</p>
  </dd>
  <dt>
    decrypt_rijndael_cbc
  </dt>
  <dd>
    <p>Takes an encrypted string, a key, and an encryption_iv string. Returns a plaintext string.</p>
  </dd>
  <dt>
    encrypt_rijndael_cbc
  </dt>
  <dd>
    <p>Takes a plaintext string, a key, and an encryption_iv string.  Returns an encrypted string.</p>
  </dd>
  <dt>
    decode_base64
  </dt>
  <dd>
    <p>Loads the MIME::Base64 library and decodes the passed string.</p>
  </dd>
  <dt>
    encode_base64
  </dt>
  <dd>
    <p>Loads the MIME::Base64 library and encodes the passed string.</p>
  </dd>
  <dt>
    unchunksum
  </dt>
  <dd>
    <p>Parses and reassembles a buffer, reading in lengths, and checksums of chunks.</p>
  </dd>
  <dt>
    decompress
  </dt>
  <dd>
    <p>Loads the Compress::Raw::Zlib library and inflates the contents.</p>
  </dd>
  <dt>
    compress
  </dt>
  <dd>
    <p>Loads the Compress::Raw::Zlib library and deflates the contents.</p>
  </dd>
  <dt>
    parse_xml
  </dt>
  <dd>
    <p>Loads the XML::Parser library and sets up a basic parser that can call hooks at various events.  Without the hooks, it runs similarly to XML::Simple::parse.     my $data = $self-&gt;parse_xml($buffer, {         top            =&gt; &apos;KeePassFile&apos;,         force_array    =&gt; {Group =&gt; 1, Entry =&gt; 1},         start_handlers =&gt; {Group =&gt; sub { $level++ }},         end_handlers   =&gt; {Group =&gt; sub { $level-- }},     });</p>
  </dd>
  <dt>
    gen_xml
  </dt>
  <dd>
    <p>Generates \s-1XML\s0 from the passed data structure.  The output of parse_xml can be passed as is.  Additionally hints such as _\|_sort_\|_ can be used to order the tags of a node and _\|_attr_\|_ can be used to indicate which items of a node are attributes.</p>
  </dd>
  <dt>
    salsa20
  </dt>
  <dd>
    <p>Takes a hashref containing a salsa20 key string (length 32 or 16), a salsa20 iv string (length 8), number of salsa20 rounds (8, 12, or 20 - default 20), and an optional data string.  The key and iv are used to initialize the salsa20 encryption. If a data string is passed, the string is salsa20 encrypted and returned. If no data string is passed a salsa20 encrypting coderef is returned.     my $encoded = $self-&gt;salsa20({key =&gt; $key, iv =&gt; $iv, data =&gt; $data});     my $uncoded = $self-&gt;salsa20({key =&gt; $key, iv =&gt; $iv, data =&gt; $encoded});     # $data eq $uncoded</p><p>    my $encoder = $self-&gt;salsa20({key =&gt; $key, iv =&gt; $Iv}); # no data     my $encoded = $encoder-&gt;($data);     my $part2   = $encoder-&gt;($more_data); # continues from previous state</p>
  </dd>
  <dt>
    salsa20_stream
  </dt>
  <dd>
    <p>Takes a hashref that will be passed to salsa20.  Uses the resulting encoder to generate a more continuous encoded stream.  The salsa20 method encodes in chunks of 64 bytes.  If a string is not a multiple of 64, then some of the xor bytes are unused.  The salsa20_stream method maintains a buffer of xor bytes to ensure that none are wasted.     my $encoder = $self-&gt;salsa20_stream({key =&gt; $key, iv =&gt; $Iv}); # no data     my $encoded = $encoder-&gt;("1234");   # calls salsa20-&gt;()     my $part2   = $encoder-&gt;("1234");   # uses the same pad until 64 bytes are used</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    _parse_v1_header
  </dt>
  <dd>
    
  </dd>
  <dt>
    _parse_v1_body
  </dt>
  <dd>
    
  </dd>
  <dt>
    _parse_v1_groups
  </dt>
  <dd>
    
  </dd>
  <dt>
    _parse_v1_entries
  </dt>
  <dd>
    
  </dd>
  <dt>
    _parse_v1_date
  </dt>
  <dd>
    <p>Utilities used for parsing version 1 type databases.</p>
  </dd>
  <dt>
    _parse_v2_header
  </dt>
  <dd>
    
  </dd>
  <dt>
    _parse_v2_body
  </dt>
  <dd>
    
  </dd>
  <dt>
    _parse_v2_date
  </dt>
  <dd>
    <p>Utilities used for parsing version 2 type databases.</p>
  </dd>
  <dt>
    _gen_v1_db
  </dt>
  <dd>
    
  </dd>
  <dt>
    _gen_v1_header
  </dt>
  <dd>
    
  </dd>
  <dt>
    _gen_v1_date
  </dt>
  <dd>
    <p>Utilities used to generate version 1 type databases.</p>
  </dd>
  <dt>
    _gen_v2_db
  </dt>
  <dd>
    
  </dd>
  <dt>
    _gen_v2_header
  </dt>
  <dd>
    
  </dd>
  <dt>
    _gen_v2_date
  </dt>
  <dd>
    <p>Utilities used to generate version 2 type databases.</p>
  </dd>
  <dt>
    _master_key
  </dt>
  <dd>
    <p>Takes the password and parsed headers.  Returns the master key based on database type.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ONE LINERS</h2>
        <div class="sectioncontent">
<p>(Long one liners)</p><p>Here is a version 1 to version 2, or version 2 to version 1 converter. Simply change the extension of the two files.  Someday we will include a kdb2kdbx utility to do this for you.</p><p>    perl -MFile::KeePass -e &apos;use IO::Prompt; $p="".prompt("Pass:",-e=&gt;"*",-tty); File::KeePass-&gt;load_db(+shift,$p,{auto_lock=&gt;0})-&gt;save_db(+shift,$p)&apos; ~/test.kdb ~/test.kdbx</p><p>    # OR using graphical prompt     perl -MFile::KeePass -e &apos;chop($p=&#96;zenity --password&#96;); File::KeePass-&gt;load_db(+shift,$p,{auto_lock=&gt;0})-&gt;save_db(+shift,$p)&apos; ~/test.kdbx ~/test.kdb</p><p>    # OR using pure perl (but echoes password)     perl -MFile::KeePass -e &apos;print "Pass:"; chop($p=&lt;STDIN&gt;); File::KeePass-&gt;load_db(+shift,$p,{auto_lock=&gt;0})-&gt;save_db(+shift,$p)&apos; ~/test.kdbx ~/test.kdb</p><p>Dumping the \s-1XML\s0 from a version 2 database.</p><p>    perl -MFile::KeePass -e &apos;chop($p=&#96;zenity --password&#96;); print File::KeePass-&gt;load_db(+shift,$p,{keep_xml=&gt;1})-&gt;{xml_in},"&#92;n"&apos; ~/test.kdbx</p><p>Outlining group information.</p><p>    perl -MFile::KeePass -e &apos;chop($p=&#96;zenity --password&#96;); print File::KeePass-&gt;load_db(+shift,$p)-&gt;dump_groups&apos; ~/test.kdbx</p><p>Dumping header information</p><p>    perl -MFile::KeePass -MData::Dumper -e &apos;chop($p=&#96;zenity --password&#96;); print Dumper +File::KeePass-&gt;load_db(+shift,$p)-&gt;header&apos; ~/test.kdbx</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Only Rijndael is supported when using v1 databases.</p><p>This module makes no attempt to act as a password agent.  That is the job of File::KeePass::Agent.  This isn't really a bug but some people will think it is.</p><p>Groups and entries don't have true objects associated with them.  At the moment this is by design.  The data is kept as plain boring data.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCES</h2>
        <div class="sectioncontent">
<p>Knowledge about the algorithms necessary to decode a KeePass \s-1DB\s0 v1 format was gleaned from the source code of keepassx-0.4.3.  That source code is published under the \s-1GPL2\s0 license.  KeePassX 0.4.3 bears the copyright of</p><p>    Copyright (C) 2005-2008 Tarek Saidi &lt;tarek.saidi@arcor.de&gt;     Copyright (C) 2007-2009 Felix Geyer &lt;debfx-keepassx {at} fobos.de&gt;</p><p>Knowledge about the algorithms necessary to decode a KeePass \s-1DB\s0 v2 format was gleaned from the source code of keepassx-2.0-alpha1.  That source code is published under the \s-1GPL2\s0 or \s-1GPL3\s0 license.  KeePassX 2.0-alpha1 bears the copyright of</p><p>    Copyright: 2010-2012, Felix Geyer &lt;debfx@fobos.de&gt;                2011-2012, Florian Geyer &lt;blueice@fobos.de&gt;</p><p>The salsa20 algorithm is based on http://cr.yp.to/snuffle/salsa20/regs/salsa20.c which is listed as Public domain (D. J. Bernstein).</p><p>The ordering and layering of encryption/decryption algorithms of File::KeePass are of derivative nature from KeePassX and could not have been created without this insight - though the perl code is from scratch.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Paul Seamons &lt;paul@seamons.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This module may be distributed under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="File::Inplace.3pm.html"><span aria-hidden="true">&larr;</span> File::Inplace.3pm: Perl module for in-place editing of files</a></li>
   <li class="next"><a href="File::Listing.3pm.html">File::Listing.3pm: Parse directory listing <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

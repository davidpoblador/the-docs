<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTML::HTML5::Parser: Parse html reliably</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parse html reliably">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="HTML::HTML5::Parser (3pm) manual">
  <meta name="twitter:description" content="Parse html reliably">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhtml-html5-parser-perl-HTML::HTML5::Parser-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/HTML::HTML5::Parser.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HTML::HTML5::Parser (3pm) manual" />
  <meta property="og:description" content="Parse html reliably" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhtml-html5-parser-perl-HTML::HTML5::Parser-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">HTML::HTML5::Parser<small> (3pm)</small></h1>
        <p class="lead">Parse html reliably</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::HTML5::Parser.3pm.html">
      <span itemprop="name">HTML::HTML5::Parser: Parse html reliably</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhtml-html5-parser-perl/">
      <span itemprop="name">libhtml-html5-parser-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::HTML5::Parser.3pm.html">
      <span itemprop="name">HTML::HTML5::Parser: Parse html reliably</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use HTML::HTML5::Parser;

  my $parser = HTML::HTML5::Parser-&gt;new;
  my $doc    = $parser-&gt;parse_string(&lt;&lt;&apos;EOT&apos;);
  &lt;!doctype html&gt;
  &lt;title&gt;Foo&lt;/title&gt;
  &lt;p&gt;&lt;b&gt;&lt;i&gt;Foo&lt;/b&gt; bar&lt;/i&gt;.
  &lt;p&gt;Baz&lt;/br&gt;Quux.
  EOT

  my $fdoc   = $parser-&gt;parse_file( $html_file_name );
  my $fhdoc  = $parser-&gt;parse_fh( $html_file_handle );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This library is substantially the same as the non-CPAN module Whatpm::HTML. Changes include:</p><ul>
<li><p>Provides an XML::LibXML-like \s-1DOM\s0 interface. If you usually use XML::LibXML's \s-1DOM\s0 parser, this should be a drop-in solution for tag soup \s-1HTML\s0.</p></li><li><p>Constructs an XML::LibXML::Document as the result of parsing.</p></li><li><p>Via bundling and modifications, removed external dependencies on non-CPAN packages.</p></li>
</ul><h3>Constructor</h3>
<p>  $parser = HTML::HTML5::Parser-&gt;new;   # or   $parser = HTML::HTML5::Parser-&gt;new(no_cache =&gt; 1); The constructor does nothing interesting besides take one flag argument, \*(C`no_cache =&gt; 1\*(C', to disable the global element metadata cache. Disabling the cache is handy for conserving memory if you parse a large number of documents, however, class methods such as \*(C`/source_line\*(C' will not work, and must be run from an instance of this parser.</p>
<h3>XML::LibXML-Compatible Methods</h3>
<p>  $doc = $parser-&gt;parse_file( $html_file_name [,&#92;%opts] ); This function parses an \s-1HTML\s0 document from a file or network; $html_file_name can be either a filename or an \s-1URL\s0. Options include 'encoding' to indicate file encoding (e.g. 'utf-8') and 'user_agent' which should be a blessed \*(C`LWP::UserAgent\*(C' (or HTTP::Tiny) object to be used when retrieving URLs. If requesting a \s-1URL\s0 and the response Content-Type header indicates an XML-based media type (such as \s-1XHTML\s0), XML::LibXML::Parser will be used automatically (instead of the tag soup parser). The \s-1XML\s0 parser can be told to use a \s-1DTD\s0 catalogue by setting the option 'xml_catalogue' to the filename of the catalogue. \s-1HTML\s0 (tag soup) parsing can be forced using the option 'force_html', even when an \s-1XML\s0 media type is returned. If an options hashref was passed, parse_file will set $options-&gt;{'parser_used'} to the name of the class used to parse the \s-1URL\s0, to allow the calling code to double-check which parser was used afterwards. If an options hashref was passed, parse_file will set $options-&gt;{'response'} to the HTTP::Response object obtained by retrieving the \s-1URI\s0.   $doc = $parser-&gt;parse_fh( $io_fh [,&#92;%opts] ); \*(C`parse_fh()\*(C' parses a \s-1IOREF\s0 or a subclass of \*(C`IO::Handle\*(C'. Options include 'encoding' to indicate file encoding (e.g. 'utf-8').   $doc = $parser-&gt;parse_string( $html_string [,&#92;%opts] ); This function is similar to \*(C`parse_fh()\*(C', but it parses an \s-1HTML\s0 document that is available as a single string in memory. Options include 'encoding' to indicate file encoding (e.g. 'utf-8'). Wrappers for the parse_* functions. These should be roughly compatible with the equivalently named functions in XML::LibXML. Note that \*(C`load_xml\*(C' first attempts to parse as real \s-1XML\s0, falling back to \s-1HTML5\s0 parsing; \*(C`load_html\*(C' just goes straight for \s-1HTML5\s0.   $fragment = $parser-&gt;parse_balanced_chunk( $string [,&#92;%opts] ); This method is roughly equivalent to XML::LibXML's method of the same name, but unlike XML::LibXML, and despite its name it does not require the chunk to be \*(L"balanced\*(R". This method is somewhat black magic, but should work, and do the proper thing in most cases. Of course, the proper thing might not be what you'd expect! I'll try to keep this explanation as brief as possible... Consider the following string:   &lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt; What is the proper way to parse that? If it were found in a document like this:   &lt;html&gt;     &lt;head&gt;&lt;title&gt;X&lt;/title&gt;&lt;/head&gt;     &lt;body&gt;       &lt;div&gt;         &lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;       &lt;/div&gt;     &lt;/body&gt;   &lt;/html&gt; Then the document would end up equivalent to the following \s-1XHTML:\s0   &lt;html&gt;     &lt;head&gt;&lt;title&gt;X&lt;/title&gt;&lt;/head&gt;     &lt;body&gt;       &lt;div&gt;         &lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;World&lt;/i&gt;       &lt;/div&gt;     &lt;/body&gt;   &lt;/html&gt; The superfluous \*(C`&lt;/td&gt;&lt;/tr&gt;\*(C' is simply ignored. However, if it were found in a document like this:   &lt;html&gt;     &lt;head&gt;&lt;title&gt;X&lt;/title&gt;&lt;/head&gt;     &lt;body&gt;       &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;         &lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;       &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;     &lt;/body&gt;   &lt;/html&gt; Then the result would be:   &lt;html&gt;     &lt;head&gt;&lt;title&gt;X&lt;/title&gt;&lt;/head&gt;     &lt;body&gt;       &lt;i&gt;World&lt;/i&gt;       &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;         &lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;       &lt;/tbody&gt;&lt;/table&gt;     &lt;/body&gt;   &lt;/html&gt; Yes, \*(C`&lt;i&gt;World&lt;/i&gt;\*(C' gets hoisted up before the \*(C`&lt;table&gt;\*(C'. This is weird, I know, but it's how browsers do it in real life. So what should:   $string   = q{&lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;};   $fragment = $parser-&gt;parse_balanced_chunk($string); actually return? Well, you can choose...   $string = q{&lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;};</p><p>  $frag1  = $parser-&gt;parse_balanced_chunk($string, {within=&gt;&apos;div&apos;});   say $frag1-&gt;toString; # &lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;World&lt;/i&gt;</p><p>  $frag2  = $parser-&gt;parse_balanced_chunk($string, {within=&gt;&apos;td&apos;});   say $frag2-&gt;toString; # &lt;i&gt;World&lt;/i&gt;&lt;b&gt;Hello&lt;/b&gt; If you don't pass a \*(L"within\*(R" option, then the chunk is parsed as if it were within a \*(C`&lt;div&gt;\*(C' element. This is often the most sensible option. If you pass something like \*(C`{ within =&gt; "foobar" }\*(C' where \*(L"foobar\*(R" is not a real \s-1HTML\s0 element name (as found in the \s-1HTML5\s0 spec), then this method will croak; if you pass the name of a void element (e.g. "br" or "meta") then this method will croak; there are a handful of other unsupported elements which will croak (namely: "noscript", "noembed", "noframes"). Note that the second time around, although we parsed the string "as if it were within a \*(C`&lt;td&gt;\*(C' element", the \*(C`&lt;i&gt;Hello&lt;/i&gt;\*(C' bit did not strictly end up within the \*(C`&lt;td&gt;\*(C' element (not even within the \*(C`&lt;table&gt;\*(C' element!) yet it still gets returned. We'll call things such as this \*(L"outliers\*(R". There is a \*(L"force_within\*(R" option which tells parse_balanced_chunk to ignore outliers:   $frag3  = $parser-&gt;parse_balanced_chunk($string,                                           {force_within=&gt;&apos;td&apos;});   say $frag3-&gt;toString; # &lt;b&gt;Hello&lt;/b&gt; There is a boolean option \*(L"mark_outliers\*(R" which marks each outlier with an attribute (\*(C`data-perl-html-html5-parser-outlier\*(C') to indicate its outlier status. Clearly, this is ignored when you use \*(L"force_within\*(R" because no outliers are returned. Some outliers may be XML::LibXML::Text elements; text nodes don't have attributes, so these will not be marked with an attribute. A last note is to mention what gets returned by this method. Normally it's an XML::LibXML::DocumentFragment object, but if you call the method in list context, a list of the individual node elements is returned. Alternatively you can request the data to be returned as an XML::LibXML::NodeList object:  # Get an XML::LibXML::NodeList  my $list = $parser-&gt;parse_balanced_chunk($str, {as=&gt;&apos;list&apos;}); The exact implementation of this method may change from version to version, but the long-term goal will be to approach how common desktop browsers parse \s-1HTML\s0 fragments when implementing the setter for \s-1DOM\s0's \*(C`innerHTML\*(C' attribute.</p><p>The push parser and SAX-based parser are not supported. Trying to change an option (such as recover_silently) will make HTML::HTML5::Parser carp a warning. (But you can inspect the options.)</p>
<h3>Error Handling</h3>
<p>Error handling is obviously different to XML::LibXML, as errors are (bugs notwithstanding) non-fatal. Get/set an error handling function. Must be set to a coderef or undef. The error handling function will be called with a single parameter, a HTML::HTML5::Parser::Error object. Returns a list of errors that occurred during the last parse. See HTML::HTML5::Parser::Error.</p>
<h3>Additional Methods</h3>
<p>The module provides a few methods to obtain additional, non-DOM data from \s-1DOM\s0 nodes.   $pubid = $parser-&gt;dtd_public_id( $doc ); For an XML::LibXML::Document which has been returned by HTML::HTML5::Parser, using this method will tell you the Public Identifier of the \s-1DTD\s0 used (if any).   $sysid = $parser-&gt;dtd_system_id( $doc ); For an XML::LibXML::Document which has been returned by HTML::HTML5::Parser, using this method will tell you the System Identifier of the \s-1DTD\s0 used (if any).   $element = $parser-&gt;dtd_element( $doc ); For an XML::LibXML::Document which has been returned by HTML::HTML5::Parser, using this method will tell you the root element declared in the \s-1DTD\s0 used (if any). That is, if the document has this doctype:   &lt;!doctype html&gt; ... it will return \*(L"html\*(R". This may return the empty string if a \s-1DTD\s0 was present but did not contain a root element; or undef if no \s-1DTD\s0 was present.   $mode = $parser-&gt;compat_mode( $doc ); Returns 'quirks', 'limited quirks' or undef (standards mode).   $charset = $parser-&gt;charset( $doc ); The character set apparently used by the document.   ($line, $col) = $parser-&gt;source_line( $node );   $line = $parser-&gt;source_line( $node ); In scalar context, \*(C`source_line\*(C' returns the line number of the source code that started a particular node (element, attribute or comment). In list context, returns a tuple: $line, $column, $implicitness. Tab characters count as one column, not eight. $implicitness indicates that the node was not explicitly marked up in the source code, but its existence was inferred by the parser. For example, in the following markup, the \s-1HTML\s0, \s-1TITLE\s0 and P elements are explicit, but the \s-1HEAD\s0 and \s-1BODY\s0 elements are implicit.  &lt;html&gt;   &lt;title&gt;I have an implicit head&lt;/title&gt;   &lt;p&gt;And an implicit body too!&lt;/p&gt;  &lt;/html&gt; (Note that implicit elements do still have a line number and column number.) The implictness indicator is a new feature, and I'd appreciate any bug reports where it gets things wrong. XML::LibXML::Node has a \*(C`line_number\*(C' method. In general this will always return 0 and HTML::HTML5::Parser has no way of influencing it. However, if you install XML::LibXML::Devel::SetLineNumber on your system, the \*(C`line_number\*(C' method will start working (at least for elements).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO HTML::HTML5::Parser&hellip;</h2>
        <div class="sectioncontent">
<p>&lt;http://suika.fam.cx/www/markup/html/whatpm/Whatpm/HTML.html&gt;.</p><p>HTML::HTML5::Writer, HTML::HTML5::Builder, XML::LibXML, XML::LibXML::PrettyPrint, XML::LibXML::Devel::SetLineNumber.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Toby Inkster, &lt;tobyink@cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENCE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2007-2011 by Wakaba</p><p>Copyright (C) 2009-2012 by Toby Inkster</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISCLAIMER OF WARRANTIES</h2>
        <div class="sectioncontent">
<p>\s-1THIS\s0 \s-1PACKAGE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1AND\s0 \s-1WITHOUT\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0, \s-1INCLUDING\s0, \s-1WITHOUT\s0 \s-1LIMITATION\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTIBILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="HTML::FromText.3pm.html"><span aria-hidden="true">&larr;</span> HTML::FromText.3pm: Converts plain text to html</a></li>
   <li class="next"><a href="HTML::HTML5::Parser::Error.3pm.html">HTML::HTML5::Parser::Error.3pm: An error that occurred during parsing <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

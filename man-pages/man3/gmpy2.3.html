<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gmpy2: Gmpy2 documentation  contents:</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Gmpy2 documentation  contents:">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gmpy2 (3) manual">
  <meta name="twitter:description" content="Gmpy2 documentation  contents:">
  <meta name="twitter:image" content="https://www.carta.tech/images/python-gmpy2-common-gmpy2-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/gmpy2.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gmpy2 (3) manual" />
  <meta property="og:description" content="Gmpy2 documentation  contents:" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/python-gmpy2-common-gmpy2-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gmpy2<small> (3)</small></h1>
        <p class="lead">Gmpy2 documentation  contents:</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/gmpy2.3.html">
      <span itemprop="name">gmpy2: Gmpy2 documentation  contents:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/python-gmpy2-common/">
      <span itemprop="name">python-gmpy2-common</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/gmpy2.3.html">
      <span itemprop="name">gmpy2: Gmpy2 documentation  contents:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION TO GMPY2</h2>
        <div class="sectioncontent">
<p>gmpy2 is a C-coded Python extension module that supports multiple-precision arithmetic. gmpy2 is the successor to the original gmpy module. The gmpy module only supported the GMP multiple-precision library. gmpy2 adds support for the MPFR (correctly rounded real floating-point arithmetic) and MPC (correctly rounded complex floating-point arithmetic) libraries. gmpy2 also updates the API and naming conventions to be more consistent and support the additional functionality.</p><p>The following libraries are supported:</p><ul>
<li><p>GMP for integer and rational arithmetic</p><p>Home page: <em>http://gmplib.org</em></p></li><li><p>MPIR is based on the GMP library but adds support for Microsoft&apos;s Visual Studio compiler. It is used to create the Windows binaries.</p><p>Home page: <em>http://www.mpir.org</em></p></li><li><p>MPFR for correctly rounded real floating-point arithmetic</p><p>Home page: <em>http://www.mpfr.org</em></p></li><li><p>MPC for correctly rounded complex floating-point arithmetic</p><p>Home page: <em>http://mpc.multiprecision.org</em></p></li><li><p>Generalized Lucas sequences and primality tests are based on the following code:</p><p>mpz_lucas: <em>http://sourceforge.net/projects/mpzlucas/</em></p><p>mpz_prp: <em>http://sourceforge.net/projects/mpzprp/</em></p></li>
</ul><h3>Changes in gmpy2 2.0.2</h3>
<ul>
<li><p>Rebuild the Windows binary installers due to a bug in MPIR.</p></li><li><p>Correct test in is_extra_strong_lucas_prp(). Note: The incorrect test is not known to cause any errors.</p></li>
</ul>
<h3>Changes in gmpy2 2.0.1</h3>
<ul>
<li><p>Updated setup.py to work in more situations.</p></li><li><p>Corrected exception handling in basic operations with mpfr type.</p></li><li><p>Correct InvalidOperation exception not raised in certain circumstances.</p></li><li><p>invert() now raises an exception if the modular inverse does not exist.</p></li><li><p>Fixed internal exception in is_bpsw_prp() and is_strong_bpsw_prp().</p></li><li><p>Updated is_extra_strong_lucas_prp() to latest version.</p></li>
</ul>
<h3>Changes in gmpy2 2.0.0</h3>
<ul>
<li><p>Fix segmentation fault in _mpmath_normalize (an undocumented helper function specifically for mpmath.)</p></li><li><p>Improved setup.py See below for documentation on the changes.</p></li><li><p>Fix issues when compiled without support for MPFR.</p></li><li><p>Conversion of too large an mpz to float now raises OverflowError instead of returning <em>inf</em>.</p></li><li><p>Renamed min2()/max2() to minnum()/maxnum()</p></li><li><p>The build and install process (i.e. setup.py) has been completely rewritten. See the Installation section for more information.</p></li><li><p>get_context() no longer accepts keyword arguments.</p></li>
</ul>
<h3>Known issues in gmpy2 2.0.0</h3>
<ul>
<li><p>The test suite is still incomplete.</p></li>
</ul>
<h3>Changes in gmpy2 2.0.0b4</h3>
<ul>
<li><p>Added __ceil__, __floor__, __trunc__, and __round__ methods to mpz and mpq types.</p></li><li><p>Added __complex__ to mpc type.</p></li><li><p>round(mpfr) now correctly returns an mpz type.</p></li><li><p>If no arguments are given to mpz, mpq, mpfr, mpc, and xmpz, return 0 of the appropriate type.</p></li><li><p>Fix broken comparison between mpz and mpq when mpz is on the left.</p></li><li><p>Added __sizeof__ to all types. <em>Note: sys.getsizeof() calls __sizeof__ to get</em> the memory size of a gmpy2 object. The returned value reflects the size of the allocated memory which may be larger than the actual minimum memory required by the object.</p></li>
</ul>
<h3>Known issues in gmpy2 2.0.0b4</h3>
<ul>
<li><p>The new test suite (test/runtest.py) is incomplete and some tests fail on Python 2.x due to formating issues.</p></li>
</ul>
<h3>Changes in gmpy2 2.0.0b3</h3>
<ul>
<li><p>mp_version(), mpc_version(), and mpfr_version() now return normal strings on Python 2.x instead of Unicode strings.</p></li><li><p>Faster conversion of the standard library Fraction type to mpq.</p></li><li><p>Improved conversion of the Decimal type to mpfr.</p></li><li><p>Consistently return OverflowError when converting "inf".</p></li><li><p>Fix mpz.__format__() when the format code includes "#".</p></li><li><p>Add is_infinite() and deprecate is_inf().</p></li><li><p>Add is_finite() and deprecate is_number().</p></li><li><p>Fixed the various is_XXX() tests when used with mpc.</p></li><li><p>Added caching for mpc objects.</p></li><li><p>Faster code path for basic operation is both operands are mpfr or mpc.</p></li><li><p>Fix mpfr + float segmentation fault.</p></li>
</ul>
<h3>Changes in gmpy2 2.0.0b2</h3>
<ul>
<li><p>Allow xmpz slice assignment to increase length of xmpz instance by specifying a value for stop.</p></li><li><p>Fixed reference counting bug in several is_xxx_prp() tests.</p></li><li><p>Added iter_bits(), iter_clear(), iter_set() methods to xmpz.</p></li><li><p>Added powmod() for easy access to three argument pow().</p></li><li><p>Removed addmul() and submul() which were added in 2.0.0b1 since they are slower than just using Python code.</p></li><li><p>Bug fix in gcd_ext when both arguments are not mpz.</p></li><li><p>Added ieee() to create contexts for 32, 64, or 128 bit floats.</p></li><li><p>Bug fix in context() not setting emax/emin correctly if they had been changed earlier.</p></li><li><p>Contexts can be directly used in with statement without requiring set_context()/local_context() sequence.</p></li><li><p>local_context() now accepts an optional context.</p></li>
</ul>
<h3>Changes in gmpy2 2.0.0b1 and earlier</h3>
<ul>
<li><p>Renamed functions that manipulate individual bits to bit_XXX() to align with bit_length().</p></li><li><p>Added caching for mpq.</p></li><li><p>Added rootrem(), fib2(), lucas(), lucas2().</p></li><li><p>Support changed hash function in Python 3.2.</p></li><li><p>Added is_even(), is_odd().</p></li><li><p>Add caching of the calculated hash value.</p></li><li><p>Add xmpz (mutable mpz) type.</p></li><li><p>Fix mpq formatting issue.</p></li><li><p>Add read/write bit access using slices to xmpz.</p></li><li><p>Add read-only bit access using slices to mpz.</p></li><li><p>Add pack()/unpack() methods to split/join an integer into n-bit chunks.</p></li><li><p>Add support for MPFR (casevh)</p></li><li><p>Removed fcoform float conversion modifier.</p></li><li><p>Add support for MPC.</p></li><li><p>Added context manager.</p></li><li><p>Allow building with just GMP/MPIR if MPFR not available.</p></li><li><p>Allow building with GMP/MPIR and MPFR if MPC not available.</p></li><li><p>Removed most instance methods in favor of gmpy2.function. The general guideline is that <em>properties</em> of an instance can be done via instance methods but <em>functions</em> that return a new result are done using gmpy2.function.</p></li><li><p>Added __ceil__, __floor__, and __trunc__ methods since they are called by math.ceil(), math.floor(), and math.trunc().</p></li><li><p>Removed gmpy2.pow() to avoid conflicts.</p></li><li><p>Removed gmpy2._copy and added xmpz.copy.</p></li><li><p>Added support for __format__.</p></li><li><p>Added as_integer_ratio, as_mantissa_exp, as_simple_fraction.</p></li><li><p>Updated rich_compare.</p></li><li><p>Require MPFR 3.1.0+ to get divby0 support.</p></li><li><p>Added fsum(), degrees(), radians().</p></li><li><p>Updated random number generation support.</p></li><li><p>Changed license to LGPL 3+.</p></li><li><p>Added lucasu, lucasu_mod, lucasv, and lucasv_mod. <em>Based on code contributed by David Cleaver.</em></p></li><li><p>Added probable-prime tests. <em>Based on code contributed by David Cleaver.</em></p></li><li><p>Added to_binary()/from_binary.</p></li><li><p>Renamed numdigits() to num_digits().</p></li><li><p>Added keyword precision to constants.</p></li><li><p>Added addmul() and submul().</p></li><li><p>Added __round__(), round2(), round_away() for mpfr.</p></li><li><p>round() is no longer a module level function.</p></li><li><p>Renamed module functions min()/max() to min2()/max2().</p></li><li><p>No longer conflicts with builtin min() and max()</p></li><li><p>Removed set_debug() and related functionality.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTALLATION</h2>
        <div class="sectioncontent">
<h3>Installing gmpy2 on Windows</h3>
<p>Pre-compiled versions of gmpy2 are available at <em>Downloads</em> . Please select the installer that corresponds to the version of Python installed on your computer. Note that either a 32 or 64-bit version of Python can be installed on a 64-bit version of Windows. If you get an error message stating that Python could not be found in the registry, you have the wrong version of the gmpy2 installer.</p>
<h3>Installing gmpy2 on Unix/Linux</h3>

<h3>Requirements</h3>
<p>gmpy2 has only been tested with the most recent versions of GMP, MPFR and MPC. Specifically, for integer and rational support, gmpy2 requires GMP 5.0.x or later. To support multiple-precision floating point arithmetic, MPFR 3.1.x or later is required. MPC 1.0.1 or later is required for complex arithmetic.</p>
<h3>Short Instructions</h3>
<p>If your system includes sufficiently recent versions of GMP, MPFR and MPC, and you have the development libraries installed, compiling should be as simple as:</p>
<pre>
cd &lt;gmpy2 source directory&gt;
python setup.py install
</pre>
<p>If this fails, read on.</p>
<h3>Detailed Instructions</h3>
<p>If your Linux distribution does not support recent versions of GMP, MPFR and MPC, you will need to compile your own versions. To avoid any possible conflict with existing libraries on your system, it is recommended to use a directory not normally used by your distribution. setup.py will automatically search the following directories for the required libraries:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>/opt/local</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>/opt</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>/usr/local</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>/usr</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>/sw</p><p>If you can&apos;t use one of these directories, you can use a directory located in your home directory. The examples will use /home/case/local. If you use one of standard directories (say /opt/local), then you won&apos;t need to specify --prefix=/home/case/local to setup.py but you will need to specify the prefix when compiling GMP, MPFR, and MPC.</p><p>Create the desired destination directory for GMP, MPFR, and MPC.</p>
<pre>
$ mkdir /home/case/local
</pre>
<p>Download and un-tar the GMP source code. Change to the GMP source directory and compile GMP.</p>
<pre>
$ cd /home/case/local/src/gmp-5.1.0
$ ./configure --prefix=/home/case/local
$ make
$ make check
$ make install
</pre>
<p>Download and un-tar the MPFR source code. Change to the MPFR source directory and compile MPFR.</p>
<pre>
$ cd /home/case/local/src/mpfr-3.1.1
$ ./configure --prefix=/home/case/local --with-gmp=/home/case/local
$ make
$ make check
$ make install
</pre>
<p>Download and un-tar the MPC source code. Change to the MPC source directory and compile MPC.</p>
<pre>
$ cd /home/case/local/src/mpc-1.0.1
$ ./configure --prefix=/home/case/local --with-gmp=/home/case/local --with-mpfr=/home/case/local
$ make
$ make check
$ make install
</pre>
<p>Compile gmpy2 and specify the location of GMP, MPFR and MPC. The location of the GMP, MPFR, and MPC libraries is embedded into the gmpy2 library so the new versions of GMP, MPFR, and MPC do not need to be installed the system library directories. The prefix directory is added to the beginning of the directories that are checked so it will be found first.</p>
<pre>
$ python setup.py install --prefix=/home/case/local
</pre>
<p>If you get a "permission denied" error message, you may need to use:</p>
<pre>
$ python setup.py build --prefix=/home/case/local
$ sudo python setup.py install --prefix=/home/case/local
</pre>

  </dd>

</dl>

<h3>Options for setup.py</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>--force</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Ignore the timestamps on all files and recompile. Normally, the results of a previous compile are cached. To force gmpy2 to recognize external changes (updated version of GMP, etc.), you will need to use this option.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>--mpir</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Force the use of MPIR instead of GMP. GMP is the default library on non-Windows operating systems.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>--gmp</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Force the use of GMP instead of MPIR. MPIR is the default library on Windows operating systems.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>--prefix=&lt;...&gt;</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Specify the directory prefix where GMP/MPIR, MPFR, and MPC are located. For example, <strong>--prefix=/opt/local</strong> instructs setup.py to search /opt/local/include for header files and /opt/local/lib for libraries.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>--nompfr</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Disables support for MPFR and MPC. This option is intended for testing purposes and is not offically supported.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>--nompc</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Disables support MPC. This option is intended for testing purposes and is not officially supported.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW OF GMPY2</h2>
        <div class="sectioncontent">
<h3>Tutorial</h3>
<p>The <em>mpz</em> type is compatible with Python&apos;s built-in int/long type but is significanly faster for large values. The cutover point for performance varies, but can be as low as 20 to 40 digits. A variety of additional integer functions are provided.</p>
<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import mpz,mpq,mpfr,mpc
&gt;&gt;&gt; mpz(99) * 43
mpz(4257)
&gt;&gt;&gt; pow(mpz(99), 37, 59)
mpz(18)
&gt;&gt;&gt; gmpy2.isqrt(99)
<strong>mpz</strong>(9)
&gt;&gt;&gt; gmpy2.isqrt_rem(99)
(<strong>mpz</strong>(9), mpz(18))
&gt;&gt;&gt; gmpy2.gcd(123,27)
<strong>mpz</strong>(3)
&gt;&gt;&gt; gmpy2.lcm(123,27)
mpz(1107)
</pre>
<p>The <em>mpq</em> type is compatible with the <em>fractions.Fraction</em> type included with Python.</p>
<pre>
&gt;&gt;&gt; mpq(3,7)/7
mpq(3,49)
&gt;&gt;&gt; mpq(45,3) * mpq(11,8)
mpq(165,8)
</pre>
<p>The most significant new features in gmpy2 are support for correctly rounded arbitrary precision real and complex arithmetic based on the MPFR and MPC libraries. Floating point contexts are used to control exceptional conditions. For example, division by zero can either return an Infinity or raise an exception.</p>
<pre>
&gt;&gt;&gt; <strong>mpfr</strong>(1)/7
mpfr(&apos;0.14285714285714285&apos;)
&gt;&gt;&gt; gmpy2.get_context().precision=200
&gt;&gt;&gt; <strong>mpfr</strong>(1)/7
mpfr(&apos;0.1428571428571428571428571428571428571428571428571428571428571&apos;,200)
&gt;&gt;&gt; gmpy2.get_context()
context(precision=200, real_prec=Default, imag_prec=Default,
        round=RoundToNearest, real_round=Default, imag_round=Default,
        emax=1073741823, emin=-1073741823,
        subnormalize=False,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=True,
        trap_invalid=False, invalid=False,
        trap_erange=False, erange=False,
        trap_divzero=False, divzero=False,
        trap_expbound=False,
        allow_complex=False)
&gt;&gt;&gt; <strong>mpfr</strong>(1)/0
mpfr(&apos;inf&apos;)
&gt;&gt;&gt; gmpy2.get_context().trap_divzero=True
&gt;&gt;&gt; <strong>mpfr</strong>(1)/0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
gmpy2.DivisionByZeroError: &apos;mpfr&apos; division by zero in division
&gt;&gt;&gt; gmpy2.get_context()
context(precision=200, real_prec=Default, imag_prec=Default,
        round=RoundToNearest, real_round=Default, imag_round=Default,
        emax=1073741823, emin=-1073741823,
        subnormalize=False,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=True,
        trap_invalid=False, invalid=False,
        trap_erange=False, erange=False,
        trap_divzero=True, divzero=True,
        trap_expbound=False,
        allow_complex=False)
&gt;&gt;&gt; gmpy2.sqrt(mpfr(-2))
mpfr(&apos;nan&apos;)
&gt;&gt;&gt; gmpy2.get_context().allow_complex=True
&gt;&gt;&gt; gmpy2.get_context().precision=53
&gt;&gt;&gt; gmpy2.sqrt(mpfr(-2))
mpc(&apos;0.0+1.4142135623730951j&apos;)
&gt;&gt;&gt;
&gt;&gt;&gt; gmpy2.set_context(gmpy2.context())
&gt;&gt;&gt; with gmpy2.local_context() as ctx:
...   print(gmpy2.const_pi())
...   ctx.precision+=20
...   print(gmpy2.const_pi())
...   ctx.precision+=20
...   print(gmpy2.const_pi())
...
3.1415926535897931
3.1415926535897932384628
3.1415926535897932384626433831
&gt;&gt;&gt; print(gmpy2.const_pi())
3.1415926535897931
&gt;&gt;&gt;
</pre>

<h3>Miscellaneous gmpy2 Functions</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>from_binary(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>from_binary(bytes) returns a gmpy2 object from a byte sequence created by to_binary().</p>
  </dd>
  <dt>
    <p><strong></strong><strong>get_cache(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>get_cache() returns the current cache size (number of objects) and the maximum size per object (number of limbs).</p><p>gmpy2 maintains an internal list of freed <em>mpz</em>, <em>xmpz</em>, <em>mpq</em>, <em>mpfr</em>, and <em>mpc</em> objects for reuse. The cache significantly improves performance but also increases the memory footprint.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>license(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>license() returns the gmpy2 license information.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mp_limbsize(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mp_limbsize() returns the number of bits per limb used by the GMP or MPIR libarary.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mp_version(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mp_version() returns the version of the GMP or MPIR library.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpc_version(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpc_version() returns the version of the MPC library.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpfr_version(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpfr_version() returns the version of the MPFR library.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>random_state(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>random_state([seed]) returns a new object containing state information for the random number generator. An optional integer argument can be specified as the seed value. Only the Mersenne Twister random number generator is supported.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>set_cache(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>set_cache(number, size) updates the maximum number of freed objects of each type that are cached and the maximum size (in limbs) of each object. The maximum number of objects of each type that can be cached is 1000. The maximum size of an object is 16384. The maximum size of an object is approximately 64K on 32-bit systems and 128K on 64-bit systems.</p><p><strong>NOTE:</strong> The caching options are global to gmpy2. Changes are not thread-safe. A change in one thread will impact all threads.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>to_binary(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>to_binary(x) returns a byte sequence from a gmpy2 object. All object types are supported.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>version(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>version() returns the version of gmpy2.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPLE-PRECISION INTEGERS</h2>
        <div class="sectioncontent">
<p>The gmpy2 <em>mpz</em> type supports arbitrary precision integers. It should be a drop-in replacement for Python&apos;s <em>long</em> type. Depending on the platform and the specific operation, an <em>mpz</em> will be faster than Python&apos;s <em>long</em> once the precision exceeds 20 to 50 digits. All the special integer functions in GMP are supported.</p><h3>Examples</h3>

<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import mpz
&gt;&gt;&gt; mpz(&apos;123&apos;) + 1
mpz(124)
&gt;&gt;&gt; 10 - <strong>mpz</strong>(1)
<strong>mpz</strong>(9)
&gt;&gt;&gt; gmpy2.is_prime(17)
True
</pre>
<p><strong>NOTE:</strong> The use of <strong>from gmpy2 import *</strong> is not recommended. The names in gmpy2 have been chosen to avoid conflict with Python&apos;s builtin names but gmpy2 does use names that may conflict with other modules or variable names.</p>
<h3>mpz Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>bit_clear(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.bit_clear(n) returns a copy of <em>x</em> with bit <em>n</em> set to 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_flip(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.bit_flip(n) returns a copy of <em>x</em> with bit <em>n</em> inverted.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_length(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.bit_length() returns the number of significant bits in the radix-2 representation of <em>x</em>. For compatibility with Python, <strong>mpz</strong>(0).bit_length() returns 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_scan0(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.bit_scan0(n) returns the index of the first 0-bit of <em>x</em> with index &gt;= <em>n</em>. If there are no more 0-bits in <em>x</em> at or above index <em>n</em> (which can only happen for <em>x</em> &lt; 0, assuming an infinitely long 2&apos;s complement format), then None is returned. <em>n</em> must be &gt;= 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_scan1(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.bit_scan1(n) returns the index of the first 1-bit of <em>x</em> with index &gt;= <em>n</em>. If there are no more 1-bits in <em>x</em> at or above index <em>n</em> (which can only happen for <em>x</em> &gt;= 0, assuming an infinitely long 2&apos;s complement format), then None is returned. <em>n</em> must be &gt;= 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_set(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.bit_set(n) returns a copy of <em>x</em> with bit <em>n</em> set to 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_test(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.bit_test(n) returns True if bit <em>n</em> of <em>x</em> is set, and False if it is not set.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>denominator(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.denominator() returns <strong>mpz</strong>(1).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>digits(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.digits([base=10]) returns a string representing <em>x</em> in radix <em>base</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>numerator(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.numerator() returns a copy of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>num_digits(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.num_digits([base=10]) returns the length of the string representing the absolute value of <em>x</em> in radix <em>base</em>. The result is correct if base is a power of 2. For other other bases, the result is usually correct but may be 1 too large. <em>base</em> can range between 2 and 62, inclusive.</p>
  </dd>

</dl>

<h3>mpz Functions</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>add(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>add(x, y) returns <em>x</em> + <em>y</em>. The result type depends on the input types.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bincoef(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bincoef(x, n) returns the binomial coefficient. <em>n</em> must be &gt;= 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_clear(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bit_clear(x, n) returns a copy of <em>x</em> with bit <em>n</em> set to 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_flip(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bit_flip(x, n) returns a copy of <em>x</em> with bit <em>n</em> inverted.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_length(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bit_length(x) returns the number of significant bits in the radix-2 representation of <em>x</em>. For compatibility with Python, <strong>mpz</strong>(0).bit_length() returns 0 while <strong>mpz</strong>(0).<strong>num_digits</strong>(2) returns 1.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_mask(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bit_mask(n) returns an <em>mpz</em> object exactly <em>n</em> bits in length with all bits set.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_scan0(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bit_scan0(x, n) returns the index of the first 0-bit of <em>x</em> with index &gt;= <em>n</em>. If there are no more 0-bits in <em>x</em> at or above index <em>n</em> (which can only happen for <em>x</em> &lt; 0, assuming an infinitely long 2&apos;s complement format), then None is returned. <em>n</em> must be &gt;= 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_scan1(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bit_scan1(x, n) returns the index of the first 1-bit of <em>x</em> with index &gt;= <em>n</em>. If there are no more 1-bits in <em>x</em> at or above index <em>n</em> (which can only happen for <em>x</em> &gt;= 0, assuming an infinitely long 2&apos;s complement format), then None is returned. <em>n</em> must be &gt;= 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_set(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bit_set(x, n) returns a copy of <em>x</em> with bit <em>n</em> set to 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>bit_test(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>bit_test(x, n) returns True if bit <em>n</em> of <em>x</em> is set, and False if it is not set.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>c_div(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>c_div(x, y) returns the quotient of <em>x</em> divided by <em>y</em>. The quotient is rounded towards +Inf (ceiling rounding). <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>c_div_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>c_div_2exp(x, n) returns the quotient of <em>x</em> divided by 2**n. The quotient is rounded towards +Inf (ceiling rounding). <em>x</em> must be an integer and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>c_divmod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>c_divmod(x, y) returns the quotient and remainder of <em>x</em> divided by <em>y</em>. The quotient is rounded towards +Inf (ceiling rounding) and the remainder will have the opposite sign of <em>y</em>. <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>c_divmod_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>c_divmod_2exp(x ,n) returns the quotient and remainder of <em>x</em> divided by 2**n. The quotient is rounded towards +Inf (ceiling rounding) and the remainder will be negative or zero. <em>x</em> must be an integer and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>c_mod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>c_mod(x, y) returns the remainder of <em>x</em> divided by <em>y</em>. The remainder will have the opposite sign of <em>y</em>. <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>c_mod_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>c_mod_2exp(x, n) returns the remainder of <em>x</em> divided by 2**n. The remainder will be negative. <em>x</em> must be an integer and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>comb(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>comb(x, n) returns the number of combinations of <em>x</em> things, taking <em>n</em> at a time. <em>n</em> must be &gt;= 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>digits(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>digits(x[, base=10]) returns a string representing <em>x</em> in radix <em>base</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>div(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>div(x, y) returns <em>x</em> / <em>y</em>. The result type depends on the input types.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>divexact(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>divexact(x, y) returns the quotient of <em>x</em> divided by <em>y</em>. Faster than standard division but requires the remainder is zero!</p>
  </dd>
  <dt>
    <p><strong></strong><strong>divm(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>divm(a, b, m) returns <em>x</em> such that <em>b</em> * <em>x</em> == <em>a</em> modulo <em>m</em>. Raises a ZeroDivisionError exception if no such value <em>x</em> exists.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>f_div(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>f_div(x, y) returns the quotient of <em>x</em> divided by <em>y</em>. The quotient is rounded towards -Inf (floor rounding). <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>f_div_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>f_div_2exp(x, n) returns the quotient of <em>x</em> divided by 2**n. The quotient is rounded towards -Inf (floor rounding). <em>x</em> must be an integer and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>f_divmod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>f_divmod(x, y) returns the quotient and remainder of <em>x</em> divided by <em>y</em>. The quotient is rounded towards -Inf (floor rounding) and the remainder will have the same sign as <em>y</em>. <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>f_divmod_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>f_divmod_2exp(x, n) returns quotient and remainder after dividing <em>x</em> by 2**n. The quotient is rounded towards -Inf (floor rounding) and the remainder will be positive. <em>x</em> must be an integer and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>f_mod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>f_mod(x, y) returns the remainder of <em>x</em> divided by <em>y</em>. The remainder will have the same sign as <em>y</em>. <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>f_mod_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>f_mod_2exp(x, n) returns remainder of <em>x</em> divided by 2**n. The remainder will be positive. <em>x</em> must be an integer and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fac(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fac(n) returns the exact factorial of <em>n</em>. Use factorial() to get the floating-point approximation.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fib(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fib(n) returns the <em>n</em>-th Fibonacci number.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fib2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fib2(n) returns a 2-tuple with the (<em>n</em>-1)-th and <em>n</em>-th Fibonacci numbers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>gcd(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>gcd(a, b) returns the greatest common denominator of integers <em>a</em> and <em>b</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>gcdext(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>gcdext(a, b) returns a 3-element tuple (<em>g</em>, <em>s</em>, <em>t</em>) such that</p><p><em>g</em> == gcd(<em>a</em>, <em>b</em>) and <em>g</em> == <em>a</em> * <em>s</em>  + <em>b</em> * <em>t</em></p>
  </dd>
  <dt>
    <p><strong></strong><strong>hamdist(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>hamdist(x, y) returns the Hamming distance (number of bit-positions where the bits differ) between integers <em>x</em> and <em>y</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>invert(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>invert(x, m) returns <em>y</em> such that <em>x</em> * <em>y</em> == 1 modulo <em>m</em>, or 0 if no such <em>y</em> exists.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>iroot(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>iroot(x,n) returns a 2-element tuple (<em>y</em>, <em>b</em>) such that <em>y</em> is the integer <em>n</em>-th root of <em>x</em> and <em>b</em> is True if the root is exact. <em>x</em> must be &gt;= 0 and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>iroot_rem(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>iroot_rem(x,n) returns a 2-element tuple (<em>y</em>, <em>r</em>) such that <em>y</em> is the integer <em>n</em>-th root of <em>x</em> and <em>x</em> = y**n + <em>r</em>. <em>x</em> must be &gt;= 0 and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_even(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_even(x) returns True if <em>x</em> is even, False otherwise.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_odd(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_odd(x) returns True if <em>x</em> is odd, False otherwise.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_power(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_power(x) returns True if <em>x</em> is a perfect power, False otherwise.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_prime(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_prime(x[, n=25]) returns True if <em>x</em> is <strong>probably</strong> prime. False is returned if <em>x</em> is definately composite. <em>x</em> is checked for small divisors and up to <em>n</em> Miller-Rabin tests are performed. The actual tests performed may vary based on version of GMP or MPIR used.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_square(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_square(x) returns True if <em>x</em> is a perfect square, False otherwise.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>isqrt(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>isqrt(x) returns the integer square root of an integer <em>x</em>. <em>x</em> must be &gt;= 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>isqrt_rem(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>isqrt_rem(x) returns a 2-tuple (<em>s</em>, <em>t</em>) such that <em>s</em> = isqrt(<em>x</em>) and <em>t</em> = <em>x</em> - <em>s</em> * <em>s</em>. <em>x</em> must be &gt;= 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>jacobi(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>jacobi(x, y) returns the Jacobi symbol (<em>x</em> | <em>y</em>). <em>y</em> must be odd and &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>kronecker(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>kronecker(x, y) returns the Kronecker-Jacobi symbol (<em>x</em> | <em>y</em>).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lcm(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lcm(a, b) returns the lowest common multiple of integers <em>a</em> and <em>b</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>legendre(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>legendre(x, y) returns the Legendre symbol (<em>x</em> | <em>y</em>). <em>y</em> is assumed to be an odd prime.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lucas(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lucas(n) returns the <em>n</em>-th Lucas number.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lucas2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lucas2(n) returns a 2-tuple with the (<em>n</em>-1)-th and <em>n</em>-th Lucas numbers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpz(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpz() returns a new <em>mpz</em> object set to 0.</p><p>mpz(n) returns a new <em>mpz</em> object from a numeric value <em>n</em>. If <em>n</em> is not an integer, it will be truncated to an integer.</p><p>mpz(s[, base=0]) returns a new <em>mpz</em> object from a string <em>s</em> made of digits in the given base. If base = 0, thn binary, octal, or hex Python strings are recognized by leading 0b, 0o, or 0x characters. Otherwise the string is assumed to be decimal. Values for base can range between 2 and 62.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpz_random(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpz_random(random_state, n) returns a uniformly distributed random integer between 0 and <em>n</em>-1. The parameter <em>random_state</em> must be created by random_state() first.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpz_rrandomb(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpz_rrandomb(random_state, b) returns a random integer between 0 and 2**b - 1 with long sequences of zeros and one in its binary representation. The parameter <em>random_state</em> must be created by random_state() first.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpz_urandomb(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpz_urandomb(random_state, b) returns a uniformly distributed random integer between 0 and 2**b - 1. The parameter <em>random_state</em> must be created by random_state() first.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mul(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mul(x, y) returns <em>x</em> * <em>y</em>. The result type depends on the input types.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>next_prime(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>next_prime(x) returns the next <strong>probable</strong> prime number &gt; <em>x</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>num_digits(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>num_digits(x[, base=10]) returns the length of the string representing the absolute value of <em>x</em> in radix <em>base</em>. The result is correct if base is a power of 2. For other other bases, the result is usually correct but may be 1 too large. <em>base</em> can range between 2 and 62, inclusive.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>popcount(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>popcount(x) returns the number of bits with value 1 in <em>x</em>. If <em>x</em> &lt; 0, the number of bits with value 1 is infinite so -1 is returned in that case.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>powmod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>powmod(x, y, m) returns (<em>x</em> ** <em>y</em>) mod <em>m</em>. The exponenent <em>y</em> can be negative, and the correct result will be returned if the inverse of <em>x</em> mod <em>m</em> exists. Otherwise, a ValueError is raised.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>remove(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>remove(x, f) will remove the factor <em>f</em> from <em>x</em> as many times as possible and return a 2-tuple (<em>y</em>, <em>m</em>) where <em>y</em> = <em>x</em> // (<em>f</em> ** <em>m</em>). <em>f</em> does not divide <em>y</em>. <em>m</em> is the multiplicity of the factor <em>f</em> in <em>x</em>. <em>f</em> must be &gt; 1.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sub(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sub(x, y) returns <em>x</em> - <em>y</em>. The result type depends on the input types.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>t_div(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>t_div(x, y) returns the quotient of <em>x</em> divided by <em>y</em>. The quotient is rounded towards zero (truncation). <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>t_div_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>t_div_2exp(x, n) returns the quotient of <em>x</em> divided by 2**n. The quotient is rounded towards zero (truncation). <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>t_divmod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>t_divmod(x, y) returns the quotient and remainder of <em>x</em> divided by <em>y</em>. The quotient is rounded towards zero (truncation) and the remainder will have the same sign as <em>x</em>. <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>t_divmod_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>t_divmod_2exp(x, n) returns the quotient and remainder of <em>x</em> divided by 2**n. The quotient is rounded towards zero (truncation) and the remainder will have the same sign as <em>x</em>. <em>x</em> must be an integer and <em>n</em> must be &gt; 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>t_mod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>t_mod(x, y) returns the remainder of <em>x</em> divided by <em>y</em>. The remainder will have the same sign as <em>x</em>. <em>x</em> and <em>y</em> must be integers.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>t_mod_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>t_mod_2exp(x, n) returns the remainder of <em>x</em> divided by 2**n. The remainder will have the same sign as <em>x</em>. <em>x</em> must be an integer and <em>n</em> must be &gt; 0.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPLE-PRECISION INTEGERS (ADVANCED TOPICS)</h2>
        <div class="sectioncontent">
<h3>The xmpz type</h3>
<p>gmpy2 provides access to an experimental integer type called <em>xmpz</em>. The <em>xmpz</em> type is a mutable integer type. In-place operations (+=, //=, etc.) modify the orignal object and do not create a new object. Instances of <em>xmpz</em> cannot be used as dictionary keys.</p>
<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import xmpz
&gt;&gt;&gt; a = xmpz(123)
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a += 1
&gt;&gt;&gt; a
xmpz(124)
&gt;&gt;&gt; b
xmpz(124)
</pre>
<p>The ability to change an <em>xmpz</em> object in-place allows for efficient and rapid bit manipulation.</p><p>Individual bits can be set or cleared:</p>
<pre>
&gt;&gt;&gt; a[10]=1
&gt;&gt;&gt; a
xmpz(1148)
</pre>
<p>Slice notation is supported. The bits referenced by a slice can be either &apos;read from&apos; or &apos;written to&apos;. To clear a slice of bits, use a source value of 0. In 2s-complement format, 0 is represented by an arbitrary number of 0-bits. To set a slice of bits, use a source value of ~0. The <em>tilde</em> operator inverts, or complements the bits in an integer. (~0 is -1 so you can also use -1.) In 2s-complement format, -1 is represented by an arbitrary number of 1-bits.</p><p>If a value for <em>stop</em> is specified in a slice assignment and the actual bit-length of the <em>xmpz</em> is less than <em>stop</em>, then the destination <em>xmpz</em> is logically padded with 0-bits to length <em>stop</em>.</p>
<pre>
&gt;&gt;&gt; a=<strong>xmpz</strong>(0)
&gt;&gt;&gt; a[8:16] = ~0
&gt;&gt;&gt; bin(a)
&apos;0b1111111100000000&apos;
&gt;&gt;&gt; a[4:12] = ~a[4:12]
&gt;&gt;&gt; bin(a)
&apos;0b1111000011110000&apos;
</pre>
<p>Bits can be reversed:</p>
<pre>
&gt;&gt;&gt; bin(a)
&apos;0b10001111100&apos;
&gt;&gt;&gt; a[::] = a[::-1]
&gt;&gt;&gt; bin(a)
&apos;0b111110001&apos;
</pre>
<p>The <em>iter_bits()</em> method returns a generator that returns True or False for each bit position. The methods <em>iter_clear()</em>, and <em>iter_set()</em> return generators that return the bit positions that are 1 or 0. The methods support arguments <em>start</em> and <em>stop</em> that define the beginning and ending bit positions that are used. To mimic the behavior of slices. the bit positions checked include <em>start</em> but the last position checked is <em>stop</em> - 1.</p>
<pre>
&gt;&gt;&gt; a=xmpz(117)
&gt;&gt;&gt; bin(a)
&apos;0b1110101&apos;
&gt;&gt;&gt; list(a.iter_bits())
[True, False, True, False, True, True, True]
&gt;&gt;&gt; list(a.iter_clear())
[1, 3]
&gt;&gt;&gt; list(a.iter_set())
[0, 2, 4, 5, 6]
&gt;&gt;&gt; list(a.iter_bits(stop=12))
[True, False, True, False, True, True, True, False, False, False, False, False]
</pre>
<p>The following program uses the Sieve of Eratosthenes to generate a list of prime numbers.</p>
<pre>
from __future__ import print_function
import time
import gmpy2

def sieve(limit=1000000):
    &apos;&apos;&apos;Returns a generator that yields the prime numbers up to limit.&apos;&apos;&apos;

    # Increment by 1 to account for the fact that slices  do not include
    # the last index value but we do want to include the last value for
    # calculating a list of primes.
    sieve_limit = gmpy2.isqrt(limit) + 1
    limit += 1

    # Mark bit positions 0 and 1 as not prime.
    bitmap = <strong>gmpy2.xmpz</strong>(3)

    # Process 2 separately. This allows us to use p+p for the step size
    # when sieving the remaining primes.
    bitmap[4 : limit : 2] = -1

    # Sieve the remaining primes.
    for p in bitmap.iter_clear(3, sieve_limit):
        bitmap[p*p : limit : p+p] = -1

    return bitmap.iter_clear(2, limit)

if __name__ == "__main__":
    start = time.time()
    result = list(sieve())
    print(time.time() - start)
    print(len(result))
</pre>

<h3>Advanced Number Theory Functions</h3>
<p>The following functions are based on mpz_lucas.c and mpz_prp.c by David Cleaver.</p><p>A good reference for probable prime testing is <em>http://www.pseudoprime.com/pseudo.html</em></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>is_bpsw_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_bpsw_prp(n) will return True if <em>n</em> is a Baillie-Pomerance-Selfridge-Wagstaff probable prime. A BPSW probable prime passes the is_strong_prp() test with base 2 and the is_selfridge_prp() test.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_euler_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_euler_prp(n,a) will return True if <em>n</em> is an Euler (also known as Solovay-Strassen) probable prime to the base <em>a</em>.</p>
<pre>
Assuming:
gcd(n, a) == 1
n is odd

Then an Euler probable prime requires:
a**((n-1)/2) == 1 (mod n)
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>is_extra_strong_lucas_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_extra_strong_lucas_prp(n,p) will return True if <em>n</em> is an extra strong Lucas probable prime with parameters (p,1).</p>
<pre>
Assuming:
n is odd
D = p*p - 4, D != 0
gcd(n, 2*D) == 1
n = s*(2**r) + Jacobi(D,n), s odd

Then an extra strong Lucas probable prime requires:
lucasu(p,1,s) == 0 (mod n)
or
lucasv(p,1,s) == +/-2 (mod n)
or
lucasv(p,1,s*(2**t)) == 0 (mod n) for some t, 0 &lt;= t &lt; r
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>is_fermat_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_fermat_prp(n,a) will return True if <em>n</em> is a Fermat probable prime to the base a.</p>
<pre>
Assuming:
gcd(n,a) == 1

Then a Fermat probable prime requires:
a**(n-1) == 1 (mod n)
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>is_fibonacci_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_fibonacci_prp(n,p,q) will return True if <em>n</em> is an Fibonacci probable prime with parameters (p,q).</p>
<pre>
Assuming:
n is odd
p &gt; 0, q = +/-1
p*p - 4*q != 0

Then a Fibonacci probable prime requires:
lucasv(p,q,n) == p (mod n).
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>is_lucas_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_lucas_prp(n,p,q) will return True if <em>n</em> is a Lucas probable prime with parameters (p,q).</p>
<pre>
Assuming:
n is odd
D = p*p - 4*q, D != 0
gcd(n, 2*q*D) == 1

Then a Lucas probable prime requires:
lucasu(p,q,n - Jacobi(D,n)) == 0 (mod n)
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>is_selfridge_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_selfridge_prp(n) will return True if <em>n</em> is a Lucas probable prime with Selfidge parameters (p,q). The Selfridge parameters are chosen by finding the first element D in the sequence {5, -7, 9, -11, 13, ...} such that Jacobi(D,n) == -1. Let p=1 and q = (1-D)/4 and then perform a Lucas probable prime test.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_strong_bpsw_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_strong_bpsw_prp(n) will return True if <em>n</em> is a strong Baillie-Pomerance-Selfridge-Wagstaff probable prime. A strong BPSW probable prime passes the is_strong_prp() test with base 2 and the is_strongselfridge_prp() test.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_strong_lucas_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_strong_lucas_prp(n,p,q) will return True if <em>n</em> is a strong Lucas probable prime with parameters (p,q).</p>
<pre>
Assuming:
n is odd
D = p*p - 4*q, D != 0
gcd(n, 2*q*D) == 1
n = s*(2**r) + Jacobi(D,n), s odd

Then a strong Lucas probable prime requires:
lucasu(p,q,s) == 0 (mod n)
or
lucasv(p,q,s*(2**t)) == 0 (mod n) for some t, 0 &lt;= t &lt; r
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>is_strong_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_strong_prp(n,a) will return True if <em>n</em> is an strong (also known as Miller-Rabin) probable prime to the base a.</p>
<pre>
Assuming:
gcd(n,a) == 1
n is odd
n = s*(2**r) + 1, with s odd

Then a strong probable prime requires one of the following is true:
a**s == 1 (mod n)
or
a**(s*(2**t)) == -1 (mod n) for some t, 0 &lt;= t &lt; r.
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>is_strong_selfridge_prp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_strong_selfridge_prp(n) will return True if <em>n</em> is a strong Lucas probable prime with Selfidge parameters (p,q). The Selfridge parameters are chosen by finding the first element D in the sequence {5, -7, 9, -11, 13, ...} such that Jacobi(D,n) == -1. Let p=1 and q = (1-D)/4 and then perform a strong Lucas probable prime test.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lucasu(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lucasu(p,q,k) will return the k-th element of the Lucas U sequence defined by p,q. p*p - 4*q must not equal 0; k must be greater than or equal to 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lucasu_mod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lucasu_mod(p,q,k,n) will return the k-th element of the Lucas U sequence defined by p,q (mod n). p*p - 4*q must not equal 0; k must be greater than or equal to 0; n must be greater than 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lucasv(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lucasv(p,q,k) will return the k-th element of the Lucas V sequence defined by parameters (p,q). p*p - 4*q must not equal 0; k must be greater than or equal to 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lucasv_mod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lucasv_mod(p,q,k,n) will return the k-th element of the Lucas V sequence defined by parameters (p,q) (mod n). p*p - 4*q must not equal 0; k must be greater than or equal to 0; n must be greater than 0.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPLE-PRECISION RATIONALS</h2>
        <div class="sectioncontent">
<p>gmpy2 provides a rational type call <em>mpq</em>. It should be a replacement for Python&apos;s fractions.Fraction module.</p>
<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import mpq
&gt;&gt;&gt; mpq(1,7)
mpq(1,7)
&gt;&gt;&gt; mpq(1,7) * 11
mpq(11,7)
&gt;&gt;&gt; mpq(11,7)/13
mpq(11,91)
</pre>
<h3>mpq Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>digits(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.digits([base=10]) returns a Python string representing <em>x</em> in the given base (2 to 62, default is 10). A leading &apos;-&apos; is present if <em>x</em> &lt; 0, but no leading &apos;+&apos; is present if <em>x</em> &gt;= 0.</p>
  </dd>

</dl>

<h3>mpq Attributes</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>denominator</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.denomintor returns the denominator of <em>x</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>numerator</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.numerator returns the numerator of <em>x</em>.</p>
  </dd>

</dl>

<h3>mpq Functions</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>add(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>add(x, y) returns <em>x</em> + <em>y</em>. The result type depends on the input types.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>div(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>div(x, y) returns <em>x</em> / <em>y</em>. The result type depends on the input types.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>f2q(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>f2q(x[, err]) returns the best <em>mpq</em> approximating <em>x</em> to within relative error <em>err</em>. Default is the precision of <em>x</em>. If <em>x</em> is not an <em>mpfr</em>, it is converted to an <em>mpfr</em>. Uses Stern-Brocot tree to find the best approximation. An <em>mpz</em> is returned if the the denominator is 1. If <em>err</em> &lt; 0, then the relative error sought is 2.0 ** <em>err</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpq(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpq() returns an <em>mpq</em> object set to 0/1.</p><p>mpq(n) returns an <em>mpq</em> object with a numeric value <em>n</em>. Decimal and Fraction values are converted exactly.</p><p>mpq(n, m) returns an <em>mpq</em> object with a numeric value <em>n</em> / <em>m</em>.</p><p>mpq(s[, base=10]) returns an <em>mpq</em> object from a string <em>s</em> made up of digits in the given base. <em>s</em> may be made up of two numbers in the same base separated by a &apos;/&apos; character. If <em>base</em> == 10, then an embedded &apos;.&apos; indicates a number with a decimal fractional part.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mul(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mul(x, y) returns <em>x</em> * <em>y</em>. The result type depends on the input types.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>qdiv(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>qdiv(x[, y=1]) returns <em>x/y</em> as <em>mpz</em> if possible, or as <em>mpq</em> if <em>x</em> is not exactly divisible by <em>y</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sub(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sub(x, y) returns <em>x</em> - <em>y</em>. The result type depends on the input types.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPLE-PRECISION REALS</h2>
        <div class="sectioncontent">
<p>gmpy2 replaces the <em>mpf</em> type from gmpy 1.x with a new <em>mpfr</em> type based on the MPFR library. The new <em>mpfr</em> type supports correct rounding, selectable rounding modes, and many trigonometric, exponential, and special functions. A <em>context manager</em> is used to control precision, rounding modes, and the behavior of exceptions.</p><p>The default precision of an <em>mpfr</em> is 53 bits - the same precision as Python&apos;s <em>float</em> type. If the precison is changed, then <strong>mpfr(float(&apos;1.2&apos;))</strong> differs from <strong>mpfr(&apos;1.2&apos;)</strong>. To take advantage of the higher precision provided by the <em>mpfr</em> type, always pass constants as strings.</p>
<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import mpfr
&gt;&gt;&gt; mpfr(&apos;1.2&apos;)
mpfr(&apos;1.2&apos;)
&gt;&gt;&gt; mpfr(float(&apos;1.2&apos;))
mpfr(&apos;1.2&apos;)
&gt;&gt;&gt; gmpy2.get_context().precision=100
&gt;&gt;&gt; mpfr(&apos;1.2&apos;)
mpfr(&apos;1.2000000000000000000000000000006&apos;,100)
&gt;&gt;&gt; mpfr(float(&apos;1.2&apos;))
mpfr(&apos;1.1999999999999999555910790149937&apos;,100)
&gt;&gt;&gt;
</pre>
<h3>Contexts</h3>
<p><strong>WARNING:</strong> Contexts and context managers are not thread-safe! Modifying the context in one thread will impact all other threads.</p><p>A <em>context</em> is used to control the behavior of <em>mpfr</em> and <em>mpc</em> arithmetic. In addition to controlling the precision, the rounding mode can be specified, minimum and maximum exponent values can be changed, various exceptions can be raised or ignored, gradual underflow can be enabled, and returning complex results can be enabled.</p><p><strong>gmpy2.context()</strong> creates a new context with all options set to default. <strong>gmpy2.set_context(ctx)</strong> will set the active context to <em>ctx</em>. <strong>gmpy2.get_context()</strong> will return a reference to the active context. Note that contexts are mutable: modifying the reference returned by get_context() will modify the active context until a new context is enabled with set_context(). The <strong>copy()</strong> method of a context will return a copy of the context.</p><p>The following example just modifies the precision. The remaining options will be discussed later.</p>
<pre>
&gt;&gt;&gt; gmpy2.set_context(gmpy2.context())
&gt;&gt;&gt; gmpy2.get_context()
context(precision=53, real_prec=Default, imag_prec=Default,
        round=RoundToNearest, real_round=Default, imag_round=Default,
        emax=1073741823, emin=-1073741823,
        subnormalize=False,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=False,
        trap_invalid=False, invalid=False,
        trap_erange=False, erange=False,
        trap_divzero=False, divzero=False,
        trap_expbound=False,
        allow_complex=False)
&gt;&gt;&gt; <strong>gmpy2.sqrt</strong>(5)
mpfr(&apos;2.2360679774997898&apos;)
&gt;&gt;&gt; gmpy2.get_context().precision=100
&gt;&gt;&gt; <strong>gmpy2.sqrt</strong>(5)
mpfr(&apos;2.2360679774997896964091736687316&apos;,100)
&gt;&gt;&gt; gmpy2.get_context().precision+=20
&gt;&gt;&gt; <strong>gmpy2.sqrt</strong>(5)
mpfr(&apos;2.2360679774997896964091736687312762351&apos;,120)
&gt;&gt;&gt; ctx=gmpy2.get_context()
&gt;&gt;&gt; ctx.precision+=20
&gt;&gt;&gt; <strong>gmpy2.sqrt</strong>(5)
mpfr(&apos;2.2360679774997896964091736687312762354406182&apos;,140)
&gt;&gt;&gt; gmpy2.set_context(gmpy2.context())
&gt;&gt;&gt; <strong>gmpy2.sqrt</strong>(5)
mpfr(&apos;2.2360679774997898&apos;)
&gt;&gt;&gt; ctx.precision+=20
&gt;&gt;&gt; <strong>gmpy2.sqrt</strong>(5)
mpfr(&apos;2.2360679774997898&apos;)
&gt;&gt;&gt; gmpy2.set_context(ctx)
&gt;&gt;&gt; <strong>gmpy2.sqrt</strong>(5)
mpfr(&apos;2.2360679774997896964091736687312762354406183596116&apos;,160)
&gt;&gt;&gt;
</pre>

<h3>Context Attributes</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>precision</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls the precision of an <em>mpfr</em> result. The precision is specified in bits, not decimal digits. The maximum precision that can be specified is platform dependent and can be retrieved with <strong>get_max_precision()</strong>.</p><p><strong>NOTE:</strong> Specifying a value for precision that is too close to the maximum precision will cause the MPFR library to fail.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>real_prec</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls the precision of the real part of an <em>mpc</em> result. If the value is <strong>Default</strong>, then the value of the precision attribute is used.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>imag_prec</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls the precision of the imaginary part of an <em>mpc</em> result. If the value is <strong>Default</strong>, then the value of real_prec is used.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>round</strong><strong></strong></p>
  </dt>
  <dd>
    <p>There are five rounding modes availble to <em>mpfr</em> types:</p>
  </dd>
  <dt>
    <p><strong></strong><strong>RoundAwayZero</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The result is rounded away from 0.0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>RoundDown</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The result is rounded towards -Infinity.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>RoundToNearest</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Round to the nearest value; ties are rounded to an even value.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>RoundToZero</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The result is rounded towards 0.0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>RoundUp</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The result is rounded towards +Infinity.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>real_round</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls the rounding mode for the real part of an <em>mpc</em> result. If the value is <strong>Default</strong>, then the value of the round attribute is used. Note: <strong>RoundAwayZero</strong> is not a valid rounding mode for <em>mpc</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>imag_round</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls the rounding mode for the imaginary part of an <em>mpc</em> result. If the value is <strong>Default</strong>, then the value of the real_round attribute is used. Note: <strong>RoundAwayZero</strong> is not a valid rounding mode for <em>mpc</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>emax</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls the maximum allowed exponent of an <em>mpfr</em> result. The maximum exponent is platform dependent and can be retrieved with <strong>get_emax_max()</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>emin</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls the minimum allowed exponent of an <em>mpfr</em> result. The minimum exponent is platform dependent and can be retrieved with <strong>get_emin_min()</strong>.</p><p><strong>NOTE:</strong> It is possible to change the values of emin/emax such that previous <em>mpfr</em> values are no longer valid numbers but should either underflow to +/-0.0 or overflow to +/-Infinity. To raise an exception if this occurs, see <strong>trap_expbound</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>subnormalize</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The usual IEEE-754 floating point representation supports gradual underflow when the minimum exponent is reached. The MFPR library does not enable gradual underflow by default but it can be enabled to precisely mimic the results of IEEE-754 floating point operations.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>trap_underflow</strong><strong></strong></p>
  </dt>
  <dd>
    <p>If set to <strong>False</strong>, a result that is smaller than the smallest possible <em>mpfr</em> given the current exponent range will be replaced by +/-0.0. If set to <strong>True</strong>, an <strong>UnderflowResultError</strong> exception is raised.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>underflow</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This flag is not user controllable. It is automatically set if a result underflowed to +/-0.0 and trap_underflow is <strong>False</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>trap_overflow</strong><strong></strong></p>
  </dt>
  <dd>
    <p>If set to <strong>False</strong>, a result that is larger than the largest possible <em>mpfr</em> given the current exponent range will be replaced by +/-Infinity. If set to <strong>True</strong>, an <strong>OverflowResultError</strong> exception is raised.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>overflow</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This flag is not user controllable. It is automatically set if a result overflowed to +/-Infinity and trap_overflow is <strong>False</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>trap_inexact</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls whether or not an <strong>InexactResultError</strong> exception is raised if an inexact result is returned. To check if the result is greater or less than the exact result, check the <strong>rc</strong> attribute of the <em>mpfr</em> result.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>inexact</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This flag is not user controllable. It is automatically set if an inexact result is returned.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>trap_invalid</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls whether or not an <strong>InvalidOperationError</strong> exception is raised if a numerical result is not defined. A special NaN (Not-A-Number) value will be returned if an exception is not raised. The <strong>InvalidOperationError</strong> is a sub-class of Python&apos;s <strong>ValueError</strong>.</p><p>For example, <strong>gmpy2.sqrt(-2)</strong> will normally return <em>mpfr(&apos;nan&apos;)</em>. However, if allow_complex is set to <strong>True</strong>, then an <em>mpc</em> result will be returned.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>invalid</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This flag is not user controllable. It is automatically set if an invalid (Not-A-Number) result is returned.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>trap_erange</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls whether or not a <strong>RangeError</strong> exception is raised when certain operations are performed on NaN and/or Infinity values. Setting trap_erange to <strong>True</strong> can be used to raise an exception if comparisons are attempted with a NaN.</p>
<pre>
&gt;&gt;&gt; gmpy2.set_context(gmpy2.context())
&gt;&gt;&gt; mpfr(&apos;nan&apos;) == mpfr(&apos;nan&apos;)
False
&gt;&gt;&gt; gmpy2.get_context().trap_erange=True
&gt;&gt;&gt; mpfr(&apos;nan&apos;) == mpfr(&apos;nan&apos;)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
gmpy2.RangeError: comparison with NaN
&gt;&gt;&gt;
</pre>

  </dd>
  <dt>
    <p><strong></strong><strong>erange</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This flag is not user controllable. It is automatically set if an erange error occurred.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>trap_divzero</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls whether or not a <strong>DivisionByZeroError</strong> exception is raised if division by 0 occurs. The <strong>DivisionByZeroError</strong> is a sub-class of Python&apos;s <strong>ZeroDivisionError</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>divzero</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This flag is not user controllable. It is automatically set if a division by zero occurred and NaN result was returned.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>trap_expbound</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls whether or not an <strong>ExponentOutOfBoundsError</strong> exception is raised if exponents in an operand are outside the current emin/emax limits.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>allow_complex</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This attribute controls whether or not an <em>mpc</em> result can be returned if an <em>mpfr</em> result would normally not be possible.</p>
  </dd>

</dl>

<h3>Context Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>clear_flags()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Clear the underflow, overflow, inexact, invalid, erange, and divzero flags.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>copy()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Return a copy of the context.</p>
  </dd>

</dl>

<h3>Contexts and the with statement</h3>
<p>Contexts can also be used in conjunction with Python&apos;s <strong>with ...</strong> statement to temporarily change the context settings for a block of code and then restore the original settings when the block of code exits.</p><p><strong>gmpy2.local_context()</strong> first save the current context and then creates a new context based on a context passed as the first argument, or the current context if no context is passed. The new context is modified if any optional keyword arguments are given. The orginal active context is restored when the block completes.</p><p>In the following example, the current context is saved by <strong>gmpy2.local_context()</strong> and then the block begins with a copy of the default context and the precision set to 100. When the block is finished, the original context is restored.</p>
<pre>
&gt;&gt;&gt; with gmpy2.local_context(gmpy2.context(), precision=100) as ctx:
...   print(<strong>gmpy2.sqrt</strong>(2))
...   ctx.precision += 100
...   print(<strong>gmpy2.sqrt</strong>(2))
...
1.4142135623730950488016887242092
1.4142135623730950488016887242096980785696718753769480731766796
&gt;&gt;&gt;
</pre>
<p>A context object can also be used directly to create a context manager block. However, instead of restoring the context to the active context when the <strong>with ...</strong> statement is executed, the restored context is the context used before any keyword argument modifications.</p><p>The code:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>::</strong></p>
  </dt>
  <dd>
    <p>with gmpy2.ieee(64) as ctx:</p><p>is equivalent to:</p>
  </dd>
  <dt>
    <p><strong>::</strong></p>
  </dt>
  <dd>
    <p>gmpy2.set_context(gmpy2.ieee(64)) with gmpy2.local_context() as ctx:</p><p>Contexts that implement the standard <em>single</em>, <em>double</em>, and <em>quadruple</em> precision floating point types can be created using <strong>ieee()</strong>.</p>
  </dd>

</dl>

<h3>mpfr Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>as_integer_ratio()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns a 2-tuple containing the numerator and denominator after converting the <em>mpfr</em> object into the exact rational equivalent. The return 2-tuple is equivalent to Python&apos;s as_integer_ratio() method of built-in float objects.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>as_mantissa_exp()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns a 2-tuple containing the mantissa and exponent.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>as_simple_fraction()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns an <em>mpq</em> containing the simpliest rational value that approximates the <em>mpfr</em> value with an error less than 1/(2**precision).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>conjugate()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns the complex conjugate. For <em>mpfr</em> objects, returns a copy of the original object.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>digits()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns a 3-tuple containing the mantissa, the exponent, and the number of bits of precision. The mantissa is represented as a string in the specified base with up to &apos;prec&apos; digits. If &apos;prec&apos; is 0, as many digits that are available are returned. No more digits than available given x&apos;s precision are returned. &apos;base&apos; must be between 2 and 62, inclusive.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_integer()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns True if the <em>mpfr</em> object is an integer.</p>
  </dd>

</dl>

<h3>mpfr Attributes</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>imag</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns the imaginary component. For <em>mpfr</em> objects, returns 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>precision</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns the precision of the <em>mpfr</em> object.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rc</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The result code (also known as ternary value in the MPFR documentation) is 0 if the value of the <em>mpfr</em> object is exactly equal to the exact, infinite precision value. If the result code is 1, then the value of the <em>mpfr</em> object is greater than the exact value. If the result code is -1, then the value of the <em>mpfr</em> object is less than the exact, infinite precision value.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>real</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns the real component. For <em>mpfr</em> objects, returns a copy of the original object.</p>
  </dd>

</dl>

<h3>mpfr Functions</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>acos(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>acos(x) returns the arc-cosine of x. x is measured in radians. If context.allow_complex is True, then an <em>mpc</em> result will be returned for abs(x) &gt; 1.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>acosh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>acosh(x) returns the inverse hyperbolic cosine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>add(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>add(x, y) returns x + y. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>agm(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>agm(x, y) returns the arithmetic-geometric mean of x and y.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>ai(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>ai(x) returns the Airy function of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>asin(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>asin(x) returns the arc-sine of x. x is measured in radians. If context.allow_complex is True, then an <em>mpc</em> result will be returned for abs(x) &gt; 1.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>asinh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>asinh(x) return the inverse hyperbolic sine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>atan(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>atan(x) returns the arc-tangent of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>atan2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>atan2(y, x) returns the arc-tangent of (y/x).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>atanh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>atanh(x) returns the inverse hyperbolic tangent of x. If context.allow_complex is True, then an <em>mpc</em> result will be returned for abs(x) &gt; 1.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>cbrt(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>cbrt(x) returns the cube root of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>ceil(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>ceil(x) returns the &apos;mpfr&apos; that is the smallest integer &gt;= x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>check_range(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>check_range(x) return a new &apos;mpfr&apos; with exponent that lies within the current range of emin and emax.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>const_catalan(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>const_catalan([precision=0]) returns the catalan constant using the specified precision. If no precision is specified, the default precision is used.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>const_euler(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>const_euler([precision=0]) returns the euler constant using the specified precision. If no precision is specified, the default precision is used.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>const_log2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>const_log2([precision=0]) returns the log2 constant using the specified precision. If no precision is specified, the default precision is used.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>const_pi(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>const_pi([precision=0]) returns the constant pi using the specified precision. If no precision is specified, the default precision is used.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>context(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>context() returns a new context manager controlling MPFR and MPC arithmetic.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>cos(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>cos(x) seturns the cosine of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>cosh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>cosh(x) returns the hyperbolic cosine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>cot(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>cot(x) returns the cotangent of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>coth(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>coth(x) returns the hyperbolic cotangent of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>csc(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>csc(x) returns the cosecant of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>csch(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>csch(x) returns the hyperbolic cosecant of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>degrees(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>degrees(x) converts an angle measurement x from radians to degrees.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>digamma(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>digamma(x) returns the digamma of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>div(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>div(x, y) returns x / y. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>div_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>div_2exp(x, n) returns an &apos;mpfr&apos; or &apos;mpc&apos; divided by 2**n.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>eint(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>eint(x) returns the exponential integral of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>erf(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>erf(x) returns the error function of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>erfc(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>erfc(x) returns the complementary error function of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>exp(x) returns e**x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>exp10(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>exp10(x) returns 10**x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>exp2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>exp2(x) returns 2**x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>expm1(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>expm1(x) returns e**x - 1. expm1() is more accurate than exp(x) - 1 when x is small.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>f2q(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>f2q(x[,err]) returns the simplest <em>mpq</em> approximating x to within relative error err. Default is the precision of x. Uses Stern-Brocot tree to find the simplist approximation. An <em>mpz</em> is returned if the the denominator is 1. If err&lt;0, error sought is 2.0 ** err.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>factorial(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>factorial(n) returns the floating-point approximation to the factorial of n.</p><p>See fac(n) to get the exact integer result.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>floor(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>floor(x) returns the &apos;mpfr&apos; that is the smallest integer &lt;= x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fma(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fma(x, y, z) returns correctly rounded result of (x * y) + z.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fmod(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fmod(x, y) returns x - n*y where n is the integer quotient of x/y, rounded to 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fms(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fms(x, y, z) returns correctly rounded result of (x * y) - z.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>frac(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>frac(x) returns the fractional part of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>frexp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>frexp(x) returns a tuple containing the exponent and mantissa of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fsum(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fsum(iterable) returns the accurate sum of the values in the iterable.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>gamma(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>gamma(x) returns the gamma of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>get_exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>get_exp(mpfr) returns the exponent of an <em>mpfr</em>. Returns 0 for NaN or Infinity and sets the erange flag and will raise an exception if trap_erange is set.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>hypot(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>hypot(y, x) returns square root of (x**2 + y**2).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>ieee(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>ieee(bitwidth) returns a context with settings for 32-bit (aka single), 64-bit (aka double), or 128-bit (aka quadruple) precision floating point types.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>inf(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>inf(n) returns an <em>mpfr</em> initialized to Infinity with the same sign as n. If n is not given, +Infinity is returned.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_finite(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_finite(x) returns True if x is an actual number (i.e. not NaN or Infinity).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_inf(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_inf(x) returns True if x is Infinity or -Infinity.</p><p><strong>NOTE:</strong> <strong>is_inf()</strong> is deprecated; please use <strong>if_infinite()</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_infinite(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_infinite(x) returns True if x Infinity or -Infinity.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_nan(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_nan(x) returns True if x is NaN (Not-A-Number).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_number(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_number(x) returns True if x is an actual number (i.e. not NaN or Infinity).</p><p><strong>NOTE:</strong> <strong>is_number()</strong> is deprecated; please use <strong>is_finite()</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_regular(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_regular(x) returns True if x is not zero, NaN, or Infinity.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_signed(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_signed(x) returns True if the sign bit of x is set.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_unordered(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_unordered(x,y) returns True if either x and/or y is NaN.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_zero(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_zero(x) returns True if x is zero.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>j0(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>j0(x) returns the Bessel function of the first kind of order 0 of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>j1(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>j1(x) returns the Bessel function of the first kind of order 1 of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>jn(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>jn(x,n) returns the Bessel function of the first kind of order n of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lgamma(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lgamma(x) returns a tuple containing the logarithm of the absolute value of gamma(x) and the sign of gamma(x)</p>
  </dd>
  <dt>
    <p><strong></strong><strong>li2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>li2(x) returns the real part of dilogarithm of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>lngamma(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>lngamma(x) returns the logarithm of gamma(x).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>log(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>log(x) returns the natural logarithm of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>log10(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>log10(x) returns the base-10 logarithm of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>log1p(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>log1p(x) returns the natural logarithm of (1+x).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>log2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>log2(x) returns the base-2 logarithm of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>max2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>max2(x, y) returns the maximum of x and y. The result may be rounded to match the current context. Use the builtin max() to get an exact copy of the largest object without any rounding.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>min2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>min2(x, y) returns the minimum of x and y. The result may be rounded to match the current context. Use the builtin min() to get an exact copy of the smallest object without any rounding.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>modf(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>modf(x) returns a tuple containing the integer and fractional portions of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpfr(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpfr() returns and <em>mpfr</em> object set to 0.0.</p><p>mpfr(n[, precison=0]) returns an <em>mpfr</em> object after converting a numeric value n. If no precision, or a precision of 0, is specified; the precision is taken from the current context.</p><p>mpfr(s[, precision=0[, [base=0]]) returns an <em>mpfr</em> object after converting a string &apos;s&apos; made up of digits in the given base, possibly with fractional part (with period as a separator) and/or exponent (with exponent marker &apos;e&apos; for base&lt;=10, else &apos;@&apos;). If no precision, or a precision of 0, is specified; the precison is taken from the current context. The base of the string representation must be 0 or in the interval 2 ... 62. If the base is 0, the leading digits of the string are used to identify the base: 0b implies base=2, 0x implies base=16, otherwise base=10 is assumed.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpfr_from_old_binary(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpfr_from_old_binary(string) returns an <em>mpfr</em> from a GMPY 1.x binary mpf format. Please use to_binary()/from_binary() to convert GMPY2 objects to or from a binary format.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpfr_grandom(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpfr_grandom(random_state) returns two random numbers with gaussian distribution. The parameter <em>random_state</em> must be created by random_state() first.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpfr_random(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpfr_random(random_state) returns a uniformly distributed number between [0,1]. The parameter <em>random_state</em> must be created by random_state() first.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mul(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mul(x, y) returns x * y. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mul_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mul_2exp(x, n) returns &apos;mpfr&apos; or &apos;mpc&apos; multiplied by 2**n.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>nan(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>nan() returns an &apos;mpfr&apos; initialized to NaN (Not-A-Number).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>next_above(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>next_above(x) returns the next &apos;mpfr&apos; from x toward +Infinity.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>next_below(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>next_below(x) returns the next &apos;mpfr&apos; from x toward -Infinity.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>radians(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>radians(x) converts an angle measurement x from degrees to radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rec_sqrt(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>rec_sqrt(x) returns the reciprocal of the square root of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>reldiff(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>reldiff(x, y) returns the relative difference between x and y. Result is equal to abs(x-y)/x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>remainder(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>remainder(x, y) returns x - n*y where n is the integer quotient of x/y, rounded to the nearest integer and ties rounded to even.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>remquo(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>remquo(x, y) returns a tuple containing the remainder(x,y) and the low bits of the quotient.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rint(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>rint(x) returns x rounded to the nearest integer using the current rounding mode.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rint_ceil(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>rint_ceil(x) returns x rounded to the nearest integer by first rounding to the next higher or equal integer and then, if needed, using the current rounding mode.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rint_floor(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>rint_floor(x) returns x rounded to the nearest integer by first rounding to the next lower or equal integer and then, if needed, using the current rounding mode.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rint_round(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>rint_round(x) returns x rounded to the nearest integer by first rounding to the nearest integer (ties away from 0) and then, if needed, using the current rounding mode.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rint_trunc(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>rint_trunc(x) returns x rounded to the nearest integer by first rounding towards zero and then, if needed, using the current rounding mode.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>root(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>root(x, n) returns n-th root of x. The result always an <em>mpfr</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>round2(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>round2(x[, n]) returns x rounded to n bits. Uses default precision if n is not specified. See round_away() to access the mpfr_round() function. Use the builtin round() to round x to n decimal digits.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>round_away(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>round_away(x) returns an <em>mpfr</em> by rounding x the nearest integer, with ties rounded away from 0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sec(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sec(x) returns the secant of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sech(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sech(x) returns the hyperbolic secant of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>set_exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>set_exp(x, n) sets the exponent of a given <em>mpfr</em> to n. If n is outside the range of valid exponents, set_exp() will set the erange flag and either return the original value or raise an exception if trap_erange is set.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>set_sign(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>set_sign(x, bool) returns a copy of x with it&apos;s sign bit set if <em>bool</em> evaluates to True.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sign(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sign(x) returns -1 if x &lt; 0, 0 if x == 0, or +1 if x &gt;0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sin(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sin(x) returns the sine of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sin_cos(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sin_cos(x) returns a tuple containing the sine and cosine of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sinh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sinh(x) returns the hyberbolic sine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sinh_cosh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sinh_cosh(x) returns a tuple containing the hyperbolic sine and cosine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sqrt(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sqrt(x) returns the square root of x. If x is integer, rational, or real, then an <em>mpfr</em> will be returned. If x is complex, then an <em>mpc</em> will be returned. If context.allow_complex is True, negative values of x will return an <em>mpc</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>square(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>square(x) returns x * x. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sub(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sub(x, y) returns x - y. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>tan(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>tan(x) returns the tangent of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>tanh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>tanh(x) returns the hyperbolic tangent of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>trunc(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>trunc(x) returns an &apos;mpfr&apos; that is x truncated towards 0. Same as x.floor() if x&gt;=0 or x.ceil() if x&lt;0.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>y0(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>y0(x) returns the Bessel function of the second kind of order 0 of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>y1(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>y1(x) returns the Bessel function of the second kind of order 1 of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>yn(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>yn(x,n) returns the Bessel function of the second kind of order n of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>zero(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>zero(n) returns an <em>mpfr</em> inialized to 0.0 with the same sign as n. If n is not given, +0.0 is returned.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>zeta(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>zeta(x) returns the Riemann zeta of x.</p>
  </dd>

</dl>

<h3>mpfr Formatting</h3>
<p>The <em>mpfr</em> type supports the __format__() special method to allow custom output formatting.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>__format__(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.__format__(fmt) returns a Python string by formatting &apos;x&apos; using the format string &apos;fmt&apos;. A valid format string consists of:</p>
<pre>
optional alignment code:
&apos;&lt;&apos; -&gt; left shifted in field
&apos;&gt;&apos; -&gt; right shifted in field
&apos;^&apos; -&gt; centered in field
optional leading sign code
&apos;+&apos; -&gt; always display leading sign
&apos;-&apos; -&gt; only display minus for negative values
&apos; &apos; -&gt; minus for negative values, space for positive values
optional width.precision
optional rounding mode:
&apos;U&apos; -&gt; round toward plus infinity
&apos;D&apos; -&gt; round toward minus infinity
&apos;Y&apos; -&gt; round away from zero
&apos;Z&apos; -&gt; round toward zero
&apos;N&apos; -&gt; round to nearest
optional conversion code:
&apos;a&apos;,&apos;A&apos; -&gt; hex format
&apos;b&apos;     -&gt; binary format
&apos;e&apos;,&apos;E&apos; -&gt; scientific format
&apos;f&apos;,&apos;F&apos; -&gt; fixed point format
&apos;g&apos;,&apos;G&apos; -&gt; fixed or scientific format
</pre>
<p><strong>NOTE:</strong> The formatting codes must be specified in the order shown above.</p>
<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import mpfr
&gt;&gt;&gt; a=mpfr("1.23456")
&gt;&gt;&gt; "{0:15.3f}".format(a)
&apos;          1.235&apos;
&gt;&gt;&gt; "{0:15.3Uf}".format(a)
&apos;          1.235&apos;
&gt;&gt;&gt; "{0:15.3Df}".format(a)
&apos;          1.234&apos;
&gt;&gt;&gt; "{0:.3Df}".format(a)
&apos;1.234&apos;
&gt;&gt;&gt; "{0:+.3Df}".format(a)
&apos;+1.234&apos;
</pre>

  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPLE-PRECISION COMPLEX</h2>
        <div class="sectioncontent">
<p>gmpy2 adds a multiple-precision complex type called <em>mpc</em> that is based on the MPC library. The context manager settings for <em>mpfr</em> arithmetic are applied to <em>mpc</em> arithmetic by default. It is possible to specifiy different precision and rounding modes for both the real and imaginary components of an <em>mpc</em>.</p>
<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import mpc
&gt;&gt;&gt; gmpy2.sqrt(mpc("1+2j"))
mpc(&apos;1.272019649514069+0.78615137775742328j&apos;)
&gt;&gt;&gt; gmpy2.get_context(real_prec=100,imag_prec=200)
context(precision=53, real_prec=100, imag_prec=200,
        round=RoundToNearest, real_round=Default, imag_round=Default,
        emax=1073741823, emin=-1073741823,
        subnormalize=False,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=True,
        trap_invalid=False, invalid=False,
        trap_erange=False, erange=False,
        trap_divzero=False, divzero=False,
        trap_expbound=False,
        allow_complex=False)
&gt;&gt;&gt; gmpy2.sqrt(mpc("1+2j"))
mpc(&apos;1.2720196495140689642524224617376+0.78615137775742328606955858584295892952312205783772323766490213j&apos;,(100,200))
</pre>
<p>Exceptions are normally raised in Python when the result of a real operation is not defined over the reals; for example, <strong>sqrt(-4)</strong> will raise an exception. The default context in gmpy2 implements the same behavior but by setting allow_complex to True, complex results will be returned.</p>
<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import mpc
&gt;&gt;&gt; gmpy2.sqrt(-4)
mpfr(&apos;nan&apos;)
&gt;&gt;&gt; gmpy2.get_context(allow_complex=True)
context(precision=53, real_prec=Default, imag_prec=Default,
        round=RoundToNearest, real_round=Default, imag_round=Default,
        emax=1073741823, emin=-1073741823,
        subnormalize=False,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=False,
        trap_invalid=False, invalid=True,
        trap_erange=False, erange=False,
        trap_divzero=False, divzero=False,
        trap_expbound=False,
        allow_complex=True)
&gt;&gt;&gt; gmpy2.sqrt(-4)
mpc(&apos;0.0+2.0j&apos;)
</pre>
<h3>mpc Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>conjugate()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns the complex conjugate.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>digits()</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns a two element tuple where each element represents the real and imaginary components as a 3-tuple containing the mantissa, the exponent, and the number of bits of precision. The mantissa is represented as a string in the specified base with up to &apos;prec&apos; digits. If &apos;prec&apos; is 0, as many digits that are available are returned. No more digits than available given x&apos;s precision are returned. &apos;base&apos; must be between 2 and 62, inclusive.</p>
  </dd>

</dl>

<h3>mpc Attributes</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>imag</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns the imaginary component.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>precision</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns a 2-tuple containing the the precision of the real and imaginary components.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rc</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns a 2-tuple containing the ternary value of the real and imaginary components. The ternary value is 0 if the value of the component is exactly equal to the exact, infinite precision value. If the result code is 1, then the value of the component is greater than the exact value. If the result code is -1, then the value of the component is less than the exact, infinite precision value.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>real</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Returns the real component.</p>
  </dd>

</dl>

<h3>mpc Functions</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>acos(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>acos(x) returns the arc-cosine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>acosh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>acosh(x) returns the inverse hyperbolic cosine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>add(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>add(x, y) returns x + y. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>asin(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>asin(x) returns the arc-sine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>asinh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>asinh(x) return the inverse hyperbolic sine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>atan(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>atan(x) returns the arc-tangent of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>atanh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>atanh(x) returns the inverse hyperbolic tangent of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>cos(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>cos(x) seturns the cosine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>cosh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>cosh(x) returns the hyperbolic cosine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>div(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>div(x, y) returns x / y. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>div_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>div_2exp(x, n) returns an &apos;mpfr&apos; or &apos;mpc&apos; divided by 2**n.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>exp(x) returns e**x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fma(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fma(x, y, z) returns correctly rounded result of (x * y) + z.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>fms(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>fms(x, y, z) returns correctly rounded result of (x * y) - z.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_inf(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_inf(x) returns True if either the real or imaginary component of x is Infinity or -Infinity.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_nan(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_nan(x) returns True if either the real or imaginary component of x is NaN (Not-A-Number).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>is_zero(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>is_zero(x) returns True if x is zero.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>log(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>log(x) returns the natural logarithm of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>log10(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>log10(x) returns the base-10 logarithm of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpc(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpc() returns an <em>mpc</em> object set to 0.0+0.0j.</p><p>mpc(c[, precision=0]) returns a new &apos;mpc&apos; object from an existing complex number (either a Python complex object or another &apos;mpc&apos; object). If the precision is not specified, then the precision is taken from the current context. The rounding mode is always taken from the current context.</p><p>mpc(r[, i=0[, precision=0]]) returns a new &apos;mpc&apos; object by converting two non-complex numbers into the real and imaginary components of an &apos;mpc&apos; object. If the precision is not specified, then the precision is taken from the current context. The rounding mode is always taken from the current context.</p><p>mpc(s[, [precision=0[, base=10]]) returns a new &apos;mpc&apos; object by converting a string s into a complex number. If base is omitted, then a base-10 representation is assumed otherwise a base between 2 and 36 can be specified. If the precision is not specified, then the precision is taken from the current context. The rounding mode is always taken from the current context.</p><p>In addition to the standard Python string representation of a complex number: <strong>"1+2j"</strong>, the string representation used by the MPC library: <strong>"(1 2)"</strong> is also supported.</p><p><strong>NOTE:</strong> The precision can be specified either a single number that is used for both the real and imaginary components, or as a 2-tuple that can specify different precisions for the real and imaginary components.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mpc_random(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mpfc_random(random_state) returns a uniformly distributed number in the unit square [0,1]x[0,1]. The parameter <em>random_state</em> must be created by random_state() first.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mul(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mul(x, y) returns x * y. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>mul_2exp(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>mul_2exp(x, n) returns &apos;mpfr&apos; or &apos;mpc&apos; multiplied by 2**n.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>norm(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>norm(x) returns the norm of a complex x. The norm(x) is defined as x.real**2 + x.imag**2. abs(x) is the square root of norm(x).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>phase(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>phase(x) returns the phase angle, also known as argument, of a complex x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>polar(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>polar(x) returns the polar coordinate form of a complex x that is in rectangular form.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>proj(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>proj(x) returns the projection of a complex x on to the Riemann sphere.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>rect(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>rect(x) returns the polar coordinate form of a complex x that is in rectangular form.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sin(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sin(x) returns the sine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sinh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sinh(x) returns the hyberbolic sine of x.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sqrt(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sqrt(x) returns the square root of x. If x is integer, rational, or real, then an <em>mpfr</em> will be returned. If x is complex, then an <em>mpc</em> will be returned. If context.allow_complex is True, negative values of x will return an <em>mpc</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>square(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>square(x) returns x * x. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>sub(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>sub(x, y) returns x - y. The type of the result is based on the types of the arguments.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>tan(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>tan(x) returns the tangent of x. x is measured in radians.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>tanh(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>tanh(x) returns the hyperbolic tangent of x.</p>
  </dd>

</dl>

<h3>mpc Formatting</h3>
<p>The <em>mpc</em> type supports the __format__() special method to allow custom output formatting.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>__format__(...)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>x.__format__(fmt) returns a Python string by formatting &apos;x&apos; using the format string &apos;fmt&apos;. A valid format string consists of:</p>
<pre>
optional alignment code:
&apos;&lt;&apos; -&gt; left shifted in field
&apos;&gt;&apos; -&gt; right shifted in field
&apos;^&apos; -&gt; centered in field
optional leading sign code
&apos;+&apos; -&gt; always display leading sign
&apos;-&apos; -&gt; only display minus for negative values
&apos; &apos; -&gt; minus for negative values, space for positive values
optional width.real_precision.imag_precision
optional rounding mode:
&apos;U&apos; -&gt; round toward plus infinity
&apos;D&apos; -&gt; round toward minus infinity
&apos;Z&apos; -&gt; round toward zero
&apos;N&apos; -&gt; round to nearest
optional output style:
&apos;P&apos; -&gt; Python style, 1+2j, (default)
&apos;M&apos; -&gt; MPC style, (1 2)
optional conversion code:
&apos;a&apos;,&apos;A&apos; -&gt; hex format
&apos;b&apos;     -&gt; binary format
&apos;e&apos;,&apos;E&apos; -&gt; scientific format
&apos;f&apos;,&apos;F&apos; -&gt; fixed point format
&apos;g&apos;,&apos;G&apos; -&gt; fixed or scientific format
</pre>
<p><strong>NOTE:</strong> The formatting codes must be specified in the order shown above.</p>
<pre>
&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; from gmpy2 import mpc
&gt;&gt;&gt; a=gmpy2.sqrt(mpc("1+2j"))
&gt;&gt;&gt; a
mpc(&apos;1.272019649514069+0.78615137775742328j&apos;)
&gt;&gt;&gt; "{0:.4.4Mf}".format(a)
&apos;(1.2720 0.7862)&apos;
&gt;&gt;&gt; "{0:.4.4f}".format(a)
&apos;1.2720+0.7862j&apos;
&gt;&gt;&gt; "{0:^20.4.4U}".format(a)
&apos;   1.2721+0.7862j   &apos;
&gt;&gt;&gt; "{0:^20.4.4D}".format(a)
&apos;   1.2720+0.7861j   &apos;
</pre>
<ul>
<li><p><em>genindex</em></p></li><li><p><em>modindex</em></p></li><li><p><em>search</em></p></li>
</ul>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Case Van Horsen</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2012, 2013, Case Van Horsen</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gmm.hpp.3.html"><span aria-hidden="true">&larr;</span> gmm.hpp.3: Src/mlpack/methods/gmm/gmm.hpp -</a></li>
   <li class="next"><a href="gmtime.3.html">gmtime.3: Transform date and time to broken-down time or ascii <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

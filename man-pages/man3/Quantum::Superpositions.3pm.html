<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Quantum::Superpositions: Qm-like superpositions in perl</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Qm-like superpositions in perl">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Quantum::Superpositions (3pm) manual">
  <meta name="twitter:description" content="Qm-like superpositions in perl">
  <meta name="twitter:image" content="https://www.carta.tech/images/libquantum-superpositions-perl-Quantum::Superpositions-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Quantum::Superpositions.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Quantum::Superpositions (3pm) manual" />
  <meta property="og:description" content="Qm-like superpositions in perl" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libquantum-superpositions-perl-Quantum::Superpositions-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Quantum::Superpositions<small> (3pm)</small></h1>
        <p class="lead">Qm-like superpositions in perl</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Quantum::Superpositions.3pm.html">
      <span itemprop="name">Quantum::Superpositions: Qm-like superpositions in perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libquantum-superpositions-perl/">
      <span itemprop="name">libquantum-superpositions-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Quantum::Superpositions.3pm.html">
      <span itemprop="name">Quantum::Superpositions: Qm-like superpositions in perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes version 1.03 of Quantum::Superpositions, released August 11, 2000.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        use Quantum::Superpositions;

        if ($x == any($a, $b, $c)) { ...  }

        while ($nextval &lt; all(@thresholds)) { ... }

        $max = any(@value) &lt; all(@values);


        use Quantum::Superpositions BINARY =&gt; [ CORE::index ];

        print index( any("opts","tops","spot"), "o" );
        print index( "stop", any("p","s") );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BACKGROUND</h2>
        <div class="sectioncontent">
<p>Under the standard interpretation of quantum mechanics, until they are observed, particles exist only as a discontinuous probability function. Under the Cophenhagen Interpretation, this situation is often visualized by imagining the state of an unobserved particle to be a ghostly overlay of all its possible observable states simultaneously. For example, a particle that might be observed in state A, B, or C may be considered to be in a pseudo-state where it is simultaneously in states A, B, and C. Such a particle is said to be in a superposition of states.</p><p>Research into applying particle superposition in construction of computer hardware is already well advanced. The aim of such research is to develop reliable quantum memories, in which an individual bit is stored as some measurable property of a quantised particle (a qubit). Because the particle can be physically coerced into a superposition of states, it can store bits that are simultaneously 1 and 0.</p><p>Specific processes based on the interactions of one or more qubits (such as interference, entanglement, or additional superposition) are then be used to construct quantum logic gates. Such gates can in turn be employed to perform logical operations on qubits, allowing logical and mathematical operations to be executed in parallel.</p><p>Unfortunately, the math required to design and use quantum algorithms on quantum computers is painfully hard. The Quantum::Superpositions module offers another approach, based on the superposition of entire scalar values (rather than individual qubits).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The Quantum::Superpositions module adds two new operators to Perl: \*(C`any\*(C' and \*(C`all\*(C'.</p><p>Each of these operators takes a list of values (states) and superimposes them into a single scalar value (a superposition), which can then be stored in a standard scalar variable.</p><p>The \*(C`any\*(C' and \*(C`all\*(C' operators produce two distinct kinds of superposition. The \*(C`any\*(C' operator produces a disjunctive superposition, which may (notionally) be in any one of its states at any time, according to the needs of the algorithm that uses it.</p><p>In contrast, the \*(C`all\*(C' operator creates a conjunctive superposition, which is always in every one of its states simultaneously.</p><p>Superpositions are scalar values and hence can participate in arithmetic and logical operations just like any other type of scalar. However, when an operation is applied to a superposition, it is applied (notionally) in parallel to each of the states in that superposition.</p><p>For example, if a superposition of states 1, 2, and 3 is multiplied by 2:</p><p>        $result = any(1,2,3) * 2;</p><p>the result is a superposition of states 2, 4, and 6. If that result is then compared with the value 4:</p><p>        if ($result == 4) { print "fore!" }</p><p>then the comparison also returns a superposition: one that is both true and false (since the equality is true for one of the states of $result and false for the other two).</p><p>Of course, a value that is both true and false is of no use in an \*(C`if\*(C' statement, so some mechanism is needed to decide which superimposed boolean state should take precedence.</p><p>This mechanism is provided by the two types of superposition available. A disjunctive superposition is true if any of its states is true, whereas a conjunctive superposition is true only if all of its states are true.</p><p>Thus the previous example does print \*(L"fore!\*(R", since the \*(C`if\*(C' condition is equivalent to:</p><p>        if (any(2,4,6) == 4)...</p><p>It suffices that any one of 2, 4, or 6 is equal to 4, so the condition is true and the \*(C`if\*(C' block executes.</p><p>On the other hand, had the control statement been:</p><p>        if (all(2,4,6) == 4)...</p><p>the condition would fail, since it is not true that all of 2, 4, and 6 are equal to 4.</p><p>Operations are also possible between two superpositions:</p><p>        if (all(1,2,3)*any(5,6) &lt; 21)                 { print "no alcohol"; }</p><p>        if (all(1,2,3)*any(5,6) &lt; 18)                 { print "no entry"; }</p><p>        if (any(1,2,3)*all(5,6) &lt; 18)                 { print "under-age" }</p><p>In this example, the string \*(L"no alcohol\*(R" is printed because the superposition produced by the multiplication is the Cartesian product of the respective states of the two operands: \*(C`all(5,6,10,12,15,18)\*(C'. Since all of these resultant states are less that 21, the condition is true. In contrast, the string \*(L"no entry\*(R" is not printed, because not all the product's states are less than 18.</p><p>Note that the type of the first operand determines the type of the result of an operation. Hence the third string \*(-- \*(L"underage\*(R" \*(-- is printed, because multiplying a disjunctive superposition by a conjunctive superposition produces a result that is disjunctive: \*(C`any(5,6,10,12,15,18)\*(C'. The condition of the \*(C`if\*(C' statement asks whether any of these values is less than 18, which is true.</p><h3>Composite Superpositions</h3>
<p>The states of a superposition may be any kind of scalar value \*(-- a number, a string, or a reference:</p><p>        $wanted = any("Mr","Ms").any(@names);         if ($name eq $wanted) { print "Reward!"; }</p><p>        $okay = all(&#92;&check1,&#92;&check2);         die unless $okay-&gt;();</p><p>        my $large =                 all(    BigNum-&gt;new($centillion),                         BigNum-&gt;new($googol),                         BigNum-&gt;new($SkewesNum)                 );         @huge =  grep {$_ &gt; $large} @nums;</p><p>More interestingly, since the individual states of a superposition are scalar values and a superposition is itself a scalar value, a superposition may have states that are themselves superpositions:</p><p>        $ideal = any( all("tall", "rich", "handsome"),                       all("rich", "old"),                       all("smart","Australian","rich")                     );</p><p>Operations involving such a composite superposition operate recursively and in parallel on each its states individually and then recompose the result. For example:</p><p>        while (@features = get_description)                 {                 if (any(@features) eq $ideal)                                 {                         print "True love";                 }         }</p><p>The \*(C`any(@features) eq $ideal\*(C' equality is true if the input characteristics collectively match any of the three superimposed conjunctive superpositions. That is, if the characteristics collectively equate to each of \*(L"tall\*(R" and \*(L"rich\*(R" and \*(L"handsome\*(R", or to both \*(L"rich\*(R" and \*(L"old\*(R", or to all three of \*(L"smart\*(R" and \*(L"Australian\*(R" and \*(L"rich\*(R".</p>
<h3>Eigenstates</h3>
<p>It is useful to be able to determine the list of states that a given superposition represents. In fact, it is not the <em>states</em> per se, but the values to which the states may collapse \*(-- the <em>eigenstates</em> that are useful.</p><p>In programming terms this is the set of values @ev for a given superposition $s such that \*(C`any(@ev) == $s\*(C' or \*(C`any(@ev) eq $s\*(C'.</p><p>This list is provided by the \*(C`eigenstates\*(C' operator, which may be called on any superposition:</p><p>        print "The factor was: ",               eigenstates($factor);</p><p>        print "Don&apos;t use any of:",               eigenstates($badpasswds);</p>
<h3>Boolean evaluation of superpositions</h3>
<p>The examples shown above assume the same meta-semantics for both arithmetic and boolean operations, namely that a binary operator is applied to the Cartesian product of the states of its two operands, regardless of whether the operation is arithmetic or logical. Thus the comparison of two superpositions produces a superposition of 1's and 0's, representing any (or all) possible comparisons between the individual states of the two operands.</p><p>The drawback of applying arithmetic metasemantics to logical operations is that it causes useful information to be lost. Specifically, which states were responsible for the success of the comparison. For example, it is possible to determine if any number in the array @newnums is less than all those in the array @oldnums with:</p><p>        if (any(@newnums) &lt; @all(oldnums))                 {           print "New minimum detected";         }</p><p>But this is almost certainly unsatisfactory, because it does not reveal which element(s) of @newnum caused the condition to be true.</p><p>It is, however, possible to define a different meta-semantics for logical operations between superpositions; one that preserves the intuitive logic of comparisons but also gives limited access to the states that cause those comparsions to succeed.</p><p>The key is to deviate from the arithmetic view of superpositional comparison (namely, that a compared superposition yields a superposition of compared state combinations). Instead, the various comparison operators are redefined so that they form a superposition of those eigenstates of the left operand that cause the operation to be true. In other words, the old meta-semantics superimposed the result of each parallel comparison, whilst the new meta-semantics superimposes the left operands of each parallel comparison that succeeds.</p><p>For example, under the original semantics, the comparisons:</p><p>        all(7,8,9) &lt;= any(5,6,7)        #A         all(5,6,7) &lt;= any(7,8,9)        #B         any(6,7,8) &lt;= all(7,8,9)        #C</p><p>would yield:</p><p>        all(0,0,1,0,0,0,0,0,0)          #A (false)         all(1,1,1,1,1,1,1,1,1)          #B (true)         any(1,1,1,1,1,1,0,1,1)          #C (true)</p><p>Under the new semantics they would yield:</p><p>        <strong>all</strong>(7)                          #A (false)         all(5,6,7)                      #B (true)         any(6,7)                        #C (true)</p><p>The success of the comparison (the truth of the result) is no longer determined by the <em>values</em> of the resulting states, but by the <em>number</em> of states in the resulting superposition.</p><p>The Quantum::Superpositions module treats logical operations and boolean conversions in exactly this way. Under these meta-semantics, it is possible to check a comparison and also determine which eigenstates of the left operand were responsible for its success:</p><p>        $newmins = any(@newnums) &lt; all(@oldnums);</p><p>        if ($newmins)                 {                 print "New minima found:", eigenstates($newmins);         }</p><p>Thus, these semantics provide a mechanism to conduct parallel searches for minima and maxima :</p><p>        sub min { eigenstates( any(@_) &lt;= all(@_) ) }</p><p>        sub max { eigenstates( any(@_) &gt;= all(@_) ) }</p><p>These definitions are also quite intuitive, almost declarative: the minimum is any value that is less-than-or-equal-to all of the other values; the maximum is any value that is greater-than-or-equal to all of them.</p>
<h3>String evaluation of superpositions</h3>
<p>Converting a superposition to a string produces a string that encode the simplest set of eigenstates equivalent to the original superposition.</p><p>If there is only one eigenstate, the stringification of that state is the string representation. This eliminates the need to explicitly apply the \*(C`eigenstates\*(C' operator when only a single resultant state is possible. For example:</p><p>        print "lexicographically first: ",               any(@words) le all(@words);</p><p>In all other cases, superpositions are stringified in the format: "all(<strong>eigenstates)"</strong> or "any(<strong>eigenstates)"</strong>.</p>
<h3>Numerical evaluation of superpositions</h3>
<p>Providing an implicit conversion to numeric (for situations where superpositions are used as operands to an arithmetic operation, or as array indices) is more challenging than stringification, since there is no mechanism to capture the entire state of a superposition in a single non-superimposed number.</p><p>Again, if the superposition has a single eigenstate, the conversion is just the standard conversion for that value. For instance, to output the value in an array element with the smallest index in the set of indices @i:</p><p>        print "The smallest element is: ",               $array[any(@i)&lt;=all(@i)];</p><p>If the superposition has no eigenstates, there is no numerical value to which it could collapse, so the result is \*(C`undef\*(C'.</p><p>If a disjunctive superposition has more than one eigenstate, that superposition could collapse to any of those values. And it is convenient to allow it to do exactly that \*(-- collapse (pseudo-)randomly to one of its eigenstates. Indeed, doing so provides a useful notation for random selection from a list:</p><p>        print "And the winner is...",               $entrant[any(0..$#entrant)];</p>
<h3>Superpositions as subroutine arguments</h3>
<p>When a superposition is used as a subroutine argument, that subroutine is applied in parallel to each state of the superposition and the results re-superimposed to form the same type of superposition. For example, given:</p><p>        $n1 = any(1,4,9);         $r1 = sqrt($n1);</p><p>        $n2 = all(1,4,9);         $r2 = pow($n2,3);</p><p>        $r3 = pow($n1,$r1);</p><p>then $r1 contains the disjunctive superposition \*(C`any(1,2,3)\*(C', $r2 contains the conjunctive superposition \*(C`all(1,64,729)\*(C', and &lt;$r3 &gt; contains the conjunctive superposition \*(C`any(1,4,9,16,64,81,729)\*(C'.</p><p>Because the built-in \*(C`sqrt\*(C' and \*(C`pow\*(C' functions don't know about superpositions, the module provides a mechanism for informing them that their arguments may be superimposed.</p><p>If the call to \*(C`use Quantum::Superpositions\*(C' is given an argument list, that list specifies which functions should be rewritten to handle superpositions. Unary functions and subroutine can be \*(L"quantized\*(R" like  so:</p><p>        sub incr    { $_[0]+1 }         sub numeric { $_[0]+0 eq $_[0] }</p><p>        use Quantum::Superpositions                 UNARY         =&gt; ["CORE::int", "main::incr"],                 UNARY_LOGICAL =&gt; ["main::numeric"];</p><p>For binary functions and subroutines use:</p><p>        sub max  { $_[0] &lt; $_[1] ? $_[1] : $_[0] }</p><p>        sub same { my $failed; $IG{_\|_WARN_\|_}=sub{$failed=1};                    return $_[0] eq $_[1] || $_[0]==$_[1] && !$failed;                  }</p><p>        use Quantum::Superpositions                 BINARY         =&gt; [&apos;main::max&apos;, &apos;CORE::index&apos;],                 BINARY_LOGICAL =&gt; [&apos;main::same&apos;];</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<h3>Primality testing</h3>
<p>The power of programming with scalar superpositions is perhaps best seen by returning the quantum computing's favourite adversary: prime numbers. Here, for example is an O(1) prime-number tester, based on naive trial division:</p><p>        sub is_prime                 {           my ($n) = @_;           return $n % all(2..sqrt($n)+1) != 0         }</p><p>The subroutine takes a single argument ($n) and computes (in parallel) its modulus with respect to every integer between 2 and \*(C`sqrt($n)\*(C'. This produces a conjunctive superposition of moduli, which is then compared with zero. That comparison will only be true if all the moduli are not zero, which is precisely the requirement for an integer to be prime.</p><p>Because \*(C`is_prime\*(C' takes a single scalar argument, it can also be passed a superposition. For example, here is a constant-time filter for detecting whether a number is part of a pair of twin primes:</p><p>        sub has_twin                 {                 my ($n) = @_;                 return is_prime($n) && is_prime($n+any(+2,-2);         }</p>
<h3>Set membership and intersection</h3>
<p>Set operations are particularly easy to perform using superimposable scalars. For example, given an array of values @elems, representing the elements of a set, the value $v is an element of that set if:</p><p>        $v == any(@elems)</p><p>Note that this is equivalent to the definition of an eigenstate. That equivalence can be used to compute set intersections. Given two disjunctive superpositions, \*(C`$s1=any(@elems1)\*(C' and \*(C`$s2=any(@elems2)\*(C', representing two sets, the values that constitute the intersection of those sets must be eigenstates of both &lt;$s1&gt; and $s2. Hence:</p><p>        @intersection = eigenstates(all($s1, $s2));</p><p>This result can be extended to extract the common elements from an arbitrary number of arrays in parallel:</p><p>        @common = eigenstates( all(     any(@list1),                                         any(@list2),                                         any(@list3),                                         any(@list4),                                   )                      );</p>
<h3>Factoring</h3>
<p>Factoring numbers is also trivial using superpositions. The factors of an integer N are all the quotients q of N/n (for all positive integers n &lt; N) that are also integral. A positive number q is integral if floor(q)==q. Hence the factors of a given number are computed by:</p><p>        sub factors                 {           my ($n) = @_;           my $q = $n / any(2..$n-1);           return eigenstates(floor($q)==$q);         }</p>
<h3>Query processing</h3>
<p>Superpositions can also be used to perform text searches. For example, to determine whether a given string ($target) appears in a collection of strings (@db):</p><p>        use Quantum::Superpositions BINARY =&gt; ["CORE::index"];</p><p>        $found = index(any(@db), $target) &gt;= 0;</p><p>To determine which of the database strings contain the target:</p><p>        sub contains_str                 {                         return $dbstr if (index($dbstr, $target) &gt;= 0;         }</p><p>        $found = contains_str(any(@db), $target);         @matches = eigenstates $found;</p><p>It is also possible to superimpose the target string, rather than the database, so as to search a single string for any of a set of targets:</p><p>        sub contains_targ                 {                 if (index($dbstr, $target) &gt;= 0)                                 {                         return $target;                 }         }</p><p>        $found = contains_targ($string, any(@targets));         @matches = eigenstates $found;</p><p>or in every target simultaneously:</p><p>        $found = contains_targ($string, all(@targets));         @matches = eigenstates $found;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Damian Conway (damian@conway.org)</p><p>Now maintainted by Steven Lembark (lembark@wrkhors.com)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 1998-2002, Damian Conway. Copyright (c) 2002, Steven Lembark</p><p>All Rights Reserved.</p><p>This module is free software. It may be used, redistributed and/or modified under the stame terms as Perl-5.6.1 (or later) (see http://www.perl.com/perl/misc/Artistic.html).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Quantum::Entanglement.3pm.html"><span aria-hidden="true">&larr;</span> Quantum::Entanglement.3pm: Qm entanglement of variables in perl</a></li>
   <li class="next"><a href="RDF::Crypt.3pm.html">RDF::Crypt.3pm: Semantic cryptography <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

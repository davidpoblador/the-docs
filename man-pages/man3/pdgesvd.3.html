<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pdgesvd: Compute the singular value decomposition (svd) of an m-by-n matrix a, optionally computing the left and/or right singular vectors</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Compute the singular value decomposition (svd) of an m-by-n matrix a, optionally computing the left and/or right singular vectors">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pdgesvd (3) manual">
  <meta name="twitter:description" content="Compute the singular value decomposition (svd) of an m-by-n matrix a, optionally computing the left and/or right singular vectors">
  <meta name="twitter:image" content="https://www.carta.tech/images/scalapack-doc-pdgesvd-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pdgesvd.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pdgesvd (3) manual" />
  <meta property="og:description" content="Compute the singular value decomposition (svd) of an m-by-n matrix a, optionally computing the left and/or right singular vectors" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/scalapack-doc-pdgesvd-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pdgesvd<small> (3)</small></h1>
        <p class="lead">Compute the singular value decomposition (svd) of an m-by-n matrix a, optionally computing the left and/or right singular vectors</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pdgesvd.3.html">
      <span itemprop="name">pdgesvd: Compute the singular value decomposition (svd) of an m-by-n matrix a, optionally computing the left and/or right singular vectors</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/scalapack-doc/">
      <span itemprop="name">scalapack-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pdgesvd.3.html">
      <span itemprop="name">pdgesvd: Compute the singular value decomposition (svd) of an m-by-n matrix a, optionally computing the left and/or right singular vectors</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>SUBROUTINE PDGESVD(</p>
  </dt>
  <dd>
    <p>JOBU, JOBVT, M, N, A, IA, JA, DESCA, S, U, IU, JU, DESCU, VT, IVT, JVT, DESCVT, WORK, LWORK, INFO )</p>
  </dd>
  <dt>
    <p>CHARACTER</p>
  </dt>
  <dd>
    <p>JOBU, JOBVT</p>
  </dd>
  <dt>
    <p>INTEGER</p>
  </dt>
  <dd>
    <p>IA, INFO, IU, IVT, JA, JU, JVT, LWORK, M, N</p>
  </dd>
  <dt>
    <p>INTEGER</p>
  </dt>
  <dd>
    <p>DESCA( * ), DESCU( * ), DESCVT( * )</p>
  </dd>
  <dt>
    <p>DOUBLE</p>
  </dt>
  <dd>
    <p>PRECISION A( * ), S( * ), U( * ), VT( * ), WORK( * )</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PURPOSE</h2>
        <div class="sectioncontent">
<p>PDGESVD computes the singular value decomposition (SVD) of an M-by-N matrix A, optionally computing the left and/or right singular vectors. The SVD is written as</p>
<pre>
     A = U * SIGMA * transpose(V)
</pre>
<p>where SIGMA is an M-by-N matrix which is zero except for its min(M,N) diagonal elements, U is an M-by-M orthogonal matrix, and V is an N-by-N orthogonal matrix. The diagonal elements of SIGMA are the singular values of A and the columns of U and V are the corresponding right and left singular vectors, respectively. The singular values are returned in array S in decreasing order and only the first min(M,N) columns of U and rows of VT = V**T are computed.</p><p>Notes</p><p>=====</p><p>Each global data object is described by an associated description vector. This vector stores the information required to establish the mapping between an object element and its corresponding process and memory location.</p><p>Let A be a generic term for any 2D block cyclicly distributed array. Such a global array has an associated description vector DESCA. In the following comments, the character _ should be read as "of the global array".</p><p>NOTATION        STORED IN      EXPLANATION</p><p>--------------- -------------- -------------------------------------- DTYPE_A(global) DESCA( DTYPE_ )The descriptor type.  In this case,</p>
<pre>
                               DTYPE_A = 1.
</pre>
<p>CTXT_A (global) DESCA( CTXT_ ) The BLACS context handle, indicating</p>
<pre>
                               the BLACS process grid A is distribu-
                               ted over. The context itself is glo-
                               bal, but the handle (the integer
                               value) may vary.
</pre>
<p>M_A    (global) DESCA( M_ )    The number of rows in the global</p>
<pre>
                               array A.
</pre>
<p>N_A    (global) DESCA( N_ )    The number of columns in the global</p>
<pre>
                               array A.
</pre>
<p>MB_A   (global) DESCA( MB_ )   The blocking factor used to distribute</p>
<pre>
                               the rows of the array.
</pre>
<p>NB_A   (global) DESCA( NB_ )   The blocking factor used to distribute</p>
<pre>
                               the columns of the array.
</pre>
<p>RSRC_A (global) DESCA( RSRC_ ) The process row over which the first</p>
<pre>
                               row of the array A is distributed.
</pre>
<p>CSRC_A (global) DESCA( CSRC_ ) The process column over which the</p>
<pre>
                               first column of the array A is
                               distributed.
</pre>
<p>LLD_A  (local)  DESCA( LLD_ )  The leading dimension of the local</p>
<pre>
                               array.  LLD_A &gt;= MAX(1,LOCr(M_A)).
</pre>
<p>Let K be the number of rows or columns of a distributed matrix, and assume that its process grid has dimension p x q. LOCr( K ) denotes the number of elements of K that a process would receive if K were distributed over the p processes of its process column. Similarly, LOCc( K ) denotes the number of elements of K that a process would receive if K were distributed over the q processes of its process row. The values of LOCr() and LOCc() may be determined via a call to the ScaLAPACK tool function, NUMROC:</p>
<pre>
        LOCr( M ) = NUMROC( M, MB_A, MYROW, RSRC_A, NPROW ),
        LOCc( N ) = NUMROC( N, NB_A, MYCOL, CSRC_A, NPCOL ).
</pre>
<p>An upper bound for these quantities may be computed by:</p>
<pre>
        LOCr( M ) &lt;= ceil( ceil(M/MB_A)/NPROW )*MB_A
</pre>

<pre>
        LOCc( N ) &lt;= ceil( ceil(N/NB_A)/NPCOL )*NB_A
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ARGUMENTS</h2>
        <div class="sectioncontent">
<p>MP = number of local rows in A and U NQ = number of local columns in A and VT SIZE = min( M, N ) SIZEQ = number of local columns in U SIZEP = number of local rows in VT</p>
<dl class='dl-vertical'>
  <dt>
    <p>JOBU    (global input) CHARACTER*1</p>
  </dt>
  <dd>
    <p>Specifies options for computing all or part of the matrix U:</p><p>= 'V':  the first SIZE columns of U (the left singular vectors) are returned in the array U; = 'N':  no columns of U (no left singular vectors) are computed.</p>
  </dd>
  <dt>
    <p>JOBVT   (global input) CHARACTER*1</p>
  </dt>
  <dd>
    <p>Specifies options for computing all or part of the matrix V**T:</p><p>= 'V':  the first SIZE rows of V**T (the right singular vectors) are returned in the array VT; = 'N':  no rows of V**T (no right singular vectors) are computed.</p>
  </dd>
  <dt>
    <p>M       (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The number of rows of the input matrix A.  M &gt;= 0.</p>
  </dd>
  <dt>
    <p>N       (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The number of columns of the input matrix A.  N &gt;= 0.</p>
  </dd>
  <dt>
    <p>A       (local input/workspace) block cyclic DOUBLE PRECISION array,</p>
  </dt>
  <dd>
    <p>global dimension (M, N), local dimension (MP, NQ) On exit, the contents of A are destroyed.</p>
  </dd>
  <dt>
    <p>IA      (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The row index in the global array A indicating the first row of sub( A ).</p>
  </dd>
  <dt>
    <p>JA      (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The column index in the global array A indicating the first column of sub( A ).</p>
  </dd>
  <dt>
    <p>DESCA   (global input) INTEGER array of dimension DLEN_</p>
  </dt>
  <dd>
    <p>The array descriptor for the distributed matrix A.</p>
  </dd>
  <dt>
    <p>S       (global output) DOUBLE PRECISION array, dimension SIZE</p>
  </dt>
  <dd>
    <p>The singular values of A, sorted so that S(i) &gt;= S(i+1).</p>
  </dd>
  <dt>
    <p>U       (local output) DOUBLE PRECISION array, local dimension</p>
  </dt>
  <dd>
    <p>(MP, SIZEQ), global dimension (M, SIZE) if JOBU = 'V', U contains the first min(m,n) columns of U if JOBU = 'N', U is not referenced.</p>
  </dd>
  <dt>
    <p>IU      (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The row index in the global array U indicating the first row of sub( U ).</p>
  </dd>
  <dt>
    <p>JU      (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The column index in the global array U indicating the first column of sub( U ).</p>
  </dd>
  <dt>
    <p>DESCU   (global input) INTEGER array of dimension DLEN_</p>
  </dt>
  <dd>
    <p>The array descriptor for the distributed matrix U.</p>
  </dd>
  <dt>
    <p>VT      (local output) DOUBLE PRECISION array, local dimension</p>
  </dt>
  <dd>
    <p>(SIZEP, NQ), global dimension (SIZE, N). If JOBVT = 'V', VT contains the first SIZE rows of V**T. If JOBVT = 'N', VT is not referenced.</p>
  </dd>
  <dt>
    <p>IVT     (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The row index in the global array VT indicating the first row of sub( VT ).</p>
  </dd>
  <dt>
    <p>JVT     (global input) INTEGER</p>
  </dt>
  <dd>
    <p>The column index in the global array VT indicating the first column of sub( VT ).</p>
  </dd>
  <dt>
    <p>DESCVT   (global input) INTEGER array of dimension DLEN_</p>
  </dt>
  <dd>
    <p>The array descriptor for the distributed matrix VT.</p>
  </dd>
  <dt>
    <p>WORK    (local workspace/output) DOUBLE PRECISION array, dimension</p>
  </dt>
  <dd>
    <p>(LWORK) On exit, if INFO = 0, <strong>WORK</strong>(1) returns the optimal LWORK;</p>
  </dd>
  <dt>
    <p>LWORK   (local input) INTEGER</p>
  </dt>
  <dd>
    <p>The dimension of the array WORK.</p><p>LWORK &gt; 2 + 6*SIZEB + MAX(WATOBD, WBDTOSVD),</p><p>where SIZEB = MAX(M,N), and WATOBD and WBDTOSVD refer, respectively, to the workspace required to bidiagonalize the matrix A and to go from the bidiagonal matrix to the singular value decomposition U*S*VT.</p><p>For WATOBD, the following holds:</p><p>WATOBD = MAX(MAX(WPDLANGE,WPDGEBRD), MAX(WPDLARED2D,WPDLARED1D)),</p><p>where WPDLANGE, WPDLARED1D, WPDLARED2D, WPDGEBRD are the workspaces required respectively for the subprograms PDLANGE, PDLARED1D, PDLARED2D, PDGEBRD. Using the standard notation</p><p>MP = NUMROC( M, MB, MYROW, DESCA( CTXT_ ), NPROW), NQ = NUMROC( N, NB, MYCOL, DESCA( LLD_ ), NPCOL),</p><p>the workspaces required for the above subprograms are</p><p>WPDLANGE = MP, WPDLARED1D = NQ0, WPDLARED2D = MP0, WPDGEBRD = NB*(MP + NQ + 1) + NQ,</p><p>where NQ0 and MP0 refer, respectively, to the values obtained at MYCOL = 0 and MYROW = 0. In general, the upper limit for the workspace is given by a workspace required on processor (0,0):</p><p>WATOBD &lt;= NB*(MP0 + NQ0 + 1) + NQ0.</p><p>In case of a homogeneous process grid this upper limit can be used as an estimate of the minimum workspace for every processor.</p><p>For WBDTOSVD, the following holds:</p><p>WBDTOSVD = SIZE*(WANTU*NRU + WANTVT*NCVT) + MAX(WDBDSQR, MAX(WANTU*WPDORMBRQLN, WANTVT*WPDORMBRPRT)),</p>
  </dd>
  <dt>
    <p>where</p>
  </dt>
  <dd>
    <p>1, if left(right) singular vectors are wanted WANTU(WANTVT) = 0, otherwise</p><p>and WDBDSQR, WPDORMBRQLN and WPDORMBRPRT refer respectively to the workspace required for the subprograms DBDSQR, PDORMBR(QLN), and PDORMBR(PRT), where QLN and PRT are the values of the arguments VECT, SIDE, and TRANS in the call to PDORMBR. NRU is equal to the local number of rows of the matrix U when distributed 1-dimensional "column" of processes. Analogously, NCVT is equal to the local number of columns of the matrix VT when distributed across 1-dimensional "row" of processes. Calling the LAPACK procedure DBDSQR requires</p><p>WDBDSQR = MAX(1, 2*SIZE + (2*SIZE - 4)*MAX(WANTU, WANTVT))</p><p>on every processor. Finally,</p><p>WPDORMBRQLN = MAX( (NB*(NB-1))/2, (SIZEQ+MP)*NB)+NB*NB, WPDORMBRPRT = MAX( (MB*(MB-1))/2, (SIZEP+NQ)*MB )+MB*MB,</p><p>If LIWORK = -1, then LIWORK is global input and a workspace query is assumed; the routine only calculates the minimum size for the work array. The required workspace is returned as the first element of WORK and no error message is issued by PXERBLA.</p>
  </dd>
  <dt>
    <p>INFO    (output) INTEGER</p>
  </dt>
  <dd>
    <p>= 0:  successful exit.</p><p>&lt; 0:  if INFO = -i, the i-th argument had an illegal value.</p><p>&gt; 0:  if SBDSQR did not converge If INFO = MIN(M,N) + 1, then PDGESVD has detected heterogeneity by finding that eigenvalues were not identical across the process grid. In this case, the accuracy of the results from PDGESVD cannot be guaranteed.</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pdgesv.3.html"><span aria-hidden="true">&larr;</span> pdgesv.3: Compute the solution to a real system of linear equations   sub( a ) * x = sub( b ),</a></li>
   <li class="next"><a href="pdgetf2.3.html">pdgetf2.3: Compute an lu factorization of a general m-by-n distributed matrix sub( a ) = a(ia:ia+m-1,ja:ja+n-1) using partial pivoting with row interchanges <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

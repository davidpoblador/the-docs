<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>IPC::Run::Timer: Timer channels for ipc::run.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Timer channels for ipc::run.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="IPC::Run::Timer (3pm) manual">
  <meta name="twitter:description" content="Timer channels for ipc::run.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libipc-run-perl-IPC::Run::Timer-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/IPC::Run::Timer.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="IPC::Run::Timer (3pm) manual" />
  <meta property="og:description" content="Timer channels for ipc::run." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libipc-run-perl-IPC::Run::Timer-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">IPC::Run::Timer<small> (3pm)</small></h1>
        <p class="lead">Timer channels for ipc::run.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IPC::Run::Timer.3pm.html">
      <span itemprop="name">IPC::Run::Timer: Timer channels for ipc::run.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libipc-run-perl/">
      <span itemprop="name">libipc-run-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IPC::Run::Timer.3pm.html">
      <span itemprop="name">IPC::Run::Timer: Timer channels for ipc::run.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
   use IPC::Run qw( run  timer timeout );
   ## or IPC::Run::Timer ( timer timeout );
   ## or IPC::Run::Timer ( :all );

   ## A non-fatal timer:
   $t = timer( 5 ); # or...
   $t = IO::Run::Timer-&gt;new( 5 );
   run $t, ...;

   ## A timeout (which is a timer that dies on expiry):
   $t = timeout( 5 ); # or...
   $t = IO::Run::Timer-&gt;new( 5, exception =&gt; "harness timed out" );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This class and module allows timers and timeouts to be created for use by IPC::Run.  A timer simply expires when it's time is up.  A timeout is a timer that throws an exception when it expires.</p><p>Timeouts are usually a bit simpler to use  than timers: they throw an exception on expiration so you don't need to check them:</p><p>   ## Give @cmd 10 seconds to get started, then 5 seconds to respond    my $t = timeout( 10 );    $h = start(       &#92;@cmd, &#92;$in, &#92;$out,       $t,    );    pump $h until $out =~ /prompt/;</p><p>   $in = "some stimulus";    $out = &apos;&apos;;    $t-&gt;time( 5 )    pump $h until $out =~ /expected response/;</p><p>You do need to check timers:</p><p>   ## Give @cmd 10 seconds to get started, then 5 seconds to respond    my $t = timer( 10 );    $h = start(       &#92;@cmd, &#92;$in, &#92;$out,       $t,    );    pump $h until $t-&gt;is_expired || $out =~ /prompt/;</p><p>   $in = "some stimulus";    $out = &apos;&apos;;    $t-&gt;time( 5 )    pump $h until $out =~ /expected response/ || $t-&gt;is_expired;</p><p>Timers and timeouts that are reset get started by <em>start()</em> and <em>pump()</em>.  Timers change state only in <em>pump()</em>.  Since <em>run()</em> and <em>finish()</em> both call <em>pump()</em>, they act like <em>pump()</em> with repect to timers.</p><p>Timers and timeouts have three states: reset, running, and expired. Setting the timeout value resets the timer, as does calling the <em>reset()</em> method.  The <em>start()</em> method starts (or restarts) a timer with the most recently set time value, no matter what state it's in.</p><h3>Time values</h3>
<p>All time values are in seconds.  Times may be specified as integer or floating point seconds, optionally preceded by puncuation-separated days, hours, and minutes.&#92;</p><p>Examples:</p><p>   1           1 second    1.1         1.1 seconds    60          60 seconds    1:0         1 minute    1:1         1 minute, 1 second    1:90        2 minutes, 30 seconds    1:2:3:4.5   1 day, 2 hours, 3 minutes, 4.5 seconds</p><p>Absolute date/time strings are *not* accepted: year, month and day-of-month parsing is not available (patches welcome :-).</p>
<h3>Interval fudging</h3>
<p>When calculating an end time from a start time and an interval, IPC::Run::Timer instances add a little fudge factor.  This is to ensure that no time will expire before the interval is up.</p><p>First a little background.  Time is sampled in discrete increments.  We'll call the exact moment that the reported time increments from one interval to the next a tick, and the interval between ticks as the time period.  Here's a diagram of three ticks and the periods between them:</p><p>    -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...     ^                   ^                   ^     |&lt;--- period 0 ----&gt;|&lt;--- period 1 ----&gt;|     |                   |                   |   tick 0              tick 1              tick 2</p><p>To see why the fudge factor is necessary, consider what would happen when a timer with an interval of 1 second is started right at the end of period 0:</p><p>    -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...     ^                ^  ^                   ^     |                |  |                   |     |                |  |                   |   tick 0             |tick 1              tick 2                      |                  start $t</p><p>Assuming that <em>check()</em> is called many times per period, then the timer is likely to expire just after tick 1, since the time reported will have lept from the value '0' to the value '1':</p><p>    -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...     ^                ^  ^   ^               ^     |                |  |   |               |     |                |  |   |               |   tick 0             |tick 1|             tick 2                      |      |                  start $t   |                             |                         check $t</p><p>Adding a fudge of '1' in this example means that the timer is guaranteed not to expire before tick 2.</p><p>The fudge is not added to an interval of '0'.</p><p>This means that intervals guarantee a minimum interval.  Given that the process running perl may be suspended for some period of time, or that it gets busy doing something time-consuming, there are no other guarantees on how long it will take a timer to expire.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING</h2>
        <div class="sectioncontent">
<p>\s-1INCOMPATIBLE\s0 \s-1CHANGE:\s0 Due to the awkwardness introduced by ripping pseudohashes out of Perl, this class <em>no longer</em> uses the fields pragma.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS & METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    timer
  </dt>
  <dd>
    <p>A constructor function (not method) of IPC::Run::Timer instances:    $t = timer( 5 );    $t = timer( 5, name =&gt; &apos;stall timer&apos;, debug =&gt; 1 );</p><p>   $t = timer;    $t-&gt;interval( 5 );</p><p>   run ..., $t;    run ..., $t = timer( 5 ); This convenience function is a shortened spelling of    IPC::Run::Timer-&gt;new( ... ); .  It returns a timer in the reset state with a given interval. If an exception is provided, it will be thrown when the timer notices that it has expired (in <em>check()</em>).  The name is for debugging usage, if you plan on having multiple timers around.  If no name is provided, a name like \*(L"timer #1\*(R" will be provided.</p>
  </dd>
  <dt>
    timeout
  </dt>
  <dd>
    <p>A constructor function (not method) of IPC::Run::Timer instances:    $t = timeout( 5 );    $t = timeout( 5, exception =&gt; "kablooey" );    $t = timeout( 5, name =&gt; "stall", exception =&gt; "kablooey" );</p><p>   $t = timeout;    $t-&gt;interval( 5 );</p><p>   run ..., $t;    run ..., $t = timeout( 5 ); A This convenience function is a shortened spelling of    IPC::Run::Timer-&gt;new( exception =&gt; "IPC::Run: timeout ...", ... ); .  It returns a timer in the reset state that will throw an exception when it expires. Takes the same parameters as \*(L"timer\*(R", any exception passed in overrides the default exception.</p>
  </dd>
  <dt>
    new
  </dt>
  <dd>
    <p>   IPC::Run::Timer-&gt;new()  ;    IPC::Run::Timer-&gt;new( 5 )  ;    IPC::Run::Timer-&gt;new( 5, exception =&gt; &apos;kablooey&apos; )  ; Constructor.  See \*(L"timer\*(R" for details.</p>
  </dd>
  <dt>
    check
  </dt>
  <dd>
    <p>   check $t;    check $t, $now;    $t-&gt;check; Checks to see if a timer has expired since the last check.  Has no effect on non-running timers.  This will throw an exception if one is defined. <em>IPC::Run::pump()</em> calls this routine for any timers in the harness. You may pass in a version of now, which is useful in case you have it lying around or you want to check several timers with a consistent concept of the current time. Returns the time left before end_time or 0 if end_time is no longer in the future or the timer is not running (unless, of course, <em>check()</em> <em>expire()</em>s the timer and this results in an exception being thrown). Returns undef if the timer is not running on entry, 0 if <em>check()</em> expires it, and the time left if it's left running.</p>
  </dd>
  <dt>
    debug
  </dt>
  <dd>
    <p>Sets/gets the current setting of the debugging flag for this timer.  This has no effect if debugging is not enabled for the current harness.</p>
  </dd>
  <dt>
    end_time
  </dt>
  <dd>
    <p>   $et = $t-&gt;end_time;    $et = end_time $t;</p><p>   $t-&gt;end_time( time + 10 ); Returns the time when this timer will or did expire.  Even if this time is in the past, the timer may not be expired, since <em>check()</em> may not have been called yet. Note that this end_time is not start_time($t) + interval($t), since some small extra amount of time is added to make sure that the timer does not expire before <em>interval()</em> elapses.  If this were not so, then Changing <em>end_time()</em> while a timer is running will set the expiration time. Changing it while it is expired has no affect, since <em>reset()</em>ing a timer always clears the <em>end_time()</em>.</p>
  </dd>
  <dt>
    exception
  </dt>
  <dd>
    <p>   $x = $t-&gt;exception;    $t-&gt;exception( $x );    $t-&gt;exception( undef ); Sets/gets the exception to throw, if any.  'undef' means that no exception will be thrown.  Exception does not need to be a scalar: you may ask that references be thrown.</p>
  </dd>
  <dt>
    interval
  </dt>
  <dd>
    <p>   $i = interval $t;    $i = $t-&gt;interval;    $t-&gt;interval( $i ); Sets the interval.  Sets the end time based on the <em>start_time()</em> and the interval (and a little fudge) if the timer is running.</p>
  </dd>
  <dt>
    expire
  </dt>
  <dd>
    <p>   expire $t;    $t-&gt;expire; Sets the state to expired (undef). Will throw an exception if one is defined and the timer was not already expired.  You can expire a reset timer without starting it.</p>
  </dd>
  <dt>
    is_running
  </dt>
  <dd>
    
  </dd>
  <dt>
    is_reset
  </dt>
  <dd>
    
  </dd>
  <dt>
    is_expired
  </dt>
  <dd>
    
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>Sets/gets this timer's name.  The name is only used for debugging purposes so you can tell which freakin' timer is doing what.</p>
  </dd>
  <dt>
    reset
  </dt>
  <dd>
    <p>   reset $t;    $t-&gt;reset; Resets the timer to the non-running, non-expired state and clears the <em>end_time()</em>.</p>
  </dd>
  <dt>
    start
  </dt>
  <dd>
    <p>   start $t;    $t-&gt;start;    start $t, $interval;    start $t, $interval, $now; Starts or restarts a timer.  This always sets the start_time.  It sets the end_time based on the interval if the timer is running or if no end time has been set. You may pass an optional interval or current time value. Not passing a defined interval causes the previous interval setting to be re-used unless the timer is reset and an end_time has been set (an exception is thrown if no interval has been set). Not passing a defined current time value causes the current time to be used. Passing a current time value is useful if you happen to have a time value lying around or if you want to make sure that several timers are started with the same concept of start time.  You might even need to lie to an IPC::Run::Timer, occasionally.</p>
  </dd>
  <dt>
    start_time
  </dt>
  <dd>
    <p>Sets/gets the start time, in seconds since the epoch.  Setting this manually is a bad idea, it's better to call \*(L"start\*(R"() at the correct time.</p>
  </dd>
  <dt>
    state
  </dt>
  <dd>
    <p>   $s = state $t;    $t-&gt;state( $s ); Get/Set the current state.  Only use this if you really need to transfer the state to/from some variable. Use \*(L"expire\*(R", \*(L"start\*(R", \*(L"reset\*(R", \*(L"is_expired\*(R", \*(L"is_running\*(R", \*(L"is_reset\*(R". Note:  Setting the state to 'undef' to expire a timer will not throw an exception.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>use Time::HiRes; if it's present.</p><p>Add detection and parsing of [[[\s-1HH:\s0]MM:]SS formatted times and intervals.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Barrie Slaymaker &lt;barries@slaysys.com&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="IPC::Run::IO.3pm.html"><span aria-hidden="true">&larr;</span> IPC::Run::IO.3pm: I/o channels for ipc::run.</a></li>
   <li class="next"><a href="IPC::Shareable.3pm.html">IPC::Shareable.3pm: Share perl variables between processes <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

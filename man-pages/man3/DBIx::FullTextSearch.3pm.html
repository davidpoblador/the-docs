<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DBIx::FullTextSearch: Indexing documents with mysql as storage</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Indexing documents with mysql as storage">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="DBIx::FullTextSearch (3pm) manual">
  <meta name="twitter:description" content="Indexing documents with mysql as storage">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdbix-fulltextsearch-perl-DBIx::FullTextSearch-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/DBIx::FullTextSearch.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="DBIx::FullTextSearch (3pm) manual" />
  <meta property="og:description" content="Indexing documents with mysql as storage" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdbix-fulltextsearch-perl-DBIx::FullTextSearch-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">DBIx::FullTextSearch<small> (3pm)</small></h1>
        <p class="lead">Indexing documents with mysql as storage</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::FullTextSearch.3pm.html">
      <span itemprop="name">DBIx::FullTextSearch: Indexing documents with mysql as storage</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdbix-fulltextsearch-perl/">
      <span itemprop="name">libdbix-fulltextsearch-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::FullTextSearch.3pm.html">
      <span itemprop="name">DBIx::FullTextSearch: Indexing documents with mysql as storage</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>DBIx::FullTextSearch uses a MySQL database backend to index files, web documents and database fields.  Supports must include, can include, and cannot include words and phrases.  Support for boolean (\s-1AND/OR\s0) queries, stop words and stemming.</p>
<pre>
    use DBIx::FullTextSearch;
    use DBI;
    # connect to database (regular DBI)
    my $dbh = DBI-&gt;connect(&apos;dbi:mysql:database&apos;, &apos;user&apos;, &apos;passwd&apos;);
</pre>
<p>    # create a new stoplist     my $sl = DBIx::FullTextSearch::StopList-&gt;create_default($dbh, &apos;sl_en&apos;, &apos;English&apos;);</p><p>    # create a new index with default english stoplist and english stemmer     my $fts = DBIx::FullTextSearch-&gt;create($dbh, &apos;fts_web_1&apos;,                 frontend =&gt; &apos;string&apos;, backend =&gt; &apos;blob&apos;,                 stoplist =&gt; &apos;sl_en&apos;, stemmer =&gt; &apos;en-us&apos;);     # or open existing one     # my $fts = DBIx::FullTextSearch-&gt;open($dbh, &apos;fts_web_1&apos;);</p><p>    # index documents     $fts-&gt;index_document(&apos;krtek&apos;, &apos;krtek leze pod zemi&apos;);     $fts-&gt;index_document(&apos;jezek&apos;, &apos;Jezek ma ostre bodliny.&apos;);</p><p>    # search for matches     my @docs = $fts-&gt;contains(&apos;foo&apos;);     my @docs = $fts-&gt;econtains(&apos;+foo&apos;, &apos;-Bar&apos;);     my @docs = $fts-&gt;search(&apos;+foo -Bar&apos;);     my @docs = $fts-&gt;search(&apos;foo AND (bar OR baz)&apos;);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>DBIx::FullTextSearch is a flexible solution for indexing contents of documents. It uses the MySQL database to store the information about words and documents and provides Perl interface for indexing new documents, making changes and searching for matches.  For DBIx::FullTextSearch, a document is nearly anything \*(-- Perl scalar, file, Web document, database field.</p><p>The basic style of interface is shown above. What you need is a MySQL database and a \s-1DBI\s0 with DBD::mysql. Then you create a DBIx::FullTextSearch index \*(-- a set of tables that maintain all necessary information. Once created it can be accessed many times, either for updating the index (adding documents) or searching.</p><p>DBIx::FullTextSearch uses one basic table to store parameters of the index. Second table is used to store the actual information about documents and words, and depending on the type of the index (specified during index creation) there may be more tables to store additional information (like conversion from external string names (eg. \s-1URL\s0's) to internal numeric form). For a user, these internal thingies and internal behaviour of the index are not important. The important part is the \s-1API\s0, the methods to index document and ask questions about words in documents. However, certain understanding of how it all works may be usefull when you are deciding if this module is for you and what type of index will best suit your needs.</p><p><strong>&#92;$1</strong></p><p>From the user, application point of view, the DBIx::FullTextSearch index stores documents that are named in a certain way, allows adding new documents, and provides methods to ask: \*(L"give me list of names of documents that contain this list of words\*(R". The DBIx::FullTextSearch index doesn't store the documents itself. Instead, it stores information about words in the documents in such a structured way that it makes easy and fast to look up what documents contain certain words and return names of the documents.</p><p>DBIx::FullTextSearch provides a couple of predefined frontend classes that specify various types of documents (and the way they relate to their names).</p>
<dl class='dl-vertical'>
  <dt>
    default
  </dt>
  <dd>
    <p>By default, user specifies the integer number of the document and the content (body) of the document. The code would for example read         $fts-&gt;index_document(53, &apos;zastavujeme vyplaty vkladu&apos;); and DBIx::FullTextSearch will remember that the document 53 contains three words. When looking for all documents containing word (string) vklad, a call         my @docs = $fts-&gt;contains(&apos;vklad*&apos;); would return numbers of all documents containing words starting with 'vklad', 53 among them. So here it's user's responsibility to maintain a relation between the document numbers and their content, to know that a document 53 is about vklady. Perhaps the documents are already stored somewhere and have unique numeric id. Note that the numeric id must be no larger than 2^\*(C`doc_id_bits\*(C'.</p>
  </dd>
  <dt>
    string
  </dt>
  <dd>
    <p>Frontend <strong>string</strong> allows the user to specify the names of the documents as strings, instead of numbers. Still the user has to specify both the name of the document and the content:         $fts-&gt;index_document(&apos;foobar&apos;,                         &apos;the quick brown fox jumped over lazy dog!&apos;); After that,         $fts-&gt;contains(&apos;dog&apos;) will return 'foobar' as one of the names of documents with word 'dog' in it.</p>
  </dd>
  <dt>
    file
  </dt>
  <dd>
    <p>To index files, use the frontend <strong>file</strong>. Here the content of the document is clearly the content of the file specified by the filename, so in a call to index_document, only the name is needed \*(-- the content of the file is read by the DBIx::FullTextSearch transparently:         $fts-&gt;index_document(&apos;/usr/doc/FAQ/Linux-FAQ&apos;);         my @files = $fts-&gt;contains(&apos;penguin&apos;);</p>
  </dd>
  <dt>
    url
  </dt>
  <dd>
    <p>Web document can be indexed by the frontend <strong>url</strong>. DBIx::FullTextSearch uses \s-1LWP\s0 to get the document and then parses it normally:         $fts-&gt;index_document(&apos;http://www.perl.com/&apos;); Note that the \s-1HTML\s0 tags themselves are indexed along with the text.</p>
  </dd>
  <dt>
    table
  </dt>
  <dd>
    <p>You can have a DBIx::FullTextSearch index that indexes char or blob fields in MySQL table. Since MySQL doesn't support triggers, you have to call the \*(C`index_document\*(C' method of DBIx::FullTextSearch any time something changes in the table. So the sequence probably will be         $dbh-&gt;do(&apos;insert into the_table (id, data, other_fields)                 values (?, ?, ?)&apos;, {}, $name, $data, $date_or_something);         $fts-&gt;index_document($name); When calling \*(C`contains\*(C', the id (name) of the record will be returned. If the id in the_table is numeric, it's directly used as the internal numeric id, otherwise a string's way of converting the id to numeric form is used. When creating this index, you'll have to pass it three additionial options, \*(C`table_name\*(C', \*(C`column_name\*(C', and \*(C`column_id_name\*(C'.  You may use the optional column_process option to pre-process data in the specified columns.</p>
  </dd>

</dl>
<p>The structure of DBIx::FullTextSearch is very flexible and adding new frontend (what will be indexed) is very easy. While frontend specifies what is indexed and how the user sees the collection of documents, backend is about low level database way of actually storing the information in the tables. Three types are available:</p>
<dl class='dl-vertical'>
  <dt>
    blob
  </dt>
  <dd>
    <p>For each word, a blob holding list of all documents containing that word is stored in the table, with the count (number of occurencies) associated with each document number. That makes it for very compact storage. Since the document names (for example \s-1URL\s0) are internally converted to numbers, storing and fetching the data is fast. However, updating the information is very slow, since information concerning one document is spread across all table, without any direct database access. Updating a document (or merely reindexing it) requires update of all blobs, which is slow. The list of documents is stored sorted by document name so that fetching an information about a document for one word is relatively easy, still a need to update (or at least scan) all records in the table makes this storage unsuitable for collections of documents that often change.</p>
  </dd>
  <dt>
    column
  </dt>
  <dd>
    <p>The <strong>column</strong> backend stores a word/document pair in database fields, indexing both, thus allowing both fast retrieval and updates \*(-- it's easy to delete all records describing one document and insert new ones. However, the database indexes that have to be maintained are large. Both <strong>blob</strong> and <strong>column</strong> backends only store a count \*(-- number of occurencies of the word in the document (and even this can be switched off, yielding just a yes/no information about the word's presence). This allows questions like         all documents containing words &apos;voda&apos; or &apos;Mattoni&apos;                 but not a word &apos;kyselka&apos; but you cannot ask whether a document contains a phrase 'kyselka Mattoni' because such information is not maintained by these types of backends.</p>
  </dd>
  <dt>
    phrase
  </dt>
  <dd>
    <p>To allow phrase matching, a <strong>phrase</strong> backend is available. For each word and document number it stores a blob of lists of positions of the word in the document. A query         $fts-&gt;contains(&apos;kyselk* Mattoni&apos;); then only returns those documents (document names/numbers) where word kyselka (or kyselky, or so) is just before word Mattoni. Any frontend can be used with any backend in one DBIx::FullTextSearch index. You can index Web documents with \*(C`url\*(C' frontend and \*(C`phrase\*(C' backend to be able to find phrases in the documents. And you can use the default, number based document scheme with \*(C`blob\*(C' backend to use the disk space as efficiently as possible \*(-- this is usefull for example for mailing-list archives, where we need to index huge number of documents that do not change at all.</p>
  </dd>

</dl>
<p>Finding optimal combination is very important and may require some analysis of the document collection and manipulation, as well as the speed and storage requirements. Benchmarking on actual target platform is very useful during the design phase.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>The following methods are available on the user side as DBIx::FullTextSearch \s-1API\s0.</p>
<dl class='dl-vertical'>
  <dt>
    create
  </dt>
  <dd>
    <p>        my $fts = DBIx::FullTextSearch-&gt;create($dbh, $index_name, %opts); The class method \*(C`create\*(C' creates index of given name (the name of the index is the name of its basic parameter table) and all necessary tables, returns an object \*(-- newly created index. The options that may be specified after the index name define the frontend and backend types, storage parameters (how many bits for what values), etc. See below for list of create options and discussion of their use.</p>
  </dd>
  <dt>
    open
  </dt>
  <dd>
    <p>        my $fts = DBIx::FullTextSearch-&gt;open($dbh, $index_name); Opens and returns object, accessing specifies DBIx::FullTextSearch index. Since all the index parameters and information are stored in the $index_name table (including names of all other needed tables), the database handler and the name of the parameter table are the only needed arguments.</p>
  </dd>
  <dt>
    index_document
  </dt>
  <dd>
    <p>        $fts-&gt;index_document(45, &apos;Sleva pri nakupu stribra.&apos;);         $fts-&gt;index_document(&apos;http://www.mozilla.org/&apos;);         $fts-&gt;index_document(&apos;http://www.mozilla.org/&apos;,&apos;This is the mozilla web site&apos;); For the \*(C`default\*(C' and \*(C`string\*(C' frontends, two arguments are expected \*(-- the name (number or string) of the document and its content. For \*(C`file\*(C', \*(C`url\*(C', and \*(C`table\*(C' frontends the content is optional.  Any content that you pass will be appended to the content from the file, \s-1URL\s0, or database table.</p>
  </dd>
  <dt>
    delete_document
  </dt>
  <dd>
    <p>        $fts-&gt;delete_document(&apos;http://www.mozilla.org/&apos;); Removes information about document from the index. Note that for \*(C`blob\*(C' backend this is very time consuming process.</p>
  </dd>
  <dt>
    contains
  </dt>
  <dd>
    <p>        my @docs = $fts-&gt;contains(&apos;sleva&apos;, &apos;strib*&apos;); Returns list of names (numbers or strings, depending on the frontend) of documents that contain some of specified words.</p>
  </dd>
  <dt>
    econtains
  </dt>
  <dd>
    <p>        my @docs = $fts-&gt;contains(&apos;foo&apos;, &apos;+bar*&apos;, &apos;-koo&apos;); Econtains stands for extended contains and allows words to be prefixed by plus or minus signs to specify that the word must or mustn't be present in the document for it to match.</p>
  </dd>
  <dt>
    search
  </dt>
  <dd>
    <p> my @docs = $fts-&gt;search(qq{+"this is a phrase" -koo +bar foo});  my @docs = $fts-&gt;search("(foo OR baz) AND (bar OR caz)"); This is a wrapper to econtains which takes a user input string and parses it into can-include, must-include, and must-not-include words and phrases. It also can handle boolean (\s-1AND/OR\s0) queries.</p>
  </dd>
  <dt>
    contains_hashref, econtains_hashref, search_hashref
  </dt>
  <dd>
    <p>Similar to \*(C`contains\*(C', \*(C`econtains\*(C' and \*(C`search\*(C', only instead of list of document names, these methods return a hash reference to a hash where keys are the document names and values are the number of occurencies of the words.</p>
  </dd>
  <dt>
    drop
  </dt>
  <dd>
    <p>Removes all tables associated with the index, including the base parameter table. Effectivelly destroying the index form the database.  $fts-&gt;drop;</p>
  </dd>
  <dt>
    empty
  </dt>
  <dd>
    <p>Emptys the index so you can reindex the data.  $fts-&gt;empty;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INDEX OPTIONS</h2>
        <div class="sectioncontent">
<p>Here we list the options that may be passed to \*(C`create\*(C' method. These allow to specify the style and storage parameters in great detail.</p>
<dl class='dl-vertical'>
  <dt>
    backend
  </dt>
  <dd>
    <p>The backend type, default \*(C`blob\*(C', possible values \*(C`blob\*(C', \*(C`column\*(C' and \*(C`phrase\*(C' (see above for explanation).</p>
  </dd>
  <dt>
    frontend
  </dt>
  <dd>
    <p>The frontend type. The \*(C`default\*(C' frontend requires the user to specify numeric id of the document together with the content of the document, other possible values are \*(C`string\*(C', \*(C`file\*(C' and \*(C`url\*(C' (see above for more info).</p>
  </dd>
  <dt>
    word_length
  </dt>
  <dd>
    <p>Maximum length of words that may be indexed, default 30.</p>
  </dd>
  <dt>
    data_table
  </dt>
  <dd>
    <p>Name of the table where the actual data about word/document relation is stored. By default, the name of the index (of the base table) with _data suffix is used.</p>
  </dd>
  <dt>
    name_length
  </dt>
  <dd>
    <p>Any frontend that uses strings as names of documents needs to maintain a conversion table from these names to internal integer ids. This value specifies maximum length of these string names (URLs, file names, ...).</p>
  </dd>
  <dt>
    blob_direct_fetch
  </dt>
  <dd>
    <p>Only for \*(C`blob\*(C' backend. When looking for information about specific document in the list stored in the blob, the blob backend uses division of interval to find the correct place in the blob. When the interval gets equal or shorter that this value, all values are fetched from the database and the final search is done in Perl code sequentially.</p>
  </dd>
  <dt>
    word_id_bits
  </dt>
  <dd>
    <p>With \*(C`column\*(C' or \*(C`phase\*(C' backends, DBIx::FullTextSearch maintains a numeric id for each word to optimize the space requirements. The word_id_bits parameter specifies the number of bits to reserve for this conversion and thus effectively limits number of distinct words that may be indexed. The default is 16 bits and possible values are 8, 16, 24 or 32 bits.</p>
  </dd>
  <dt>
    word_id_table
  </dt>
  <dd>
    <p>Name of the table that holds conversion from words to their numeric id (for \*(C`column\*(C' and \*(C`phrase\*(C' backends). By default is the name of the index with _words suffix.</p>
  </dd>
  <dt>
    doc_id_bits
  </dt>
  <dd>
    <p>A number of bits to hold a numeric id of the document (that is either provided by the user (with \*(C`default\*(C' frontend) or generated by the module to accomplish the conversion from the string name of the document). This value limits the maximum number of documents to hold. The default is 16 bits and possible values are 8, 16 and 32 bits for \*(C`blob\*(C' backend and 8, 16, 24 and 32 bits for \*(C`column\*(C' and \*(C`phrase\*(C' backends.</p>
  </dd>
  <dt>
    doc_id_table
  </dt>
  <dd>
    <p>Name of the table that holds conversion from string names of documents to their numeric id, by default the name of the index with _docid suffix.</p>
  </dd>
  <dt>
    count_bits
  </dt>
  <dd>
    <p>Number of bits reserved for storing number of occurencies of each word in the document. The default is 8 and possible values are the same as with doc_id_bits.</p>
  </dd>
  <dt>
    position_bits
  </dt>
  <dd>
    <p>With \*(C`phrase backend\*(C', DBIx::FullTextSearch stores positions of each word of the documents. This value specifies how much space should be reserved for this purpose. The default is 32 bits and possible values are 8, 16 or 32 bits. This value limits the maximum number of words of each document that can be stored.</p>
  </dd>
  <dt>
    index_splitter
  </dt>
  <dd>
    <p>DBIx::FullTextSearch allows the user to provide any Perl code that will be used to split the content of the document to words when indexing documents. The code will be evalled inside of the DBIx::FullTextSearch code. The default is         /(&#92;w{2,$word_length})/g and shows that the input is stored in the variable $data and the code may access any other variable available in the perl_and_index_data_* methods (see source), especially $word_length to get the maximum length of words and $backend to get the backend object. The default value also shows that by default, the minimum length of words indexed is 2.</p>
  </dd>
  <dt>
    search_splitter
  </dt>
  <dd>
    <p>This is similar to the \*(C`index_splitter\*(C' method, except that it is used in the \*(C`contains_hashref\*(C' method when searching for documents instead of when indexing documents.  The default is        /(&#92;w{2,$word_length}&#92;*?)/g Which, unlike the default \*(C`index_splitter\*(C', allows for the wild card character (*).</p>
  </dd>
  <dt>
    filter
  </dt>
  <dd>
    <p>The output words of splitter (and also any parameter of (e)contains* methods) are send to filter that may do further processing. Filter is again a Perl code, the default is         map { lc $_ } showing that the filter operates on input list and by default does conversion to lowercase (yielding case insensitive index).</p>
  </dd>
  <dt>
    init_env
  </dt>
  <dd>
    <p>Because user defined splitter or filter may depend on other things that it is reasonable to set before the actual procession of words, you can use yet another Perl hook to set things up. The default is no initialization hook.</p>
  </dd>
  <dt>
    stoplist
  </dt>
  <dd>
    <p>This is the name of a DBIx::FullTextSearch::StopList object that is used for stop words.</p>
  </dd>
  <dt>
    stemmer
  </dt>
  <dd>
    <p>If this option is set, then word stemming will be enabled in the indexing and searching. The value is the name of a Lingua::Stem recognized locale. Currently, 'en', 'en-us' and 'en-uk' are the only recognized locales. All locale identifiers are converted to lowercase.</p>
  </dd>
  <dt>
    table_name
  </dt>
  <dd>
    <p>For \*(C`table\*(C' frontend; this is the name of the table that will be indexed.</p>
  </dd>
  <dt>
    column_name
  </dt>
  <dd>
    <p>For \*(C`table\*(C' frontend; this is a reference to an array of columns in the \*(C`table_name\*(C' that contains the documents \*(-- data to be indexed. It can also have a form table.column that will be used if the \*(C`table_name\*(C' option is not specified.</p>
  </dd>
  <dt>
    column_id_name
  </dt>
  <dd>
    <p>For \*(C`table\*(C' frontend; this is the name of the field in \*(C`table_name\*(C' that holds names (ids) of the records. If not specified, a field that has primary key on it is used. If this field is numeric, it's values are directly used as identifiers, otherwise a conversion to numeric values is made.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>To handle internationalization, it may help to use the following in your code (for example Spanish in Chile):</p><p>  use POSIX;   my $loc = POSIX::setlocale( &POSIX::LC_ALL, "es_CL" );</p><p>I haven't tested this, so I would be interested in hearing whether this works.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERROR HANDLING</h2>
        <div class="sectioncontent">
<p>The create and open methods return the DBIx::FullTextSearch object on success, upon failure they return undef and set error message in $DBIx::FullTextSearch::errstr variable.</p><p>All other methods return reasonable (documented above) value on success, failure is signalized by unreasonable (typically undef or null) return value; the error message may then be retrieved by \*(C`$fts-&gt;errstr\*(C' method call.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This documentation describes DBIx::FullTextSearch module version 0.73.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Error handling needs more polishing.</p><p>We do not check if the stored values are larger that specified by the *_bits parameters.</p><p>No \s-1CGI\s0 administration tool at the moment.</p><p>No scoring algorithm implemented.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEVELOPMENT</h2>
        <div class="sectioncontent">
<p>These modules are under active development. If you would like to contribute, please e-mail tjmather@maxmind.com</p><p>There are two mailing lists for this module, one for users, and another for developers.  To subscribe, visit http://sourceforge.net/mail/?group_id=8645</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>(Original) Jan Pazdziora, adelton@fi.muni.cz, http://www.fi.muni.cz/~adelton/ at Faculty of Informatics, Masaryk University in Brno, Czech Republic</p><p>(Current Maintainer) T.J. Mather, tjmather@maxmind.com, http://www.maxmind.com/app/opensourceservices Princeton, \s-1NJ\s0 \s-1USA\s0</p><p>Paid support is available from directly from the maintainers of this package. Please see &lt;http://www.maxmind.com/app/opensourceservices&gt; for more details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREDITS</h2>
        <div class="sectioncontent">
<p>Fixes, Bug Reports, Docs have been generously provided by:</p><p>  Vladimir Bogdanov   Ade Olonoh   Kate Pugh   Sven Paulus   Andrew Turner   Tom Bille   Joern Reder   Tarik Alkasab   Dan Collis Puro   Tony Bowden   Mario Minati   Miroslav Suchý   Stephen Patterson   Joern Reder   Hans Poo</p><p>Of course, big thanks to Jan Pazdziora, the original author of this module.  Especially for providing a clean, modular code base!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>All rights reserved. This package is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO DBIx::FullTextSearch&hellip;</h2>
        <div class="sectioncontent">
<p>DBIx::FullTextSearch::StopWord, Class::DBI::mysql::FullTextSearch</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER PRODUCTS and why I've written this module</h2>
        <div class="sectioncontent">
<p>I'm aware of DBIx::TextIndex and DBIx::KwIndex modules and about UdmSearch utility, and about htdig and glimpse on the non-database side of the world.</p><p>To me, using a database gives reasonable maintenance benefits. With products that use their own files to store the information (even if the storage algorithms are efficient and well thought of), you always struggle with permissions on files and directories for various users, with files that somebody accidently deleted or mungled, and making the index available remotely is not trivial.</p><p>That's why I've wanted a module that will use a database as a storage backend. With MySQL, you get remote access and access control for free, and on many web servers MySQL is part of the standard equipment. So using it for text indexes seemed natural.</p><p>However, existing DBIx::TextIndex and UdmSearch are too narrow-aimed to me. The first only supports indexing of data that is stored in the database, but you may not always want or need to store the documents in the database as well. The UdmSearch on the other hand is only for web documents, making it unsuitable for indexing mailing-list archives or local data.</p><p>I believe that DBIx::FullTextSearch is reasonably flexible and still very efficient. It doesn't enforce its own idea of what is good for you \*(-- the number of options is big and you can always extend the module with your own backend of frontend if you feel that those provided are not sufficient. Or you can extend existing by adding one or two parameters that will add new features. Of course, patches are always welcome. DBIx::FullTextSearch is a tool that can be deployed in many projects. It's not a complete environment since different people have different needs. On the other hand, the methods that it provides make it easy to build a complete solution on top of this in very short course of time.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="DBIx::Easy.3pm.html"><span aria-hidden="true">&larr;</span> DBIx::Easy.3pm: Easy to use dbi interface</a></li>
   <li class="next"><a href="DBIx::FullTextSearch::StopList.3pm.html">DBIx::FullTextSearch::StopList.3pm: Stopwords for dbix::fulltextsearch <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

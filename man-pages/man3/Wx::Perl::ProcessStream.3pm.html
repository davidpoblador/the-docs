<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wx::Perl::ProcessStream: Access io of external processes via events</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Access io of external processes via events">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Wx::Perl::ProcessStream (3pm) manual">
  <meta name="twitter:description" content="Access io of external processes via events">
  <meta name="twitter:image" content="https://www.carta.tech/images/libwx-perl-processstream-perl-Wx::Perl::ProcessStream-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Wx::Perl::ProcessStream.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Wx::Perl::ProcessStream (3pm) manual" />
  <meta property="og:description" content="Access io of external processes via events" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libwx-perl-processstream-perl-Wx::Perl::ProcessStream-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Wx::Perl::ProcessStream<small> (3pm)</small></h1>
        <p class="lead">Access io of external processes via events</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Wx::Perl::ProcessStream.3pm.html">
      <span itemprop="name">Wx::Perl::ProcessStream: Access io of external processes via events</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libwx-perl-processstream-perl/">
      <span itemprop="name">libwx-perl-processstream-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Wx::Perl::ProcessStream.3pm.html">
      <span itemprop="name">Wx::Perl::ProcessStream: Access io of external processes via events</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>Version 0.32</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSYS</h2>
        <div class="sectioncontent">

<pre>
    use Wx::Perl::ProcessStream qw( :everything );

    EVT_WXP_PROCESS_STREAM_STDOUT    ( $self, &#92;&evt_process_stdout );
    EVT_WXP_PROCESS_STREAM_STDERR    ( $self, &#92;&evt_process_stderr );
    EVT_WXP_PROCESS_STREAM_EXIT      ( $self, &#92;&evt_process_exit   );
    EVT_WXP_PROCESS_STREAM_MAXLINES  ( $self, &#92;&evt_process_maxlines  );

    my $proc1 = Wx::Perl::ProcessStream::Process-&gt;new(&apos;perl -e"print qq($_&#92;n) for(@INC);"&apos;, &apos;MyName1&apos;, $self);
    $proc1-&gt;Run;

    my $command = &apos;executable.exe parm1 parm2 parm3&apos;
    my $proc2 = Wx::Perl::ProcessStream::Process-&gt;new($command, &apos;MyName2&apos;, $self)
                                                -&gt;Run;

    my @args = qw( executable.exe parm1 parm2 parm3 );
    my $proc3 = Wx::Perl::ProcessStream::Process-&gt;new(&#92;@args, &apos;MyName2&apos;, $self);
    $proc3-&gt;Run;

    my $proc4 = Wx::Perl::ProcessStream::Process-&gt;new(&#92;@args, &apos;MyName2&apos;, $self, &apos;readline&apos;)-&gt;Run;

    my $proc5 = Wx::Perl::ProcessStream::Process-&gt;new(&#92;@args, &apos;MyName2&apos;, $self);

    sub evt_process_stdout {
        my ($self, $event) = @_;
        $event-&gt;<strong>Skip</strong>(1);
        my $process = $event-&gt;GetProcess;
        my $line = $event-&gt;GetLine;

        if($line eq &apos;something we are waiting for&apos;) {
            $process-&gt;WriteProcess(&apos;a message to stdin&apos;);

            $process-&gt;CloseInput() if($finishedwriting);
        }
        ............
        # To Clear Buffer
        my @buffers = @{ $process-&gt;GetStdOutBuffer };

    }

    sub evt_process_stderr {
        my ($self, $event) = @_;
        $event-&gt;<strong>Skip</strong>(1);
        my $process = $event-&gt;GetProcess;
        my $line = $event-&gt;GetLine;
        print STDERR qq($line&#92;n);
        # To Clear Buffer
        my @errors = @{ $process-&gt;GetStdErrBuffer };
    }

    sub evt_process_exit {
        my ($self, $event) = @_;
        $event-&gt;<strong>Skip</strong>(1);
        my $process = $event-&gt;GetProcess;
        my $line = $event-&gt;GetLine;
        my @buffers = @{ $process-&gt;GetStdOutBuffer };
        my @errors = @{ $process-&gt;GetStdErrBuffer };
        my $exitcode = $process-&gt;GetExitCode;
        ............
        $process-&gt;Destroy;
    }

    sub evt_process_maxlines {
        my ($self, $event) = @_;
        my $process = $event-&gt;GetProcess;

        ..... bad process

        $process-&gt;Kill;
    }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides the \s-1STDOUT\s0, \s-1STDERR\s0 and exit codes of asynchronously running processes via events. It may be used for long running or blocking processes that provide periodic updates on state via \s-1STDOUT\s0. Simple \s-1IPC\s0 is possible via \s-1STDIN\s0.</p><p>Do not use this module simply to collect the output of another process. For that, it is much simpler to do:</p><p>    my ($status, $output) = Wx::ExecuteStdout( &apos;perl -e"print qq($_&#92;n) for(@INC);"&apos; );</p><h3>Wx::Perl::ProcessStream::Process</h3>
<p><em>Methods</em></p>
<dl class='dl-vertical'>
  <dt>
    new
  </dt>
  <dd>
    <p>Create a new Wx::Perl::ProcessStream::Process object. You must then use the Run method to execute your command.     my $process = Wx::Perl::ProcessStream::Process-&gt;new($command, $name, $eventhandler, $readmethod);</p><p>    $command      = command text (and parameters) you wish to run. You may also pass a                     reference to an array containing the command and parameters.     $name         = an arbitray name for the process.     $eventhandler = the Wx EventHandler (Wx:Window) that will handle events for this process.     $readmethod   = &apos;read&apos; or &apos;readline&apos; (default = &apos;readline&apos;) an optional param. From Wx version                     0.75 you can specify the method you wish to use to read the output of an                     external process.                     The default depends on your Wx version ( &apos;getc&apos; &lt; 0.75,&apos;readline&apos; &gt;= 0.75)                     read       -- uses the Wx::InputStream-&gt;READ method to read bytes.                     readline   -- uses the Wx::InputStream-&gt;READLINE method to read bytes                     getc       -- alias for read (getc not actually used)</p>
  </dd>
  <dt>
    SetMaxLines
  </dt>
  <dd>
    <p>Set the maximum number of lines that will be read from a continuous stream before raising a \s-1EVT_WXP_PROCESS_STREAM_MAXLINES\s0 event. The default is 1000. A continuous stream will cause your application to hang.     $process-&gt;SetMaxLines(10);</p>
  </dd>
  <dt>
    Run
  </dt>
  <dd>
    <p>Run the process with the parameters passed to new. On success, returns the process object itself. This allows you to do: my $process = Wx::Perl::ProcessStream-&gt;new($command, $name, $self)-&gt;Run; Returns undef if the process could not be started.     my $process = Wx::Perl::ProcessStream::Process-&gt;new($command, $name, $eventhandler, $readmethod);     $process-&gt;Run;</p>
  </dd>
  <dt>
    CloseInput
  </dt>
  <dd>
    <p>Close the \s-1STDIN\s0 stream of the external process. (Some processes may not close until \s-1STDIN\s0 is closed.)     $process-&gt;CloseInput();</p>
  </dd>
  <dt>
    GetAppCloseAction
  </dt>
  <dd>
    <p>Returns the current process signal that will used on application exit. Either wxpSIGTERM or wxpSIGKILL. See SetAppCloseAction.     my $action = $process-&gt;GetAppCloseAction();</p>
  </dd>
  <dt>
    GetExitCode
  </dt>
  <dd>
    <p>Returns the process exit code. It is undefined until a wxpEVT_PROCESS_STREAM_EXIT event has been received.     my $exitcode = $process-&gt;GetExitCode();</p>
  </dd>
  <dt>
    GetProcessName
  </dt>
  <dd>
    <p>Returns the process name as passed to the OpenProcess constructor.     my $processname = $process-&gt;GetProcessName();</p>
  </dd>
  <dt>
    GetStdErrBuffer
  </dt>
  <dd>
    <p>This returns a reference to an array containing all the lines sent by the process to stderr. Calling this clears the process object internal stderr buffer. (This has no effect on the actual process I/O buffers.)     my $arryref = $process-&gt;GetStdErrBuffer();</p>
  </dd>
  <dt>
    GetStdOutBuffer
  </dt>
  <dd>
    <p>This returns a reference to an array containing all the lines sent by the process to stdout. Calling this clears the process object internal stdout buffer. (This has no effect on the actual process I/O buffers.)     my $arryref = $process-&gt;GetStdOutBuffer();</p>
  </dd>
  <dt>
    GetStdErrBufferLineCount
  </dt>
  <dd>
    <p>This returns the number of lines currently in the stderr buffer.     my $count = $process-&gt;GetStdErrBufferLineCount();</p>
  </dd>
  <dt>
    GetStdOutBufferLineCount
  </dt>
  <dd>
    <p>This returns the number of lines currently in the stdout buffer.     my $count = $process-&gt;GetStdOutBufferLineCount();</p>
  </dd>
  <dt>
    PeekStdErrBuffer
  </dt>
  <dd>
    <p>This returns a reference to an array containing all the lines sent by the process to stderr. To retrieve the buffer and clear it, call GetStdErrBuffer instead.     my $arryref = $process-&gt;PeekStdErrBuffer();</p>
  </dd>
  <dt>
    PeekStdOutBuffer
  </dt>
  <dd>
    <p>This returns a reference to an array containing all the lines sent by the process to stdout. To retrieve the buffer and clear it, call GetStdOutBuffer instead.     my $arryref = $process-&gt;PeekStdOutBuffer();</p>
  </dd>
  <dt>
    GetProcessId
  </dt>
  <dd>
    <p>Returns the process id assigned by the system.     my $processid = $process-&gt;GetProcessId();</p>
  </dd>
  <dt>
    GetPid
  </dt>
  <dd>
    <p>Returns the process id assigned by the system.     my $processid = $process-&gt;GetPid();</p>
  </dd>
  <dt>
    IsAlive
  </dt>
  <dd>
    <p>Check if the process still exists in the system. Returns 1 if process exists, 0 if process does not exist. If the process has already signalled its exit, the IsAlive method will always return 0. Therefore IsAlive should always return 0 (false) once a \s-1EVT_WXP_PROCESS_STREAM_EXIT\s0 event has been sent.     my $isalive = $process-&gt;IsAlive();</p>
  </dd>
  <dt>
    KillProcess
  </dt>
  <dd>
    <p>Send a \s-1SIGKILL\s0 signal to the external process.     $process-&gt;KillProcess();</p>
  </dd>
  <dt>
    SetAppCloseAction
  </dt>
  <dd>
    <p>When your application exits, any remaining Wx::Perl::ProcessStream::Process objects will be signaled to close. The default signal is wxpSIGTERM but you can change this to wxpSIGKILL if you are sure this is what you want.     $process-&gt;SetAppCloseAction( $newaction );</p><p>    $newaction = one of wxpSIGTERM, wxpSIGKILL</p>
  </dd>
  <dt>
    TerminateProcess
  </dt>
  <dd>
    <p>Send a \s-1SIGTERM\s0 signal to the external process.     $process-&gt;TerminateProcess();</p>
  </dd>
  <dt>
    WriteProcess
  </dt>
  <dd>
    <p>Write to the \s-1STDIN\s0 of process.     $process-&gt;WriteProcess( $writedata . "&#92;n" );</p><p>    $writedata = The data you wish to write. Remember to add any appropriate line endings your external process may expect.</p>
  </dd>

</dl>

<h3>Wx::Perl::ProcessStream</h3>
<p><em>Methods</em></p>
<dl class='dl-vertical'>
  <dt>
    OpenProcess
  </dt>
  <dd>
    <p>Run an external process. \s-1DEPRECATED\s0 - use Wx::Perl::ProcessStream::Process-&gt;<em>new()</em>-&gt;Run; If the process is launched successfully, returns a Wx::Perl::ProcessStream::Process object. If the process could not be launched, returns undef;     my $process = Wx::Perl::ProcessStream-&gt;OpenProcess($command, $name, $eventhandler, $readmethod);</p><p>    $command      = command text (and parameters) you wish to run. You may also pass a                     reference to an array containing the command and parameters.     $name         = an arbitray name for the process.     $eventhandler = the Wx object that will handle events for this process.     $process      = Wx::Perl::ProcessStream::Process object     $readmethod   = &apos;getc&apos; or &apos;readline&apos; (default = &apos;readline&apos;) an optional param. From Wx version                     0.75 you can specifiy the method you wish to use to read the output of an                     external process. The default depends on your Wx version ( &apos;getc&apos; &lt; 0.75,                     &apos;readline&apos; &gt;= 0.75)                     &apos;getc&apos; uses the Wx::InputStream-&gt;GetC method to read bytes.                     &apos;readline&apos;, uses the wxPerl implementation of Wx::InputStream-&gt;READLINE. If the process could not be started then zero is returned. You should destroy each process after it has completed. You can do this after receiving the exit event.</p>
  </dd>
  <dt>
    GetDefaultAppCloseAction
  </dt>
  <dd>
    <p>Returns the default on application close action that will be given to new processes. When your application exits, any remaining Wx::Perl::ProcessStream::Process objects will be signalled to close. The default signal is wxpSIGTERM but you can change this to wxpSIGKILL if you are sure this is what you want. Whenever a mew process is opened, it is given the application close action returned by GetDefaultAppCloseAction. You can also set the application close action at an individual process level.     my $def-action = Wx::Perl::ProcessStream-&gt;SetDefaultAppCloseAction();</p><p>    $def-action will be one of wxpSIGTERM or wxpSIGKILL; (default wxpSIGTERM)</p>
  </dd>
  <dt>
    SetDefaultAppCloseAction
  </dt>
  <dd>
    <p>Sets the default on application close action that will be given to new processes. See GetDefaultAppCloseAction.     Wx::Perl::ProcessStream-&gt;SetDefaultAppCloseAction( $newdefaction );</p><p>    $newdefaction = one of wxpSIGTERM or wxpSIGKILL</p>
  </dd>
  <dt>
    SetDefaultMaxLines
  </dt>
  <dd>
    <p>Sets the default maximum number of lines that will be processed continuously from an individual process. If a process produces a continuous stream of output, this would hang your application. This setting provides a maximum number of lines that will be read from the process streams before control is yielded and the events can be processed. Additionally, a \s-1EVT_WXP_PROCESS_STREAM_MAXLINES\s0 event will be sent to the eventhandler. The setting can also be set on an individual process basis using $process-&gt;SetMaxLines     Wx::Perl::ProcessStream-&gt;SetDefaultMaxLines( $maxlines );</p><p>    the default maxlines number is 1000</p>
  </dd>
  <dt>
    GetPollInterval
  </dt>
  <dd>
    <p>Get the current polling interval. See SetPollInterval.     $milliseconds = Wx::Perl::ProcessStream-&gt;GetPollInterval();</p>
  </dd>
  <dt>
    SetPollInterval
  </dt>
  <dd>
    <p>When all buffers are empty but there are still running external process, the module will pause before polling the processes again for output. By default, the module waits for 500 milliseconds. You can set the value of this polling intrval with this method. Internally, a Wx::Timer object is used to handle polling and the value you set here is passed directly to that. The precision of the intervals is \s-1OS\s0 dependent.     Wx::Perl::ProcessStream-&gt;SetPollInterval( $milliseconds );</p><p>    $milliseconds = number of milliseconds to wait when no buffer activity</p>
  </dd>

</dl>

<h3>Wx::Perl::ProcessStream::ProcessEvent</h3>
<p>A Wx::Perl::ProcessStream::ProcessEvent is sent whenever an external process started with OpenProcess writes to \s-1STDOUT\s0, \s-1STDERR\s0 or when the process exits.</p><p><em>Event Connectors</em></p>
<dl class='dl-vertical'>
  <dt>
    \s-1EVT_WXP_PROCESS_STREAM_STDOUT\s0
  </dt>
  <dd>
    <p>Install an event handler for an event of type wxpEVT_PROCESS_STREAM_STDOUT exported on request by this module. The event subroutine will receive a Wx::Perl::ProcessStream::ProcessEvent for every line written to \s-1STDOUT\s0 by the external process.     EVT_WXP_PROCESS_STREAM_STDOUT( $eventhandler, $codref );</p>
  </dd>
  <dt>
    \s-1EVT_WXP_PROCESS_STREAM_STDERR\s0
  </dt>
  <dd>
    <p>Install an event handler for an event of type wxpEVT_PROCESS_STREAM_STDERR exported on request by this module. The event subroutine will receive a Wx::Perl::ProcessStream::ProcessEvent for every line written to \s-1STDERR\s0 by the external process.     EVT_WXP_PROCESS_STREAM_STDERR( $eventhandler, $codref );</p>
  </dd>
  <dt>
    \s-1EVT_WXP_PROCESS_STREAM_EXIT\s0
  </dt>
  <dd>
    <p>Install an event handler for an event of type wxpEVT_PROCESS_STREAM_EXIT exported on request by this module. The event subroutine will receive a Wx::Perl::ProcessStream::ProcessEvent when the external process exits.     EVT_WXP_PROCESS_STREAM_EXIT( $eventhandler, $codref );</p>
  </dd>
  <dt>
    \s-1EVT_WXP_PROCESS_STREAM_MAXLINES\s0
  </dt>
  <dd>
    <p>Install an event handler for an event of type wxpEVT_PROCESS_STREAM_MAXLINES exported on request by this module. The event subroutine will receive a Wx::Perl::ProcessStream::ProcessEvent when the external process produces a continuous stream of lines on stderr and stdout that exceed the max lines set via $process-&gt;SetMaxLines or Wx::Perl::ProcessStream-&gt;SetDefaultMaxLines.     EVT_WXP_PROCESS_STREAM_MAXLINES( $eventhandler, $codref );</p>
  </dd>

</dl>
<p><em>Methods</em></p>
<dl class='dl-vertical'>
  <dt>
    GetLine
  </dt>
  <dd>
    <p>For events of type wxpEVT_PROCESS_STREAM_STDOUT and wxpEVT_PROCESS_STREAM_STDERR this will return the line written by the process.</p>
  </dd>
  <dt>
    GetProcess
  </dt>
  <dd>
    <p>This returns the process that raised the event. If this is a wxpEVT_PROCESS_STREAM_EXIT event you should destroy the process with $process-&gt;Destroy;</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT & LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2007-2010 Mark Dootson, all rights reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>Thanks to Johan Vromans for testing and suggesting a better interface.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Mark Dootson, \*(C`&lt;mdootson at cpan.org&gt;\*(C'</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Wx::Perl::ProcessStream&hellip;</h2>
        <div class="sectioncontent">
<p>The distribution includes examples in the 'example' folder. From the source root, run</p><p>    perl -Ilib example/psexample.pl</p><p>You can enter commands, execute them and view results.</p><p>You may also wish to consult the wxWidgets manuals for:</p><p>Wx::Process</p><p>Wx::Execute</p><p>Wx::ExecuteArgs</p><p>Wx::ExecuteCommand</p><p>Wx::ExecuteStdout</p><p>Wx::ExecuteStdoutStderr</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Wx::Perl::DataWalker.3pm.html"><span aria-hidden="true">&larr;</span> Wx::Perl::DataWalker.3pm: Perl extension for blah blah blah</a></li>
   <li class="next"><a href="X11::FreeDesktop::DesktopEntry.3pm.html">X11::FreeDesktop::DesktopEntry.3pm: An interface to freedesktop.org .desktop files. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

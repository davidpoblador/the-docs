<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Term::ShellUI: A fully-featured shell-like command line environment</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A fully-featured shell-like command line environment">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Term::ShellUI (3pm) manual">
  <meta name="twitter:description" content="A fully-featured shell-like command line environment">
  <meta name="twitter:image" content="https://www.carta.tech/images/libterm-shellui-perl-Term::ShellUI-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Term::ShellUI.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Term::ShellUI (3pm) manual" />
  <meta property="og:description" content="A fully-featured shell-like command line environment" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libterm-shellui-perl-Term::ShellUI-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Term::ShellUI<small> (3pm)</small></h1>
        <p class="lead">A fully-featured shell-like command line environment</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Term::ShellUI.3pm.html">
      <span itemprop="name">Term::ShellUI: A fully-featured shell-like command line environment</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libterm-shellui-perl/">
      <span itemprop="name">libterm-shellui-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Term::ShellUI.3pm.html">
      <span itemprop="name">Term::ShellUI: A fully-featured shell-like command line environment</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Term::ShellUI;
  my $term = new Term::ShellUI(
      commands =&gt; {
              "cd" =&gt; {
                  desc =&gt; "Change to directory DIR",
                  maxargs =&gt; 1, args =&gt; sub { shift-&gt;complete_onlydirs(@_); },
                  proc =&gt; sub { chdir($_[0] || $ENV{HOME} || $ENV{LOGDIR}); },
              },
              "chdir" =&gt; { alias =&gt; &apos;cd&apos; },
              "pwd" =&gt; {
                  desc =&gt; "Print the current working directory",
                  maxargs =&gt; 0, proc =&gt; sub { system(&apos;pwd&apos;); },
              },
              "quit" =&gt; {
                  desc =&gt; "Quit this program", maxargs =&gt; 0,
                  method =&gt; sub { shift-&gt;<strong>exit_requested</strong>(1); },
              }},
          history_file =&gt; &apos;~/.shellui-synopsis-history&apos;,
      );
  print &apos;Using &apos;.$term-&gt;{term}-&gt;ReadLine."&#92;n";
  $term-&gt;run();
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Term::ShellUI uses the history and autocompletion features of Term::ReadLine to present a sophisticated command-line interface to the user.  It tries to make every feature that one would expect to see in a fully interactive shell trivial to implement. You simply declare your command set and let ShellUI take care of the heavy lifting.</p><p>This module was previously called Term::GDBUI.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMAND SET</h2>
        <div class="sectioncontent">
<p>A command set is the data structure that describes your application's entire user interface. It's easiest to illustrate with a working example. We shall implement the following 6 \*(L"\s-1COMMAND\s0\*(R"s:</p>
<dl class='dl-vertical'>
  <dt>
    help
  </dt>
  <dd>
    <p>Prints the help for the given command. With no arguments, prints a list and short summary of all available commands.</p>
  </dd>
  <dt>
    h
  </dt>
  <dd>
    <p>This is just a synonym for \*(L"help\*(R".  We don't want to list it in the possible completions. Of course, pressing \*(L"h&lt;tab&gt;&lt;return&gt;\*(R" will autocomplete to \*(L"help\*(R" and then execute the help command.  Including this command allows you to simply type \*(L"h&lt;return&gt;\*(R". The 'alias' directive used to be called 'syn' (for synonym). Either term works.</p>
  </dd>
  <dt>
    exists
  </dt>
  <dd>
    <p>This command shows how to use the \*(L"complete_files\*(R" routines to complete on file names, and how to provide more comprehensive help.</p>
  </dd>
  <dt>
    show
  </dt>
  <dd>
    <p>Demonstrates subcommands (like \s-1GDB\s0's show command). This makes it easy to implement commands like \*(L"show warranty\*(R" and \*(L"show args\*(R".</p>
  </dd>
  <dt>
    show args
  </dt>
  <dd>
    <p>This shows more advanced argument processing. First, it uses cusom argument completion: a static completion for the first argument (either \*(L"create\*(R" or \*(L"delete\*(R") and the standard file completion for the second.  When executed, it echoes its own command name followed by its arguments.</p>
  </dd>
  <dt>
    quit
  </dt>
  <dd>
    <p>How to nicely quit. Term::ShellUI also follows Term::ReadLine's default of quitting when Control-D is pressed.</p>
  </dd>

</dl>
<p>This code is fairly comprehensive because it attempts to demonstrate most of Term::ShellUI's many features.  You can find a working version of this exact code titled \*(L"synopsis\*(R" in the examples directory. For a more real-world example, see the fileman-example in the same directory.</p><p> sub get_commands  {      return {          "help" =&gt; {              desc =&gt; "Print helpful information",              args =&gt; sub { shift-&gt;help_args(undef, @_); },              method =&gt; sub { shift-&gt;help_call(undef, @_); }          },          "h" =&gt;      { alias =&gt; "help", exclude_from_completion=&gt;1},          "exists" =&gt; {              desc =&gt; "List whether files exist",              args =&gt; sub { shift-&gt;complete_files(@_); },              proc =&gt; sub {                  print "exists: " .                      join(", ", map {-e($_) ? "&lt;$_&gt;":$_} @_) .                      "&#92;n";              },              doc =&gt; &lt;&lt;EOL,  Comprehensive documentation for our ls command.  If a file exists, it is printed in &lt;angle brackets&gt;.  The help can&#92;nspan&#92;nmany&#92;nlines  EOL          },          "show" =&gt; {              desc =&gt; "An example of using subcommands",              cmds =&gt; {                  "warranty" =&gt; { proc =&gt; "You have no warranty!&#92;n" },                  "args" =&gt; {                      minargs =&gt; 2, maxargs =&gt; 2,                      args =&gt; [ sub {qw(create delete)},                                &#92;&Term::ShellUI::complete_files ],                      desc =&gt; "Demonstrate method calling",                      method =&gt; sub {                          my $self = shift;                          my $parms = shift;                          print $self-&gt;get_cname($parms-&gt;{cname}) .                              ": " . join(" ",@_), "&#92;n";                      },                  },              },          },          "quit" =&gt; {              desc =&gt; "Quit using Fileman",              maxargs =&gt; 0,              method =&gt; sub { shift-&gt;<strong>exit_requested</strong>(1); }          },          "q" =&gt; { alias =&gt; &apos;quit&apos;, exclude_from_completion =&gt; 1 },      };  }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMAND</h2>
        <div class="sectioncontent">
<p>This data structure describes a single command implemented by your application. \*(L"help\*(R", \*(L"exit\*(R", etc. All fields are optional. Commands are passed to Term::ShellUI using a \*(L"\s-1COMMAND\s0 \s-1SET\s0\*(R".</p>
<dl class='dl-vertical'>
  <dt>
    desc
  </dt>
  <dd>
    <p>A short, one-line description for the command.  Normally this is a simple string, but it may also be a subroutine that will be called every time the description is printed. The subroutine takes two arguments, $self (the Term::ShellUI object), and $cmd (the command hash for the command), and returns the command's description as a string.</p>
  </dd>
  <dt>
    doc
  </dt>
  <dd>
    <p>A comprehensive, many-line description for the command. Like desc, this is normally a string but if you store a reference to a subroutine in this field, it will be called to calculate the documentation. Your subroutine should accept three arguments: self (the Term::ShellUI object), cmd (the command hash for the command), and the command's name. It should return a string containing the command's documentation. See examples/xmlexer to see how to read the doc for a command out of the pod.</p>
  </dd>
  <dt>
    minargs
  </dt>
  <dd>
    
  </dd>
  <dt>
    maxargs
  </dt>
  <dd>
    <p>These set the minimum and maximum number of arguments that this command will accept.</p>
  </dd>
  <dt>
    proc
  </dt>
  <dd>
    <p>This contains a reference to the subroutine that should be executed when this command is called.  Arguments are those passed on the command line and the return value is the value returned by call_cmd and process_a_cmd (i.e. it is ignored unless your application makes use of it). If this field is a string instead of a subroutine ref, the string is printed when the command is executed (good for things like \*(L"Not implemented yet\*(R"). Examples of both subroutine and string procs can be seen in the example above.</p>
  </dd>
  <dt>
    method
  </dt>
  <dd>
    <p>Similar to proc, but passes more arguments.  Where proc simply passes the arguments for the command, method also passes the Term::ShellUI object and the command's parms object (see \*(L"call_cmd\*(R" for more on parms).  Most commands can be implemented entirely using a simple proc procedure, but sometimes they require addtional information supplied to the method.  Like proc, method may also be a string.</p>
  </dd>
  <dt>
    args
  </dt>
  <dd>
    <p>This tells how to complete the command's arguments.  It is usually a subroutine.  See \*(L"complete_files\*(R" for an reasonably simple example, and the \*(L"complete\*(R" routine for a description of the arguments and cmpl data structure. Args can also be an arrayref.  Each position in the array will be used as the corresponding argument. See \*(L"show args\*(R" in get_commands above for an example. The last argument is repeated indefinitely (see \*(L"maxargs\*(R" for how to limit this). Finally, args can also be a string.  The string is intended to be a reminder and is printed whenever the user types tab twice (i.e. \*(L"a number between 0 and 65536\*(R"). It does not affect completion at all.</p>
  </dd>
  <dt>
    cmds
  </dt>
  <dd>
    <p>Command sets can be recursive.  This allows a command to have subcommands (like \s-1GDB\s0's info and show commands, and the show command in the example above). A command that has subcommands should only have two fields: cmds (of course), and desc (briefly describe this collection of subcommands). It may also implement doc, but ShellUI's default behavior of printing a summary of the command's subcommands is usually sufficient. Any other fields (args, method, maxargs, etc) will be taken from the subcommand.</p>
  </dd>
  <dt>
    exclude_from_completion
  </dt>
  <dd>
    <p>If this field exists, then the command will be excluded from command-line completion.  This is useful for one-letter abbreviations, such as \*(L"h\*(R"-&gt;\*(L"help\*(R": including \*(L"h\*(R" in the completions just clutters up the screen.</p>
  </dd>
  <dt>
    exclude_from_history
  </dt>
  <dd>
    <p>If this field exists, the command will never be stored in history. This is useful for commands like help and quit.</p>
  </dd>

</dl>
<h3>Default Command</h3>
<p>If your command set includes a command named '' (the empty string), this pseudo-command will be called any time the actual command cannot be found.  Here's an example:</p><p>  &apos;&apos; =&gt; {     proc =&gt; "HA ha.  No command here by that name&#92;n",     desc =&gt; "HA ha.  No help for unknown commands.",     doc =&gt; "Yet more taunting...&#92;n",   },</p><p>Note that minargs and maxargs for the default command are ignored. method and proc will be called no matter how many arguments the user entered.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CATEGORIES</h2>
        <div class="sectioncontent">
<p>Normally, when the user types 'help', she receives a short summary of all the commands in the command set. However, if your application has 30 or more commands, this can result in information overload.  To manage this, you can organize your commands into help categories</p><p>All help categories are assembled into a hash and passed to the the default help_call and \*(L"help_args\*(R" methods.  If you don't want to use help categories, simply pass undef for the categories.</p><p>Here is an example of how to declare a collection of help categories:</p><p>  my $helpcats = {       breakpoints =&gt; {           desc =&gt; "Commands to halt the program",           cmds =&gt; qw(break tbreak delete disable enable),       },       data =&gt; {           desc =&gt; "Commands to examine data",           cmds =&gt; [&apos;info&apos;, &apos;show warranty&apos;, &apos;show args&apos;],       }   };</p><p>\*(L"show warranty\*(R" and \*(L"show args\*(R" on the last line above are examples of how to include subcommands in a help category: separate the command and subcommands with whitespace.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACKS</h2>
        <div class="sectioncontent">
<p>Callbacks are functions supplied by ShellUI but intended to be called by your application. They implement common functions like 'help' and 'history'.</p>
<dl class='dl-vertical'>
  <dt>
    help_call(cats, parms, topic)
  </dt>
  <dd>
    <p>Call this routine to implement your help routine.  Pass the help categories or undef, followed by the command-line arguments:   "help" =&gt;   { desc =&gt; "Print helpful information",                 args =&gt; sub { shift-&gt;help_args($helpcats, @_); },                 method =&gt; sub { shift-&gt;help_call($helpcats, @_); } },</p>
  </dd>
  <dt>
    help_args
  </dt>
  <dd>
    <p>This provides argument completion for help commands. See the example above for how to call it.</p>
  </dd>
  <dt>
    complete_files
  </dt>
  <dd>
    <p>Completes on filesystem objects (files, directories, etc). Use either   args =&gt; sub { shift-&gt;complete_files(@_) }, or   args =&gt; &#92;&complete_files, Starts in the current directory.</p>
  </dd>
  <dt>
    complete_onlyfiles
  </dt>
  <dd>
    <p>Like \*(L"complete_files\*(R"" but excludes directories, device nodes, etc. It returns regular files only.</p>
  </dd>
  <dt>
    complete_onlydirs
  </dt>
  <dd>
    <p>Like \*(L"complete_files\*(R"", but excludes files, device nodes, etc. It returns only directories. It <em>does</em> return the . and .. special directories so you'll need to remove those manually if you don't want to see them:   args = sub { grep { !/^&#92;.?&#92;.$/ } complete_onlydirs(@_) },</p>
  </dd>
  <dt>
    history_call
  </dt>
  <dd>
    <p>You can use this callback to implement the standard bash history command.  This command supports:     NUM       display last N history items               (displays all history if N is omitted)     -c        clear all history     -d NUM    delete an item from the history Add it to your command set using something like this:   "history" =&gt; { desc =&gt; "Prints the command history",      doc =&gt; "Specify a number to list the last N lines of history" .             "Pass -c to clear the command history, " .             "-d NUM to delete a single item&#92;n",      args =&gt; "[-c] [-d] [number]",      method =&gt; sub { shift-&gt;history_call(@_) },   },</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>These are the routines that your application calls to create and use a Term::ShellUI object. Usually you simply call <em>new()</em> and then <em>run()</em> \*(-- everything else is handled automatically. You only need to read this section if you wanted to do something out of the ordinary. Creates a new ShellUI object. It accepts the following named parameters:</p>
<dl class='dl-vertical'>
  <dt>
    app
  </dt>
  <dd>
    <p>The name of this application (will be passed to \*(L"new\*(R" in Term::ReadLine). Defaults to $0, the name of the current executable.</p>
  </dd>
  <dt>
    term
  </dt>
  <dd>
    <p>Usually Term::ShellUI uses its own Term::ReadLine object (created with \*(C`new Term::ReadLine $args{&apos;app&apos;}\*(C').  However, if you can create a new Term::ReadLine object yourself and supply it using the term argument.</p>
  </dd>
  <dt>
    blank_repeats_cmd
  </dt>
  <dd>
    <p>This tells Term::ShellUI what to do when the user enters a blank line.  Pass 0 (the default) to have it do nothing (like Bash), or 1 to have it repeat the last command (like \s-1GDB\s0).</p>
  </dd>
  <dt>
    commands
  </dt>
  <dd>
    <p>A hashref containing all the commands that ShellUI will respond to. The format of this data structure can be found below in the command set documentation. If you do not supply any commands to the constructor, you must call the \*(L"commands\*(R" method to provide at least a minimal command set before using many of the following calls.  You may add or delete commands or even change the entire command set at any time.</p>
  </dd>
  <dt>
    history_file
  </dt>
  <dd>
    <p>If defined then the command history is saved to this file on exit. It should probably specify a dotfile in the user's home directory. Tilde expansion is performed, so something like \*(C`~/.myprog-history\*(C' is perfectly acceptable.</p>
  </dd>
  <dt>
    history_max = 500
  </dt>
  <dd>
    <p>This tells how many items to save to the history file. The default is 500. Note that this parameter does not affect in-memory history.  Term::ShellUI makes no attemt to cull history so you're at the mercy of the default of whatever ReadLine library you are using. See \*(L"StifleHistory\*(R" in Term::ReadLine::Gnu for one way to change this.</p>
  </dd>
  <dt>
    keep_quotes
  </dt>
  <dd>
    <p>Normally all unescaped, unnecessary quote marks are stripped. If you specify \*(C`keep_quotes=&gt;1\*(C', however, they are preserved. This is useful if your application uses quotes to delimit, say, Perl-style strings.</p>
  </dd>
  <dt>
    backslash_continues_command
  </dt>
  <dd>
    <p>Normally commands don't respect backslash continuation.  If you pass backslash_continues_command=&gt;1 to \*(L"new\*(R", then whenever a line ends with a backslash, Term::ShellUI will continue reading.  The backslash is replaced with a space, so</p>
<pre>
    $ abc &#92;
    &gt; def
</pre>
<p>Will produce the command string 'abc  def'.</p>
  </dd>
  <dt>
    prompt
  </dt>
  <dd>
    <p>This is the prompt that should be displayed for every request. It can be changed at any time using the \*(L"prompt\*(R" method. The default is &lt;\*(L"$0 \*(R"&gt;&gt; (see app above). If you specify a code reference, then the coderef is executed and its return value is set as the prompt.  Two arguments are passed to the coderef: the Term::ShellUI object, and the raw command. The raw command is always "" unless you're using command completion, where the raw command is the command line entered so far. For example, the following line sets the prompt to \*(L"## &gt; \*(R" where ## is the current number of history items.     $term-&gt;prompt(sub { $term-&gt;{term}-&gt;GetHistory() . " &gt; " }); If you specify an arrayref, then the first item is the normal prompt and the second item is the prompt when the command is being continued. For instance, this would emulate Bash's behavior ($ is the normal prompt, but &gt; is the prompt when continuing).     $term-&gt;prompt([&apos;$&apos;, &apos;&gt;&apos;]); Of course, you specify backslash_continues_command=&gt;1 to to \*(L"new\*(R" to cause commands to continue. And, of course, you can use an array of procs too.     $term-&gt;prompt([sub {&apos;$&apos;}, sub {&apos;&lt;&apos;}]);</p>
  </dd>
  <dt>
    token_chars
  </dt>
  <dd>
    <p>This argument specifies the characters that should be considered tokens all by themselves.  For instance, if I pass token_chars=&gt;'=', then 'ab=123' would be parsed to ('ab', '=', '123'). Without token_chars, 'ab=123' remains a single string. \s-1NOTE:\s0 you cannot change token_chars after the constructor has been called!  The regexps that use it are compiled once (m//o).</p>
  </dd>
  <dt>
    display_summary_in_help
  </dt>
  <dd>
    <p>Usually it's easier to have the command's summary (desc) printed first, then follow it with the documentation (doc).  However, if the doc already contains its description (for instance, if you're reading it from a podfile), you don't want the summary up there too.  Pass 0 to prevent printing the desc above the doc.  Defaults to 1.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    process_a_cmd([cmd])
  </dt>
  <dd>
    <p>Runs the specified command or prompts for it if no arguments are supplied. Returns the result or undef if no command was called.</p>
  </dd>
  <dt>
    <em>run()</em>
  </dt>
  <dd>
    <p>The main loop.  Processes all commands until someone calls \*(C`/"exit_requested(exitflag)"(true)\*(C'. If you pass arguments, they are joined and run once.  For instance, $term-&gt;run(@ARGV) allows your program to be run interactively or noninteractively:</p>
<dl class='dl-vertical'>
  <dt>
    myshell help
  </dt>
  <dd>
    <p>Runs the help command and exits.</p>
  </dd>
  <dt>
    myshell
  </dt>
  <dd>
    <p>Invokes an interactive Term::ShellUI.</p>
  </dd>

</dl>

  </dd>
  <dt>
    prompt(newprompt)
  </dt>
  <dd>
    <p>If supplied with an argument, this method sets the command-line prompt. Returns the old prompt.</p>
  </dd>
  <dt>
    commands(newcmds)
  </dt>
  <dd>
    <p>If supplied with an argument, it sets the current command set. This can be used to change the command set at any time. Returns the old command set.</p>
  </dd>
  <dt>
    add_commands(newcmds)
  </dt>
  <dd>
    <p>Takes a command set as its first argument. Adds all the commands in it the current command set. It silently replaces any commands that have the same name.</p>
  </dd>
  <dt>
    exit_requested(exitflag)
  </dt>
  <dd>
    <p>If supplied with an argument, sets Term::ShellUI's finished flag to the argument (1=exit, 0=don't exit).  So, to get the interpreter to exit at the end of processing the current command, call \*(C`$self-&gt;<strong>exit_requested</strong>(1)\*(C'.  To cancel an exit request before the command is finished, \*(C`$self-&gt;<strong>exit_requested</strong>(0)\*(C'. Returns the old state of the flag.</p>
  </dd>
  <dt>
    add_eof_exit_hook(subroutine_reference)
  </dt>
  <dd>
    <p>Call this method to add a subroutine as a hook into Term::ShellUI's \*(L"exit on \s-1EOF\s0\*(R" (Ctrl-D) functionality. When a user enters Ctrl-D, Term::ShellUI will call each function in this hook list, in order, and will exit only if all of them return 0. The first function to return a non-zero value will stop further processing of these hooks and prevent the program from exiting. The return value of this method is the placement of the hook routine in the hook list (1 is first) or 0 (zero) on failure.</p>
  </dd>
  <dt>
    get_cname(cname)
  </dt>
  <dd>
    <p>This is a tiny utility function that turns the cname (array ref of names for this command as returned by \*(L"get_deep_command\*(R") into a human-readable string. This function exists only to ensure that we do this consistently.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERRIDES</h2>
        <div class="sectioncontent">
<p>These are routines that probably already do the right thing. If not, however, they are designed to be overridden.</p>
<dl class='dl-vertical'>
  <dt>
    <em>blank_line()</em>
  </dt>
  <dd>
    <p>This routine is called when the user inputs a blank line. It returns a string specifying the command to run or undef if nothing should happen. By default, ShellUI simply presents another command line.  Pass \*(C`blank_repeats_cmd=&gt;1\*(C' to the constructor to get ShellUI to repeat the previous command.  Override this method to supply your own behavior.</p>
  </dd>
  <dt>
    error(msg)
  </dt>
  <dd>
    <p>Called when an error occurrs.  By default, the routine simply prints the msg to stderr.  Override it to change this behavior. It takes any number of arguments, cocatenates them together and prints them to stderr.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING A COMPLETION ROUTINE</h2>
        <div class="sectioncontent">
<p>Term::ReadLine makes writing a completion routine a notoriously difficult task. Term::ShellUI goes out of its way to make it as easy as possible.  The best way to write a completion routine is to start with one that already does something similar to what you want (see the \*(L"\s-1CALLBACKS\s0\*(R" section for the completion routines that come with ShellUI).</p><p>Your routine returns an arrayref of possible completions, a string conaining a short but helpful note, or undef if an error prevented any completions from being generated. Return an empty array if there are simply no applicable competions. Be careful; the distinction between no completions and an error can be significant.</p><p>Your routine takes two arguments: a reference to the ShellUI object and cmpl, a data structure that contains all the information you need to calculate the completions.  Set $term-&gt;{debug_complete}=5 to see the contents of cmpl:</p>
<dl class='dl-vertical'>
  <dt>
    str
  </dt>
  <dd>
    <p>The exact string that needs completion.  Often, for simple completions, you don't need anything more than this. \s-1NOTE:\s0 str does <em>not</em> respect token_chars!  It is supplied unchanged from Readline and so uses whatever tokenizing it implements. Unfortunately, if you've changed token_chars, this will often be different from how Term::ShellUI would tokenize the same string.</p>
  </dd>
  <dt>
    cset
  </dt>
  <dd>
    <p>Command set for the deepest command found (see \*(L"get_deep_command\*(R"). If no command was found then cset is set to the topmost command set ($self-&gt;<em>commands()</em>).</p>
  </dd>
  <dt>
    cmd
  </dt>
  <dd>
    <p>The command hash for deepest command found or undef if no command was found (see \*(L"get_deep_command\*(R"). cset is the command set that contains cmd.</p>
  </dd>
  <dt>
    cname
  </dt>
  <dd>
    <p>The full name of deepest command found as an array of tokens (see \*(L"get_deep_command\*(R").  Use \*(L"get_cname\*(R" to convert this into a human-readable string.</p>
  </dd>
  <dt>
    args
  </dt>
  <dd>
    <p>The arguments (as a list of tokens) that should be passed to the command (see \*(L"get_deep_command\*(R").  Valid only if cmd is non-null.  Undef if no args were passed.</p>
  </dd>
  <dt>
    argno
  </dt>
  <dd>
    <p>The index of the argument (in args) containing the cursor. If the user is trying to complete on the command name, then argno is negative (because the cursor comes before the arguments).</p>
  </dd>
  <dt>
    tokens
  </dt>
  <dd>
    <p>The tokenized command-line.</p>
  </dd>
  <dt>
    tokno
  </dt>
  <dd>
    <p>The index of the token containing the cursor.</p>
  </dd>
  <dt>
    tokoff
  </dt>
  <dd>
    <p>The character offset of the cursor in the token. For instance, if the cursor is on the first character of the third token, tokno will be 2 and tokoff will be 0.</p>
  </dd>
  <dt>
    twice
  </dt>
  <dd>
    <p>True if user has hit tab twice in a row.  This usually means that you should print a message explaining the possible completions. If you return your completions as a list, then $twice is handled for you automatically.  You could use it, for instance, to display an error message (using completemsg) telling why no completions could be found.</p>
  </dd>
  <dt>
    rawline
  </dt>
  <dd>
    <p>The command line as a string, exactly as entered by the user.</p>
  </dd>
  <dt>
    rawstart
  </dt>
  <dd>
    <p>The character position of the cursor in rawline.</p>
  </dd>

</dl>
<p>The following are utility routines that your completion function can call.</p>
<dl class='dl-vertical'>
  <dt>
    completemsg(msg)
  </dt>
  <dd>
    <p>Allows your completion routine to print to the screen while completing (i.e. to offer suggestions or print debugging info \*(-- see debug_complete). If it just blindly calls print, the prompt will be corrupted and things will be confusing until the user redraws the screen (probably by hitting Control-L).     $self-&gt;completemsg("You cannot complete here!&#92;n"); Note that Term::ReadLine::Perl doesn't support this so the user will always have to hit Control-L after printing.  If your completion routine returns a string rather than calling <em>completemsg()</em> then it should work everywhere.</p>
  </dd>
  <dt>
    <em>suppress_completion_append_character()</em>
  </dt>
  <dd>
    <p>When the ReadLine library finds a unique match among the list that you returned, it automatically appends a space.  Normally this is what you want (i.e. when completing a command name, in help, etc.) However, if you're navigating the filesystem, this is definitely not desirable (picture having to hit backspace after completing each directory). Your completion function needs to call this routine every time it runs if it doesn't want a space automatically appended to the completions that it returns.</p>
  </dd>
  <dt>
    <em>suppress_completion_escape()</em>
  </dt>
  <dd>
    <p>Normally everything returned by your completion routine is escaped so that it doesn't get destroyed by shell metacharacter interpretation (quotes, backslashes, etc).  To avoid escaping twice (disastrous), a completion routine that does its own escaping (perhaps using Text::Shellwords::Cursorparse_escape) must call suppress_completion_escape every time is called.</p>
  </dd>
  <dt>
    force_to_string(cmpl, commmpletions, default_quote)
  </dt>
  <dd>
    <p>If all the completions returned by your completion routine should be enclosed in single or double quotes, call force_to_string on them. You will most likely need this routine if keep_quotes is 1. This is useful when completing a construct that you know must always be quoted. force_to_string surrounds all completions with the quotes supplied by the user or, if the user didn't supply any quotes, the quote passed in default_quote. If the programmer didn't supply a default_quote and the user didn't start the token with an open quote, then force_to_string won't change anything. Here's how to use it to force strings on two possible completions, aaa and bbb.  If the user doesn't supply any quotes, the completions will be surrounded by double quotes.      args =&gt; sub { shift-&gt;force_to_string(@_,[&apos;aaa&apos;,&apos;bbb&apos;],&apos;"&apos;) }, Calling force_to_string escapes your completions (unless your callback calls suppress_completion_escape itself), then calls suppress_completion_escape to ensure the final quote isn't mangled.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNALS</h2>
        <div class="sectioncontent">
<p>These commands are internal to ShellUI. They are documented here only for completeness \*(-- you should never need to call them.</p>
<dl class='dl-vertical'>
  <dt>
    get_deep_command
  </dt>
  <dd>
    <p>Looks up the supplied command line in a command hash. Follows all synonyms and subcommands. Returns undef if the command could not be found.     my($cset, $cmd, $cname, $args) =         $self-&gt;get_deep_command($self-&gt;commands(), $tokens); This call takes two arguments:</p>
<dl class='dl-vertical'>
  <dt>
    cset
  </dt>
  <dd>
    <p>This is the command set to use.  Pass $self-&gt;<em>commands()</em> unless you know exactly what you're doing.</p>
  </dd>
  <dt>
    tokens
  </dt>
  <dd>
    <p>This is the command line that the command should be read from. It is a reference to an array that has already been split on whitespace using Text::Shellwords::Cursor::parse_line.</p>
  </dd>

</dl>
<p>and it returns a list of 4 values:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>cset: the deepest command set found.  Always returned.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>cmd: the command hash for the command.  Undef if no command was found.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>cname: the full name of the command.  This is an array of tokens, i.e. ('show', 'info').  Returns as deep as it could find commands even if the final command was not found.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>args: the command's arguments (all remaining tokens after the command is found).</p>
  </dd>

</dl>

  </dd>
  <dt>
    get_cset_completions(cset)
  </dt>
  <dd>
    <p>Returns a list of commands from the passed command set that are suitable for completing.</p>
  </dd>
  <dt>
    call_args
  </dt>
  <dd>
    <p>Given a command set, does the correct thing at this stage in the completion (a surprisingly nontrivial task thanks to ShellUI's flexibility).  Called by <em>complete()</em>.</p>
  </dd>
  <dt>
    complete
  </dt>
  <dd>
    <p>This routine figures out the command set of the completion routine that needs to be called, then calls <em>call_args()</em>.  It is called by completion_function. You should override this routine if your application has custom completion needs (like non-trivial tokenizing, where you'll need to modify the cmpl data structure).  If you override this routine, you will probably need to override call_cmd as well.</p>
  </dd>
  <dt>
    completion_function
  </dt>
  <dd>
    <p>This is the entrypoint to the ReadLine completion callback. It sets up a bunch of data, then calls complete to calculate the actual completion. To watch and debug the completion process, you can set $self-&gt;{debug_complete} to 2 (print tokenizing), 3 (print tokenizing and results) or 4 (print everything including the cmpl data structure). Youu should never need to call or override this function.  If you do (but, trust me, you don't), set $self-&gt;{term}-&gt;Attribs-&gt;{completion_function} to point to your own routine. See the Term::ReadLine documentation for a description of the arguments.</p>
  </dd>
  <dt>
    get_cmd_summary(tokens, cset)
  </dt>
  <dd>
    <p>Prints a one-line summary for the given command. Uses self-&gt;<em>commands()</em> if cset is not specified.</p>
  </dd>
  <dt>
    get_cmd_help(tokens, cset)
  </dt>
  <dd>
    <p>Prints the full help text for the given command. Uses self-&gt;<em>commands()</em> if cset is not specified.</p>
  </dd>
  <dt>
    get_category_summary(name, cats)
  </dt>
  <dd>
    <p>Prints a one-line summary for the named category in the category hash specified in cats.</p>
  </dd>
  <dt>
    get_category_help(cat, cset)
  </dt>
  <dd>
    <p>Returns a summary of the commands listed in cat. You must pass the command set that contains those commands in cset.</p>
  </dd>
  <dt>
    get_all_cmd_summaries(cset)
  </dt>
  <dd>
    <p>Pass it a command set, and it will return a string containing the summaries for each command in the set.</p>
  </dd>
  <dt>
    <em>load_history()</em>
  </dt>
  <dd>
    <p>If $self-&gt;{history_file} is set (see \*(L"new\*(R"), this will load all history from that file.  Called by run on startup.  If you don't use run, you will need to call this command manually.</p>
  </dd>
  <dt>
    <em>save_history()</em>
  </dt>
  <dd>
    <p>If $self-&gt;{history_file} is set (see \*(L"new\*(R"), this will save all history to that file.  Called by run on shutdown.  If you don't use run, you will need to call this command manually. The history routines don't use ReadHistory and WriteHistory so they can be used even if other ReadLine libs are being used.  save_history requires that the ReadLine lib supply a GetHistory call.</p>
  </dd>
  <dt>
    call_command(parms)
  </dt>
  <dd>
    <p>Executes a command and returns the result.  It takes a single argument: the parms data structure. parms is a subset of the cmpl data structure (see the \*(L"complete(cmpl)\*(R" in complete routine for more).  Briefly, it contains: cset, cmd, cname, args (see \*(L"get_deep_command\*(R"), tokens and rawline (the tokenized and untokenized command lines). See complete for full descriptions of these fields. This call should be overridden if you have exotic command processing needs.  If you override this routine, you will probably need to override the complete routine too.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2003-2011 Scott Bronson, all rights reserved. This program is free software released under the \s-1MIT\s0 license.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Scott Bronson &lt;bronson@rinspin.com&gt; Lester Hightower &lt;hightowe@cpan.org&gt; Ryan Gies &lt;ryan@livesite.net&gt; Martin Kluge &lt;mk@elxsi.de&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Term::ReadPassword.3pm.html"><span aria-hidden="true">&larr;</span> Term::ReadPassword.3pm: Asking the user for a password</a></li>
   <li class="next"><a href="Term::Size::Any.3pm.html">Term::Size::Any.3pm: Retrieve terminal size <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

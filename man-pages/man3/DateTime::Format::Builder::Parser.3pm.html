<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DateTime::Format::Builder::Parser: Parser creation</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parser creation">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="DateTime::Format::Builder::Parser (3pm) manual">
  <meta name="twitter:description" content="Parser creation">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdatetime-format-builder-perl-DateTime::Format::Builder::Parser-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/DateTime::Format::Builder::Parser.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="DateTime::Format::Builder::Parser (3pm) manual" />
  <meta property="og:description" content="Parser creation" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdatetime-format-builder-perl-DateTime::Format::Builder::Parser-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">DateTime::Format::Builder::Parser<small> (3pm)</small></h1>
        <p class="lead">Parser creation</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DateTime::Format::Builder::Parser.3pm.html">
      <span itemprop="name">DateTime::Format::Builder::Parser: Parser creation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdatetime-format-builder-perl/">
      <span itemprop="name">libdatetime-format-builder-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DateTime::Format::Builder::Parser.3pm.html">
      <span itemprop="name">DateTime::Format::Builder::Parser: Parser creation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>version 0.81</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    my $class = &apos;DateTime::Format::Builder::Parser&apos;;
    my $parser = $class-&gt;create_single_parser( %specs );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is a utility class for DateTime::Format::Builder that handles creation of parsers. It is to here that \*(C`Builder\*(C' delegates most of its responsibilities.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTORS</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>There are two sorts of methods in this class. Those used by parser implementations and those used by \*(C`Builder\*(C'. It is generally unlikely the user will want to use any of them.</p><p>They are presented, grouped according to use.</p><h3>Parameter Handling (implementations)</h3>
<p>These methods allow implementations to have validation of their arguments in a standard manner and due to \*(C`Parser\*(C''s impelementation, these methods also allow \*(C`Parser\*(C' to determine which implementation to use.</p><p><em>Common parameters</em></p><p>These parameters appear for all parser implementations. These are primarily documented in DateTime::Format::Builder.</p><ul>
<li><p><strong>on_match</strong></p></li><li><p><strong>on_fail</strong></p></li><li><p><strong>postprocess</strong></p></li><li><p><strong>preprocess</strong></p></li><li><p><strong>label</strong></p></li><li><p><strong>length</strong> may be a number or an arrayref of numbers indicating the length of the input. This lets us optimise in the case of static length input. If supplying an arrayref of numbers, please keep the number of numbers to a minimum.</p></li>
</ul><p><em>params</em></p><p>    my $params = $self-&gt;params();     validate( @_, $params );</p><p>Returns declared parameters and \*(C`common\*(C' parameters in a hashref suitable for handing to Params::Validate's \*(C`validate\*(C' function.</p><p><em>params_all</em></p><p>    my $all_params = $self-&gt;params_all();</p><p>Returns a hash of all the valid options. Not recommended for general use.</p><p><em>valid_params</em></p><p>    _\|_PACKAGE_\|_-&gt;valid_params( %params );</p><p>Arguments are as per Params::Validate's \*(C`validate\*(C' function. This method is used to declare what your valid arguments are in a parser specification.</p><p><em>whose_params</em></p><p>    my $class = whose_params( $key );</p><p>Internal function which merely returns to which class a parameter is unique. If not unique, returns \*(C`undef\*(C'.</p>
<h3>Organising and Creating Parsers</h3>
<p><em>create_single_parser</em></p><p>This takes a single specification and returns a coderef that is a parser that suits that specification. This is the end of the line for all the parser creation methods. It delegates no further.</p><p>If a coderef is specified, then that coderef is immediately returned (it is assumed to be appropriate).</p><p>The single specification (if not a coderef) can be either a hashref or a hash. The keys and values must be as per the specification.</p><p>It is here that any arrays of callbacks are unified. It is also here that any parser implementations are used. With the spec that's given, the keys are looked at and whichever module is the first to have a unique key in the spec is the one to whom the spec is given.</p><p><strong>Note</strong>: please declare a \*(C`valid_params\*(C' argument with an uppercase letter. For example, if you're writing \*(C`DateTime::Format::Builder::Parser::Fnord\*(C', declare a parameter called \*(C`Fnord\*(C'. Similarly, \*(C`DTFBP::Strptime\*(C' should have \*(C`Strptime\*(C' and \*(C`DTFBP::Regex\*(C' should have \*(C`Regex\*(C'. These latter two don't for backwards compatibility reasons.</p><p>The returned parser will return either a \*(C`DateTime\*(C' object or \*(C`undef\*(C'.</p><p><em>merge_callbacks</em></p><p>Produce either undef or a single coderef from either undef, an empty array, a single coderef or an array of coderefs</p>
<h3>create_multiple_parsers</h3>
<p>Given the options block (as made from \*(C`create_parser()\*(C') and a list of single parser specifications, this returns a coderef that returns either the resultant \*(C`DateTime\*(C' object or \*(C`undef\*(C'.</p><p>It first sorts the specifications using \*(C`sort_parsers()\*(C' and then creates the function based on what that returned.</p>
<h3>sort_parsers</h3>
<p>This takes the list of specifications and sorts them while turning the specifications into parsers. It returns two values: the first is a hashref containing all the length based parsers. The second is an array containing all the other parsers.</p><p>If any of the specs are not code or hash references, then it will call \*(C`croak()\*(C'.</p><p>Code references are put directly into the 'other' array. Any hash references without <em>length</em> keys are run through \*(C`create_single_parser()\*(C' and the resultant parser is placed in the 'other' array.</p><p>Hash references <strong>with</strong> <em>length</em> keys are run through \*(C`create_single_parser()\*(C', but the resultant parser is used as the value in the length hashref with the length being the key. If two or more parsers have the same <em>length</em> specified then an error is thrown.</p>
<h3>create_parser</h3>
<p>\*(C`create_class()\*(C' is mostly a wrapper around \*(C`create_parser()\*(C' that does loops and stuff and calls \*(C`create_parser()\*(C' to create the actual parsers.</p><p>\*(C`create_parser()\*(C' takes the parser specifications (be they single specifications or multiple specifications) and returns an anonymous coderef that is suitable for use as a method. The coderef will call \*(C`croak()\*(C' in the event of being unable to parse the single string it expects as input.</p><p>The simplest input is that of a single specification, presented just as a plain hash, not a hashref. This is passed directly to \*(C`create_single_parser()\*(C' with the return value from that being wrapped in a function that lets it \*(C`croak()\*(C' on failure, with that wrapper being returned.</p><p>If the first argument to \*(C`create_parser()\*(C' is an arrayref, then that is taken to be an options block (as per the multiple parser specification documented earlier).</p><p>Any further arguments should be either hashrefs or coderefs. If the first argument after the optional arrayref is not a hashref or coderef then that argument and all remaining arguments are passed off to \*(C`create_single_parser()\*(C' directly. If the first argument is a hashref or coderef, then it and the remaining arguments are passed to \*(C`create_multiple_parsers()\*(C'.</p><p>The resultant coderef from calling either of the creation methods is then wrapped in a function that calls \*(C`croak()\*(C' in event of failure or the \*(C`DateTime\*(C' object in event of success.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FINDING IMPLEMENTATIONS</h2>
        <div class="sectioncontent">
<p>\*(C`Parser\*(C' automatically loads any parser classes in @INC.</p><p>To be loaded automatically, you must be a \*(C`DateTime::Format::Builder::Parser::XXX\*(C' module.</p><p>To be invisible, and not loaded, start your class with a lower class letter. These are ignored.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING A PARSER IMPLEMENTATION</h2>
        <div class="sectioncontent">
<h3>Naming your parser</h3>
<p>Create a module and name it in the form \*(C`DateTime::Format::Builder::Parser::XXX\*(C' where <em>\s-1XXX\s0</em> is whatever you like, so long as it doesn't start with a lower case letter.</p><p>Alternatively, call it something completely different if you don't mind the users explicitly loading your module.</p><p>I'd recommend keeping within the \*(C`DateTime::Format::Builder\*(C' namespace though --- at the time of writing I've not given thought to what non-auto loaded ones should be called. Any ideas, please email me.</p>
<h3>Declaring specification arguments</h3>
<p>Call \*(C`&lt;DateTime::Format::Builder::Parser-\*(C'<em>valid_params()</em>&gt;&gt; with \*(C`Params::Validate\*(C' style arguments. For example:</p><p>   DateTime::Format::Builder::Parser-&gt;valid_params(        params =&gt; { type =&gt; ARRAYREF },        Regex  =&gt; { type =&gt; SCALARREF, callbacks =&gt; {           &apos;is a regex&apos; =&gt; sub { ref(shift) eq &apos;Regexp&apos; }        }}    );</p><p>Start one of the key names with a capital letter. Ideally that key should match the <em>\s-1XXX\s0</em> from earlier. This will be used to help identify which module a parser specification should be given to.</p><p>The key names <em>on_match</em>, <em>on_fail</em>, <em>postprocess</em>, <em>preprocess</em>, <em>label</em> and <em>length</em> are predefined. You are recommended to make use of them. You may ignore <em>length</em> as \*(C`sort_parsers\*(C' takes care of that.</p>
<h3>Define create_parser</h3>
<p>A class method of the name \*(C`create_parser\*(C' that does the following:</p><p>Its arguments are as for a normal method (i.e. class as first argument). The other arguments are the result from a call to \*(C`Params::Validate\*(C' according to your specification (the \*(C`valid_params\*(C' earlier), i.e. a hash of argument name and value.</p><p>The return value should be a coderef that takes a date string as its first argument and returns either a \*(C`DateTime\*(C' object or \*(C`undef\*(C'.</p>
<h3>Callbacks</h3>
<p>It is preferred that you support some callbacks to your parsers. In particular, \*(C`preprocess\*(C', \*(C`on_match\*(C', \*(C`on_fail\*(C' and \*(C`postprocess\*(C'. See the main Builder docs for the appropriate placing of calls to the callbacks.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>See DateTime::Format::Builder for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO DateTime::Format::Builder::Parser&hellip;</h2>
        <div class="sectioncontent">
<p>\*(C`datetime@perl.org\*(C' mailing list.</p><p>http://datetime.perl.org/</p><p>perl, DateTime, DateTime::Format::Builder.</p><p>Params::Validate.</p><p>DateTime::Format::Builder::Parser::generic, DateTime::Format::Builder::Parser::Dispatch, DateTime::Format::Builder::Parser::Quick, DateTime::Format::Builder::Parser::Regex, DateTime::Format::Builder::Parser::Strptime.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<ul>
<li><p>Dave Rolsky &lt;autarch@urth.org&gt;</p></li><li><p>Iain Truskett</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>This software is Copyright (c) 2013 by Dave Rolsky.</p><p>This is free software, licensed under:</p><p>  The Artistic License 2.0 (GPL Compatible)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="DateTime::Format::Builder.3pm.html"><span aria-hidden="true">&larr;</span> DateTime::Format::Builder.3pm: Create datetime parser classes and objects.</a></li>
   <li class="next"><a href="DateTime::Format::Builder::Parser::Dispatch.3pm.html">DateTime::Format::Builder::Parser::Dispatch.3pm: Dispatch parsers by group <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

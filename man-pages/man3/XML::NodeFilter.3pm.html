<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::NodeFilter: Generic xml::nodefilter class</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Generic xml::nodefilter class">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::NodeFilter (3pm) manual">
  <meta name="twitter:description" content="Generic xml::nodefilter class">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-nodefilter-perl-XML::NodeFilter-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::NodeFilter.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::NodeFilter (3pm) manual" />
  <meta property="og:description" content="Generic xml::nodefilter class" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-nodefilter-perl-XML::NodeFilter-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::NodeFilter<small> (3pm)</small></h1>
        <p class="lead">Generic xml::nodefilter class</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::NodeFilter.3pm.html">
      <span itemprop="name">XML::NodeFilter: Generic xml::nodefilter class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-nodefilter-perl/">
      <span itemprop="name">libxml-nodefilter-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::NodeFilter.3pm.html">
      <span itemprop="name">XML::NodeFilter: Generic xml::nodefilter class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use XML::NodeFilter;

  my $filter = XML::NodeFilter-&gt;new();

  $your_iterator-&gt;set_filter( $filter );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>\*(L"Filters are objects that know how to \*(R"filter out\*(L" nodes. If a NodeIterator or a TreeWalker is given a NodeFilter, it applies the filter before it returns the next node. If the filter says to accept the node, the traversal logic returns it; otherwise, traversal looks for the next node and pretends that the node was rejected was not there.\*(R"</p><p>This definition is given by the \s-1DOM\s0 Traversal and Range Specification. It explains pretty well, what this class is for: A XML::NodeFilter will recieve a node from a traversal object, such as XML::LibXML::Iterator is one and tells if the given node should be returned to the caller or not.</p><p>Although I refere only to XML::LibXML here, XML::NodeFilter is implemented more open, so it can be used with other \s-1DOM\s0 implementations as well.</p><h3>The Spec And The Implementation</h3>
<p>The \s-1DOM\s0 Traversal and Range Specification just defines the contstants and <em>accept_node()</em> for a node filter. The XML::NodeFilter implementation also adds the <em>what_to_show()</em> function to the class definition, since I think that it is a filters job to decide which node-types should be shown and which not.</p><p>Also XML::NodeFilter adds two constants which are not part of the specification. The first one is <strong>\s-1FILTER_DECLINED\s0</strong>. It tells the traversal logic, that it should apply another filter in order to decide if the node should be visible or not. While the spec only defines the traversal logic to have either one or no filter applied, it showed that it leads to cleaner code if more filter could be used in conjunktion. If a traversal logic finds a single filter that returns <strong>\s-1FILTER_DECLINED\s0</strong>, it should be handled as a synonym of <strong>\s-1FILTER_ACCEPT\s0</strong>. While <strong>\s-1FILTER_ACCEPT\s0</strong> is finite and would cause all other not to be executed, <strong>\s-1FILTER_DECLINED\s0</strong> gives one more flexibility.</p><p>The second extension of the specification is the <strong>\s-1SHOW_NONE\s0</strong> symbol. It was added for operational completeness, so one can explicitly switch the node type filter off (means all node types are rejected). This will cause the two calls of what_to_show have a different result:</p><p>  $filter-&gt;what_to_show( undef );     # will set SHOW_ALL   $filter-&gt;what_to_show( SHOW_NONE ); # will not set SHOW_ALL</p><p>Infact <strong>\s-1SHOW_NONE\s0</strong> is a \s-1NULL\s0 flag, that means it can be added to any list of flags without altering it.</p><p>  $filter-&gt;what_to_show( SHOW_ELEMENT | SHOW_TEXT | SHOW_NONE );</p><p>is therefore identical to</p><p>  $filter-&gt;what_to_show( SHOW_ELEMENT | SHOW_TEXT );</p><p><strong>\s-1SHOW_NONE\s0</strong> is espacially usefull to avoid numerically or even more ugly unintialized values while building such flag lists dynamically.</p>
<h3>How To write a Node Filter with XML::NodeFilter?</h3>
<p>Actually writing a node filter becomes very simple with XML::NodeFilter: Simply inherit your specialized node filter from XML::NodeFilter and implement your implement the function <em>accept_node()</em>. This name is more perlish than the name given by the specification. If your implementation needs to stay very close to the specification, you can alternativly implement <em>acceptNode()</em>. Implementing both functions makes no sense, since <em>accept_node()</em> should be prefered by the traversal logic. Because of this <em>acceptNode()</em> will only be called if no <em>accept_node()</em> implementation was given.</p><p>Example:</p><p>   package My::NodeFilter;</p><p>   use XML::NodeFilter qw(:results);    use vars qw(@ISA);    @ISA = qw(XML::NodeFilter);</p><p>   use XML::LibXML::Common;</p><p>   sub accept_node {        my $filter = shift;        my $node   = shift;</p><p>       unless ( $node-&gt;getNodeType == ELEMENT_NODE                 and defined $node-&gt;getNamespaceURI ) {           # ignore node without a defined namespace           return FILTER_REJECT;        }        return FILTER_DECLINED;    }</p><p>   1;</p><p>This example shows a simple nodefilter that will reject any element without a namespace defined. Note that \s-1FILTER_DECLINED\s0 is returned if the node was not rejected. This allows a traversal logic to apply another filter on the nodes with a namespace defined. If your application needs to use different filters on the namespaced elements depending on the state where you want to traverse your \s-1DOM\s0 but you need allways to ignore elements without a namespace such a filter will enshure that you need not to add redundant code to your filter or even to choose a base class.</p>
<h3>How To make use of a XML::NodeFilter Filter?</h3>
<p>If you need to write some traversal code yourself, you should call the node filters <em>accept_node()</em> function to test if the logic should return the current node. A node is not returned if any filter retunrs \s-1FILTER_SKIP\s0 or \s-1FILTER_REJECT\s0. In this case you need to reinvoke your traversal code.</p><p>The following code snippet shows how you can make use of XML::NodeFilter in your traversal logic:</p><p>  use XML::NodeFilter qw(:results);</p><p>  #...   sub traversal_logic {       my $refnode = shift;       my @filters = @_;       my $node = undef;</p><p>      TRAVERSE: while (1) {             my $state = FILTER_DECLINED;             # your traversal logic             # ...             last TRAVERSE unless defined $node;             FILTER: foreach my $filter ( @filters ) {                 $state = $filter-&gt;accept_node($node);                 last TRAVERSE if     $state == FILTER_ACCEPT;                 last FILTER   unless $state == FILTER_DECLINED;                         last TRAVERSE if $state == FILTER_DECLINED;       }</p><p>      return $node;   }</p><p>As you see the traversal code will call only <em>accept_node()</em> on each filter. Still this will work fine with filters, that have <em>acceptNode()</em> implemented: XML::NodeFilter calls <em>acceptNode()</em> if the original <em>accept_node()</em> function is called. This ashures that filters that use function names conform to the specification will work as well.</p><p>Note that XML::NodeFilter uses as default return value of <em>accept_node()</em> \s-1FILTER_ACCEPT\s0 rather than \s-1FILTER_DECLINED\s0. This is done so you can write 100% specification conform traversal and filter logic.</p>
<h3>Functions</h3>

<dl class='dl-vertical'>
  <dt>
    <em>new()</em>
  </dt>
  <dd>
    <p>As the constructor of this class it accepts some parameters in form of a hash. This parameter hash will be blessed into a hash reference. The only parameter used by the class itself is <strong>-show</strong>. This parameter may hold a bitmask of node filter flags as described below or a hash reference containing the same information. If <strong>-show</strong> is ommited \s-1SHOW_ALL\s0 is assumed as default.</p>
  </dd>
  <dt>
    <em>what_to_show()</em>
  </dt>
  <dd>
    <p>This function is added to the filter class, rather than assuming it is available directly from within a traversal logic. <em>what_to_show()</em> takes either a bitmask or a hash that holds the information what nodes should be filtered. If <em>what_to_show()</em> is called without any parameter, it simply returns the bitmaks in scalar context; if called in array context it returns a hash containing the corresponding information: If a bit is set in the bitmask the corresponding key has the value 1; otherwise it has the value 0.</p>
  </dd>
  <dt>
    <em>accept_node()</em>
  </dt>
  <dd>
    <p>This function is used to tell a calling traversal function if a given node should be returned to the caller or should be skipped. It has four possible return values: \s-1FILTER_DECLINED\s0 to indicate that the filter itself would accept if no other (less significant) filters rejects or skips it. <strong>\s-1NOTE\s0</strong> \s-1FILTER_DECLINED\s0 is not defined by the spec. \s-1FILTER_ACCEPT\s0 to indicate that a node is accepted regardless what other filters may indicate. \s-1FILTER_SKIP\s0 to indicate a node is skipped, but its descendants should be still available. \s-1FILTER_REJECT\s0 to indicate a node and all its descendants should be skipped by the traversal logic. By default <em>accept_node()</em> returns \s-1FILTER_ACCEPT\s0.</p>
  </dd>
  <dt>
    <em>acceptNode()</em>
  </dt>
  <dd>
    <p>Alternative function for <em>accept_node()</em>. This is only available for spec conformance. Any traversal logic should request <em>accept_node()</em>. Node filter implementations may choose either to implement <em>accept_node()</em> or <em>acceptNode()</em>. Implmenting both makes no sense at all!</p>
  </dd>

</dl>

<h3>Constants</h3>
<ul>
<li><p>\s-1FILTER_DECLINED\s0 (0) Additional symbol to allow stacked node filters.</p></li><li><p>\s-1FILTER_ACCEPT\s0   (1) Defined by the specification</p></li><li><p>\s-1FILTER_SKIP\s0     (2) Defined by the specification</p></li><li><p>\s-1FILTER_REJECT\s0   (3) Defined by the specification</p></li><li><p>\s-1SHOW_ALL\s0 Defined by the specification</p></li><li><p>\s-1SHOW_ELEMENT\s0 Defined by the specification</p></li><li><p>\s-1SHOW_ATTRIBUTE\s0 Defined by the specification</p></li><li><p>\s-1SHOW_TEXT\s0 Defined by the specification</p></li><li><p>\s-1SHOW_CDATA_SECTION\s0 Defined by the specification</p></li><li><p>\s-1SHOW_ENTITY_REFERENCE\s0 Defined by the specification</p></li><li><p>\s-1SHOW_ENTITY\s0 Defined by the specification</p></li><li><p>\s-1SHOW_PROCESSING_INSTRUCTION\s0 Defined by the specification</p></li><li><p>\s-1SHOW_COMMENT\s0 Defined by the specification</p></li><li><p>\s-1SHOW_DOCUMENT\s0 Defined by the specification</p></li><li><p>\s-1SHOW_DOCUMENT_TYPE\s0 Defined by the specification</p></li><li><p>\s-1SHOW_DOCUMENT_FRAGMENT\s0 Defined by the specification</p></li><li><p>\s-1SHOW_NOTATION\s0 Defined by the specification</p></li><li><p>\s-1SHOW_NONE\s0 Additional symbol to indicate a \s-1NULL\s0 filter. This is for operational completeness.</p></li><li><p>@FLAGNAMES Contains the names of the \s-1FLAGS\s0 used by <em>what_to_show()</em>. The combining symbols \s-1SHOW_ALL\s0 and \s-1SHOW_NONE\s0 are not included by this list.</p></li><li><p>%FLAGMAPPING This hash mapps flagnames (as listed by @FLAGNAMES) to their predefined values. The combining symbols \s-1SHOW_ALL\s0 and \s-1SHOW_NONE\s0 are not included by this list. <strong>\s-1NOTE:\s0</strong> @FLAGNAMES and %FALGMAPPING are not exported. To make use of them you have to use the fully quallified namespace as follows   # gives the value of the SHOW_ELEMENT.   my $flag = $XML::NodeFilter::FLAGMAPPING{SHOW_ELEMENT};</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p>XML::NodeFilter will not export any symbols at all. Instead it gives two tags: ':results' and ':flags'.</p>
<dl class='dl-vertical'>
  <dt>
    :results
  </dt>
  <dd>
    <p>This tag exports the FILTER_* constants. This is usefull to avoid hardcoded numerical values within the filter code or the traversal logic. These symbols are used by <em>accept_node()</em> and are required to indicate the state</p>
  </dd>
  <dt>
    :flags
  </dt>
  <dd>
    <p>Exports SHOW_* flags. Import these symbols if <em>what_to_show()</em> should be used conform to the specification rather than using named parameters.</p>
  </dd>

</dl>
<p>Alternativly you might import ':all' to get all symbols exported by both of the tags just described.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Christian Glahn, &lt;christian.glahn@uibk.ac.at&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::NodeFilter&hellip;</h2>
        <div class="sectioncontent">
<p>perl, XML::LibXML::Iterator, XML::LibXML::NodeFilter</p><p>W3C \s-1DOM\s0 Level 2 Traversal and Range Specification</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>(c) 2002, Christian Glahn. All rights reserved.</p><p>This package is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::Node.3pm.html"><span aria-hidden="true">&larr;</span> XML::Node.3pm: Node-based xml parsing: an simplified interface to xml::parser</a></li>
   <li class="next"><a href="XML::Normalize::LibXML.3pm.html">XML::Normalize::LibXML.3pm: Simple whitespace striping functions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoTextureScalePolicy: The sotexturescalepolicy class is a node for controlling the texture scale policy.  if a texture map is of size != 2^n, it must be scaled before opengl can handle it. this node enables you to control how/if textures are scaled before it is sent to opengl.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sotexturescalepolicy class is a node for controlling the texture scale policy.  if a texture map is of size != 2^n, it must be scaled before opengl can handle it. this node enables you to control how/if textures are scaled before it is sent to opengl.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoTextureScalePolicy (3) manual">
  <meta name="twitter:description" content="The sotexturescalepolicy class is a node for controlling the texture scale policy.  if a texture map is of size != 2^n, it must be scaled before opengl can handle it. this node enables you to control how/if textures are scaled before it is sent to opengl.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoTextureScalePolicy-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoTextureScalePolicy.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoTextureScalePolicy (3) manual" />
  <meta property="og:description" content="The sotexturescalepolicy class is a node for controlling the texture scale policy.  if a texture map is of size != 2^n, it must be scaled before opengl can handle it. this node enables you to control how/if textures are scaled before it is sent to opengl." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoTextureScalePolicy-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoTextureScalePolicy<small> (3)</small></h1>
        <p class="lead">The sotexturescalepolicy class is a node for controlling the texture scale policy.  if a texture map is of size != 2^n, it must be scaled before opengl can handle it. this node enables you to control how/if textures are scaled before it is sent to opengl.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoTextureScalePolicy.3.html">
      <span itemprop="name">SoTextureScalePolicy: The sotexturescalepolicy class is a node for controlling the texture scale policy.  if a texture map is of size != 2^n, it must be scaled before opengl can handle it. this node enables you to control how/if textures are scaled before it is sent to opengl.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoTextureScalePolicy.3.html">
      <span itemprop="name">SoTextureScalePolicy: The sotexturescalepolicy class is a node for controlling the texture scale policy.  if a texture map is of size != 2^n, it must be scaled before opengl can handle it. this node enables you to control how/if textures are scaled before it is sent to opengl.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/nodes/SoTextureScalePolicy.h&gt;</p><p>Inherits <strong>SoNode</strong>.</p><h3>Public Types</h3>
<p>enum <strong>Policy</strong> { <strong>USE_TEXTURE_QUALITY</strong>, <strong>SCALE_DOWN</strong>, <strong>SCALE_UP</strong>, <strong>FRACTURE</strong> }</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> <strong>SoTextureScalePolicy</strong> (void)</p><p>virtual void <strong>GLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p>
<h3>Public Attributes</h3>
<p><strong>SoSFEnum</strong> <strong>policy</strong></p><p><strong>SoSFFloat</strong> <strong>quality</strong></p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual <strong>~SoTextureScalePolicy</strong> ()</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoTextureScalePolicy</strong> class is a node for controlling the texture scale policy.</p><p>If a texture map is of size != 2^n, it must be scaled before OpenGL can handle it. This node enables you to control how/if textures are scaled before it is sent to OpenGL.</p><p>Also, if a texture map is bigger than the maximum OpenGL texture size (implementation and context dependent), it will be scaled down to the maximum size. You can avoid this by setting the texture policy to <strong>SoTextureScalePolicy::FRACTURE</strong>, in which case the texture will be split into several small subtextures before the geometry using the texture is rendered.</p><p>Setting <strong>SoTextureScalePolicy::policy</strong> to <strong>SoTextureScalePolicy::FRACTURE</strong> will also cause the internal texture handling unit in Coin to automatically downsample the individual subtextures to not use more graphics card memory than necessary to cover the current screen size of the texture.</p><p>These two aspects of <strong>SoTextureScalePolicy::FRACTURE</strong> rendering together, subtexture fracturing and automatic downsampling, makes it possible to have textures with almost unlimited size. The only real limit is the amount of memory on the system, since the entire texture must fit into CPU memory.</p><p>The <strong>SoTextureScalePolicy::FRACTURE</strong> policy is also very handy for using the Coin library's built-in handling of non-power-of-2 textures. This will then be done completely transparent to the application programmer, for maximum convenience. Below is a very simple example which demonstrates how to use it. The texture has dimensions 3x3, but no scaling (and thereby interpolation) will have to be done when <strong>SoTextureScalePolicy::FRACTURE</strong> is specified:</p>
<pre>
#Inventor V2.1 ascii

Separator {
   TextureScalePolicy { policy FRACTURE }
   Complexity { textureQuality 0.01 }  # don't generate smoothed mipmaps
   Texture2 {
      image 3 3 4  # dimensions 3x3, RGBA (4-component) image
      0xff0000ff 0x00ff00ff 0x0000ffff  # red, green, blue
      0xffff00ff 0xff00ffff 0x00ffffff  # yellow, magenta, cyan
      0x222222ff 0x777777ff 0xccccccff  # dark, medium and light grey
   }
   Cube { }
}
</pre>
<p>Be aware that the triangle throughput is much slower when using the FRACTURE texture mode, since all triangles need to be clipped (using the CPU) against subtextures. It's therefore usually not a good idea to use the FRACTURE mode on large triangle meshes.</p><p>Be aware that this class is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>FILE FORMAT/DEFAULTS:</strong></p>
<pre>
TextureScalePolicy {
    policy USE_TEXTURE_QUALITY
    quality 0.5
}

</pre>
<p><strong>Since:</strong></p><p>Coin 2.0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoTextureScalePolicy::Policy\fP</h3>
<p>Enumerates the available policy settings.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>USE_TEXTURE_QUALITY </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Uses the texture quality to decide whether to scale up or down.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SCALE_DOWN </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Always scales down.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SCALE_UP </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Always scales up.</p>
  </dd>
  <dt>
    <p><strong></strong><em>FRACTURE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Splits the texture into several subtextures, and clips the geometry into each subtexture. Also automatically downsamples the subtextures to not use more graphics card memory than necessary versus the current screen size of the texture.</p>
  </dd>

</dl>
<p>These two features makes it possible to have textures with almost unlimited size. The only real limit is the amount of memory on the system, since the entire texture must fit into CPU memory.</p><p>Be aware that the rendering is quite slow with this mode if the texture(s) will be mapped onto lots of polygon primitives.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoTextureScalePolicy::SoTextureScalePolicy (void)</h3>
<p>Constructor.</p>
<h3>SoTextureScalePolicy::~SoTextureScalePolicy ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoTextureScalePolicy::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Implements <strong>SoBase</strong>.</p>
<h3>const \fBSoFieldData\fP * SoTextureScalePolicy::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoFieldContainer</strong>.</p>
<h3>void SoTextureScalePolicy::GLRender (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGLRenderAction</strong>.</p><p>This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method.</p><p>Reimplemented from <strong>SoNode</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoSFEnum\fP SoTextureScalePolicy::policy</h3>
<p>The policy setting. Default value is USE_TEXTURE_QUALITY.</p><p>USE_TEXTURE_QUALITY means that <strong>SoComplexity::textureQuality</strong> will be used to decide if the texture should be scaled up or down. <strong>SoComplexity::textureQuality</strong> &gt;= 0.7 means scale up, while &lt; 0.7 means scale down. Textures smaller than 256 pixels are never scaled down since you lose too much information.</p>
<h3>\fBSoSFFloat\fP SoTextureScalePolicy::quality</h3>
<p>The texture scale/resize quality. Default value is 0.5.</p><p>This field can be used to force Coin to use a lower quality (but much faster) image resize function. Currently, if you set this field to a value &lt; 0.5, a low quality resize function will be used, otherwise a high quality (but slow) function will be used.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoTextureQualityElement.3.html"><span aria-hidden="true">&larr;</span> SoTextureQualityElement.3: The sotexturequalityelement is yet to be documented.  fixme: write doc.</a></li>
   <li class="next"><a href="SoTextureUnit.3.html">SoTextureUnit.3: The sotextureunit class is a node for setting the active texture unit.  when an sotextureunit node is inserted into the scene graph, all subsequent texture nodes (sotexture2, sotexturecoordinate2, sotexturecoordinate3, sotexture2transform, sotexture3transform, sotexturecoordinateenvironment, sotexturecoordinateplane and socomplexity) will affect the texture unit set in the unit field. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

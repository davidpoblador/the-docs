<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>epp_dodger: Epp_dodger - bypasses the erlang preprocessor.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Epp_dodger - bypasses the erlang preprocessor.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="epp_dodger (3erl) manual">
  <meta name="twitter:description" content="Epp_dodger - bypasses the erlang preprocessor.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-epp_dodger-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/epp_dodger.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="epp_dodger (3erl) manual" />
  <meta property="og:description" content="Epp_dodger - bypasses the erlang preprocessor." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-epp_dodger-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">epp_dodger<small> (3erl)</small></h1>
        <p class="lead">Epp_dodger - bypasses the erlang preprocessor.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/epp_dodger.3erl.html">
      <span itemprop="name">epp_dodger: Epp_dodger - bypasses the erlang preprocessor.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/epp_dodger.3erl.html">
      <span itemprop="name">epp_dodger: Epp_dodger - bypasses the erlang preprocessor.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>epp_dodger</em> - bypasses the Erlang preprocessor.</p><p>This module tokenises and parses most Erlang source code without expanding preprocessor directives and macro applications, as long as these are syntactically "well-behaved". Because the normal parse trees of the <em>erl_parse</em> module cannot represent these things (normally, they are expanded by the Erlang preprocessor <strong>epp(3erl)</strong> before the parser sees them), an extended syntax tree is created, using the <strong>erl_syntax</strong> module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>errorinfo() = {ErrorLine::integer(), Module::atom(), Descriptor::term()}</em>:</p><p>This is a so-called Erlang I/O ErrorInfo structure; see the <strong>io(3erl)</strong> module for details.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> parse(Dev::IODevice) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Equivalent to <strong>parse(IODevice, 1)</strong>.</p><p><strong></strong> parse(Dev::IODevice, L::StartLine) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Types:</p><p>IODevice = pid()</p><p>StartLine = integer()</p><p>Forms = [syntaxTree() (see module erl_syntax)]</p><p>Equivalent to <strong>parse(IODevice, StartLine, [])</strong>.</p><p><em>See also:</em> <strong>parse/1</strong>.</p><p><strong></strong> parse(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Types:</p><p>IODevice = pid()</p><p>StartLine = integer()</p><p>Options = [term()]</p><p>Forms = [syntaxTree() (see module erl_syntax)]</p><p>Reads and parses program text from an I/O stream. Characters are read from <em>IODevice</em> until end-of-file; apart from this, the behaviour is the same as for <strong>parse_file/2</strong>. <em>StartLine</em> is the initial line number, which should be a positive integer.</p><p><em>See also:</em> <strong>parse/2</strong>, <strong>parse_file/2</strong>, <strong>parse_form/2</strong>, <strong>quick_parse/3</strong>.</p><p><strong></strong> parse_file(File) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Types:</p><p>File = filename() (see module file)</p><p>Forms = [syntaxTree() (see module erl_syntax)]</p><p>Equivalent to <strong>parse_file(File, [])</strong>.</p><p><strong></strong> parse_file(File, Options) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Types:</p><p>File = filename() (see module file)</p><p>Options = [term()]</p><p>Forms = [syntaxTree() (see module erl_syntax)]</p><p>Reads and parses a file. If successful, <em>{ok, Forms}</em> is returned, where <em>Forms</em> is a list of abstract syntax trees representing the "program forms" of the file (cf. <em>erl_syntax:is_form/1</em>). Otherwise, <em>{error, errorinfo()}</em> is returned, typically if the file could not be opened. Note that parse errors show up as error markers in the returned list of forms; they do not cause this function to fail or return <em>{error, errorinfo()}</em>.</p><p>Options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{no_fail, boolean()}</em>: If <em>true</em>, this makes <em>epp_dodger</em> replace any program forms that could not be parsed with nodes of type <em>text</em> (see <strong>erl_syntax:text/1</strong>), representing the raw token sequence of the form, instead of reporting a parse error. The default value is <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{clever, boolean()}</em>: If set to <em>true</em>, this makes <em>epp_dodger</em> try to repair the source code as it seems fit, in certain cases where parsing would otherwise fail. Currently, it inserts <em>++</em>-operators between string literals and macros where it looks like concatenation was intended. The default value is <em>false</em>.</p>
  </dd>

</dl>
<p><em>See also:</em> <strong>parse/2</strong>, <strong>quick_parse_file/1</strong>, <strong>erl_syntax:is_form/1</strong>.</p><p><strong></strong> parse_form(Dev::IODevice, L0::StartLine) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error, errorinfo(), LineNo}</p><p>Types:</p><p>IODevice = pid()</p><p>StartLine = integer()</p><p>Form = syntaxTree() (see module erl_syntax)</p><p>LineNo = integer()</p><p>Equivalent to <strong>parse_form(IODevice, StartLine, [])</strong>.</p><p><em>See also:</em> <strong>quick_parse_form/2</strong>.</p><p><strong></strong> parse_form(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error, errorinfo(), LineNo}</p><p>Types:</p><p>IODevice = pid()</p><p>StartLine = integer()</p><p>Options = [term()]</p><p>Form = syntaxTree() (see module erl_syntax)</p><p>LineNo = integer()</p><p>Reads and parses a single program form from an I/O stream. Characters are read from <em>IODevice</em> until an end-of-form marker is found (a period character followed by whitespace), or until end-of-file; apart from this, the behaviour is similar to that of <em>parse/3</em>, except that the return values also contain the final line number given that <em>StartLine</em> is the initial line number, and that <em>{eof, LineNo}</em> may be returned.</p><p><em>See also:</em> <strong>parse/3</strong>, <strong>parse_form/2</strong>, <strong>quick_parse_form/3</strong>.</p><p><strong></strong> quick_parse(Dev::IODevice) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Equivalent to <strong>quick_parse(IODevice, 1)</strong>.</p><p><strong></strong> quick_parse(Dev::IODevice, L::StartLine) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Types:</p><p>IODevice = pid()</p><p>StartLine = integer()</p><p>Forms = [syntaxTree() (see module erl_syntax)]</p><p>Equivalent to <strong>quick_parse(IODevice, StartLine, [])</strong>.</p><p><em>See also:</em> <strong>quick_parse/1</strong>.</p><p><strong></strong> quick_parse(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Types:</p><p>IODevice = pid()</p><p>StartLine = integer()</p><p>Options = [term()]</p><p>Forms = [syntaxTree() (see module erl_syntax)]</p><p>Similar to <strong>parse/3</strong>, but does a more quick-and-dirty processing of the code. See <strong>quick_parse_file/2</strong> for details.</p><p><em>See also:</em> <strong>parse/3</strong>, <strong>quick_parse/2</strong>, <strong>quick_parse_file/2</strong>, <strong>quick_parse_form/2</strong>.</p><p><strong></strong> quick_parse_file(File) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Types:</p><p>File = filename() (see module file)</p><p>Forms = [syntaxTree() (see module erl_syntax)]</p><p>Equivalent to <strong>quick_parse_file(File, [])</strong>.</p><p><strong></strong> quick_parse_file(File, Options) -&gt; {ok, Forms} | {error, errorinfo()}</p><p>Types:</p><p>File = filename() (see module file)</p><p>Options = [term()]</p><p>Forms = [syntaxTree() (see module erl_syntax)]</p><p>Similar to <strong>parse_file/2</strong>, but does a more quick-and-dirty processing of the code. Macro definitions and other preprocessor directives are discarded, and all macro calls are replaced with atoms. This is useful when only the main structure of the code is of interest, and not the details. Furthermore, the quick-parse method can usually handle more strange cases than the normal, more exact parsing.</p><p>Options: see <strong>parse_file/2</strong>. Note however that for <em>quick_parse_file/2</em>, the option <em>no_fail</em> is <em>true</em> by default.</p><p><em>See also:</em> <strong>parse_file/2</strong>, <strong>quick_parse/2</strong>.</p><p><strong></strong> quick_parse_form(Dev::IODevice, L0::StartLine) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error, errorinfo(), LineNo}</p><p>Types:</p><p>IODevice = pid()</p><p>StartLine = integer()</p><p>Form = syntaxTree() (see module erl_syntax) | none</p><p>LineNo = integer()</p><p>Equivalent to <strong>quick_parse_form(IODevice, StartLine, [])</strong>.</p><p><em>See also:</em> <strong>parse_form/2</strong>.</p><p><strong></strong> quick_parse_form(Dev::IODevice, L0::StartLine, Options) -&gt; {ok, Form, LineNo} | {eof, LineNo} | {error, errorinfo(), LineNo}</p><p>Types:</p><p>IODevice = pid()</p><p>StartLine = integer()</p><p>Options = [term()]</p><p>Form = syntaxTree() (see module erl_syntax)</p><p>LineNo = integer()</p><p>Similar to <strong>parse_form/3</strong>, but does a more quick-and-dirty processing of the code. See <strong>quick_parse_file/2</strong> for details.</p><p><em>See also:</em> <strong>parse/3</strong>, <strong>parse_form/3</strong>, <strong>quick_parse_form/2</strong>.</p><p><strong></strong> tokens_to_string(Tokens::[term()]) -&gt; string()</p><p>Generates a string corresponding to the given token sequence. The string can be re-tokenized to yield the same token list again.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Richard Carlsson <em></em> &lt;carlsson.richard@gmail.com&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="epp.3erl.html"><span aria-hidden="true">&larr;</span> epp.3erl: An erlang code preprocessor</a></li>
   <li class="next"><a href="eprof.3erl.html">eprof.3erl: A time profiling tool for erlang <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

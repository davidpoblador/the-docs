<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>netcdf_f90: Unidata network common data form (netcdf) library, version 3 interface</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Unidata network common data form (netcdf) library, version 3 interface">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="netcdf_f90 (3f90) manual">
  <meta name="twitter:description" content="Unidata network common data form (netcdf) library, version 3 interface">
  <meta name="twitter:image" content="https://www.carta.tech/images/libnetcdf-dev-netcdf_f90-3f90.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3f90/netcdf_f90.3f90.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="netcdf_f90 (3f90) manual" />
  <meta property="og:description" content="Unidata network common data form (netcdf) library, version 3 interface" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libnetcdf-dev-netcdf_f90-3f90.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">netcdf_f90<small> (3f90)</small></h1>
        <p class="lead">Unidata network common data form (netcdf) library, version 3 interface</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3f90/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3f90/netcdf_f90.3f90.html">
      <span itemprop="name">netcdf_f90: Unidata network common data form (netcdf) library, version 3 interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libnetcdf-dev/">
      <span itemprop="name">libnetcdf-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3f90/netcdf_f90.3f90.html">
      <span itemprop="name">netcdf_f90: Unidata network common data form (netcdf) library, version 3 interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>use netcdf</p><h3>Most Systems:</h3>
<p>f90 ... -lnetcdf</p>
<h3>CRAY PVP Systems:</h3>
<p>f90 -dp -i64 ... -lnetcdf</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIBRARY VERSION</h2>
        <div class="sectioncontent">
<p>This document describes version 3 of Unidata netCDF data-access interface for the Fortran-90 programming language. <strong>character*80 nf90_inq_libvers(\|)</strong></p><p>character(len=80) :: nf90_inq_libvers</p><p>Returns a string identifying the version of the netCDF library, and when it was built, like: "3.1a of Aug 22 1996 12:57:47 $".</p><p>The RCS <a href="../man1/ident.1.html"><strong>ident</strong>(1)</a></strong> command will find a string like "$\|Id: @\|(#) netcdf library version 3.1a of Sep  6 1996 15:56:26 $" in the library. The SCCS <strong>what</strong>(1)</strong> command will find a string like "netcdf library version 3.1a of Aug 23 1996 16:07:40 $".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ROUTINE DESCRIPTIONS</h2>
        <div class="sectioncontent">
<p>All netCDF functions (except <strong>nf90_inq_libvers(\|)</strong> and <strong>nf90_strerror(\|)</strong>) return an integer status. This behavior replaces the <strong>rcode</strong> argument used in previous versions of the library. If this returned status value is not equal to <strong>nf90_noerr</strong> (zero), it indicates that an error occurred. The possible status values are defined in the module <strong>netcdf</strong>. <strong>function nf90_strerror(</strong><em>ncerr</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncerr
character(len=80) :: nf90_strerror
</pre>
<p>Returns a string textual translation of the <em>ncerr</em> value, like "Attribute or variable name contains illegal characters" or "No such file or directory".</p><p><strong>function nf90_create(</strong><em>path</em><strong>, </strong><em>cmode</em><strong>, </strong><em>ncid</em><strong>)</strong></p>
<pre>
character(len=*), intent(in) :: path
integer, intent(in) :: cmode
integer, optional, intent(in) :: initialsize
integer, optional, intent(inout) :: chunksize
integer, intent(out) :: ncid
integer :: nf90_create
</pre>
<p>(Corresponds to <strong>nccre(\|)</strong> in version 2)</p><p>Creates a new netCDF dataset at <em>path</em>, returning a netCDF ID in <em>ncid</em>. The argument <em>cmode</em> may include the bitwise-or of the following flags: <strong>nf90_noclobber</strong> to protect existing datasets (default silently blows them away), <strong>nf90_share</strong> for synchronous dataset updates (default is to buffer accesses), and <strong>nf90_lock</strong> (not yet implemented). When a netCDF dataset is created, is is opened <strong>nf90_write</strong>. The new netCDF dataset is in define mode.</p><p>The optional argument <em>initialsize</em> sets the initial size of the file at creation time.</p><p>See <strong>nf__open(\|)</strong> below for an explanation of the optional <em>chunksize</em> argument.</p><p><strong>function nf90_open(</strong><em>path</em><strong>, </strong><em>mode</em><strong>, </strong><em>ncid</em><strong>, </strong><em>chunksize</em><strong>)</strong></p>
<pre>
character(len=*), intent(in) :: path
integer, intent(in) :: mode
integer, intent(out) :: ncid
integer, optional, intent(inout) :: chunksize
integer :: nf90_open
</pre>
<p>(Corresponds to <strong>ncopn(\|)</strong> in version 2)</p><p>Opens a existing netCDF dataset at <em>path</em> returning a netCDF ID in <em>ncid</em>. As of NetCDF version 4.1, and if DAP support was enabled when the library was built, the path may instead specify a DAP URL (refer to the NetCDF user's manual for details).</p><p>The type of access is described by the <em>mode</em> parameter, which may include the bitwise-or of the following flags: <strong>nf90_write</strong> for read-write access (default read-only), <strong>nf90_share</strong> for synchronous dataset updates (default is to buffer accesses), and <strong>nf90_lock</strong> (not yet implemented).</p><p>The optional argument referenced by <em>chunksize</em> controls a space versus time tradeoff, memory allocated in the netcdf library versus number of system calls. Because of internal requirements, the value may not be set to exactly the value requested. The actual value chosen is returned by reference. Using the value <strong>nf90_sizehint_default</strong> causes the library to choose a default. How the system choses the default depends on the system. On many systems, the "preferred I/O block size" is available from the <strong>stat()</strong> system call, <strong>struct stat</strong> member <strong>st_blksize</strong>. If this is available it is used. Lacking that, twice the system pagesize is used. Lacking a call to discover the system pagesize, we just set default chunksize to 8192.</p><p>The chunksize is a property of a given open netcdf descriptor <em>ncid</em>: it is not a persistent property of the netcdf dataset.</p><p><strong>function nf90_set_fill(</strong><em>ncid</em><strong>, </strong><em>fillmode</em><strong>, </strong><em>old_mode</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid, fillmode
integer, intent(out) :: old_mode
integer :: nf90_set_fill
</pre>
<p>Sets the fill-mode for a netCDF dataset to optimize writes under some circumstances. The fill-mode argument, <em>fillmode</em>, can be either <strong>nf90_fill</strong> or <strong>nf90_nofill</strong>. <strong>nf90_fill</strong> causes fill-values to be written into non-record variables and into skipped-over records when writing beyond the last valid record. <strong>nf90_nofill</strong> suspends this behavior. The default behavior corresponds to <strong>nf90_fill</strong>.</p><p>The previous fill-mode value is return in <em>old_mode</em>.</p><p>The fill-mode is a property of a given open netcdf descriptor <em>ncid</em>: it is not a persistent property of the netcdf dataset.</p><p><strong>function nf90_redef(</strong><em>ncid</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
integer :: nf90_redef
</pre>
<p>(Corresponds to <strong>ncredf(\|)</strong> in version 2)</p><p>Puts an open netCDF dataset into define mode, so dimensions, variables, and attributes can be added or renamed and attributes can be deleted.</p><p><strong>function nf90_enddef(</strong><em>ncid</em><strong>, </strong><em>h_minfree</em><strong>, </strong><em>v_align</em><strong>,</strong> <em>v_minfree</em>, <em>r_align</em>)</p>
<pre>
integer, intent(in) :: ncid
integer, optional, intent(in) :: h_minfree, v_align
integer, optional, intent(in) :: v_minfree, r_align
integer :: nf90_enddef
</pre>
<p>(Corresponds to <strong>ncendf(\|)</strong> in version 2)</p><p>Takes an open netCDF dataset out of define mode. The changes made to the netCDF dataset while it was in define mode are checked and committed to disk if no problems occurred.  Some data values may be written as well, see "VARIABLE PREFILLING" below. After a successful call, variable data can be read or written to the dataset.</p><p>The optional arguments are performance tuning parameters. They exposes internals of the netcdf version 1 file format and may not be available on future netcdf implementations.</p><p>The current netcdf file format has three sections, the "header" section, the data section for fixed size variables, and the data section for variables which have an unlimited dimension (record variables). The header begins at the beginning of the file. The index (offset) of the beginning of the other two sections is contained in the header. Typically, there is no space between the sections. This causes copying overhead to accrue if one wishes to change the size of the sections, as may happen when changing names of things, text attribute values, adding attributes or adding variables. Also, for buffered i/o, there may be advantages to aligning sections in certain ways.</p><p>The minfree parameters allow one to control costs of future calls to <strong>nf90_redef(\|)</strong>, <strong>nf90_enddef(\|)</strong> by requesting that <em>minfree</em> bytes be available at the end of the section. The <em>h_minfree</em> parameter sets the pad at the end of the "header" section. The <em>v_minfree</em> parameter sets the pad at the end of the data section for fixed size variables.</p><p>The align parameters allow one to set the alignment of the beginning of the corresponding sections. The beginning of the section is rounded up to an index which is a multiple of the align parameter. The flag value <strong>nf90_align_chunk</strong> tells the library to use the chunksize (see above) as the align parameter. The <em>v_align</em> parameter controls the alignment of the beginning of the data section for fixed size variables. The <em>r_align</em> parameter controls the alignment of the beginning of the data section for variables which have an unlimited dimension (record variables).</p><p>The file format requires mod 4 alignment, so the align parameters are silently rounded up to multiples of 4. The usual call, <strong>nf90_enddef(</strong><em>ncid</em><strong>)</strong> is equivalent to <strong>nf__enddef(</strong><em>ncid</em><strong>, 0, 4, 0, 4)</strong>.</p><p>The file format does not contain a "record size" value, this is calculated from the sizes of the record variables. This unfortunate fact prevents us from providing minfree and alignment control of the "records" in a netcdf file. If you add a variable which has an unlimited dimension, the third section will always be copied with the new variable added.</p><p><strong>function nf90_sync(</strong><em>ncid</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
integer :: nf90_sync
</pre>
<p>(Corresponds to <strong>ncsnc(\|)</strong> in version 2)</p><p>Unless the <strong>nf90_share</strong> bit is set in <strong>nf90_open(\|)</strong> or <strong>nf90_create(\|)</strong>, accesses to the underlying netCDF dataset are buffered by the library. This function synchronizes the state of the underlying dataset and the library. This is done automatically by <strong>nf90_close(\|)</strong> and <strong>nf90_enddef(\|)</strong>.</p><p><strong>function nf90_abort(</strong><em>ncid</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
integer :: nf90_abort
</pre>
<p>(Corresponds to <strong>ncabor(\|)</strong> in version 2)</p><p>You don't need to call this function. This function is called automatically by <strong>nf90_close(\|)</strong> if the netCDF dataset was in define mode and something goes wrong with the commit. If the netCDF dataset isn't in define mode, then this function is equivalent to <strong>nf90_close(\|)</strong>. If it is called after <strong>nf90_redef(\|)</strong>, but before <strong>nf90_enddef(\|)</strong>, the new definitions are not committed and the dataset is closed. If it is called after <strong>nf90_create(\|)</strong> but before <strong>nf90_enddef(\|)</strong>, the dataset disappears.</p><p><strong>function nf90_close(</strong><em>ncid</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
integer :: nf90_close
</pre>
<p>(Corresponds to <strong>ncclos(\|)</strong> in version 2)</p><p>Closes an open netCDF dataset. If the dataset is in define mode, <strong>nf90_enddef(\|)</strong> will be called before closing. After a dataset is closed, its ID may be reassigned to another dataset.</p><p><strong>function nf90_inquire(</strong><em>ncid</em><strong>, </strong><em>ndims</em><strong>, </strong><em>nvars</em><strong>,</strong> <em>natts</em>, <em>unlimdimid</em>, <em>nformat</em>)</p>
<pre>
integer, intent(in) :: ncid
integer, optional, intent(out) :: ndims, nvars
integer, optional, intent(out) :: natts, unlimdimid
integer, optional, intent(out) :: nformat
integer :: nf90_inquire
</pre>
<p>Inquire about an open netCDF dataset. <em>ncid</em> is the netCDF ID of the open dataset. Upon successful return, <em>ndims</em> will contain  the number of dimensions defined for this netCDF dataset, <em>nvars</em> will contain the number of variables, <em>natts</em> will contain the number of attributes, and <em>unlimdimid</em> will contain the dimension ID of the unlimited dimension if one exists, or 0 otherwise. <em>nformat</em> will contain the format version number, rarely needed because the library detects the format version and behaves appropriately.</p><p><strong>function nf90_def_dim(</strong><em>ncid</em><strong>, </strong><em>name</em><strong>, </strong><em>len</em><strong>, </strong><em>dimid</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
character(len=*), intent(in) :: name
integer, intent(in) :: len
integer, intent(out) :: dimid
integer :: nf90_def_dim
</pre>
<p>(Corresponds to <strong>ncddef(\|)</strong> in version 2)</p><p>Adds a new dimension to an open netCDF dataset, which must be in define mode. <em>name</em> is the dimension name. <em>len</em> is the size of the new dimension or <strong>nf90_unlimited</strong> to define the unlimited dimension. On return, <em>dimid</em> will contain the dimension ID of the newly created dimension.</p><p><strong>function nf90_inq_dimid(</strong><em>ncid</em><strong>, </strong><em>name</em><strong>, </strong><em>dimid</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
character(len=*), intent(in) :: name
integer, intent(out) :: dimid
integer :: nf90_inq_dimid
</pre>
<p>(Corresponds to <strong>ncdid(\|)</strong> in version 2)</p><p>Given an open netCDF dataset and dimension name, returns the dimension ID of the netCDF dimension in <em>dimid</em>.</p><p><strong>function nf90_inquire_dimension(</strong><em>ncid</em><strong>, </strong><em>dimid</em><strong>, </strong><em>name</em><strong>, </strong><em>len</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid, dimid
character(len=*), optional, intent(out) :: name
integer, optional, intent(out) :: len
integer :: nf90_inquire_dimension
</pre>
<p>Inquire about a dimension. <em>name</em> should be  big enough (<strong>nf90_max_name</strong>) to hold the dimension name as the name will be copied into your storage. The length return parameter, <em>len</em> will contain the size of the dimension. For the unlimited dimension, the returned length is the current maximum value used for writing into any of the variables which use the dimension.</p><p><strong>function nf90_rename_dim(</strong><em>ncid</em><strong>, </strong><em>dimid</em><strong>, </strong><em>name</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
character(len=*), intent(in) :: name
integer, intent(in) :: dimid
integer :: nf90_rename_dim
</pre>
<p>(Corresponds to <strong>ncdren(\|)</strong> in version 2)</p><p>Renames an existing dimension in an open netCDF dataset. If the new name is longer than the old name, the netCDF dataset must be in define mode. You cannot rename a dimension to have the same name as another dimension.</p><p><strong>function nf90_def_var(</strong><em>ncid</em><strong>, </strong><em>name</em><strong>, </strong><em>xtype</em><strong>, </strong><em>dimids</em><strong>, </strong><em>varid</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
character(len=*), intent(in) :: name
integer, intent(in) :: xtype
integer, optional, dimension(:), intent(in) :: dimids
integer :: nf90_def_var
</pre>
<p>(Corresponds to <strong>ncvdef(\|)</strong> in version 2)</p><p>Adds a new variable to a netCDF dataset. The netCDF must be in define mode. <em>name</em> will be the name of the netCDF variable. <em>xtype</em> is the external, netCDF type of the variable and should be one of <strong>nf90_byte</strong>, <strong>nf90_char</strong>, <strong>nf90_short</strong>, <strong>nf90_int</strong>, <strong>nf90_float</strong>, or <strong>nf90_double</strong>, The optional <em>dimids</em> argument contains the dimension ID-s of the domain of the netCDF variable and, consequently, determines the rank of the created variable: if <em>dimids</em> is omitted, then the netCDF variable will be a scalar; if <em>dimids</em> is a scalar, then the netCDF variable will be 1 dimensional; and if <em>dimids</em> is a vector, then the netCDF variable will have rank equal to the number of elements in <em>dimids</em>. <em>varid</em> will be set to the netCDF variable ID.</p><p><strong>function nf90_inq_varid(</strong><em>ncid</em><strong>, </strong><em>name</em><strong>, </strong><em>varid</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid
character(len=*), intent(in) :: name
integer, intent(out) :: varid
integer :: nf90_inq_varid
</pre>
<p>(Corresponds to <strong>ncvid(\|)</strong> in version 2)</p><p>Returns the ID of a netCDF variable in <em>varid</em> given an open netCDF dataset and the name of the variable.</p><p><strong>function nf90_inquire_variable(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>name</em><strong>,</strong> <em>xtype</em>, <em>ndims</em>, <em>dimids</em>, <em>natts</em>)</p>
<pre>
integer, intent(in) :: ncid, varid
character(len=*), optional, intent(out) :: name
integer, optional, intent(out) :: xtype, ndims
integer, dimension(*), optional, intent(out) :: dimids
integer, optional, intent(out) :: natts
integer :: nf90_inquire_variable
</pre>
<p>Inquire about a netCDF variable in an open netCDF dataset, given its variable ID. On return, <em>name</em> will contain the name of the variable and should be capacious enough (<strong>nf90_max_name</strong>). <em>xtype</em> will contain the external, netCDF type of the variable. <em>ndims</em> will contain the dimensionality of the netCDF variable: if the variable is a scalar, then size(<em>ndims</em>) will be zero; otherwise, size(<em>ndims</em>) will be the rank of the variable and <em>ndims</em> will contain the dimension ID-s of the netCDF dimensions that constitute the domain of the variable. <em>natts</em> will contain the number of attributes associated with the netCDF variable.</p><p><strong>function nf90_rename_var(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>name</em><strong>)</strong></p>
<pre>
integer, intent9in) :: ncid, varid
character(len=*), intent(in) :: newname
integer :: nf90_rename_var
</pre>
<p>(Corresponds to <strong>ncvren(\|)</strong> in version 2)</p><p>Changes the name of a netCDF variable. If the new name is longer than the old name, the netCDF must be in define mode. You cannot rename a variable to have the name of any existing variable.</p><p><strong>function nf90_put_var(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>values</em><strong>,</strong> <em>start</em>, <em>stride</em>, <em>imap</em>)</p>
<pre>
integer, intent(in) :: ncid, varid
&lt;&lt;whatever&gt;&gt;, intent(in) :: values
integer, dimension(:), optional, intent(in) :: start
integer, dimension(:), optional, intent(in) ::  stride
integer, dimension(:), optional, intent(in) ::  imap
integer :: nf90_put_var
</pre>
<p>(Replaces <strong>ncvpt(\|)</strong> in version 2)</p><p>Writes a value or values to a netCDF variable. The netCDF dataset must be open and in data mode. <em>values</em> contains the value(s) what will be written to the netCDF variable identified by <em>ncid</em> and <em>varid</em>; it may be a scalar or an array and must be of type <strong>character</strong>, <strong>integer(kind=OneByteInt)</strong>, <strong>integer(kind=TwoByteInt)</strong>, <strong>integer(kind=FourByteInt)</strong>, <strong>integer(kind=EightByteInt)</strong>, <strong>real(kind=FourByteReal)</strong>, or <strong>real(kind=EightByteReal)</strong>. All values are converted to the external type of the netCDF variable, if possible; otherwise, an <strong>nf90_erange</strong> error is returned. The optional argument <em>start</em> specifies the starting index in the netCDF variable for writing for each dimension of the netCDF variable. The optional argument <em>stride</em> specifies the sampling stride (the interval between accessed values in the netCDF variable) for each dimension of the netCDF variable (see COMMON ARGUMENT DESCRIPTIONS below). The optional argument <em>imap</em> specifies the in-memory arrangement of the data values (see COMMON ARGUMENT DESCRIPTIONS below).</p><p><strong>function nf90_get_var(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>values</em><strong>,</strong> <em>start</em>, <em>stride</em>, <em>imap</em>)</p>
<pre>
integer, intent(in) :: ncid, varid
&lt;&lt;whatever&gt;&gt;, intent(out) :: values
integer, dimension(:), optional, intent(in) :: start
integer, dimension(:), optional, intent(in) ::  stride
integer, dimension(:), optional, intent(in) ::  imap
integer :: nf90_get_var
</pre>
<p>(Replaces <strong>ncvgt(\|)</strong> in version 2)</p><p>Reads a value or values from a netCDF variable. The netCDF dataset must be open and in data mode. <em>values</em> will receive the value(s) what will be read from the netCDF  variable identified by <em>ncid</em> and <em>varid</em>; it may be a scalar or an array and must be of type <strong>character</strong>, <strong>integer(kind=OneByteInt)</strong>, <strong>integer(kind=TwoByteInt)</strong>, <strong>integer(kind=FourByteInt)</strong>, <strong>integer(kind=EightByteInt)</strong>, <strong>real(kind=FourByteReal)</strong>, or <strong>real(kind=EightByteReal)</strong>. All values are converted from the external type of the netCDF variable, if possible; otherwise, an <strong>nf90_erange</strong> error is returned. The optional argument <em>start</em> specifies the starting index in the netCDF variable for reading for each dimension of the netCDF variable. The optional argument <em>stride</em> specifies the sampling stride (the interval between accessed values in the netCDF variable) for each dimension of the netCDF variable (see COMMON ARGUMENT DESCRIPTIONS below). The optional argument <em>imap</em> specifies the in-memory arrangement of the data values (see COMMON ARGUMENT DESCRIPTIONS below).</p><p><strong>function nf90_inquire_attribute(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>name</em><strong>,</strong> <em>xtype</em>, <em>len</em>, <em>attnum</em>)</p>
<pre>
integer, intent(in) :: ncid, varid
character(len=*), intent(in) :: name
integer, optional, intent(out) :: xtype, len, attnum
integer :: nf90_inquire_attribute
</pre>
<p>Inquires about the netCDF attribute named <em>name</em>, of variable <em>varid</em>, in the open netCDF dataset <em>ncid</em>. <em>xtype</em> will contain the external, netCDF type of the variable. <em>len</em> will contain the number of elements in the attribute. <em>attnum</em> will contain the attribute number.</p><p><strong>function nf90_inq_attname(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>attnum</em><strong>,</strong> <em>name</em>)</p>
<pre>
integer, intent(in) :: ncid, varid, attnum
character(len=*), intent(out) :: name
integer :: nf90_inq_attname
</pre>
<p>(Corresponds to <strong>ncanam(\|)</strong> in version 2)</p><p>Gets the name of an attribute, given its variable ID and attribute number. This function is useful in generic applications that need to get the names of all the attributes associated with a variable because attributes are accessed by name rather than number in all other attribute functions (the number of an attribute is more volatile than the name because it can change when other attributes of the same variable are deleted).  The attributes for each variable are numbered from 1 (the first attribute) to <em>natts</em>, where <em>natts</em> is the number of attributes for the variable, as returned from a call to <strong>nf90_inquire_variable(\|)</strong>.</p><p><strong>function nf90_put_att(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>name</em><strong>,</strong> <em>values</em>)</p>
<pre>
integer, intent(in) :: ncid, varid
character(len=*), intent(in) :: name
&lt;&lt;whatever&gt;&gt;, intent(in) :: values
integer :: nf90_put_att
</pre>
<p>Unlike variables, attributes do not have separate functions for defining and writing values. This function defines a new attribute with a value or changes the value of an existing attribute. If the attribute is new, or if the space required to store the attribute value is greater than before, the netCDF dataset must be in define mode. <em>values</em> contains the attribute values to be written; it may be a scalar or a vector and must be of type <strong>character</strong>, <strong>integer(kind=OneByteInt)</strong>, <strong>integer(kind=TwoByteInt)</strong>, <strong>integer(kind=FourByteInt)</strong>, <strong>integer(kind=EightByteInt)</strong>, <strong>real(kind=FourByteReal)</strong>, or <strong>real(kind=EightByteReal)</strong>.</p><p><strong>function nf90_get_att(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>name</em><strong>,  fIvalues</strong><em>)</em></p>
<pre>
integer, intent(in) :: ncid, varid
character(len=*), intent(in) :: name
&lt;&lt;whatever&gt;&gt;, intent(out) :: values
integer :: nf90_get_att
</pre>
<p>(Replaces <strong>ncagt(\|)</strong> in version 2)</p><p>Gets the value(s) of a netCDF attribute, given its variable ID and name. The values are returned in <em>values</em>, which must be of type <strong>character</strong>, <strong>integer(kind=OneByteInt)</strong>, <strong>integer(kind=TwoByteInt)</strong>, <strong>integer(kind=FourByteInt)</strong>, <strong>integer(kind=EightByteInt)</strong>, <strong>real(kind=FourByteReal)</strong>, or <strong>real(kind=EightByteReal)</strong>. Converts from the external type to the type of the receiving variable, if possible; otherwise returns an <strong>nf90_erange</strong> error. All values of the attribute are returned, so you must allocate enough space to hold them.  If you don't know how much space to reserve, call <strong>nf90_inquire_attribute(\|)</strong> first to find out the length of the attribute.</p><p><strong>function nf90_copy_att(</strong><em>ncid_in</em><strong>, </strong><em>varid_in</em><strong>, </strong><em>name</em><strong>,</strong> <em>ncid_out</em>, <em>varid_out</em>)</p>
<pre>
integer, intent(in) :: ncid_in, varid_in
character(len=*), intent(in) :: name
integer, intent(in) :: ncid_out, varid_out
integer :: nf90_copy_att
</pre>
<p>(Corresponds to <strong>ncacpy(\|)</strong> in version 2)</p><p>Copies an attribute from one netCDF dataset to another.  It can also be used to copy an attribute from one variable to another within the same netCDF dataset. <em>ncid_in</em> is the netCDF ID of an input netCDF dataset from which the attribute will be copied. <em>varid_in</em> is the ID of the variable in the input netCDF dataset from which the attribute will be copied, or <strong>nf90_global</strong> for a global attribute. <em>name</em> is the name of the attribute in the input netCDF dataset to be copied. <em>ncid_out</em> is the netCDF ID of the output netCDF dataset to which the attribute will be copied. It is permissible for the input and output netCDF ID's to be the same.  The output netCDF dataset should be in define mode if the attribute to be copied does not already exist for the target variable, or if it would cause an existing target attribute to grow. <em>varid_out</em> is the ID of the variable in the output netCDF dataset to which the attribute will be copied, or <strong>nf90_global</strong> to copy to a global attribute.</p><p><strong>function nf90_rename_att(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>name</em><strong>,</strong> <em>newname</em>)</p>
<pre>
integer, intent(in) :: ncid, varid
character(len=*), intent(in) :: name, newname
integer :: nf90_rename_att
</pre>
<p>(Corresponds to <strong>ncaren(\|)</strong></p><p>Changes the name of an attribute.  If the new name is longer than the original name, the netCDF must be in define mode.  You cannot rename an attribute to have the same name as another attribute of the same variable. <em>name</em> is the original attribute name. <em>newname</em> is the new name to be assigned to the specified attribute.  If the new name is longer than the old name, the netCDF dataset must be in define mode. <strong>function nf90_del_att(</strong><em>ncid</em><strong>, </strong><em>varid</em><strong>, </strong><em>name</em><strong>)</strong></p>
<pre>
integer, intent(in) :: ncid, varid
character(len=*), intent(in) :: name
integer :: nf90_del_att
</pre>
<p>(Corresponds to <strong>ncadel(\|)</strong> in version 2)</p><p>Deletes an attribute from a netCDF dataset.  The dataset must be in define mode.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMON ARGUMENT DESCRIPTIONS</h2>
        <div class="sectioncontent">
<p>In this section we define some common arguments which are used in the "FUNCTION DESCRIPTIONS" section.</p>
<dl class='dl-vertical'>
  <dt>
    <p>integer <em>ncid</em></p>
  </dt>
  <dd>
    <p>is the netCDF ID returned from a previous, successful call to <strong>nf90_open(\|)</strong> or <strong>nf90_create(\|)</strong></p>
  </dd>
  <dt>
    <p>character(len=*) <em>name</em></p>
  </dt>
  <dd>
    <p>is the name of a dimension, variable, or attribute. It shall begin with an alphabetic character, followed by zero or more alphanumeric characters including the underscore (`_') or hyphen (`-').  Case is significant. The maximum allowable number of characters is <strong>nf90_max_name</strong>. Names that begin with an underscore (`_') are reserved for use by the netCDF interface.</p>
  </dd>
  <dt>
    <p>integer <em>xtype</em></p>
  </dt>
  <dd>
    <p>specifies the external data type of a netCDF variable or attribute and is one of the following: <strong>nf90_byte</strong>, <strong>nf90_char</strong>, <strong>nf90_short</strong>, <strong>nf90_int</strong>, <strong>nf90_float</strong>, or <strong>nf90_double</strong>. These are used to specify 8-bit integers, characters, 16-bit integers, 32-bit integers, 32-bit IEEE floating point numbers, and 64-bit IEEE floating-point numbers, respectively.</p>
  </dd>
  <dt>
    <p>integer <em>dimids</em></p>
  </dt>
  <dd>
    <p>is a vector of dimension ID's and defines the shape of a netCDF variable. The size of the vector shall be greater than or equal to the rank (i.e. the number of dimensions) of the variable (<em>ndims</em>). The vector shall be ordered by the speed with which a dimension varies: <em>dimids</em>(\|1) shall be the dimension ID of the most rapidly varying dimension and <em>dimids</em>(<em>ndims</em>) shall be the dimension ID of the most slowly varying dimension. The maximum possible number of dimensions for a variable is given by the symbolic constant <strong>nf90_max_var_dims</strong>.</p>
  </dd>
  <dt>
    <p>integer <em>dimid</em></p>
  </dt>
  <dd>
    <p>is the ID of a netCDF dimension. netCDF dimension ID's are allocated sequentially from the positive integers beginning with 1.</p>
  </dd>
  <dt>
    <p>integer <em>ndims</em></p>
  </dt>
  <dd>
    <p>is either the total number of dimensions in a netCDF dataset or the rank (i.e. the number of dimensions) of a netCDF variable. The value shall not be negative or greater than the symbolic constant <strong>nf90_max_var_dims</strong>.</p>
  </dd>
  <dt>
    <p>integer <em>varid</em></p>
  </dt>
  <dd>
    <p>is the ID of a netCDF variable or (for the attribute-access functions) the symbolic constant <strong>nf90_global</strong>, which is used to reference global attributes. netCDF variable ID's are allocated sequentially from the positive integers beginning with 1.</p>
  </dd>
  <dt>
    <p>integer <em>natts</em></p>
  </dt>
  <dd>
    <p>is the number of global attributes in a netCDF dataset  for the <strong>nf90_inquire(\|)</strong> function or the number of attributes associated with a netCDF variable for the <strong>nf90_varinq(\|)</strong> function.</p>
  </dd>
  <dt>
    <p>integer <em>start</em></p>
  </dt>
  <dd>
    <p>specifies the starting point for accessing a netCDF variable's data values in terms of the indicial coordinates of the corner of the array section. The indices start at 1; thus, the first data value of a variable is (1, 1, ..., 1). The size of the vector shall be at least the rank of the associated netCDF variable and its elements shall correspond, in order, to the variable's dimensions.</p>
  </dd>
  <dt>
    <p>integer <em>stride</em></p>
  </dt>
  <dd>
    <p>specifies the sampling interval along each dimension of the netCDF variable.   The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (<strong>stride</strong>(1)) gives the sampling interval along the most rapidly varying dimension of the netCDF variable).  Sampling intervals are specified in type-independent units of elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects every other element, etc.).</p>
  </dd>
  <dt>
    <p><em>imap</em></p>
  </dt>
  <dd>
    <p>specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.  The elements of the index mapping vector correspond, in order, to the netCDF variable's dimensions (<strong>imap</strong>(1) gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the netCDF variable). Distances between elements are specified in type-independent units of elements (the distance between internal elements that occupy adjacent memory locations is 1 and not the element's byte-length as in netCDF 2).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VARIABLE PREFILLING</h2>
        <div class="sectioncontent">
<p>By default, the netCDF interface sets the values of all newly-defined variables of finite length (i.e. those that do not have an unlimited, dimension) to the type-dependent fill-value associated with each variable.  This is done when <strong>nf90_enddef(\|)</strong> is called.  The fill-value for a variable may be changed from the default value by defining the attribute `<strong>_FillValue</strong>' for the variable.  This attribute must have the same type as the variable and be of length one.</p><p>Variables with an unlimited dimension are also prefilled, but on an `as needed' basis.  For example, if the first write of such a variable is to position 5, then positions 1 through 4 (and no others) would be set to the fill-value at the same time.</p><p>This default prefilling of data values may be disabled by or'ing the <strong>nf90_nofill</strong> flag into the mode parameter of <strong>nf90_open(\|)</strong> or <strong>nf90_create(\|)</strong>, or, by calling the function <strong>nf90_set_fill(\|)</strong> with the argument <strong>nf90_nofill</strong>. For variables that do not use the unlimited dimension, this call must be made before <strong>nf90_enddef(\|)</strong>. For variables that use the unlimited dimension, this call may be made at any time.</p><p>One can obtain increased performance of the netCDF interface by using this feature, but only at the expense of requiring the application to set every single data value.  The performance enhancing behavior of this function is dependent on the particulars of the implementation and dataset format. The flag value controlled by <strong>nf90_set_fill(\|)</strong> is per netCDF ID, not per variable or per write. Allowing this to change affects the degree to which a program can be effectively parallelized. Given all of this, we state that the use of this feature may not be available (or even needed) in future releases. Programmers are cautioned against heavy reliance upon this feature.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MPP FUNCTION DESCRIPTIONS</h2>
        <div class="sectioncontent">
<p>Additional functions for use on SGI/Cray MPP machines (_CRAYMPP). These are used to set and inquire which PE is the base for MPP for a particular netCDF. These are only relevant when using the SGI/Cray ``global'' Flexible File I/O layer and desire to have only a subset of PEs to open the specific netCDF file. For technical reasons, these functions are available on all platforms. On a platform other than SGI/Cray MPP, it is as if only processor available were processor 0.</p><p>To use this feature, you need to specify a communicator group and call <strong>glio_group_mpi(\|)</strong> or <strong>glio_group_shmem(\|)</strong> prior to the netCDF <strong>nf90_open(\|)</strong> and <strong>nf90_create(\|)</strong> calls.</p><p>Note that the routines described below are Fortran-77 routines rather than Fortran-90 routines (they have an "nf_" prefix rather than an "nf90_" prefix). <strong>integer function nf__create_mp(character*(*) </strong><em>path</em><strong>, integer </strong><em>cmode</em><strong>, integer </strong><em>initialsize</em><strong>, integer </strong><em>pe</em><strong>, integer </strong><em>chunksize</em><strong>, integer </strong><em>ncid</em><strong>)</strong></p><p>Like <strong>nf__create(\|)</strong> but allows the base PE to be set.</p><p>The argument <em>pe</em> sets the base PE at creation time. In the MPP environment, <strong>nf__create(\|)</strong> and <strong>nf90_create(\|)</strong> set the base PE to processor zero by default. <strong>integer function nf__open_mp(character*(*) </strong><em>path</em><strong>, integer </strong><em>mode</em><strong>, integer </strong><em>pe</em><strong>, integer </strong><em>chunksize</em><strong>, integer </strong><em>ncid</em><strong>)</strong></p><p>Like <strong>nf__open(\|)</strong> but allows the base PE to be set. The argument <em>pe</em> sets the base PE at creation time. In the MPP environment, <strong>nf__open(\|)</strong> and <strong>nf90_open(\|)</strong> set the base PE to processor zero by default. <strong>integer function nf_inq_base_pe(integer </strong><em>ncid</em><strong>, integer </strong><em>pe</em><strong>)</strong></p><p>Inquires of the netCDF dataset which PE is being used as the base for MPP use. This is safe to use at any time. <strong>integer function nf_set_base_pe(integer </strong><em>ncid</em><strong>, integer </strong><em>pe</em><strong>)</strong></p><p>Resets the base PE for the netCDF dataset. Only perform this operation when the affected communicator group synchronizes before and after the call. This operation is very risky and should only be contemplated under only the most extreme cases.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT VARIABLES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>NETCDF_FFIOSPEC</strong></p>
  </dt>
  <dd>
    <p>Specifies the Flexible File I/O buffers for netCDF I/O when executing under the UNICOS operating system (the variable is ignored on other operating systems). An appropriate specification can greatly increase the efficiency of netCDF I/O -- to the extent that it can actually surpass FORTRAN binary I/O. This environment variable has been made a little more generalized, such that other FFIO option specifications can now be added. The default specification is <strong>bufa:336:2</strong>, unless a current FFIO specification is in operation, which will be honored. See UNICOS Flexible File I/O for more information.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAILING-LISTS</h2>
        <div class="sectioncontent">
<p>Both a mailing list and a digest are available for discussion of the netCDF interface and announcements about netCDF bugs, fixes, and enhancements. To begin or change your subscription to either the mailing-list or the digest, send one of the following in the body (not the subject line) of an email message to "majordomo@unidata.ucar.edu". Use your email address in place of <em>jdoe@host.inst.domain</em>.</p><p>To subscribe to the netCDF mailing list:</p><p><strong>subscribe netcdfgroup </strong><em>jdoe@host.inst.domain</em></p><p>To unsubscribe from the netCDF mailing list:</p><p><strong>unsubscribe netcdfgroup </strong><em>jdoe@host.inst.domain</em></p><p>To subscribe to the netCDF digest:</p><p><strong>subscribe netcdfdigest </strong><em>jdoe@host.inst.domain</em></p><p>To unsubscribe from the netCDF digest:</p><p><strong>unsubscribe netcdfdigest </strong><em>jdoe@host.inst.domain</em></p><p>To retrieve the general introductory information for the mailing list:</p><p><strong>info netcdfgroup</strong></p><p>To get a synopsis of other majordomo commands:</p><p><strong>help</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO netcdf_f90&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/ncdump.1.html"><strong>ncdump</strong>(1)</a>, <strong>ncgen</strong>(1), <strong>netcdf</strong>(3f).</p><p><em>netCDF User's Guide</em>, published by the Unidata Program Center, University Corporation for Atmospheric Research, located in Boulder, Colorado.</p>
        </div>
      </section>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CGI::Application::Plugin::TT: Add template toolkit support to cgi::application</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Add template toolkit support to cgi::application">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="CGI::Application::Plugin::TT (3pm) manual">
  <meta name="twitter:description" content="Add template toolkit support to cgi::application">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcgi-application-plugin-tt-perl-CGI::Application::Plugin::TT-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/CGI::Application::Plugin::TT.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="CGI::Application::Plugin::TT (3pm) manual" />
  <meta property="og:description" content="Add template toolkit support to cgi::application" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcgi-application-plugin-tt-perl-CGI::Application::Plugin::TT-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">CGI::Application::Plugin::TT<small> (3pm)</small></h1>
        <p class="lead">Add template toolkit support to cgi::application</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/CGI::Application::Plugin::TT.3pm.html">
      <span itemprop="name">CGI::Application::Plugin::TT: Add template toolkit support to cgi::application</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcgi-application-plugin-tt-perl/">
      <span itemprop="name">libcgi-application-plugin-tt-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/CGI::Application::Plugin::TT.3pm.html">
      <span itemprop="name">CGI::Application::Plugin::TT: Add template toolkit support to cgi::application</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use base qw(CGI::Application);
 use CGI::Application::Plugin::TT;

 sub myrunmode {
   my $self = shift;

   my %params = (
                 email       =&gt; &apos;email@company.com&apos;,
                 menu        =&gt; [
                                 { title =&gt; &apos;Home&apos;,     href =&gt; &apos;/home.html&apos; },
                                 { title =&gt; &apos;Download&apos;, href =&gt; &apos;/download.html&apos; },
                                ],
                 session_obj =&gt; $self-&gt;session,
   );

   return $self-&gt;tt_process(&apos;template.tmpl&apos;, &#92;%params);
 }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>CGI::Application::Plugin::TT adds support for the popular Template Toolkit engine to your CGI::Application modules by providing several helper methods that allow you to process template files from within your runmodes.</p><p>It compliments the support for HTML::Template that is built into CGI::Application through the <strong>load_tmpl</strong> method.  It also provides a few extra features than just the ability to load a template.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>tt_process</h3>
<p>This is a simple wrapper around the Template Toolkit process method.  It accepts zero, one or two parameters; an optional template filename, and an optional hashref of template parameters (the template filename is optional, and will be autogenerated by a call to $self-&gt;tt_template_name if not provided). The return value will be a scalar reference to the output of the template.</p><p>  package My::App::Browser   sub myrunmode {     my $self = shift;</p><p>    return $self-&gt;tt_process( &apos;Browser/myrunmode.tmpl&apos;, { foo =&gt; &apos;bar&apos; } );   }</p><p>  sub myrunmode2 {     my $self = shift;</p><p>    return $self-&gt;tt_process( { foo =&gt; &apos;bar&apos; } ); # will process template &apos;My/App/Browser/myrunmode2.tmpl&apos;   }</p>
<h3>tt_config</h3>
<p>This method can be used to customize the functionality of the CGI::Application::Plugin::TT module, and the Template Toolkit module that it wraps.  The recommended place to call \*(C`tt_config\*(C' is as a class method in the global scope of your module (See \s-1SINGLETON\s0 \s-1SUPPORT\s0 for an explanation of why this is a good idea).  If this method is called after a call to tt_process or tt_obj, then it will die with an error message.</p><p>It is not a requirement to call this method, as the module will work without any configuration.  However, most will find it useful to set at least a path to the location of the template files ( or you can set the path later using the tt_include_path method).</p><p>    our $TEMPLATE_OPTIONS = {         COMPILE_DIR =&gt; &apos;/tmp/tt_cache&apos;,         DEFAULT     =&gt; &apos;notfound.tmpl&apos;,         PRE_PROCESS =&gt; &apos;defaults.tmpl&apos;,     };     _\|_PACKAGE_\|_-&gt;tt_config( TEMPLATE_OPTIONS =&gt; $TEMPLATE_OPTIONS );</p><p>The following parameters are accepted:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1TEMPLATE_OPTIONS\s0
  </dt>
  <dd>
    <p>This allows you to customize how the Template object is created by providing a list of options that will be passed to the Template constructor.  Please see the documentation for the Template module for the exact syntax of the parameters, or see below for an example.</p>
  </dd>
  <dt>
    \s-1TEMPLATE_NAME_GENERATOR\s0
  </dt>
  <dd>
    <p>This allows you to provide your own method for auto-generating the template filename.  It requires a reference to a function that will be passed the $self object as it's only parameter.  This function will be called everytime $self-&gt;tt_process is called without providing the filename of the template to process.  This can standardize the way templates are organized and structured by making the template filenames follow a predefined pattern. The default template filename generator uses the current module name, and the name of the calling function to generate a filename.  This means your templates are named by a combination of the module name, and the runmode.</p>
  </dd>
  <dt>
    \s-1TEMPLATE_PRECOMPILE_DIR\s0
  </dt>
  <dd>
    <p>This options allows you to specify a directory (or an array of directories) to search when this module is loaded and then compile all files found into memory. This provides a speed boost in persistent environments (mod_perl, fast-cgi) and can improve memory usage in environments that use shared memory (mod_perl).</p>
  </dd>
  <dt>
    \s-1TEMPLATE_PRECOMPILE_FILETEST\s0
  </dt>
  <dd>
    <p>This option allows you to specify exactly which files will get compiled when using the \s-1TEMPLATE_PRECOMPILE_DIR\s0 option.  You can provide it with one of 3 different variable types:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1STRING\s0
  </dt>
  <dd>
    <p>A filename extension that can specify what type of files will be loaded (eg 'tmpl').</p>
  </dd>
  <dt>
    \s-1REGEXP\s0
  </dt>
  <dd>
    <p>Filenames that match the regular expression will be precompiled ( eg qr/&#92;.(tt|tmpl|html)$/ ).</p>
  </dd>
  <dt>
    \s-1CODEREF\s0
  </dt>
  <dd>
    <p>A code reference that will be called once for each filename and directory found, and if it returns true, the template will be precompiled (eg sub { my $file = shift; ... } ).</p>
  </dd>

</dl>

  </dd>

</dl>

<h3>tt_obj</h3>
<p>This method will return the underlying Template Toolkit object that is used behind the scenes.  It is usually not necessary to use this object directly, as you can process templates and configure the Template object through the tt_process and tt_config methods.  Every call to this method will return the same object during a single request.</p><p>It may be useful for debugging purposes.</p>
<h3>tt_params</h3>
<p>This method will accept a hash or hashref of parameters that will be included in the processing of every call to tt_process.  It is important to note that the parameters defined using tt_params will be passed to every template that is processed during a given request cycle.  Usually only one template is processed per request, but it is entirely possible to call tt_process multiple times with different templates.  Everytime tt_process is called, the hashref of parameters passed to tt_process will be merged with the parameters set using the tt_params method.  Parameters passed through tt_process will have precidence in case of duplicate parameters.</p><p>This can be useful to add global values to your templates, for example passing the user's name automatically if they are logged in.</p><p>  sub cgiapp_prerun {     my $self = shift;</p><p>    $self-&gt;tt_params(username =&gt; $ENV{REMOTE_USER}) if $ENV{REMOTE_USER};   }</p>
<h3>tt_clear_params</h3>
<p>This method will clear all the currently stored parameters that have been set with tt_params.</p>
<h3>tt_pre_process</h3>
<p>This is an overridable method that works in the spirit of cgiapp_prerun.  The method will be called just before a template is processed, and will be passed the template filename, and a hashref of template parameters.  It can be used to make last minute changes to the template, or the parameters before the template is processed.</p><p>  sub tt_pre_process {     my ($self, $file, $vars) = @_;     $vars-&gt;{user} = $ENV{REMOTE_USER};     return;   }</p><p>If you are using CGI::Application 4.0 or greater, you can also register this as a callback.</p><p>  _\|_PACKAGE_\|_-&gt;add_callback(&apos;tt_pre_process&apos;, sub {     my ($self, $file, $vars) = @_;     $vars-&gt;{user} = $ENV{REMOTE_USER};     return;   });</p>
<h3>tt_post_process</h3>
<p>This, like it's counterpart cgiapp_postrun, is called right after a template has been processed. It will be passed a scalar reference to the processed template.</p><p>  sub tt_post_process {     my ($self, $htmlref) = shift;</p><p>    require HTML::Clean;     my $h = HTML::Clean-&gt;new($htmlref);     $h-&gt;strip;     my $newref = $h-&gt;data;     $$htmlref = $$newref;     return;   }</p><p>If you are using CGI::Application 4.0 or greater, you can also register this as a callback (See tt_pre_process for an example of how to use it).</p>
<h3>tt_template_name</h3>
<p>This method will generate a template name for you based on two pieces of information:  the method name of the caller, and the package name of the caller.  It allows you to consistently name your templates based on a directory hierarchy and naming scheme defined by the structure of the code.  This can simplify development and lead to more consistent, readable code.</p><p>If you do not want the template to be named after the method that called tt_template_name, you can pass in an integer, and the method used to generate the template name will be that many levels above the caller.  It defaults to zero.</p><p>For example:</p><p> package My::App::Browser</p><p> sub dummy_call {    my $self = shift;    return $self-&gt;<strong>tt_template_name</strong>(1); # parent callers name  }</p><p> sub view {    my $self = shift;    my $template;</p><p>   $template = $self-&gt;tt_template_name; # returns &apos;My/App/Browser/view.tmpl&apos;    $template = $self-&gt;dummy_call;  # also returns &apos;My/App/Browser/view.tmpl&apos;    return $self-&gt;tt_process($template, { var1 =&gt; param1 });  }</p><p>To simplify things even more, tt_process automatically calls $self-&gt;tt_template_name for you if you do not pass a template name, so the above can be reduced to this:</p><p> package MyApp::Example</p><p> sub view {    my $self = shift;</p><p>   return $self-&gt;tt_process({ var1 =&gt; param1 }); # process template &apos;MyApp/Example/view.tmpl&apos;  }</p><p>Since the path is generated based on the name of the module, you could place all of your templates in the same directory as your perl modules, and then pass @INC as your \s-1INCLUDE_PATH\s0 parameter. Whether that is actually a good idea is left up to the reader.</p><p> $self-&gt;tt_include_path(&#92;@INC);</p>
<h3>tt_include_path</h3>
<p>This method will allow you to set the include path for the Template Toolkit object after the object has already been created.  Normally you set the \s-1INCLUDE_PATH\s0 option when creating the Template Toolkit object, but sometimes it can be useful to change this value after the object has already been created.  This method will allow you to do that without needing to create an entirely new Template Toolkit object.  This can be especially handy when using the Singleton support mentioned below, where a Template Toolkit object may persist across many request. It is important to note that a call to tt_include_path will change the \s-1INCLUDE_PATH\s0 for all subsequent calls to this object, until tt_include_path is called again.  So if you change the \s-1INCLUDE_PATH\s0 based on the user that is connecting to your site, then make sure you call tt_include_path on every request.</p><p>  my $root = &apos;/var/www/&apos;;   $self-&gt;tt_include_path( [$root.$ENV{SERVER_NAME}, $root.&apos;default&apos;] );</p><p>When called with no parameters tt_include_path returns an arrayref containing the current \s-1INCLUDE_PATH\s0.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEFAULT PARAMETERS</h2>
        <div class="sectioncontent">
<p>By default, the \s-1TT\s0 plugin will automatically add a parameter 'c' to the template that will return to your CGI::Application object $self.  This allows you to access any methods in your CGI::Application module that you could normally call on $self from within your template.  This allows for some powerful actions in your templates. For example, your templates will be able to access query parameters, or if you use the CGI::Application::Plugin::Session module, you can access session parameters.</p><p> Hello [% c.session.param(&apos;username&apos;) || &apos;Anonymous User&apos; %]</p><p> &lt;a href="[% c.query.self_url %]"&gt;Reload this page&lt;/a&gt;</p><p>Another useful plugin that can use this feature is the CGI::Application::Plugin::HTMLPrototype plugin, which gives easy access to the very powerful prototype.js JavaScript library.</p><p>  [% c.prototype.define_javascript_functions %]   &lt;a href="#" onclick="javascript:[% c.prototype.visual_effect( &apos;Appear&apos;, &apos;extra_info&apos; ) %] return false;"&gt;Extra Info&lt;/a&gt;   &lt;div style="display: none" id="extra_info"&gt;Here is some more extra info&lt;/div&gt;</p><p>With this extra flexibility comes some responsibilty as well.  It could lead down a dangerous path if you start making alterations to your object from within the template. For example you could call c.header_add to add new outgoing headers, but that is something that should be left in your code, not in your template.  Try to limit yourself to pulling in information into your templates (like the session example above does).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>In a CGI::Application module:</p><p>  package My::App</p><p>  use CGI::Application::Plugin::TT;   use base qw(CGI::Application);</p><p>  # configure the template object once during the init stage   sub cgiapp_init {     my $self = shift;</p><p>    # Configure the template     $self-&gt;tt_config(               TEMPLATE_OPTIONS =&gt; {                         INCLUDE_PATH =&gt; &apos;/path/to/template/files&apos;,                         POST_CHOMP   =&gt; 1,                         FILTERS =&gt; {                                      &apos;currency&apos; =&gt; sub { sprintf(&apos;$ %0.2f&apos;, @_) },                         },               },     );   }</p><p>  sub cgiapp_prerun {     my $self = shift;</p><p>    # Add the username to all templates if the user is logged in     $self-&gt;tt_params(username =&gt; $ENV{REMOTE_USER}) if $ENV{REMOTE_USER};   }</p><p>  sub tt_pre_process {     my $self = shift;     my $template = shift;     my $params = shift;</p><p>    # could add the username here instead if we want     $params-&gt;{username} = $ENV{REMOTE_USER}) if $ENV{REMOTE_USER};</p><p>    return;   }</p><p>  sub tt_post_process {     my $self    = shift;     my $htmlref = shift;</p><p>    # clean up the resulting HTML     require HTML::Clean;     my $h = HTML::Clean-&gt;new($htmlref);     $h-&gt;strip;     my $newref = $h-&gt;data;     $$htmlref = $$newref;     return;   }</p><p>  sub my_runmode {     my $self = shift;</p><p>    my %params = (             foo =&gt; &apos;bar&apos;,     );</p><p>    # return the template output     return $self-&gt;tt_process(&apos;my_runmode.tmpl&apos;, &#92;%params);   }</p><p>  sub my_otherrunmode {     my $self = shift;</p><p>    my %params = (             foo =&gt; &apos;bar&apos;,     );</p><p>    # Since we don&apos;t provide the name of the template to tt_process, it     # will be auto-generated by a call to $self-&gt;tt_template_name,     # which will result in a filename of &apos;Example/my_otherrunmode.tmpl&apos;.     return $self-&gt;tt_process(&#92;%params);   }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SINGLETON SUPPORT</h2>
        <div class="sectioncontent">
<p>Creating a Template Toolkit object can be an expensive operation if it needs to be done for every request.  This startup cost increases dramatically as the number of templates you use increases.  The reason for this is that when \s-1TT\s0 loads and parses a template, it generates actual perlcode to do the rendering of that template.  This means that the rendering of the template is extremely fast, but the initial parsing of the templates can be inefficient.  Even by using the builting caching mechanism that \s-1TT\s0 provides only writes the generated perl code to the filesystem.  The next time a \s-1TT\s0 object is created, it will need to load these templates from disk, and eval the sourcecode that they contain.</p><p>So to improve the efficiency of Template Toolkit, we should keep the object (and hence all the compiled templates) in memory across multiple requests.  This means you only get hit with the startup cost the first time the \s-1TT\s0 object is created.</p><p>All you need to do to use this module as a singleton is to call tt_config as a class method instead of as an object method.  All the same parameters can be used when calling tt_config as a class method.</p><p>When creating the singleton, the Template Toolkit object will be saved in the namespace of the module that created it.  The singleton will also be inherited by any subclasses of this module.  So in effect this is not a traditional Singleton, since an instance of a Template Toolkit object is only shared by a module and it's children.  This allows you to still have different configurations for different CGI::Application modules if you require it.  If you want all of your CGI::Application applications to share the same Template Toolkit object, just create a Base class that calls tt_config to configure the plugin, and have all of your applications inherit from this Base class.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SINGLETON EXAMPLE</h2>
        <div class="sectioncontent">
<p>  package My::App;</p><p>  use base qw(CGI::Application);   use CGI::Application::Plugin::TT;   My::App-&gt;tt_config(               TEMPLATE_OPTIONS =&gt; {                         POST_CHOMP   =&gt; 1,               },   );</p><p>  sub cgiapp_prerun {     my $self = shift;</p><p>    # Set the INCLUDE_PATH (will change the INCLUDE_PATH for     # all subsequent requests as well, until tt_include_path is called     # again)     my $basedir = &apos;/path/to/template/files/&apos;,     $self-&gt;tt_include_path( [$basedir.$ENV{SERVER_NAME}, $basedir.&apos;default&apos;] );   }</p><p>  sub my_runmode {     my $self = shift;</p><p>    # Will use the same TT object across multiple request     return $self-&gt;tt_process({ param1 =&gt; &apos;value1&apos; });   }</p><p>  package My::App::Subclass;</p><p>  use base qw(My::App);</p><p>  sub my_other_runmode {     my $self = shift;</p><p>    # Uses the TT object from the parent class (My::App)     return $self-&gt;tt_process({ param2 =&gt; &apos;value2&apos; });   }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Cees Hek &lt;ceeshek@gmail.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Please report any bugs or feature requests to \*(C`bug-cgi-application-plugin-tt@rt.cpan.org\*(C', or through the web interface at &lt;http://rt.cpan.org&gt;.  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTRIBUTING</h2>
        <div class="sectioncontent">
<p>Patches, questions and feedback are welcome.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO CGI::Application::Plugin::TT&hellip;</h2>
        <div class="sectioncontent">
<p>CGI::Application, Template, <em>perl</em>\|(1)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2005 Cees Hek, All Rights Reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="CGI::Application::Plugin::RequireSSL.3pm.html"><span aria-hidden="true">&larr;</span> CGI::Application::Plugin::RequireSSL.3pm: Force ssl in specified pages or modules</a></li>
   <li class="next"><a href="CGI::Application::Plugin::TT::LastModified.3pm.html">CGI::Application::Plugin::TT::LastModified.3pm: Set "last-modified" header based on tt template <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>File::Find::Rule: Alternative interface to file::find</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Alternative interface to file::find">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="File::Find::Rule (3pm) manual">
  <meta name="twitter:description" content="Alternative interface to file::find">
  <meta name="twitter:image" content="https://www.carta.tech/images/libfile-find-rule-perl-File::Find::Rule-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/File::Find::Rule.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="File::Find::Rule (3pm) manual" />
  <meta property="og:description" content="Alternative interface to file::find" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libfile-find-rule-perl-File::Find::Rule-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">File::Find::Rule<small> (3pm)</small></h1>
        <p class="lead">Alternative interface to file::find</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/File::Find::Rule.3pm.html">
      <span itemprop="name">File::Find::Rule: Alternative interface to file::find</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libfile-find-rule-perl/">
      <span itemprop="name">libfile-find-rule-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/File::Find::Rule.3pm.html">
      <span itemprop="name">File::Find::Rule: Alternative interface to file::find</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use File::Find::Rule;
  # find all the subdirectories of a given directory
  my @subdirs = File::Find::Rule-&gt;directory-&gt;in( $directory );

  # find all the .pm files in @INC
  my @files = File::Find::Rule-&gt;file()
                              -&gt;name( &apos;*.pm&apos; )
                              -&gt;in( @INC );

  # as above, but without method chaining
  my $rule =  File::Find::Rule-&gt;new;
  $rule-&gt;file;
  $rule-&gt;name( &apos;*.pm&apos; );
  my @files = $rule-&gt;in( @INC );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>File::Find::Rule is a friendlier interface to File::Find.  It allows you to build rules which specify the desired files and directories.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>A constructor.  You need not invoke \*(C`new\*(C' manually unless you wish to, as each of the rule-making methods will auto-create a suitable object if called as class methods.</p><h3>Matching Rules</h3>
<p>Specifies names that should match.  May be globs or regular expressions.  $set-&gt;name( &apos;*.mp3&apos;, &apos;*.ogg&apos; ); # mp3s or oggs  $set-&gt;name( qr/&#92;.(mp3|ogg)$/ ); # the same as a regex  $set-&gt;name( &apos;foo.bar&apos; );        # just things named foo.bar</p>
<dl class='dl-vertical'>
  <dt>
    -X tests
  </dt>
  <dd>
    <p>Synonyms are provided for each of the -X tests. See \*(L"-X\*(R" in perlfunc for details.  None of these methods take arguments.   Test | Method               Test |  Method  ------|-------------        ------|----------------    -r  |  readable             -R  |  r_readable    -w  |  writeable            -W  |  r_writeable    -w  |  writable             -W  |  r_writable    -x  |  executable           -X  |  r_executable    -o  |  owned                -O  |  r_owned        |                           |    -e  |  exists               -f  |  file    -z  |  empty                -d  |  directory    -s  |  nonempty             -l  |  symlink        |                       -p  |  fifo    -u  |  setuid               -S  |  socket    -g  |  setgid               -b  |  block    -k  |  sticky               -c  |  character        |                       -t  |  tty    -M  |  modified                 |    -A  |  accessed             -T  |  ascii    -C  |  changed              -B  |  binary Though some tests are fairly meaningless as binary flags (\*(C`modified\*(C', \*(C`accessed\*(C', \*(C`changed\*(C'), they have been included for completeness.  # find nonempty files  $rule-&gt;file,       -&gt;nonempty;</p>
  </dd>
  <dt>
    stat tests
  </dt>
  <dd>
    <p>The following \*(C`stat\*(C' based methods are provided: \*(C`dev\*(C', \*(C`ino\*(C', \*(C`mode\*(C', \*(C`nlink\*(C', \*(C`uid\*(C', \*(C`gid\*(C', \*(C`rdev\*(C', \*(C`size\*(C', \*(C`atime\*(C', \*(C`mtime\*(C', \*(C`ctime\*(C', \*(C`blksize\*(C', and \*(C`blocks\*(C'.  See \*(L"stat\*(R" in perlfunc for details. Each of these can take a number of targets, which will follow Number::Compare semantics.  $rule-&gt;size( 7 );         # exactly 7  $rule-&gt;size( "&gt;7Ki" );    # larger than 7 * 1024 * 1024 bytes  $rule-&gt;size( "&gt;=7" )       -&gt;size( "&lt;=90" );    # between 7 and 90, inclusive  $rule-&gt;size( 7, 9, 42 );  # 7, 9 or 42 Allows shortcircuiting boolean evaluation as an alternative to the default and-like nature of combined rules.  \*(C`any\*(C' and \*(C`or\*(C' are interchangeable.  # find avis, movs, things over 200M and empty files  $rule-&gt;any( File::Find::Rule-&gt;name( &apos;*.avi&apos;, &apos;*.mov&apos; ),              File::Find::Rule-&gt;size( &apos;&gt;200M&apos; ),              File::Find::Rule-&gt;file-&gt;empty,            ); Negates a rule.  (The inverse of \*(C`any\*(C'.)  \*(C`none\*(C' and \*(C`not\*(C' are interchangeable.   # files that aren&apos;t 8.3 safe   $rule-&gt;file        -&gt;not( $rule-&gt;new-&gt;name( qr/^[^.]{1,8}(&#92;.[^.]{0,3})?$/ ) ); Traverse no further.  This rule always matches. Don't keep this file.  This rule always matches. Allows user-defined rules.  Your subroutine will be invoked with $_ set to the current short name, and with parameters of the name, the path you're in, and the full relative filename. Return a true value if your rule matched.  # get things with long names  $rules-&gt;exec( sub { length &gt; 20 } ); Opens a file and tests it each line at a time. For each line it evaluates each of the specifiers, stopping at the first successful match.  A specifier may be a regular expression or a subroutine.  The subroutine will be invoked with the same parameters as an -&gt;exec subroutine. It is possible to provide a set of negative specifiers by enclosing them in anonymous arrays.  Should a negative specifier match the iteration is aborted and the clause is failed.  For example:  $rule-&gt;grep( qr/^#!.*&#92;bperl/, [ sub { 1 } ] ); Is a passing clause if the first line of a file looks like a perl shebang line. Descend at most $level (a non-negative integer) levels of directories below the starting point. May be invoked many times per rule, but only the most recent value is used. Do not apply any tests at levels less than $level (a non-negative integer). Specifies extra values to pass through to \*(C`File::File::find\*(C' as part of the options hash. For example this allows you to specify following of symlinks like so:  my $rule = File::Find::Rule-&gt;extras({ follow =&gt; 1 }); May be invoked many times per rule, but only the most recent value is used. Trim the leading portion of any path found Negated version of the rule.  An effective shortand related to ! in the procedural interface.  $foo-&gt;not_name(&apos;*.pl&apos;);</p><p> $foo-&gt;not( $foo-&gt;new-&gt;name(&apos;*.pl&apos; ) );</p>
  </dd>

</dl>

<h3>Query Methods</h3>
<p>Evaluates the rule, returns a list of paths to matching files and directories. Starts a find across the specified directories.  Matching items may then be queried using \*(L"match\*(R".  This allows you to use a rule as an iterator.  my $rule = File::Find::Rule-&gt;file-&gt;name("*.jpeg")-&gt;start( "/web" );  while ( defined ( my $image = $rule-&gt;match ) ) {      ...  } Returns the next file which matches, false if there are no more.</p>
<h3>Extensions</h3>
<p>Extension modules are available from \s-1CPAN\s0 in the File::Find::Rule namespace.  In order to use these extensions either use them directly:</p><p> use File::Find::Rule::ImageSize;  use File::Find::Rule::MMagic;</p><p> # now your rules can use the clauses supplied by the ImageSize and  # MMagic extension</p><p>or, specify that File::Find::Rule should load them for you:</p><p> use File::Find::Rule qw( :ImageSize :MMagic );</p><p>For notes on implementing your own extensions, consult File::Find::Rule::Extending</p>
<h3>Further examples</h3>

<dl class='dl-vertical'>
  <dt>
    Finding perl scripts
  </dt>
  <dd>
    <p> my $finder = File::Find::Rule-&gt;or   (    File::Find::Rule-&gt;name( &apos;*.pl&apos; ),    File::Find::Rule-&gt;exec(                           sub {                               if (open my $fh, $_) {                                   my $shebang = &lt;$fh&gt;;                                   close $fh;                                   return $shebang =~ /^#!.*&#92;bperl/;                               }                               return 0;                           } ),   ); Based upon this message http://use.perl.org/comments.pl?sid=7052&cid=10842</p>
  </dd>
  <dt>
    ignore \s-1CVS\s0 directories
  </dt>
  <dd>
    <p> my $rule = File::Find::Rule-&gt;new;  $rule-&gt;or($rule-&gt;new                 -&gt;directory                 -&gt;name(&apos;CVS&apos;)                 -&gt;prune                 -&gt;discard,            $rule-&gt;new); Note here the use of a null rule.  Null rules match anything they see, so the effect is to match (and discard) directories called '\s-1CVS\s0' or to match anything.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TWO FOR THE PRICE OF ONE</h2>
        <div class="sectioncontent">
<p>File::Find::Rule also gives you a procedural interface.  This is documented in File::Find::Rule::Procedural</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p>\*(L"find\*(R", \*(L"rule\*(R"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TAINT MODE INTERACTION</h2>
        <div class="sectioncontent">
<p>As of 0.32 File::Find::Rule doesn't capture the current working directory in a taint-unsafe manner.  File::Find itself still does operations that the taint system will flag as insecure but you can use the \*(L"extras\*(R" feature to ask File::Find to internally \*(C`untaint\*(C' file paths with a regex like so:</p><p>    my $rule = File::Find::Rule-&gt;extras({ untaint =&gt; 1 });</p><p>Please consult File::Find's documentation for \*(C`untaint\*(C', \*(C`untaint_pattern\*(C', and \*(C`untaint_skip\*(C' for more information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>The code makes use of the \*(C`our\*(C' keyword and as such requires perl version 5.6.0 or newer.</p><p>Currently it isn't possible to remove a clause from a rule object.  If this becomes a significant issue it will be addressed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Richard Clamp &lt;richardc@unixbeard.net&gt; with input gained from this use.perl discussion: http://use.perl.org/~richardc/journal/6467</p><p>Additional proofreading and input provided by Kake, Greg McCarroll, and Andy Lester andy@petdance.com.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp.  All Rights Reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO File::Find::Rule&hellip;</h2>
        <div class="sectioncontent">
<p>File::Find, Text::Glob, Number::Compare, <em>find</em>\|(1)</p><p>If you want to know about the procedural interface, see File::Find::Rule::Procedural, and if you have an idea for a neat extension File::Find::Rule::Extending</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="File::File::Data.3pm.html"><span aria-hidden="true">&larr;</span> File::File::Data.3pm: Interface to file data</a></li>
   <li class="next"><a href="File::Find::Rule::Extending.3pm.html">File::Find::Rule::Extending.3pm: The mini-guide to extending file::find::rule <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

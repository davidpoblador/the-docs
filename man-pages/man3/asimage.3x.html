<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>asimage: Asimage- internal structures and methods used for image manipulation in libafterimage libafterimage/asimage.h</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Asimage- internal structures and methods used for image manipulation in libafterimage libafterimage/asimage.h">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="asimage (3x) manual">
  <meta name="twitter:description" content="Asimage- internal structures and methods used for image manipulation in libafterimage libafterimage/asimage.h">
  <meta name="twitter:image" content="https://www.carta.tech/images/libafterimage-dev-asimage-3x.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3x/asimage.3x.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="asimage (3x) manual" />
  <meta property="og:description" content="Asimage- internal structures and methods used for image manipulation in libafterimage libafterimage/asimage.h" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libafterimage-dev-asimage-3x.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">asimage<small> (3x)</small></h1>
        <p class="lead">Asimage- internal structures and methods used for image manipulation in libafterimage libafterimage/asimage.h</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/asimage.3x.html">
      <span itemprop="name">asimage: Asimage- internal structures and methods used for image manipulation in libafterimage libafterimage/asimage.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libafterimage-dev/">
      <span itemprop="name">libafterimage-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/asimage.3x.html">
      <span itemprop="name">asimage: Asimage- internal structures and methods used for image manipulation in libafterimage libafterimage/asimage.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">NAMEasimage</h2>
        <div class="sectioncontent">
<p>defines main structures and function for image manipulation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>libAfterImage provides powerful functionality to load, store and transform images. It allows for smaller memory utilization by utilizing run-length encoding of the image data. There could be different levels of compression selected, allowing to choose best speed/memory ratio.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO asimage&hellip;</h2>
        <div class="sectioncontent">
<p>Structures :</p>
<pre>
         ASImage
         ASImageManager
         ASImageBevel
         ASImageDecoder
         ASImageOutput
         ASImageLayer
         ASGradient
</pre>
<p>Functions :</p>
<pre>
         asimage_init(), asimage_start(), create_asimage(),
         clone_asimage(), destroy_asimage()
</pre>

<pre>
  ImageManager Reference counting and managing :
         create_image_manager(), destroy_image_manager(),
         store_asimage(), fetch_asimage(), query_asimage(),
         dup_asimage(), release_asimage(),
         release_asimage_by_name(), forget_asimage(),
         safe_asimage_destroy()
</pre>

<pre>
  Gradients helper functions :
         flip_gradient(), destroy_asgradient()
</pre>

<pre>
  Layers helper functions :
         init_image_layers(), create_image_layers(),
         destroy_image_layers()
</pre>

<pre>
  Encoding :
         asimage_add_line(),    asimage_add_line_mono(),
         asimage_print_line(), get_asimage_chanmask(),
         move_asimage_channel(), copy_asimage_channel(),
         copy_asimage_lines()
</pre>

<pre>
  Decoding
         start_image_decoding(), stop_image_decoding(),
         asimage_decode_line (), set_decoder_shift(),
         set_decoder_back_color()
</pre>

<pre>
  Output :
         start_image_output(), set_image_output_back_color(),
         toggle_image_output_direction(), stop_image_output()
</pre>
<p>Other libAfterImage modules :</p>
<pre>
         ascmap.h asfont.h asimage.h asvisual.h blender.h export.h
         import.h transform.h ximage.h
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sasha Vasko &lt;sasha at aftercode dot net&gt; libAfterImage/ASAltImFormats</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASAltImFormats</h2>
        <div class="sectioncontent">
<p>identifies what output format should be used for storing the transformation result. Also identifies what data is currently stored in alt member of ASImage structure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef enum {</p>
<pre>
    ASA_ASImage = 0,
    ASA_XImage,
    ASA_MaskXImage,
    /* temporary XImages to be allocated from static pool of memory :*/
    ASA_ScratchXImage,
    ASA_ScratchMaskXImage,
</pre>

<pre>
    ASA_ScratchXImageAndAlpha,
</pre>

<pre>
    ASA_ARGB32,
    ASA_Vector,       /* This cannot be used for transformation's result
                       * format */
    ASA_Formats
</pre>
<p>}ASAltImFormats;</p><p>libAfterImage/ASImage</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASImage</h2>
        <div class="sectioncontent">
<p>is the main structure to hold image data.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Images are stored internally split into ARGB channels, each split into scanline. Actuall data is stored using ASStorage container. Inside ASImage data structure we only store IDs pointing to data in ASStorage ASStorage implements reference counting, data compression, automatic memory defragmentation and other nice things.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO asimage&hellip;</h2>
        <div class="sectioncontent">
<p> asimage_init()  asimage_start()  create_asimage()  destroy_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>struct ASImageAlternative; struct ASImageManager;</p><p>/* magic number identifying ASFont data structure */ #define MAGIC_ASIMAGE            0xA3A314AE</p><p>typedef struct ASImage {</p>
<pre>
  unsigned long magic ;
</pre>

<pre>
  unsigned int width, height;       /* size of the image in pixels */
</pre>

<pre>
  /* arrays of storage ids of stored scanlines of particular channel: */
  ASStorageID *alpha,
              *red,
              *green,
              *blue;
</pre>

<pre>
  ASStorageID *channels[IC_NUM_CHANNELS];
                                    /* merely a shortcut so we can
                                     * somewhat simplify code in loops */
</pre>

<pre>
  ARGB32 back_color ;               /* background color of the image, so
                                     * we could discard everything that
                                     * matches it, and then restore it
                                     * back. */
</pre>

<pre>
  struct ASImageAlternative
  {  /* alternative forms of ASImage storage : */
    XImage *ximage ;                /* pointer to XImage created as the
                                     * result of transformations whenever
                                     * we request it to output into
                                     * XImage ( see to_xim parameter ) */
    XImage *mask_ximage ;           /* XImage of depth 1 that could be
                                     * used to store mask of the image */
    ARGB32 *argb32 ;                /* array of widthxheight ARGB32
                                     * values */
    double *vector ;                /* scientific data that should be used
                                     * in conjunction with
                                     * ASScientificPalette to produce
                                     * actuall ARGB data */
  }alt;
</pre>

<pre>
  struct ASImageManager *imageman;  /* if not null - then image could be
                                     * referenced by some other code */
  int                    ref_count ;/* this will tell us what us how many
                                     * times */
</pre>

<pre>
  char                  *name ;     /* readonly copy of image name
                                     * this name is a hash value used to
                                     * store image in the image-man's hash,
                                     * and gets freed automagically on image
                                     * removal from hash */
</pre>
<p>#define ASIM_DATA_NOT_USEFUL    (0x01&lt;&lt;0) #define ASIM_VECTOR_TOP2BOTTOM  (0x01&lt;&lt;1) #define ASIM_XIMAGE_8BIT_MASK   (0x01&lt;&lt;2) #define ASIM_NO_COMPRESSION     (0x01&lt;&lt;3) /* Do not use compression to</p>
<pre>
                                           * save some computation time
                                           */
</pre>
<p>#define ASIM_ALPHA_IS_BITMAP    (0x01&lt;&lt;4) #define ASIM_RGB_IS_BITMAP      (0x01&lt;&lt;5) #define ASIM_XIMAGE_NOT_USEFUL  (0x01&lt;&lt;6) #define ASIM_NAME_IS_FILENAME   (0x01&lt;&lt;7)</p>
<pre>
  ASFlagType             flags ;    /* combination of the above flags */
</pre>
<p>} ASImage;</p><p>libAfterImage/ASImageManager</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASImageManager</h2>
        <div class="sectioncontent">
<p>structure to be used to maintain list of loaded images for given set of search paths and gamma. Images are named and reference counted.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef struct ASImageManager {</p>
<pre>
    ASHashTable  *image_hash ;
    /* misc stuff that may come handy : */
    char         *search_path[MAX_SEARCH_PATHS+1];
    double        gamma ;
</pre>
<p>}ASImageManager;</p><p>libAfterImage/LIMITS</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEMAX_IMPORT_IMAGE_SIZE</h2>
        <div class="sectioncontent">
<p>effectively limits size of the allowed images to be loaded from files. That is needed to be able to filter out corrupt files. MAX_BEVEL_OUTLINE Limit on bevel outline to be drawn around the image. MAX_SEARCH_PATHS Number of search paths to be used while loading images from files.</p><p>#define MAX_IMPORT_IMAGE_SIZE   8000 #define MAX_BEVEL_OUTLINE       100 #define MAX_SEARCH_PATHS        8      /* prudently limiting ourselfs */</p><p>libAfterImage/ASVectorPalette</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASVectorPalette</h2>
        <div class="sectioncontent">
<p>contains palette allowing us to map double values in vector image data into actuall ARGB values.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef struct ASVectorPalette {</p>
<pre>
    unsigned int npoints ;
    double *points ;
    CARD16 *channels[IC_NUM_CHANNELS] ;   /* ARGB data for key points. */
    ARGB32  default_color;
</pre>
<p>}ASVectorPalette;</p><p>libAfterImage/asimage/ASImageLayer</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASImageLayer</h2>
        <div class="sectioncontent">
<p>specifies parameters of the image superimposition.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>libAfterImage allows for simultaneous superimposition (overlaying) of arbitrary number of images. To facilitate this ASImageLayer structure has been created in order to specify parameters of each image participating in overlaying operation. Images need not to be exact same size. For each image its position on destination is specified via dst_x and dst_y data members. Each image maybe tiled and clipped to fit into rectangle specified by clip_x, clip_y, clip_width, clip_height ( in image coordinates - not destination ). If image is missing, then area specified by dst_x, dst_y, clip_width, clip_height will be filled with solid_color. Entire image will be tinted using tint parameter prior to overlaying. Bevel specified by bevel member will be drawn over image prior to overlaying. Specific overlay method has to be specified. merge_scanlines method is pointer to a function, that accepts 2 ASScanlines as arguments and performs overlaying of first one with the second one. There are 15 different merge_scanline methods implemented in libAfterImage, including alpha-blending, tinting, averaging, HSV and HSL colorspace operations, etc.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>ASImageLayer s could be organized into chains using next pointers. Since there could be a need to rearrange layers and maybe bypass some layers - we need to provide for flexibility, while at the same time allowing for simplicity of arrays. As the result next pointers could be used to link together continuous arrays of layer, like so : array1: [layer1(next==NULL)][layer2(next!=NULL)]</p>
<pre>
         ____________________________|
         V
</pre>
<p>array2: [layer3(next==NULL)][layer4(next==NULL)][layer5(next!=NULL)]</p>
<pre>
         ________________________________________________|
         V
</pre>
<p>array3: [layer6(next==NULL)][layer7(next==layer7)]</p>
<pre>
                               ^______|
</pre>
<p>While iterating through such a list we check for two conditions - exceeding count of layers and layer pointing to self. When any of that is met - we stopping iteration.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO asimage&hellip;</h2>
        <div class="sectioncontent">
<p>merge_layers() blender.h</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef struct ASImageLayer {</p>
<pre>
    ASImage *im;
    ARGB32   solid_color ;              /* If im == NULL, then fill
                                         * the area with this color. */
</pre>

<pre>
    int dst_x, dst_y;                   /* placement in overall
                                         * composition */
</pre>

<pre>
    /* clip area could be partially outside of the image -
     * image gets tiled in it */
    int clip_x, clip_y;
    unsigned int clip_width, clip_height;
</pre>

<pre>
    ARGB32 tint ;                       /* if 0 - no tint */
    struct ASImageBevel *bevel ;        /* border to wrap layer with
                                         * (for buttons, etc.)*/
</pre>

<pre>
    /* if image is clipped then we need to specify offsets of bevel as
     * related to clipped rectangle. Normally it should be :
     * 0, 0, im-&gt;width, im-&gt;height. And if width/height left 0 - it will
     * default to this values. Note that clipped image MUST be entirely
     * inside the bevel rectangle. !!!*/
    int bevel_x, bevel_y;
    unsigned int bevel_width, bevel_height;
</pre>

<pre>
    int merge_mode ;                        /* reserved for future use */
    merge_scanlines_func merge_scanlines ;  /* overlay method */
    struct ASImageLayer *next;              /* optional pointer to next
                                             * layer. If it points to
                                             * itself - then end of the
                                             * chain.*/
    void *data;                             /* hook to hung data on */
</pre>
<p>}ASImageLayer;</p><p>libAfterImage/asimage/GRADIENT_TYPE_flags</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>Combination of this flags defines the way gradient is rendered.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEGRADIENT_TYPE_DIAG</h2>
        <div class="sectioncontent">
<p>when set it will cause gradient's direction to be rotated by 45 degrees GRADIENT_TYPE_ORIENTATION will cause gradient direction to be rotated by 90 degrees. When combined with GRADIENT_TYPE_DIAG - rotates gradient direction by 135 degrees.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>#define GRADIENT_TYPE_DIAG          (0x01&lt;&lt;0) #define GRADIENT_TYPE_ORIENTATION   (0x01&lt;&lt;1) #define GRADIENT_TYPE_MASK          (GRADIENT_TYPE_ORIENTATION| &#92;</p>
<pre>
                                     GRADIENT_TYPE_DIAG)
</pre>
<p>libAfterImage/asimage/GRADIENT_TYPE</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>This are named combinations of above flags to define type of gradient.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEGRADIENT_Left2Right</h2>
        <div class="sectioncontent">
<p>normal left-to-right gradient. GRADIENT_TopLeft2BottomRight diagonal top-left to bottom-right. GRADIENT_Top2Bottom vertical top to bottom gradient. GRADIENT_BottomLeft2TopRight diagonal bottom-left to top-right.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>#define GRADIENT_Left2Right             0 #define GRADIENT_TopLeft2BottomRight    GRADIENT_TYPE_DIAG #define GRADIENT_Top2Bottom             GRADIENT_TYPE_ORIENTATION #define GRADIENT_BottomLeft2TopRight    (GRADIENT_TYPE_DIAG| &#92;</p>
<pre>
                                         GRADIENT_TYPE_ORIENTATION)
</pre>
<p>libAfterImage/ASGradient</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASGradient</h2>
        <div class="sectioncontent">
<p>describes how gradient is to be drawn.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>libAfterImage includes functionality to draw multipoint gradients in 4 different directions left-&gt;right, top-&gt;bottom and diagonal lefttop-&gt;rightbottom and bottomleft-&gt;topright. Each gradient described by type, number of colors (or anchor points), ARGB values for each color and offsets of each point from the beginning of gradient in fractions of entire length. There should be at least 2 anchor points. very first point should have offset of 0. and last point should have offset of 1. Gradients are drawn in ARGB colorspace, so it is possible to have semitransparent gradients.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO asimage&hellip;</h2>
        <div class="sectioncontent">
<p>make_gradient()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef struct ASGradient {</p>
<pre>
    int         type;     /* see GRADIENT_TYPE above */
</pre>

<pre>
    int         npoints;  /* number of anchor points */
    ARGB32     *color;    /* ARGB color values for each anchor point*/
    double     *offset;   /* offset of each point from the beginning in
                           * fractions of entire length */
</pre>
<p>}ASGradient;</p><p>libAfterImage/asimage/flip</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>This are flags that define rotation angle.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEFLIP_VERTICAL</h2>
        <div class="sectioncontent">
<p>defines rotation of 90 degrees counterclockwise. FLIP_UPSIDEDOWN defines rotation of 180 degrees counterclockwise. combined they define rotation of 270 degrees counterclockwise.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>#define FLIP_VERTICAL       (0x01&lt;&lt;0) #define FLIP_UPSIDEDOWN     (0x01&lt;&lt;1) #define FLIP_MASK           (FLIP_UPSIDEDOWN|FLIP_VERTICAL)</p><p>libAfterImage/asimage/flip_gradient()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEflip_gradient()</h2>
        <div class="sectioncontent">
<p>- rotates gradient in 90 degree increments.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASGradient *flip_gradient( ASGradient *orig, int flip );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    orig
  </dt>
  <dd>
    <p>- pointer to original ASGradient structure to be rotated.</p>
  </dd>
  <dt>
    flip
  </dt>
  <dd>
    <p>- value defining desired rotation.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>Same as original gradient if flip is 0. New gradient structure in any other case.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Rotates ( flips ) gradient data in 90 degree increments. When needed order of points is reversed. libAfterImage/asimage/tint</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>We use 32 bit ARGB values to define how tinting should be done. The formula for tinting particular channel data goes like that: tinted_data = (image_data * tint)/128 So if tint channel value is greater then 127 - same channel will be brighter in destination image; if it is lower then 127 - same channel will be darker in destination image. Tint channel value of 127 ( or 0x7F hex ) does not change anything. Alpha channel is tinted as well, allowing for creation of semitransparent images. Calculations are performed in 24.8 format - with 8 bit precision. Result is saturated to avoid overflow, and precision is carried over to next pixel ( error diffusion ), when con verting 24.8 to 8 bit format.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMETINT_NONE</h2>
        <div class="sectioncontent">
<p>special value that disables tinting TINT_LEAVE_SAME also disables tinting.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>#define TINT_NONE           0 #define TINT_LEAVE_SAME     (0x7F7F7F7F) #define TINT_HALF_DARKER    (0x3F3F3F3F) #define TINT_HALF_BRIGHTER  (0xCFCFCFCF) #define TINT_RED            (0x7F7F0000) #define TINT_GREEN          (0x7F007F00) #define TINT_BLUE           (0x7F00007F)</p><p>libAfterImage/asimage/compression</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>Defines the level of compression to attempt on ASImage scanlines.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASIM_COMPRESSION_NONE</h2>
        <div class="sectioncontent">
<p>defined as 0 - disables compression. ASIM_COMPRESSION_FULL defined as 100 - highest compression level. Anything in between 0 and 100 will cause only part of the scanline to be compressed. This is obsolete. Now all images are compressed if possible. libAfterImage/asimage/asimage_init()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEasimage_init()</h2>
        <div class="sectioncontent">
<p>frees datamembers of the supplied ASImage structure, and initializes it to all 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void asimage_init (ASImage * im, Bool free_resources);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure</p>
  </dd>
  <dt>
    free_resources
  </dt>
  <dd>
    <p>- if True will make function attempt to free all non-NULL pointers. libAfterImage/asimage/flush_asimage_cache()</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEflush_asimage_cache()</h2>
        <div class="sectioncontent">
<p>destroys XImage and mask XImage kept from previous conversions to/from X Pixmap.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void flush_asimage_cache (ASImage * im );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure libAfterImage/asimage/asimage_start()</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEasimage_start()</h2>
        <div class="sectioncontent">
<p>Allocates memory needed to store scanline of the image of supplied size. Assigns all the data members valid values. Makes sure that ASImage structure is ready to store image data.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void asimage_start (ASImage * im, unsigned int width,</p>
<pre>
                                  unsigned int height,
                                  unsigned int compression);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure</p>
  </dd>
  <dt>
    width
  </dt>
  <dd>
    <p>- width of the image</p>
  </dd>
  <dt>
    height
  </dt>
  <dd>
    <p>- height of the image</p>
  </dd>
  <dt>
    compression
  </dt>
  <dd>
    <p>- level of compression to perform on image data. compression has to be in range of 0-100 with 100 signifying highest level of compression.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>In order to resize ASImage structure after asimage_start() has been called, asimage_init() must be invoked to free all the memory, and then asimage_start() has to be called with new dimensions. libAfterImage/asimage/create_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_asimage()</h2>
        <div class="sectioncontent">
<p>Performs memory allocation for the new ASImage structure, as well as initialization of allocated structure based on supplied parameters.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *create_asimage( unsigned int width,</p>
<pre>
                         unsigned int height,
                         unsigned int compression);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    width
  </dt>
  <dd>
    <p>- desired image width</p>
  </dd>
  <dt>
    height
  </dt>
  <dd>
    <p>- desired image height</p>
  </dd>
  <dt>
    compression
  </dt>
  <dd>
    <p>- compression level in new ASImage( see asimage_start() for more ).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>Pointer to newly allocated and initialized ASImage structure on Success. NULL in case of any kind of error - that should never happen. libAfterImage/asimage/clone_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEclone_asimage()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *clone_asimage(ASImage *src, ASFlagType filter );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    src
  </dt>
  <dd>
    <p>- original ASImage.</p>
  </dd>
  <dt>
    filter
  </dt>
  <dd>
    <p>- bitmask of channels to be copied from one image to another.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>New ASImage, as a copy of original image.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Creates exact clone of the original ASImage, with same compression, back_color and rest of the attributes. Only ASImage data will be carried over. Any attached alternative forms of images (XImages, etc.) will not be copied. Any channel with unset bit in filter will not be copied. Image name, ASImageManager and ref_count will not be copied - use store_asimage() afterwards and make sure you use different name, to avoid clashes with original image. libAfterImage/asimage/destroy_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEdestroy_asimage()</h2>
        <div class="sectioncontent">
<p>frees all the memory allocated for specified ASImage.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void destroy_asimage( ASImage **im );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>If there was XImage attached to it - it will be deallocated as well.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>asview.c: ASView.5 libAfterImage/asimage/asimage_replace()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEasimage_replace()</h2>
        <div class="sectioncontent">
<p>will replace ASImage's data using data from another ASImage</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Bool asimage_replace (ASImage *im, ASImage *from);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure.</p>
  </dd>
  <dt>
    from
  </dt>
  <dd>
    <p>- pointer to ASImage from which to take the data.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>this function updates image without reallocating structure itself, which means that all pointers to it will still be valid. If that function succeeds - [from] ASImage will become unusable and should be deallocated using free() call. libAfterImage/asimage/set_asimage_vector()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEset_asimage_vector()</h2>
        <div class="sectioncontent">
<p>This function replaces contents of the vector member of ASImage structure with new double precision data.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>set_asimage_vector( ASImage *im, register double *vector );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure.</p>
  </dd>
  <dt>
    vector
  </dt>
  <dd>
    <p>- scientific data to attach to the image.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>Data must have size of width*height ahere width and height are size of the ASImage. libAfterImage/asimage/vectorize_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEvectorize_asimage()</h2>
        <div class="sectioncontent">
<p>This function replaces contents of the vector member of ASImage structure with new double precision data, generated from native ARGB32 image contents. Color palette is generated by indexing color values using max_colors, dither and opaque_threshold parameters.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASVectorPalette* vectorize_asimage( ASImage *im,</p>
<pre>
                                    unsigned int max_colors,
                                    unsigned int dither,
                                    int opaque_threshold );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure.</p>
  </dd>
  <dt>
    max_colors
  </dt>
  <dd>
    <p>- maximum size of the colormap.</p>
  </dd>
  <dt>
    dither
  </dt>
  <dd>
    <p>- number of bits to strip off the color data ( 0...7 )</p>
  </dd>
  <dt>
    opaque_threshold
  </dt>
  <dd>
    <p>- alpha channel threshold at which pixel should be treated as opaque</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>pointer to the ASVectorPalette structure that could be used for reverse conversion from double values to ARGB32.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>alt.vector member of the supplied ASImage will be replaced and will contain WIDTHxHEIGHT double values representing generated scientific data. libAfterImage/asimage/create_image_manager()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_image_manager()</h2>
        <div class="sectioncontent">
<p>create ASImage management and reference counting object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImageManager *create_image_manager( ASImageManager *reusable_memory,</p>
<pre>
                                      double gamma, ... );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    reusable_memory
  </dt>
  <dd>
    <p>- optional pointer to a block of memory to be used to store ASImageManager object.</p>
  </dd>
  <dt>
    double
  </dt>
  <dd>
    <p>gamma - value of gamma correction to be used while loading images from files.</p>
  </dd>
  <dt>
    ...
  </dt>
  <dd>
    <p>- NULL terminated list of up to 8 PATH strings to list locations at which images could be found.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Creates ASImageManager object in memory and initializes it with requested gamma value and PATH list. This Object will contain a hash table referencing all the loaded images. When such object is used while loading images from the file - gamma and PATH values will be used, so that all the loaded and referenced images will have same parameters. File name will be used as the image name, and if same file is attempted to be loaded again - instead reference will be incremented, and previously loaded image will be retyrned. All the images stored in ASImageManager's table will contain a back pointer to it, and they must be deallocated only by calling release_asimage(). destroy_asimage() will refuse to deallocate such an image. libAfterImage/asimage/destroy_image_manager()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEdestroy_image_manager()</h2>
        <div class="sectioncontent">
<p>destroy management obejct.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void destroy_image_manager( struct ASImageManager *imman,</p>
<pre>
                               Bool reusable );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    imman
  </dt>
  <dd>
    <p>- pointer to ASImageManager object to be deallocated</p>
  </dd>
  <dt>
    reusable
  </dt>
  <dd>
    <p>- if True, then memory that holds object itself will not be deallocated. Useful when object is created on stack.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Destroys all the referenced images, PATH values and if reusable is False, also deallocates object's memory. libAfterImage/asimage/store_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEstore_asimage()</h2>
        <div class="sectioncontent">
<p>add ASImage to the reference.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Bool store_asimage( ASImageManager* imageman, ASImage *im,</p>
<pre>
                       const char *name );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    imageman
  </dt>
  <dd>
    <p>- pointer to valid ASImageManager object.</p>
  </dd>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to the image to be stored.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>- unique name of the image.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Adds specifyed image to the ASImageManager's list of referenced images. Stored ASImage could be deallocated only by release_asimage(), or when ASImageManager object itself is destroyed. libAfterImage/asimage/relocate_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMErelocate_asimage()</h2>
        <div class="sectioncontent">
<p>relocate ASImage into a different image manager.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void     relocate_asimage( ASImageManager* to_imageman, ASImage *im );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    to_imageman
  </dt>
  <dd>
    <p>- pointer to valid ASImageManager object.</p>
  </dd>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to the image to be stored.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Moves image from one ASImageManager's list of referenced images into another ASImageManager. Reference count will be kept the same. libAfterImage/asimage/fetch_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEfetch_asimage()</h2>
        <div class="sectioncontent">
<p>query_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *fetch_asimage( ASImageManager* imageman, const char *name ); ASImage *query_asimage( ASImageManager* imageman, const char *name );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    imageman
  </dt>
  <dd>
    <p>- pointer to valid ASImageManager object.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>- unique name of the image.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Looks for image with the name in ASImageManager's list and if found, returns pointer to it. Note that query_asimage() does not increment reference count, while fetch_asimage() does. Therefore if fetch_asimage() is used - release_asimage() should be called , when image is no longer in use. libAfterImage/asimage/dup_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEdup_asimage()</h2>
        <div class="sectioncontent">
<p>increment reference count of stored ASImage.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImage *dup_asimage( ASImage* im );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to already referenced image. libAfterImage/asimage/release_asimage()</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMErelease_asimage()</h2>
        <div class="sectioncontent">
<p>decrement reference count for given ASImage. release_asimage_by_name() decrement reference count for ASImage identifyed by its name.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>int release_asimage( ASImage *im ); int release_asimage_by_name( ASImageManager *imman, char *name );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to already referenced image.</p>
  </dd>
  <dt>
    imageman
  </dt>
  <dd>
    <p>- pointer to valid ASImageManager object.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>- unique name of the image.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Decrements reference count on the ASImage object and destroys it if reference count is below zero. libAfterImage/asimage/forget_asimage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEforget_asimage()</h2>
        <div class="sectioncontent">
<p>remove ASImage from ASImageManager's hash by pointer. forget_asimage_name() remove ASImage from ASImageManager's hash by its name.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void     forget_asimage( ASImage *im ); void  forget_asimage_name( ASImageManager *imman, const char *name );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>pointer to already referenced image.</p>
  </dd>
  <dt>
    imageman
  </dt>
  <dd>
    <p>pointer to valid ASImageManager object.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>unique name of the image. libAfterImage/safe_asimage_destroy()</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEsafe_asimage_destroy()</h2>
        <div class="sectioncontent">
<p>either release or destroy asimage, checking if it is attached to ASImageManager.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>int      safe_asimage_destroy( ASImage *im );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>pointer to and ASImage structure. libAfterImage/print_asimage_manager()</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEprint_asimage_manager()</h2>
        <div class="sectioncontent">
<p>prints list of images referenced in given ASImageManager structure. libAfterImage/asimage/destroy_asgradient()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEdestroy_asgradient()</h2>
        <div class="sectioncontent">
<p>- destroy ASGradient structure, deallocating all associated memory libAfterImage/asimage/init_image_layers()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEinit_image_layers()</h2>
        <div class="sectioncontent">
<p>- initialize set of ASImageLayer structures.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void init_image_layers( register ASImageLayer *l, int count );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    l
  </dt>
  <dd>
    <p>- pointer to valid ASImageLayer structure.</p>
  </dd>
  <dt>
    count
  </dt>
  <dd>
    <p>- number of elements to initialize.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Initializes array on ASImageLayer structures to sensible defaults. Basically - all zeros and merge_scanlines == alphablend_scanlines. libAfterImage/asimage/create_image_layers()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_image_layers()</h2>
        <div class="sectioncontent">
<p>- allocate and initialize set of ASImageLayer's.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASImageLayer *create_image_layers( int count );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    count
  </dt>
  <dd>
    <p>- number of ASImageLayer structures in allocated array.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>Pointer to newly allocated and initialized array of ASImageLayer structures on Success. NULL in case of any kind of error - that should never happen.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Performs memory allocation for the new array of ASImageLayer structures, as well as initialization of allocated structure to sensible defaults - merge_func will be set to alphablend_scanlines. libAfterImage/asimage/destroy_image_layers()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEdestroy_image_layers()</h2>
        <div class="sectioncontent">
<p>- destroy set of ASImageLayer structures.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void destroy_image_layers( register ASImageLayer *l,</p>
<pre>
                           int count,
                           Bool reusable );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    l
  </dt>
  <dd>
    <p>- pointer to pointer to valid array of ASImageLayer structures.</p>
  </dd>
  <dt>
    count
  </dt>
  <dd>
    <p>- number of structures in array.</p>
  </dd>
  <dt>
    reusable
  </dt>
  <dd>
    <p>- if True - then array itself will not be deallocates - which is usable when it was allocated on stack.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>frees all the memory allocated for specified array of ASImageLayer s. If there was ASImage and/or ASImageBevel attached to it - it will be deallocated as well. libAfterImage/asimage/asimage_add_line()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEasimage_add_line()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>size_t asimage_add_line ( ASImage * im, ColorPart color,</p>
<pre>
                          CARD32 * data, unsigned int y);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure</p>
  </dd>
  <dt>
    color
  </dt>
  <dd>
    <p>- color channel's number</p>
  </dd>
  <dt>
    data
  </dt>
  <dd>
    <p>- raw channel data of 32 bits per pixel - only lowest 8 bits gets encoded.</p>
  </dd>
  <dt>
    y
  </dt>
  <dd>
    <p>- image row starting with 0</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>asimage_add_line() return size of the encoded channel scanline in bytes. On failure it will return 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Encodes raw data of the single channel into ASImage channel scanline. based on compression level selected for this ASImage all or part of the scanline will be RLE encoded. libAfterImage/asimage/asimage_add_line_mono()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEasimage_add_line_mono()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>size_t asimage_add_line_mono ( ASImage * im, ColorPart color,</p>
<pre>
                               CARD8 value, unsigned int y);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure</p>
  </dd>
  <dt>
    color
  </dt>
  <dd>
    <p>- color channel's number</p>
  </dd>
  <dt>
    value
  </dt>
  <dd>
    <p>- value for the channel</p>
  </dd>
  <dt>
    y
  </dt>
  <dd>
    <p>- image row starting with 0</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>asimage_add_line_mono() return size of the encoded channel scanline in bytes. On failure it will return 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>encodes ASImage channel scanline to have same color components value in every pixel. Useful for vertical gradients for example. libAfterImage/asimage/get_asimage_chanmask()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEget_asimage_chanmask()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASFlagType get_asimage_chanmask( ASImage *im);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- valid ASImage object.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>goes throu all the scanlines of the ASImage and toggles bits representing those components that have at least some data. libAfterImage/asimage/move_asimage_channel()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEmove_asimage_channel()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void move_asimage_channel( ASImage *dst, int channel_dst,</p>
<pre>
                           ASImage *src, int channel_src );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    dst
  </dt>
  <dd>
    <p>- ASImage which will have its channel substituted;</p>
  </dd>
  <dt>
    channel_dst
  </dt>
  <dd>
    <p>- what channel to move data to;</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- ASImage which will donate its channel to dst;</p>
  </dd>
  <dt>
    channel_src
  </dt>
  <dd>
    <p>- what source image channel to move data from.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>MOves channel data from one ASImage to another, while discarding what was already in destination's channel.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>Source image (donor) will loose its channel data, as it will be moved to destination ASImage. Also there is a condition that both images must be of the same width - otherwise function returns without doing anything. If height is different - the minimum of two will be used. libAfterImage/asimage/copy_asimage_channel()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcopy_asimage_channel()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void copy_asimage_channel( ASImage *dst, int channel_dst,</p>
<pre>
                           ASImage *src, int channel_src );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    dst
  </dt>
  <dd>
    <p>- ASImage which will have its channel substituted;</p>
  </dd>
  <dt>
    channel_dst
  </dt>
  <dd>
    <p>- what channel to copy data to;</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- ASImage which will donate its channel to dst;</p>
  </dd>
  <dt>
    channel_src
  </dt>
  <dd>
    <p>- what source image channel to copy data from.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Same as move_asimage_channel() but makes copy of channel's data instead of simply moving it from one image to another. libAfterImage/asimage/copy_asimage_lines()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcopy_asimage_lines()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void copy_asimage_lines( ASImage *dst, unsigned int offset_dst,</p>
<pre>
                         ASImage *src, unsigned int offset_src,
                         unsigned int nlines, ASFlagType filter );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    dst
  </dt>
  <dd>
    <p>- ASImage which will have its channel substituted;</p>
  </dd>
  <dt>
    offset_dst
  </dt>
  <dd>
    <p>- scanline in destination image to copy to;</p>
  </dd>
  <dt>
    src
  </dt>
  <dd>
    <p>- ASImage which will donate its channel to dst;</p>
  </dd>
  <dt>
    offset_src
  </dt>
  <dd>
    <p>- scanline in source image to copy data from;</p>
  </dd>
  <dt>
    nlines
  </dt>
  <dd>
    <p>- number of scanlines to be copied;</p>
  </dd>
  <dt>
    filter
  </dt>
  <dd>
    <p>- specifies what channels should be copied.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Makes copy of scanline data for continuos set of scanlines, affecting only those channels marked in filter. NOTE Images must be of the same width. libAfterImage/asimage/verbosity</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>This are flags that define what should be printed by asimage_print_line():</p>
<pre>
    VRB_LINE_SUMMARY    - print only summary for each scanline
    VRB_LINE_CONTENT    - print summary and data for each scanline
    VRB_CTRL_EXPLAIN    - print summary, data and control codes for each
                          scanline
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>#define VRB_LINE_SUMMARY    (0x01&lt;&lt;0) #define VRB_LINE_CONTENT    (0x01&lt;&lt;1) #define VRB_CTRL_EXPLAIN    (0x01&lt;&lt;2) #define VRB_EVERYTHING      (VRB_LINE_SUMMARY|VRB_CTRL_EXPLAIN| &#92;</p>
<pre>
                             VRB_LINE_CONTENT)
</pre>
<p>libAfterImage/asimage/asimage_print_line()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEasimage_print_line()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    unsigned int asimage_print_line ( ASImage * im, ColorPart color,
                                      unsigned int y,
                                      unsigned long verbosity);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    im
  </dt>
  <dd>
    <p>- pointer to valid ASImage structure</p>
  </dd>
  <dt>
    color
  </dt>
  <dd>
    <p>- color channel's number</p>
  </dd>
  <dt>
    y
  </dt>
  <dd>
    <p>- image row starting with 0</p>
  </dd>
  <dt>
    verbosity
  </dt>
  <dd>
    <p>- verbosity level - any combination of flags is allowed</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>amount of memory used by this particular channel of specified scanline.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>asimage_print_line() prints data stored in specified image scanline channel. That may include simple summary of how much memory is used, actual visible data, and/or RLE control codes. That helps one to see how effectively data is encoded.</p><p>Useful mostly for debugging purposes. libAfterImage/asimage/get_asimage_channel_rects()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEget_asimage_channel_rects()</h2>
        <div class="sectioncontent">
<p>- translate image into a list of rectangles.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>XRectangle*</p>
<pre>
    get_asimage_channel_rects( ASImage *src, int channel,
                               unsigned int threshold,
                               unsigned int *rects_count_ret );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    src
  </dt>
  <dd>
    <p>- ASImage which will donate its channel to dst;</p>
  </dd>
  <dt>
    channel
  </dt>
  <dd>
    <p>- what source image channel to copy data from;</p>
  </dd>
  <dt>
    threshold
  </dt>
  <dd>
    <p>- threshold to compare channel values against;</p>
  </dd>
  <dt>
    rects_count_ret
  </dt>
  <dd>
    <p>- returns count of generated rectangles.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This function will translate contents of selected channel (usually alpha) into a list of rectangles, ecompasing regions with values above the threshold. This is useful to generate shape of the window to be used with X Shape extension.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="asgrad.3x.html"><span aria-hidden="true">&larr;</span> asgrad.3x: Asgrad- demonstrates rendering of multi point linear gradients libafterimage/tutorials/asgrad</a></li>
   <li class="next"><a href="asimagexml.3x.html">asimagexml.3x: Asimagexml- xml schema to be used for scripting image manipulation by afterstep and ascompose libafterimage/asimagexml <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

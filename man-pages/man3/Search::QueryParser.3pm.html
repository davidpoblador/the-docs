<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Search::QueryParser: Parses a query string into a data structure suitable for external search engines</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parses a query string into a data structure suitable for external search engines">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Search::QueryParser (3pm) manual">
  <meta name="twitter:description" content="Parses a query string into a data structure suitable for external search engines">
  <meta name="twitter:image" content="https://www.carta.tech/images/libsearch-queryparser-perl-Search::QueryParser-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Search::QueryParser.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Search::QueryParser (3pm) manual" />
  <meta property="og:description" content="Parses a query string into a data structure suitable for external search engines" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libsearch-queryparser-perl-Search::QueryParser-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Search::QueryParser<small> (3pm)</small></h1>
        <p class="lead">Parses a query string into a data structure suitable for external search engines</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Search::QueryParser.3pm.html">
      <span itemprop="name">Search::QueryParser: Parses a query string into a data structure suitable for external search engines</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libsearch-queryparser-perl/">
      <span itemprop="name">libsearch-queryparser-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Search::QueryParser.3pm.html">
      <span itemprop="name">Search::QueryParser: Parses a query string into a data structure suitable for external search engines</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  my $qp = new Search::QueryParser;
  my $s = &apos;+mandatoryWord -excludedWord +field:word "exact phrase"&apos;;
  my $query = $qp-&gt;parse($s)  or die "Error in query : " . $qp-&gt;err;
  $someIndexer-&gt;search($query);

  # query with comparison operators and implicit plus (second arg is true)
  $query = $qp-&gt;parse("txt~&apos;^foo.*&apos; date&gt;=&apos;01.01.2001&apos; date&lt;=&apos;02.02.2002&apos;", 1);

  # boolean operators (example below is equivalent to "+a +(b c) -d")
  $query = $qp-&gt;parse("a AND (b OR c) AND NOT d");

  # subset of rows
  $query = $qp-&gt;parse("Id#123,444,555,666 AND (b OR c)");
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module parses a query string into a data structure to be handled by external search engines.  For examples of such engines, see File::Tabular and Search::Indexer.</p><p>The query string can contain simple terms, \*(L"exact phrases\*(R", field names and comparison operators, '+/-' prefixes, parentheses, and boolean connectors.</p><p>The parser can be parameterized by regular expressions for specific notions of \*(L"term\*(R", \*(L"field name\*(R" or \*(L"operator\*(R" ; see the new method. The parser has no support for lemmatization or other term transformations : these should be done externally, before passing the query data structure to the search engine.</p><p>The data structure resulting from a parsed query is a tree of terms and operators, as described below in the parse method.  The interpretation of the structure is up to the external search engine that will receive the parsed query ; the present module does not make any assumption about what it means to be \*(L"equal\*(R" or to \*(L"contain\*(R" a term.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUERY STRING</h2>
        <div class="sectioncontent">
<p>The query string is decomposed into \*(L"items\*(R", where each item has an optional sign prefix, an optional field name and comparison operator, and a mandatory value.</p><h3>Sign prefix</h3>
<p>Prefix '+' means that the item is mandatory. Prefix '-' means that the item must be excluded. No prefix means that the item will be searched for, but is not mandatory.</p><p>As far as the result set is concerned, \*(C`+a +b c\*(C' is strictly equivalent to \*(C`+a +b\*(C' : the search engine will return documents containing both terms 'a' and 'b', and possibly also term 'c'. However, if the search engine also returns relevance scores, query \*(C`+a +b c\*(C' might give a better score to documents containing also term 'c'.</p><p>See also section \*(L"Boolean connectors\*(R" below, which is another way to combine items into a query.</p>
<h3>Field name and comparison operator</h3>
<p>Internally, each query item has a field name and comparison operator; if not written explicitly in the query, these take default values &apos;&apos; (empty field name) and &apos;:&apos; (colon operator).</p><p>Operators have a left operand (the field name) and a right operand (the value to be compared with); for example, \*(C`foo:bar\*(C' means \*(L"search documents containing term 'bar' in field 'foo'\*(R", whereas \*(C`foo=bar\*(C' means \*(L"search documents where field 'foo' has exact value 'bar'\*(R".</p><p>Here is the list of admitted operators with their intended meaning : treat value as a term to be searched within field. This is the default operator. treat value as a regex; match field against the regex. negation of above classical relational operators Inclusion in the set of comma-separated integers supplied on the right-hand side.</p><p>Operators \*(C`:\*(C', \*(C`~\*(C', \*(C`=~\*(C', \*(C`!~\*(C' and \*(C`#\*(C' admit an empty left operand (so the field name will be &apos;&apos;). Search engines will usually interpret this as \*(L"any field\*(R" or \*(L"the whole data record\*(R".</p>
<h3>Value</h3>
<p>A value (right operand to a comparison operator) can be</p><ul>
<li><p>just a term (as recognized by regex \*(C`rxTerm\*(C', see new method below)</p></li><li><p>A quoted phrase, i.e. a collection of terms within single or double quotes. Quotes can be used not only for \*(L"exact phrases\*(R", but also to prevent misinterpretation of some values : for example \*(C`-2\*(C' would mean \*(L"value '2' with prefix '-'\*(R", in other words \*(L"exclude term '2'\*(R", so if you want to search for value -2, you should write "-2" instead. In the last example of the synopsis, quotes were used to prevent splitting of dates into several search terms.</p></li><li><p>a subquery within parentheses. Field names and operators distribute over parentheses, so for example \*(C`foo:(bar bie)\*(C' is equivalent to \*(C`foo:bar foo:bie\*(C'. Nested field names such as \*(C`foo:(bar:bie)\*(C' are not allowed. Sign prefixes do not distribute : \*(C`+(foo bar) +bie\*(C' is not equivalent to \*(C`+foo +bar +bie\*(C'.</p></li>
</ul>
<h3>Boolean connectors</h3>
<p>Queries can contain boolean connectors '\s-1AND\s0', '\s-1OR\s0', '\s-1NOT\s0' (or their equivalent in some other languages). This is mere syntactic sugar for the '+' and '-' prefixes : \*(C`a AND b\*(C' is translated into \*(C`+a +b\*(C'; \*(C`a OR b\*(C' is translated into \*(C`(a b)\*(C'; \*(C`NOT a\*(C' is translated into \*(C`-a\*(C'. \*(C`+a OR b\*(C' does not make sense, but it is translated into \*(C`(a b)\*(C', under the assumption that the user understands \*(L"\s-1OR\s0\*(R" better than a '+' prefix. \*(C`-a OR b\*(C' does not make sense either, but has no meaningful approximation, so it is rejected.</p><p>Combinations of \s-1AND/OR\s0 clauses must be surrounded by parentheses, i.e. \*(C`(a AND b) OR c\*(C' or \*(C`a AND (b OR c)\*(C' are allowed, but \*(C`a AND b OR c\*(C' is not.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    new
  </dt>
  <dd>
    <p>  new(rxTerm   =&gt; qr/.../, rxOp =&gt; qr/.../, ...) Creates a new query parser, initialized with (optional) regular expressions :</p>
<dl class='dl-vertical'>
  <dt>
    rxTerm
  </dt>
  <dd>
    <p>Regular expression for matching a term. Of course it should not match the empty string. Default value is \*(C`qr/[^&#92;s()]+/\*(C'. A term should not be allowed to include parenthesis, otherwise the parser might get into trouble.</p>
  </dd>
  <dt>
    rxField
  </dt>
  <dd>
    <p>Regular expression for matching a field name. Default value is \*(C`qr/&#92;w+/\*(C' (meaning of \*(C`&#92;w\*(C' according to \*(C`use locale\*(C').</p>
  </dd>
  <dt>
    rxOp
  </dt>
  <dd>
    <p>Regular expression for matching an operator. Default value is \*(C`qr/==|&lt;=|&gt;=|!=|=~|!~|:|=|&lt;|&gt;|~/\*(C'. Note that the longest operators come first in the regex, because \*(L"alternatives are tried from left to right\*(R" (see \*(L"Version 8 Regular Expressions\*(R" in perlre) : this is to avoid \*(C`a&lt;=3\*(C' being parsed as \*(C`a &lt; &apos;=3&apos;\*(C'.</p>
  </dd>
  <dt>
    rxOpNoField
  </dt>
  <dd>
    <p>Regular expression for a subset of the operators which admit an empty left operand (no field name). Default value is \*(C`qr/=~|!~|~|:/\*(C'. Such operators can be meaningful for comparisons with \*(L"any field\*(R" or with \*(L"the whole record\*(R" ; the precise interpretation depends on the search engine.</p>
  </dd>
  <dt>
    rxAnd
  </dt>
  <dd>
    <p>Regular expression for boolean connector \s-1AND\s0. Default value is \*(C`qr/AND|ET|UND|E/\*(C'.</p>
  </dd>
  <dt>
    rxOr
  </dt>
  <dd>
    <p>Regular expression for boolean connector \s-1OR\s0. Default value is \*(C`qr/OR|OU|ODER|O/\*(C'.</p>
  </dd>
  <dt>
    rxNot
  </dt>
  <dd>
    <p>Regular expression for boolean connector \s-1NOT\s0. Default value is \*(C`qr/NOT|PAS|NICHT|NON/\*(C'.</p>
  </dd>
  <dt>
    defField
  </dt>
  <dd>
    <p>If no field is specified in the query, use <em>defField</em>. The default is the empty string "".</p>
  </dd>

</dl>

  </dd>
  <dt>
    parse
  </dt>
  <dd>
    <p>  $q = $queryParser-&gt;parse($queryString, $implicitPlus); Returns a data structure corresponding to the parsed string. The second argument is optional; if true, it adds an implicit '+' in front of each term without prefix, so \*(C`parse("+a b c -d", 1)\*(C' is equivalent to \*(C`parse("+a +b +c -d")\*(C'. This is often seen in common \s-1WWW\s0 search engines as an option \*(L"match all words\*(R". The return value has following structure :   { &apos;+&apos; =&gt; [{field=&gt;&apos;f1&apos;, op=&gt;&apos;:&apos;, value=&gt;&apos;v1&apos;, quote=&gt;&apos;q1&apos;},             {field=&gt;&apos;f2&apos;, op=&gt;&apos;:&apos;, value=&gt;&apos;v2&apos;, quote=&gt;&apos;q2&apos;}, ...],     &apos;&apos;  =&gt; [...],     &apos;-&apos; =&gt; [...]   } In other words, it is a hash ref with 3 keys &apos;+&apos;, &apos;&apos; and &apos;-&apos;, corresponding to the 3 sign prefixes (mandatory, ordinary or excluded items). Each key holds either a ref to an array of items, or \*(C`undef\*(C' (no items with this prefix in the query). An <em>item</em> is a hash ref containing</p><p>scalar, field name (may be the empty string) scalar, operator scalar, character that was used for quoting the value ('\*(L"', \*(R"'" or undef) Either</p><ul>
<li><p>a scalar (simple term), or</p></li><li><p>a recursive ref to another query structure. In that case, \*(C`op\*(C' is necessarily &apos;()&apos; ; this corresponds to a subquery in parentheses.</p></li>
</ul><p>In case of a parsing error, \*(C`parse\*(C' returns \*(C`undef\*(C'; method err can be called to get an explanatory message.</p>
  </dd>
  <dt>
    err
  </dt>
  <dd>
    <p>  $msg = $queryParser-&gt;err; Message describing the last parse error</p>
  </dd>
  <dt>
    unparse
  </dt>
  <dd>
    <p>  $s = $queryParser-&gt;unparse($query); Returns a string representation of the $query data structure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Laurent Dami, &lt;laurent.dami \s-1AT\s0 etat ge ch&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2005, 2007 by Laurent Dami.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Scope::Guard.3pm.html"><span aria-hidden="true">&larr;</span> Scope::Guard.3pm: Lexically-scoped resource management</a></li>
   <li class="next"><a href="Sendmail::Milter.3pm.html">Sendmail::Milter.3pm: Compatibility interface for sendmail::pmilter <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

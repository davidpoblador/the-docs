<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>bootstrap-vz: Bootstrap-vz documentation  contents:</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Bootstrap-vz documentation  contents:">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="bootstrap-vz (3) manual">
  <meta name="twitter:description" content="Bootstrap-vz documentation  contents:">
  <meta name="twitter:image" content="https://www.carta.tech/images/bootstrap-vz-bootstrap-vz-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/bootstrap-vz.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="bootstrap-vz (3) manual" />
  <meta property="og:description" content="Bootstrap-vz documentation  contents:" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/bootstrap-vz-bootstrap-vz-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">bootstrap-vz<small> (3)</small></h1>
        <p class="lead">Bootstrap-vz documentation  contents:</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/bootstrap-vz.3.html">
      <span itemprop="name">bootstrap-vz: Bootstrap-vz documentation  contents:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/bootstrap-vz/">
      <span itemprop="name">bootstrap-vz</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/bootstrap-vz.3.html">
      <span itemprop="name">bootstrap-vz: Bootstrap-vz documentation  contents:</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">BASE FUNCTIONALITY</h2>
        <div class="sectioncontent">
<p>The base module represents concepts of the bootstrapping process that tasks can interact with and handles the gather, sorting and running of tasks.</p><h3>Filesystem handling</h3>

<h3>Volume</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.volume.Volume(partition_map)</strong></p>
  </dt>
  <dd>
    <p>Represents an abstract volume. This class is a finite state machine and represents the state of the real volume.</p>
  </dd>
  <dt>
    <p><strong>_before_link_dm_node(e)</strong></p>
  </dt>
  <dd>
    <p>Links the volume using the device mapper This allows us to create a &apos;window&apos; into the volume that acts like a volum in itself. Mainly it is used to fool grub into thinking that it is working with a real volume, rather than a loopback device or a network block device.</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>e</strong> (<em>_e_obj</em>) -- Event object containing arguments to create()</p>
  </dd>

</dl>
<p>Keyword arguments to link_dm_node() are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>logical_start_sector</strong> (<em>int</em>) -- The sector the volume should start at in the new volume</p></li><li><p><strong>start_sector</strong> (<em>int</em>) -- The offset at which the volume should begin to be mapped in the new volume</p></li><li><p><strong>sectors</strong> (<em>int</em>) -- The number of sectors that should be mapped</p><p>Read more at: <em>http://manpages.debian.org/cgi-bin/man.cgi?query=dmsetup&apropos=0&sektion=0&manpath=Debian+7.0+wheezy&format=html&locale=en</em></p></li>
</ul>
  </dd>
  <dt>
    <p><strong>Raises VolumeError</strong></p>
  </dt>
  <dd>
    <p>When a free block device cannot be found.</p>
  </dd>
  <dt>
    <p><strong>_before_unlink_dm_node(e)</strong></p>
  </dt>
  <dd>
    <p>Unlinks the device mapping</p>
  </dd>
  <dt>
    <p><strong>_check_blocking(e)</strong></p>
  </dt>
  <dd>
    <p>Checks whether the volume is blocked</p>
  </dd>
  <dt>
    <p><strong>Raises VolumeError</strong></p>
  </dt>
  <dd>
    <p>When the volume is blocked from being detached</p>
  </dd>

</dl>

<h3>Partitionmaps</h3>

<h3>Abstract Partitionmap</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitionmaps.abstract.AbstractPartitionMap(bootloader)</strong></p>
  </dt>
  <dd>
    <p>Abstract representation of a partiton map This class is a finite state machine and represents the state of the real partition map</p>
  </dd>
  <dt>
    <p><strong>_before_map(event)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>Raises PartitionError</strong></p>
  </dt>
  <dd>
    <p>In case a partition could not be mapped.</p>
  </dd>
  <dt>
    <p><strong>_before_unmap(event)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>Raises PartitionError</strong></p>
  </dt>
  <dd>
    <p>If the a partition cannot be unmapped</p>
  </dd>
  <dt>
    <p><strong>create(volume)</strong></p>
  </dt>
  <dd>
    <p>Creates the partition map</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>volume</strong> (<em>Volume</em>) -- The volume to create the partition map on</p>
  </dd>
  <dt>
    <p><strong>get_total_size()</strong></p>
  </dt>
  <dd>
    <p>Returns the total size the partitions occupy</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The size of all partitions</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>Bytes</p>
  </dd>
  <dt>
    <p><strong>is_blocking()</strong></p>
  </dt>
  <dd>
    <p>Returns whether the partition map is blocking volume detach operations</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>bool</p>
  </dd>
  <dt>
    <p><strong>map(volume)</strong></p>
  </dt>
  <dd>
    <p>Maps the partition map to device nodes</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>volume</strong> (<em>Volume</em>) -- The volume the partition map resides on</p>
  </dd>
  <dt>
    <p><strong>unmap(volume)</strong></p>
  </dt>
  <dd>
    <p>Unmaps the partition</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>volume</strong> (<em>Volume</em>) -- The volume to unmap the partition map from</p>
  </dd>

</dl>

<h3>GPT Partitionmap</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitionmaps.gpt.GPTPartitionMap(data, bootloader)</strong></p>
  </dt>
  <dd>
    <p>Represents a GPT partition map</p>
  </dd>
  <dt>
    <p><strong>_before_create(event)</strong></p>
  </dt>
  <dd>
    <p>Creates the partition map</p>
  </dd>

</dl>

<h3>MS-DOS Partitionmap</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitionmaps.msdos.MSDOSPartitionMap(data, bootloader)</strong></p>
  </dt>
  <dd>
    <p>Represents a MS-DOS partition map Sometimes also called MBR (but that confuses the hell out of me, so ms-dos it is)</p>
  </dd>

</dl>

<h3>No Partitionmap</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitionmaps.none.NoPartitions(data, bootloader)</strong></p>
  </dt>
  <dd>
    <p>Represents a virtual &apos;NoPartitions&apos; partitionmap. This virtual partition map exists because it is easier for tasks to simply always deal with partition maps and then let the base abstract that away.</p>
  </dd>
  <dt>
    <p><strong>get_total_size()</strong></p>
  </dt>
  <dd>
    <p>Returns the total size the partitions occupy</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The size of all the partitions</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>Bytes</p>
  </dd>
  <dt>
    <p><strong>is_blocking()</strong></p>
  </dt>
  <dd>
    <p>Returns whether the partition map is blocking volume detach operations</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>bool</p>
  </dd>

</dl>

<h3>Partitions</h3>

<h3>Abstract partition</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitions.abstract.AbstractPartition(size, filesystem, format_command)</strong></p>
  </dt>
  <dd>
    <p>Abstract representation of a partiton This class is a finite state machine and represents the state of the real partition</p>
  </dd>
  <dt>
    <p><strong>class Mount(source, destination, opts)</strong></p>
  </dt>
  <dd>
    <p>Represents a mount into the partition</p>
  </dd>
  <dt>
    <p><strong>mount(prefix)</strong></p>
  </dt>
  <dd>
    <p>Performs the mount operation or forwards it to another partition</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>prefix</strong> (<em>str</em>) -- Path prefix of the mountpoint</p>
  </dd>
  <dt>
    <p><strong>unmount()</strong></p>
  </dt>
  <dd>
    <p>Performs the unmount operation or asks the partition to unmount itself</p>
  </dd>
  <dt>
    <p><strong>AbstractPartition._after_mount(e)</strong></p>
  </dt>
  <dd>
    <p>Mount any mounts associated with this partition</p>
  </dd>
  <dt>
    <p><strong>AbstractPartition._before_format(e)</strong></p>
  </dt>
  <dd>
    <p>Formats the partition</p>
  </dd>
  <dt>
    <p><strong>AbstractPartition._before_mount(e)</strong></p>
  </dt>
  <dd>
    <p>Mount the partition</p>
  </dd>
  <dt>
    <p><strong>AbstractPartition._before_unmount(e)</strong></p>
  </dt>
  <dd>
    <p>Unmount any mounts associated with this partition</p>
  </dd>
  <dt>
    <p><strong>AbstractPartition.add_mount(source, destination, opts=[])</strong></p>
  </dt>
  <dd>
    <p>Associate a mount with this partition Automatically mounts it</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>source</strong> (<em>str,AbstractPartition</em>) -- The source of the mount</p></li><li><p><strong>destination</strong> (<em>str</em>) -- The path to the mountpoint</p></li><li><p><strong>opts</strong> (<em>list</em>) -- Any options that should be passed to the mount command</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>AbstractPartition.get_end()</strong></p>
  </dt>
  <dd>
    <p>Gets the end of the partition</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The end of the partition</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>Bytes</p>
  </dd>
  <dt>
    <p><strong>AbstractPartition.get_uuid()</strong></p>
  </dt>
  <dd>
    <p>Gets the UUID of the partition</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The UUID of the partition</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>str</p>
  </dd>
  <dt>
    <p><strong>AbstractPartition.remove_mount(destination)</strong></p>
  </dt>
  <dd>
    <p>Remove a mount from this partition Automatically unmounts it</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>destination</strong> (<em>str</em>) -- The mountpoint path of the mount that should be removed</p>
  </dd>

</dl>

<h3>Base partition</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitions.base.BasePartition(size, filesystem, format_command, previous)</strong></p>
  </dt>
  <dd>
    <p>Represents a partition that is actually a partition (and not a virtual one like &apos;Single&apos;)</p>
  </dd>
  <dt>
    <p><strong>_before_create(e)</strong></p>
  </dt>
  <dd>
    <p>Creates the partition</p>
  </dd>
  <dt>
    <p><strong>create(volume)</strong></p>
  </dt>
  <dd>
    <p>Creates the partition</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>volume</strong> (<em>Volume</em>) -- The volume to create the partition on</p>
  </dd>
  <dt>
    <p><strong>get_index()</strong></p>
  </dt>
  <dd>
    <p>Gets the index of this partition in the partition map</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The index of the partition in the partition map</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>int</p>
  </dd>
  <dt>
    <p><strong>get_start()</strong></p>
  </dt>
  <dd>
    <p>Gets the starting byte of this partition</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The starting byte of this partition</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>Bytes</p>
  </dd>
  <dt>
    <p><strong>map(device_path)</strong></p>
  </dt>
  <dd>
    <p>Maps the partition to a device_path</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>device_path</strong> (<em>str</em>) -- The device patht his partition should be mapped to</p>
  </dd>

</dl>

<h3>GPT partition</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitions.gpt.GPTPartition(size, filesystem, format_command, name, previous)</strong></p>
  </dt>
  <dd>
    <p>Represents a GPT partition</p>
  </dd>

</dl>

<h3>GPT swap partition</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitions.gpt_swap.GPTSwapPartition(size, previous)</strong></p>
  </dt>
  <dd>
    <p>Represents a GPT swap partition</p>
  </dd>

</dl>

<h3>MS-DOS partition</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitions.msdos.MSDOSPartition(size, filesystem, format_command, previous)</strong></p>
  </dt>
  <dd>
    <p>Represents an MS-DOS partition</p>
  </dd>

</dl>

<h3>MS-DOS swap partition</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitions.msdos_swap.MSDOSSwapPartition(size, previous)</strong></p>
  </dt>
  <dd>
    <p>Represents a MS-DOS swap partition</p>
  </dd>

</dl>

<h3>Single</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitions.single.SinglePartition(size, filesystem, format_command)</strong></p>
  </dt>
  <dd>
    <p>Represents a single virtual partition on an unpartitioned volume</p>
  </dd>
  <dt>
    <p><strong>get_start()</strong></p>
  </dt>
  <dd>
    <p>Gets the starting byte of this partition</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The starting byte of this partition</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>Bytes</p>
  </dd>

</dl>

<h3>Unformatted partition</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.fs.partitions.unformatted.UnformattedPartition(size, previous)</strong></p>
  </dt>
  <dd>
    <p>Represents an unformatted partition It cannot be mounted</p>
  </dd>

</dl>

<h3>Exceptions</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>exception bootstrapvz.base.fs.exceptions.PartitionError</strong></p>
  </dt>
  <dd>
    <p>Raised when an error occurs while interacting with the partitions on the volume</p>
  </dd>
  <dt>
    <p><strong>exception bootstrapvz.base.fs.exceptions.VolumeError</strong></p>
  </dt>
  <dd>
    <p>Raised when an error occurs while interacting with the volume</p>
  </dd>

</dl>

<h3>Package handling</h3>

<h3>Package list</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.pkg.packagelist.PackageList(manifest_vars, source_lists)</strong></p>
  </dt>
  <dd>
    <p>Represents a list of packages</p>
  </dd>
  <dt>
    <p><strong>class Local(path)</strong></p>
  </dt>
  <dd>
    <p>A local package</p>
  </dd>
  <dt>
    <p><strong>class PackageList.Remote(name, target)</strong></p>
  </dt>
  <dd>
    <p>A remote package with an optional target</p>
  </dd>
  <dt>
    <p><strong>PackageList.add(name, target=None)</strong></p>
  </dt>
  <dd>
    <p>Adds a package to the install list</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>name</strong> (<em>str</em>) -- The name of the package to install, may contain manifest vars references</p></li><li><p><strong>target</strong> (<em>str</em>) -- The name of the target release for the package, may contain manifest vars references</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>Raises</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>PackageError</strong> -- When a package of the same name but with a different target has already been added.</p></li><li><p><strong>PackageError</strong> -- When the specified target release could not be found.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>PackageList.add_local(package_path)</strong></p>
  </dt>
  <dd>
    <p>Adds a local package to the installation list</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>package_path</strong> (<em>str</em>) -- Path to the local package, may contain manifest vars references</p>
  </dd>

</dl>

<h3>Sources list</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.pkg.sourceslist.Source(line)</strong></p>
  </dt>
  <dd>
    <p>Represents a single source line</p>
  </dd>
  <dt>
    <p><strong>class bootstrapvz.base.pkg.sourceslist.SourceLists(manifest_vars)</strong></p>
  </dt>
  <dd>
    <p>Represents a list of sources lists for apt</p>
  </dd>
  <dt>
    <p><strong>add(name, line)</strong></p>
  </dt>
  <dd>
    <p>Adds a source to the apt sources list</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>name</strong> (<em>str</em>) -- Name of the file in sources.list.d, may contain manifest vars references</p></li><li><p><strong>line</strong> (<em>str</em>) -- The line for the source file, may contain manifest vars references</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>target_exists(target)</strong></p>
  </dt>
  <dd>
    <p>Checks whether the target exists in the sources list</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>target</strong> (<em>str</em>) -- Name of the target to check for, may contain manifest vars references</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>Whether the target exists</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>bool</p>
  </dd>

</dl>

<h3>Preferences list</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.pkg.preferenceslist.Preference(preference)</strong></p>
  </dt>
  <dd>
    <p>Represents a single preference</p>
  </dd>
  <dt>
    <p><strong>class bootstrapvz.base.pkg.preferenceslist.PreferenceLists(manifest_vars)</strong></p>
  </dt>
  <dd>
    <p>Represents a list of preferences lists for apt</p>
  </dd>
  <dt>
    <p><strong>add(name, preferences)</strong></p>
  </dt>
  <dd>
    <p>Adds a preference to the apt preferences list</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>name</strong> (<em>str</em>) -- Name of the file in preferences.list.d, may contain manifest vars references</p></li><li><p><strong>preferences</strong> (<em>object</em>) -- The preferences</p></li>
</ul>
  </dd>

</dl>

<h3>Exceptions</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>exception bootstrapvz.base.pkg.exceptions.PackageError</strong></p>
  </dt>
  <dd>
    <p>Raised when an error occurrs while handling the packageslist</p>
  </dd>
  <dt>
    <p><strong>exception bootstrapvz.base.pkg.exceptions.SourceError</strong></p>
  </dt>
  <dd>
    <p>Raised when an error occurs while handling the sourceslist</p>
  </dd>

</dl>

<h3>Bootstrap information</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.bootstrapinfo.BootstrapInformation(manifest=None, debug=False)</strong></p>
  </dt>
  <dd>
    <p>The BootstrapInformation class holds all information about the bootstrapping process. The nature of the attributes of this class are rather diverse. Tasks may set their own attributes on this class for later retrieval by another task. Information that becomes invalid (e.g. a path to a file that has been deleted) must be removed.</p>
  </dd>
  <dt>
    <p><strong>_BootstrapInformation__create_manifest_vars(manifest, additional_vars={})</strong></p>
  </dt>
  <dd>
    <p>Creates the manifest variables dictionary, based on the manifest contents and additional data.</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>manifest</strong> (<em>Manifest</em>) -- The Manifest</p></li><li><p><strong>additional_vars</strong> (<em>dict</em>) -- Additional values (they will take precedence and overwrite anything else)</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The manifest_vars dictionary</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>dict</p>
  </dd>

</dl>

<h3>Manifest</h3>
<p>The Manifest module contains the manifest that providers and plugins use to determine which tasks should be added to the tasklist, what arguments various invocations should have etc..</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.manifest.Manifest(path)</strong></p>
  </dt>
  <dd>
    <p>This class holds all the information that providers and plugins need to perform the bootstrapping process. All actions that are taken originate from here. The manifest shall not be modified after it has been loaded. Currently, immutability is not enforced and it would require a fair amount of code to enforce it, instead we just rely on tasks behaving properly.</p>
  </dd>
  <dt>
    <p><strong>load()</strong></p>
  </dt>
  <dd>
    <p>Loads the manifest. This function not only reads the manifest but also loads the specified provider and plugins. Once they are loaded, the initialize() function is called on each of them (if it exists). The provider must have an initialize function.</p>
  </dd>
  <dt>
    <p><strong>parse()</strong></p>
  </dt>
  <dd>
    <p>Parses the manifest. Well... "parsing" is a big word. The function really just sets up some convenient attributes so that tasks don&apos;t have to access information with info.manifest.data[&apos;section&apos;] but can do it with info.manifest.section.</p>
  </dd>
  <dt>
    <p><strong>schema_validator(data, schema_path)</strong></p>
  </dt>
  <dd>
    <p>This convenience function is passed around to all the validation functions so that they may run a json-schema validation by giving it the data and a path to the schema.</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>data</strong> (<em>dict</em>) -- Data to validate (normally the manifest data)</p></li><li><p><strong>schema_path</strong> (<em>str</em>) -- Path to the json-schema to use for validation</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>validate()</strong></p>
  </dt>
  <dd>
    <p>Validates the manifest using the base, provider and plugin validation functions. Plugins are not required to have a validate_manifest function</p>
  </dd>
  <dt>
    <p><strong>validation_error(message, json_path=None)</strong></p>
  </dt>
  <dd>
    <p>This function is passed to all validation functions so that they may raise a validation error because a custom validation of the manifest failed.</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>message</strong> (<em>str</em>) -- Message to user about the error</p></li><li><p><strong>json_path</strong> (<em>list</em>) -- A path to the location in the manifest where the error occurred</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>Raises ManifestError</strong></p>
  </dt>
  <dd>
    <p>With absolute certainty</p>
  </dd>

</dl>

<h3>Tasklist</h3>
<p>The tasklist module contains the TaskList class.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.tasklist.TaskList(tasks)</strong></p>
  </dt>
  <dd>
    <p>The tasklist class aggregates all tasks that should be run and orders them according to their dependencies.</p>
  </dd>
  <dt>
    <p><strong>run(info, dry_run=False)</strong></p>
  </dt>
  <dd>
    <p>Converts the taskgraph into a list and runs all tasks in that list</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>info</strong> (<em>dict</em>) -- The bootstrap information object</p></li><li><p><strong>dry_run</strong> (<em>bool</em>) -- Whether to actually run the tasks or simply step through them</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.tasklist.check_ordering(task)</strong></p>
  </dt>
  <dd>
    <p>Checks the ordering of a task in relation to other tasks and their phases.</p><p>This function checks for a subset of what the strongly connected components algorithm does, but can deliver a more precise error message, namely that there is a conflict between what a task has specified as its predecessors or successors and in which phase it is placed.</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>task</strong> (<em>Task</em>) -- The task to check the ordering for</p>
  </dd>
  <dt>
    <p><strong>Raises TaskListError</strong></p>
  </dt>
  <dd>
    <p>If there is a conflict between task precedence and phase precedence</p>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.tasklist.create_list(subset)</strong></p>
  </dt>
  <dd>
    <p>Creates a list of all the tasks that should be run.</p>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.tasklist.get_all_classes(path=None, prefix=&apos;&apos;)</strong></p>
  </dt>
  <dd>
    <p>Given a path to a package, this function retrieves all the classes in it</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>path</strong> (<em>str</em>) -- Path to the package</p></li><li><p><strong>prefix</strong> (<em>str</em>) -- Name of the package followed by a dot</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>A generator that yields classes</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>generator</p>
  </dd>
  <dt>
    <p><strong>Raises Exception</strong></p>
  </dt>
  <dd>
    <p>If a module cannot be inspected.</p>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.tasklist.get_all_tasks()</strong></p>
  </dt>
  <dd>
    <p>Gets a list of all task classes in the package</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>A list of all tasks in the package</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>list</p>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.tasklist.load_tasks(function, manifest, *args)</strong></p>
  </dt>
  <dd>
    <p>Calls <strong>function</strong> on the provider and all plugins that have been loaded by the manifest. Any additional arguments are passed directly to <strong>function</strong>. The function that is called shall accept the taskset as its first argument and the manifest as its second argument.</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>function</strong> (<em>str</em>) -- Name of the function to call</p></li><li><p><strong>manifest</strong> (<em>Manifest</em>) -- The manifest</p></li><li><p><strong>args</strong> (<em>list</em>) -- Additional arguments that should be passed to the function that is called</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.tasklist.strongly_connected_components(graph)</strong></p>
  </dt>
  <dd>
    <p>Find the strongly connected components in a graph using Tarjan&apos;s algorithm.</p><p>Source: <em>http://www.logarithmic.net/pfh-files/blog/01208083168/sort.py</em></p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>graph</strong> (<em>dict</em>) -- mapping of tasks to lists of successor tasks</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>List of tuples that are strongly connected comoponents</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>list</p>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.tasklist.topological_sort(graph)</strong></p>
  </dt>
  <dd>
    <p>Runs a topological sort on a graph.</p><p>Source: <em>http://www.logarithmic.net/pfh-files/blog/01208083168/sort.py</em></p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>graph</strong> (<em>dict</em>) -- mapping of tasks to lists of successor tasks</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>A list of all tasks in the graph sorted according to ther dependencies</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>list</p>
  </dd>

</dl>

<h3>Logging</h3>
<p>This module holds functions and classes responsible for formatting the log output both to a file and to the console.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.log.ConsoleFormatter(fmt=None, datefmt=None)</strong></p>
  </dt>
  <dd>
    <p>Formats log statements for the console</p>
  </dd>
  <dt>
    <p><strong>class bootstrapvz.base.log.FileFormatter(fmt=None, datefmt=None)</strong></p>
  </dt>
  <dd>
    <p>Formats log statements for output to file Currently this is just a stub</p>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.log.get_log_filename(manifest_path)</strong></p>
  </dt>
  <dd>
    <p>Returns the path to a logfile given a manifest The logfile name is constructed from the current timestamp and the basename of the manifest</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>manifest_path</strong> (<em>str</em>) -- The path to the manifest</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The path to the logfile</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>str</p>
  </dd>
  <dt>
    <p><strong>bootstrapvz.base.log.setup_logger(logfile=None, debug=False)</strong></p>
  </dt>
  <dd>
    <p>Sets up the python logger to log to both a file and the console</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <ul>
<li><p><strong>logfile</strong> (<em>str</em>) -- Path to a logfile</p></li><li><p><strong>debug</strong> (<em>bool</em>) -- Whether to log debug output to the console</p></li>
</ul>
  </dd>

</dl>

<h3>Task</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.task.Task</strong></p>
  </dt>
  <dd>
    <p>The task class represents a task that can be run. It is merely a wrapper for the run function and should never be instantiated.</p>
  </dd>
  <dt>
    <p><strong>classmethod run(info)</strong></p>
  </dt>
  <dd>
    <p>The run function, all work is done inside this function</p>
  </dd>
  <dt>
    <p><strong>Parameters</strong></p>
  </dt>
  <dd>
    <p><strong>info</strong> (<em>BootstrapInformation</em>) -- The bootstrap info object.</p>
  </dd>

</dl>

<h3>Phase</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>class bootstrapvz.base.phase.Phase(name, description)</strong></p>
  </dt>
  <dd>
    <p>The Phase class represents a phase a task may be in. It has no function other than to act as an anchor in the task graph. All phases are instantiated in common.phases</p>
  </dd>
  <dt>
    <p><strong>pos()</strong></p>
  </dt>
  <dd>
    <p>Gets the position of the phase</p>
  </dd>
  <dt>
    <p><strong>Returns</strong></p>
  </dt>
  <dd>
    <p>The positional index of the phase in relation to the other phases</p>
  </dd>
  <dt>
    <p><strong>Return type</strong></p>
  </dt>
  <dd>
    <p>int</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMON</h2>
        <div class="sectioncontent">
<p>The common module contains features that are common to multiple providers and plugins. It holds both a large set of shared tasks and also various tools that are used by both the base module and tasks.</p><h3>Volume representations</h3>

<h3>Shared tasks</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PLUGINS</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROVIDERS</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEVELOPMENT GUIDELINES</h2>
        <div class="sectioncontent">
<p>The following guidelines should serve as general advice when developing providers or plugins for bootstrap-vz. Keep in mind that these guidelines are not rules , they are advice on how to better add value to the bootstrap-vz codebase.</p><ul>
<li><p><strong>The manifest should always fully describe the resulting image. The</strong> outcome of a bootstrapping process should never depend on settings specified elsewhere.</p><p>This allows others to easily reproduce any setup other people are running and makes it possible to share manifests. <em>The official debian EC2 images</em> for example can be reproduced using the manifests available in the manifest directory of bootstrap-vz.</p></li><li><p><strong>The bootstrapper should always be able to run fully unattended.</strong></p><p>For end users, this guideline minimizes the risk of errors. Any required input would also be in direct conflict with the previous guideline that the manifest should always fully describe the resulting image.</p><p>Additionally developers may have to run the bootstrap process multiple times though, any prompts in the middle of that process may significantly slow down the development speed.</p></li><li><p><strong>The bootstrapper should only need as much setup as the manifest</strong> requires.</p><p>Having to shuffle specific paths on the host into place (e.g. <strong>/target</strong> has to be created manually) to get the bootstrapper running is going to increase the rate of errors made by users. Aim for minimal setup.</p><p>Exceptions are of course things such as the path to the VirtualBox Guest Additions ISO or tools like <strong>parted</strong> that need to be installed on the host.</p></li><li><p><strong>Roll complexity into which tasks are added to the tasklist.</strong></p><p>If a <strong>run()</strong> function checks whether it should do any work or simply be skipped, consider doing that check in <strong>resolve_tasks()</strong> instead and avoid adding that task alltogether. This allows people looking at the tasklist in the logfile to determine what work has been performed. If a task says it will modify a file but then bails , a developer may get confused when looking at that file after bootstrapping. He could conclude that the file has either been overwritten or that the search & replace does not work correctly.</p></li><li><p><strong>Control flow should be directed from the task graph.</strong></p><p>Avoid creating complicated <strong>run()</strong> functions. If necessary, split up a function into two semantically separate tasks.</p><p>This allows other tasks to interleave with the control-flow and add extended functionality (e.g. because volume creation and mounting are two separate tasks, <em>the prebootstrapped plugin</em> can replace the volume creation task with a task of its own that creates a volume from a snapshot instead, but still reuse the mount task).</p></li><li><p><strong>Task classes should be treated as decorated run() functions, they</strong> should not have any state</p><p>Thats what the BootstrapInformation object is for.</p></li><li><p><strong>Only add stuff to the BootstrapInformation object when really necessary.</strong></p><p>This is mainly to avoid clutter.</p></li><li><p><strong>Use a json-schema to check for allowed settings</strong> The json-schema may be verbose but it keeps the bulk of check work outside the python code, which is a big plus when it comes to readability. This of course only applies bas long as the checks are simple. You can of course fall back to doing the check in python when that solution is considerably less complex.</p></li><li><p><strong>When invoking external programs, use long options whenever possible</strong></p><p>This makes the commands a lot easier to understand, since the option names usually hint at what they do.</p></li><li><p><strong>When invoking external programs, don&apos;t use full paths, rely on \(ga\(ga$PATH\(ga\(ga</strong></p><p>This increases robustness when executable locations change. Example: Use <strong>log_call([&apos;wget&apos;, ...])</strong> instead of <strong>log_call([&apos;/usr/bin/wget&apos;, ...])</strong>.</p></li>
</ul><h3>Coding style</h3>
<p>bootstrap-vz is coded to comply closely with the PEP8 style guidelines. There however a few exceptions:</p><ul>
<li><p>Max line length is 110 chars, not 80.</p></li><li><p>Multiple assignments may be aligned with spaces so that the = match vertically.</p></li><li><p>Ignore <strong>E101</strong>: Indent with tabs and align with spaces</p></li><li><p>Ignore <strong>E221 & E241</strong>: Alignment of assignments</p></li><li><p>Ignore <strong>E501</strong>: The max line length is not 80 characters</p></li><li><p>Ignore <strong>W191</strong>: Indent with tabs not spaces</p><p>The codebase can be checked for any violations quite easily, since those rules are already specified in the <em>tox</em> configuration file.</p>
<pre>
tox -e flake8
</pre>
</li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TASKOVERVIEW</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HOW BOOTSTRAP-VZ WORKS</h2>
        <div class="sectioncontent">
<h3>Tasks</h3>
<p>At its core bootstrap-vz is based on tasks that perform units of work. By keeping those tasks small and with a solid structure built around them a high degree of flexibility can be achieved. To ensure that tasks are executed in the right order, each task is placed in a dependency graph where directed edges dictate precedence. Each task is a simple class that defines its predecessor tasks and successor tasks via attributes. Here is an example:</p>
<pre>
class MapPartitions(Task):
    description = &apos;Mapping volume partitions&apos;
    phase = phases.volume_preparation
    predecessors = [PartitionVolume]
    successors = [filesystem.Format]

    @classmethod
    def run(cls, info):
            info.volume.partition_map.map(info.volume)
</pre>
<p>In this case the attributes define that the task at hand should run after the <strong>PartitionVolume</strong> task — i.e. after volume has been partitioned (<strong>predecessors</strong>) — but before formatting each partition (<strong>successors</strong>). It is also placed in the <strong>volume_preparation</strong> phase. Phases are ordered and group tasks together. All tasks in a phase are run before proceeding with the tasks in the next phase. They are a way of avoiding the need to list 50 different tasks as predecessors and successors.</p><p>The final task list that will be executed is computed by enumerating all tasks in the package, placing them in the graph and <em>sorting them topoligcally</em>. Subsequently the list returned is filtered to contain only the tasks the provider and the plugins added to the taskset.</p>
<h3>System abstractions</h3>
<p>There are several abstractions in bootstrap-vz that make it possible to generalize things like volume creation, partitioning, mounting and package installation. As a rule these abstractions are located in the <strong>base/</strong> folder, where the manifest parsing and task ordering algorithm are placed as well.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMANDLINE SWITCHES</h2>
        <div class="sectioncontent">
<p>As a developer, there are commandline switches available which can make your life a lot easier.</p><ul>
<li><p><strong>--debug</strong>: Enables debug output in the console. This includes output from all commands that are invoked during bootstrapping.</p></li><li><p><strong>--pause-on-error</strong>: Pauses the execution when an exception occurs before rolling back. This allows you to debug by inspecting the volume at the time the error occured.</p></li><li><p><strong>--dry-run</strong>: Prevents the <strong>run()</strong> function from being called on all tasks. This is useful if you want to see whether the task order is correct.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOGFILE</h2>
        <div class="sectioncontent">
<p>Every run creates a new logfile in the <strong>logs/</strong> directory. The filename for each run consists of a timestamp (<strong>%Y%m%d%H%M%S</strong>) and the basename of the manifest used. The log also contains debugging statements regardless of whether the <strong>--debug</strong> switch was used.</p><ul>
<li><p><em>genindex</em></p></li><li><p><em>modindex</em></p></li><li><p><em>search</em></p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Anders Ingemann</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2014, Anders Ingemann</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="boolstuff.3.html"><span aria-hidden="true">&larr;</span> boolstuff.3: Disjunctive normal form boolean expression c++ library</a></li>
   <li class="next"><a href="bounds.hpp.3.html">bounds.hpp.3: Bounds that are useful for binary space partitioning trees. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

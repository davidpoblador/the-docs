<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pgmres: Generalized minimum residual method</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Generalized minimum residual method">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pgmres (4rheolef) manual">
  <meta name="twitter:description" content="Generalized minimum residual method">
  <meta name="twitter:image" content="https://www.carta.tech/images/librheolef-dev-pgmres-4rheolef.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man4rheolef/pgmres.4rheolef.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pgmres (4rheolef) manual" />
  <meta property="og:description" content="Generalized minimum residual method" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/librheolef-dev-pgmres-4rheolef.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pgmres<small> (4rheolef)</small></h1>
        <p class="lead">Generalized minimum residual method</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4rheolef/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4rheolef/pgmres.4rheolef.html">
      <span itemprop="name">pgmres: Generalized minimum residual method</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/librheolef-dev/">
      <span itemprop="name">librheolef-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4rheolef/pgmres.4rheolef.html">
      <span itemprop="name">pgmres: Generalized minimum residual method</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
   template &lt;class Matrix, class Vector, class Preconditioner,
     class SmallMatrix, class SmallVector, class Real, class Size&gt;
   int pgmres (const Matrix &A, Vector &x, const Vector &b, const Preconditioner &M,
     SmallMatrix &H, const SmallVector& dummy,
     Size m, Size &max_iter, Real &tol);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>The simplest call to <strong>pgmres</strong> has the folling form:</p>
<pre>
        double tol = 1e-7;
        size_t max_iter = 100;
        size_t m = 6;
        boost::numeric::ublas::matrix&lt;double&gt; H(m+1,m+1);
        vec&lt;double,sequential&gt; dummy;
        int status = pgmres (a, x, b, ic0(a), H, dummy, m, max_iter, tol);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>pgmres</strong> solves the unsymmetric linear system Ax = b using the generalized minimum residual method.</p><p>The return value indicates convergence within max_iter (input) iterations (0), or no convergence within max_iter iterations (1). Upon successful return, output arguments have the following values:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>x</strong></p>
  </dt>
  <dd>
    <p>approximate solution to Ax = b</p>
  </dd>
  <dt>
    <p><strong>max_iter</strong></p>
  </dt>
  <dd>
    <p>the number of iterations performed before the tolerance was reached</p>
  </dd>
  <dt>
    <p><strong>tol</strong></p>
  </dt>
  <dd>
    <p>the residual after the final iteration In addition, M specifies a preconditioner, H specifies a matrix to hold the coefficients of the upper Hessenberg matrix constructed by the <strong>pgmres</strong> iterations, <strong>m</strong> specifies the number of iterations for each restart.</p>
  </dd>

</dl>
<p><strong>pgmres</strong> requires two matrices as input, A and H. The matrix A, which will typically be a sparse matrix) corresponds to the matrix in the linear system Ax=b. The matrix H, which will be typically a dense matrix, corresponds to the upper Hessenberg matrix H that is constructed during the <strong>pgmres</strong> iterations. Within <strong>pgmres</strong>, H is used in a different way than A, so its class must supply different functionality. That is, A is only accessed though its matrix-vector and transpose-matrix-vector multiplication functions. On the other hand, <strong>pgmres</strong> solves a dense upper triangular linear system of equations on H. Therefore, the class to which H belongs must provide H(i,j) operator for element acess.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTE</h2>
        <div class="sectioncontent">
<p>It is important to remember that we use the convention that indices are 0-based. That is H(0,0) is the first component of the matrix H. Also, the type of the matrix must be compatible with the type of single vector entry. That is, operations such as H(i,j)*x(j) must be able to be carried out.</p><p><strong>pgmres</strong> is an iterative template routine.</p><p><strong>pgmres</strong> follows the algorithm described on p. 20 in <em>Templates for the solution of linear systems: building blocks for iterative methods</em>, 2nd Edition, R. Barrett, M. Berry, T. F. Chan, J. Demmel, J. Donato, J. Dongarra, V. Eijkhout, R. Pozo, C. Romine, H. Van der Vorst, SIAM, 1994, <strong>ftp.netlib.org/templates/templates.ps</strong>.</p><p>The present implementation is inspired from <strong>IML++ 1.2</strong> iterative method library, <strong>http://math.nist.gov/iml++</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTATION</h2>
        <div class="sectioncontent">

<pre>
template &lt;class SmallMatrix, class Vector, class SmallVector, class Size&gt;
void
Update(Vector &x, Size k, SmallMatrix &h, SmallVector &s, Vector v[])
{
  SmallVector y = s;
  // Back solve:
  for (int i = k; i &gt;= 0; i--) {
    y(i) /= h(i,i);
    for (int j = i - 1; j &gt;= 0; j--)
      y(j) -= h(j,i) * y(i);
  }
  for (Size j = 0; j &lt;= k; j++) {
    x += v[j] * y(j);
  }
}
template&lt;class Real&gt;
void GeneratePlaneRotation(Real &dx, Real &dy, Real &cs, Real &sn)
{
  if (dy == <strong>Real</strong>(0)) {
    cs = 1.0;
    sn = 0.0;
  } else if (abs(dy) &gt; abs(dx)) {
    Real temp = dx / dy;
    sn = 1.0 / ::sqrt( 1.0 + temp*temp );
    cs = temp * sn;
  } else {
    Real temp = dy / dx;
    cs = 1.0 / ::sqrt( 1.0 + temp*temp );
    sn = temp * cs;
  }
}
template&lt;class Real&gt;
void ApplyPlaneRotation(Real &dx, Real &dy, Real &cs, Real &sn)
{
  Real temp  =  cs * dx + sn * dy;
  dy = -sn * dx + cs * dy;
  dx = temp;
}
template &lt;class Matrix, class Vector, class Preconditioner,
          class SmallMatrix, class SmallVector, class Real, class Size&gt;
int
pgmres (const Matrix &A, Vector &x, const Vector &b, const Preconditioner &M,
      SmallMatrix &H, const SmallVector&, const Size &m, Size &max_iter, Real &tol)
{
  odiststream* p_derr = &derr;
  std::string label = "pgmres";
  if (p_derr) (*p_derr) &lt;&lt; "[" &lt;&lt; label &lt;&lt; "] #iteration residue" &lt;&lt; std::endl;
  Vector w;
  SmallVector s(m+1), cs(m+1), sn(m+1);
  Size i;
  Size j = 1;
  Size k;
  Real resid;
  Real normb = norm(M.solve(b));
  Vector r = M.solve(b - A * x);
  Real beta = norm(r);
  if (normb == <strong>Real</strong>(0)) {
    normb = 1;
  }
  resid = norm(r) / normb;
  if (resid  &lt;= tol) {
    tol = resid;
    max_iter = 0;
    return 0;
  }
  Vector *v = new Vector[m+1];
  while (j &lt;= max_iter) {
    v[0] = r * (1.0 / beta);    // ??? r / beta
    s = 0.0;
    s(0) = beta;
    for (i = 0; i &lt; m && j &lt;= max_iter; i++, j++) {
      w = M.solve(A * v[i]);
      for (k = 0; k &lt;= i; k++) {
        H(k, i) = dot(w, v[k]);
        w -= H(k, i) * v[k];
      }
      H(i+1, i) = norm(w);
      v[i+1] = w * (1.0 / H(i+1, i)); // ??? w / H(i+1, i)
      for (k = 0; k &lt; i; k++) {
        ApplyPlaneRotation(H(k,i), H(k+1,i), cs(k), sn(k));
      }
      GeneratePlaneRotation(H(i,i), H(i+1,i), cs(i), sn(i));
      ApplyPlaneRotation(H(i,i), H(i+1,i), cs(i), sn(i));
      ApplyPlaneRotation(s(i), s(i+1), cs(i), sn(i));
      resid = abs(s(i+1)) / normb;
      if (p_derr) (*p_derr) &lt;&lt; "[" &lt;&lt; label &lt;&lt; "] " &lt;&lt; j &lt;&lt; " " &lt;&lt; resid &lt;&lt; std::endl;
      if (resid  &lt; tol) {
        Update(x, i, H, s, v);
        tol = resid;
        max_iter = j;
        delete [] v;
        return 0;
      }
    }
    Update(x, m - 1, H, s, v);
    r = M.solve(b - A * x);
    beta = norm(r);
    resid = beta / normb;
    if (p_derr) (*p_derr) &lt;&lt; "[" &lt;&lt; label &lt;&lt; "] " &lt;&lt; j &lt;&lt; " " &lt;&lt; resid &lt;&lt; std::endl;
    if (resid &lt; tol) {
      tol = resid;
      max_iter = j;
      delete [] v;
      return 0;
    }
  }
  tol = resid;
  delete [] v;
  return 1;
}
</pre>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pcg.4rheolef.html"><span aria-hidden="true">&larr;</span> pcg.4rheolef: Conjugate gradient algorithm.</a></li>
   <li class="next"><a href="pminres.4rheolef.html">pminres.4rheolef: Conjugate gradient algorithm. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

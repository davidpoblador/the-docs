<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>m-intf: Interfile 3.3 medical image format (medcon)</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Interfile 3.3 medical image format (medcon)">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="m-intf (4) manual">
  <meta name="twitter:description" content="Interfile 3.3 medical image format (medcon)">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmdc2-dev-m-intf-4.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man4/m-intf.4.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="m-intf (4) manual" />
  <meta property="og:description" content="Interfile 3.3 medical image format (medcon)" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmdc2-dev-m-intf-4.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">m-intf<small> (4)</small></h1>
        <p class="lead">Interfile 3.3 medical image format (medcon)</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4/">
      <span itemprop="name">Special files</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4/m-intf.4.html">
      <span itemprop="name">m-intf: Interfile 3.3 medical image format (medcon)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmdc2-dev/">
      <span itemprop="name">libmdc2-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4/m-intf.4.html">
      <span itemprop="name">m-intf: Interfile 3.3 medical image format (medcon)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The file consists of two parts, the administrative data in ASCII and the binary image data. It is possible to put both in one file, but we prefer to separate the data into two files. The administrative data in a file with extension `.h33' and the binary data in a file with extension `.i33'.</p><p>This is a wonderful feature! Because of the separate header in ASCII you could write your own header for any raw image data you may have. I regularly use InterFile for turning unsupported formats into a supported format. Try to extract the raw image data from the unknown format and add an appropriate header with all information you know about.</p><p>The basic defines for the format:</p>
<pre>
---------------------------------------------------------------------------

#define MDC_INTF_MAXKEYCHARS 256

char keystr[MDC_INTF_MAXKEYCHARS];

/* the  data type */
#define MDC_INTF_STATIC      1
#define MDC_INTF_DYNAMIC     2
#define MDC_INTF_GATED       3
#define MDC_INTF_TOMOGRAPH   4
#define MDC_INTF_CURVE       5
#define MDC_INTF_ROI         6

/* the process status */
#define MDC_INTF_ACQUIRED      1
#define MDC_INTF_RECONSTRUCTED 2

/* gated spect nesting outer level */
#define MDC_INTF_NESTING_SPECT 1
#define MDC_INTF_NESTING_GATED 2

typedef struct MdcInterFile_t {

  int data_type, process_status, pixel_type, gspect_nesting;
  Uint32 width, height, images_per_dimension, time_slots;
  Uint32 data_offset, data_blocks, imagesize, number_images;
  Uint32 energy_windows, frame_groups, time_windows, detector_heads;
  float pixel_xsize, pixel_ysize, slice_thickness, centre_centre_separation;
  float study_duration, image_duration, image_pause, group_pause, ext_rot;
  Int8 patient_rot, patient_orient, slice_orient;
  double version;

} MDC_INTERFILE;

---------------------------------------------------------------------------
</pre>
<p>What does the format support or not support:</p>
<pre>
===========================================================================
Item            Supported                             Not Supported
===========================================================================
Color Map     : grayscale                                  -
File Endian   : little or big                              -
Pixeltypes    : 1-bit, all intergers                       -
                float, double, ASCII
===========================================================================
Scaling factors  : quantify & calibrate factors/image  are NOT supported,
                   unless you define your own key-value pairs
---------------------------------------------------------------------------
Dimensions/Image : different dimensions for each image are supported
---------------------------------------------------------------------------
Pixeltypes/Image : different pixeltypes for each image are supported, but
                   decoders are not required to be able to read.
                   MedCon does support different pixeltypes per image.
===========================================================================
</pre>
<p>Underneath you will find a description of the format.</p><p>1. ADMINISTRATIVE DATA</p>
<pre>
   ===================
</pre>

<dl class='dl-vertical'>
  <dt>
    a)
  </dt>
  <dd>
    <p>The administrative data are only composed of key-value pairs and exist in the form of ASCII text. The administrative data should be terminated with a &lt;Ctrl-Z).</p>
  </dd>
  <dt>
    b)
  </dt>
  <dd>
    <p>All administrative data are to be supplied in the form of key-value pairs in ASCII with delimiters. A `key' is the name of a parameter taking a specific `value', an example being:</p>
  </dd>

</dl>
<p>patient name := Elvis Presley &lt;cr&gt;&lt;lf&gt;</p>
<dl class='dl-vertical'>
  <dt>
    c)
  </dt>
  <dd>
    <p>The maximum permitted number of characters for a key or a value or a comment is 255 characters.</p>
  </dd>
  <dt>
    d)
  </dt>
  <dd>
    <p>Neither keys nor values are to be treated as case sensitive. The characters &lt;space&gt; &lt;tab&gt; &lt;underscore&gt; &lt;!&gt; may all be treated as white space and ignored.</p>
  </dd>
  <dt>
    e)
  </dt>
  <dd>
    <p>All relevant keys should be included in the intermediate file. A null value is permitted which will invoke the default where specified. The required keys are preceded by an exclamation mark.</p>
  </dd>
  <dt>
    f)
  </dt>
  <dd>
    <p>A hole line or key-value pairs may have comments appended to them by preceding the comment with a semicolon &lt;;&gt;.</p>
  </dd>
  <dt>
    g)
  </dt>
  <dd>
    <p>A required key ("name of data file") is included to point to the image data file, even if the binary data is in the same file of the administrative data.</p>
  </dd>
  <dt>
    h)
  </dt>
  <dd>
    <p>The two alternate keys ("data starting block") or ("data offset in bytes") are used to indicate the offset of the binary data in the file as specified by the key ("name of data file"). The ("data starting block")  represents the offset in number of blocks or 2048 bytes. The use of the key ("data offset in bytes") permits the offset to the binary data to be freely specified.</p>
  </dd>

</dl>
<p>2. IMAGE DATA</p>
<pre>
   ==========
</pre>

<dl class='dl-vertical'>
  <dt>
    a)
  </dt>
  <dd>
    <p>The order of the pixel data shall increment by column from left to right, and then by row, from top to bottom.</p>
  </dd>
  <dt>
    b)
  </dt>
  <dd>
    <p>Image data shall be in either bit, signed or unsigned integer format, IEEE floating point format (float or double) or ASCII. When the data pixels are written in ASCII, the text line must not exceed 255 characters.</p>
  </dd>
  <dt>
    c)
  </dt>
  <dd>
    <p>The default value for the key ("imagedata byte order") is BIGENDIAN, but LITTLEENDIAN is allowed. The byte order must be respected for integer and floating point numbers.</p>
  </dd>
  <dt>
    d)
  </dt>
  <dd>
    <p>Bit data will stored in a single byte, representing 8 pixel values and ordered such that the most significant bit corresponds to the leftmost pixel.</p>
  </dd>

</dl>
<p>3. LIST OF KEYS - VERSION 3.3    (Updated for Gated SPECT)</p>
<pre>
   ==========================
</pre>

<pre>
!INTERFILE  := &lt;NULL&gt;
;to indicate that this is an Interfile file

!imaging modality := &lt;ASCII&gt; nucmed
;only nucmed is defined for the purpose of this document

!originating system := &lt;ASCII&gt;
;eg.GAMMA-11, MDS, ADAC, etc.

!version of keys := &lt;Numeric&gt; 3.3
;future versions shall increment

date of keys := &lt;DateFormat&gt; 1996:09:26
;date of version 3.3 in date format

conversion program := &lt;ASCII&gt;
;name of program used

program author := &lt;ASCII&gt;
;your chance of fame and fortune

program version := &lt;Numeric&gt;
;to keep track of conversion programs

program date := &lt;DateFormat&gt;
;date of program

!GENERAL DATA := &lt;NULL&gt;
;required but can be treated as comment

original institution := &lt;ASCII&gt;
;name of hospital etc.

contact person := &lt;ASCII&gt;
;another chance of fame (and fortune?)

data description := &lt;ASCII&gt;
;whatever you want

!data starting block := &lt;Numeric&gt; 0
;the value is the offset in blocks of 2048 bytes in either the
;administrative or the data file depending on the key value for
;name of data file (see below)
|      ;OR
!data offset in bytes:= &lt;Numeric&gt; 0
;as above but the offset may be specified freely in bytes

!name of data file := &lt;ASCII&gt; &lt;NULL&gt;
;&lt;NULL&gt; if no image data exists
;key is a name of the file where the data are present, either when
;in a separate binary data file, or when in a combined
;administrative/binary data file

patient name := &lt;ASCII&gt;
;last name, first name (recommended)

!patient ID := &lt;ASCII&gt;
;as used in your hospital

patient dob := &lt;DateFormat&gt;
;date of birth

patient sex := &lt;ASCIIlist&gt; Unknown M|F|Unknown
;default is Unknown!

!study ID := &lt;ASCII&gt;
;as local conditions dictate

exam type := &lt;ASCII&gt;
;description of procedure as above

data compression := &lt;ASCII&gt; none
;name of algorithm if present- e.g. JPEG, etc.

data encode := &lt;ASCII&gt; none
;name of method of encoding if present- e.g. uuencode etc.

organ := &lt;ASCII&gt; none
;ENLF: for mapping with DICOM tag (0018,0015) BodyPartExamined

isotope := &lt;ASCII&gt; | &lt;ASCII&gt;/&lt;ASCII&gt; none
;ENLF: for mapping with DICOM radionuclide/radiopharmaceutical entries.

dose := &lt;Numeric&gt; 0
;ENLF: for mapping with DICOM tag (0018,1074) RadionuclideTotalDose [MBq]

!GENERAL IMAGE DATA := &lt;NULL&gt;
;again required but treated as comment

!type of data := &lt;ASCIIlist&gt;  Other
   Static|Dynamic|Gated|Tomographic|Curve|ROI|GSPECT|Other
;important - this key is used for many conditionals

!total number of images := &lt;Numeric&gt;
;how many images are there altogether in total in the associated
;data file (for all windows etc.). This overrides any other way of
;calculating the total number of images.

study date := &lt;DateFormat&gt;
;date of the first image included in the data file

study time := &lt;TimeFormat&gt;
;time for the start of first image specified

imagedata byte order := &lt;ASCIIlist&gt; BIGENDIAN
        BIGENDIAN|LITTLEENDIAN
;BIGENDIAN is the default if unspecified

process label := &lt;ASCII&gt; none
;ENLF: for mapping with DICOM tag (0008,103E) SeriesDescription

quantification units := +1.696265e-05
;ENLF: global scale factor for mediman dialect

NUD/rescale slope := +1.696265e-05
;ENLF: global scale factor for NUD systems

NUD/rescale intercept := +0.000000e+00
;ENLF: global scale intercept for NUD systems

number of energy windows := &lt;Numeric&gt; 1
;defaulted to one if unspecified

for ( number of energy windows, energy window)
{
      energy window[&lt;energy window&gt;] := &lt;ASCII&gt;
      ;ASCII text- for example "Tc99m"
      ;this starts as "energy window [1]" and then increments to
      ;energy window[2]:= &lt;ASCII&gt;
      ;and then on to
      ;energy window[3]:= &lt;ASCII&gt;
      ;etc. etc.

      energy window lower level [&lt;energy window&gt;] := &lt;Numeric&gt;
      ;value of lower energy level in keV for the corresponding window
      ;starts off as "energy window lower level [1]"
      ;and continues [2],[3] .. as above

      energy window upper level [&lt;energy window&gt;] := &lt;Numeric&gt;
      ;value of upper energy level in keV for the corresponding window
      ;starts off as "energy window upper level [1]"
      ;and continues [2],[3] .. as above


      flood corrected := &lt;ASCIIlist&gt; Y Y|N
      ;corrected if unspecified

      decay corrected := &lt;ASCIIlist&gt; N Y|N
      ;not corrected if unspecified

      if( type of data = "Static"|"ROI")
      {
      !STATIC STUDY (General) := &lt;NULL&gt;
      ;label to indicate that this is the static definition

      number of images/energy window := &lt;Numeric&gt; 1
      ;number of images in THIS energy window

      for ( number of images/energy window )
      {
            !Static Study (each frame) := &lt;NULL&gt;
            ;included at the beginning of the definition of
            ;each new static frame

            !image number := &lt;Numeric&gt;
            ;starting from 1 [see above]
            ;- must be specified!!
            ;starts from 1 and increments though all
            ;windows to its maximum value which equals the
            ;total number of images in the file!!

            !matrix size [1] :=&lt; Numeric&gt;
            ;matrix size across (number of columns)- previously x
            ;32, 64, 128 etc. but not necessarily powers of 2

            !matrix size [2] := &lt;Numeric&gt;
            ;matrix size down (number of rows)- previously y
            ;32, 64, 128 etc. but not necessarily powers of 2

            !number format := &lt;ASCIIlist&gt; unsigned integer
                signed integer|unsigned integer
                |long float|short float|bit|ASCII
            ;as specified

            !number of bytes per pixel := &lt;Numeric&gt;
            ;e.g. 1|2|4.. [this key ignored for bit data]

            scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
            ;size of pixel across- previously x

            scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
            ;size of pixel down- previously y

            image duration (sec) := &lt;Numeric&gt;
            ;eg. 120.0  i.e. normally a float, for each image

            image start time := &lt;TimeFormat&gt;
            ;time for each image

            label := &lt;ASCII&gt;
            ;eg Anterior

            maximum pixel count := &lt;Numeric&gt;
            ;for scaling purposes, for each image

            total counts := &lt;Numeric&gt;
            ;either an integer or a float, for each image

            }
            ;End of frame loop - Repeat for each subsequent frame
        }
        ;End of static definitions


        if( type of data = "Dynamic")
        {
            !DYNAMIC STUDY (general) := &lt;NULL&gt;
            ;label to indicate that this is a dynamic study

            !number of frame groups := &lt;Numeric&gt; 1
            ;defaults to 1

            for( number of frame groups, frame group number)
            {
                  !Dynamic Study (each frame group) := &lt;NULL&gt;
                  ;Repeated for each group of frames as

                  ;indication of  the start of the
                  ;definition of the new group

                  !frame group number := &lt;Numeric&gt;
                  ;numbering starts from 1 (must be specified)


                  !matrix size [1] := &lt;Numeric&gt;
                  ;matrix size across (number of columns)
                  ;-previously matrix size x
                  ;32, 64, 128 etc. but not necessarily powers of 2

                  !matrix size [2] := &lt;Numeric&gt;
                  ;matrix size down (number of rows)- previously y
                  ;32, 64, 128 etc. but not necessarily powers of 2

                  !number format := &lt;ASCIIlist&gt; unsigned integer
                     signed integer|unsigned integer|
                     long float|short float|bit|ASCII
                  ;as specified

                  !number of bytes per pixel := &lt;Numeric&gt;
                  ;e.g. 1|2|4.. [this key ignored for bit data]

                  scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
                  ;size of pixel across- previously x

                  scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
                  ;size of pixel down- previously y

                  !number of images this frame group := &lt;Numeric&gt;
                  ;for each frame group
                  ;(for each energy window)

                  !image duration (sec) := &lt;Numeric&gt;
                  ;eg 0.2, for each frame group
                  ;(for each energy window)

                  pause between images (sec) := &lt;Numeric&gt; 0.0
                  ;eg 0.0, default is 0.0

                  pause between frame groups (sec) := &lt;Numeric&gt; 0.0
                  ;eg 5.0 default 0.0, time between last
                  ;frame group (or start of study) and this frame group

                  !maximum pixel count in group := &lt;Numeric&gt;
                  ;eg 1234 (for scaling purposes)
                  ;maximum pixel for all frames in this
                  ;group and this window!!

            }
            ;Repeat for each subsequent frame group
        }

        ; End of dynamic definitions


        if( type of data = "Gated")
        {
        !GATED STUDY (general) := &lt;NULL&gt;
        ;again a flag to indicate a gated study

        !matrix size [1] := &lt;Numeric&gt;
        ;matrix size across (number of columns)- previously x
        ;32, 64, 128 etc. but not necessarily powers of 2

        !matrix size [2] := &lt;Numeric&gt;
        ;matrix size down (number of rows)- previously y
        ;32, 64, 128 etc. but not necessarily powers of 2

        !number format := &lt;ASCIIlist&gt; unsigned integer
           signed integer|unsigned integer|
           long float|short float|bit|ASCII
        ;as specified

        !number of bytes per pixel := &lt;Numeric&gt;
        ;e.g. 1|2|4|..&gt; [this key ignored for bit data]

        scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
        ;size of pixel across- previously x

        scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
        ;size of pixel down- previously y

        study duration (elapsed) sec := &lt;Numeric&gt;
        ;eg 300, total elapsed time for whole study

        number of cardiac cycles (observed) := &lt;Numeric&gt;
        ;total number of cycles if known, for this
        ;energy window

        number of time windows := &lt;Numeric&gt; 1
        ;defaults to 1 if unspecified- number of different
        ;sets of time intervals

        for ( number of time windows, time window number)
        {
            !Gated Study (each time window) := &lt;NULL&gt;

            !time window number := &lt;Numeric&gt;
            ;starting from 1

            !number of images in time window := &lt;Numeric&gt;
            ;eg 24

            !image duration (sec) := &lt;Numeric&gt;
            ;eg 0.04  for each frame in THIS time window

            framing method := &lt;ASCIIlist&gt; Forward
                    Forward|Backward|Mixed|Other
            ;default is forward

            time window lower limit (sec) := &lt;Numeric&gt;
            ;float normally expected, for THIS time window

            time window upper limit (sec) := &lt;Numeric&gt;
            ;float normally expected

            % R-R cycles acquired this window := &lt;Numeric&gt;
            ;if known

            number of cardiac cycles (acquired) := &lt;Numeric&gt;
            ;eg 356 , if known

            study duration (acquired) sec := &lt;Numeric&gt;
            ;total  acquisition time duration for
            ;this window only (if it can be computed!!) as
            ;opposed to total acquisition time (when different)

            !maximum pixel count := &lt;Numeric&gt;
            ;for scaling purposes for all images in this
            ;time window (and energy window) only

            R-R histogram := &lt;ASCIIlist&gt; N Y|N
            ;flag to indicate that one exists!!

            }
            ;Repeat for each subsequent time window.

        }
        ;end of gated definitions


        if( type of data = "Tomographic")
        {

        !SPECT STUDY (general) := &lt;NULL&gt;
        ;flag to indicate tomographic data with no effect as such

        number of detector heads := &lt;Numeric&gt; 1
        ;default=1 if unspecified

        for ( number of detector heads )
        {

            !number of images/energy window := &lt;Numeric&gt;
            ;total number of images (for all heads) for
            ;THIS energy window!!

            !process status := Reconstructed Acquired|Reconstructed
            ;used below in conditional- MUST be defined

            !matrix size [1] := &lt;Numeric&gt;
            ;matrix size across (number of columns)- previously x
            ;32, 64, 128 etc. but not necessarily powers of 2

            !matrix size [2] := &lt;Numeric&gt;
            ;matrix size down (number of rows)- previously y
            ;32, 64, 128 etc. but not necessarily powers of 2

            !number format := &lt;ASCIIlist&gt; unsigned integer
               signed integer|unsigned integer|
               long float|short float|bit|ASCII
            ;as specified

            !number of bytes per pixel := &lt;Numeric&gt;
            ;e.g. 1|2|4|.. [this key ignored for bit data]

            scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
            ;size of pixel across- previously x

            scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
            ;size of pixel down- previously y

            !number of projections := &lt;Numeric&gt;
            ;for example- 64
            ;note this is the actual number of images per
            ;head per energy window if
            ;the data are acquired, but NOT if the data are
            ;reconstructed where the number of images is
            ;specified separately as number of slices

            !extent of rotation := &lt;Numeric&gt;
            ;e.g 180, 360

            !time per projection (sec) := &lt;Numeric&gt;
            ;important for Acquired data

            study duration (sec) := &lt;Numeric&gt;
            ;eg 1280.0, for acquired data should be equal
            ;to the product of number of projections and
            ;time per projection, but could be different!!

            !maximum pixel count := &lt;Numeric&gt;
            ;for scaling- in THIS image series( this head
            ;and this energy window)

            patient orientation := &lt;ASCIIlist&gt; head_in
                 head_in|feet_in|other

            patient rotation :=  &lt;ASCIIlist&gt; supine
                 prone|supine|other

            if( process status = "acquired")
            {
               !SPECT STUDY (acquired data):= &lt;NULL&gt;

               !direction of rotation := &lt;ASCIIlist&gt; CW CW|CCW
               ;CW = clockwise, CCW = counter clockwise

               start angle := &lt;Numeric&gt;
               ;0 is top-dead-centre, in degrees
               ;in orientation as specified above

               first projection angle in data set := &lt;Numeric&gt;
               ;in degrees expressed with respect to
               ;anterior-  angles in direction as
               ;specified CW or CCW

               acquisition mode := &lt;ASCIIlist&gt; stepped
               stepped|continuous

               Centre_of_rotation :=  &lt;ASCIIlist&gt; Corrected
               Corrected|Single_value|For_every_angle
               ;default is "Corrected"
               ;"Corrected" corresponds to a null centre of rotation
               ;correction, as previous required by Interfile, that
               ;is, no centre of rotation information is to be
               ;passed. The key "Single value" indicates the
               ;conventional definition of the centre of rotation
               ;offset to be a single value specified for all angles,
               ;specified for each head given a multiple head
               ;acquisition.
               ;The key "For_every_angle" indicates that the centre
               ;of rotation offset will be  specified for each head
               ;and every angle. This is not currently implemented in
               ;this Interfile definition, but will be introduced in
               ;V4.
               ;The mathematical centre of rotation is assumed to be
               ;in the exact middle of the projection for example at
               ;x= 32.5 y=32.5 for a 64x64 image where the count
               ;starts from 1. Note that the choice of coordinates
               ;does not matter, the only constraint being the
               ;assumption that all projections have a length which
               ;is an even number of pixels. The centre of rotation
               ;is specified as the offset from that position to the
               ;perpendicular dropped from a point on the axis of
               ;rotation onto the head.

           if( Centre_of_rotation = "Single_value" )
           {

               !X_offset := &lt;Numeric&gt;
               ;x offset for all angles in mm.
               ;x_offset is the x offset between the perpendicular
               ;dropped from the centre of rotation and the dead
               ;centre of the matrix,
               ;The positive direction for the offset is considered
               ;to be that of the increasing projection index, e.g.
               ;for a projection with pixels of size 6mm, which
               ;should be centred at 32.5, an offset of +6mm
               ;indicates that the centre of rotation is at 33.5
               ;Note that since offset is specified in mm, the pixel
               ;size must be known.


               Y_offset := &lt;Numeric&gt;
               ;y offset for all angles in mm
               ;y_offset is the y offset between that perpendicular
               ;dropped from the centre of rotation from that point
               ;on the axis of rotation where the y_offset is
               ;considered to be zero, and the centre of the camera's
               ;field of view. Thus y_offset is the RELATIVE shift of
               ;the y-axis with respect to some arbitrary position,
               ;normally that from the centre of the filed of view of
               ;the first at the top dead centre position. Thus for
               ;a single head, this value would normally be expected
               ;to be equal to zero.

               Radius := &lt;Numeric&gt;
               ;radial distance to centre of rotation in mm,
               ;for this head.


               }
               ;end of centre of rotation specification

               orbit := &lt;ASCIIlist&gt; Circular Circular|non-circular

               preprocessed := &lt;ASCII&gt;
               ;preprocessing method

            }
            ; end of process status acquired

            if( process status = "reconstructed")
            {
               !SPECT STUDY (reconstructed data) := &lt;NULL&gt;

               method of reconstruction := &lt;ASCII&gt;

               !number of slices := &lt;Numeric&gt;
               ;i.e. number of images in this set for this
               ;head and this energy window

               number of reference frame := &lt;Numeric&gt; 0
               ;if unspecified the frame number
               ;originally used for defining slice positions
               ;0=default [Note- not a very useful key]

               slice orientation := &lt;ASCIIlist&gt; Transverse
                   Transverse|Coronal|Sagittal|Other
               ;default is transverse if unspecified

               slice thickness (pixels) := &lt;Numeric&gt; 1
               ;if unspecified 1=default

               centre-centre slice separation (pixels):=&lt;Numeric&gt; 1
               ;e.g.1,2,3,4...  as distinct from slice thickness
               ;the word centre can also be spelt as center

               filter name :=  &lt;ASCII&gt;
               ;e.g. Hann, Hamming, Butterworth

               filter parameters := &lt;ASCII&gt;
               ;Nyquist freq etc.

               z-axis filter := &lt;ASCII&gt;
               ;method [1,2,1] etc.

               attenuation correction coefficient/cm := &lt;Numeric&gt; 0.0
               ;default 0 means not done if unspecified

               method of attenuation correction :=  &lt;ASCII&gt;  none

               scatter corrected := &lt;ASCIIlist&gt; N Y|N

               method of scatter correction := &lt;ASCII&gt; none

               oblique reconstruction := &lt;ASCIIlist&gt; N Y|N

               oblique orientation := &lt;ASCII&gt;
               ;free text [Note ACR-NEMA convention preferred]
            }
            ;end of reconstructed tomo
       }
      ;End of tomo


*      if( type of data = "GSPECT")
       {
*      !GATED SPECT STUDY (general) := &lt;NULL&gt;
       ;again a flag to indicate a gated SPECT study
       ;MIXTURE OF GATED & TOMO

       !matrix size [1] := &lt;Numeric&gt;
       ;matrix size across (number of columns)- previously x
       ;32, 64, 128 etc. but not necessarily powers of 2

       !matrix size [2] := &lt;Numeric&gt;
       ;matrix size down (number of rows)- previously y
       ;32, 64, 128 etc. but not necessarily powers of 2

       !number format := &lt;ASCIIlist&gt; unsigned integer
        signed integer|unsigned integer|
        long float|short float|bit|ASCII
       ;as specified

       !number of bytes per pixel := &lt;Numeric&gt;
       ;e.g. 1|2|4|..&gt; [this key ignored for bit data]

       !Gated SPECT nesting outer level := SPECT|Gated  Gated
       ; key to indictae order of images, if SPECT is outer level
       ; order is, for every angle give each gated image, if
       ; gated is outer level, then order is, for every gated
       ; time value, vie set of tomographic images

       scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
       ;size of pixel across- previously x

       scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
       ;size of pixel down- previously y

       study duration (elapsed) sec := &lt;Numeric&gt;
       ;eg 300, total elapsed time for whole study

       number of cardiac cycles (observed) := &lt;Numeric&gt;
       ;total number of cycles if known, for this
       ;energy window

       number of time windows := &lt;Numeric&gt; 1
       ;defaults to 1 if unspecified- number of different
       ;sets of time intervals

       for ( number of time windows, time window number)
       {
            !Gated Study (each time window) := &lt;NULL&gt;

            !time window number := &lt;Numeric&gt;
            ;starting from 1

*           !number of images in time window := &lt;Numeric&gt;
            ;eg 24 NOTE that here in gated SPECT is means images/angle

            !image duration (sec) := &lt;Numeric&gt;
            ;eg 0.04  for each frame in THIS time window

            framing method := &lt;ASCIIlist&gt; Forward
                    Forward|Backward|Mixed|Other
            ;default is forward

            time window lower limit (sec) := &lt;Numeric&gt;
            ;float normally expected, for THIS time window

            time window upper limit (sec) := &lt;Numeric&gt;
            ;float normally expected

            % R-R cycles acquired this window := &lt;Numeric&gt;
            ;if known

            number of cardiac cycles (acquired) := &lt;Numeric&gt;
            ;eg 356 , if known

            study duration (acquired) sec := &lt;Numeric&gt;
            ;total  acquisition time duration for
            ;this window only (if it can be computed!!) as
            ;opposed to total acquisition time (when different)

            !maximum pixel count := &lt;Numeric&gt;
            ;for scaling purposes for all images in this
            ;time window (and energy window) only

            R-R histogram := &lt;ASCIIlist&gt; N Y|N
            ;flag to indicate that one exists!!

        }
        ;Repeat for each subsequent time window.


	;start of tomographic keys

        number of detector heads := &lt;Numeric&gt; 1
        ;default=1 if unspecified

        for ( number of detector heads )
        {

            !number of images/energy window := &lt;Numeric&gt;
            ;total number of images (for all heads) for
            ;THIS energy window!!

            !process status := Reconstructed Acquired|Reconstructed
            ;used below in conditional- MUST be defined

            !number of projections := &lt;Numeric&gt;
            ;for example- 64
            ;note this is the actual number of images per
            ;head per energy window if
            ;the data are acquired, but NOT if the data are
            ;reconstructed where the number of images is
            ;specified separately as number of slices

            !extent of rotation := &lt;Numeric&gt;
            ;e.g 180, 360

            !time per projection (sec) := &lt;Numeric&gt;
            ;important for Acquired data
            patient orientation := &lt;ASCIIlist&gt; head_in
                   head_in|feet_in|other

            patient rotation :=  &lt;ASCIIlist&gt; supine
                   prone|supine|other

            if( process status = "acquired")
            {
               !SPECT STUDY (acquired data):= &lt;NULL&gt;

               !direction of rotation := &lt;ASCIIlist&gt; CW CW|CCW
               ;CW = clockwise, CCW = counter clockwise

               start angle := &lt;Numeric&gt;
               ;0 is top-dead-centre, in degrees
               ;in orientation as specified above

               first projection angle in data set := &lt;Numeric&gt;
               ;in degrees expressed with respect to
               ;anterior-  angles in direction as
               ;specified CW or CCW

               acquisition mode := &lt;ASCIIlist&gt; stepped
                    stepped|continuous

              Centre_of_rotation :=  &lt;ASCIIlist&gt; Corrected
                   Corrected|Single_value|For_every_angle
              ;default is "Corrected"
              ;"Corrected" corresponds to a null centre of rotation
              ;correction, as previous required by Interfile, that
              ;is, no centre of rotation information is to be
              ;passed. The key "Single value" indicates the
              ;conventional definition of the centre of rotation
              ;offset to be a single value specified for all angles,
              ;specified for each head given a multiple head
              ;acquisition.
              ;The key "For_every_angle" indicates that the centre
              ;of rotation offset will be  specified for each head
              ;and every angle. This is not currently implemented in
              ;this Interfile definition, but will be introduced in
              ;V4.
              ;The mathematical centre of rotation is assumed to be
              ;in the exact middle of the projection for example at
              ;x= 32.5 y=32.5 for a 64x64 image where the count
              ;starts from 1. Note that the choice of coordinates
              ;does not matter, the only constraint being the
              ;assumption that all projections have a length which
              ;is an even number of pixels. The centre of rotation
              ;is specified as the offset from that position to the
              ;perpendicular dropped from a point on the axis of
              ;rotation onto the head.

              if( Centre_of_rotation = "Single_value" )
              {

               !X_offset := &lt;Numeric&gt;
               ;x offset for all angles in mm.
              ;x_offset is the x offset between the perpendicular
              ;dropped from the centre of rotation and the dead
              ;centre of the matrix,
              ;The positive direction for the offset is considered
              ;to be that of the increasing projection index, e.g.
              ;for a projection with pixels of size 6mm, which
              ;should be centred at 32.5, an offset of +6mm
              ;indicates that the centre of rotation is at 33.5
              ;Note that since offset is specified in mm, the pixel
              ;size must be known.


               Y_offset := &lt;Numeric&gt;
               ;y offset for all angles in mm
              ;y_offset is the y offset between that perpendicular
              ;dropped from the centre of rotation from that point
              ;on the axis of rotation where the y_offset is
              ;considered to be zero, and the centre of the camera's
              ;field of view. Thus y_offset is the RELATIVE shift of
              ;the y-axis with respect to some arbitrary position,
              ;normally that from the centre of the filed of view of
              ;the first at the top dead centre position. Thus for
              ;a single head, this value would normally be expected
              ;to be equal to zero.

               Radius := &lt;Numeric&gt;
               ;radial distance to centre of rotation in mm,
              ;for this head.


               }
              ;end of centre of rotation specification

               orbit := &lt;ASCIIlist&gt; Circular Circular|non-circular

               preprocessed := &lt;ASCII&gt;
               ;preprocessing method
            }
            ; end of process status acquired

            if( process status = "reconstructed")
            {
               !SPECT STUDY (reconstructed data) := &lt;NULL&gt;

               method of reconstruction := &lt;ASCII&gt;

               !number of slices := &lt;Numeric&gt;
               ;i.e. number of images in this set for this
               ;head and this energy window

               number of reference frame := &lt;Numeric&gt; 0
               ;if unspecified the frame number
               ;originally used for defining slice positions
               ;0=default [Note- not a very useful key]

               slice orientation := &lt;ASCIIlist&gt; Transverse
                   Transverse|Coronal|Sagittal|Other
               ;default is transverse if unspecified

               slice thickness (pixels) := &lt;Numeric&gt; 1
               ;if unspecified 1=default

               centre-centre slice separation (pixels):=&lt;Numeric&gt; 1
               ;e.g.1,2,3,4...  as distinct from slice thickness
               ;the word centre can also be spelt as center

               filter name :=  &lt;ASCII&gt;
               ;e.g. Hann, Hamming, Butterworth

               filter parameters := &lt;ASCII&gt;
               ;Nyquist freq etc.

               z-axis filter := &lt;ASCII&gt;
               ;method [1,2,1] etc.

               attenuation correction coefficient/cm := &lt;Numeric&gt; 0.0
               ;default 0 means not done if unspecified

               method of attenuation correction :=  &lt;ASCII&gt;  none

               scatter corrected := &lt;ASCIIlist&gt; N Y|N

               method of scatter correction := &lt;ASCII&gt; none

               oblique reconstruction := &lt;ASCIIlist&gt; N Y|N

               oblique orientation := &lt;ASCII&gt;
               ;free text [Note ACR-NEMA convention preferred]
            }
            ;end of reconstructed tomo
       }
      ;End of GATED SPECT

}
;end of loop for energy windows

if( type of data = "Curve")
      {
       !CURVE DATA := &lt;NULL&gt;
       ;label to indicate that this is the curve definition
       ;curves should always be kept in separate data files
       ;and not together with the administrative data

       Curve_dimensions := &lt;Numeric&gt; 2
       ;how many dimensions- ONLY 2 is permitted in V3.3.
       ;Even if a single vector of values is required
       ;both matrix size[1] and [2] must be defined
       ;although one of them should take the value 1.
       ;A set of x,y values is 2 dimensional with normally
       ;matrix size[1] or matrix size[2] equal to 2.
       ;and the other matrix size specifying
       ;the number of PAIRS of values present (see Fig 1).
       ;Matrix sizes greater than 2 for BOTH dimensions are not
       ;recommended.

       !matrix size[1] := &lt;Numeric&gt;
       ;matrix size across (number of columns)

       !matrix size[2] := &lt;Numeric&gt;
       ;matrix size down (number of rows)

       !number format := &lt;ASCIIlist&gt; unsigned integer
           signed integer|unsigned integer|
           long float|short float|bit|ASCII

       !number of bytes per pixel := &lt;Numeric&gt;
       ;e.g. 1|2|4|.. [this key ignored for bit data]

       Type_of_curve :=  &lt;ASCII&gt;
       ;what kind of curve is it, for example time activity curve
       ;ROI indicates that this is a list
       ;of vectors corresponding to an ROI.

       for( Curve_dimensions, dimension)
       {

          ;When matrix size[1] or matrix size[2] equals 2 (the normal
          ;case) such that the data comprise pairs of values,
          ;then Label[1],  Units[1] etc. refers to the set of first
          ;values for each pair, and Label[2] etc. refers the set of
          ;second values for each pair.

          Label[&lt;dimension&gt;] :=  &lt;ASCII&gt;
          ;a text label for the corresponding axis  e.g. "counts"

          Units[&lt;dimension&gt;] := &lt;ASCII&gt;
          ;units of measurement for the corresponding axis
          ;e.g. "units[1]:=counts/sec"

          Min[&lt;dimension&gt;] := &lt;Numeric&gt;
          ;Minimum of set of values as indicated in units as defined,
          ;optional

          Max[&lt;dimension&gt;] := &lt;Numeric&gt;
          ;Maximum value as above, optional

      }
     ;End of loop for curve dimensions

}
!END OF INTERFILE := &lt;NULL&gt;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<pre>
/usr/local/xmedcon/source/m-intf.h      The header file.
/usr/local/xmedcon/source/m-intf.c      The source file.

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO m-intf&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/medcon.1.html"><strong>medcon</strong>(1)</a>, <a href="../man1/xmedcon.1.html"><strong>xmedcon</strong>(1)</a>, <a href="../man1/xmedcon-config.1.html"><strong>xmedcon-config</strong>(1)</a></p><p><a href="../man4/m-acr.4.html"><strong>m-acr</strong>(4)</a>, <a href="../man4/m-anlz.4.html"><strong>m-anlz</strong>(4)</a>, <strong>m-gif</strong>(5), <a href="../man4/m-inw.4.html"><strong>m-inw</strong>(4)</a>, <a href="../man4/m-ecat.4.html"><strong>m-ecat</strong>(4)</a></p><p><a href="../man3/medcon.3.html"><strong>medcon</strong>(3)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><em>(X)MedCon</em> project was originally written by Erik Nolf (eNlf) for the former PET-Centre at Ghent University (Belgium).</p><table class="table table-striped">
<tr>
<th>e-mail:</th>
<th>enlf-at-users.sourceforge.net</th>
<th>www:</th>
<th>http://xmedcon.sourceforge.net</th></tr>
</table>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="m-gif.4.html"><span aria-hidden="true">&larr;</span> m-gif.4: Gif87a and annimated gif89a format (medcon)</a></li>
   <li class="next"><a href="m-inw.4.html">m-inw.4: Rug inw1.0 medical image format (medcon) <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

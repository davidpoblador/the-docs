<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cpuset: Confine tasks to processor and memory node subsets</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Confine tasks to processor and memory node subsets">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="cpuset (4) manual">
  <meta name="twitter:description" content="Confine tasks to processor and memory node subsets">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcpuset1-cpuset-4.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man4/cpuset.4.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="cpuset (4) manual" />
  <meta property="og:description" content="Confine tasks to processor and memory node subsets" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcpuset1-cpuset-4.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">cpuset<small> (4)</small></h1>
        <p class="lead">Confine tasks to processor and memory node subsets</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4/">
      <span itemprop="name">Special files</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4/cpuset.4.html">
      <span itemprop="name">cpuset: Confine tasks to processor and memory node subsets</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcpuset1/">
      <span itemprop="name">libcpuset1</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man4/cpuset.4.html">
      <span itemprop="name">cpuset: Confine tasks to processor and memory node subsets</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The cpuset file system is a pseudo-filesystem interface to the kernel cpuset mechanism for controlling the processor and memory placement of tasks.  It is commonly mounted at <em>/dev/cpuset</em>.</p><p>A cpuset defines a list of CPUs and memory nodes. Cpusets are represented as directories in a hierarchical virtual file system, where the top directory in the hierarchy (<em>/dev/cpuset</em>) represents the entire system (all online CPUs and memory nodes) and any cpuset that is the child (descendant) of another parent cpuset contains a subset of that parents CPUs and memory nodes. The directories and files representing cpusets have normal file system permissions.</p><p>Every task in the system belongs to exactly one cpuset. A task is confined to only run on the CPUs in the cpuset it belongs to, and to allocate memory only on the memory nodes in that cpuset.  When a task forks, the child task is placed in the same cpuset as its parent. With sufficient privilege, a task may be moved from one cpuset to another and the allowed CPUs and memory nodes of an existing cpuset may be changed.</p><p>When the system begins booting, only the top cpuset is defined and all tasks are in that cpuset.  During the boot process  or later during normal system operation, other cpusets may be created, as sub-directories of the top cpuset under the control of the system administrator and tasks may be placed in these other cpusets.</p><p>Cpusets are integrated with the <a href="../man2/sched_setaffinity.2.html"><strong>sched_setaffinity</strong>(2)</a> scheduling affinity mechanism and the <a href="../man2/mbind.2.html"><strong>mbind</strong>(2)</a> and <strong>set_mempolicy</strong>(2) memory placement mechanisms in the kernel. Neither of these mechanisms let a task make use of a CPU or memory node that is not allowed by cpusets. If changes to a tasks cpuset placement conflict with these other mechanisms, then cpuset placement is enforced even if it means overriding these other mechanisms.</p><p>Typically, a cpuset is used to manage the CPU and memory node confinement for the entire set of tasks in a job, and these other mechanisms are used to manage the placement of individual tasks or memory regions within a job.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>Each directory below <em>/dev/cpuset</em> represents a cpuset and contains several files describing the state of that cpuset.</p><p>New cpusets are created using the <strong>mkdir</strong> system call or shell command.  The properties of a cpuset, such as its flags, allowed CPUs and memory nodes, and attached tasks, are queried and modified by reading or writing to the appropriate file in that cpusets directory, as listed below.</p><p>The files in each cpuset directory are automatically created when the cpuset is created, as a result of the <strong>mkdir</strong> invocation. It is not allowed to add or remove files from a cpuset directory.</p><p>The files in each cpuset directory are small text files that may be read and written using traditional shell utilities such as <a href="../man1/cat.1.html"><strong>cat</strong>(1)</a>, and <a href="../man1/echo.1.html"><strong>echo</strong>(1)</a>, or using ordinary file access routines from programmatic languages, such as <a href="../man2/open.2.html"><strong>open</strong>(2)</a>, <a href="../man2/read.2.html"><strong>read</strong>(2)</a>, <a href="../man2/write.2.html"><strong>write</strong>(2)</a> and <a href="../man2/close.2.html"><strong>close</strong>(2)</a> from the 'C' library. These files represent internal kernel state and do not have any persistent image on disk.  Each of these per-cpuset files is listed and described below.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>tasks</strong></p>
  </dt>
  <dd>
    <p>List of the process IDs (PIDs) of the tasks in that cpuset. The list is formatted as a series of <small>ASCII</small> decimal numbers, each followed by a newline. A task may be added to a cpuset (removing it from the cpuset previously containing it) by writing its PID to that cpusets <strong>tasks</strong> file (with or without a trailing newline.)</p><p>Beware that only one PID may be written to the <strong>tasks</strong> file at a time.  If a string is written that contains more than one PID, only the first one will be considered.</p>
  </dd>
  <dt>
    <p><strong>notify_on_release</strong></p>
  </dt>
  <dd>
    <p>Flag (0 or 1).  If set (1), that cpuset will receive special handling whenever its last using task and last child cpuset goes away.  See the <strong>Notify On Release</strong> section, below.</p>
  </dd>
  <dt>
    <p><strong>cpus</strong></p>
  </dt>
  <dd>
    <p>List of CPUs on which tasks in that cpuset are allowed to execute. See <strong>List Format</strong> below for a description of the format of <strong>cpus</strong>.</p><p>The CPUs allowed to a cpuset may be changed by writing a new list to its <strong>cpus</strong> file.  Note however, such a change does not take affect until the PIDs of the tasks in the cpuset are rewritten to the cpusets <strong>tasks</strong> file.  See the <strong>WARNINGS</strong> section, below.</p>
  </dd>
  <dt>
    <p><strong>cpu_exclusive</strong></p>
  </dt>
  <dd>
    <p>Flag (0 or 1).  If set (1), the cpuset has exclusive use of its CPUs (no sibling or cousin cpuset may overlap CPUs). By default this is off (0).  Newly created cpusets also initially default this to off (0).</p>
  </dd>
  <dt>
    <p><strong>mems</strong></p>
  </dt>
  <dd>
    <p>List of memory nodes on which tasks in that cpuset are allowed to allocate memory. See <strong>List Format</strong> below for a description of the format of <strong>mems</strong>.</p>
  </dd>
  <dt>
    <p><strong>mem_exclusive</strong></p>
  </dt>
  <dd>
    <p>Flag (0 or 1).  If set (1), the cpuset has exclusive use of its memory nodes (no sibling or cousin may overlap). By default this is off (0).  Newly created cpusets also initially default this to off (0).</p>
  </dd>
  <dt>
    <p><strong>memory_migrate</strong></p>
  </dt>
  <dd>
    <p>Flag (0 or 1).  If set (1), then memory migration is enabled. See the <strong>Memory Migration</strong> section, below.</p>
  </dd>
  <dt>
    <p><strong>memory_pressure</strong></p>
  </dt>
  <dd>
    <p>A measure of how much memory pressure the tasks in this cpuset are causing.  See the <strong>Memory Pressure</strong> section, below. Unless <strong>memory_pressure_enabled</strong> is enabled, always has value zero (0).  This file is read-only. See the <strong>WARNINGS</strong> section, below.</p>
  </dd>
  <dt>
    <p><strong>memory_pressure_enabled</strong></p>
  </dt>
  <dd>
    <p>Flag (0 or 1).  This file is only present in the root cpuset, normally <em>/dev/cpuset</em>.  If set (1), the <strong>memory_pressure</strong> calculations are enabled for all cpusets in the system.  See the <strong>Memory Pressure</strong> section, below.</p>
  </dd>
  <dt>
    <p><strong>memory_spread_page</strong></p>
  </dt>
  <dd>
    <p>Flag (0 or 1).  If set (1), the kernel page cache (file system buffers) are uniformly spread across the cpuset. See the <strong>Memory Spread</strong> section, below.</p>
  </dd>
  <dt>
    <p><strong>memory_spread_slab</strong></p>
  </dt>
  <dd>
    <p>Flag (0 or 1).  If set (1), the kernel slab caches for file I/O (directory and inode structures) are uniformly spread across the cpuset. See the <strong>Memory Spread</strong> section, below.</p>
  </dd>

</dl>
<p>In addition to the above special files in each directory below <em>/dev/cpuset</em>, each task under <em>/proc</em> has an added file named <strong>cpuset</strong>, displaying the cpuset name, as the path relative to the root of the cpuset file system.</p><p>Also the <em>/proc/&lt;pid&gt;/status</em> file for each task has two added lines, displaying the tasks cpus_allowed (on which CPUs it may be scheduled) and mems_allowed (on which memory nodes it may obtain memory), in the <strong>Mask Format</strong> (see below) as shown in the following example:</p><ul>
<li>
<pre>
Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff
Mems_allowed:   ffffffff,ffffffff
</pre>
</li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTENDED CAPABILITIES</h2>
        <div class="sectioncontent">
<p>In addition to controlling which <strong>cpus</strong> and <strong>mems</strong> a task is allowed to use, cpusets provide the following extended capabilities.</p><h3>Exclusive Cpusets</h3>
<p>If a cpuset is marked <strong>cpu_exclusive</strong> or <strong>mem_exclusive</strong>, no other cpuset, other than a direct ancestor or descendant, may share any of the same CPUs or memory nodes.</p><p>A cpuset that is <strong>cpu_exclusive</strong> has a scheduler (sched) domain associated with it.  The sched domain consists of all CPUs in the current cpuset that are not part of any exclusive child cpusets. This ensures that the scheduler load balancing code only balances against the CPUs that are in the sched domain as defined above and not all of the CPUs in the system. This removes any overhead due to load balancing code trying to pull tasks outside of the <strong>cpu_exclusive</strong> cpuset only to be prevented by the tasks' cpus_allowed mask.</p><p>A cpuset that is <strong>mem_exclusive</strong> restricts kernel allocations for page, buffer and other data commonly shared by the kernel across multiple users.  All cpusets, whether <strong>mem_exclusive</strong> or not, restrict allocations of memory for user space.  This enables configuring a system so that several independent jobs can share common kernel data, such as file system pages, while isolating each jobs user allocation in its own cpuset.  To do this, construct a large <strong>mem_exclusive</strong> cpuset to hold all the jobs, and construct child, non-<strong>mem_exclusive</strong> cpusets for each individual job.  Only a small amount of typical kernel memory, such as requests from interrupt handlers, is allowed to be taken outside even a <strong>mem_exclusive</strong> cpuset.</p>
<h3>Notify On Release</h3>
<p>If the <strong>notify_on_release</strong> flag is enabled (1) in a cpuset, then whenever the last task in the cpuset leaves (exits or attaches to some other cpuset) and the last child cpuset of that cpuset is removed, the kernel will run the command <em>/sbin/cpuset_release_agent</em>, supplying the pathname (relative to the mount point of the cpuset file system) of the abandoned cpuset.  This enables automatic removal of abandoned cpusets.</p><p>The default value of <strong>notify_on_release</strong> in the root cpuset at system boot is disabled (0).  The default value of other cpusets at creation is the current value of their parents <strong>notify_on_release</strong> setting.</p><p>The command <em>/sbin/cpuset_release_agent</em> is invoked, with the name (<em>/dev/cpuset</em> relative path) of that cpuset in <em>argv[1]</em>. This supports automatic cleanup of abandoned cpusets.</p><p>The usual contents of the command <em>/sbin/cpuset_release_agent</em> is simply the shell script:</p>
<pre>
#!/bin/sh
rmdir /dev/cpuset/$1
</pre>
<p>By default, <strong>notify_on_release</strong> is off (0).  Newly created cpusets inherit their <strong>notify_on_release</strong> setting from their parent cpuset.</p><p>As with other flag values below, this flag can be changed by writing an <small>ASCII</small> number 0 or 1 (with optional trailing newline) into the file, to clear or set the flag, respectively.</p>
<h3>Memory Pressure</h3>
<p>The memory_pressure of a cpuset provides a simple per-cpuset metric of the rate that the tasks in a cpuset are attempting to free up in use memory on the nodes of the cpuset to satisfy additional memory requests.</p><p>This enables batch managers monitoring jobs running in dedicated cpusets to efficiently detect what level of memory pressure that job is causing.</p><p>This is useful both on tightly managed systems running a wide mix of submitted jobs, which may choose to terminate or re-prioritize jobs that are trying to use more memory than allowed on the nodes assigned them, and with tightly coupled, long running, massively parallel scientific computing jobs that will dramatically fail to meet required performance goals if they start to use more memory than allowed to them.</p><p>This mechanism provides a very economical way for the batch manager to monitor a cpuset for signs of memory pressure.  It's up to the batch manager or other user code to decide what to do about it and take action.</p><p>Unless memory pressure calculation is enabled by setting the special file <em>/dev/cpuset/memory_pressure_enabled</em>, it is not computed for any cpuset, and always reads a value of zero. See the <strong>WARNINGS</strong> section, below.</p><p>Why a per-cpuset, running average:</p><p>Because this meter is per-cpuset rather than per-task or mm, the system load imposed by a batch scheduler monitoring this metric is sharply reduced on large systems, because a scan of the tasklist can be avoided on each set of queries.</p><p>Because this meter is a running average rather than an accumulating counter, a batch scheduler can detect memory pressure with a single read, instead of having to read and accumulate results for a period of time.</p><p>Because this meter is per-cpuset rather than per-task or mm, the batch scheduler can obtain the key information, memory pressure in a cpuset, with a single read, rather than having to query and accumulate results over all the (dynamically changing) set of tasks in the cpuset.</p><p>A per-cpuset simple digital filter is kept within the kernel, and updated by any task attached to that cpuset, if it enters the synchronous (direct) page reclaim code.</p><p>A per-cpuset file provides an integer number representing the recent (half-life of 10 seconds) rate of direct page reclaims caused by the tasks in the cpuset, in units of reclaims attempted per second, times 1000.</p>
<h3>Memory Spread</h3>
<p>There are two Boolean flag files per cpuset that control where the kernel allocates pages for the file system buffers and related in kernel data structures.  They are called <strong>memory_spread_page</strong> and <strong>memory_spread_slab</strong>.</p><p>If the per-cpuset Boolean flag file <strong>memory_spread_page</strong> is set, then the kernel will spread the file system buffers (page cache) evenly over all the nodes that the faulting task is allowed to use, instead of preferring to put those pages on the node where the task is running.</p><p>If the per-cpuset Boolean flag file <strong>memory_spread_slab</strong> is set, then the kernel will spread some file system related slab caches, such as for inodes and directory entries evenly over all the nodes that the faulting task is allowed to use, instead of preferring to put those pages on the node where the task is running.</p><p>The setting of these flags does not affect anonymous data segment or stack segment pages of a task.</p><p>By default, both kinds of memory spreading are off and the kernel prefers to allocate memory pages on the node local to where the requesting task is running.  If that node is not allowed by the tasks NUMA mempolicy or cpuset configuration or if there are insufficient free memory pages on that node, then the kernel looks for the nearest node that is allowed and does have sufficient free memory.</p><p>When new cpusets are created, they inherit the memory spread settings of their parent.</p><p>Setting memory spreading causes allocations for the affected page or slab caches to ignore the tasks NUMA mempolicy and be spread instead.    Tasks using mbind() or set_mempolicy() calls to set NUMA mempolicies will not notice any change in these calls as a result of their containing tasks memory spread settings.  If memory spreading is turned off, the currently specified NUMA mempolicy once again applies to memory page allocations.</p><p>Both <strong>memory_spread_page</strong> and <strong>memory_spread_slab</strong> are Boolean flag files.  By default they contain "0", meaning that the feature is off for that cpuset.  If a "1" is written to that file, that turns the named feature on.</p><p>This memory placement policy is also known (in other contexts) as round-robin or interleave.</p><p>This policy can provide substantial improvements for jobs that need to place thread local data on the corresponding node, but that need to access large file system data sets that need to be spread across the several nodes in the jobs cpuset in order to fit.  Without this policy, especially for jobs that might have one thread reading in the data set, the memory allocation across the nodes in the jobs cpuset can become very uneven.</p>
<h3>Memory Migration</h3>
<p>Normally, under the default setting (disabled) of <strong>memory_migrate</strong>, once a page is allocated (given a physical page of main memory) then that page stays on whatever node it was allocated, so long as it remains allocated, even if the cpusets memory placement policy <strong>mems</strong> subsequently changes.</p><p>When memory migration is enabled in a cpuset, if the <strong>mems</strong> setting of the cpuset is changed, then any memory page in use by any task in the cpuset that is on a memory node no longer allowed will be migrated to a memory node that is allowed.</p><p>Also if a task is moved into a cpuset with <strong>memory_migrate</strong> enabled, any memory pages it uses that were on memory nodes allowed in its previous cpuset, but which are not allowed in its new cpuset, will be migrated to a memory node allowed in the new cpuset.</p><p>The relative placement of a migrated page within the cpuset is preserved during these migration operations if possible. For example, if the page was on the second valid node of the prior cpuset, then the page will be placed on the second valid node of the new cpuset, if possible.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FORMATS</h2>
        <div class="sectioncontent">
<p>The following formats are used to represent sets of CPUs and memory nodes.</p><h3>Mask Format</h3>
<p>The <strong>Mask Format</strong> is used to represent CPU and memory node bitmasks in the <em>/proc/&lt;pid&gt;/status</em> file.</p><p>It is hexadecimal, using <small>ASCII</small> characters "0" - "9" and "a" - "f". This format displays each 32-bit word in hex (zero filled) and for masks longer than one word uses a comma separator between words. Words are displayed in big-endian order most significant first. And hex digits within a word are also in big-endian order.</p><p>The number of 32-bit words displayed is the minimum number needed to display all bits of the bitmask, based on the size of the bitmask.</p><p>Examples of the <strong>Mask Format</strong>:</p>
<pre>
00000001                        # just bit 0 set
80000000,00000000,00000000      # just bit 95 set
00000001,00000000,00000000      # just bit 64 set
000000ff,00000000               # bits 32-39 set
00000000,000E3862               # 1,5,6,11-13,17-19 set
</pre>
<p>A mask with bits 0, 1, 2, 4, 8, 16, 32 and 64 set displays as "00000001,00000001,00010117".  The first "1" is for bit 64, the second for bit 32, the third for bit 16, the fourth for bit 8, the fifth for bit 4, and the "7" is for bits 2, 1 and 0.</p>
<h3>List Format</h3>
<p>The <strong>List Format</strong> for <strong>cpus</strong> and <strong>mems</strong> is a comma separated list of CPU or memory node numbers and ranges of numbers, in <small>ASCII</small> decimal.</p><p>Examples of the <strong>List Format</strong>:</p>
<pre>
0-4,9           # bits 0, 1, 2, 3, 4 and 9 set
0-2,7,12-14     # bits 0, 1, 2, 7, 12, 13 and 14 set
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RULES</h2>
        <div class="sectioncontent">
<p>The following rules apply to each cpuset:</p><p>* Its CPUs and memory nodes must be a (possibly equal) subset of its parents.</p><p>* It can only be marked <strong>cpu_exclusive</strong> if its parent is.</p><p>* It can only be marked <strong>mem_exclusive</strong> if its parent is.</p><p>* If it is <strong>cpu_exclusive</strong>, its CPUs may not overlap any sibling.</p><p>* If it is <strong>memory_exclusive</strong>, its memory nodes may not overlap any sibling.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERMISSIONS</h2>
        <div class="sectioncontent">
<p>The permissions of a cpuset are determined by the permissions of the special files and directories in the cpuset file system, normally mounted at <em>/dev/cpuset</em>.</p><p>For instance, a task can put itself in some other cpuset (than its current one) if it can write the tasks file for that cpuset (requires execute permission on the encompassing directories and write permission on that tasks file).</p><p>An additional constraint is applied to requests to place some other task in a cpuset.  One task may not attach another to a cpuset unless it would have permission to send that task a signal.</p><p>A task may create a child cpuset if it can access and write the parent cpuset directory.  It can modify the CPUs or memory nodes in a cpuset if it can access that cpusets directory (execute permissions on the encompassing directories) and write the corresponding cpus or mems file.</p><p>Note however that since changes to the CPUs of a cpuset don't apply to any task in that cpuset until said task is reattached to that cpuset, it would normally not be a good idea to arrange the permissions on a cpuset so that some task could write the <strong>cpus</strong> file unless it could also write the <strong>tasks</strong> file to reattach the tasks therein.</p><p>There is one minor difference between the manner in which these permissions are evaluated and the manner in which normal file system operation permissions are evaluated.  The kernel evaluates relative pathnames starting at a tasks current working directory. Even if one is operating on a cpuset file, relative pathnames are evaluated relative to the current working directory, not relative to a tasks current cpuset.  The only ways that cpuset paths relative to a tasks current cpuset can be used are if either the tasks current working directory is its cpuset (it first did a <strong>cd</strong> or <strong>chdir</strong> to its cpuset directory beneath <em>/dev/cpuset</em>, which is a bit unusual) or if some user code converts the relative cpuset path to a full file system path.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WARNINGS</h2>
        <div class="sectioncontent">
<h3>Updating a cpusets cpus</h3>
<p>Changes to a cpusets <strong>cpus</strong> file do not take affect for any task in that cpuset until that tasks process ID (PID) is rewritten to the cpusets <strong>tasks</strong> file.  This unusual requirement is needed to optimize a critical code path in the Linux kernel.  Beware that only one PID can be written at a time to a cpusets <strong>tasks</strong> file.  Additional PIDs on a single <a href="../man2/write.2.html"><strong>write</strong>(2)</a> system call are ignored.  One (unobvious) way to satisfy this requirement to rewrite the <strong>tasks</strong> file after updating the <strong>cpus</strong> file is to use the <strong>-u</strong> unbuffered option to the <a href="../man1/sed.1.html"><strong>sed</strong>(1)</a> command, as in the following scenario:</p>
<pre>
cd /dev/cpuset/foo              # /foo is an existing cpuset
/bin/echo 3 &gt; cpus              # change /foo's cpus
sed -un p &lt; tasks &gt; tasks       # rewrite /foo's tasks file
</pre>
<p>If one examines the <strong>Cpus_allowed</strong> value in the <em>/proc/&lt;pid&gt;/status</em> file for one of the tasks in cpuset <em>/foo</em> in the above scenario, one will notice that the value does not change when the <strong>cpus</strong> file is written (the <strong>echo</strong> command), but only later, after the <strong>tasks</strong> file is rewritten (the <strong>sed</strong> command).</p>
<h3>Enabling memory_pressure</h3>
<p>By default, the per-cpuset file <strong>memory_pressure</strong> always contains zero (0). Unless this feature is enabled by writing "1" to the special file <em>/dev/cpuset/memory_pressure_enabled</em>, the kernel does not compute per-cpuset <strong>memory_pressure</strong>.</p>
<h3>Using the echo command</h3>
<p>When using the <strong>echo</strong> command at the shell prompt to change the values of cpuset files, beware that most shell built-in <strong>echo</strong> commands to not display an error message if the <a href="../man2/write.2.html"><strong>write</strong>(2)</a> system call fails.  For example, if the command:</p>
<pre>
echo 19 &gt; mems
</pre>
<p>failed because memory node 19 was not allowed (perhaps the current system does not have a memory node 19), then the above <strong>echo</strong> command would not display any error.  It is better to use the <strong>/bin/echo</strong> external command to change cpuset file settings, as this command will display <a href="../man2/write.2.html"><strong>write</strong>(2)</a> errors, as in the example:</p>
<pre>
/bin/echo 19 &gt; mems
/bin/echo: write error: No space left on device
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXCEPTIONS</h2>
        <div class="sectioncontent">
<p>Not all allocations of system memory are constrained by cpusets, for the following reasons.</p><p>If hot-plug functionality is used to remove all the CPUs that are currently assigned to a cpuset, then the kernel will automatically update the cpus_allowed of all tasks attached to CPUs in that cpuset to allow all CPUs.  When memory hot-plug functionality for removing memory nodes is available, a similar exception is expected to apply there as well.  In general, the kernel prefers to violate cpuset placement, over starving a task that has had all its allowed CPUs or memory nodes taken offline.  User code should reconfigure cpusets to only refer to online CPUs and memory nodes when using hot-plug to add or remove such resources.</p><p>A few kernel critical internal memory allocation requests, marked GFP_ATOMIC, must be satisfied, immediately.  The kernel may drop some request or malfunction if one of these allocations fail.  If such a request cannot be satisfied within the current tasks cpuset, then we relax the cpuset, and look for memory anywhere we can find it. It's better to violate the cpuset than stress the kernel.</p><p>Allocations of memory requested by kernel drivers while processing an interrupt lack any relevant task context, and are not confined by cpusets.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<h3>Kernel limitations updating cpusets</h3>
<p>In order to minimize the impact of cpusets on critical kernel code, such as the scheduler, and due to the fact that the kernel does not support one task updating the memory placement of another task directly, the impact on a task of changing its cpuset CPU or memory node placement, or of changing to which cpuset a task is attached, is subtle.</p><p>If a cpuset has its memory nodes modified, then for each task attached to that cpuset, the next time that the kernel attempts to allocate a page of memory for that task, the kernel will notice the change in the tasks cpuset, and update its per-task memory placement to remain within the new cpusets memory placement.  If the task was using mempolicy MPOL_BIND, and the nodes to which it was bound overlap with its new cpuset, then the task will continue to use whatever subset of MPOL_BIND nodes are still allowed in the new cpuset.  If the task was using MPOL_BIND and now none of its MPOL_BIND nodes are allowed in the new cpuset, then the task will be essentially treated as if it was MPOL_BIND bound to the new cpuset (even though its NUMA placement, as queried by get_mempolicy(), doesn't change).  If a task is moved from one cpuset to another, then the kernel will adjust the tasks memory placement, as above, the next time that the kernel attempts to allocate a page of memory for that task.</p><p>If a cpuset has its CPUs modified, each task using that cpuset does _not_ change its behavior automatically.  In order to minimize the impact on the critical scheduling code in the kernel, tasks will continue to use their prior CPU placement until they are rebound to their cpuset, by rewriting their PID to the 'tasks' file of their cpuset.  If a task had been bound to some subset of its cpuset using the sched_setaffinity() call, and if any of that subset is still allowed in its new cpuset settings, then the task will be restricted to the intersection of the CPUs it was allowed on before, and its new cpuset CPU placement.  If, on the other hand, there is no overlap between a tasks prior placement and its new cpuset CPU placement, then the task will be allowed to run on any CPU allowed in its new cpuset.  If a task is moved from one cpuset to another, its CPU placement is updated in the same way as if the tasks PID is rewritten to the 'tasks' file of its current cpuset.</p><p>In summary, the memory placement of a task whose cpuset is changed is updated by the kernel, on the next allocation of a page for that task, but the processor placement is not updated, until that tasks PID is rewritten to the 'tasks' file of its cpuset.  This is done to avoid impacting the scheduler code in the kernel with a check for changes in a tasks processor placement.</p>
<h3>Rename limitations</h3>
<p>You can use the <a href="../man2/rename.2.html"><strong>rename</strong>(2)</a> system call to rename cpusets. Only simple renaming is supported, changing the name of a cpuset directory while keeping its same parent.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>Despite its name, the <em>pid</em> parameter is actually a thread id, and each thread in a threaded group can be attached to a different cpuset.  The value returned from  a call to <a href="../man2/gettid.2.html"><strong>gettid</strong>(2)</a></strong> can be passed in the argument <em>pid</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>The following examples demonstrate querying and setting cpuset options using shell commands.</p><h3>Creating and attaching to a cpuset.</h3>
<p>To create a new cpuset and attach the current command shell to it, the steps are:</p><p>1) mkdir /dev/cpuset (if not already done) 2) mount -t cpuset none /dev/cpuset (if not already done) 3) Create the new cpuset using <a href="../man1/mkdir.1.html"><strong>mkdir</strong>(1)</a>. 4) Assign CPUs and memory nodes to the new cpuset. 5) Attach the shell to the new cpuset.</p><p>For example, the following sequence of commands will setup a cpuset named "Charlie", containing just CPUs 2 and 3, and memory node 1, and then attach the current shell to that cpuset.</p>
<pre>
mkdir /dev/cpuset
mount -t cpuset cpuset /dev/cpuset
cd /dev/cpuset
mkdir Charlie
cd Charlie
/bin/echo 2-3 &gt; cpus
/bin/echo 1 &gt; mems
/bin/echo $$ &gt; tasks
# The current shell is now running in cpuset Charlie
# The next line should display '/Charlie'
cat /proc/self/cpuset
</pre>

<h3>Migrating a job to different memory nodes.</h3>
<p>To migrate a job (the set of tasks attached to a cpuset) to different CPUs and memory nodes in the system, including moving the memory pages currently allocated to that job, perform the following steps.</p><p>1) Lets say we want to move the job in cpuset <em>alpha</em> (CPUs 4-7 and memory nodes 2-3) to a new cpuset <em>beta</em> (CPUs 16-19 and memory nodes 8-9). 2) First create the new cpuset <em>beta</em>. 3) Then allow CPUs 16-19 and memory nodes 8-9 in <em>beta</em>. 4) Then enable <strong>memory_migration</strong> in <em>beta</em>. 5) Then move each task from <em>alpha</em> to <em>beta</em>.</p><p>The following sequence of commands accomplishes this.</p>
<pre>
cd /dev/cpuset
mkdir beta
cd beta
/bin/echo 16-19 &gt; cpus
/bin/echo 8-9 &gt; mems
/bin/echo 1 &gt; memory_migrate
while read i; do /bin/echo $i; done &lt; ../alpha/tasks &gt; tasks
</pre>
<p>The above should move any tasks in alpha to beta, and any memory held by these tasks on memory nodes 2-3 to memory nodes 8-9, respectively.</p><p>Notice that the last step of the above sequence did not do:</p>
<pre>
cp ../alpha/tasks tasks
</pre>
<p>The <em>while</em> loop, rather than the seemingly easier use of the <strong>cp</strong>(1) command, was necessary because only one task PID at a time may be written to the <strong>tasks</strong> file.</p><p>The same affect (writing one pid at a time) as the <em>while</em> loop can be accomplished more efficiently, in fewer keystrokes and in syntax that works on any shell, but alas more obscurely, by using the <strong>sed -u [unbuffered]</strong> option:</p>
<pre>
sed -un p &lt; ../alpha/tasks &gt; tasks
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p>The Linux kernel implementation of cpusets sets <strong>errno</strong> to specify the reason for a failed system call affecting cpusets.</p><p>The possible errno settings and their meaning when set on a failed cpuset call are as listed below.</p>
<dl class='dl-vertical'>
  <dt>
    <p>ENOMEM</p>
  </dt>
  <dd>
    <p>Insufficient memory is available.</p>
  </dd>
  <dt>
    <p>EBUSY</p>
  </dt>
  <dd>
    <p>Attempted to remove a cpuset with attached tasks.</p>
  </dd>
  <dt>
    <p>EBUSY</p>
  </dt>
  <dd>
    <p>Attempted to remove a cpuset with child cpusets.</p>
  </dd>
  <dt>
    <p>ENOENT</p>
  </dt>
  <dd>
    <p>Attempted to create a cpuset in a parent cpuset that doesn't exist.</p>
  </dd>
  <dt>
    <p>ENOENT</p>
  </dt>
  <dd>
    <p>Attempted to access a non-existent file in a cpuset directory.</p>
  </dd>
  <dt>
    <p>EEXIST</p>
  </dt>
  <dd>
    <p>Attempted to create a cpuset that already exists.</p>
  </dd>
  <dt>
    <p>EEXIST</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/rename.2.html"><strong>rename</strong>(2)</a> a cpuset to a name that already exists.</p>
  </dd>
  <dt>
    <p>ENOTDIR</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/rename.2.html"><strong>rename</strong>(2)</a> a non-existent cpuset.</p>
  </dd>
  <dt>
    <p>E2BIG</p>
  </dt>
  <dd>
    <p>Attempted a <a href="../man2/write.2.html"><strong>write</strong>(2)</a> system  call on a special cpuset file with a length larger than some kernel determined upper limit on the length of such writes.</p>
  </dd>
  <dt>
    <p>ESRCH</p>
  </dt>
  <dd>
    <p>Attempted to write the process ID (PID) of a non-existent task to a cpuset <strong>tasks</strong> file.</p>
  </dd>
  <dt>
    <p>EACCES</p>
  </dt>
  <dd>
    <p>Attempted to write the process ID (PID) of a task to a cpuset <strong>tasks</strong> file when one lacks permission to move that task.</p>
  </dd>
  <dt>
    <p>EACCESS</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a <strong>memory_pressure</strong> file.</p>
  </dd>
  <dt>
    <p>ENOSPC</p>
  </dt>
  <dd>
    <p>Attempted to write the process ID (PID) of a task to a cpuset <strong>tasks</strong> file when the cpuset had an empty <strong>cpus</strong> or empty <strong>mems</strong> setting.</p>
  </dd>
  <dt>
    <p>EINVAL</p>
  </dt>
  <dd>
    <p>Attempted to change a cpuset in a way that would violate a <strong>cpu_exclusive</strong> or <strong>mem_exclusive</strong> attribute of that cpuset or any of its siblings.</p>
  </dd>
  <dt>
    <p>EINVAL</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> an empty <strong>cpus</strong> or <strong>mems</strong> list to the kernel.  The kernel creates new cpusets (via <a href="../man2/mkdir.2.html"><strong>mkdir</strong>(2)</a>) with empty <strong>cpus</strong> and <strong>mems</strong>.  But the kernel will not allow an empty list to be written to the special <strong>cpus</strong> or <strong>mems</strong> files of a cpuset.</p>
  </dd>
  <dt>
    <p>EIO</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a string to a cpuset <strong>tasks</strong> file that does not begin with an <small>ASCII</small> decimal integer.</p>
  </dd>
  <dt>
    <p>EIO</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/rename.2.html"><strong>rename</strong>(2)</a> a cpuset outside of its current directory.</p>
  </dd>
  <dt>
    <p>ENOSPC</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a list to a <strong>cpus</strong> file that did not include any online CPUs.</p>
  </dd>
  <dt>
    <p>ENOSPC</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a list to a <strong>mems</strong> file that did not include any online memory nodes.</p>
  </dd>
  <dt>
    <p>ENODEV</p>
  </dt>
  <dd>
    <p>The cpuset was removed by another task at the same time as a <a href="../man2/write.2.html"><strong>write</strong>(2)</a> was attempted on one of the special files in the cpuset directory.</p>
  </dd>
  <dt>
    <p>EACCES</p>
  </dt>
  <dd>
    <p>Attempted to add a CPU or memory node to a cpuset that is not already in its parent.</p>
  </dd>
  <dt>
    <p>EACCES</p>
  </dt>
  <dd>
    <p>Attempted to set <strong>cpu_exclusive</strong> or <strong>mem_exclusive</strong> on a cpuset whose parent lacks the same setting.</p>
  </dd>
  <dt>
    <p>EBUSY</p>
  </dt>
  <dd>
    <p>Attempted to remove a CPU or memory node from a cpuset that is also in a child of that cpuset.</p>
  </dd>
  <dt>
    <p>EFAULT</p>
  </dt>
  <dd>
    <p>Attempted to <a href="../man2/read.2.html"><strong>read</strong>(2)</a> or <a href="../man2/write.2.html"><strong>write</strong>(2)</a> a cpuset file using a buffer that is outside your accessible address space.</p>
  </dd>
  <dt>
    <p>ENAMETOOLONG</p>
  </dt>
  <dd>
    <p>Attempted to read a <em>/proc/&lt;pid&gt;/cpuset</em> file for a cpuset path that is longer than the kernel page size.</p>
  </dd>
  <dt>
    <p>ENAMETOOLONG</p>
  </dt>
  <dd>
    <p>Attempted to create a cpuset whose base directory name is longer than 255 characters.</p>
  </dd>
  <dt>
    <p>ENAMETOOLONG</p>
  </dt>
  <dd>
    <p>Attempted to create a cpuset whose full pathname including the "/dev/cpuset/" prefix is longer than 4095 characters.</p>
  </dd>
  <dt>
    <p>EINVAL</p>
  </dt>
  <dd>
    <p>Specified a <strong>cpus</strong> or <strong>mems</strong> list to the kernel which included a range with the second number smaller than the first number.</p>
  </dd>
  <dt>
    <p>EINVAL</p>
  </dt>
  <dd>
    <p>Specified a <strong>cpus</strong> or <strong>mems</strong> list to the kernel which included an invalid character in the string.</p>
  </dd>
  <dt>
    <p>ERANGE</p>
  </dt>
  <dd>
    <p>Specified a <strong>cpus</strong> or <strong>mems</strong> list to the kernel which included a number too large for the kernel to set in its bitmasks.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO cpuset&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/cat.1.html"><strong>cat</strong>(1)</a>, <a href="../man1/echo.1.html"><strong>echo</strong>(1)</a>, ls(1), <a href="../man1/mkdir.1.html"><strong>mkdir</strong>(1)</a>, <a href="../man1/rmdir.1.html"><strong>rmdir</strong>(1)</a>, <a href="../man1/sed.1.html"><strong>sed</strong>(1)</a>, <a href="../man1/taskset.1.html"><strong>taskset</strong>(1)</a>, <a href="../man2/close.2.html"><strong>close</strong>(2)</a>, <a href="../man2/get_mempolicy.2.html"><strong>get_mempolicy</strong>(2)</a>, <a href="../man2/mbind.2.html"><strong>mbind</strong>(2)</a>, <a href="../man2/mkdir.2.html"><strong>mkdir</strong>(2)</a>, <a href="../man2/open.2.html"><strong>open</strong>(2)</a>, <a href="../man2/read.2.html"><strong>read</strong>(2)</a> <a href="../man2/rmdir.2.html"><strong>rmdir</strong>(2)</a>, <a href="../man2/sched_getaffinity.2.html"><strong>sched_getaffinity</strong>(2)</a>, <a href="../man2/sched_setaffinity.2.html"><strong>sched_setaffinity</strong>(2)</a>, <strong>set_mempolicy</strong>(2), <a href="../man2/sched_setscheduler.2.html"><strong>sched_setscheduler</strong>(2)</a>, <strong>taskset</strong>(2), <a href="../man2/write.2.html"><strong>write</strong>(2)</a>, <a href="../man3/libbitmask.3.html"><strong>libbitmask</strong>(3)</a>, <a href="../man5/proc.5.html"><strong>proc</strong>(5)</a>, <a href="../man8/migratepages.8.html"><strong>migratepages</strong>(8)</a>, <a href="../man8/numactl.8.html"><strong>numactl</strong>(8)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p>Cpusets appeared in version 2.6.13 of the Linux kernel.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p><strong>memory_pressure</strong> cpuset files can be opened for writing, creation or truncation, but then the <a href="../man2/write.2.html"><strong>write</strong>(2)</a> fails with <strong>errno</strong> == <strong>EACCESS</strong>, and the creation and truncation options on <a href="../man2/open.2.html"><strong>open</strong>(2)</a> have no affect.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>This man page was written by Paul Jackson.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="cpuid.4.html"><span aria-hidden="true">&larr;</span> cpuid.4: X86 cpuid access device</a></li>
   <li class="next"><a href="doc.4.html">doc.4: (pilot standard text document) file format <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>md - Multiple Device driver aka Linux Software RAID</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Multiple device driver aka linux software raid">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">md<small> (4)</small></h1>
        <p class="lead">Multiple device driver aka linux software raid</p>
      </div>

    <ol class="breadcrumb">
	<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_section">
		<a itemprop="url" href="/"><span itemprop="title">Carta.tech</span></a>
	</li>
	<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_section">
		<a itemprop="url" href="https://www.carta.tech/man-pages/"><span itemprop="title">man-pages</span></a>
	</li>
	<li id="breadcrumb_section" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_page" itemprop="child">
		<a itemprop="url" href="https://www.carta.tech/man-pages/man4/"><span itemprop="title">Special files</span></a>
	</li>
	<li id="breadcrumb_page" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemprop="child" class="active">
		<a itemprop="url" href="https://www.carta.tech/man-pages/man4/md.4.html"><span itemprop="title">md</span></a>
	</li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<p><strong>/dev/md</strong><em>n</em></p>
<p class='spacer'>

<p><strong>/dev/md/</strong><em>n</em></p>
<p class='spacer'>

<p><strong>/dev/md/</strong>name</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<p>The <strong>md</strong> driver provides virtual devices that are created from one or more independent underlying devices.  This array of devices often contains redundancy and the devices are often disk drives, hence the acronym RAID which stands for a Redundant Array of Independent Disks.</p>
<p class='spacer'>

<p><strong>md</strong> supports RAID levels 1 (mirroring), 4 (striped array with parity device), 5 (striped array with distributed parity information), 6 (striped array with distributed dual redundancy information), and 10 (striped and mirrored). If some number of underlying devices fails while using one of these levels, the array will continue to function; this number is one for RAID levels 4 and 5, two for RAID level 6, and all but one (N-1) for RAID level 1, and dependent on configuration for level 10.</p>
<p class='spacer'>

<p><strong>md</strong> also supports a number of pseudo RAID (non-redundant) configurations including RAID0 (striped array), LINEAR (catenated array), MULTIPATH (a set of different interfaces to the same device), and FAULTY (a layer over a single device into which errors can be injected).</p>
<p class='spacer'>

  <h3>MD METADATA</h3>
<p>Each device in an array may have some <em>metadata</em> stored in the device.  This metadata is sometimes called a <strong>superblock</strong>. The metadata records information about the structure and state of the array. This allows the array to be reliably re-assembled after a shutdown.</p>
<p class='spacer'>

<p>From Linux kernel version 2.6.10, <strong>md</strong> provides support for two different formats of metadata, and other formats can be added.  Prior to this release, only one format is supported.</p>
<p class='spacer'>

<p>The common format &ndash; known as version 0.90 &ndash; has a superblock that is 4K long and is written into a 64K aligned block that starts at least 64K and less than 128K from the end of the device (i.e. to get the address of the superblock round the size of the device down to a multiple of 64K and then subtract 64K). The available size of each device is the amount of space before the super block, so between 64K and 128K is lost when a device in incorporated into an MD array. This superblock stores multi-byte fields in a processor-dependent manner, so arrays cannot easily be moved between computers with different processors.</p>
<p class='spacer'>

<p>The new format &ndash; known as version 1 &ndash; has a superblock that is normally 1K long, but can be longer.  It is normally stored between 8K and 12K from the end of the device, on a 4K boundary, though variations can be stored at the start of the device (version 1.1) or 4K from the start of the device (version 1.2). This metadata format stores multibyte data in a processor-independent format and supports up to hundreds of component devices (version 0.90 only supports 28).</p>
<p class='spacer'>

  <p>The metadata contains, among other things:</p>
  <dl class='dl-horizontal'>
    <dt>LEVEL</dt>
    <dd>
  <p>The manner in which the devices are arranged into the array (LINEAR, RAID0, RAID1, RAID4, RAID5, RAID10, MULTIPATH).</p>
    </dd>
    <dt>UUID</dt>
    <dd>
  <p>a 128 bit Universally Unique Identifier that identifies the array that contains this device.</p>
<p class='spacer'>

    </dd>
  </dl>
<p class='spacer'>

<p>When a version 0.90 array is being reshaped (e.g. adding extra devices to a RAID5), the version number is temporarily set to 0.91.  This ensures that if the reshape process is stopped in the middle (e.g. by a system crash) and the machine boots into an older kernel that does not support reshaping, then the array will not be assembled (which would cause data corruption) but will be left untouched until a kernel that can complete the reshape processes is used.</p>
<p class='spacer'>

  <h3>ARRAYS WITHOUT METADATA</h3>
  <p>While it is usually best to create arrays with superblocks so that they can be assembled reliably, there are some circumstances when an array without superblocks is preferred.  These include:</p>
  <dl class='dl-vertical'>
    <dt>LEGACY ARRAYS</dt>
    <dd>
  <p>Early versions of the <strong>md</strong> driver only supported LINEAR and RAID0 configurations and did not use a superblock (which is less critical with these configurations). While such arrays should be rebuilt with superblocks if possible, <strong>md</strong> continues to support them.</p>
    </dd>
    <dt>FAULTY</dt>
    <dd>
  <p>Being a largely transparent layer over a different device, the FAULTY personality doesn't gain anything from having a superblock.</p>
    </dd>
    <dt>MULTIPATH</dt>
    <dd>
  <p>It is often possible to detect devices which are different paths to the same storage directly rather than having a distinctive superblock written to the device and searched for on all paths.  In this case, a MULTIPATH array with no superblock makes sense.</p>
    </dd>
    <dt>RAID1</dt>
    <dd>
  <p>In some configurations it might be desired to create a RAID1 configuration that does not use a superblock, and to maintain the state of the array elsewhere.  While not encouraged for general use, it does have special-purpose uses and is supported.</p>
<p class='spacer'>

    </dd>
  </dl>
  <h3>ARRAYS WITH EXTERNAL METADATA</h3>
<p class='spacer'>

<p>From release 2.6.28, the <em>md</em> driver supports arrays with externally managed metadata.  That is, the metadata is not managed by the kernel but rather by a user-space program which is external to the kernel.  This allows support for a variety of metadata formats without cluttering the kernel with lots of details.</p>
<p class='spacer'>

<p><em>md</em> is able to communicate with the user-space program through various sysfs attributes so that it can make appropriate changes to the metadata - for example to mark a device as faulty.  When necessary, <em>md</em> will wait for the program to acknowledge the event by writing to a sysfs attribute. The manual page for <a href="../man8/mdmon.8.html"><strong>mdmon</strong>(8)</a> contains more detail about this interaction.</p>
<p class='spacer'>

  <h3>CONTAINERS</h3>
<p>Many metadata formats use a single block of metadata to describe a number of different arrays which all use the same set of devices. In this case it is helpful for the kernel to know about the full set of devices as a whole.  This set is known to md as a <em>container</em>. A container is an <em>md</em> array with externally managed metadata and with device offset and size so that it just covers the metadata part of the devices.  The remainder of each device is available to be incorporated into various arrays.</p>
<p class='spacer'>

  <h3>LINEAR</h3>
<p class='spacer'>

<p>A LINEAR array simply catenates the available space on each drive to form one large virtual drive.</p>
<p class='spacer'>

<p>One advantage of this arrangement over the more common RAID0 arrangement is that the array may be reconfigured at a later time with an extra drive, so the array is made bigger without disturbing the data that is on the array.  This can even be done on a live array.</p>
<p class='spacer'>

<p>If a chunksize is given with a LINEAR array, the usable space on each device is rounded down to a multiple of this chunksize.</p>
<p class='spacer'>

  <h3>RAID0</h3>
<p class='spacer'>

<p>A RAID0 array (which has zero redundancy) is also known as a striped array. A RAID0 array is configured at creation with a <strong>Chunk Size</strong> which must be a power of two (prior to Linux 2.6.31), and at least 4 kibibytes.</p>
<p class='spacer'>

<p>The RAID0 driver assigns the first chunk of the array to the first device, the second chunk to the second device, and so on until all drives have been assigned one chunk.  This collection of chunks forms a <strong>stripe</strong>. Further chunks are gathered into stripes in the same way, and are assigned to the remaining space in the drives.</p>
<p class='spacer'>

<p>If devices in the array are not all the same size, then once the smallest device has been exhausted, the RAID0 driver starts collecting chunks into smaller stripes that only span the drives which still have remaining space.</p>
<p class='spacer'>

  <h3>RAID1</h3>
<p class='spacer'>

<p>A RAID1 array is also known as a mirrored set (though mirrors tend to provide reflected images, which RAID1 does not) or a plex.</p>
<p class='spacer'>

<p>Once initialised, each device in a RAID1 array contains exactly the same data.  Changes are written to all devices in parallel.  Data is read from any one device.  The driver attempts to distribute read requests across all devices to maximise performance.</p>
<p class='spacer'>

<p>All devices in a RAID1 array should be the same size.  If they are not, then only the amount of space available on the smallest device is used (any extra space on other devices is wasted).</p>
<p class='spacer'>

<p>Note that the read balancing done by the driver does not make the RAID1 performance profile be the same as for RAID0; a single stream of sequential input will not be accelerated (e.g. a single dd), but multiple sequential streams or a random workload will use more than one spindle. In theory, having an N-disk RAID1 will allow N sequential threads to read from all disks.</p>
<p class='spacer'>

<p>Individual devices in a RAID1 can be marked as "write-mostly". These drives are excluded from the normal read balancing and will only be read from when there is no other option.  This can be useful for devices connected over a slow link.</p>
<p class='spacer'>

  <h3>RAID4</h3>
<p class='spacer'>

<p>A RAID4 array is like a RAID0 array with an extra device for storing parity. This device is the last of the active devices in the array. Unlike RAID0, RAID4 also requires that all stripes span all drives, so extra space on devices that are larger than the smallest is wasted.</p>
<p class='spacer'>

<p>When any block in a RAID4 array is modified, the parity block for that stripe (i.e. the block in the parity device at the same device offset as the stripe) is also modified so that the parity block always contains the "parity" for the whole stripe.  I.e. its content is equivalent to the result of performing an exclusive-or operation between all the data blocks in the stripe.</p>
<p class='spacer'>

<p>This allows the array to continue to function if one device fails. The data that was on that device can be calculated as needed from the parity block and the other data blocks.</p>
<p class='spacer'>

  <h3>RAID5</h3>
<p class='spacer'>

<p>RAID5 is very similar to RAID4.  The difference is that the parity blocks for each stripe, instead of being on a single device, are distributed across all devices.  This allows more parallelism when writing, as two different block updates will quite possibly affect parity blocks on different devices so there is less contention.</p>
<p class='spacer'>

<p>This also allows more parallelism when reading, as read requests are distributed over all the devices in the array instead of all but one.</p>
<p class='spacer'>

  <h3>RAID6</h3>
<p class='spacer'>

<p>RAID6 is similar to RAID5, but can handle the loss of any <em>two</em> devices without data loss.  Accordingly, it requires N+2 drives to store N drives worth of data.</p>
<p class='spacer'>

<p>The performance for RAID6 is slightly lower but comparable to RAID5 in normal mode and single disk failure mode.  It is very slow in dual disk failure mode, however.</p>
<p class='spacer'>

  <h3>RAID10</h3>
<p class='spacer'>

<p>RAID10 provides a combination of RAID1 and RAID0, and is sometimes known as RAID1+0.  Every datablock is duplicated some number of times, and the resulting collection of datablocks are distributed over multiple drives.</p>
<p class='spacer'>

<p>When configuring a RAID10 array, it is necessary to specify the number of replicas of each data block that are required (this will usually be&nbsp;2) and whether their layout should be "near", "far" or "offset" (with "offset" being available since Linux&nbsp;2.6.18).</p>
<p class='spacer'>

<p><strong>About the RAID10 Layout Examples:</strong></p>
<p class='spacer'>

<p>The examples below visualise the chunk distribution on the underlying devices for the respective layout.</p>
<p class='spacer'>

<p>For simplicity it is assumed that the size of the chunks equals the size of the blocks of the underlying devices as well as those of the RAID10 device exported by the kernel (for example <strong>/dev/md/</strong>name).</p>
<p class='spacer'>

<p>Therefore the chunks&nbsp;/&nbsp;chunk numbers map directly to the blocks&nbsp;/ block addresses of the exported RAID10 device.</p>
<p class='spacer'>

<p>Decimal numbers (0,&nbsp;1, 2,&nbsp;...) are the chunks of the RAID10 and due to the above assumption also the blocks and block addresses of the exported RAID10 device.</p>
<p class='spacer'>

<p>Repeated numbers mean copies of a chunk&nbsp;/&nbsp;block (obviously on different underlying devices).</p>
<p class='spacer'>

<p>Hexadecimal numbers (0x00,&nbsp;0x01, 0x02,&nbsp;...) are the block addresses of the underlying devices.</p>
<p class='spacer'>

  <dl class='dl-vertical'>
    <dt><strong> "near" Layout</strong></dt>
    <dd>
  <p>When "near" replicas are chosen, the multiple copies of a given chunk are laid out consecutively ("as close to each other as possible") across the stripes of the array.</p>
<p class='spacer'>

  <p>With an even number of devices, they will likely (unless some misalignment is present) lay at the very same offset on the different devices.</p>
<p class='spacer'>

  <p>This is as the "classic" RAID1+0; that is two groups of mirrored devices (in the example below the groups Device&nbsp;#1&nbsp;/&nbsp;#2 and Device&nbsp;#3&nbsp;/&nbsp;#4 are each a RAID1) both in turn forming a striped RAID0.</p>
<p class='spacer'>

  <p><strong>Example with 2&nbsp;copies per chunk and an even number&nbsp;(4) of devices:</strong></p>
<table class="table table-striped">
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th></tr>

<tr>
<td></td>
<td>Device #1</td>
<td>Device #2</td>
<td>Device #3</td>
<td>Device #4</td></tr>

<tr>
<td>0x00</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td></tr>

<tr>
<td>0x01</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td></tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td></tr>

<tr>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td></tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td></tr>

<tr>
<td>0x80</td>
<td>254</td>
<td>254</td>
<td>255</td>
<td>255</td></tr>

<tr>
<td></td>
<td>\---------v---------/</td>
<td>\---------v---------/</td>
<td></td>
<td></td></tr>

<tr>
<td></td>
<td>RAID1</td>
<td>RAID1</td>
<td></td>
<td></td></tr>

<tr>
<td></td>
<td>\---------------------v---------------------/</td>
<td></td>
<td></td>
<td></td></tr>

<tr>
<td></td>
<td>RAID0</td>
<td></td>
<td></td>
<td></td></tr>
</table>

<p class='spacer'>

  <p><strong>Example with 2&nbsp;copies per chunk and an odd number&nbsp;(5) of devices:</strong></p>
<table class="table table-striped">
<tr>
<th></th></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>Dev #1</td></tr>

<tr>
<td>Dev #2</td></tr>

<tr>
<td>Dev #3</td></tr>

<tr>
<td>Dev #4</td></tr>

<tr>
<td>Dev #5</td></tr>

<tr>
<td>0x00</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>0x01</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>0x80</td></tr>

<tr>
<td>317</td></tr>

<tr>
<td>318</td></tr>

<tr>
<td>318</td></tr>

<tr>
<td>319</td></tr>

<tr>
<td>319</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>
</table>

<p class='spacer'>

    </dd>
    <dt><strong> "far" Layout</strong></dt>
    <dd>
  <p>When "far" replicas are chosen, the multiple copies of a given chunk are laid out quite distant ("as far as reasonably possible") from each other.</p>
<p class='spacer'>

  <p>First a complete sequence of all data blocks (that is all the data one sees on the exported RAID10 block device) is striped over the devices. Then another (though "shifted") complete sequence of all data blocks; and so on (in the case of more than 2&nbsp;copies per chunk).</p>
<p class='spacer'>

  <p>The "shift" needed to prevent placing copies of the same chunks on the same devices is actually a cyclic permutation with offset&nbsp;1 of each of the stripes within a complete sequence of chunks.</p>
<p class='spacer'>

  <p>The offset&nbsp;1 is relative to the previous complete sequence of chunks, so in case of more than 2&nbsp;copies per chunk one gets the following offsets:</p>
<p class='spacer'>

  <p>1.&nbsp;complete sequence of chunks: offset&nbsp;=&nbsp;&nbsp;0</p>
<p class='spacer'>

  <p>2.&nbsp;complete sequence of chunks: offset&nbsp;=&nbsp;&nbsp;1</p>
<p class='spacer'>

  <p>3.&nbsp;complete sequence of chunks: offset&nbsp;=&nbsp;&nbsp;2</p>
<p class='spacer'>

<pre>                       :</pre>

<p class='spacer'>

  <p>n.&nbsp;complete sequence of chunks: offset&nbsp;=&nbsp;n-1</p>
<p class='spacer'>

  <p><strong>Example with 2&nbsp;copies per chunk and an even number&nbsp;(4) of devices:</strong></p>
<table class="table table-striped">
<tr>
<th></th></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>Device #1</td></tr>

<tr>
<td>Device #2</td></tr>

<tr>
<td>Device #3</td></tr>

<tr>
<td>Device #4</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>0x00</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>&#92</td></tr>

<tr>
<td></td></tr>

<tr>
<td>0x01</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>5</td></tr>

<tr>
<td>6</td></tr>

<tr>
<td>7</td></tr>

<tr>
<td>&gt</td></tr>

<tr>
<td> [#]</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>0x40</td></tr>

<tr>
<td>252</td></tr>

<tr>
<td>253</td></tr>

<tr>
<td>254</td></tr>

<tr>
<td>255</td></tr>

<tr>
<td>/</td></tr>

<tr>
<td>0x41</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>&#92</td></tr>

<tr>
<td></td></tr>

<tr>
<td>0x42</td></tr>

<tr>
<td>7</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>5</td></tr>

<tr>
<td>6</td></tr>

<tr>
<td>&gt</td></tr>

<tr>
<td> [#]~</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>0x80</td></tr>

<tr>
<td>255</td></tr>

<tr>
<td>252</td></tr>

<tr>
<td>253</td></tr>

<tr>
<td>254</td></tr>

<tr>
<td>/</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>
</table>

<p class='spacer'>

  <p><strong>Example with 2&nbsp;copies per chunk and an odd number&nbsp;(5) of devices:</strong></p>
<table class="table table-striped">
<tr>
<th></th></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>Dev #1</td></tr>

<tr>
<td>Dev #2</td></tr>

<tr>
<td>Dev #3</td></tr>

<tr>
<td>Dev #4</td></tr>

<tr>
<td>Dev #5</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>0x00</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>&#92</td></tr>

<tr>
<td></td></tr>

<tr>
<td>0x01</td></tr>

<tr>
<td>5</td></tr>

<tr>
<td>6</td></tr>

<tr>
<td>7</td></tr>

<tr>
<td>8</td></tr>

<tr>
<td>9</td></tr>

<tr>
<td>&gt</td></tr>

<tr>
<td> [#]</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>0x40</td></tr>

<tr>
<td>315</td></tr>

<tr>
<td>316</td></tr>

<tr>
<td>317</td></tr>

<tr>
<td>318</td></tr>

<tr>
<td>319</td></tr>

<tr>
<td>/</td></tr>

<tr>
<td>0x41</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>&#92</td></tr>

<tr>
<td></td></tr>

<tr>
<td>0x42</td></tr>

<tr>
<td>9</td></tr>

<tr>
<td>5</td></tr>

<tr>
<td>6</td></tr>

<tr>
<td>7</td></tr>

<tr>
<td>8</td></tr>

<tr>
<td>&gt</td></tr>

<tr>
<td> [#]~</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>0x80</td></tr>

<tr>
<td>319</td></tr>

<tr>
<td>315</td></tr>

<tr>
<td>316</td></tr>

<tr>
<td>317</td></tr>

<tr>
<td>318</td></tr>

<tr>
<td>/</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>
</table>

<p class='spacer'>

  <p>With [#]&nbsp;being the complete sequence of chunks and [#]~&nbsp;the cyclic permutation with offset&nbsp;1 thereof (in the case of more than 2 copies per chunk there would be ([#]~)~,&nbsp;(([#]~)~)~,&nbsp;...).</p>
<p class='spacer'>

  <p>The advantage of this layout is that MD can easily spread sequential reads over the devices, making them similar to RAID0 in terms of speed.</p>
<p class='spacer'>

  <p>The cost is more seeking for writes, making them substantially slower.</p>
<p class='spacer'>

    </dd>
    <dt><strong>"offset" Layout</strong></dt>
    <dd>
  <p>When "offset" replicas are chosen, all the copies of a given chunk are striped consecutively ("offset by the stripe length after each other") over the devices.</p>
<p class='spacer'>

  <p>Explained in detail, &lt;number of devices&gt; consecutive chunks are striped over the devices, immediately followed by a "shifted" copy of these chunks (and by further such "shifted" copies in the case of more than 2&nbsp;copies per chunk).</p>
<p class='spacer'>

  <p>This pattern repeats for all further consecutive chunks of the exported RAID10 device (in other words: all further data blocks).</p>
<p class='spacer'>

  <p>The "shift" needed to prevent placing copies of the same chunks on the same devices is actually a cyclic permutation with offset&nbsp;1 of each of the striped copies of &lt;number of devices&gt; consecutive chunks.</p>
<p class='spacer'>

  <p>The offset&nbsp;1 is relative to the previous striped copy of &lt;number of devices&gt; consecutive chunks, so in case of more than 2&nbsp;copies per chunk one gets the following offsets:</p>
<p class='spacer'>

  <p>1.&nbsp;&lt;number of devices&gt; consecutive chunks: offset&nbsp;=&nbsp;&nbsp;0</p>
<p class='spacer'>

  <p>2.&nbsp;&lt;number of devices&gt; consecutive chunks: offset&nbsp;=&nbsp;&nbsp;1</p>
<p class='spacer'>

  <p>3.&nbsp;&lt;number of devices&gt; consecutive chunks: offset&nbsp;=&nbsp;&nbsp;2</p>
<p class='spacer'>

<pre>                             :</pre>

<p class='spacer'>

  <p>n.&nbsp;&lt;number of devices&gt; consecutive chunks: offset&nbsp;=&nbsp;n-1</p>
<p class='spacer'>

  <p><strong>Example with 2&nbsp;copies per chunk and an even number&nbsp;(4) of devices:</strong></p>
<table class="table table-striped">
<tr>
<th></th></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>Device #1</td></tr>

<tr>
<td>Device #2</td></tr>

<tr>
<td>Device #3</td></tr>

<tr>
<td>Device #4</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>0x00</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>) AA</td></tr>

<tr>
<td>0x01</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>) AA~</td></tr>

<tr>
<td>0x02</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>5</td></tr>

<tr>
<td>6</td></tr>

<tr>
<td>7</td></tr>

<tr>
<td>) AB</td></tr>

<tr>
<td>0x03</td></tr>

<tr>
<td>7</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>5</td></tr>

<tr>
<td>6</td></tr>

<tr>
<td>) AB~</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>) ...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>  :</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>) ...</td></tr>

<tr>
<td>0x79</td></tr>

<tr>
<td>251</td></tr>

<tr>
<td>252</td></tr>

<tr>
<td>253</td></tr>

<tr>
<td>254</td></tr>

<tr>
<td>) EX</td></tr>

<tr>
<td>0x80</td></tr>

<tr>
<td>254</td></tr>

<tr>
<td>251</td></tr>

<tr>
<td>252</td></tr>

<tr>
<td>253</td></tr>

<tr>
<td>) EX~</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>
</table>

<p class='spacer'>

  <p><strong>Example with 2&nbsp;copies per chunk and an odd number&nbsp;(5) of devices:</strong></p>
<table class="table table-striped">
<tr>
<th></th></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>Dev #1</td></tr>

<tr>
<td>Dev #2</td></tr>

<tr>
<td>Dev #3</td></tr>

<tr>
<td>Dev #4</td></tr>

<tr>
<td>Dev #5</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>

<tr>
<td>0x00</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>) AA</td></tr>

<tr>
<td>0x01</td></tr>

<tr>
<td>4</td></tr>

<tr>
<td>0</td></tr>

<tr>
<td>1</td></tr>

<tr>
<td>2</td></tr>

<tr>
<td>3</td></tr>

<tr>
<td>) AA~</td></tr>

<tr>
<td>0x02</td></tr>

<tr>
<td>5</td></tr>

<tr>
<td>6</td></tr>

<tr>
<td>7</td></tr>

<tr>
<td>8</td></tr>

<tr>
<td>9</td></tr>

<tr>
<td>) AB</td></tr>

<tr>
<td>0x03</td></tr>

<tr>
<td>9</td></tr>

<tr>
<td>5</td></tr>

<tr>
<td>6</td></tr>

<tr>
<td>7</td></tr>

<tr>
<td>8</td></tr>

<tr>
<td>) AB~</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>) ...</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>:</td></tr>

<tr>
<td>  :</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>...</td></tr>

<tr>
<td>) ...</td></tr>

<tr>
<td>0x79</td></tr>

<tr>
<td>314</td></tr>

<tr>
<td>315</td></tr>

<tr>
<td>316</td></tr>

<tr>
<td>317</td></tr>

<tr>
<td>318</td></tr>

<tr>
<td>) EX</td></tr>

<tr>
<td>0x80</td></tr>

<tr>
<td>318</td></tr>

<tr>
<td>314</td></tr>

<tr>
<td>315</td></tr>

<tr>
<td>316</td></tr>

<tr>
<td>317</td></tr>

<tr>
<td>) EX~</td></tr>

<tr>
<td></td></tr>

<tr>
<td></td></tr>
</table>

<p class='spacer'>

  <p>With AA,&nbsp;AB,&nbsp;..., AZ,&nbsp;BA,&nbsp;... being the sets of &lt;number of devices&gt; consecutive chunks and AA~,&nbsp;AB~,&nbsp;..., AZ~,&nbsp;BA~,&nbsp;... the cyclic permutations with offset&nbsp;1 thereof (in the case of more than 2 copies per chunk there would be (AA~)~,&nbsp;... as well as ((AA~)~)~,&nbsp;... and so on).</p>
<p class='spacer'>

  <p>This should give similar read characteristics to "far" if a suitably large chunk size is used, but without as much seeking for writes.</p>
    </dd>
  </dl>
<p class='spacer'>

<p>It should be noted that the number of devices in a RAID10 array need not be a multiple of the number of replica of each data block; however, there must be at least as many devices as replicas.</p>
<p class='spacer'>

<p>If, for example, an array is created with 5 devices and 2 replicas, then space equivalent to 2.5 of the devices will be available, and every block will be stored on two different devices.</p>
<p class='spacer'>

<p>Finally, it is possible to have an array with both "near" and "far" copies.  If an array is configured with 2 near copies and 2 far copies, then there will be a total of 4 copies of each block, each on a different drive.  This is an artifact of the implementation and is unlikely to be of real value.</p>
<p class='spacer'>

  <h3>MULTIPATH</h3>
<p class='spacer'>

<p>MULTIPATH is not really a RAID at all as there is only one real device in a MULTIPATH md array.  However there are multiple access points (paths) to this device, and one of these paths might fail, so there are some similarities.</p>
<p class='spacer'>

<p>A MULTIPATH array is composed of a number of logically different devices, often fibre channel interfaces, that all refer the the same real device. If one of these interfaces fails (e.g. due to cable problems), the MULTIPATH driver will attempt to redirect requests to another interface.</p>
<p class='spacer'>

<p>The MULTIPATH drive is not receiving any ongoing development and should be considered a legacy driver.  The device-mapper based multipath drivers should be preferred for new installations.</p>
<p class='spacer'>

  <h3>FAULTY</h3>
<p>The FAULTY md module is provided for testing purposes.  A FAULTY array has exactly one component device and is normally assembled without a superblock, so the md array created provides direct access to all of the data in the component device.</p>
<p class='spacer'>

<p>The FAULTY module may be requested to simulate faults to allow testing of other md levels or of filesystems.  Faults can be chosen to trigger on read requests or write requests, and can be transient (a subsequent read/write at the address will probably succeed) or persistent (subsequent read/write of the same address will fail).  Further, read faults can be "fixable" meaning that they persist until a write request at the same address.</p>
<p class='spacer'>

<p>Fault types can be requested with a period.  In this case, the fault will recur repeatedly after the given number of requests of the relevant type.  For example if persistent read faults have a period of 100, then every 100th read request would generate a fault, and the faulty sector would be recorded so that subsequent reads on that sector would also fail.</p>
<p class='spacer'>

<p>There is a limit to the number of faulty sectors that are remembered. Faults generated after this limit is exhausted are treated as transient.</p>
<p class='spacer'>

<p>The list of faulty sectors can be flushed, and the active list of failure modes can be cleared.</p>
<p class='spacer'>

  <h3>UNCLEAN SHUTDOWN</h3>
<p class='spacer'>

<p>When changes are made to a RAID1, RAID4, RAID5, RAID6, or RAID10 array there is a possibility of inconsistency for short periods of time as each update requires at least two block to be written to different devices, and these writes probably won't happen at exactly the same time.  Thus if a system with one of these arrays is shutdown in the middle of a write operation (e.g. due to power failure), the array may not be consistent.</p>
<p class='spacer'>

<p>To handle this situation, the md driver marks an array as "dirty" before writing any data to it, and marks it as "clean" when the array is being disabled, e.g. at shutdown.  If the md driver finds an array to be dirty at startup, it proceeds to correct any possibly inconsistency.  For RAID1, this involves copying the contents of the first drive onto all other drives.  For RAID4, RAID5 and RAID6 this involves recalculating the parity for each stripe and making sure that the parity block has the correct data.  For RAID10 it involves copying one of the replicas of each block onto all the others.  This process, known as "resynchronising" or "resync" is performed in the background. The array can still be used, though possibly with reduced performance.</p>
<p class='spacer'>

<p>If a RAID4, RAID5 or RAID6 array is degraded (missing at least one drive, two for RAID6) when it is restarted after an unclean shutdown, it cannot recalculate parity, and so it is possible that data might be undetectably corrupted.  The 2.4 md driver <strong>does not</strong> alert the operator to this condition.  The 2.6 md driver will fail to start an array in this condition without manual intervention, though this behaviour can be overridden by a kernel parameter.</p>
<p class='spacer'>

  <h3>RECOVERY</h3>
<p class='spacer'>

<p>If the md driver detects a write error on a device in a RAID1, RAID4, RAID5, RAID6, or RAID10 array, it immediately disables that device (marking it as faulty) and continues operation on the remaining devices.  If there are spare drives, the driver will start recreating on one of the spare drives the data which was on that failed drive, either by copying a working drive in a RAID1 configuration, or by doing calculations with the parity block on RAID4, RAID5 or RAID6, or by finding and copying originals for RAID10.</p>
<p class='spacer'>

<p>In kernels prior to about 2.6.15, a read error would cause the same effect as a write error.  In later kernels, a read-error will instead cause md to attempt a recovery by overwriting the bad block. i.e. it will find the correct data from elsewhere, write it over the block that failed, and then try to read it back again.  If either the write or the re-read fail, md will treat the error the same way that a write error is treated, and will fail the whole device.</p>
<p class='spacer'>

<p>While this recovery process is happening, the md driver will monitor accesses to the array and will slow down the rate of recovery if other activity is happening, so that normal access to the array will not be unduly affected.  When no other activity is happening, the recovery process proceeds at full speed.  The actual speed targets for the two different situations can be controlled by the <strong>speed_limit_min</strong> and <strong>speed_limit_max</strong> control files mentioned below.</p>
<p class='spacer'>

  <h3>SCRUBBING AND MISMATCHES</h3>
<p class='spacer'>

<p>As storage devices can develop bad blocks at any time it is valuable to regularly read all blocks on all devices in an array so as to catch such bad blocks early.  This process is called <em>scrubbing</em>.</p>
<p class='spacer'>

<p>md arrays can be scrubbed by writing either <em>check</em> or <em>repair</em> to the file <em>md/sync_action</em> in the <em>sysfs</em> directory for the device.</p>
<p class='spacer'>

<p>Requesting a scrub will cause <em>md</em> to read every block on every device in the array, and check that the data is consistent.  For RAID1 and RAID10, this means checking that the copies are identical.  For RAID4, RAID5, RAID6 this means checking that the parity block is (or blocks are) correct.</p>
<p class='spacer'>

<p>If a read error is detected during this process, the normal read-error handling causes correct data to be found from other devices and to be written back to the faulty device.  In many case this will effectively <em>fix</em> the bad block.</p>
<p class='spacer'>

<p>If all blocks read successfully but are found to not be consistent, then this is regarded as a <em>mismatch</em>.</p>
<p class='spacer'>

<p>If <em>check</em> was used, then no action is taken to handle the mismatch, it is simply recorded. If <em>repair</em> was used, then a mismatch will be repaired in the same way that <em>resync</em> repairs arrays.  For RAID5/RAID6 new parity blocks are written.  For RAID1/RAID10, all but one block are overwritten with the content of that one block.</p>
<p class='spacer'>

<p>A count of mismatches is recorded in the <em>sysfs</em> file <em>md/mismatch_cnt</em>. This is set to zero when a scrub starts and is incremented whenever a sector is found that is a mismatch. <em>md</em> normally works in units much larger than a single sector and when it finds a mismatch, it does not determine exactly how many actual sectors were affected but simply adds the number of sectors in the IO unit that was used.  So a value of 128 could simply mean that a single 64KB check found an error (128 x 512bytes = 64KB).</p>
<p class='spacer'>

<p>If an array is created by <em>mdadm</em> with <em>--assume-clean</em> then a subsequent check could be expected to find some mismatches.</p>
<p class='spacer'>

<p>On a truly clean RAID5 or RAID6 array, any mismatches should indicate a hardware problem at some level - software issues should never cause such a mismatch.</p>
<p class='spacer'>

<p>However on RAID1 and RAID10 it is possible for software issues to cause a mismatch to be reported.  This does not necessarily mean that the data on the array is corrupted.  It could simply be that the system does not care what is stored on that part of the array - it is unused space.</p>
<p class='spacer'>

<p>The most likely cause for an unexpected mismatch on RAID1 or RAID10 occurs if a swap partition or swap file is stored on the array.</p>
<p class='spacer'>

<p>When the swap subsystem wants to write a page of memory out, it flags the page as 'clean' in the memory manager and requests the swap device to write it out.  It is quite possible that the memory will be changed while the write-out is happening.  In that case the 'clean' flag will be found to be clear when the write completes and so the swap subsystem will simply forget that the swapout had been attempted, and will possibly choose a different page to write out.</p>
<p class='spacer'>

<p>If the swap device was on RAID1 (or RAID10), then the data is sent from memory to a device twice (or more depending on the number of devices in the array).  Thus it is possible that the memory gets changed between the times it is sent, so different data can be written to the different devices in the array.  This will be detected by <em>check</em> as a mismatch.  However it does not reflect any corruption as the block where this mismatch occurs is being treated by the swap system as being empty, and the data will never be read from that block.</p>
<p class='spacer'>

<p>It is conceivable for a similar situation to occur on non-swap files, though it is less likely.</p>
<p class='spacer'>

<p>Thus the <em>mismatch_cnt</em> value can not be interpreted very reliably on RAID1 or RAID10, especially when the device is used for swap.</p>
<p class='spacer'>

  <h3>BITMAP WRITE-INTENT LOGGING</h3>
<p class='spacer'>

<p>From Linux 2.6.13, <em>md</em> supports a bitmap based write-intent log.  If configured, the bitmap is used to record which blocks of the array may be out of sync. Before any write request is honoured, md will make sure that the corresponding bit in the log is set.  After a period of time with no writes to an area of the array, the corresponding bit will be cleared.</p>
<p class='spacer'>

<p>This bitmap is used for two optimisations.</p>
<p class='spacer'>

<p>Firstly, after an unclean shutdown, the resync process will consult the bitmap and only resync those blocks that correspond to bits in the bitmap that are set.  This can dramatically reduce resync time.</p>
<p class='spacer'>

<p>Secondly, when a drive fails and is removed from the array, md stops clearing bits in the intent log.  If that same drive is re-added to the array, md will notice and will only recover the sections of the drive that are covered by bits in the intent log that are set.  This can allow a device to be temporarily removed and reinserted without causing an enormous recovery cost.</p>
<p class='spacer'>

<p>The intent log can be stored in a file on a separate device, or it can be stored near the superblocks of an array which has superblocks.</p>
<p class='spacer'>

<p>It is possible to add an intent log to an active array, or remove an intent log if one is present.</p>
<p class='spacer'>

<p>In 2.6.13, intent bitmaps are only supported with RAID1.  Other levels with redundancy are supported from 2.6.15.</p>
<p class='spacer'>

  <h3>BAD BLOCK LIST</h3>
<p class='spacer'>

<p>From Linux 3.5 each device in an <em>md</em> array can store a list of known-bad-blocks.  This list is 4K in size and usually positioned at the end of the space between the superblock and the data.</p>
<p class='spacer'>

<p>When a block cannot be read and cannot be repaired by writing data recovered from other devices, the address of the block is stored in the bad block list.  Similarly if an attempt to write a block fails, the address will be recorded as a bad block.  If attempting to record the bad block fails, the whole device will be marked faulty.</p>
<p class='spacer'>

<p>Attempting to read from a known bad block will cause a read error. Attempting to write to a known bad block will be ignored if any write errors have been reported by the device.  If there have been no write errors then the data will be written to the known bad block and if that succeeds, the address will be removed from the list.</p>
<p class='spacer'>

<p>This allows an array to fail more gracefully - a few blocks on different devices can be faulty without taking the whole array out of action.</p>
<p class='spacer'>

<p>The list is particularly useful when recovering to a spare.  If a few blocks cannot be read from the other devices, the bulk of the recovery can complete and those few bad blocks will be recorded in the bad block list.</p>
<p class='spacer'>

  <h3>RAID456 WRITE JOURNAL</h3>
<p class='spacer'>

<p>Due to non-atomicity nature of RAID write operations, interruption of write operations (system crash, etc.) to RAID456 array can lead to inconsistent parity and data loss (so called RAID-5 write hole).</p>
<p class='spacer'>

<p>To plug the write hole, from Linux 4.4 (to be confirmed), <em>md</em> supports write ahead journal for RAID456. When the array is created, an additional journal device can be added to the array through <em>write-journal</em> option. The RAID write journal works similar to file system journals. Before writing to the data disks, md persists data AND parity of the stripe to the journal device. After crashes, md searches the journal device for incomplete write operations, and replay them to the data disks.</p>
<p class='spacer'>

<p>When the journal device fails, the RAID array is forced to run in read-only mode.</p>
<p class='spacer'>

  <h3>WRITE-BEHIND</h3>
<p class='spacer'>

<p>From Linux 2.6.14, <em>md</em> supports WRITE-BEHIND on RAID1 arrays.</p>
<p class='spacer'>

<p>This allows certain devices in the array to be flagged as <em>write-mostly</em>. MD will only read from such devices if there is no other option.</p>
<p class='spacer'>

<p>If a write-intent bitmap is also provided, write requests to write-mostly devices will be treated as write-behind requests and md will not wait for writes to those requests to complete before reporting the write as complete to the filesystem.</p>
<p class='spacer'>

<p>This allows for a RAID1 with WRITE-BEHIND to be used to mirror data over a slow link to a remote computer (providing the link isn't too slow).  The extra latency of the remote link will not slow down normal operations, but the remote system will still have a reasonably up-to-date copy of all data.</p>
<p class='spacer'>

  <h3>RESTRIPING</h3>
<p class='spacer'>

<p><em>Restriping</em>, also known as <em>Reshaping</em>, is the processes of re-arranging the data stored in each stripe into a new layout.  This might involve changing the number of devices in the array (so the stripes are wider), changing the chunk size (so stripes are deeper or shallower), or changing the arrangement of data and parity (possibly changing the RAID level, e.g. 1 to 5 or 5 to 6).</p>
<p class='spacer'>

<p>As of Linux 2.6.35, md can reshape a RAID4, RAID5, or RAID6 array to have a different number of devices (more or fewer) and to have a different layout or chunk size.  It can also convert between these different RAID levels.  It can also convert between RAID0 and RAID10, and between RAID0 and RAID4 or RAID5. Other possibilities may follow in future kernels.</p>
<p class='spacer'>

<p>During any stripe process there is a 'critical section' during which live data is being overwritten on disk.  For the operation of increasing the number of drives in a RAID5, this critical section covers the first few stripes (the number being the product of the old and new number of devices).  After this critical section is passed, data is only written to areas of the array which no longer hold live data &ndash; the live data has already been located away.</p>
<p class='spacer'>

<p>For a reshape which reduces the number of devices, the 'critical section' is at the end of the reshape process.</p>
<p class='spacer'>

<p>md is not able to ensure data preservation if there is a crash (e.g. power failure) during the critical section.  If md is asked to start an array which failed during a critical section of restriping, it will fail to start the array.</p>
<p class='spacer'>

  <p>To deal with this possibility, a user-space program must</p>
  <dl class='dl-horizontal'>
    <dt>&bull;</dt>
    <dd>
  <p>Disable writes to that section of the array (using the <strong>sysfs</strong> interface),</p>
    </dd>
    <dt>&bull;</dt>
    <dd>
  <p>take a copy of the data somewhere (i.e. make a backup),</p>
    </dd>
    <dt>&bull;</dt>
    <dd>
  <p>allow the process to continue and invalidate the backup and restore write access once the critical section is passed, and</p>
    </dd>
    <dt>&bull;</dt>
    <dd>
  <p>provide for restoring the critical data before restarting the array after a system crash.</p>
    </dd>
  </dl>
<p class='spacer'>

<p><strong>mdadm</strong> versions from 2.4 do this for growing a RAID5 array.</p>
<p class='spacer'>

<p>For operations that do not change the size of the array, like simply increasing chunk size, or converting RAID5 to RAID6 with one extra device, the entire process is the critical section.  In this case, the restripe will need to progress in stages, as a section is suspended, backed up, restriped, and released.</p>
<p class='spacer'>

  <h3>SYSFS INTERFACE</h3>
<p>Each block device appears as a directory in <em>sysfs</em> (which is usually mounted at <strong>/sys</strong>). For MD devices, this directory will contain a subdirectory called <strong>md</strong> which contains various files for providing access to information about the array.</p>
<p class='spacer'>

<p>This interface is documented more fully in the file <strong>Documentation/md.txt</strong> which is distributed with the kernel sources.  That file should be consulted for full documentation.  The following are just a selection of attribute files that are available.</p>
<p class='spacer'>

  <dl class='dl-vertical'>
    <dt><strong>md/sync_speed_min</strong></dt>
    <dd>
  <p>This value, if set, overrides the system-wide setting in <strong>/proc/sys/dev/raid/speed_limit_min</strong> for this array only. Writing the value <strong>system</strong> to this file will cause the system-wide setting to have effect.</p>
<p class='spacer'>

    </dd>
    <dt><strong>md/sync_speed_max</strong></dt>
    <dd>
  <p>This is the partner of <strong>md/sync_speed_min</strong> and overrides <strong>/proc/sys/dev/raid/speed_limit_max</strong> described below.</p>
<p class='spacer'>

    </dd>
    <dt><strong>md/sync_action</strong></dt>
    <dd>
  <p>This can be used to monitor and control the resync/recovery process of MD. In particular, writing "check" here will cause the array to read all data block and check that they are consistent (e.g. parity is correct, or all mirror replicas are the same).  Any discrepancies found are <strong>NOT</strong> corrected.</p>
<p class='spacer'>

  <p>A count of problems found will be stored in <strong>md/mismatch_count</strong>.</p>
<p class='spacer'>

  <p>Alternately, "repair" can be written which will cause the same check to be performed, but any errors will be corrected.</p>
<p class='spacer'>

  <p>Finally, "idle" can be written to stop the check/repair process.</p>
<p class='spacer'>

    </dd>
    <dt><strong>md/stripe_cache_size</strong></dt>
    <dd>
  <p>This is only available on RAID5 and RAID6.  It records the size (in pages per device) of the  stripe cache which is used for synchronising all write operations to the array and all read operations if the array is degraded.  The default is 256.  Valid values are 17 to 32768. Increasing this number can increase performance in some situations, at some cost in system memory.  Note, setting this value too high can result in an "out of memory" condition for the system.</p>
<p class='spacer'>

  <p>memory_consumed = system_page_size * nr_disks * stripe_cache_size</p>
<p class='spacer'>

    </dd>
    <dt><strong>md/preread_bypass_threshold</strong></dt>
    <dd>
  <p>This is only available on RAID5 and RAID6.  This variable sets the number of times MD will service a full-stripe-write before servicing a stripe that requires some "prereading".  For fairness this defaults to 1.  Valid values are 0 to stripe_cache_size.  Setting this to 0 maximizes sequential-write throughput at the cost of fairness to threads doing small or random writes.</p>
<p class='spacer'>

    </dd>
  </dl>
  <h3>KERNEL PARAMETERS</h3>
<p class='spacer'>

  <p>The md driver recognised several different kernel parameters.</p>
  <dl class='dl-vertical'>
    <dt><strong>raid=noautodetect</strong></dt>
    <dd>
  <p>This will disable the normal detection of md arrays that happens at boot time.  If a drive is partitioned with MS-DOS style partitions, then if any of the 4 main partitions has a partition type of 0xFD, then that partition will normally be inspected to see if it is part of an MD array, and if any full arrays are found, they are started.  This kernel parameter disables this behaviour.</p>
<p class='spacer'>

    </dd>
    <dt><strong>raid=partitionable</strong></dt>
    <dd>
    </dd>
    <dt><strong>raid=part</strong></dt>
    <dd>
  <p>These are available in 2.6 and later kernels only.  They indicate that autodetected MD arrays should be created as partitionable arrays, with a different major device number to the original non-partitionable md arrays.  The device number is listed as <em>mdp</em> in <em>/proc/devices</em>.</p>
<p class='spacer'>

    </dd>
    <dt><strong>md_mod.start_ro=1</strong></dt>
    <dd>
    </dd>
    <dt><strong>/sys/module/md_mod/parameters/start_ro</strong></dt>
    <dd>
  <p>This tells md to start all arrays in read-only mode.  This is a soft read-only that will automatically switch to read-write on the first write request.  However until that write request, nothing is written to any device by md, and in particular, no resync or recovery operation is started.</p>
<p class='spacer'>

    </dd>
    <dt><strong>md_mod.start_dirty_degraded=1</strong></dt>
    <dd>
    </dd>
    <dt><strong>/sys/module/md_mod/parameters/start_dirty_degraded</strong></dt>
    <dd>
  <p>As mentioned above, md will not normally start a RAID4, RAID5, or RAID6 that is both dirty and degraded as this situation can imply hidden data loss.  This can be awkward if the root filesystem is affected.  Using this module parameter allows such arrays to be started at boot time.  It should be understood that there is a real (though small) risk of data corruption in this situation.</p>
<p class='spacer'>

    </dd>
    <dt><strong>md=</strong><em>n</em><strong>,</strong><em>dev</em><strong>,</strong><em>dev</em><strong>,...</strong></dt>
    <dd>
    </dd>
    <dt><strong>md=d</strong><em>n</em><strong>,</strong><em>dev</em><strong>,</strong><em>dev</em><strong>,...</strong></dt>
    <dd>
  <p>This tells the md driver to assemble <strong>/dev/md n</strong> from the listed devices.  It is only necessary to start the device holding the root filesystem this way.  Other arrays are best started once the system is booted.</p>
<p class='spacer'>

  <p>In 2.6 kernels, the <strong>d</strong> immediately after the <strong>=</strong> indicates that a partitionable device (e.g. <strong>/dev/md/d0</strong>) should be created rather than the original non-partitionable device.</p>
<p class='spacer'>

    </dd>
    <dt><strong>md=</strong><em>n</em><strong>,</strong><em>l</em><strong>,</strong><em>c</em><strong>,</strong><em>i</em><strong>,</strong><em>dev...</em></dt>
    <dd>
  <p>This tells the md driver to assemble a legacy RAID0 or LINEAR array without a superblock. <em>n</em> gives the md device number, <em>l</em> gives the level, 0 for RAID0 or -1 for LINEAR, <em>c</em> gives the chunk size as a base-2 logarithm offset by twelve, so 0 means 4K, 1 means 8K. <em>i</em> is ignored (legacy support).</p>
<p class='spacer'>

    </dd>
  </dl>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

  <dl class='dl-vertical'>
    <dt><strong>/proc/mdstat</strong></dt>
    <dd>
  <p>Contains information about the status of currently running array.</p>
    </dd>
    <dt><strong>/proc/sys/dev/raid/speed_limit_min</strong></dt>
    <dd>
  <p>A readable and writable file that reflects the current "goal" rebuild speed for times when non-rebuild activity is current on an array. The speed is in Kibibytes per second, and is a per-device rate, not a per-array rate (which means that an array with more disks will shuffle more data for a given speed).   The default is 1000.</p>
<p class='spacer'>

    </dd>
    <dt><strong>/proc/sys/dev/raid/speed_limit_max</strong></dt>
    <dd>
  <p>A readable and writable file that reflects the current "goal" rebuild speed for times when no non-rebuild activity is current on an array. The default is 200,000.</p>
<p class='spacer'>

    </dd>
  </dl>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEE ALSO</h2>
        <div class="sectioncontent">

<p><strong>mdadm</strong>(8),</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="lp.4.html"><span aria-hidden="true">&larr;</span> lp.4: line printer devices</a></li>
   <li class="next"><a href="mem.4.html">mem.4: system memory, kernel memory and system ports <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

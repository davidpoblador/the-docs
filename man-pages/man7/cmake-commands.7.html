<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cmake-commands: Cmake language command reference</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Cmake language command reference">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="cmake-commands (7) manual">
  <meta name="twitter:description" content="Cmake language command reference">
  <meta name="twitter:image" content="https://www.carta.tech/images/cmake-data-cmake-commands-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/cmake-commands.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="cmake-commands (7) manual" />
  <meta property="og:description" content="Cmake language command reference" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/cmake-data-cmake-commands-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">cmake-commands<small> (7)</small></h1>
        <p class="lead">Cmake language command reference</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/cmake-commands.7.html">
      <span itemprop="name">cmake-commands: Cmake language command reference</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/cmake-data/">
      <span itemprop="name">cmake-data</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/cmake-commands.7.html">
      <span itemprop="name">cmake-commands: Cmake language command reference</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">NORMAL COMMANDS</h2>
        <div class="sectioncontent">
<p>These commands may be used freely in CMake projects.</p><h3>add_compile_options</h3>
<p>Adds options to the compilation of source files.</p>
<pre>
add_compile_options(&lt;option&gt; ...)
</pre>
<p>Adds options to the compiler command line for sources in the current directory and below.  This command can be used to add any options, but alternative commands exist to add preprocessor definitions (<strong>target_compile_definitions()</strong> and <strong>add_definitions()</strong>) or include directories (<strong>target_include_directories()</strong> and <strong>include_directories()</strong>).  See documentation of the <strong>directory</strong> and :prop_tgt:\(ga target &lt;COMPILE_OPTIONS&gt;\(ga <strong>COMPILE_OPTIONS</strong> properties.</p><p>Arguments to <strong>add_compile_options</strong> may use "generator expressions" with the syntax <strong>$&lt;...&gt;</strong>.  See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions.  See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p>
<h3>add_custom_command</h3>
<p>Add a custom build rule to the generated build system.</p><p>There are two main signatures for add_custom_command The first signature is for adding a custom command to produce an output.</p>
<pre>
add_custom_command(OUTPUT output1 [output2 ...]
                   COMMAND command1 [ARGS] [args1...]
                   [COMMAND command2 [ARGS] [args2...] ...]
                   [MAIN_DEPENDENCY depend]
                   [DEPENDS [depends...]]
                   [IMPLICIT_DEPENDS &lt;lang1&gt; depend1
                                    [&lt;lang2&gt; depend2] ...]
                   [WORKING_DIRECTORY dir]
                   [COMMENT comment] [VERBATIM] [APPEND])
</pre>
<p>This defines a command to generate specified OUTPUT file(s).  A target created in the same directory (CMakeLists.txt file) that specifies any output of the custom command as a source file is given a rule to generate the file using the command at build time.  Do not list the output in more than one independent target that may build in parallel or the two instances of the rule may conflict (instead use add_custom_target to drive the command and make the other targets depend on that one).  If an output name is a relative path it will be interpreted relative to the build tree directory corresponding to the current source directory.  Note that MAIN_DEPENDENCY is completely optional and is used as a suggestion to visual studio about where to hang the custom command.  In makefile terms this creates a new target in the following form:</p>
<pre>
OUTPUT: MAIN_DEPENDENCY DEPENDS
        COMMAND
</pre>
<p>If more than one command is specified they will be executed in order. The optional ARGS argument is for backward compatibility and will be ignored.</p><p>The second signature adds a custom command to a target such as a library or executable.  This is useful for performing an operation before or after building the target.  The command becomes part of the target and will only execute when the target itself is built.  If the target is already built, the command will not execute.</p>
<pre>
add_custom_command(TARGET target
                   PRE_BUILD | PRE_LINK | POST_BUILD
                   COMMAND command1 [ARGS] [args1...]
                   [COMMAND command2 [ARGS] [args2...] ...]
                   [WORKING_DIRECTORY dir]
                   [COMMENT comment] [VERBATIM])
</pre>
<p>This defines a new command that will be associated with building the specified target.  When the command will happen is determined by which of the following is specified:</p>
<pre>
PRE_BUILD - run before all other dependencies
PRE_LINK - run after other dependencies
POST_BUILD - run after the target has been built
</pre>
<p>Note that the PRE_BUILD option is only supported on Visual Studio 7 or later.  For all other generators PRE_BUILD will be treated as PRE_LINK.</p><p>If WORKING_DIRECTORY is specified the command will be executed in the directory given.  If it is a relative path it will be interpreted relative to the build tree directory corresponding to the current source directory.  If COMMENT is set, the value will be displayed as a message before the commands are executed at build time.  If APPEND is specified the COMMAND and DEPENDS option values are appended to the custom command for the first output specified.  There must have already been a previous call to this command with the same output. The COMMENT, WORKING_DIRECTORY, and MAIN_DEPENDENCY options are currently ignored when APPEND is given, but may be used in the future.</p><p>If VERBATIM is given then all arguments to the commands will be escaped properly for the build tool so that the invoked command receives each argument unchanged.  Note that one level of escapes is still used by the CMake language processor before add_custom_command even sees the arguments.  Use of VERBATIM is recommended as it enables correct behavior.  When VERBATIM is not given the behavior is platform specific because there is no protection of tool-specific special characters.</p><p>If the output of the custom command is not actually created as a file on disk it should be marked as SYMBOLIC with SET_SOURCE_FILES_PROPERTIES.</p><p>The IMPLICIT_DEPENDS option requests scanning of implicit dependencies of an input file.  The language given specifies the programming language whose corresponding dependency scanner should be used. Currently only C and CXX language scanners are supported.  The language has to be specified for every file in the IMPLICIT_DEPENDS list.  Dependencies discovered from the scanning are added to those of the custom command at build time.  Note that the IMPLICIT_DEPENDS option is currently supported only for Makefile generators and will be ignored by other generators.</p><p>If COMMAND specifies an executable target (created by ADD_EXECUTABLE) it will automatically be replaced by the location of the executable created at build time.  Additionally a target-level dependency will be added so that the executable target will be built before any target using this custom command.  However this does NOT add a file-level dependency that would cause the custom command to re-run whenever the executable is recompiled.</p><p>Arguments to COMMAND may use "generator expressions" with the syntax <strong>$&lt;...&gt;</strong>.  See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions.</p><p>Note that tgt is not added as a dependency of the target this expression is evaluated on.</p>
<pre>
$&lt;TARGET_POLICY:pol&gt;          = &apos;1&apos; if the policy was NEW when the &apos;head&apos; target was created, else &apos;0&apos;.  If the policy was not set, the warning message for the policy will be emitted.  This generator expression only works for a subset of policies.
$&lt;INSTALL_PREFIX&gt;         = Content of the install prefix when the target is exported via INSTALL(EXPORT) and empty otherwise.
</pre>
<p>Boolean expressions:</p>
<pre>
$&lt;AND:?[,?]...&gt;           = &apos;1&apos; if all &apos;?&apos; are &apos;1&apos;, else &apos;0&apos;
$&lt;OR:?[,?]...&gt;            = &apos;0&apos; if all &apos;?&apos; are &apos;0&apos;, else &apos;1&apos;
$&lt;NOT:?&gt;                  = &apos;0&apos; if &apos;?&apos; is &apos;1&apos;, else &apos;1&apos;
</pre>
<p>where &apos;?&apos; is always either &apos;0&apos; or &apos;1&apos;.</p><p>Expressions with an implicit &apos;this&apos; target:</p>
<pre>
$&lt;TARGET_PROPERTY:prop&gt;   = The value of the property prop on the target on which the generator expression is evaluated.
</pre>
<p>References to target names in generator expressions imply target-level dependencies, but NOT file-level dependencies.  List target names with the DEPENDS option to add file dependencies.</p><p>The DEPENDS option specifies files on which the command depends.  If any dependency is an OUTPUT of another custom command in the same directory (CMakeLists.txt file) CMake automatically brings the other custom command into the target in which this command is built.  If DEPENDS is not specified the command will run whenever the OUTPUT is missing; if the command does not actually create the OUTPUT then the rule will always run.  If DEPENDS specifies any target (created by an ADD_* command) a target-level dependency is created to make sure the target is built before any target using this custom command. Additionally, if the target is an executable or library a file-level dependency is created to cause the custom command to re-run whenever the target is recompiled.</p>
<h3>add_custom_target</h3>
<p>Add a target with no output so it will always be built.</p>
<pre>
add_custom_target(Name [ALL] [command1 [args1...]]
                  [COMMAND command2 [args2...] ...]
                  [DEPENDS depend depend depend ... ]
                  [WORKING_DIRECTORY dir]
                  [COMMENT comment] [VERBATIM]
                  [SOURCES src1 [src2...]])
</pre>
<p>Adds a target with the given name that executes the given commands. The target has no output file and is ALWAYS CONSIDERED OUT OF DATE even if the commands try to create a file with the name of the target. Use ADD_CUSTOM_COMMAND to generate a file with dependencies.  By default nothing depends on the custom target.  Use ADD_DEPENDENCIES to add dependencies to or from other targets.  If the ALL option is specified it indicates that this target should be added to the default build target so that it will be run every time (the command cannot be called ALL).  The command and arguments are optional and if not specified an empty target will be created.  If WORKING_DIRECTORY is set, then the command will be run in that directory.  If it is a relative path it will be interpreted relative to the build tree directory corresponding to the current source directory.  If COMMENT is set, the value will be displayed as a message before the commands are executed at build time.  Dependencies listed with the DEPENDS argument may reference files and outputs of custom commands created with add_custom_command() in the same directory (CMakeLists.txt file).</p><p>If VERBATIM is given then all arguments to the commands will be escaped properly for the build tool so that the invoked command receives each argument unchanged.  Note that one level of escapes is still used by the CMake language processor before add_custom_target even sees the arguments.  Use of VERBATIM is recommended as it enables correct behavior.  When VERBATIM is not given the behavior is platform specific because there is no protection of tool-specific special characters.</p><p>The SOURCES option specifies additional source files to be included in the custom target.  Specified source files will be added to IDE project files for convenience in editing even if they have not build rules.</p>
<h3>add_definitions</h3>
<p>Adds -D define flags to the compilation of source files.</p>
<pre>
add_definitions(-DFOO -DBAR ...)
</pre>
<p>Adds definitions to the compiler command line for sources in the current directory and below.  This command can be used to add any flags, but it is intended to add preprocessor definitions.  Flags beginning in -D or /D that look like preprocessor definitions are automatically added to the <strong>COMPILE_DEFINITIONS</strong> directory property for the current directory.  Definitions with non-trivial values may be left in the set of flags instead of being converted for reasons of backwards compatibility.  See documentation of the <strong>directory</strong>, <strong>target</strong>, <strong>source file</strong> <strong>COMPILE_DEFINITIONS</strong> properties for details on adding preprocessor definitions to specific scopes and configurations.</p><p>See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p>
<h3>add_dependencies</h3>
<p>Add a dependency between top-level targets.</p>
<pre>
add_dependencies(&lt;target&gt; [&lt;target-dependency&gt;]...)
</pre>
<p>Make a top-level &lt;target&gt; depend on other top-level targets to ensure that they build before &lt;target&gt; does.  A top-level target is one created by ADD_EXECUTABLE, ADD_LIBRARY, or ADD_CUSTOM_TARGET. Dependencies added to an IMPORTED target are followed transitively in its place since the target itself does not build.</p><p>See the DEPENDS option of ADD_CUSTOM_TARGET and ADD_CUSTOM_COMMAND for adding file-level dependencies in custom rules.  See the OBJECT_DEPENDS option in SET_SOURCE_FILES_PROPERTIES to add file-level dependencies to object files.</p>
<h3>add_executable</h3>
<p>Add an executable to the project using the specified source files.</p>
<pre>
add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]
               [EXCLUDE_FROM_ALL]
               source1 [source2 ...])
</pre>
<p>Adds an executable target called <strong>&lt;name&gt;</strong> to be built from the source files listed in the command invocation.  The <strong>&lt;name&gt;</strong> corresponds to the logical target name and must be globally unique within a project.  The actual file name of the executable built is constructed based on conventions of the native platform (such as <strong>&lt;name&gt;.exe</strong> or just <strong>&lt;name&gt;</strong>.</p><p>By default the executable file will be created in the build tree directory corresponding to the source tree directory in which the command was invoked.  See documentation of the <strong>RUNTIME_OUTPUT_DIRECTORY</strong> target property to change this location.  See documentation of the <strong>OUTPUT_NAME</strong> target property to change the <strong>&lt;name&gt;</strong> part of the final file name.</p><p>If <strong>WIN32</strong> is given the property <strong>WIN32_EXECUTABLE</strong> will be set on the target created.  See documentation of that target property for details.</p><p>If <strong>MACOSX_BUNDLE</strong> is given the corresponding property will be set on the created target.  See documentation of the <strong>MACOSX_BUNDLE</strong> target property for details.</p><p>If <strong>EXCLUDE_FROM_ALL</strong> is given the corresponding property will be set on the created target.  See documentation of the <strong>EXCLUDE_FROM_ALL</strong> target property for details.</p><p>See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p><p>----</p>
<pre>
add_executable(&lt;name&gt; IMPORTED [GLOBAL])
</pre>
<p>An <em>IMPORTED executable target</em> references an executable file located outside the project.  No rules are generated to build it, and the <strong>IMPORTED</strong> target property is <strong>True</strong>.  The target name has scope in the directory in which it is created and below, but the <strong>GLOBAL</strong> option extends visibility.  It may be referenced like any target built within the project.  <strong>IMPORTED</strong> executables are useful for convenient reference from commands like <strong>add_custom_command()</strong>. Details about the imported executable are specified by setting properties whose names begin in <strong>IMPORTED_</strong>.  The most important such property is <strong>IMPORTED_LOCATION</strong> (and its per-configuration version <strong>IMPORTED_LOCATION_&lt;CONFIG&gt;</strong>) which specifies the location of the main executable file on disk.  See documentation of the <strong>IMPORTED_*</strong> properties for more information.</p><p>----</p>
<pre>
add_executable(&lt;name&gt; ALIAS &lt;target&gt;)
</pre>
<p>Creates an <em>Alias Target</em>, such that <strong>&lt;name&gt;</strong> can be used to refer to <strong>&lt;target&gt;</strong> in subsequent commands.  The <strong>&lt;name&gt;</strong> does not appear in the generated buildsystem as a make target.  The <strong>&lt;target&gt;</strong> may not be an <em>Imported Target</em> or an <strong>ALIAS</strong>.  <strong>ALIAS</strong> targets can be used as targets to read properties from, executables for custom commands and custom targets.  They can also be tested for existance with the regular <strong>if(TARGET)</strong> subcommand. The <strong>&lt;name&gt;</strong> may not be used to modify properties of <strong>&lt;target&gt;</strong>, that is, it may not be used as the operand of <strong>set_property()</strong>, <strong>set_target_properties()</strong>, <strong>target_link_libraries()</strong> etc. An <strong>ALIAS</strong> target may not be installed or exported.</p>
<h3>add_library</h3>
<p>Add a library to the project using the specified source files.</p>
<pre>
add_library(&lt;name&gt; [STATIC | SHARED | MODULE]
            [EXCLUDE_FROM_ALL]
            source1 [source2 ...])
</pre>
<p>Adds a library target called <strong>&lt;name&gt;</strong> to be built from the source files listed in the command invocation.  The <strong>&lt;name&gt;</strong> corresponds to the logical target name and must be globally unique within a project.  The actual file name of the library built is constructed based on conventions of the native platform (such as <strong>lib&lt;name&gt;.a</strong> or <strong>&lt;name&gt;.lib</strong>).</p><p><strong>STATIC</strong>, <strong>SHARED</strong>, or <strong>MODULE</strong> may be given to specify the type of library to be created.  <strong>STATIC</strong> libraries are archives of object files for use when linking other targets.  <strong>SHARED</strong> libraries are linked dynamically and loaded at runtime.  <strong>MODULE</strong> libraries are plugins that are not linked into other targets but may be loaded dynamically at runtime using dlopen-like functionality.  If no type is given explicitly the type is <strong>STATIC</strong> or <strong>SHARED</strong> based on whether the current value of the variable <strong>BUILD_SHARED_LIBS</strong> is <strong>ON</strong>.  For <strong>SHARED</strong> and <strong>MODULE</strong> libraries the <strong>POSITION_INDEPENDENT_CODE</strong> target property is set to <strong>ON</strong> automatically.</p><p>By default the library file will be created in the build tree directory corresponding to the source tree directory in which thecommand was invoked.  See documentation of the <strong>ARCHIVE_OUTPUT_DIRECTORY</strong>, <strong>LIBRARY_OUTPUT_DIRECTORY</strong>, and <strong>RUNTIME_OUTPUT_DIRECTORY</strong> target properties to change this location.  See documentation of the <strong>OUTPUT_NAME</strong> target property to change the <strong>&lt;name&gt;</strong> part of the final file name.</p><p>If <strong>EXCLUDE_FROM_ALL</strong> is given the corresponding property will be set on the created target.  See documentation of the <strong>EXCLUDE_FROM_ALL</strong> target property for details.</p><p>See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p><p>----</p>
<pre>
add_library(&lt;name&gt; &lt;SHARED|STATIC|MODULE|UNKNOWN&gt; IMPORTED
            [GLOBAL])
</pre>
<p>An <em>IMPORTED library target</em> references a library file located outside the project.  No rules are generated to build it, and the <strong>IMPORTED</strong> target property is <strong>True</strong>.  The target name has scope in the directory in which it is created and below, but the <strong>GLOBAL</strong> option extends visibility.  It may be referenced like any target built within the project.  <strong>IMPORTED</strong> libraries are useful for convenient reference from commands like <strong>target_link_libraries()</strong>.  Details about the imported library are specified by setting properties whose names begin in <strong>IMPORTED_</strong> and <strong>INTERFACE_</strong>.  The most important such property is <strong>IMPORTED_LOCATION</strong> (and its per-configuration variant <strong>IMPORTED_LOCATION_&lt;CONFIG&gt;</strong>) which specifies the location of the main library file on disk.  See documentation of the <strong>IMPORTED_*</strong> and <strong>INTERFACE_*</strong> properties for more information.</p><p>----</p>
<pre>
add_library(&lt;name&gt; OBJECT &lt;src&gt;...)
</pre>
<p>Creates a special "object library" target.  An object library compiles source files but does not archive or link their object files into a library.  Instead other targets created by <strong>add_library()</strong> or <strong>add_executable()</strong> may reference the objects using an expression of the form <strong>$&lt;TARGET_OBJECTS:objlib&gt;</strong> as a source, where <strong>objlib</strong> is the object library name.  For example:</p>
<pre>
add_library(... $&lt;TARGET_OBJECTS:objlib&gt; ...)
add_executable(... $&lt;TARGET_OBJECTS:objlib&gt; ...)
</pre>
<p>will include objlib&apos;s object files in a library and an executable along with those compiled from their own sources.  Object libraries may contain only sources (and headers) that compile to object files. They may contain custom commands generating such sources, but not <strong>PRE_BUILD</strong>, <strong>PRE_LINK</strong>, or <strong>POST_BUILD</strong> commands.  Object libraries cannot be imported, exported, installed, or linked.  Some native build systems may not like targets that have only object files, so consider adding at least one real source file to any target that references <strong>$&lt;TARGET_OBJECTS:objlib&gt;</strong>.</p><p>----</p>
<pre>
add_library(&lt;name&gt; ALIAS &lt;target&gt;)
</pre>
<p>Creates an <em>Alias Target</em>, such that <strong>&lt;name&gt;</strong> can be used to refer to <strong>&lt;target&gt;</strong> in subsequent commands.  The <strong>&lt;name&gt;</strong> does not appear in the generatedbuildsystem as a make target.  The <strong>&lt;target&gt;</strong> may not be an <em>Imported Target</em> or an <strong>ALIAS</strong>. <strong>ALIAS</strong> targets can be used as linkable targets and as targets to read properties from.  They can also be tested for existance with the regular <strong>if(TARGET)</strong> subcommand.  The <strong>&lt;name&gt;</strong> may not be used to modify properties of <strong>&lt;target&gt;</strong>, that is, it may not be used as the operand of <strong>set_property()</strong>, <strong>set_target_properties()</strong>, <strong>target_link_libraries()</strong> etc.  An <strong>ALIAS</strong> target may not be installed or exported.</p><p>----</p>
<pre>
add_library(&lt;name&gt; INTERFACE [IMPORTED [GLOBAL]])
</pre>
<p>Creates an <em>Interface Library</em>.  An <strong>INTERFACE</strong> library target does not directly create build output, though it may have properties set on it and it may be installed, exported and imported. Typically the <strong>INTERFACE_*</strong> properties are populated on the interface target using the <strong>set_property()</strong>, <strong>target_link_libraries(INTERFACE)</strong>, <strong>target_include_directories(INTERFACE)</strong>, <strong>target_compile_options(INTERFACE)</strong> and <strong>target_compile_definitions(INTERFACE)</strong> commands, and then it is used as an argument to <strong>target_link_libraries()</strong> like any other target.</p><p>An <strong>INTERFACE</strong> <em>Imported Target</em> may also be created with this signature.  An <strong>IMPORTED</strong> library target references a library defined outside the project.  The target name has scope in the directory in which it is created and below, but the <strong>GLOBAL</strong> option extends visibility.  It may be referenced like any target built within the project.  <strong>IMPORTED</strong> libraries are useful for convenient reference from commands like <strong>target_link_libraries()</strong>.</p>
<h3>add_subdirectory</h3>
<p>Add a subdirectory to the build.</p>
<pre>
add_subdirectory(source_dir [binary_dir]
                 [EXCLUDE_FROM_ALL])
</pre>
<p>Add a subdirectory to the build.  The source_dir specifies the directory in which the source CMakeLists.txt and code files are located.  If it is a relative path it will be evaluated with respect to the current directory (the typical usage), but it may also be an absolute path.  The binary_dir specifies the directory in which to place the output files.  If it is a relative path it will be evaluated with respect to the current output directory, but it may also be an absolute path.  If binary_dir is not specified, the value of source_dir, before expanding any relative path, will be used (the typical usage).  The CMakeLists.txt file in the specified source directory will be processed immediately by CMake before processing in the current input file continues beyond this command.</p><p>If the EXCLUDE_FROM_ALL argument is provided then targets in the subdirectory will not be included in the ALL target of the parent directory by default, and will be excluded from IDE project files. Users must explicitly build targets in the subdirectory.  This is meant for use when the subdirectory contains a separate part of the project that is useful but not necessary, such as a set of examples. Typically the subdirectory should contain its own project() command invocation so that a full build system will be generated in the subdirectory (such as a VS IDE solution file).  Note that inter-target dependencies supercede this exclusion.  If a target built by the parent project depends on a target in the subdirectory, the dependee target will be included in the parent project build system to satisfy the dependency.</p>
<h3>add_test</h3>
<p>Add a test to the project to be run by <a href="../man1/ctest.1.html"><strong>ctest</strong>(1)</a></strong>.</p>
<pre>
add_test(NAME &lt;name&gt; COMMAND &lt;command&gt; [&lt;arg&gt;...]
         [CONFIGURATIONS &lt;config&gt;...]
         [WORKING_DIRECTORY &lt;dir&gt;])
</pre>
<p>Add a test called <strong>&lt;name&gt;</strong>.  The test name may not contain spaces, quotes, or other characters special in CMake syntax.  The options are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>COMMAND</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Specify the test command-line.  If <strong>&lt;command&gt;</strong> specifies an executable target (created by <strong>add_executable()</strong>) it will automatically be replaced by the location of the executable created at build time.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>CONFIGURATIONS</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Restrict execution of the test only to the named configurations.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>WORKING_DIRECTORY</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Set the <strong>WORKING_DIRECTORY</strong> test property to specify the working directory in which to execute the test. If not specified the test will be run with the current working directory set to the build directory corresponding to the current source directory.</p><p>The <strong>COMMAND</strong> and <strong>WORKING_DIRECTORY</strong> options may use "generator expressions" with the syntax <strong>$&lt;...&gt;</strong>.  See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions.</p><p>Example usage:</p>
<pre>
add_test(NAME mytest
         COMMAND testDriver --config $&lt;CONFIGURATION&gt;
                            --exe $&lt;TARGET_FILE:myexe&gt;)
</pre>
<p>This creates a test <strong>mytest</strong> whose command runs a <strong>testDriver</strong> tool passing the configuration name and the full path to the executable file produced by target <strong>myexe</strong>.</p><p><strong>NOTE:</strong> CMake will generate tests only if the <strong>enable_testing()</strong> command has been invoked.  The <strong>CTest</strong> module invokes the command automatically when the <strong>BUILD_TESTING</strong> option is <strong>ON</strong>.</p><p>----</p>
<pre>
add_test(&lt;name&gt; &lt;command&gt; [&lt;arg&gt;...])
</pre>
<p>Add a test called <strong>&lt;name&gt;</strong> with the given command-line.  Unlike the above <strong>NAME</strong> signature no transformation is performed on the command-line to support target names or generator expressions.</p>
  </dd>

</dl>

<h3>aux_source_directory</h3>
<p>Find all source files in a directory.</p>
<pre>
aux_source_directory(&lt;dir&gt; &lt;variable&gt;)
</pre>
<p>Collects the names of all the source files in the specified directory and stores the list in the &lt;variable&gt; provided.  This command is intended to be used by projects that use explicit template instantiation.  Template instantiation files can be stored in a "Templates" subdirectory and collected automatically using this command to avoid manually listing all instantiations.</p><p>It is tempting to use this command to avoid writing the list of source files for a library or executable target.  While this seems to work, there is no way for CMake to generate a build system that knows when a new source file has been added.  Normally the generated build system knows when it needs to rerun CMake because the CMakeLists.txt file is modified to add a new source.  When the source is just added to the directory without modifying this file, one would have to manually rerun CMake to generate a build system incorporating the new file.</p>
<h3>break</h3>
<p>Break from an enclosing foreach or while loop.</p>
<pre>
break()
</pre>
<p>Breaks from an enclosing foreach loop or while loop</p>
<h3>build_command</h3>
<p>Get a command line to build the current project. This is mainly intended for internal use by the <strong>CTest</strong> module.</p>
<pre>
build_command(&lt;variable&gt;
              [CONFIGURATION &lt;config&gt;]
              [TARGET &lt;target&gt;]
              [PROJECT_NAME &lt;projname&gt;] # legacy, causes warning
             )
</pre>
<p>Sets the given <strong>&lt;variable&gt;</strong> to a command-line string of the form:</p>
<pre>
&lt;cmake&gt; --build . [--config &lt;config&gt;] [--target &lt;target&gt;] [-- -i]
</pre>
<p>where <strong>&lt;cmake&gt;</strong> is the location of the <a href="../man1/cmake.1.html"><strong>cmake</strong>(1)</a></strong> command-line tool, and <strong>&lt;config&gt;</strong> and <strong>&lt;target&gt;</strong> are the values provided to the <strong>CONFIGURATION</strong> and <strong>TARGET</strong> options, if any.  The trailing <strong>-- -i</strong> option is added for Makefile generators.</p><p>When invoked, this <strong>cmake --build</strong> command line will launch the underlying build system tool.</p>
<pre>
build_command(&lt;cachevariable&gt; &lt;makecommand&gt;)
</pre>
<p>This second signature is deprecated, but still available for backwards compatibility.  Use the first signature instead.</p><p>It sets the given <strong>&lt;cachevariable&gt;</strong> to a command-line string as above but without the <strong>--config</strong> or <strong>--target</strong> options. The <strong>&lt;makecommand&gt;</strong> is ignored but should be the full path to msdev, devenv, nmake, make or one of the end user build tools for legacy invocations.</p><p><strong>NOTE:</strong> In CMake versions prior to 3.0 this command returned a command line that directly invokes the native build tool for the current generator.  Their implementation of the <strong>PROJECT_NAME</strong> option had no useful effects, so CMake now warns on use of the option.</p>
<h3>cmake_host_system_information</h3>
<p>Query host system specific information.</p>
<pre>
cmake_host_system_information(RESULT &lt;variable&gt; QUERY &lt;key&gt; ...)
</pre>
<p>Queries system information of the host system on which cmake runs. One or more &lt;key&gt; can be provided to select the information to be queried.  The list of queried values is stored in &lt;variable&gt;.</p><p>&lt;key&gt; can be one of the following values:</p>
<pre>
NUMBER_OF_LOGICAL_CORES   = Number of logical cores.
NUMBER_OF_PHYSICAL_CORES  = Number of physical cores.
HOSTNAME                  = Hostname.
FQDN                      = Fully qualified domain name.
TOTAL_VIRTUAL_MEMORY      = Total virtual memory in megabytes.
AVAILABLE_VIRTUAL_MEMORY  = Available virtual memory in megabytes.
TOTAL_PHYSICAL_MEMORY     = Total physical memory in megabytes.
AVAILABLE_PHYSICAL_MEMORY = Available physical memory in megabytes.
</pre>

<h3>cmake_minimum_required</h3>
<p>Set the minimum required version of cmake for a project.</p>
<pre>
cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]]
                       [FATAL_ERROR])
</pre>
<p>If the current version of CMake is lower than that required it will stop processing the project and report an error.  When a version higher than 2.4 is specified the command implicitly invokes</p>
<pre>
cmake_policy(VERSION major[.minor[.patch[.tweak]]])
</pre>
<p>which sets the cmake policy version level to the version specified. When version 2.4 or lower is given the command implicitly invokes</p>
<pre>
cmake_policy(VERSION 2.4)
</pre>
<p>which enables compatibility features for CMake 2.4 and lower.</p><p>The FATAL_ERROR option is accepted but ignored by CMake 2.6 and higher.  It should be specified so CMake versions 2.4 and lower fail with an error instead of just a warning.</p>
<h3>cmake_policy</h3>
<p>Manage CMake Policy settings.</p><p>As CMake evolves it is sometimes necessary to change existing behavior in order to fix bugs or improve implementations of existing features. The CMake Policy mechanism is designed to help keep existing projects building as new versions of CMake introduce changes in behavior.  Each new policy (behavioral change) is given an identifier of the form "CMP&lt;NNNN&gt;" where "&lt;NNNN&gt;" is an integer index.  Documentation associated with each policy describes the OLD and NEW behavior and the reason the policy was introduced.  Projects may set each policy to select the desired behavior.  When CMake needs to know which behavior to use it checks for a setting specified by the project.  If no setting is available the OLD behavior is assumed and a warning is produced requesting that the policy be set.</p><p>The cmake_policy command is used to set policies to OLD or NEW behavior.  While setting policies individually is supported, we encourage projects to set policies based on CMake versions.</p>
<pre>
cmake_policy(VERSION major.minor[.patch[.tweak]])
</pre>
<p>Specify that the current CMake list file is written for the given version of CMake.  All policies introduced in the specified version or earlier will be set to use NEW behavior.  All policies introduced after the specified version will be unset (unless variable CMAKE_POLICY_DEFAULT_CMP&lt;NNNN&gt; sets a default).  This effectively requests behavior preferred as of a given CMake version and tells newer CMake versions to warn about their new policies.  The policy version specified must be at least 2.4 or the command will report an error.  In order to get compatibility features supporting versions earlier than 2.4 see documentation of policy CMP0001.</p>
<pre>
cmake_policy(SET CMP&lt;NNNN&gt; NEW)
cmake_policy(SET CMP&lt;NNNN&gt; OLD)
</pre>
<p>Tell CMake to use the OLD or NEW behavior for a given policy. Projects depending on the old behavior of a given policy may silence a policy warning by setting the policy state to OLD.  Alternatively one may fix the project to work with the new behavior and set the policy state to NEW.</p>
<pre>
cmake_policy(GET CMP&lt;NNNN&gt; &lt;variable&gt;)
</pre>
<p>Check whether a given policy is set to OLD or NEW behavior.  The output variable value will be "OLD" or "NEW" if the policy is set, and empty otherwise.</p><p>CMake keeps policy settings on a stack, so changes made by the cmake_policy command affect only the top of the stack.  A new entry on the policy stack is managed automatically for each subdirectory to protect its parents and siblings.  CMake also manages a new entry for scripts loaded by include() and find_package() commands except when invoked with the NO_POLICY_SCOPE option (see also policy CMP0011). The cmake_policy command provides an interface to manage custom entries on the policy stack:</p>
<pre>
cmake_policy(PUSH)
cmake_policy(POP)
</pre>
<p>Each PUSH must have a matching POP to erase any changes.  This is useful to make temporary changes to policy settings.</p><p>Functions and macros record policy settings when they are created and use the pre-record policies when they are invoked.  If the function or macro implementation sets policies, the changes automatically propagate up through callers until they reach the closest nested policy stack entry.</p>
<h3>configure_file</h3>
<p>Copy a file to another location and modify its contents.</p>
<pre>
configure_file(&lt;input&gt; &lt;output&gt;
               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]
               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])
</pre>
<p>Copies a file &lt;input&gt; to file &lt;output&gt; and substitutes variable values referenced in the file content.  If &lt;input&gt; is a relative path it is evaluated with respect to the current source directory.  The &lt;input&gt; must be a file, not a directory.  If &lt;output&gt; is a relative path it is evaluated with respect to the current binary directory.  If &lt;output&gt; names an existing directory the input file is placed in that directory with its original name.</p><p>If the &lt;input&gt; file is modified the build system will re-run CMake to re-configure the file and generate the build system again.</p><p>This command replaces any variables in the input file referenced as ${VAR} or @VAR@ with their values as determined by CMake.  If a variable is not defined, it will be replaced with nothing.  If COPYONLY is specified, then no variable expansion will take place.  If ESCAPE_QUOTES is specified then any substituted quotes will be C-style escaped.  The file will be configured with the current values of CMake variables.  If @ONLY is specified, only variables of the form @VAR@ will be replaced and ${VAR} will be ignored.  This is useful for configuring scripts that use ${VAR}.</p><p>Input file lines of the form "#cmakedefine VAR ..." will be replaced with either "#define VAR ..." or <strong>/* #undef VAR */</strong> depending on whether VAR is set in CMake to any value not considered a false constant by the if() command.  (Content of "...", if any, is processed as above.) Input file lines of the form "#cmakedefine01 VAR" will be replaced with either "#define VAR 1" or "#define VAR 0" similarly.</p><p>With NEWLINE_STYLE the line ending could be adjusted:</p>
<pre>
&apos;UNIX&apos; or &apos;LF&apos; for &#92;n, &apos;DOS&apos;, &apos;WIN32&apos; or &apos;CRLF&apos; for &#92;r&#92;n.
</pre>
<p>COPYONLY must not be used with NEWLINE_STYLE.</p>
<h3>create_test_sourcelist</h3>
<p>Create a test driver and source list for building test programs.</p>
<pre>
create_test_sourcelist(sourceListName driverName
                       test1 test2 test3
                       EXTRA_INCLUDE include.h
                       FUNCTION function)
</pre>
<p>A test driver is a program that links together many small tests into a single executable.  This is useful when building static executables with large libraries to shrink the total required size.  The list of source files needed to build the test driver will be in sourceListName.  DriverName is the name of the test driver program. The rest of the arguments consist of a list of test source files, can be semicolon separated.  Each test source file should have a function in it that is the same name as the file with no extension (foo.cxx should have int foo(int, char*[]);) DriverName will be able to call each of the tests by name on the command line.  If EXTRA_INCLUDE is specified, then the next argument is included into the generated file. If FUNCTION is specified, then the next argument is taken as a function name that is passed a pointer to ac and av.  This can be used to add extra command line processing to each test.  The cmake variable CMAKE_TESTDRIVER_BEFORE_TESTMAIN can be set to have code that will be placed directly before calling the test main function. CMAKE_TESTDRIVER_AFTER_TESTMAIN can be set to have code that will be placed directly after the call to the test main function.</p>
<h3>define_property</h3>
<p>Define and document custom properties.</p>
<pre>
define_property(&lt;GLOBAL | DIRECTORY | TARGET | SOURCE |
                 TEST | VARIABLE | CACHED_VARIABLE&gt;
                 PROPERTY &lt;name&gt; [INHERITED]
                 BRIEF_DOCS &lt;brief-doc&gt; [docs...]
                 FULL_DOCS &lt;full-doc&gt; [docs...])
</pre>
<p>Define one property in a scope for use with the set_property and get_property commands.  This is primarily useful to associate documentation with property names that may be retrieved with the get_property command.  The first argument determines the kind of scope in which the property should be used.  It must be one of the following:</p>
<pre>
GLOBAL    = associated with the global namespace
DIRECTORY = associated with one directory
TARGET    = associated with one target
SOURCE    = associated with one source file
TEST      = associated with a test named with add_test
VARIABLE  = documents a CMake language variable
CACHED_VARIABLE = documents a CMake cache variable
</pre>
<p>Note that unlike set_property and get_property no actual scope needs to be given; only the kind of scope is important.</p><p>The required PROPERTY option is immediately followed by the name of the property being defined.</p><p>If the INHERITED option then the get_property command will chain up to the next higher scope when the requested property is not set in the scope given to the command.  DIRECTORY scope chains to GLOBAL. TARGET, SOURCE, and TEST chain to DIRECTORY.</p><p>The BRIEF_DOCS and FULL_DOCS options are followed by strings to be associated with the property as its brief and full documentation. Corresponding options to the get_property command will retrieve the documentation.</p>
<h3>elseif</h3>
<p>Starts the elseif portion of an if block.</p>
<pre>
elseif(expression)
</pre>
<p>See the if command.</p>
<h3>else</h3>
<p>Starts the else portion of an if block.</p>
<pre>
else(expression)
</pre>
<p>See the if command.</p>
<h3>enable_language</h3>
<p>Enable a language (CXX/C/Fortran/etc)</p>
<pre>
enable_language(&lt;lang&gt; [OPTIONAL] )
</pre>
<p>This command enables support for the named language in CMake.  This is the same as the project command but does not create any of the extra variables that are created by the project command.  Example languages are CXX, C, Fortran.</p><p>This command must be called in file scope, not in a function call. Furthermore, it must be called in the highest directory common to all targets using the named language directly for compiling sources or indirectly through link dependencies.  It is simplest to enable all needed languages in the top-level directory of a project.</p><p>The OPTIONAL keyword is a placeholder for future implementation and does not currently work.</p>
<h3>enable_testing</h3>
<p>Enable testing for current directory and below.</p>
<pre>
enable_testing()
</pre>
<p>Enables testing for this directory and below.  See also the add_test command.  Note that ctest expects to find a test file in the build directory root.  Therefore, this command should be in the source directory root.</p>
<h3>endforeach</h3>
<p>Ends a list of commands in a FOREACH block.</p>
<pre>
endforeach(expression)
</pre>
<p>See the FOREACH command.</p>
<h3>endfunction</h3>
<p>Ends a list of commands in a function block.</p>
<pre>
endfunction(expression)
</pre>
<p>See the function command.</p>
<h3>endif</h3>
<p>Ends a list of commands in an if block.</p>
<pre>
endif(expression)
</pre>
<p>See the if command.</p>
<h3>endmacro</h3>
<p>Ends a list of commands in a macro block.</p>
<pre>
endmacro(expression)
</pre>
<p>See the macro command.</p>
<h3>endwhile</h3>
<p>Ends a list of commands in a while block.</p>
<pre>
endwhile(expression)
</pre>
<p>See the while command.</p>
<h3>execute_process</h3>
<p>Execute one or more child processes.</p>
<pre>
execute_process(COMMAND &lt;cmd1&gt; [args1...]]
                [COMMAND &lt;cmd2&gt; [args2...] [...]]
                [WORKING_DIRECTORY &lt;directory&gt;]
                [TIMEOUT &lt;seconds&gt;]
                [RESULT_VARIABLE &lt;variable&gt;]
                [OUTPUT_VARIABLE &lt;variable&gt;]
                [ERROR_VARIABLE &lt;variable&gt;]
                [INPUT_FILE &lt;file&gt;]
                [OUTPUT_FILE &lt;file&gt;]
                [ERROR_FILE &lt;file&gt;]
                [OUTPUT_QUIET]
                [ERROR_QUIET]
                [OUTPUT_STRIP_TRAILING_WHITESPACE]
                [ERROR_STRIP_TRAILING_WHITESPACE])
</pre>
<p>Runs the given sequence of one or more commands with the standard output of each process piped to the standard input of the next. A single standard error pipe is used for all processes.</p><p>Options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>COMMAND</strong></p>
  </dt>
  <dd>
    <p>A child process command line.</p><p>CMake executes the child process using operating system APIs directly. All arguments are passed VERBATIM to the child process. No intermediate shell is used, so shell operators such as <strong>&gt;</strong> are treated as normal arguments. (Use the <strong>INPUT_*</strong>, <strong>OUTPUT_*</strong>, and <strong>ERROR_*</strong> options to redirect stdin, stdout, and stderr.)</p>
  </dd>
  <dt>
    <p><strong>WORKING_DIRECTORY</strong></p>
  </dt>
  <dd>
    <p>The named directory will be set as the current working directory of the child processes.</p>
  </dd>
  <dt>
    <p><strong>TIMEOUT</strong></p>
  </dt>
  <dd>
    <p>The child processes will be terminated if they do not finish in the specified number of seconds (fractions are allowed).</p>
  </dd>
  <dt>
    <p><strong>RESULT_VARIABLE</strong></p>
  </dt>
  <dd>
    <p>The variable will be set to contain the result of running the processes. This will be an integer return code from the last child or a string describing an error condition.</p>
  </dd>
  <dt>
    <p><strong>OUTPUT_VARIABLE, ERROR_VARIABLE</strong></p>
  </dt>
  <dd>
    <p>The variable named will be set with the contents of the standard output and standard error pipes, respectively.  If the same variable is named for both pipes their output will be merged in the order produced.</p>
  </dd>
  <dt>
    <p><strong>INPUT_FILE, OUTPUT_FILE, ERROR_FILE</strong></p>
  </dt>
  <dd>
    <p>The file named will be attached to the standard input of the first process, standard output of the last process, or standard error of all processes, respectively.</p>
  </dd>
  <dt>
    <p><strong>OUTPUT_QUIET, ERROR_QUIET</strong></p>
  </dt>
  <dd>
    <p>The standard output or standard error results will be quietly ignored.</p><p>If more than one <strong>OUTPUT_*</strong> or <strong>ERROR_*</strong> option is given for the same pipe the precedence is not specified. If no <strong>OUTPUT_*</strong> or <strong>ERROR_*</strong> options are given the output will be shared with the corresponding pipes of the CMake process itself.</p><p>The <strong>execute_process()</strong> command is a newer more powerful version of <strong>exec_program()</strong>, but the old command has been kept for compatibility. Both commands run while CMake is processing the project prior to build system generation.  Use <strong>add_custom_target()</strong> and <strong>add_custom_command()</strong> to create custom commands that run at build time.</p>
  </dd>

</dl>

<h3>export</h3>
<p>Export targets from the build tree for use by outside projects.</p>
<pre>
export(EXPORT &lt;export-name&gt; [NAMESPACE &lt;namespace&gt;] [FILE &lt;filename&gt;])
</pre>
<p>Create a file &lt;filename&gt; that may be included by outside projects to import targets from the current project&apos;s build tree.  This is useful during cross-compiling to build utility executables that can run on the host platform in one project and then import them into another project being compiled for the target platform.  If the NAMESPACE option is given the &lt;namespace&gt; string will be prepended to all target names written to the file.</p><p>Target installations are associated with the export &lt;export-name&gt; using the <strong>EXPORT</strong> option of the <strong>install(TARGETS)</strong> command.</p><p>The file created by this command is specific to the build tree and should never be installed.  See the install(EXPORT) command to export targets from an installation tree.</p><p>The properties set on the generated IMPORTED targets will have the same values as the final values of the input TARGETS.</p>
<pre>
export(TARGETS [target1 [target2 [...]]] [NAMESPACE &lt;namespace&gt;]
       [APPEND] FILE &lt;filename&gt; [EXPORT_LINK_INTERFACE_LIBRARIES])
</pre>
<p>This signature is similar to the <strong>EXPORT</strong> signature, but targets are listed explicitly rather than specified as an export-name.  If the APPEND option is given the generated code will be appended to the file instead of overwriting it. The EXPORT_LINK_INTERFACE_LIBRARIES keyword, if present, causes the contents of the properties matching <strong>(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)?</strong> to be exported, when policy CMP0022 is NEW.  If a library target is included in the export but a target to which it links is not included the behavior is unspecified.</p>
<pre>
export(PACKAGE &lt;name&gt;)
</pre>
<p>Store the current build directory in the CMake user package registry for package &lt;name&gt;.  The find_package command may consider the directory while searching for package &lt;name&gt;.  This helps dependent projects find and use a package from the current project&apos;s build tree without help from the user.  Note that the entry in the package registry that this command creates works only in conjunction with a package configuration file (&lt;name&gt;Config.cmake) that works with the build tree.</p>
<h3>file</h3>
<p>File manipulation command.</p>
<pre>
file(WRITE filename "message to write"... )
file(APPEND filename "message to write"... )
file(READ filename variable [LIMIT numBytes] [OFFSET offset] [HEX])
file(&lt;MD5|SHA1|SHA224|SHA256|SHA384|SHA512&gt; filename variable)
file(STRINGS filename variable [LIMIT_COUNT num]
     [LIMIT_INPUT numBytes] [LIMIT_OUTPUT numBytes]
     [LENGTH_MINIMUM numBytes] [LENGTH_MAXIMUM numBytes]
     [NEWLINE_CONSUME] [REGEX regex]
     [NO_HEX_CONVERSION])
file(GLOB variable [RELATIVE path] [globbing expressions]...)
file(GLOB_RECURSE variable [RELATIVE path]
     [FOLLOW_SYMLINKS] [globbing expressions]...)
file(RENAME &lt;oldname&gt; &lt;newname&gt;)
file(REMOVE [file1 ...])
file(REMOVE_RECURSE [file1 ...])
file(MAKE_DIRECTORY [directory1 directory2 ...])
file(RELATIVE_PATH variable directory file)
file(TO_CMAKE_PATH path result)
file(TO_NATIVE_PATH path result)
file(DOWNLOAD url file [INACTIVITY_TIMEOUT timeout]
     [TIMEOUT timeout] [STATUS status] [LOG log] [SHOW_PROGRESS]
     [EXPECTED_HASH ALGO=value] [EXPECTED_MD5 sum]
     [TLS_VERIFY on|off] [TLS_CAINFO file])
file(UPLOAD filename url [INACTIVITY_TIMEOUT timeout]
     [TIMEOUT timeout] [STATUS status] [LOG log] [SHOW_PROGRESS])
file(TIMESTAMP filename variable [&lt;format string&gt;] [UTC])
file(GENERATE OUTPUT output_file
     &lt;INPUT input_file|CONTENT input_content&gt;
     [CONDITION expression])
</pre>
<p>WRITE will write a message into a file called &apos;filename&apos;.  It overwrites the file if it already exists, and creates the file if it does not exist.  (If the file is a build input, use configure_file to update the file only when its content changes.)</p><p>APPEND will write a message into a file same as WRITE, except it will append it to the end of the file</p><p>READ will read the content of a file and store it into the variable. It will start at the given offset and read up to numBytes.  If the argument HEX is given, the binary data will be converted to hexadecimal representation and this will be stored in the variable.</p><p>MD5, SHA1, SHA224, SHA256, SHA384, and SHA512 will compute a cryptographic hash of the content of a file.</p><p>STRINGS will parse a list of ASCII strings from a file and store it in a variable.  Binary data in the file are ignored.  Carriage return (CR) characters are ignored.  It works also for Intel Hex and Motorola S-record files, which are automatically converted to binary format when reading them.  Disable this using NO_HEX_CONVERSION.</p><p>LIMIT_COUNT sets the maximum number of strings to return.  LIMIT_INPUT sets the maximum number of bytes to read from the input file. LIMIT_OUTPUT sets the maximum number of bytes to store in the output variable.  LENGTH_MINIMUM sets the minimum length of a string to return.  Shorter strings are ignored.  LENGTH_MAXIMUM sets the maximum length of a string to return.  Longer strings are split into strings no longer than the maximum length.  NEWLINE_CONSUME allows newlines to be included in strings instead of terminating them.</p><p>REGEX specifies a regular expression that a string must match to be returned.  Typical usage</p>
<pre>
file(STRINGS myfile.txt myfile)
</pre>
<p>stores a list in the variable "myfile" in which each item is a line from the input file.</p><p>GLOB will generate a list of all files that match the globbing expressions and store it into the variable.  Globbing expressions are similar to regular expressions, but much simpler.  If RELATIVE flag is specified for an expression, the results will be returned as a relative path to the given path.  (We do not recommend using GLOB to collect a list of source files from your source tree.  If no CMakeLists.txt file changes when a source is added or removed then the generated build system cannot know when to ask CMake to regenerate.)</p><p>Examples of globbing expressions include:</p>
<pre>
*.cxx      - match all files with extension cxx
*.vt?      - match all files with extension vta,...,vtz
f[3-5].txt - match files f3.txt, f4.txt, f5.txt
</pre>
<p>GLOB_RECURSE will generate a list similar to the regular GLOB, except it will traverse all the subdirectories of the matched directory and match the files.  Subdirectories that are symlinks are only traversed if FOLLOW_SYMLINKS is given or cmake policy CMP0009 is not set to NEW. See cmake --help-policy CMP0009 for more information.</p><p>Examples of recursive globbing include:</p>
<pre>
/dir/*.py  - match all python files in /dir and subdirectories
</pre>
<p>MAKE_DIRECTORY will create the given directories, also if their parent directories don&apos;t exist yet</p><p>RENAME moves a file or directory within a filesystem, replacing the destination atomically.</p><p>REMOVE will remove the given files, also in subdirectories</p><p>REMOVE_RECURSE will remove the given files and directories, also non-empty directories</p><p>RELATIVE_PATH will determine relative path from directory to the given file.</p><p>TO_CMAKE_PATH will convert path into a cmake style path with unix /. The input can be a single path or a system path like "$ENV{PATH}". Note the double quotes around the ENV call TO_CMAKE_PATH only takes one argument.  This command will also convert the native list delimiters for a list of paths like the PATH environment variable.</p><p>TO_NATIVE_PATH works just like TO_CMAKE_PATH, but will convert from a cmake style path into the native path style for windows and / for UNIX.</p><p>DOWNLOAD will download the given URL to the given file.  If LOG var is specified a log of the download will be put in var.  If STATUS var is specified the status of the operation will be put in var.  The status is returned in a list of length 2.  The first element is the numeric return value for the operation, and the second element is a string value for the error.  A 0 numeric error means no error in the operation.  If TIMEOUT time is specified, the operation will timeout after time seconds, time should be specified as an integer.  The INACTIVITY_TIMEOUT specifies an integer number of seconds of inactivity after which the operation should terminate.  If EXPECTED_HASH ALGO=value is specified, the operation will verify that the downloaded file&apos;s actual hash matches the expected value, where ALGO is one of MD5, SHA1, SHA224, SHA256, SHA384, or SHA512.  If it does not match, the operation fails with an error.  ("EXPECTED_MD5 sum" is short-hand for "EXPECTED_HASH MD5=sum".) If SHOW_PROGRESS is specified, progress information will be printed as status messages until the operation is complete.  For https URLs CMake must be built with OpenSSL.  TLS/SSL certificates are not checked by default.  Set TLS_VERIFY to ON to check certificates and/or use EXPECTED_HASH to verify downloaded content.  Set TLS_CAINFO to specify a custom Certificate Authority file.  If either TLS option is not given CMake will check variables CMAKE_TLS_VERIFY and CMAKE_TLS_CAINFO, respectively.</p><p>UPLOAD will upload the given file to the given URL.  If LOG var is specified a log of the upload will be put in var.  If STATUS var is specified the status of the operation will be put in var.  The status is returned in a list of length 2.  The first element is the numeric return value for the operation, and the second element is a string value for the error.  A 0 numeric error means no error in the operation.  If TIMEOUT time is specified, the operation will timeout after time seconds, time should be specified as an integer.  The INACTIVITY_TIMEOUT specifies an integer number of seconds of inactivity after which the operation should terminate.  If SHOW_PROGRESS is specified, progress information will be printed as status messages until the operation is complete.</p><p>TIMESTAMP will write a string representation of the modification time of filename to variable.</p><p>Should the command be unable to obtain a timestamp variable will be set to the empty string "".</p><p>See documentation of the string TIMESTAMP sub-command for more details.</p><p>The file() command also provides COPY and INSTALL signatures:</p>
<pre>
file(&lt;COPY|INSTALL&gt; files... DESTINATION &lt;dir&gt;
     [FILE_PERMISSIONS permissions...]
     [DIRECTORY_PERMISSIONS permissions...]
     [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]
     [FILES_MATCHING]
     [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]
      [EXCLUDE] [PERMISSIONS permissions...]] [...])
</pre>
<p>The COPY signature copies files, directories, and symlinks to a destination folder.  Relative input paths are evaluated with respect to the current source directory, and a relative destination is evaluated with respect to the current build directory.  Copying preserves input file timestamps, and optimizes out a file if it exists at the destination with the same timestamp.  Copying preserves input permissions unless explicit permissions or NO_SOURCE_PERMISSIONS are given (default is USE_SOURCE_PERMISSIONS).  See the install(DIRECTORY) command for documentation of permissions, PATTERN, REGEX, and EXCLUDE options.</p><p>The INSTALL signature differs slightly from COPY: it prints status messages, and NO_SOURCE_PERMISSIONS is default.  Installation scripts generated by the install() command use this signature (with some undocumented options for internal use).</p><p>GENERATE will write an &lt;output_file&gt; with content from an &lt;input_file&gt;, or from &lt;input_content&gt;.  The output is generated conditionally based on the content of the &lt;condition&gt;.  The file is written at CMake generate-time and the input may contain generator expressions.  The &lt;condition&gt;, &lt;output_file&gt; and &lt;input_file&gt; may also contain generator expressions.  The &lt;condition&gt; must evaluate to either &apos;0&apos; or &apos;1&apos;.  The &lt;output_file&gt; must evaluate to a unique name among all configurations and among all invocations of file(GENERATE).</p>
<h3>find_file</h3>
<p>A short-hand signature is:</p>
<pre>
find_file (&lt;VAR&gt; name1 [path1 path2 ...])
</pre>
<p>The general signature is:</p>
<pre>
find_file (
          &lt;VAR&gt;
          name | NAMES name1 [name2 ...]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [NO_DEFAULT_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_CMAKE_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )
</pre>
<p>This command is used to find a full path to named file. A cache entry named by <strong>&lt;VAR&gt;</strong> is created to store the result of this command. If the full path to a file is found the result is stored in the variable and the search will not be repeated unless the variable is cleared. If nothing is found, the result will be <strong>&lt;VAR&gt;-NOTFOUND</strong>, and the search will be attempted again the next time find_file is invoked with the same variable. The name of the full path to a file that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the HINTS or PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache. PATH_SUFFIXES specifies additional subdirectories to check below each search path.</p><p>If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. This can be skipped if NO_CMAKE_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/include/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_INCLUDE_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific environment variables. These are intended to be set in the user&apos;s shell configuration. This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/include/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_INCLUDE_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Search the paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the location of another item already found. Hard-coded guesses should be specified with the PATHS option.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>PATH and INCLUDE</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/include/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_SYSTEM_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_SYSTEM_INCLUDE_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_SYSTEM_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    6.
  </dt>
  <dd>
    <p>Search the paths specified by the PATHS option or in the short-hand version of the command. These are typically hard-coded guesses.</p><p>On Darwin or systems supporting OS X Frameworks, the cmake variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find frameworks before standard libraries or headers. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find frameworks after standard libraries or headers.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find frameworks.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find frameworks.</p><p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find application bundles before standard programs. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find application bundles after standard programs.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find application bundles.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find application bundles.</p><p>The CMake variable <strong>CMAKE_FIND_ROOT_PATH</strong> specifies one or more directories to be prepended to all other search directories.  This effectively "re-roots" the entire search under given locations. Paths which are descendants of the <strong>CMAKE_STAGING_PREFIX</strong> are excluded from this re-rooting, because that variable is always a path on the host system. By default the <strong>CMAKE_FIND_ROOT_PATH</strong> is empty.</p><p>The <strong>CMAKE_SYSROOT</strong> variable can also be used to specify exactly one directory to use as a prefix.  Setting <strong>CMAKE_SYSROOT</strong> also has other effects.  See the documentation for that variable for more.</p><p>These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too.  By default at first the directories listed in <strong>CMAKE_FIND_ROOT_PATH</strong> are searched, then the <strong>CMAKE_SYSROOT</strong> directory is searched, and then the non-rooted directories will be searched.  The default behavior can be adjusted by setting <strong>CMAKE_FIND_ROOT_PATH_MODE_INCLUDE</strong>.  This behavior can be manually overridden on a per-call basis.  By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above.  If NO_CMAKE_FIND_ROOT_PATH is used then <strong>CMAKE_FIND_ROOT_PATH</strong> will not be used.  If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories and directories below <strong>CMAKE_STAGING_PREFIX</strong> will be searched.</p><p>The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply calling the command multiple times and using the <strong>NO_*</strong> options:</p>
<pre>
find_file (&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)
find_file (&lt;VAR&gt; NAMES name)
</pre>
<p>Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again.</p>
  </dd>

</dl>

<h3>find_library</h3>
<p>A short-hand signature is:</p>
<pre>
find_library (&lt;VAR&gt; name1 [path1 path2 ...])
</pre>
<p>The general signature is:</p>
<pre>
find_library (
          &lt;VAR&gt;
          name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [NO_DEFAULT_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_CMAKE_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )
</pre>
<p>This command is used to find a library. A cache entry named by <strong>&lt;VAR&gt;</strong> is created to store the result of this command. If the library is found the result is stored in the variable and the search will not be repeated unless the variable is cleared. If nothing is found, the result will be <strong>&lt;VAR&gt;-NOTFOUND</strong>, and the search will be attempted again the next time find_library is invoked with the same variable. The name of the library that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the HINTS or PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache. PATH_SUFFIXES specifies additional subdirectories to check below each search path.</p><p>If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. This can be skipped if NO_CMAKE_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/lib/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/lib for each &lt;prefix&gt; in CMAKE_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_LIBRARY_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific environment variables. These are intended to be set in the user&apos;s shell configuration. This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/lib/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/lib for each &lt;prefix&gt; in CMAKE_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_LIBRARY_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Search the paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the location of another item already found. Hard-coded guesses should be specified with the PATHS option.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>PATH and LIB</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/lib/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/lib for each &lt;prefix&gt; in CMAKE_SYSTEM_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_SYSTEM_LIBRARY_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_SYSTEM_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    6.
  </dt>
  <dd>
    <p>Search the paths specified by the PATHS option or in the short-hand version of the command. These are typically hard-coded guesses.</p><p>On Darwin or systems supporting OS X Frameworks, the cmake variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find frameworks before standard libraries or headers. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find frameworks after standard libraries or headers.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find frameworks.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find frameworks.</p><p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find application bundles before standard programs. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find application bundles after standard programs.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find application bundles.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find application bundles.</p><p>The CMake variable <strong>CMAKE_FIND_ROOT_PATH</strong> specifies one or more directories to be prepended to all other search directories.  This effectively "re-roots" the entire search under given locations. Paths which are descendants of the <strong>CMAKE_STAGING_PREFIX</strong> are excluded from this re-rooting, because that variable is always a path on the host system. By default the <strong>CMAKE_FIND_ROOT_PATH</strong> is empty.</p><p>The <strong>CMAKE_SYSROOT</strong> variable can also be used to specify exactly one directory to use as a prefix.  Setting <strong>CMAKE_SYSROOT</strong> also has other effects.  See the documentation for that variable for more.</p><p>These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too.  By default at first the directories listed in <strong>CMAKE_FIND_ROOT_PATH</strong> are searched, then the <strong>CMAKE_SYSROOT</strong> directory is searched, and then the non-rooted directories will be searched.  The default behavior can be adjusted by setting <strong>CMAKE_FIND_ROOT_PATH_MODE_LIBRARY</strong>.  This behavior can be manually overridden on a per-call basis.  By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above.  If NO_CMAKE_FIND_ROOT_PATH is used then <strong>CMAKE_FIND_ROOT_PATH</strong> will not be used.  If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories and directories below <strong>CMAKE_STAGING_PREFIX</strong> will be searched.</p><p>The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply calling the command multiple times and using the <strong>NO_*</strong> options:</p>
<pre>
find_library (&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)
find_library (&lt;VAR&gt; NAMES name)
</pre>
<p>Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again.</p><p>When more than one value is given to the NAMES option this command by default will consider one name at a time and search every directory for it.  The NAMES_PER_DIR option tells this command to consider one directory at a time and search for all names in it.</p><p>If the library found is a framework, then VAR will be set to the full path to the framework &lt;fullPath&gt;/A.framework.  When a full path to a framework is used as a library, CMake will use a -framework A, and a -F&lt;fullPath&gt; to link the framework to the target.</p><p>If the global property FIND_LIBRARY_USE_LIB64_PATHS is set all search paths will be tested as normal, with "64/" appended, and with all matches of "lib/" replaced with "lib64/".  This property is automatically set for the platforms that are known to need it if at least one of the languages supported by the PROJECT command is enabled.</p>
  </dd>

</dl>

<h3>find_package</h3>
<p>Load settings for an external project.</p>
<pre>
find_package(&lt;package&gt; [version] [EXACT] [QUIET] [MODULE]
             [REQUIRED] [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
             [NO_POLICY_SCOPE])
</pre>
<p>Finds and loads settings from an external project.  <strong>&lt;package&gt;_FOUND</strong> will be set to indicate whether the package was found.  When the package is found package-specific information is provided through variables and <em>Imported Targets</em> documented by the package itself.  The <strong>QUIET</strong> option disables messages if the package cannot be found.  The <strong>MODULE</strong> option disables the second signature documented below.  The <strong>REQUIRED</strong> option stops processing with an error message if the package cannot be found.</p><p>A package-specific list of required components may be listed after the <strong>COMPONENTS</strong> option (or after the <strong>REQUIRED</strong> option if present). Additional optional components may be listed after <strong>OPTIONAL_COMPONENTS</strong>.  Available components and their influence on whether a package is considered to be found are defined by the target package.</p><p>The <strong>[version]</strong> argument requests a version with which the package found should be compatible (format is <strong>major[.minor[.patch[.tweak]]]</strong>).  The <strong>EXACT</strong> option requests that the version be matched exactly.  If no <strong>[version]</strong> and/or component list is given to a recursive invocation inside a find-module, the corresponding arguments are forwarded automatically from the outer call (including the <strong>EXACT</strong> flag for <strong>[version]</strong>).  Version support is currently provided only on a package-by-package basis (details below).</p><p>User code should generally look for packages using the above simple signature.  The remainder of this command documentation specifies the full command signature and details of the search process.  Project maintainers wishing to provide a package to be found by this command are encouraged to read on.</p><p>The command has two modes by which it searches for packages: "Module" mode and "Config" mode.  Module mode is available when the command is invoked with the above reduced signature.  CMake searches for a file called <strong>Find&lt;package&gt;.cmake</strong> in the <strong>CMAKE_MODULE_PATH</strong> followed by the CMake installation.  If the file is found, it is read and processed by CMake.  It is responsible for finding the package, checking the version, and producing any needed messages.  Many find-modules provide limited or no support for versioning; check the module documentation.  If no module is found and the <strong>MODULE</strong> option is not given the command proceeds to Config mode.</p><p>The complete Config mode command signature is:</p>
<pre>
find_package(&lt;package&gt; [version] [EXACT] [QUIET]
             [REQUIRED] [[COMPONENTS] [components...]]
             [CONFIG|NO_MODULE]
             [NO_POLICY_SCOPE]
             [NAMES name1 [name2 ...]]
             [CONFIGS config1 [config2 ...]]
             [HINTS path1 [path2 ... ]]
             [PATHS path1 [path2 ... ]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_PACKAGE_REGISTRY]
             [NO_CMAKE_BUILDS_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH])
</pre>
<p>The <strong>CONFIG</strong> option may be used to skip Module mode explicitly and switch to Config mode.  It is synonymous to using <strong>NO_MODULE</strong>.  Config mode is also implied by use of options not specified in the reduced signature.</p><p>Config mode attempts to locate a configuration file provided by the package to be found.  A cache entry called <strong>&lt;package&gt;_DIR</strong> is created to hold the directory containing the file.  By default the command searches for a package with the name <strong>&lt;package&gt;</strong>.  If the <strong>NAMES</strong> option is given the names following it are used instead of <strong>&lt;package&gt;</strong>.  The command searches for a file called <strong>&lt;name&gt;Config.cmake</strong> or <strong>&lt;lower-case-name&gt;-config.cmake</strong> for each name specified.  A replacement set of possible configuration file names may be given using the <strong>CONFIGS</strong> option.  The search procedure is specified below. Once found, the configuration file is read and processed by CMake. Since the file is provided by the package it already knows the location of package contents.  The full path to the configuration file is stored in the cmake variable <strong>&lt;package&gt;_CONFIG</strong>.</p><p>All configuration files which have been considered by CMake while searching for an installation of the package with an appropriate version are stored in the cmake variable <strong>&lt;package&gt;_CONSIDERED_CONFIGS</strong>, the associated versions in <strong>&lt;package&gt;_CONSIDERED_VERSIONS</strong>.</p><p>If the package configuration file cannot be found CMake will generate an error describing the problem unless the <strong>QUIET</strong> argument is specified.  If <strong>REQUIRED</strong> is specified and the package is not found a fatal error is generated and the configure step stops executing.  If <strong>&lt;package&gt;_DIR</strong> has been set to a directory not containing a configuration file CMake will ignore it and search from scratch.</p><p>When the <strong>[version]</strong> argument is given Config mode will only find a version of the package that claims compatibility with the requested version (format is <strong>major[.minor[.patch[.tweak]]]</strong>).  If the <strong>EXACT</strong> option is given only a version of the package claiming an exact match of the requested version may be found.  CMake does not establish any convention for the meaning of version numbers.  Package version numbers are checked by "version" files provided by the packages themselves.  For a candidate package configuration file <strong>&lt;config-file&gt;.cmake</strong> the corresponding version file is located next to it and named either <strong>&lt;config-file&gt;-version.cmake</strong> or <strong>&lt;config-file&gt;Version.cmake</strong>.  If no such version file is available then the configuration file is assumed to not be compatible with any requested version.  A basic version file containing generic version matching code can be created using the <strong>CMakePackageConfigHelpers</strong> module.  When a version file is found it is loaded to check the requested version number.  The version file is loaded in a nested scope in which the following variables have been defined:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_NAME</strong><strong></strong></p>
  </dt>
  <dd>
    <p>the <strong>&lt;package&gt;</strong> name</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>full requested version string</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_MAJOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>major version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_MINOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>minor version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_PATCH</strong><strong></strong></p>
  </dt>
  <dd>
    <p>patch version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_TWEAK</strong><strong></strong></p>
  </dt>
  <dd>
    <p>tweak version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_COUNT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>number of version components, 0 to 4</p><p>The version file checks whether it satisfies the requested version and sets these variables:</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_VERSION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>full provided version string</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_VERSION_EXACT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>true if version is exact match</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_VERSION_COMPATIBLE</strong><strong></strong></p>
  </dt>
  <dd>
    <p>true if version is compatible</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_VERSION_UNSUITABLE</strong><strong></strong></p>
  </dt>
  <dd>
    <p>true if unsuitable as any version</p><p>These variables are checked by the <strong>find_package</strong> command to determine whether the configuration file provides an acceptable version.  They are not available after the find_package call returns.  If the version is acceptable the following variables are set:</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>full provided version string</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_MAJOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>major version if provided, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_MINOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>minor version if provided, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_PATCH</strong><strong></strong></p>
  </dt>
  <dd>
    <p>patch version if provided, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_TWEAK</strong><strong></strong></p>
  </dt>
  <dd>
    <p>tweak version if provided, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_COUNT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>number of version components, 0 to 4</p><p>and the corresponding package configuration file is loaded.  When multiple package configuration files are available whose version files claim compatibility with the version requested it is unspecified which one is chosen.  No attempt is made to choose a highest or closest version number.</p><p>Config mode provides an elaborate interface and search procedure. Much of the interface is provided for completeness and for use internally by find-modules loaded by Module mode.  Most user code should simply call:</p>
<pre>
find_package(&lt;package&gt; [major[.minor]] [EXACT] [REQUIRED|QUIET])
</pre>
<p>in order to find a package.  Package maintainers providing CMake package configuration files are encouraged to name and install them such that the procedure outlined below will find them without requiring use of additional options.</p><p>CMake constructs a set of possible installation prefixes for the package.  Under each prefix several directories are searched for a configuration file.  The tables below show the directories searched. Each entry is meant for installation trees following Windows (W), UNIX (U), or Apple (A) conventions:</p>
<pre>
&lt;prefix&gt;/                                               (W)
&lt;prefix&gt;/(cmake|CMake)/                                 (W)
&lt;prefix&gt;/&lt;name&gt;*/                                       (W)
&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/                         (W)
&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/cmake/&lt;name&gt;*/          (U)
&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/&lt;name&gt;*/                (U)
&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/&lt;name&gt;*/(cmake|CMake)/  (U)
</pre>
<p>On systems supporting OS X Frameworks and Application Bundles the following directories are searched for frameworks or bundles containing a configuration file:</p>
<pre>
&lt;prefix&gt;/&lt;name&gt;.framework/Resources/                    (A)
&lt;prefix&gt;/&lt;name&gt;.framework/Resources/CMake/              (A)
&lt;prefix&gt;/&lt;name&gt;.framework/Versions/*/Resources/         (A)
&lt;prefix&gt;/&lt;name&gt;.framework/Versions/*/Resources/CMake/   (A)
&lt;prefix&gt;/&lt;name&gt;.app/Contents/Resources/                 (A)
&lt;prefix&gt;/&lt;name&gt;.app/Contents/Resources/CMake/           (A)
</pre>
<p>In all cases the <strong>&lt;name&gt;</strong> is treated as case-insensitive and corresponds to any of the names specified (<strong>&lt;package&gt;</strong> or names given by <strong>NAMES</strong>). Paths with <strong>lib/&lt;arch&gt;</strong> are enabled if the <strong>CMAKE_LIBRARY_ARCHITECTURE</strong> variable is set.  If <strong>PATH_SUFFIXES</strong> is specified the suffixes are appended to each (W) or (U) directory entry one-by-one.</p><p>This set of directories is intended to work in cooperation with projects that provide configuration files in their installation trees. Directories above marked with (W) are intended for installations on Windows where the prefix may point at the top of an application&apos;s installation directory.  Those marked with (U) are intended for installations on UNIX platforms where the prefix is shared by multiple packages.  This is merely a convention, so all (W) and (U) directories are still searched on all platforms.  Directories marked with (A) are intended for installations on Apple platforms.  The cmake variables <strong>CMAKE_FIND_FRAMEWORK</strong> and <strong>CMAKE_FIND_APPBUNDLE</strong> determine the order of preference as specified below.</p><p>The set of installation prefixes is constructed using the following steps.  If <strong>NO_DEFAULT_PATH</strong> is specified all <strong>NO_*</strong> options are enabled.</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific cache variables.  These are intended to be used on the command line with a <strong>-DVAR=value</strong>. This can be skipped if <strong>NO_CMAKE_PATH</strong> is passed:</p>
<pre>
CMAKE_PREFIX_PATH
CMAKE_FRAMEWORK_PATH
CMAKE_APPBUNDLE_PATH
</pre>

  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific environment variables. These are intended to be set in the user&apos;s shell configuration. This can be skipped if <strong>NO_CMAKE_ENVIRONMENT_PATH</strong> is passed:</p>
<pre>
&lt;package&gt;_DIR
CMAKE_PREFIX_PATH
CMAKE_FRAMEWORK_PATH
CMAKE_APPBUNDLE_PATH
</pre>

  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Search paths specified by the <strong>HINTS</strong> option.  These should be paths computed by system introspection, such as a hint provided by the location of another item already found.  Hard-coded guesses should be specified with the <strong>PATHS</strong> option.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>Search the standard system environment variables.  This can be skipped if <strong>NO_SYSTEM_ENVIRONMENT_PATH</strong> is passed.  Path entries ending in <strong>/bin</strong> or <strong>/sbin</strong> are automatically converted to their parent directories:</p>
<pre>
PATH
</pre>

  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>Search project build trees recently configured in a <a href="../man1/cmake-gui.1.html"><strong>cmake-gui</strong>(1)</a></strong>. This can be skipped if <strong>NO_CMAKE_BUILDS_PATH</strong> is passed.  It is intended for the case when a user is building multiple dependent projects one after another. (This step is implemented only on Windows.)</p>
  </dd>
  <dt>
    6.
  </dt>
  <dd>
    <p>Search paths stored in the CMake <em>User Package Registry</em>. This can be skipped if <strong>NO_CMAKE_PACKAGE_REGISTRY</strong> is passed. See the <a href="../man7/cmake-packages.7.html"><strong>cmake-packages</strong>(7)</a></strong> manual for details on the user package registry.</p>
  </dd>
  <dt>
    7.
  </dt>
  <dd>
    <p>Search cmake variables defined in the Platform files for the current system.  This can be skipped if <strong>NO_CMAKE_SYSTEM_PATH</strong> is passed:</p>
<pre>
CMAKE_SYSTEM_PREFIX_PATH
CMAKE_SYSTEM_FRAMEWORK_PATH
CMAKE_SYSTEM_APPBUNDLE_PATH
</pre>

  </dd>
  <dt>
    8.
  </dt>
  <dd>
    <p>Search paths stored in the CMake <em>System Package Registry</em>. This can be skipped if <strong>NO_CMAKE_SYSTEM_PACKAGE_REGISTRY</strong> is passed. See the <a href="../man7/cmake-packages.7.html"><strong>cmake-packages</strong>(7)</a></strong> manual for details on the system package registry.</p>
  </dd>
  <dt>
    9.
  </dt>
  <dd>
    <p>Search paths specified by the <strong>PATHS</strong> option.  These are typically hard-coded guesses.</p><p>On Darwin or systems supporting OS X Frameworks, the cmake variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find frameworks before standard libraries or headers. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find frameworks after standard libraries or headers.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find frameworks.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find frameworks.</p><p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find application bundles before standard programs. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find application bundles after standard programs.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find application bundles.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find application bundles.</p><p>The CMake variable <strong>CMAKE_FIND_ROOT_PATH</strong> specifies one or more directories to be prepended to all other search directories.  This effectively "re-roots" the entire search under given locations. Paths which are descendants of the <strong>CMAKE_STAGING_PREFIX</strong> are excluded from this re-rooting, because that variable is always a path on the host system. By default the <strong>CMAKE_FIND_ROOT_PATH</strong> is empty.</p><p>The <strong>CMAKE_SYSROOT</strong> variable can also be used to specify exactly one directory to use as a prefix.  Setting <strong>CMAKE_SYSROOT</strong> also has other effects.  See the documentation for that variable for more.</p><p>These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too.  By default at first the directories listed in <strong>CMAKE_FIND_ROOT_PATH</strong> are searched, then the <strong>CMAKE_SYSROOT</strong> directory is searched, and then the non-rooted directories will be searched.  The default behavior can be adjusted by setting <strong>CMAKE_FIND_ROOT_PATH_MODE_PACKAGE</strong>.  This behavior can be manually overridden on a per-call basis.  By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above.  If NO_CMAKE_FIND_ROOT_PATH is used then <strong>CMAKE_FIND_ROOT_PATH</strong> will not be used.  If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories and directories below <strong>CMAKE_STAGING_PREFIX</strong> will be searched.</p><p>The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply calling the command multiple times and using the <strong>NO_*</strong> options:</p>
<pre>
find_package (&lt;package&gt; PATHS paths... NO_DEFAULT_PATH)
find_package (&lt;package&gt;)
</pre>
<p>Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again.</p><p>Every non-REQUIRED <strong>find_package</strong> call can be disabled by setting the <strong>CMAKE_DISABLE_FIND_PACKAGE_&lt;PackageName&gt;</strong> variable to <strong>TRUE</strong>.</p><p>When loading a find module or package configuration file <strong>find_package</strong> defines variables to provide information about the call arguments (and restores their original state before returning):</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_REQUIRED</strong><strong></strong></p>
  </dt>
  <dd>
    <p>true if <strong>REQUIRED</strong> option was given</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_QUIETLY</strong><strong></strong></p>
  </dt>
  <dd>
    <p>true if <strong>QUIET</strong> option was given</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_VERSION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>full requested version string</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_VERSION_MAJOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>major version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_VERSION_MINOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>minor version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_VERSION_PATCH</strong><strong></strong></p>
  </dt>
  <dd>
    <p>patch version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_VERSION_TWEAK</strong><strong></strong></p>
  </dt>
  <dd>
    <p>tweak version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_VERSION_COUNT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>number of version components, 0 to 4</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_VERSION_EXACT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>true if <strong>EXACT</strong> option was given</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_COMPONENTS</strong><strong></strong></p>
  </dt>
  <dd>
    <p>list of requested components</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_FIND_REQUIRED_&lt;c&gt;</strong><strong></strong></p>
  </dt>
  <dd>
    <p>true if component <strong>&lt;c&gt;</strong> is required, false if component <strong>&lt;c&gt;</strong> is optional</p><p>In Module mode the loaded find module is responsible to honor the request detailed by these variables; see the find module for details. In Config mode <strong>find_package</strong> handles <strong>REQUIRED</strong>, <strong>QUIET</strong>, and <strong>[version]</strong> options automatically but leaves it to the package configuration file to handle components in a way that makes sense for the package.  The package configuration file may set <strong>&lt;package&gt;_FOUND</strong> to false to tell <strong>find_package</strong> that component requirements are not satisfied.</p><p>See the <strong>cmake_policy()</strong> command documentation for discussion of the <strong>NO_POLICY_SCOPE</strong> option.</p>
  </dd>

</dl>

<h3>find_path</h3>
<p>A short-hand signature is:</p>
<pre>
find_path (&lt;VAR&gt; name1 [path1 path2 ...])
</pre>
<p>The general signature is:</p>
<pre>
find_path (
          &lt;VAR&gt;
          name | NAMES name1 [name2 ...]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [NO_DEFAULT_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_CMAKE_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )
</pre>
<p>This command is used to find a directory containing the named file. A cache entry named by <strong>&lt;VAR&gt;</strong> is created to store the result of this command. If the file in a directory is found the result is stored in the variable and the search will not be repeated unless the variable is cleared. If nothing is found, the result will be <strong>&lt;VAR&gt;-NOTFOUND</strong>, and the search will be attempted again the next time find_path is invoked with the same variable. The name of the file in a directory that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the HINTS or PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache. PATH_SUFFIXES specifies additional subdirectories to check below each search path.</p><p>If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. This can be skipped if NO_CMAKE_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/include/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_INCLUDE_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific environment variables. These are intended to be set in the user&apos;s shell configuration. This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/include/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_INCLUDE_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Search the paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the location of another item already found. Hard-coded guesses should be specified with the PATHS option.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>PATH and INCLUDE</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/include/&lt;arch&gt; if CMAKE_LIBRARY_ARCHITECTURE is set, and &lt;prefix&gt;/include for each &lt;prefix&gt; in CMAKE_SYSTEM_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_SYSTEM_INCLUDE_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_SYSTEM_FRAMEWORK_PATH</p>
  </dd>
  <dt>
    6.
  </dt>
  <dd>
    <p>Search the paths specified by the PATHS option or in the short-hand version of the command. These are typically hard-coded guesses.</p><p>On Darwin or systems supporting OS X Frameworks, the cmake variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find frameworks before standard libraries or headers. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find frameworks after standard libraries or headers.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find frameworks.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find frameworks.</p><p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find application bundles before standard programs. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find application bundles after standard programs.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find application bundles.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find application bundles.</p><p>The CMake variable <strong>CMAKE_FIND_ROOT_PATH</strong> specifies one or more directories to be prepended to all other search directories.  This effectively "re-roots" the entire search under given locations. Paths which are descendants of the <strong>CMAKE_STAGING_PREFIX</strong> are excluded from this re-rooting, because that variable is always a path on the host system. By default the <strong>CMAKE_FIND_ROOT_PATH</strong> is empty.</p><p>The <strong>CMAKE_SYSROOT</strong> variable can also be used to specify exactly one directory to use as a prefix.  Setting <strong>CMAKE_SYSROOT</strong> also has other effects.  See the documentation for that variable for more.</p><p>These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too.  By default at first the directories listed in <strong>CMAKE_FIND_ROOT_PATH</strong> are searched, then the <strong>CMAKE_SYSROOT</strong> directory is searched, and then the non-rooted directories will be searched.  The default behavior can be adjusted by setting <strong>CMAKE_FIND_ROOT_PATH_MODE_INCLUDE</strong>.  This behavior can be manually overridden on a per-call basis.  By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above.  If NO_CMAKE_FIND_ROOT_PATH is used then <strong>CMAKE_FIND_ROOT_PATH</strong> will not be used.  If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories and directories below <strong>CMAKE_STAGING_PREFIX</strong> will be searched.</p><p>The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply calling the command multiple times and using the <strong>NO_*</strong> options:</p>
<pre>
find_path (&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)
find_path (&lt;VAR&gt; NAMES name)
</pre>
<p>Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again.</p><p>When searching for frameworks, if the file is specified as A/b.h, then the framework search will look for A.framework/Headers/b.h.  If that is found the path will be set to the path to the framework.  CMake will convert this to the correct -F option to include the file.</p>
  </dd>

</dl>

<h3>find_program</h3>
<p>A short-hand signature is:</p>
<pre>
find_program (&lt;VAR&gt; name1 [path1 path2 ...])
</pre>
<p>The general signature is:</p>
<pre>
find_program (
          &lt;VAR&gt;
          name | NAMES name1 [name2 ...]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [NO_DEFAULT_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_CMAKE_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )
</pre>
<p>This command is used to find a program. A cache entry named by <strong>&lt;VAR&gt;</strong> is created to store the result of this command. If the program is found the result is stored in the variable and the search will not be repeated unless the variable is cleared. If nothing is found, the result will be <strong>&lt;VAR&gt;-NOTFOUND</strong>, and the search will be attempted again the next time find_program is invoked with the same variable. The name of the program that is searched for is specified by the names listed after the NAMES argument.   Additional search locations can be specified after the PATHS argument.  If ENV var is found in the HINTS or PATHS section the environment variable var will be read and converted from a system environment variable to a cmake style list of paths.  For example ENV PATH would be a way to list the system path variable. The argument after DOC will be used for the documentation string in the cache. PATH_SUFFIXES specifies additional subdirectories to check below each search path.</p><p>If NO_DEFAULT_PATH is specified, then no additional paths are added to the search. If NO_DEFAULT_PATH is not specified, the search process is as follows:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific cache variables. These are intended to be used on the command line with a -DVAR=value. This can be skipped if NO_CMAKE_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/[s]bin for each &lt;prefix&gt; in CMAKE_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_PROGRAM_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_APPBUNDLE_PATH</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Search paths specified in cmake-specific environment variables. These are intended to be set in the user&apos;s shell configuration. This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/[s]bin for each &lt;prefix&gt; in CMAKE_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_PROGRAM_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_APPBUNDLE_PATH</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Search the paths specified by the HINTS option. These should be paths computed by system introspection, such as a hint provided by the location of another item already found. Hard-coded guesses should be specified with the PATHS option.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>Search the standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is an argument.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>PATH</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>Search cmake variables defined in the Platform files for the current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>&lt;prefix&gt;/[s]bin for each &lt;prefix&gt; in CMAKE_SYSTEM_PREFIX_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_SYSTEM_PROGRAM_PATH</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>CMAKE_SYSTEM_APPBUNDLE_PATH</p>
  </dd>
  <dt>
    6.
  </dt>
  <dd>
    <p>Search the paths specified by the PATHS option or in the short-hand version of the command. These are typically hard-coded guesses.</p><p>On Darwin or systems supporting OS X Frameworks, the cmake variable CMAKE_FIND_FRAMEWORK can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find frameworks before standard libraries or headers. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find frameworks after standard libraries or headers.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find frameworks.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find frameworks.</p><p>On Darwin or systems supporting OS X Application Bundles, the cmake variable CMAKE_FIND_APPBUNDLE can be set to empty or one of the following:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>FIRST: Try to find application bundles before standard programs. This is the default on Darwin.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>LAST: Try to find application bundles after standard programs.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ONLY: Only try to find application bundles.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>NEVER: Never try to find application bundles.</p><p>The CMake variable <strong>CMAKE_FIND_ROOT_PATH</strong> specifies one or more directories to be prepended to all other search directories.  This effectively "re-roots" the entire search under given locations. Paths which are descendants of the <strong>CMAKE_STAGING_PREFIX</strong> are excluded from this re-rooting, because that variable is always a path on the host system. By default the <strong>CMAKE_FIND_ROOT_PATH</strong> is empty.</p><p>The <strong>CMAKE_SYSROOT</strong> variable can also be used to specify exactly one directory to use as a prefix.  Setting <strong>CMAKE_SYSROOT</strong> also has other effects.  See the documentation for that variable for more.</p><p>These variables are especially useful when cross-compiling to point to the root directory of the target environment and CMake will search there too.  By default at first the directories listed in <strong>CMAKE_FIND_ROOT_PATH</strong> are searched, then the <strong>CMAKE_SYSROOT</strong> directory is searched, and then the non-rooted directories will be searched.  The default behavior can be adjusted by setting <strong>CMAKE_FIND_ROOT_PATH_MODE_PROGRAM</strong>.  This behavior can be manually overridden on a per-call basis.  By using CMAKE_FIND_ROOT_PATH_BOTH the search order will be as described above.  If NO_CMAKE_FIND_ROOT_PATH is used then <strong>CMAKE_FIND_ROOT_PATH</strong> will not be used.  If ONLY_CMAKE_FIND_ROOT_PATH is used then only the re-rooted directories and directories below <strong>CMAKE_STAGING_PREFIX</strong> will be searched.</p><p>The default search order is designed to be most-specific to least-specific for common use cases. Projects may override the order by simply calling the command multiple times and using the <strong>NO_*</strong> options:</p>
<pre>
find_program (&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)
find_program (&lt;VAR&gt; NAMES name)
</pre>
<p>Once one of the calls succeeds the result variable will be set and stored in the cache so that no call will search again.</p>
  </dd>

</dl>

<h3>fltk_wrap_ui</h3>
<p>Create FLTK user interfaces Wrappers.</p>
<pre>
fltk_wrap_ui(resultingLibraryName source1
             source2 ... sourceN )
</pre>
<p>Produce .h and .cxx files for all the .fl and .fld files listed.  The resulting .h and .cxx files will be added to a variable named resultingLibraryName_FLTK_UI_SRCS which should be added to your library.</p>
<h3>foreach</h3>
<p>Evaluate a group of commands for each value in a list.</p>
<pre>
foreach(loop_var arg1 arg2 ...)
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endforeach(loop_var)
</pre>
<p>All commands between foreach and the matching endforeach are recorded without being invoked.  Once the endforeach is evaluated, the recorded list of commands is invoked once for each argument listed in the original foreach command.  Before each iteration of the loop "${loop_var}" will be set as a variable with the current value in the list.</p>
<pre>
foreach(loop_var RANGE total)
foreach(loop_var RANGE start stop [step])
</pre>
<p>Foreach can also iterate over a generated range of numbers.  There are three types of this iteration:</p><ul>
<li><p>When specifying single number, the range will have elements 0 to "total".</p></li><li><p>When specifying two numbers, the range will have elements from the first number to the second number.</p></li><li><p>The third optional number is the increment used to iterate from the first number to the second number.</p>
<pre>
foreach(loop_var IN [LISTS [list1 [...]]]
                    [ITEMS [item1 [...]]])
</pre>
<p>Iterates over a precise list of items.  The LISTS option names list-valued variables to be traversed, including empty elements (an empty string is a zero-length list).  (Note macro arguments are not variables.)  The ITEMS option ends argument parsing and includes all arguments following it in the iteration.</p></li>
</ul>
<h3>function</h3>
<p>Start recording a function for later invocation as a command.</p>
<pre>
function(&lt;name&gt; [arg1 [arg2 [arg3 ...]]])
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endfunction(&lt;name&gt;)
</pre>
<p>Define a function named &lt;name&gt; that takes arguments named arg1 arg2 arg3 (...).  Commands listed after function, but before the matching endfunction, are not invoked until the function is invoked.  When it is invoked, the commands recorded in the function are first modified by replacing formal parameters (${arg1}) with the arguments passed, and then invoked as normal commands.  In addition to referencing the formal parameters you can reference the variable ARGC which will be set to the number of arguments passed into the function as well as ARGV0 ARGV1 ARGV2 ...  which will have the actual values of the arguments passed in.  This facilitates creating functions with optional arguments.  Additionally ARGV holds the list of all arguments given to the function and ARGN holds the list of arguments past the last expected argument.</p><p>A function opens a new scope: see set(var PARENT_SCOPE) for details.</p><p>See the cmake_policy() command documentation for the behavior of policies inside functions.</p>
<h3>get_cmake_property</h3>
<p>Get a property of the CMake instance.</p>
<pre>
get_cmake_property(VAR property)
</pre>
<p>Get a property from the CMake instance.  The value of the property is stored in the variable VAR.  If the property is not found, VAR will be set to "NOTFOUND".  Some supported properties include: VARIABLES, CACHE_VARIABLES, COMMANDS, MACROS, and COMPONENTS.</p><p>See also the more general get_property() command.</p>
<h3>get_directory_property</h3>
<p>Get a property of DIRECTORY scope.</p>
<pre>
get_directory_property(&lt;variable&gt; [DIRECTORY &lt;dir&gt;] &lt;prop-name&gt;)
</pre>
<p>Store a property of directory scope in the named variable.  If the property is not defined the empty-string is returned.  The DIRECTORY argument specifies another directory from which to retrieve the property value.  The specified directory must have already been traversed by CMake.</p>
<pre>
get_directory_property(&lt;variable&gt; [DIRECTORY &lt;dir&gt;]
                       DEFINITION &lt;var-name&gt;)
</pre>
<p>Get a variable definition from a directory.  This form is useful to get a variable definition from another directory.</p><p>See also the more general get_property() command.</p>
<h3>get_filename_component</h3>
<p>Get a specific component of a full filename.</p>
<pre>
get_filename_component(&lt;VAR&gt; &lt;FileName&gt; &lt;COMP&gt; [CACHE])
</pre>
<p>Set &lt;VAR&gt; to a component of &lt;FileName&gt;, where &lt;COMP&gt; is one of:</p>
<pre>
DIRECTORY = Directory without file name
NAME      = File name without directory
EXT       = File name longest extension (.b.c from d/a.b.c)
NAME_WE   = File name without directory or longest extension
ABSOLUTE  = Full path to file
REALPATH  = Full path to existing file with symlinks resolved
PATH      = Legacy alias for DIRECTORY (use for CMake &lt;= 2.8.11)
</pre>
<p>Paths are returned with forward slashes and have no trailing slahes. The longest file extension is always considered.  If the optional CACHE argument is specified, the result variable is added to the cache.</p>
<pre>
get_filename_component(&lt;VAR&gt; FileName
                       PROGRAM [PROGRAM_ARGS &lt;ARG_VAR&gt;]
                       [CACHE])
</pre>
<p>The program in FileName will be found in the system search path or left as a full path.  If PROGRAM_ARGS is present with PROGRAM, then any command-line arguments present in the FileName string are split from the program name and stored in &lt;ARG_VAR&gt;.  This is used to separate a program name from its arguments in a command line string.</p>
<h3>get_property</h3>
<p>Get a property.</p>
<pre>
get_property(&lt;variable&gt;
             &lt;GLOBAL             |
              DIRECTORY [dir]    |
              TARGET    &lt;target&gt; |
              SOURCE    &lt;source&gt; |
              TEST      &lt;test&gt;   |
              CACHE     &lt;entry&gt;  |
              VARIABLE&gt;
             PROPERTY &lt;name&gt;
             [SET | DEFINED | BRIEF_DOCS | FULL_DOCS])
</pre>
<p>Get one property from one object in a scope.  The first argument specifies the variable in which to store the result.  The second argument determines the scope from which to get the property.  It must be one of the following:</p><p>GLOBAL scope is unique and does not accept a name.</p><p>DIRECTORY scope defaults to the current directory but another directory (already processed by CMake) may be named by full or relative path.</p><p>TARGET scope must name one existing target.</p><p>SOURCE scope must name one source file.</p><p>TEST scope must name one existing test.</p><p>CACHE scope must name one cache entry.</p><p>VARIABLE scope is unique and does not accept a name.</p><p>The required PROPERTY option is immediately followed by the name of the property to get.  If the property is not set an empty value is returned.  If the SET option is given the variable is set to a boolean value indicating whether the property has been set.  If the DEFINED option is given the variable is set to a boolean value indicating whether the property has been defined such as with define_property. If BRIEF_DOCS or FULL_DOCS is given then the variable is set to a string containing documentation for the requested property.  If documentation is requested for a property that has not been defined NOTFOUND is returned.</p>
<h3>get_source_file_property</h3>
<p>Get a property for a source file.</p>
<pre>
get_source_file_property(VAR file property)
</pre>
<p>Get a property from a source file.  The value of the property is stored in the variable VAR.  If the property is not found, VAR will be set to "NOTFOUND".  Use set_source_files_properties to set property values.  Source file properties usually control how the file is built. One property that is always there is LOCATION</p><p>See also the more general get_property() command.</p>
<h3>get_target_property</h3>
<p>Get a property from a target.</p>
<pre>
get_target_property(VAR target property)
</pre>
<p>Get a property from a target.  The value of the property is stored in the variable VAR.  If the property is not found, VAR will be set to "NOTFOUND".  Use set_target_properties to set property values. Properties are usually used to control how a target is built, but some query the target instead.  This command can get properties for any target so far created.  The targets do not need to be in the current CMakeLists.txt file.</p><p>See also the more general get_property() command.</p>
<h3>get_test_property</h3>
<p>Get a property of the test.</p>
<pre>
get_test_property(test property VAR)
</pre>
<p>Get a property from the Test.  The value of the property is stored in the variable VAR.  If the property is not found, VAR will be set to "NOTFOUND".  For a list of standard properties you can type cmake --help-property-list</p><p>See also the more general get_property() command.</p>
<h3>if</h3>
<p>Conditionally execute a group of commands.</p>
<pre>
if(expression)
  # then section.
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
elseif(expression2)
  # elseif section.
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
else(expression)
  # else section.
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endif(expression)
</pre>
<p>Evaluates the given expression.  If the result is true, the commands in the THEN section are invoked.  Otherwise, the commands in the else section are invoked.  The elseif and else sections are optional.  You may have multiple elseif clauses.  Note that the expression in the else and endif clause is optional.  Long expressions can be used and there is a traditional order of precedence.  Parenthetical expressions are evaluated first followed by unary tests such as <strong>EXISTS</strong>, <strong>COMMAND</strong>, and <strong>DEFINED</strong>.  Then any binary tests such as <strong>EQUAL</strong>, <strong>LESS</strong>, <strong>GREATER</strong>, <strong>STRLESS</strong>, <strong>STRGREATER</strong>, <strong>STREQUAL</strong>, and <strong>MATCHES</strong> will be evaluated.  Then boolean <strong>NOT</strong> operators and finally boolean <strong>AND</strong> and then <strong>OR</strong> operators will be evaluated.</p><p>Possible expressions are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>if(&lt;constant&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the constant is <strong>1</strong>, <strong>ON</strong>, <strong>YES</strong>, <strong>TRUE</strong>, <strong>Y</strong>, or a non-zero number.  False if the constant is <strong>0</strong>, <strong>OFF</strong>, <strong>NO</strong>, <strong>FALSE</strong>, <strong>N</strong>, <strong>IGNORE</strong>, <strong>NOTFOUND</strong>, the empty string, or ends in the suffix <strong>-NOTFOUND</strong>.  Named boolean constants are case-insensitive.  If the argument is not one of these constants, it is treated as a variable.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the variable is defined to a value that is not a false constant.  False otherwise.  (Note macro arguments are not variables.)</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(NOT &lt;expression&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the expression is not true.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;expr1&gt; AND &lt;expr2&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if both expressions would be considered true individually.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;expr1&gt; OR &lt;expr2&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if either expression would be considered true individually.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(COMMAND command-name)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given name is a command, macro or function that can be invoked.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(POLICY policy-id)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given name is an existing policy (of the form <strong>CMP&lt;NNNN&gt;</strong>).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(TARGET target-name)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given name is an existing logical target name such as those created by the <strong>add_executable()</strong>, <strong>add_library()</strong>, or <strong>add_custom_target()</strong> commands.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(EXISTS path-to-file-or-directory)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the named file or directory exists.  Behavior is well-defined only for full paths.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(file1 IS_NEWER_THAN file2)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if file1 is newer than file2 or if one of the two files doesn&apos;t exist.  Behavior is well-defined only for full paths.  If the file time stamps are exactly the same, an <strong>IS_NEWER_THAN</strong> comparison returns true, so that any dependent build operations will occur in the event of a tie.  This includes the case of passing the same file name for both file1 and file2.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(IS_DIRECTORY path-to-directory)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given name is a directory.  Behavior is well-defined only for full paths.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(IS_SYMLINK file-name)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given name is a symbolic link.  Behavior is well-defined only for full paths.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(IS_ABSOLUTE path)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given path is an absolute path.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; MATCHES regex)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given string or variable&apos;s value matches the given regular expression.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; LESS &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given string or variable&apos;s value is a valid number and less than that on the right.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; GREATER &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given string or variable&apos;s value is a valid number and greater than that on the right.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; EQUAL &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given string or variable&apos;s value is a valid number and equal to that on the right.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; STRLESS &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given string or variable&apos;s value is lexicographically less than the string or variable on the right.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; STRGREATER &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given string or variable&apos;s value is lexicographically greater than the string or variable on the right.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given string or variable&apos;s value is lexicographically equal to the string or variable on the right.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; VERSION_LESS &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Component-wise integer version number comparison (version format is <strong>major[.minor[.patch[.tweak]]]</strong>).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; VERSION_EQUAL &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Component-wise integer version number comparison (version format is <strong>major[.minor[.patch[.tweak]]]</strong>).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(&lt;variable|string&gt; VERSION_GREATER &lt;variable|string&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Component-wise integer version number comparison (version format is <strong>major[.minor[.patch[.tweak]]]</strong>).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if(DEFINED &lt;variable&gt;)</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if the given variable is defined.  It does not matter if the variable is true or false just if it has been set.  (Note macro arguments are not variables.)</p>
  </dd>
  <dt>
    <p><strong></strong><strong>if((expression) AND (expression OR (expression)))</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The expressions inside the parenthesis are evaluated first and then the remaining expression is evaluated as in the previous examples. Where there are nested parenthesis the innermost are evaluated as part of evaluating the expression that contains them.</p><p>The if command was written very early in CMake&apos;s history, predating the <strong>${}</strong> variable evaluation syntax, and for convenience evaluates variables named by its arguments as shown in the above signatures. Note that normal variable evaluation with <strong>${}</strong> applies before the if command even receives the arguments.  Therefore code like:</p>
<pre>
set(var1 OFF)
set(var2 "var1")
if(${var2})
</pre>
<p>appears to the if command as:</p>
<pre>
if(var1)
</pre>
<p>and is evaluated according to the <strong>if(&lt;variable&gt;)</strong> case documented above.  The result is <strong>OFF</strong> which is false.  However, if we remove the <strong>${}</strong> from the example then the command sees:</p>
<pre>
if(var2)
</pre>
<p>which is true because <strong>var2</strong> is defined to "var1" which is not a false constant.</p><p>Automatic evaluation applies in the other cases whenever the above-documented signature accepts <strong>&lt;variable|string&gt;</strong>:</p><ul>
<li><p>The left hand argument to <strong>MATCHES</strong> is first checked to see if it is a defined variable, if so the variable&apos;s value is used, otherwise the original value is used.</p></li><li><p>If the left hand argument to <strong>MATCHES</strong> is missing it returns false without error</p></li><li><p>Both left and right hand arguments to <strong>LESS</strong>, <strong>GREATER</strong>, and <strong>EQUAL</strong> are independently tested to see if they are defined variables, if so their defined values are used otherwise the original value is used.</p></li><li><p>Both left and right hand arguments to <strong>STRLESS</strong>, <strong>STREQUAL</strong>, and <strong>STRGREATER</strong> are independently tested to see if they are defined variables, if so their defined values are used otherwise the original value is used.</p></li><li><p>Both left and right hand arguments to <strong>VERSION_LESS</strong>, <strong>VERSION_EQUAL</strong>, and <strong>VERSION_GREATER</strong> are independently tested to see if they are defined variables, if so their defined values are used otherwise the original value is used.</p></li><li><p>The right hand argument to <strong>NOT</strong> is tested to see if it is a boolean constant, if so the value is used, otherwise it is assumed to be a variable and it is dereferenced.</p></li><li><p>The left and right hand arguments to <strong>AND</strong> and <strong>OR</strong> are independently tested to see if they are boolean constants, if so they are used as such, otherwise they are assumed to be variables and are dereferenced.</p></li>
</ul>
  </dd>

</dl>

<h3>include_directories</h3>
<p>Add include directories to the build.</p>
<pre>
include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])
</pre>
<p>Add the given directories to those the compiler uses to search for include files.  Relative paths are interpreted as relative to the current source directory.</p><p>The include directories are added to the <strong>INCLUDE_DIRECTORIES</strong> directory property for the current <strong>CMakeLists</strong> file.  They are also added to the <strong>INCLUDE_DIRECTORIES</strong> target property for each target in the current <strong>CMakeLists</strong> file.  The target property values are the ones used by the generators.</p><p>By default the directories specified are appended onto the current list of directories.  This default behavior can be changed by setting <strong>CMAKE_INCLUDE_DIRECTORIES_BEFORE</strong> to <strong>ON</strong>.  By using <strong>AFTER</strong> or <strong>BEFORE</strong> explicitly, you can select between appending and prepending, independent of the default.</p><p>If the <strong>SYSTEM</strong> option is given, the compiler will be told the directories are meant as system include directories on some platforms. Signalling this setting might achieve effects such as the compiler skipping warnings, or these fixed-install system files not being considered in dependency calculations - see compiler docs.</p><p>Arguments to <strong>include_directories</strong> may use "generator expressions" with the syntax "$&lt;...&gt;".  See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions.  See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p>
<h3>include_external_msproject</h3>
<p>Include an external Microsoft project file in a workspace.</p>
<pre>
include_external_msproject(projectname location
                           [TYPE projectTypeGUID]
                           [GUID projectGUID]
                           [PLATFORM platformName]
                           dep1 dep2 ...)
</pre>
<p>Includes an external Microsoft project in the generated workspace file.  Currently does nothing on UNIX.  This will create a target named [projectname].  This can be used in the add_dependencies command to make things depend on the external project.</p><p>TYPE, GUID and PLATFORM are optional parameters that allow one to specify the type of project, id (GUID) of the project and the name of the target platform.  This is useful for projects requiring values other than the default (e.g.  WIX projects).  These options are not supported by the Visual Studio 6 generator.</p>
<h3>include_regular_expression</h3>
<p>Set the regular expression used for dependency checking.</p>
<pre>
include_regular_expression(regex_match [regex_complain])
</pre>
<p>Set the regular expressions used in dependency checking.  Only files matching regex_match will be traced as dependencies.  Only files matching regex_complain will generate warnings if they cannot be found (standard header paths are not searched).  The defaults are:</p>
<pre>
regex_match    = "^.*$" (match everything)
regex_complain = "^$" (match empty string only)
</pre>

<h3>include</h3>
<p>Load and run CMake code from a file or module.</p>
<pre>
include(&lt;file|module&gt; [OPTIONAL] [RESULT_VARIABLE &lt;VAR&gt;]
                      [NO_POLICY_SCOPE])
</pre>
<p>Load and run CMake code from the file given.  Variable reads and writes access the scope of the caller (dynamic scoping).  If OPTIONAL is present, then no error is raised if the file does not exist.  If RESULT_VARIABLE is given the variable will be set to the full filename which has been included or NOTFOUND if it failed.</p><p>If a module is specified instead of a file, the file with name &lt;modulename&gt;.cmake is searched first in CMAKE_MODULE_PATH, then in the CMake module directory.  There is one exception to this: if the file which calls include() is located itself in the CMake module directory, then first the CMake module directory is searched and CMAKE_MODULE_PATH afterwards.  See also policy CMP0017.</p><p>See the cmake_policy() command documentation for discussion of the NO_POLICY_SCOPE option.</p>
<h3>install</h3>
<p>Specify rules to run at install time.</p><p>This command generates installation rules for a project.  Rules specified by calls to this command within a source directory are executed in order during installation.  The order across directories is not defined.</p><p>There are multiple signatures for this command.  Some of them define installation options for files and targets.  Options common to multiple signatures are covered here but they are valid only for signatures that specify them.  The common options are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>DESTINATION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Specify the directory on disk to which a file will be installed. If a full path (with a leading slash or drive letter) is given it is used directly.  If a relative path is given it is interpreted relative to the value of the <strong>CMAKE_INSTALL_PREFIX</strong> variable. The prefix can be relocated at install time using the <strong>DESTDIR</strong> mechanism explained in the <strong>CMAKE_INSTALL_PREFIX</strong> variable documentation.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PERMISSIONS</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Specify permissions for installed files.  Valid permissions are <strong>OWNER_READ</strong>, <strong>OWNER_WRITE</strong>, <strong>OWNER_EXECUTE</strong>, <strong>GROUP_READ</strong>, <strong>GROUP_WRITE</strong>, <strong>GROUP_EXECUTE</strong>, <strong>WORLD_READ</strong>, <strong>WORLD_WRITE</strong>, <strong>WORLD_EXECUTE</strong>, <strong>SETUID</strong>, and <strong>SETGID</strong>.  Permissions that do not make sense on certain platforms are ignored on those platforms.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>CONFIGURATIONS</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Specify a list of build configurations for which the install rule applies (Debug, Release, etc.).</p>
  </dd>
  <dt>
    <p><strong></strong><strong>COMPONENT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Specify an installation component name with which the install rule is associated, such as "runtime" or "development".  During component-specific installation only install rules associated with the given component name will be executed.  During a full installation all components are installed.  If <strong>COMPONENT</strong> is not provided a default component "Unspecified" is created.  The default component name may be controlled with the <strong>CMAKE_INSTALL_DEFAULT_COMPONENT_NAME</strong> variable.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>RENAME</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Specify a name for an installed file that may be different from the original file.  Renaming is allowed only when a single file is installed by the command.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>OPTIONAL</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Specify that it is not an error if the file to be installed does not exist.</p><p>----</p>
<pre>
install(TARGETS targets... [EXPORT &lt;export-name&gt;]
        [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE|
          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
         [DESTINATION &lt;dir&gt;]
         [INCLUDES DESTINATION [&lt;dir&gt; ...]]
         [PERMISSIONS permissions...]
         [CONFIGURATIONS [Debug|Release|...]]
         [COMPONENT &lt;component&gt;]
         [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP]
        ] [...])
</pre>
<p>The <strong>TARGETS</strong> form specifies rules for installing targets from a project.  There are five kinds of target files that may be installed: <strong>ARCHIVE</strong>, <strong>LIBRARY</strong>, <strong>RUNTIME</strong>, <strong>FRAMEWORK</strong>, and <strong>BUNDLE</strong>. Executables are treated as <strong>RUNTIME</strong> targets, except that those marked with the <strong>MACOSX_BUNDLE</strong> property are treated as <strong>BUNDLE</strong> targets on OS X.  Static libraries are always treated as <strong>ARCHIVE</strong> targets.  Module libraries are always treated as <strong>LIBRARY</strong> targets. For non-DLL platforms shared libraries are treated as <strong>LIBRARY</strong> targets, except that those marked with the <strong>FRAMEWORK</strong> property are treated as <strong>FRAMEWORK</strong> targets on OS X.  For DLL platforms the DLL part of a shared library is treated as a <strong>RUNTIME</strong> target and the corresponding import library is treated as an <strong>ARCHIVE</strong> target. All Windows-based systems including Cygwin are DLL platforms. The <strong>ARCHIVE</strong>, <strong>LIBRARY</strong>, <strong>RUNTIME</strong>, and <strong>FRAMEWORK</strong> arguments change the type of target to which the subsequent properties apply. If none is given the installation properties apply to all target types.  If only one is given then only targets of that type will be installed (which can be used to install just a DLL or just an import library).  The <strong>INCLUDES DESTINATION</strong> specifies a list of directories which will be added to the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> target property of the <strong>&lt;targets&gt;</strong> when exported by the <strong>install(EXPORT)</strong> command.  If a relative path is specified, it is treated as relative to the <strong>$&lt;INSTALL_PREFIX&gt;</strong>.</p><p>The <strong>PRIVATE_HEADER</strong>, <strong>PUBLIC_HEADER</strong>, and <strong>RESOURCE</strong> arguments cause subsequent properties to be applied to installing a <strong>FRAMEWORK</strong> shared library target&apos;s associated files on non-Apple platforms.  Rules defined by these arguments are ignored on Apple platforms because the associated files are installed into the appropriate locations inside the framework folder.  See documentation of the <strong>PRIVATE_HEADER</strong>, <strong>PUBLIC_HEADER</strong>, and <strong>RESOURCE</strong> target properties for details.</p><p>Either <strong>NAMELINK_ONLY</strong> or <strong>NAMELINK_SKIP</strong> may be specified as a <strong>LIBRARY</strong> option.  On some platforms a versioned shared library has a symbolic link such as:</p>
<pre>
lib&lt;name&gt;.so -&gt; lib&lt;name&gt;.so.1
</pre>
<p>where <strong>lib&lt;name&gt;.so.1</strong> is the soname of the library and <strong>lib&lt;name&gt;.so</strong> is a "namelink" allowing linkers to find the library when given <strong>-l&lt;name&gt;</strong>.  The <strong>NAMELINK_ONLY</strong> option causes installation of only the namelink when a library target is installed.  The <strong>NAMELINK_SKIP</strong> option causes installation of library files other than the namelink when a library target is installed.  When neither option is given both portions are installed.  On platforms where versioned shared libraries do not have namelinks or when a library is not versioned the <strong>NAMELINK_SKIP</strong> option installs the library and the <strong>NAMELINK_ONLY</strong> option installs nothing.  See the <strong>VERSION</strong> and <strong>SOVERSION</strong> target properties for details on creating versioned shared libraries.</p><p>One or more groups of properties may be specified in a single call to the <strong>TARGETS</strong> form of this command.  A target may be installed more than once to different locations.  Consider hypothetical targets <strong>myExe</strong>, <strong>mySharedLib</strong>, and <strong>myStaticLib</strong>.  The code:</p>
<pre>
install(TARGETS myExe mySharedLib myStaticLib
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib/static)
install(TARGETS mySharedLib DESTINATION /some/full/path)
</pre>
<p>will install <strong>myExe</strong> to <strong>&lt;prefix&gt;/bin</strong> and <strong>myStaticLib</strong> to <strong>&lt;prefix&gt;/lib/static</strong>.  On non-DLL platforms <strong>mySharedLib</strong> will be installed to <strong>&lt;prefix&gt;/lib</strong> and <strong>/some/full/path</strong>.  On DLL platforms the <strong>mySharedLib</strong> DLL will be installed to <strong>&lt;prefix&gt;/bin</strong> and <strong>/some/full/path</strong> and its import library will be installed to <strong>&lt;prefix&gt;/lib/static</strong> and <strong>/some/full/path</strong>.</p><p>The <strong>EXPORT</strong> option associates the installed target files with an export called <strong>&lt;export-name&gt;</strong>.  It must appear before any <strong>RUNTIME</strong>, <strong>LIBRARY</strong>, or <strong>ARCHIVE</strong> options.  To actually install the export file itself, call <strong>install(EXPORT)</strong>, documented below.</p><p>Installing a target with the <strong>EXCLUDE_FROM_ALL</strong> target property set to <strong>TRUE</strong> has undefined behavior.</p><p>----</p>
<pre>
install(&lt;FILES|PROGRAMS&gt; files... DESTINATION &lt;dir&gt;
        [PERMISSIONS permissions...]
        [CONFIGURATIONS [Debug|Release|...]]
        [COMPONENT &lt;component&gt;]
        [RENAME &lt;name&gt;] [OPTIONAL])
</pre>
<p>The <strong>FILES</strong> form specifies rules for installing files for a project. File names given as relative paths are interpreted with respect to the current source directory.  Files installed by this form are by default given permissions <strong>OWNER_WRITE</strong>, <strong>OWNER_READ</strong>, <strong>GROUP_READ</strong>, and <strong>WORLD_READ</strong> if no <strong>PERMISSIONS</strong> argument is given.</p><p>The <strong>PROGRAMS</strong> form is identical to the <strong>FILES</strong> form except that the default permissions for the installed file also include <strong>OWNER_EXECUTE</strong>, <strong>GROUP_EXECUTE</strong>, and <strong>WORLD_EXECUTE</strong>.  This form is intended to install programs that are not targets, such as shell scripts.  Use the <strong>TARGETS</strong> form to install targets built within the project.</p><p>The list of <strong>files...</strong> given to <strong>FILES</strong> or <strong>PROGRAMS</strong> may use "generator expressions" with the syntax <strong>$&lt;...&gt;</strong>.  See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions. However, if any item begins in a generator expression it must evaluate to a full path.</p><p>----</p>
<pre>
install(DIRECTORY dirs... DESTINATION &lt;dir&gt;
        [FILE_PERMISSIONS permissions...]
        [DIRECTORY_PERMISSIONS permissions...]
        [USE_SOURCE_PERMISSIONS] [OPTIONAL]
        [CONFIGURATIONS [Debug|Release|...]]
        [COMPONENT &lt;component&gt;] [FILES_MATCHING]
        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]
         [EXCLUDE] [PERMISSIONS permissions...]] [...])
</pre>
<p>The <strong>DIRECTORY</strong> form installs contents of one or more directories to a given destination.  The directory structure is copied verbatim to the destination.  The last component of each directory name is appended to the destination directory but a trailing slash may be used to avoid this because it leaves the last component empty.  Directory names given as relative paths are interpreted with respect to the current source directory.  If no input directory names are given the destination directory will be created but nothing will be installed into it.  The <strong>FILE_PERMISSIONS</strong> and <strong>DIRECTORY_PERMISSIONS</strong> options specify permissions given to files and directories in the destination. If <strong>USE_SOURCE_PERMISSIONS</strong> is specified and <strong>FILE_PERMISSIONS</strong> is not, file permissions will be copied from the source directory structure. If no permissions are specified files will be given the default permissions specified in the <strong>FILES</strong> form of the command, and the directories will be given the default permissions specified in the <strong>PROGRAMS</strong> form of the command.</p><p>Installation of directories may be controlled with fine granularity using the <strong>PATTERN</strong> or <strong>REGEX</strong> options.  These "match" options specify a globbing pattern or regular expression to match directories or files encountered within input directories.  They may be used to apply certain options (see below) to a subset of the files and directories encountered.  The full path to each input file or directory (with forward slashes) is matched against the expression.  A <strong>PATTERN</strong> will match only complete file names: the portion of the full path matching the pattern must occur at the end of the file name and be preceded by a slash.  A <strong>REGEX</strong> will match any portion of the full path but it may use <strong>/</strong> and <strong>$</strong> to simulate the <strong>PATTERN</strong> behavior.  By default all files and directories are installed whether or not they are matched. The <strong>FILES_MATCHING</strong> option may be given before the first match option to disable installation of files (but not directories) not matched by any expression.  For example, the code</p>
<pre>
install(DIRECTORY src/ DESTINATION include/myproj
        FILES_MATCHING PATTERN "*.h")
</pre>
<p>will extract and install header files from a source tree.</p><p>Some options may follow a <strong>PATTERN</strong> or <strong>REGEX</strong> expression and are applied only to files or directories matching them.  The <strong>EXCLUDE</strong> option will skip the matched file or directory.  The <strong>PERMISSIONS</strong> option overrides the permissions setting for the matched file or directory.  For example the code</p>
<pre>
install(DIRECTORY icons scripts/ DESTINATION share/myproj
        PATTERN "CVS" EXCLUDE
        PATTERN "scripts/*"
        PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                    GROUP_EXECUTE GROUP_READ)
</pre>
<p>will install the <strong>icons</strong> directory to <strong>share/myproj/icons</strong> and the <strong>scripts</strong> directory to <strong>share/myproj</strong>.  The icons will get default file permissions, the scripts will be given specific permissions, and any <strong>CVS</strong> directories will be excluded.</p><p>----</p>
<pre>
install([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]] [...])
</pre>
<p>The <strong>SCRIPT</strong> form will invoke the given CMake script files during installation.  If the script file name is a relative path it will be interpreted with respect to the current source directory.  The <strong>CODE</strong> form will invoke the given CMake code during installation.  Code is specified as a single argument inside a double-quoted string.  For example, the code</p>
<pre>
install(CODE "MESSAGE(&#92;"Sample install message.&#92;")")
</pre>
<p>will print a message during installation.</p><p>----</p>
<pre>
install(EXPORT &lt;export-name&gt; DESTINATION &lt;dir&gt;
        [NAMESPACE &lt;namespace&gt;] [FILE &lt;name&gt;.cmake]
        [PERMISSIONS permissions...]
        [CONFIGURATIONS [Debug|Release|...]]
        [EXPORT_LINK_INTERFACE_LIBRARIES]
        [COMPONENT &lt;component&gt;])
</pre>
<p>The <strong>EXPORT</strong> form generates and installs a CMake file containing code to import targets from the installation tree into another project. Target installations are associated with the export <strong>&lt;export-name&gt;</strong> using the <strong>EXPORT</strong> option of the <strong>install(TARGETS)</strong> signature documented above.  The <strong>NAMESPACE</strong> option will prepend <strong>&lt;namespace&gt;</strong> to the target names as they are written to the import file.  By default the generated file will be called <strong>&lt;export-name&gt;.cmake</strong> but the <strong>FILE</strong> option may be used to specify a different name.  The value given to the <strong>FILE</strong> option must be a file name with the <strong>.cmake</strong> extension. If a <strong>CONFIGURATIONS</strong> option is given then the file will only be installed when one of the named configurations is installed.  Additionally, the generated import file will reference only the matching target configurations.  The <strong>EXPORT_LINK_INTERFACE_LIBRARIES</strong> keyword, if present, causes the contents of the properties matching <strong>(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)?</strong> to be exported, when policy <strong>CMP0022</strong> is <strong>NEW</strong>.  If a <strong>COMPONENT</strong> option is specified that does not match that given to the targets associated with <strong>&lt;export-name&gt;</strong> the behavior is undefined.  If a library target is included in the export but a target to which it links is not included the behavior is unspecified.</p><p>The <strong>EXPORT</strong> form is useful to help outside projects use targets built and installed by the current project.  For example, the code</p>
<pre>
install(TARGETS myexe EXPORT myproj DESTINATION bin)
install(EXPORT myproj NAMESPACE mp_ DESTINATION lib/myproj)
</pre>
<p>will install the executable myexe to <strong>&lt;prefix&gt;/bin</strong> and code to import it in the file <strong>&lt;prefix&gt;/lib/myproj/myproj.cmake</strong>.  An outside project may load this file with the include command and reference the <strong>myexe</strong> executable from the installation tree using the imported target name <strong>mp_myexe</strong> as if the target were built in its own tree.</p><p><strong>NOTE:</strong> This command supercedes the <strong>install_targets()</strong> command and the <strong>PRE_INSTALL_SCRIPT</strong> and <strong>POST_INSTALL_SCRIPT</strong> target properties.  It also replaces the <strong>FILES</strong> forms of the <strong>install_files()</strong> and <strong>install_programs()</strong> commands. The processing order of these install rules relative to those generated by <strong>install_targets()</strong>, <strong>install_files()</strong>, and <strong>install_programs()</strong> commands is not defined.</p>
  </dd>

</dl>

<h3>link_directories</h3>
<p>Specify directories in which the linker will look for libraries.</p>
<pre>
link_directories(directory1 directory2 ...)
</pre>
<p>Specify the paths in which the linker should search for libraries. The command will apply only to targets created after it is called. Relative paths given to this command are interpreted as relative to the current source directory, see CMP0015.</p><p>Note that this command is rarely necessary.  Library locations returned by find_package() and find_library() are absolute paths. Pass these absolute library file paths directly to the target_link_libraries() command.  CMake will ensure the linker finds them.</p>
<h3>list</h3>
<p>List operations.</p>
<pre>
list(LENGTH &lt;list&gt; &lt;output variable&gt;)
list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...]
     &lt;output variable&gt;)
list(APPEND &lt;list&gt; [&lt;element&gt; ...])
list(FIND &lt;list&gt; &lt;value&gt; &lt;output variable&gt;)
list(INSERT &lt;list&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])
list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])
list(REMOVE_AT &lt;list&gt; &lt;index&gt; [&lt;index&gt; ...])
list(REMOVE_DUPLICATES &lt;list&gt;)
list(REVERSE &lt;list&gt;)
list(SORT &lt;list&gt;)
</pre>
<p>LENGTH will return a given list&apos;s length.</p><p>GET will return list of elements specified by indices from the list.</p><p>APPEND will append elements to the list.</p><p>FIND will return the index of the element specified in the list or -1 if it wasn&apos;t found.</p><p>INSERT will insert elements to the list to the specified location.</p><p>REMOVE_AT and REMOVE_ITEM will remove items from the list.  The difference is that REMOVE_ITEM will remove the given items, while REMOVE_AT will remove the items at the given indices.</p><p>REMOVE_DUPLICATES will remove duplicated items in the list.</p><p>REVERSE reverses the contents of the list in-place.</p><p>SORT sorts the list in-place alphabetically.</p><p>The list subcommands APPEND, INSERT, REMOVE_AT, REMOVE_ITEM, REMOVE_DUPLICATES, REVERSE and SORT may create new values for the list within the current CMake variable scope.  Similar to the SET command, the LIST command creates new variable values in the current scope, even if the list itself is actually defined in a parent scope.  To propagate the results of these operations upwards, use SET with PARENT_SCOPE, SET with CACHE INTERNAL, or some other means of value propagation.</p><p>NOTES: A list in cmake is a ; separated group of strings.  To create a list the set command can be used.  For example, set(var a b c d e) creates a list with a;b;c;d;e, and set(var "a b c d e") creates a string or a list with one item in it.   (Note macro arguments are not variables, and therefore cannot be used in LIST commands.)</p><p>When specifying index values, if &lt;element index&gt; is 0 or greater, it is indexed from the beginning of the list, with 0 representing the first list element.  If &lt;element index&gt; is -1 or lesser, it is indexed from the end of the list, with -1 representing the last list element. Be careful when counting with negative indices: they do not start from 0.  -0 is equivalent to 0, the first list element.</p>
<h3>load_cache</h3>
<p>Load in the values from another project&apos;s CMake cache.</p>
<pre>
load_cache(pathToCacheFile READ_WITH_PREFIX
           prefix entry1...)
</pre>
<p>Read the cache and store the requested entries in variables with their name prefixed with the given prefix.  This only reads the values, and does not create entries in the local project&apos;s cache.</p>
<pre>
load_cache(pathToCacheFile [EXCLUDE entry1...]
           [INCLUDE_INTERNALS entry1...])
</pre>
<p>Load in the values from another cache and store them in the local project&apos;s cache as internal entries.  This is useful for a project that depends on another project built in a different tree.  EXCLUDE option can be used to provide a list of entries to be excluded. INCLUDE_INTERNALS can be used to provide a list of internal entries to be included.  Normally, no internal entries are brought in.  Use of this form of the command is strongly discouraged, but it is provided for backward compatibility.</p>
<h3>load_command</h3>
<p>Disallowed.  See CMake Policy <strong>CMP0031</strong>.</p><p>Load a command into a running CMake.</p>
<pre>
load_command(COMMAND_NAME &lt;loc1&gt; [loc2 ...])
</pre>
<p>The given locations are searched for a library whose name is cmCOMMAND_NAME.  If found, it is loaded as a module and the command is added to the set of available CMake commands.  Usually, TRY_COMPILE is used before this command to compile the module.  If the command is successfully loaded a variable named</p>
<pre>
CMAKE_LOADED_COMMAND_&lt;COMMAND_NAME&gt;
</pre>
<p>will be set to the full path of the module that was loaded.  Otherwise the variable will not be set.</p>
<h3>macro</h3>
<p>Start recording a macro for later invocation as a command.</p>
<pre>
macro(&lt;name&gt; [arg1 [arg2 [arg3 ...]]])
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endmacro(&lt;name&gt;)
</pre>
<p>Define a macro named &lt;name&gt; that takes arguments named arg1 arg2 arg3 (...).  Commands listed after macro, but before the matching endmacro, are not invoked until the macro is invoked.  When it is invoked, the commands recorded in the macro are first modified by replacing formal parameters (<strong>${arg1}</strong>) with the arguments passed, and then invoked as normal commands.  In addition to referencing the formal parameters you can reference the values <strong>${ARGC}</strong> which will be set to the number of arguments passed into the function as well as <strong>${ARGV0}</strong> <strong>${ARGV1}</strong> <strong>${ARGV2}</strong> ...  which will have the actual values of the arguments passed in.  This facilitates creating macros with optional arguments. Additionally <strong>${ARGV}</strong> holds the list of all arguments given to the macro and <strong>${ARGN}</strong> holds the list of arguments past the last expected argument.</p><p>See the cmake_policy() command documentation for the behavior of policies inside macros.</p>
<h3>Macro Argument Caveats</h3>
<p>Note that the parameters to a macro and values such as <strong>ARGN</strong> are not variables in the usual CMake sense.  They are string replacements much like the C preprocessor would do with a macro. Therefore you will NOT be able to use commands like:</p>
<pre>
if(ARGV1) # ARGV1 is not a variable
foreach(loop_var IN LISTS ARGN) # ARGN is not a variable
</pre>
<p>In the first case you can use <strong>if(${ARGV1})</strong>, in the second case, you can use <strong>foreach(loop_var ${ARGN})</strong> but this will skip empty arguments. If you need to include them, you can use:</p>
<pre>
set(list_var "${ARGN}")
foreach(loop_var IN LISTS list_var)
</pre>
<p>Note that if you have a variable with the same name in the scope from which the macro is called, using unreferenced names will use the existing variable instead of the arguments. For example:</p>
<pre>
macro(_BAR)
  foreach(arg IN LISTS ARGN)
    [...]
  endforeach()
endmacro()

function(_FOO)
  _bar(x y z)
endfunction()

_foo(a b c)
</pre>
<p>Will loop over <strong>a;b;c</strong> and not over <strong>x;y;z</strong> as one might be expecting. If you want true CMake variables and/or better CMake scope control you should look at the function command.</p>
<h3>mark_as_advanced</h3>
<p>Mark cmake cached variables as advanced.</p>
<pre>
mark_as_advanced([CLEAR|FORCE] VAR [VAR2 ...])
</pre>
<p>Mark the named cached variables as advanced.  An advanced variable will not be displayed in any of the cmake GUIs unless the show advanced option is on.  If CLEAR is the first argument advanced variables are changed back to unadvanced.  If FORCE is the first argument, then the variable is made advanced.  If neither FORCE nor CLEAR is specified, new values will be marked as advanced, but if the variable already has an advanced/non-advanced state, it will not be changed.</p><p>It does nothing in script mode.</p>
<h3>math</h3>
<p>Mathematical expressions.</p>
<pre>
math(EXPR &lt;output variable&gt; &lt;math expression&gt;)
</pre>
<p>EXPR evaluates mathematical expression and returns result in the output variable.  Example mathematical expression is &apos;5 * ( 10 + 13 )&apos;.  Supported operators are + - * / % | & ^ ~ &lt;&lt; &gt;&gt; * / %.  They have the same meaning as they do in C code.</p>
<h3>message</h3>
<p>Display a message to the user.</p>
<pre>
message([&lt;mode&gt;] "message to display" ...)
</pre>
<p>The optional &lt;mode&gt; keyword determines the type of message:</p>
<pre>
(none)         = Important information
STATUS         = Incidental information
WARNING        = CMake Warning, continue processing
AUTHOR_WARNING = CMake Warning (dev), continue processing
SEND_ERROR     = CMake Error, continue processing,
                              but skip generation
FATAL_ERROR    = CMake Error, stop processing and generation
DEPRECATION    = CMake Deprecation Error or Warning if variable
                 CMAKE_ERROR_DEPRECATED or CMAKE_WARN_DEPRECATED
                 is enabled, respectively, else no message.
</pre>
<p>The CMake command-line tool displays STATUS messages on stdout and all other message types on stderr.  The CMake GUI displays all messages in its log area.  The interactive dialogs (ccmake and CMakeSetup) show STATUS messages one at a time on a status line and other messages in interactive pop-up boxes.</p><p>CMake Warning and Error message text displays using a simple markup language.  Non-indented text is formatted in line-wrapped paragraphs delimited by newlines.  Indented text is considered pre-formatted.</p>
<h3>option</h3>
<p>Provides an option that the user can optionally select.</p>
<pre>
option(&lt;option_variable&gt; "help string describing option"
       [initial value])
</pre>
<p>Provide an option for the user to select as ON or OFF.  If no initial value is provided, OFF is used.</p><p>If you have options that depend on the values of other options, see the module help for CMakeDependentOption.</p>
<h3>project</h3>
<p>Set a name, version, and enable languages for the entire project.</p>
<pre>
project(&lt;PROJECT-NAME&gt; [LANGUAGES] [&lt;language-name&gt;...])
project(&lt;PROJECT-NAME&gt;
        [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]
        [LANGUAGES &lt;language-name&gt;...])
</pre>
<p>Sets the name of the project and stores the name in the <strong>PROJECT_NAME</strong> variable.  Additionally this sets variables</p><ul>
<li><p><strong>PROJECT_SOURCE_DIR</strong>, <strong>&lt;PROJECT-NAME&gt;_SOURCE_DIR</strong></p></li><li><p><strong>PROJECT_BINARY_DIR</strong>, <strong>&lt;PROJECT-NAME&gt;_BINARY_DIR</strong></p><p>If <strong>VERSION</strong> is specified, given components must be non-negative integers. If <strong>VERSION</strong> is not specified, the default version is the empty string. The <strong>VERSION</strong> option may not be used unless policy <strong>CMP0048</strong> is set to <strong>NEW</strong>.</p><p>The <strong>project()</strong> command stores the version number and its components in variables</p></li><li><p><strong>PROJECT_VERSION</strong>, <strong>&lt;PROJECT-NAME&gt;_VERSION</strong></p></li><li><p><strong>PROJECT_VERSION_MAJOR</strong>, <strong>&lt;PROJECT-NAME&gt;_VERSION_MAJOR</strong></p></li><li><p><strong>PROJECT_VERSION_MINOR</strong>, <strong>&lt;PROJECT-NAME&gt;_VERSION_MINOR</strong></p></li><li><p><strong>PROJECT_VERSION_PATCH</strong>, <strong>&lt;PROJECT-NAME&gt;_VERSION_PATCH</strong></p></li><li><p><strong>PROJECT_VERSION_TWEAK</strong>, <strong>&lt;PROJECT-NAME&gt;_VERSION_TWEAK</strong></p><p>Variables corresponding to unspecified versions are set to the empty string (if policy <strong>CMP0048</strong> is set to <strong>NEW</strong>).</p><p>Optionally you can specify which languages your project supports. Example languages are <strong>C</strong>, <strong>CXX</strong> (i.e.  C++), <strong>Fortran</strong>, etc. By default <strong>C</strong> and <strong>CXX</strong> are enabled if no language options are given.  Specify language <strong>NONE</strong>, or use the <strong>LANGUAGES</strong> keyword and list no languages, to skip enabling any languages.</p><p>If a variable exists called <strong>CMAKE_PROJECT_&lt;PROJECT-NAME&gt;_INCLUDE</strong>, the file pointed to by that variable will be included as the last step of the project command.</p><p>The top-level <strong>CMakeLists.txt</strong> file for a project must contain a literal, direct call to the <strong>project()</strong> command; loading one through the <strong>include()</strong> command is not sufficient.  If no such call exists CMake will implicitly add one to the top that enables the default languages (<strong>C</strong> and <strong>CXX</strong>).</p></li>
</ul>
<h3>qt_wrap_cpp</h3>
<p>Create Qt Wrappers.</p>
<pre>
qt_wrap_cpp(resultingLibraryName DestName
            SourceLists ...)
</pre>
<p>Produce moc files for all the .h files listed in the SourceLists.  The moc files will be added to the library using the DestName source list.</p>
<h3>qt_wrap_ui</h3>
<p>Create Qt user interfaces Wrappers.</p>
<pre>
qt_wrap_ui(resultingLibraryName HeadersDestName
           SourcesDestName SourceLists ...)
</pre>
<p>Produce .h and .cxx files for all the .ui files listed in the SourceLists.  The .h files will be added to the library using the HeadersDestNamesource list.  The .cxx files will be added to the library using the SourcesDestNamesource list.</p>
<h3>remove_definitions</h3>
<p>Removes -D define flags added by add_definitions.</p>
<pre>
remove_definitions(-DFOO -DBAR ...)
</pre>
<p>Removes flags (added by add_definitions) from the compiler command line for sources in the current directory and below.</p>
<h3>return</h3>
<p>Return from a file, directory or function.</p>
<pre>
return()
</pre>
<p>Returns from a file, directory or function.  When this command is encountered in an included file (via include() or find_package()), it causes processing of the current file to stop and control is returned to the including file.  If it is encountered in a file which is not included by another file, e.g.  a CMakeLists.txt, control is returned to the parent directory if there is one.  If return is called in a function, control is returned to the caller of the function.  Note that a macro is not a function and does not handle return like a function does.</p>
<h3>separate_arguments</h3>
<p>Parse space-separated arguments into a semicolon-separated list.</p>
<pre>
separate_arguments(&lt;var&gt; &lt;UNIX|WINDOWS&gt;_COMMAND "&lt;args&gt;")
</pre>
<p>Parses a unix- or windows-style command-line string "&lt;args&gt;" and stores a semicolon-separated list of the arguments in &lt;var&gt;.  The entire command line must be given in one "&lt;args&gt;" argument.</p><p>The UNIX_COMMAND mode separates arguments by unquoted whitespace.  It recognizes both single-quote and double-quote pairs.  A backslash escapes the next literal character (" is "); there are no special escapes (n is just n).</p><p>The WINDOWS_COMMAND mode parses a windows command-line using the same syntax the runtime library uses to construct argv at startup.  It separates arguments by whitespace that is not double-quoted. Backslashes are literal unless they precede double-quotes.  See the MSDN article "Parsing C Command-Line Arguments" for details.</p>
<pre>
separate_arguments(VARIABLE)
</pre>
<p>Convert the value of VARIABLE to a semi-colon separated list.  All spaces are replaced with &apos;;&apos;.  This helps with generating command lines.</p>
<h3>set_directory_properties</h3>
<p>Set a property of the directory.</p>
<pre>
set_directory_properties(PROPERTIES prop1 value1 prop2 value2)
</pre>
<p>Set a property for the current directory and subdirectories.  If the property is not found, CMake will report an error.  The properties include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES, INCLUDE_REGULAR_EXPRESSION, and ADDITIONAL_MAKE_CLEAN_FILES. ADDITIONAL_MAKE_CLEAN_FILES is a list of files that will be cleaned as a part of "make clean" stage.</p>
<h3>set_property</h3>
<p>Set a named property in a given scope.</p>
<pre>
set_property(&lt;GLOBAL                            |
              DIRECTORY [dir]                   |
              TARGET    [target1 [target2 ...]] |
              SOURCE    [src1 [src2 ...]]       |
              TEST      [test1 [test2 ...]]     |
              CACHE     [entry1 [entry2 ...]]&gt;
             [APPEND] [APPEND_STRING]
             PROPERTY &lt;name&gt; [value1 [value2 ...]])
</pre>
<p>Set one property on zero or more objects of a scope.  The first argument determines the scope in which the property is set.  It must be one of the following:</p><p>GLOBAL scope is unique and does not accept a name.</p><p>DIRECTORY scope defaults to the current directory but another directory (already processed by CMake) may be named by full or relative path.</p><p>TARGET scope may name zero or more existing targets.</p><p>SOURCE scope may name zero or more source files.  Note that source file properties are visible only to targets added in the same directory (CMakeLists.txt).</p><p>TEST scope may name zero or more existing tests.</p><p>CACHE scope must name zero or more cache existing entries.</p><p>The required PROPERTY option is immediately followed by the name of the property to set.  Remaining arguments are used to compose the property value in the form of a semicolon-separated list.  If the APPEND option is given the list is appended to any existing property value.If the APPEND_STRING option is given the string is append to any existing property value as string, i.e.  it results in a longer string and not a list of strings.</p>
<h3>set</h3>
<p>Set a CMake, cache or environment variable to a given value.</p>
<pre>
set(&lt;variable&gt; &lt;value&gt;
    [[CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]] | PARENT_SCOPE])
</pre>
<p>Within CMake sets &lt;variable&gt; to the value &lt;value&gt;.  &lt;value&gt; is expanded before &lt;variable&gt; is set to it.  Normally, set will set a regular CMake variable.  If CACHE is present, then the &lt;variable&gt; is put in the cache instead, unless it is already in the cache.  See section &apos;Variable types in CMake&apos; below for details of regular and cache variables and their interactions.  If CACHE is used, &lt;type&gt; and &lt;docstring&gt; are required.  &lt;type&gt; is used by the CMake GUI to choose a widget with which the user sets a value.  The value for &lt;type&gt; may be one of</p>
<pre>
FILEPATH = File chooser dialog.
PATH     = Directory chooser dialog.
STRING   = Arbitrary string.
BOOL     = Boolean ON/OFF checkbox.
INTERNAL = No GUI entry (used for persistent variables).
</pre>
<p>If &lt;type&gt; is INTERNAL, the cache variable is marked as internal, and will not be shown to the user in tools like cmake-gui.  This is intended for values that should be persisted in the cache, but which users should not normally change.  INTERNAL implies FORCE.</p><p>Normally, set(...CACHE...) creates cache variables, but does not modify them.  If FORCE is specified, the value of the cache variable is set, even if the variable is already in the cache.  This should normally be avoided, as it will remove any changes to the cache variable&apos;s value by the user.</p><p>If PARENT_SCOPE is present, the variable will be set in the scope above the current scope.  Each new directory or function creates a new scope.  This command will set the value of a variable into the parent directory or calling function (whichever is applicable to the case at hand).  PARENT_SCOPE cannot be combined with CACHE.</p><p>If &lt;value&gt; is not specified then the variable is removed instead of set.  See also: the unset() command.</p>
<pre>
set(&lt;variable&gt; &lt;value1&gt; ... &lt;valueN&gt;)
</pre>
<p>In this case &lt;variable&gt; is set to a semicolon separated list of values.</p><p>&lt;variable&gt; can be an environment variable such as:</p>
<pre>
set( ENV{PATH} /home/martink )
</pre>
<p>in which case the environment variable will be set.</p><p><strong>* Variable types in CMake *</strong></p><p>In CMake there are two types of variables: normal variables and cache variables.  Normal variables are meant for the internal use of the script (just like variables in most programming languages); they are not persisted across CMake runs.  Cache variables (unless set with INTERNAL) are mostly intended for configuration settings where the first CMake run determines a suitable default value, which the user can then override, by editing the cache with tools such as ccmake or cmake-gui.  Cache variables are stored in the CMake cache file, and are persisted across CMake runs.</p><p>Both types can exist at the same time with the same name but different values.  When ${FOO} is evaluated, CMake first looks for a normal variable &apos;FOO&apos; in scope and uses it if set.  If and only if no normal variable exists then it falls back to the cache variable &apos;FOO&apos;.</p><p>Some examples:</p><p>The code &apos;set(FOO "x")&apos; sets the normal variable &apos;FOO&apos;.  It does not touch the cache, but it will hide any existing cache value &apos;FOO&apos;.</p><p>The code &apos;set(FOO "x" CACHE ...)&apos; checks for &apos;FOO&apos; in the cache, ignoring any normal variable of the same name.  If &apos;FOO&apos; is in the cache then nothing happens to either the normal variable or the cache variable.  If &apos;FOO&apos; is not in the cache, then it is added to the cache.</p><p>Finally, whenever a cache variable is added or modified by a command, CMake also <em>removes</em> the normal variable of the same name from the current scope so that an immediately following evaluation of it will expose the newly cached value.</p><p>Normally projects should avoid using normal and cache variables of the same name, as this interaction can be hard to follow.  However, in some situations it can be useful.  One example (used by some projects):</p><p>A project has a subproject in its source tree.  The child project has its own CMakeLists.txt, which is included from the parent CMakeLists.txt using add_subdirectory().  Now, if the parent and the child project provide the same option (for example a compiler option), the parent gets the first chance to add a user-editable option to the cache.  Normally, the child would then use the same value that the parent uses.  However, it may be necessary to hard-code the value for the child project&apos;s option while still allowing the user to edit the value used by the parent project.  The parent project can achieve this simply by setting a normal variable with the same name as the option in a scope sufficient to hide the option&apos;s cache variable from the child completely.  The parent has already set the cache variable, so the child&apos;s set(...CACHE...) will do nothing, and evaluating the option variable will use the value from the normal variable, which hides the cache variable.</p>
<h3>set_source_files_properties</h3>
<p>Source files can have properties that affect how they are built.</p>
<pre>
set_source_files_properties([file1 [file2 [...]]]
                            PROPERTIES prop1 value1
                            [prop2 value2 [...]])
</pre>
<p>Set properties associated with source files using a key/value paired list.  See properties documentation for those known to CMake. Unrecognized properties are ignored.  Source file properties are visible only to targets added in the same directory (CMakeLists.txt).</p>
<h3>set_target_properties</h3>
<p>Targets can have properties that affect how they are built.</p>
<pre>
set_target_properties(target1 target2 ...
                      PROPERTIES prop1 value1
                      prop2 value2 ...)
</pre>
<p>Set properties on a target.  The syntax for the command is to list all the files you want to change, and then provide the values you want to set next.  You can use any prop value pair you want and extract it later with the GET_TARGET_PROPERTY command.</p><p>Properties that affect the name of a target&apos;s output file are as follows.  The PREFIX and SUFFIX properties override the default target name prefix (such as "lib") and suffix (such as ".so").  IMPORT_PREFIX and IMPORT_SUFFIX are the equivalent properties for the import library corresponding to a DLL (for SHARED library targets).  OUTPUT_NAME sets the real name of a target when it is built and can be used to help create two targets of the same name even though CMake requires unique logical target names.  There is also a &lt;CONFIG&gt;_OUTPUT_NAME that can set the output name on a per-configuration basis.  &lt;CONFIG&gt;_POSTFIX sets a postfix for the real name of the target when it is built under the configuration named by &lt;CONFIG&gt; (in upper-case, such as "DEBUG_POSTFIX").  The value of this property is initialized when the target is created to the value of the variable CMAKE_&lt;CONFIG&gt;_POSTFIX (except for executable targets because earlier CMake versions which did not use this variable for executables).</p><p>The LINK_FLAGS property can be used to add extra flags to the link step of a target.  LINK_FLAGS_&lt;CONFIG&gt; will add to the configuration &lt;CONFIG&gt;, for example, DEBUG, RELEASE, MINSIZEREL, RELWITHDEBINFO. DEFINE_SYMBOL sets the name of the preprocessor symbol defined when compiling sources in a shared library.  If not set here then it is set to target_EXPORTS by default (with some substitutions if the target is not a valid C identifier).  This is useful for headers to know whether they are being included from inside their library or outside to properly setup dllexport/dllimport decorations.  The COMPILE_FLAGS property sets additional compiler flags used to build sources within the target.  It may also be used to pass additional preprocessor definitions.</p><p>The LINKER_LANGUAGE property is used to change the tool used to link an executable or shared library.  The default is set the language to match the files in the library.  CXX and C are common values for this property.</p><p>For shared libraries VERSION and SOVERSION can be used to specify the build version and API version respectively.  When building or installing appropriate symlinks are created if the platform supports symlinks and the linker supports so-names.  If only one of both is specified the missing is assumed to have the same version number.  For executables VERSION can be used to specify the build version.  When building or installing appropriate symlinks are created if the platform supports symlinks.  For shared libraries and executables on Windows the VERSION attribute is parsed to extract a "major.minor" version number.  These numbers are used as the image version of the binary.</p><p>There are a few properties used to specify RPATH rules.  INSTALL_RPATH is a semicolon-separated list specifying the rpath to use in installed targets (for platforms that support it).  INSTALL_RPATH_USE_LINK_PATH is a boolean that if set to true will append directories in the linker search path and outside the project to the INSTALL_RPATH. SKIP_BUILD_RPATH is a boolean specifying whether to skip automatic generation of an rpath allowing the target to run from the build tree. BUILD_WITH_INSTALL_RPATH is a boolean specifying whether to link the target in the build tree with the INSTALL_RPATH.  This takes precedence over SKIP_BUILD_RPATH and avoids the need for relinking before installation.  INSTALL_NAME_DIR is a string specifying the directory portion of the "install_name" field of shared libraries on Mac OSX to use in the installed targets.  When the target is created the values of the variables CMAKE_INSTALL_RPATH, CMAKE_INSTALL_RPATH_USE_LINK_PATH, CMAKE_SKIP_BUILD_RPATH, CMAKE_BUILD_WITH_INSTALL_RPATH, and CMAKE_INSTALL_NAME_DIR are used to initialize these properties.</p><p>PROJECT_LABEL can be used to change the name of the target in an IDE like visual studio.  VS_KEYWORD can be set to change the visual studio keyword, for example Qt integration works better if this is set to Qt4VSv1.0.</p><p>VS_SCC_PROJECTNAME, VS_SCC_LOCALPATH, VS_SCC_PROVIDER and VS_SCC_AUXPATH can be set to add support for source control bindings in a Visual Studio project file.</p><p>VS_GLOBAL_&lt;variable&gt; can be set to add a Visual Studio project-specific global variable.  Qt integration works better if VS_GLOBAL_QtVersion is set to the Qt version FindQt4.cmake found.  For example, "4.7.3"</p><p>The PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT properties are the old way to specify CMake scripts to run before and after installing a target.  They are used only when the old INSTALL_TARGETS command is used to install the target.  Use the INSTALL command instead.</p><p>The EXCLUDE_FROM_DEFAULT_BUILD property is used by the visual studio generators.  If it is set to 1 the target will not be part of the default build when you select "Build Solution".  This can also be set on a per-configuration basis using EXCLUDE_FROM_DEFAULT_BUILD_&lt;CONFIG&gt;.</p>
<h3>set_tests_properties</h3>
<p>Set a property of the tests.</p>
<pre>
set_tests_properties(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)
</pre>
<p>Set a property for the tests.  If the property is not found, CMake will report an error.  Generator expressions will be expanded the same as supported by the test&apos;s add_test call.  The properties include:</p><p>WILL_FAIL: If set to true, this will invert the pass/fail flag of the test.</p><p>PASS_REGULAR_EXPRESSION: If set, the test output will be checked against the specified regular expressions and at least one of the regular expressions has to match, otherwise the test will fail.</p>
<pre>
Example: PASS_REGULAR_EXPRESSION "TestPassed;All ok"
</pre>
<p>FAIL_REGULAR_EXPRESSION: If set, if the output will match to one of specified regular expressions, the test will fail.</p>
<pre>
Example: PASS_REGULAR_EXPRESSION "[^a-z]Error;ERROR;Failed"
</pre>
<p>Both PASS_REGULAR_EXPRESSION and FAIL_REGULAR_EXPRESSION expect a list of regular expressions.</p><p>TIMEOUT: Setting this will limit the test runtime to the number of seconds specified.</p>
<h3>site_name</h3>
<p>Set the given variable to the name of the computer.</p>
<pre>
site_name(variable)
</pre>

<h3>source_group</h3>
<p>Define a grouping for source files in IDE project generation.</p>
<pre>
source_group(&lt;name&gt; [FILES &lt;src&gt;...] [REGULAR_EXPRESSION &lt;regex&gt;])
</pre>
<p>Defines a group into which sources will be placed in project files. This is intended to set up file tabs in Visual Studio. The options are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>FILES</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Any source file specified explicitly will be placed in group <strong>&lt;name&gt;</strong>.  Relative paths are interpreted with respect to the current source directory.</p>
  </dd>
  <dt>
    <p><strong></strong><strong>REGULAR_EXPRESSION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Any source file whose name matches the regular expression will be placed in group <strong>&lt;name&gt;</strong>.</p><p>If a source file matches multiple groups, the <em>last</em> group that explicitly lists the file with <strong>FILES</strong> will be favored, if any. If no group explicitly lists the file, the <em>last</em> group whose regular expression matches the file will be favored.</p><p>The <strong>&lt;name&gt;</strong> of the group may contain backslashes to specify subgroups:</p>
<pre>
source_group(outer&#92;&#92;inner ...)
</pre>
<p>For backwards compatibility, the short-hand signature</p>
<pre>
source_group(&lt;name&gt; &lt;regex&gt;)
</pre>
<p>is equivalent to</p>
<pre>
source_group(&lt;name&gt; REGULAR_EXPRESSION &lt;regex&gt;)
</pre>

  </dd>

</dl>

<h3>string</h3>
<p>String operations.</p>
<pre>
string(REGEX MATCH &lt;regular_expression&gt;
       &lt;output variable&gt; &lt;input&gt; [&lt;input&gt;...])
string(REGEX MATCHALL &lt;regular_expression&gt;
       &lt;output variable&gt; &lt;input&gt; [&lt;input&gt;...])
string(REGEX REPLACE &lt;regular_expression&gt;
       &lt;replace_expression&gt; &lt;output variable&gt;
       &lt;input&gt; [&lt;input&gt;...])
string(REPLACE &lt;match_string&gt;
       &lt;replace_string&gt; &lt;output variable&gt;
       &lt;input&gt; [&lt;input&gt;...])
string(CONCAT &lt;output variable&gt; [&lt;input&gt;...])
string(&lt;MD5|SHA1|SHA224|SHA256|SHA384|SHA512&gt;
       &lt;output variable&gt; &lt;input&gt;)
string(COMPARE EQUAL &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)
string(COMPARE NOTEQUAL &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)
string(COMPARE LESS &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)
string(COMPARE GREATER &lt;string1&gt; &lt;string2&gt; &lt;output variable&gt;)
string(ASCII &lt;number&gt; [&lt;number&gt; ...] &lt;output variable&gt;)
string(CONFIGURE &lt;string1&gt; &lt;output variable&gt;
       [@ONLY] [ESCAPE_QUOTES])
string(TOUPPER &lt;string1&gt; &lt;output variable&gt;)
string(TOLOWER &lt;string1&gt; &lt;output variable&gt;)
string(LENGTH &lt;string&gt; &lt;output variable&gt;)
string(SUBSTRING &lt;string&gt; &lt;begin&gt; &lt;length&gt; &lt;output variable&gt;)
string(STRIP &lt;string&gt; &lt;output variable&gt;)
string(RANDOM [LENGTH &lt;length&gt;] [ALPHABET &lt;alphabet&gt;]
       [RANDOM_SEED &lt;seed&gt;] &lt;output variable&gt;)
string(FIND &lt;string&gt; &lt;substring&gt; &lt;output variable&gt; [REVERSE])
string(TIMESTAMP &lt;output variable&gt; [&lt;format string&gt;] [UTC])
string(MAKE_C_IDENTIFIER &lt;input string&gt; &lt;output variable&gt;)
</pre>
<p>REGEX MATCH will match the regular expression once and store the match in the output variable.</p><p>REGEX MATCHALL will match the regular expression as many times as possible and store the matches in the output variable as a list.</p><p>REGEX REPLACE will match the regular expression as many times as possible and substitute the replacement expression for the match in the output.  The replace expression may refer to paren-delimited subexpressions of the match using 1, 2, ..., 9.  Note that two backslashes (&#92;1) are required in CMake code to get a backslash through argument parsing.</p><p>REPLACE will replace all occurrences of match_string in the input with replace_string and store the result in the output.</p><p>CONCAT will concatenate all the input arguments together and store the result in the named output variable.</p><p>MD5, SHA1, SHA224, SHA256, SHA384, and SHA512 will compute a cryptographic hash of the input string.</p><p>COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare the strings and store true or false in the output variable.</p><p>ASCII will convert all numbers into corresponding ASCII characters.</p><p>CONFIGURE will transform a string like CONFIGURE_FILE transforms a file.</p><p>TOUPPER/TOLOWER will convert string to upper/lower characters.</p><p>LENGTH will return a given string&apos;s length.</p><p>SUBSTRING will return a substring of a given string.  If length is -1 the remainder of the string starting at begin will be returned.</p><p>STRIP will return a substring of a given string with leading and trailing spaces removed.</p><p>RANDOM will return a random string of given length consisting of characters from the given alphabet.  Default length is 5 characters and default alphabet is all numbers and upper and lower case letters. If an integer RANDOM_SEED is given, its value will be used to seed the random number generator.</p><p>FIND will return the position where the given substring was found in the supplied string.  If the REVERSE flag was used, the command will search for the position of the last occurrence of the specified substring.</p><p>The following characters have special meaning in regular expressions:</p>
<pre>
^         Matches at beginning of input
$         Matches at end of input
.         Matches any single character
[ ]       Matches any character(s) inside the brackets
[^ ]      Matches any character(s) not inside the brackets
 -        Inside brackets, specifies an inclusive range between
          characters on either side e.g. [a-f] is [abcdef]
          To match a literal - using brackets, make it the first
          or the last character e.g. [+*/-] matches basic
          mathematical operators.
*         Matches preceding pattern zero or more times
+         Matches preceding pattern one or more times
?         Matches preceding pattern zero or once only
|         Matches a pattern on either side of the |
()        Saves a matched subexpression, which can be referenced
          in the REGEX REPLACE operation. Additionally it is saved
          by all regular expression-related commands, including
          e.g. if( MATCHES ), in the variables CMAKE_MATCH_(0..9).
</pre>
<p><strong>*</strong>, <strong>+</strong> and <strong>?</strong> have higher precedence than concatenation.  | has lower precedence than concatenation.  This means that the regular expression "^ab+d$" matches "abbd" but not "ababd", and the regular expression "^(ab|cd)$" matches "ab" but not "abd".</p><p>TIMESTAMP will write a string representation of the current date and/or time to the output variable.</p><p>Should the command be unable to obtain a timestamp the output variable will be set to the empty string "".</p><p>The optional UTC flag requests the current date/time representation to be in Coordinated Universal Time (UTC) rather than local time.</p><p>The optional &lt;format string&gt; may contain the following format specifiers:</p>
<pre>
%d        The day of the current month (01-31).
%H        The hour on a 24-hour clock (00-23).
%I        The hour on a 12-hour clock (01-12).
%j        The day of the current year (001-366).
%m        The month of the current year (01-12).
%M        The minute of the current hour (00-59).
%S        The second of the current minute.
          60 represents a leap second. (00-60)
%U        The week number of the current year (00-53).
%w        The day of the current week. 0 is Sunday. (0-6)
%y        The last two digits of the current year (00-99)
%Y        The current year.
</pre>
<p>Unknown format specifiers will be ignored and copied to the output as-is.</p><p>If no explicit &lt;format string&gt; is given it will default to:</p>
<pre>
%Y-%m-%dT%H:%M:%S    for local time.
%Y-%m-%dT%H:%M:%SZ   for UTC.
</pre>
<p>MAKE_C_IDENTIFIER will write a string which can be used as an identifier in C.</p>
<h3>target_compile_definitions</h3>
<p>Add compile definitions to a target.</p>
<pre>
target_compile_definitions(&lt;target&gt;
  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]
  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])
</pre>
<p>Specify compile definitions to use when compiling a given &lt;target.  The named <strong>&lt;target&gt;</strong> must have been created by a command such as <strong>add_executable()</strong> or <strong>add_library()</strong> and must not be an <em>Imported Target</em>.</p><p>The <strong>INTERFACE</strong>, <strong>PUBLIC</strong> and <strong>PRIVATE</strong> keywords are required to specify the scope of the following arguments.  <strong>PRIVATE</strong> and <strong>PUBLIC</strong> items will populate the <strong>COMPILE_DEFINITIONS</strong> property of <strong>&lt;target&gt;</strong>. <strong>PUBLIC</strong> and <strong>INTERFACE</strong> items will populate the <strong>INTERFACE_COMPILE_DEFINITIONS</strong> property of <strong>&lt;target&gt;</strong>.  The following arguments specify compile definitions.  Repeated calls for the same <strong>&lt;target&gt;</strong> append items in the order called.</p><p>Arguments to <strong>target_compile_definitions</strong> may use "generator expressions" with the syntax <strong>$&lt;...&gt;</strong>.  See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions.  See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p>
<h3>target_compile_options</h3>
<p>Add compile options to a target.</p>
<pre>
target_compile_options(&lt;target&gt; [BEFORE]
  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]
  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])
</pre>
<p>Specify compile options to use when compiling a given target.  The named <strong>&lt;target&gt;</strong> must have been created by a command such as <strong>add_executable()</strong> or <strong>add_library()</strong> and must not be an <strong>IMPORTED Target</strong>.  If <strong>BEFORE</strong> is specified, the content will be prepended to the property instead of being appended.</p><p>This command can be used to add any options, but alternative commands exist to add preprocessor definitions (<strong>target_compile_definitions()</strong> and <strong>add_definitions()</strong>) or include directories (<strong>target_include_directories()</strong> and <strong>include_directories()</strong>).  See documentation of the <strong>directory</strong> and :prop_tgt:\(ga target &lt;COMPILE_OPTIONS&gt;\(ga <strong>COMPILE_OPTIONS</strong> properties.</p><p>The <strong>INTERFACE</strong>, <strong>PUBLIC</strong> and <strong>PRIVATE</strong> keywords are required to specify the scope of the following arguments.  <strong>PRIVATE</strong> and <strong>PUBLIC</strong> items will populate the <strong>COMPILE_OPTIONS</strong> property of <strong>&lt;target&gt;</strong>.  <strong>PUBLIC</strong> and <strong>INTERFACE</strong> items will populate the <strong>INTERFACE_COMPILE_OPTIONS</strong> property of <strong>&lt;target&gt;</strong>.  The following arguments specify compile options.  Repeated calls for the same <strong>&lt;target&gt;</strong> append items in the order called.</p><p>Arguments to <strong>target_compile_options</strong> may use "generator expressions" with the syntax <strong>$&lt;...&gt;</strong>. See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions.  See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p>
<h3>target_include_directories</h3>
<p>Add include directories to a target.</p>
<pre>
target_include_directories(&lt;target&gt; [SYSTEM] [BEFORE]
  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]
  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])
</pre>
<p>Specify include directories or targets to use when compiling a given target.  The named <strong>&lt;target&gt;</strong> must have been created by a command such as <strong>add_executable()</strong> or <strong>add_library()</strong> and must not be an <strong>IMPORTED</strong> target.</p><p>If <strong>BEFORE</strong> is specified, the content will be prepended to the property instead of being appended.</p><p>The <strong>INTERFACE</strong>, <strong>PUBLIC</strong> and <strong>PRIVATE</strong> keywords are required to specify the scope of the following arguments.  <strong>PRIVATE</strong> and <strong>PUBLIC</strong> items will populate the <strong>INCLUDE_DIRECTORIES</strong> property of <strong>&lt;target&gt;</strong>. <strong>PUBLIC</strong> and <strong>INTERFACE</strong> items will populate the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> property of <strong>&lt;target&gt;</strong>.  The following arguments specify include directories.</p><p>Specified include directories may be absolute paths or relative paths. Repeated calls for the same &lt;target&gt; append items in the order called.  If <strong>SYSTEM</strong> is specified, the compiler will be told the directories are meant as system include directories on some platforms (signalling this setting might achieve effects such as the compiler skipping warnings, or these fixed-install system files not being considered in dependency calculations - see compiler docs).  If <strong>SYSTEM</strong> is used together with <strong>PUBLIC</strong> or <strong>INTERFACE</strong>, the <strong>INTERFACE_SYSTEM_INCLUDE_DIRECTORIES</strong> target property will be populated with the specified directories.</p><p>Arguments to <strong>target_include_directories</strong> may use "generator expressions" with the syntax <strong>$&lt;...&gt;</strong>.  See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions.  See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p><p>Include directories usage requirements commonly differ between the build-tree and the install-tree.  The <strong>BUILD_INTERFACE</strong> and <strong>INSTALL_INTERFACE</strong> generator expressions can be used to describe separate usage requirements based on the usage location.  Relative paths are allowed within the <strong>INSTALL_INTERFACE</strong> expression and are interpreted relative to the installation prefix.  For example:</p>
<pre>
target_include_directories(mylib PUBLIC
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/mylib&gt;
  $&lt;INSTALL_INTERFACE:include/mylib&gt;  # &lt;prefix&gt;/include/mylib
)
</pre>

<h3>target_link_libraries</h3>
<p>Link a target to given libraries.</p>
<pre>
target_link_libraries(&lt;target&gt; [item1 [item2 [...]]]
                      [[debug|optimized|general] &lt;item&gt;] ...)
</pre>
<p>Specify libraries or flags to use when linking a given target.  The named <strong>&lt;target&gt;</strong> must have been created in the current directory by a command such as <strong>add_executable()</strong> or <strong>add_library()</strong>.  The remaining arguments specify library names or flags.  Repeated calls for the same <strong>&lt;target&gt;</strong> append items in the order called.</p><p>If a library name matches that of another target in the project a dependency will automatically be added in the build system to make sure the library being linked is up-to-date before the target links. Item names starting with <strong>-</strong>, but not <strong>-l</strong> or <strong>-framework</strong>, are treated as linker flags.</p><p>A <strong>debug</strong>, <strong>optimized</strong>, or <strong>general</strong> keyword indicates that the library immediately following it is to be used only for the corresponding build configuration.  The <strong>debug</strong> keyword corresponds to the Debug configuration (or to configurations named in the <strong>DEBUG_CONFIGURATIONS</strong> global property if it is set).  The <strong>optimized</strong> keyword corresponds to all other configurations.  The <strong>general</strong> keyword corresponds to all configurations, and is purely optional (assumed if omitted).  Higher granularity may be achieved for per-configuration rules by creating and linking to <em>IMPORTED library targets</em>.</p><p>Library dependencies are transitive by default with this signature. When this target is linked into another target then the libraries linked to this target will appear on the link line for the other target too.  This transitive "link interface" is stored in the <strong>INTERFACE_LINK_LIBRARIES</strong> target property and may be overridden by setting the property directly.  When <strong>CMP0022</strong> is not set to <strong>NEW</strong>, transitive linking is built in but may be overridden by the <strong>LINK_INTERFACE_LIBRARIES</strong> property.  Calls to other signatures of this command may set the property making any libraries linked exclusively by this signature private.</p><p>CMake will also propagate <em>usage requirements</em> from linked library targets.  Usage requirements of dependencies affect compilation of sources in the <strong>&lt;target&gt;</strong>.</p><p>If an <strong>&lt;item&gt;</strong> is a library in a Mac OX framework, the <strong>Headers</strong> directory of the framework will also be processed as a <em>usage requirement</em>.  This has the same effect as passing the framework directory as an include directory.</p><p>----</p>
<pre>
target_link_libraries(&lt;target&gt;
                    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;lib&gt; ...
                    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;lib&gt; ... ] ...])
</pre>
<p>The <strong>PUBLIC</strong>, <strong>PRIVATE</strong> and <strong>INTERFACE</strong> keywords can be used to specify both the link dependencies and the link interface in one command. Libraries and targets following <strong>PUBLIC</strong> are linked to, and are made part of the link interface.  Libraries and targets following <strong>PRIVATE</strong> are linked to, but are not made part of the link interface.  Libraries following <strong>INTERFACE</strong> are appended to the link interface and are not used for linking <strong>&lt;target&gt;</strong>.</p><p>----</p>
<pre>
target_link_libraries(&lt;target&gt; LINK_INTERFACE_LIBRARIES
                      [[debug|optimized|general] &lt;lib&gt;] ...)
</pre>
<p>The <strong>LINK_INTERFACE_LIBRARIES</strong> mode appends the libraries to the <strong>INTERFACE_LINK_LIBRARIES</strong> target property instead of using them for linking.  If policy <strong>CMP0022</strong> is not <strong>NEW</strong>, then this mode also appends libraries to the <strong>LINK_INTERFACE_LIBRARIES</strong> and its per-configuration equivalent.</p><p>This signature is for compatibility only.  Prefer the <strong>INTERFACE</strong> mode instead.</p><p>Libraries specified as <strong>debug</strong> are wrapped in a generator expression to correspond to debug builds.  If policy <strong>CMP0022</strong> is not <strong>NEW</strong>, the libraries are also appended to the <strong>LINK_INTERFACE_LIBRARIES_DEBUG</strong> property (or to the properties corresponding to configurations listed in the <strong>DEBUG_CONFIGURATIONS</strong> global property if it is set). Libraries specified as <strong>optimized</strong> are appended to the <strong>INTERFACE_LINK_LIBRARIES</strong> property.  If policy <strong>CMP0022</strong> is not <strong>NEW</strong>, they are also appended to the <strong>LINK_INTERFACE_LIBRARIES</strong> property.  Libraries specified as <strong>general</strong> (or without any keyword) are treated as if specified for both <strong>debug</strong> and <strong>optimized</strong>.</p><p>----</p>
<pre>
target_link_libraries(&lt;target&gt;
                      &lt;LINK_PRIVATE|LINK_PUBLIC&gt;
                        [[debug|optimized|general] &lt;lib&gt;] ...
                      [&lt;LINK_PRIVATE|LINK_PUBLIC&gt;
                        [[debug|optimized|general] &lt;lib&gt;] ...])
</pre>
<p>The <strong>LINK_PUBLIC</strong> and <strong>LINK_PRIVATE</strong> modes can be used to specify both the link dependencies and the link interface in one command.</p><p>This signature is for compatibility only.  Prefer the <strong>PUBLIC</strong> or <strong>PRIVATE</strong> keywords instead.</p><p>Libraries and targets following <strong>LINK_PUBLIC</strong> are linked to, and are made part of the <strong>INTERFACE_LINK_LIBRARIES</strong>.  If policy <strong>CMP0022</strong> is not <strong>NEW</strong>, they are also made part of the <strong>LINK_INTERFACE_LIBRARIES</strong>.  Libraries and targets following <strong>LINK_PRIVATE</strong> are linked to, but are not made part of the <strong>INTERFACE_LINK_LIBRARIES</strong> (or <strong>LINK_INTERFACE_LIBRARIES</strong>).</p><p>The library dependency graph is normally acyclic (a DAG), but in the case of mutually-dependent <strong>STATIC</strong> libraries CMake allows the graph to contain cycles (strongly connected components).  When another target links to one of the libraries, CMake repeats the entire connected component. For example, the code</p>
<pre>
add_library(A STATIC a.c)
add_library(B STATIC b.c)
target_link_libraries(A B)
target_link_libraries(B A)
add_executable(main main.c)
target_link_libraries(main A)
</pre>
<p>links <strong>main</strong> to <strong>A B A B</strong>.  While one repetition is usually sufficient, pathological object file and symbol arrangements can require more.  One may handle such cases by manually repeating the component in the last <strong>target_link_libraries</strong> call.  However, if two archives are really so interdependent they should probably be combined into a single archive.</p><p>Arguments to target_link_libraries may use "generator expressions" with the syntax <strong>$&lt;...&gt;</strong>.  Note however, that generator expressions will not be used in OLD handling of <strong>CMP0003</strong> or <strong>CMP0004</strong>. See the <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> manual for available expressions.  See the <a href="../man7/cmake-buildsystem.7.html"><strong>cmake-buildsystem</strong>(7)</a></strong> manual for more on defining buildsystem properties.</p>
<h3>try_compile</h3>
<p>Try building some code.</p>
<pre>
try_compile(RESULT_VAR &lt;bindir&gt; &lt;srcdir&gt;
            &lt;projectName&gt; [targetName] [CMAKE_FLAGS flags...]
            [OUTPUT_VARIABLE &lt;var&gt;])
</pre>
<p>Try building a project.  In this form, srcdir should contain a complete CMake project with a CMakeLists.txt file and all sources. The bindir and srcdir will not be deleted after this command is run. Specify targetName to build a specific target instead of the &apos;all&apos; or &apos;ALL_BUILD&apos; target.</p>
<pre>
try_compile(RESULT_VAR &lt;bindir&gt; &lt;srcfile|SOURCES srcfile...&gt;
            [CMAKE_FLAGS flags...]
            [COMPILE_DEFINITIONS flags...]
            [LINK_LIBRARIES libs...]
            [OUTPUT_VARIABLE &lt;var&gt;]
            [COPY_FILE &lt;fileName&gt; [COPY_FILE_ERROR &lt;var&gt;]])
</pre>
<p>Try building an executable from one or more source files.  In this form the user need only supply one or more source files that include a definition for &apos;main&apos;.  CMake will create a CMakeLists.txt file to build the source(s) as an executable.  Specify COPY_FILE to get a copy of the linked executable at the given fileName and optionally COPY_FILE_ERROR to capture any error.</p><p>In this version all files in bindir/CMakeFiles/CMakeTmp will be cleaned automatically.  For debugging, --debug-trycompile can be passed to cmake to avoid this clean.  However, multiple sequential try_compile operations reuse this single output directory.  If you use --debug-trycompile, you can only debug one try_compile call at a time. The recommended procedure is to configure with cmake all the way through once, then delete the cache entry associated with the try_compile call of interest, and then re-run cmake again with --debug-trycompile.</p><p>Some extra flags that can be included are, INCLUDE_DIRECTORIES, LINK_DIRECTORIES, and LINK_LIBRARIES.  COMPILE_DEFINITIONS are -Ddefinition that will be passed to the compile line.</p><p>The srcfile signature also accepts a LINK_LIBRARIES argument which may contain a list of libraries or IMPORTED targets which will be linked to in the generated project.  If LINK_LIBRARIES is specified as a parameter to try_compile, then any LINK_LIBRARIES passed as CMAKE_FLAGS will be ignored.</p><p>try_compile creates a CMakeList.txt file on the fly that looks like this:</p>
<pre>
add_definitions( &lt;expanded COMPILE_DEFINITIONS from calling cmake&gt;)
include_directories(${INCLUDE_DIRECTORIES})
link_directories(${LINK_DIRECTORIES})
add_executable(cmTryCompileExec sources)
target_link_libraries(cmTryCompileExec ${LINK_LIBRARIES})
</pre>
<p>In both versions of the command, if OUTPUT_VARIABLE is specified, then the output from the build process is stored in the given variable. The success or failure of the try_compile, i.e.  TRUE or FALSE respectively, is returned in RESULT_VAR.  CMAKE_FLAGS can be used to pass -DVAR:TYPE=VALUE flags to the cmake that is run during the build. Set variable CMAKE_TRY_COMPILE_CONFIGURATION to choose a build configuration.</p>
<h3>try_run</h3>
<p>Try compiling and then running some code.</p>
<pre>
try_run(RUN_RESULT_VAR COMPILE_RESULT_VAR
        bindir srcfile [CMAKE_FLAGS &lt;Flags&gt;]
        [COMPILE_DEFINITIONS &lt;flags&gt;]
        [COMPILE_OUTPUT_VARIABLE comp]
        [RUN_OUTPUT_VARIABLE run]
        [OUTPUT_VARIABLE var]
        [ARGS &lt;arg1&gt; &lt;arg2&gt;...])
</pre>
<p>Try compiling a srcfile.  Return TRUE or FALSE for success or failure in COMPILE_RESULT_VAR.  Then if the compile succeeded, run the executable and return its exit code in RUN_RESULT_VAR.  If the executable was built, but failed to run, then RUN_RESULT_VAR will be set to FAILED_TO_RUN.  COMPILE_OUTPUT_VARIABLE specifies the variable where the output from the compile step goes.  RUN_OUTPUT_VARIABLE specifies the variable where the output from the running executable goes.</p><p>For compatibility reasons OUTPUT_VARIABLE is still supported, which gives you the output from the compile and run step combined.</p><p>Cross compiling issues</p><p>When cross compiling, the executable compiled in the first step usually cannot be run on the build host.  try_run() checks the CMAKE_CROSSCOMPILING variable to detect whether CMake is in crosscompiling mode.  If that&apos;s the case, it will still try to compile the executable, but it will not try to run the executable.  Instead it will create cache variables which must be filled by the user or by presetting them in some CMake script file to the values the executable would have produced if it had been run on its actual target platform. These variables are RUN_RESULT_VAR (explanation see above) and if RUN_OUTPUT_VARIABLE (or OUTPUT_VARIABLE) was used, an additional cache variable RUN_RESULT_VAR__COMPILE_RESULT_VAR__TRYRUN_OUTPUT.This is intended to hold stdout and stderr from the executable.</p><p>In order to make cross compiling your project easier, use try_run only if really required.  If you use try_run, use RUN_OUTPUT_VARIABLE (or OUTPUT_VARIABLE) only if really required.  Using them will require that when crosscompiling, the cache variables will have to be set manually to the output of the executable.  You can also "guard" the calls to try_run with if(CMAKE_CROSSCOMPILING) and provide an easy-to-preset alternative for this case.</p><p>Set variable CMAKE_TRY_COMPILE_CONFIGURATION to choose a build configuration.</p>
<h3>unset</h3>
<p>Unset a variable, cache variable, or environment variable.</p>
<pre>
unset(&lt;variable&gt; [CACHE | PARENT_SCOPE])
</pre>
<p>Removes the specified variable causing it to become undefined.  If CACHE is present then the variable is removed from the cache instead of the current scope.</p><p>If PARENT_SCOPE is present then the variable is removed from the scope above the current scope.  See the same option in the set() command for further details.</p><p>&lt;variable&gt; can be an environment variable such as:</p>
<pre>
unset(ENV{LD_LIBRARY_PATH})
</pre>
<p>in which case the variable will be removed from the current environment.</p>
<h3>variable_watch</h3>
<p>Watch the CMake variable for change.</p>
<pre>
variable_watch(&lt;variable name&gt; [&lt;command to execute&gt;])
</pre>
<p>If the specified variable changes, the message will be printed about the variable being changed.  If the command is specified, the command will be executed.  The command will receive the following arguments: COMMAND(&lt;variable&gt; &lt;access&gt; &lt;value&gt; &lt;current list file&gt; &lt;stack&gt;)</p>
<h3>while</h3>
<p>Evaluate a group of commands while a condition is true</p>
<pre>
while(condition)
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endwhile(condition)
</pre>
<p>All commands between while and the matching endwhile are recorded without being invoked.  Once the endwhile is evaluated, the recorded list of commands is invoked as long as the condition is true.  The condition is evaluated using the same logic as the if command.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEPRECATED COMMANDS</h2>
        <div class="sectioncontent">
<p>These commands are available only for compatibility with older versions of CMake.  Do not use them in new code.</p><h3>build_name</h3>
<p>Disallowed.  See CMake Policy <strong>CMP0036</strong>.</p><p>Use ${CMAKE_SYSTEM} and ${CMAKE_CXX_COMPILER} instead.</p>
<pre>
build_name(variable)
</pre>
<p>Sets the specified variable to a string representing the platform and compiler settings.  These values are now available through the CMAKE_SYSTEM and CMAKE_CXX_COMPILER variables.</p>
<h3>exec_program</h3>
<p>Deprecated.  Use the execute_process() command instead.</p><p>Run an executable program during the processing of the CMakeList.txt file.</p>
<pre>
exec_program(Executable [directory in which to run]
             [ARGS &lt;arguments to executable&gt;]
             [OUTPUT_VARIABLE &lt;var&gt;]
             [RETURN_VALUE &lt;var&gt;])
</pre>
<p>The executable is run in the optionally specified directory.  The executable can include arguments if it is double quoted, but it is better to use the optional ARGS argument to specify arguments to the program.  This is because cmake will then be able to escape spaces in the executable path.  An optional argument OUTPUT_VARIABLE specifies a variable in which to store the output.  To capture the return value of the execution, provide a RETURN_VALUE.  If OUTPUT_VARIABLE is specified, then no output will go to the stdout/stderr of the console running cmake.</p>
<h3>export_library_dependencies</h3>
<p>Disallowed.  See CMake Policy <strong>CMP0033</strong>.</p><p>Use <strong>install(EXPORT)</strong> or <strong>export()</strong> command.</p><p>This command generates an old-style library dependencies file. Projects requiring CMake 2.6 or later should not use the command.  Use instead the install(EXPORT) command to help export targets from an installation tree and the export() command to export targets from a build tree.</p><p>The old-style library dependencies file does not take into account per-configuration names of libraries or the LINK_INTERFACE_LIBRARIES target property.</p>
<pre>
export_library_dependencies(&lt;file&gt; [APPEND])
</pre>
<p>Create a file named &lt;file&gt; that can be included into a CMake listfile with the INCLUDE command.  The file will contain a number of SET commands that will set all the variables needed for library dependency information.  This should be the last command in the top level CMakeLists.txt file of the project.  If the APPEND option is specified, the SET commands will be appended to the given file instead of replacing it.</p>
<h3>install_files</h3>
<p>Deprecated.  Use the install(FILES ) command instead.</p><p>This command has been superceded by the install command.  It is provided for compatibility with older CMake code.  The FILES form is directly replaced by the FILES form of the install command.  The regexp form can be expressed more clearly using the GLOB form of the file command.</p>
<pre>
install_files(&lt;dir&gt; extension file file ...)
</pre>
<p>Create rules to install the listed files with the given extension into the given directory.  Only files existing in the current source tree or its corresponding location in the binary tree may be listed.  If a file specified already has an extension, that extension will be removed first.  This is useful for providing lists of source files such as foo.cxx when you want the corresponding foo.h to be installed. A typical extension is &apos;.h&apos;.</p>
<pre>
install_files(&lt;dir&gt; regexp)
</pre>
<p>Any files in the current source directory that match the regular expression will be installed.</p>
<pre>
install_files(&lt;dir&gt; FILES file file ...)
</pre>
<p>Any files listed after the FILES keyword will be installed explicitly from the names given.  Full paths are allowed in this form.</p><p>The directory &lt;dir&gt; is relative to the installation prefix, which is stored in the variable CMAKE_INSTALL_PREFIX.</p>
<h3>install_programs</h3>
<p>Deprecated. Use the install(PROGRAMS ) command instead.</p><p>This command has been superceded by the install command.  It is provided for compatibility with older CMake code.  The FILES form is directly replaced by the PROGRAMS form of the INSTALL command.  The regexp form can be expressed more clearly using the GLOB form of the FILE command.</p>
<pre>
install_programs(&lt;dir&gt; file1 file2 [file3 ...])
install_programs(&lt;dir&gt; FILES file1 [file2 ...])
</pre>
<p>Create rules to install the listed programs into the given directory. Use the FILES argument to guarantee that the file list version of the command will be used even when there is only one argument.</p>
<pre>
install_programs(&lt;dir&gt; regexp)
</pre>
<p>In the second form any program in the current source directory that matches the regular expression will be installed.</p><p>This command is intended to install programs that are not built by cmake, such as shell scripts.  See the TARGETS form of the INSTALL command to create installation rules for targets built by cmake.</p><p>The directory &lt;dir&gt; is relative to the installation prefix, which is stored in the variable CMAKE_INSTALL_PREFIX.</p>
<h3>install_targets</h3>
<p>Deprecated. Use the install(TARGETS )  command instead.</p><p>This command has been superceded by the install command.  It is provided for compatibility with older CMake code.</p>
<pre>
install_targets(&lt;dir&gt; [RUNTIME_DIRECTORY dir] target target)
</pre>
<p>Create rules to install the listed targets into the given directory. The directory &lt;dir&gt; is relative to the installation prefix, which is stored in the variable CMAKE_INSTALL_PREFIX.  If RUNTIME_DIRECTORY is specified, then on systems with special runtime files (Windows DLL), the files will be copied to that directory.</p>
<h3>link_libraries</h3>
<p>Deprecated. Use the target_link_libraries() command instead.</p><p>Link libraries to all targets added later.</p>
<pre>
link_libraries(library1 &lt;debug | optimized&gt; library2 ...)
</pre>
<p>Specify a list of libraries to be linked into any following targets (typically added with the add_executable or add_library calls).  This command is passed down to all subdirectories.  The debug and optimized strings may be used to indicate that the next library listed is to be used only for that specific type of build.</p>
<h3>make_directory</h3>
<p>Deprecated. Use the file(MAKE_DIRECTORY ) command instead.</p>
<pre>
make_directory(directory)
</pre>
<p>Creates the specified directory.  Full paths should be given.  Any parent directories that do not exist will also be created.  Use with care.</p>
<h3>output_required_files</h3>
<p>Disallowed.  See CMake Policy <strong>CMP0032</strong>.</p><p>Approximate C preprocessor dependency scanning.</p><p>This command exists only because ancient CMake versions provided it. CMake handles preprocessor dependency scanning automatically using a more advanced scanner.</p>
<pre>
output_required_files(srcfile outputfile)
</pre>
<p>Outputs a list of all the source files that are required by the specified srcfile.  This list is written into outputfile.  This is similar to writing out the dependencies for srcfile except that it jumps from .h files into .cxx, .c and .cpp files if possible.</p>
<h3>remove</h3>
<p>Deprecated. Use the list(REMOVE_ITEM ) command instead.</p>
<pre>
remove(VAR VALUE VALUE ...)
</pre>
<p>Removes VALUE from the variable VAR.  This is typically used to remove entries from a vector (e.g.  semicolon separated list).  VALUE is expanded.</p>
<h3>subdir_depends</h3>
<p>Disallowed.  See CMake Policy <strong>CMP0029</strong>.</p><p>Does nothing.</p>
<pre>
subdir_depends(subdir dep1 dep2 ...)
</pre>
<p>Does not do anything.  This command used to help projects order parallel builds correctly.  This functionality is now automatic.</p>
<h3>subdirs</h3>
<p>Deprecated. Use the add_subdirectory() command instead.</p><p>Add a list of subdirectories to the build.</p>
<pre>
subdirs(dir1 dir2 ...[EXCLUDE_FROM_ALL exclude_dir1 exclude_dir2 ...]
        [PREORDER] )
</pre>
<p>Add a list of subdirectories to the build.  The add_subdirectory command should be used instead of subdirs although subdirs will still work.  This will cause any CMakeLists.txt files in the sub directories to be processed by CMake.  Any directories after the PREORDER flag are traversed first by makefile builds, the PREORDER flag has no effect on IDE projects.  Any directories after the EXCLUDE_FROM_ALL marker will not be included in the top level makefile or project file.  This is useful for having CMake create makefiles or projects for a set of examples in a project.  You would want CMake to generate makefiles or project files for all the examples at the same time, but you would not want them to show up in the top level project or be built each time make is run from the top.</p>
<h3>use_mangled_mesa</h3>
<p>Disallowed.  See CMake Policy <strong>CMP0030</strong>.</p><p>Copy mesa headers for use in combination with system GL.</p>
<pre>
use_mangled_mesa(PATH_TO_MESA OUTPUT_DIRECTORY)
</pre>
<p>The path to mesa includes, should contain gl_mangle.h.  The mesa headers are copied to the specified output directory.  This allows mangled mesa headers to override other GL headers by being added to the include directory path earlier.</p>
<h3>utility_source</h3>
<p>Disallowed.  See CMake Policy <strong>CMP0034</strong>.</p><p>Specify the source tree of a third-party utility.</p>
<pre>
utility_source(cache_entry executable_name
               path_to_source [file1 file2 ...])
</pre>
<p>When a third-party utility&apos;s source is included in the distribution, this command specifies its location and name.  The cache entry will not be set unless the path_to_source and all listed files exist.  It is assumed that the source tree of the utility will have been built before it is needed.</p><p>When cross compiling CMake will print a warning if a utility_source() command is executed, because in many cases it is used to build an executable which is executed later on.  This doesn&apos;t work when cross compiling, since the executable can run only on their target platform. So in this case the cache entry has to be adjusted manually so it points to an executable which is runnable on the build host.</p>
<h3>variable_requires</h3>
<p>Disallowed.  See CMake Policy <strong>CMP0035</strong>.</p><p>Use the if() command instead.</p><p>Assert satisfaction of an option&apos;s required variables.</p>
<pre>
variable_requires(TEST_VARIABLE RESULT_VARIABLE
                  REQUIRED_VARIABLE1
                  REQUIRED_VARIABLE2 ...)
</pre>
<p>The first argument (TEST_VARIABLE) is the name of the variable to be tested, if that variable is false nothing else is done.  If TEST_VARIABLE is true, then the next argument (RESULT_VARIABLE) is a variable that is set to true if all the required variables are set. The rest of the arguments are variables that must be true or not set to NOTFOUND to avoid an error.  If any are not true, an error is reported.</p>
<h3>write_file</h3>
<p>Deprecated. Use the file(WRITE ) command instead.</p>
<pre>
write_file(filename "message to write"... [APPEND])
</pre>
<p>The first argument is the file name, the rest of the arguments are messages to write.  If the argument APPEND is specified, then the message will be appended.</p><p>NOTE 1: file(WRITE ...  and file(APPEND ...  do exactly the same as this one but add some more functionality.</p><p>NOTE 2: When using write_file the produced file cannot be used as an input to CMake (CONFIGURE_FILE, source file ...) because it will lead to an infinite loop.  Use configure_file if you want to generate input files to CMake.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CTEST COMMANDS</h2>
        <div class="sectioncontent">
<p>These commands are available only in ctest scripts.</p><h3>ctest_build</h3>
<p>Build the project.</p>
<pre>
ctest_build([BUILD build_dir] [TARGET target] [RETURN_VALUE res]
            [APPEND][NUMBER_ERRORS val] [NUMBER_WARNINGS val])
</pre>
<p>Builds the given build directory and stores results in Build.xml.  If no BUILD is given, the CTEST_BINARY_DIRECTORY variable is used.</p><p>The TARGET variable can be used to specify a build target.  If none is specified, the "all" target will be built.</p><p>The RETURN_VALUE option specifies a variable in which to store the return value of the native build tool.  The NUMBER_ERRORS and NUMBER_WARNINGS options specify variables in which to store the number of build errors and warnings detected.</p><p>The APPEND option marks results for append to those previously submitted to a dashboard server since the last ctest_start.  Append semantics are defined by the dashboard server in use.</p>
<h3>ctest_configure</h3>
<p>Configure the project build tree.</p>
<pre>
ctest_configure([BUILD build_dir] [SOURCE source_dir] [APPEND]
                [OPTIONS options] [RETURN_VALUE res])
</pre>
<p>Configures the given build directory and stores results in Configure.xml.  If no BUILD is given, the CTEST_BINARY_DIRECTORY variable is used.  If no SOURCE is given, the CTEST_SOURCE_DIRECTORY variable is used.  The OPTIONS argument specifies command line arguments to pass to the configuration tool.  The RETURN_VALUE option specifies a variable in which to store the return value of the native build tool.</p><p>The APPEND option marks results for append to those previously submitted to a dashboard server since the last ctest_start.  Append semantics are defined by the dashboard server in use.</p>
<h3>ctest_coverage</h3>
<p>Collect coverage tool results.</p>
<pre>
ctest_coverage([BUILD build_dir] [RETURN_VALUE res] [APPEND]
               [LABELS label1 [label2 [...]]])
</pre>
<p>Perform the coverage of the given build directory and stores results in Coverage.xml.  The second argument is a variable that will hold value.</p><p>The LABELS option filters the coverage report to include only source files labeled with at least one of the labels specified.</p><p>The APPEND option marks results for append to those previously submitted to a dashboard server since the last ctest_start.  Append semantics are defined by the dashboard server in use.</p>
<h3>ctest_empty_binary_directory</h3>
<p>empties the binary directory</p>
<pre>
ctest_empty_binary_directory( directory )
</pre>
<p>Removes a binary directory.  This command will perform some checks prior to deleting the directory in an attempt to avoid malicious or accidental directory deletion.</p>
<h3>ctest_memcheck</h3>
<p>Run tests with a dynamic analysis tool.</p>
<pre>
ctest_memcheck([BUILD build_dir] [RETURN_VALUE res] [APPEND]
           [START start number] [END end number]
           [STRIDE stride number] [EXCLUDE exclude regex ]
           [INCLUDE include regex]
           [EXCLUDE_LABEL exclude regex]
           [INCLUDE_LABEL label regex]
           [PARALLEL_LEVEL level] )
</pre>
<p>Tests the given build directory and stores results in MemCheck.xml. The second argument is a variable that will hold value.  Optionally, you can specify the starting test number START, the ending test number END, the number of tests to skip between each test STRIDE, a regular expression for tests to run INCLUDE, or a regular expression for tests not to run EXCLUDE.  EXCLUDE_LABEL and INCLUDE_LABEL are regular expressions for tests to be included or excluded by the test property LABEL.  PARALLEL_LEVEL should be set to a positive number representing the number of tests to be run in parallel.</p><p>The APPEND option marks results for append to those previously submitted to a dashboard server since the last ctest_start.  Append semantics are defined by the dashboard server in use.</p>
<h3>ctest_read_custom_files</h3>
<p>read CTestCustom files.</p>
<pre>
ctest_read_custom_files( directory ... )
</pre>
<p>Read all the CTestCustom.ctest or CTestCustom.cmake files from the given directory.</p>
<h3>ctest_run_script</h3>
<p>runs a ctest -S script</p>
<pre>
ctest_run_script([NEW_PROCESS] script_file_name script_file_name1
            script_file_name2 ... [RETURN_VALUE var])
</pre>
<p>Runs a script or scripts much like if it was run from ctest -S.  If no argument is provided then the current script is run using the current settings of the variables.  If NEW_PROCESS is specified then each script will be run in a separate process.If RETURN_VALUE is specified the return value of the last script run will be put into var.</p>
<h3>ctest_sleep</h3>
<p>sleeps for some amount of time</p>
<pre>
ctest_sleep(&lt;seconds&gt;)
</pre>
<p>Sleep for given number of seconds.</p>
<pre>
ctest_sleep(&lt;time1&gt; &lt;duration&gt; &lt;time2&gt;)
</pre>
<p>Sleep for t=(time1 + duration - time2) seconds if t &gt; 0.</p>
<h3>ctest_start</h3>
<p>Starts the testing for a given model</p>
<pre>
ctest_start(Model [TRACK &lt;track&gt;] [APPEND] [source [binary]])
</pre>
<p>Starts the testing for a given model.  The command should be called after the binary directory is initialized.  If the &apos;source&apos; and &apos;binary&apos; directory are not specified, it reads the CTEST_SOURCE_DIRECTORY and CTEST_BINARY_DIRECTORY.  If the track is specified, the submissions will go to the specified track.  If APPEND is used, the existing TAG is used rather than creating a new one based on the current time stamp.</p>
<h3>ctest_submit</h3>
<p>Submit results to a dashboard server.</p>
<pre>
ctest_submit([PARTS ...] [FILES ...] [RETRY_COUNT count]                [RETRY_DELAY delay][RETURN_VALUE res])
</pre>
<p>By default all available parts are submitted if no PARTS or FILES are specified.  The PARTS option lists a subset of parts to be submitted. Valid part names are:</p>
<pre>
Start      = nothing
Update     = ctest_update results, in Update.xml
Configure  = ctest_configure results, in Configure.xml
Build      = ctest_build results, in Build.xml
Test       = ctest_test results, in Test.xml
Coverage   = ctest_coverage results, in Coverage.xml
MemCheck   = ctest_memcheck results, in DynamicAnalysis.xml
Notes      = Files listed by CTEST_NOTES_FILES, in Notes.xml
ExtraFiles = Files listed by CTEST_EXTRA_SUBMIT_FILES
Upload     = Files prepared for upload by ctest_upload(), in Upload.xml
Submit     = nothing
</pre>
<p>The FILES option explicitly lists specific files to be submitted. Each individual file must exist at the time of the call.</p><p>The RETRY_DELAY option specifies how long in seconds to wait after a timed-out submission before attempting to re-submit.</p><p>The RETRY_COUNT option specifies how many times to retry a timed-out submission.</p>
<h3>ctest_test</h3>
<p>Run tests in the project build tree.</p>
<pre>
ctest_test([BUILD build_dir] [APPEND]
           [START start number] [END end number]
           [STRIDE stride number] [EXCLUDE exclude regex ]
           [INCLUDE include regex] [RETURN_VALUE res]
           [EXCLUDE_LABEL exclude regex]
           [INCLUDE_LABEL label regex]
           [PARALLEL_LEVEL level]
           [SCHEDULE_RANDOM on]
           [STOP_TIME time of day])
</pre>
<p>Tests the given build directory and stores results in Test.xml.  The second argument is a variable that will hold value.  Optionally, you can specify the starting test number START, the ending test number END, the number of tests to skip between each test STRIDE, a regular expression for tests to run INCLUDE, or a regular expression for tests to not run EXCLUDE.  EXCLUDE_LABEL and INCLUDE_LABEL are regular expression for test to be included or excluded by the test property LABEL.  PARALLEL_LEVEL should be set to a positive number representing the number of tests to be run in parallel.  SCHEDULE_RANDOM will launch tests in a random order, and is typically used to detect implicit test dependencies.  STOP_TIME is the time of day at which the tests should all stop running.</p><p>The APPEND option marks results for append to those previously submitted to a dashboard server since the last ctest_start.  Append semantics are defined by the dashboard server in use.</p>
<h3>ctest_update</h3>
<p>Update the work tree from version control.</p>
<pre>
ctest_update([SOURCE source] [RETURN_VALUE res])
</pre>
<p>Updates the given source directory and stores results in Update.xml. If no SOURCE is given, the CTEST_SOURCE_DIRECTORY variable is used. The RETURN_VALUE option specifies a variable in which to store the result, which is the number of files updated or -1 on error.</p>
<h3>ctest_upload</h3>
<p>Upload files to a dashboard server.</p>
<pre>
ctest_upload(FILES ...)
</pre>
<p>Pass a list of files to be sent along with the build results to the dashboard server.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2000-2014 Kitware, Inc.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="cmake-buildsystem.7.html"><span aria-hidden="true">&larr;</span> cmake-buildsystem.7: Cmake buildsystem reference</a></li>
   <li class="next"><a href="cmake-developer.7.html">cmake-developer.7: Cmake developer reference <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

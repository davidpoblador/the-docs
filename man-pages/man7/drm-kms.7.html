<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>drm-kms: Kernel mode-setting</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Kernel mode-setting">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="drm-kms (7) manual">
  <meta name="twitter:description" content="Kernel mode-setting">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdrm-dev-drm-kms-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/drm-kms.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="drm-kms (7) manual" />
  <meta property="og:description" content="Kernel mode-setting" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdrm-dev-drm-kms-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">drm-kms<small> (7)</small></h1>
        <p class="lead">Kernel mode-setting</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/drm-kms.7.html">
      <span itemprop="name">drm-kms: Kernel mode-setting</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdrm-dev/">
      <span itemprop="name">libdrm-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/drm-kms.7.html">
      <span itemprop="name">drm-kms: Kernel mode-setting</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;xf86drm.h&gt;
</pre>

<pre>
#include &lt;xf86drmMode.h&gt;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Each DRM device provides access to manage which monitors and displays are currently used and what frames to be displayed. This task is called <em>Kernel Mode-Setting</em> (KMS). Historically, this was done in user-space and called <em>User-space Mode-Setting</em> (UMS). Almost all open-source drivers now provide the KMS kernel API to do this in the kernel, however, many non-open-source binary drivers from different vendors still do not support this. You can use <strong>drmModeSettingSupported</strong>(3) to check whether your driver supports this. To understand how KMS works, we need to introduce 5 objects: <em>CRTCs</em>, <em>Planes</em>, <em>Encoders</em>, <em>Connectors</em> and <em>Framebuffers</em>.</p><p>CRTCs</p><p>A <em>CRTC</em> short for <em>CRT Controller</em> is an abstraction representing a part of the chip that contains a pointer to a scanout buffer. Therefore, the number of CRTCs available determines how many independent scanout buffers can be active at any given time. The CRTC structure contains several fields to support this: a pointer to some video memory (abstracted as a frame-buffer object), a list of driven connectors, a display mode and an (x, y) offset into the video memory to support panning or configurations where one piece of video memory spans multiple CRTCs. A CRTC is the central point where configuration of displays happens. You select which objects to use, which modes and which parameters and then configure each CRTC via <strong>drmModeCrtcSet</strong>(3) to drive the display devices.</p><p>Planes</p><p>A <em>plane</em> respresents an image source that can be blended with or overlayed on top of a CRTC during the scanout process. Planes are associated with a frame-buffer to crop a portion of the image memory (source) and optionally scale it to a destination size. The result is then blended with or overlayed on top of a CRTC. Planes are not provided by all hardware and the number of available planes is limited. If planes are not available or if not enough planes are available, the user should fall back to normal software blending (via GPU or CPU).</p><p>Encoders</p><p>An <em>encoder</em> takes pixel data from a CRTC and converts it to a format suitable for any attached connectors. On some devices, it may be possible to have a CRTC send data to more than one encoder. In that case, both encoders would receive data from the same scanout buffer, resulting in a <em>cloned</em> display configuration across the connectors attached to each encoder.</p><p>Connectors</p><p>A <em>connector</em> is the final destination of pixel-data on a device, and usually connects directly to an external display device like a monitor or laptop panel. A connector can only be attached to one encoder at a time. The connector is also the structure where information about the attached display is kept, so it contains fields for display data, <em>EDID</em> data, <em>DPMS</em> and <em>connection status</em>, and information about modes supported on the attached displays.</p><p>Framebuffers</p><p><em>Framebuffers</em> are abstract memory objects that provide a source of pixel data to scanout to a CRTC. Applications explicitely request the creation of framebuffers and can control their behavior. Framebuffers rely on the underneath memory manager for low-level memory operations. When creating a framebuffer, applications pass a memory handle through the API which is used as backing storage. The framebuffer itself is only an abstract object with no data. It just refers to memory buffers that must be created with the <a href="../man7/drm-memory.7.html"><strong>drm-memory</strong>(7)</a> API.</p><h3>Mode-Setting</h3>
<p>Before mode-setting can be performed, an application needs to call <strong>drmSetMaster</strong>(3) to become <em>DRM-Master</em>. It then has exclusive access to the KMS API. A call to <a href="../man3/drmModeGetResources.3.html"><strong>drmModeGetResources</strong>(3)</a> returns a list of <em>CRTCs</em>, <em>Connectors</em>, <em>Encoders</em> and <em>Planes</em>.</p><p>Normal procedure now includes: First, you select which connectors you want to use. Users are mostly interested in which monitor or display-panel is active so you need to make sure to arrange them in the correct logical order and select the correct ones to use. For each connector, you need to find a CRTC to drive this connector. If you want to clone output to two or more connectors, you may use a single CRTC for all cloned connectors (if the hardware supports this). To find a suitable CRTC, you need to iterate over the list of encoders that are available for each connector. Each encoder contains a list of CRTCs that it can work with and you simply select one of these CRTCs. If you later program the CRTC to control a connector, it automatically selects the best encoder. However, this procedure is needed so your CRTC has at least one working encoder for the selected connector. See the <em>Examples</em> section below for more information.</p><p>All valid modes for a connector can be retrieved with a call to <strong>drmModeGetConnector</strong>(3) You need to select the mode you want to use and save it. The first mode in the list is the default mode with the highest resolution possible and often a suitable choice.</p><p>After you have a working connector+CRTC+mode combination, you need to create a framebuffer that is used for scanout. Memory buffer allocation is driver-depedent and described in <a href="../man7/drm-memory.7.html"><strong>drm-memory</strong>(7)</a>. You need to create a buffer big enough for your selected mode. Now you can create a framebuffer object that uses your memory-buffer as scanout buffer. You can do this with <strong>drmModeAddFB</strong>(3) and <strong>drmModeAddFB2</strong>(3).</p><p>As a last step, you want to program your CRTC to drive your selected connector. You can do this with a call to <strong>drmModeSetCrtc</strong>(3).</p>
<h3>Page-Flipping</h3>
<p>A call to <strong>drmModeSetCrtc</strong>(3) is executed immediately and forces the CRTC to use the new scanout buffer. If you want smooth-transitions without tearing, you probably use double-buffering. You need to create one framebuffer object for each buffer you use. You can then call <strong>drmModeSetCrtc</strong>(3) on the next buffer to flip. If you want to synchronize your flips with <em>vertical-blanks</em>, you can use <strong>drmModePageFlip</strong>(3) which schedules your page-flip for the next <em>vblank</em>.</p>
<h3>Planes</h3>
<p>Planes are controlled independently from CRTCs. That is, a call to <strong>drmModeSetCrtc</strong>(3) does not affect planes. Instead, you need to call <strong>drmModeSetPlane</strong>(3) to configure a plane. This requires the plane ID, a CRTC, a framebuffer and offsets into the plane-framebuffer and the CRTC-framebuffer. The CRTC then blends the content from the plane over the CRTC framebuffer buffer during scanout. As this does not involve any software-blending, it is way faster than traditional blending. However, plane resources are limited. See <strong>drmModeGetPlaneResources</strong>(3) for more information.</p>
<h3>Cursors</h3>
<p>Similar to planes, many hardware also supports cursors. A cursor is a very small buffer with an image that is blended over the CRTC framebuffer. You can set a different cursor for each CRTC with <strong>drmModeSetCursor</strong>(3) and move it on the screen with <strong>drmModeMoveCursor</strong>(3). This allows to move the cursor on the screen without rerendering. If no hardware cursors are supported, you need to rerender for each frame the cursor is moved.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Some examples of how basic mode-setting can be done. See the man-page of each DRM function for more information.</p><h3>CRTC/Encoder Selection</h3>
<p>If you retrieved all display configuration information via <a href="../man3/drmModeGetResources.3.html"><strong>drmModeGetResources</strong>(3)</a> as drmModeRes *<em>res</em>, selected a connector from the list in <em>res</em>-&gt;<em>connectors</em> and retrieved the connector-information as drmModeConnector *<em>conn</em> via <strong>drmModeGetConnector</strong>(3) then this example shows, how you can find a suitable CRTC id to drive this connector. This function takes a file-descriptor to the DRM device (see <strong>drmOpen</strong>(3)) as <em>fd</em>, a pointer to the retrieved resources as <em>res</em> and a pointer to the selected connector as <em>conn</em>. It returns an integer smaller than 0 on failure, otherwise, a valid CRTC id is returned.</p>
<pre>
static int modeset_find_crtc(int fd, drmModeRes *res, drmModeConnector *conn)
{
	drmModeEncoder *enc;
	unsigned int i, j;

	/* iterate all encoders of this connector */
	for (i = 0; i &lt; conn-&gt;count_encoders; ++i) {
		enc = drmModeGetEncoder(fd, conn-&gt;encoders[i]);
		if (!enc) {
			/* cannot retrieve encoder, ignoring... */
			continue;
		}

		/* iterate all global CRTCs */
		for (j = 0; j &lt; res-&gt;count_crtcs; ++j) {
			/* check whether this CRTC works with the encoder */
			if (!(enc-&gt;possible_crtcs & (1 &lt;&lt; j)))
				continue;


			/* Here you need to check that no other connector
			 * currently uses the CRTC with id "crtc". If you intend
			 * to drive one connector only, then you can skip this
			 * step. Otherwise, simply scan your list of configured
			 * connectors and CRTCs whether this CRTC is already
			 * used. If it is, then simply continue the search here. */
			if (res-&gt;crtcs[j] "is unused") {
				drmModeFreeEncoder(enc);
				return res-&gt;crtcs[j];
			}
		}

		drmModeFreeEncoder(enc);
	}

	/* cannot find a suitable CRTC */
	return -ENOENT;
}
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REPORTING BUGS</h2>
        <div class="sectioncontent">
<p>Bugs in this manual should be reported to http://bugs.freedesktop.org under the "Mesa" product, with "Other" or "libdrm" as the component.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO drm-kms&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man7/drm.7.html"><strong>drm</strong>(7)</a>, <a href="../man7/drm-memory.7.html"><strong>drm-memory</strong>(7)</a>, <a href="../man3/drmModeGetResources.3.html"><strong>drmModeGetResources</strong>(3)</a>, <strong>drmModeGetConnector</strong>(3), <strong>drmModeGetEncoder</strong>(3), <strong>drmModeGetCrtc</strong>(3), <strong>drmModeSetCrtc</strong>(3), <strong>drmModeGetFB</strong>(3), <strong>drmModeAddFB</strong>(3), <strong>drmModeAddFB2</strong>(3), <strong>drmModeRmFB</strong>(3), <strong>drmModePageFlip</strong>(3), <strong>drmModeGetPlaneResources</strong>(3), <strong>drmModeGetPlane</strong>(3), <strong>drmModeSetPlane</strong>(3), <strong>drmModeSetCursor</strong>(3), <strong>drmModeMoveCursor</strong>(3), <strong>drmSetMaster</strong>(3), <a href="../man3/drmAvailable.3.html"><strong>drmAvailable</strong>(3)</a>, <strong>drmCheckModesettingSupported</strong>(3), <strong>drmOpen</strong>(3)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="drm-gem.7.html"><span aria-hidden="true">&larr;</span> drm-gem.7: Drm memory management</a></li>
   <li class="next"><a href="drm-memory.7.html">drm-memory.7: Drm memory management <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cmake-policies: Cmake policies reference</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Cmake policies reference">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="cmake-policies (7) manual">
  <meta name="twitter:description" content="Cmake policies reference">
  <meta name="twitter:image" content="https://www.carta.tech/images/cmake-data-cmake-policies-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/cmake-policies.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="cmake-policies (7) manual" />
  <meta property="og:description" content="Cmake policies reference" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/cmake-data-cmake-policies-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">cmake-policies<small> (7)</small></h1>
        <p class="lead">Cmake policies reference</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/cmake-policies.7.html">
      <span itemprop="name">cmake-policies: Cmake policies reference</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/cmake-data/">
      <span itemprop="name">cmake-data</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/cmake-policies.7.html">
      <span itemprop="name">cmake-policies: Cmake policies reference</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>Policies in CMake are used to preserve backward compatible behavior across multiple releases.  When a new policy is introduced, newer CMake versions will begin to warn about the backward compatible behavior.  It is possible to disable the warning by explicitly requesting the OLD, or backward compatible behavior using the <strong>cmake_policy()</strong> command. It is also possible to request <strong>NEW</strong>, or non-backward compatible behavior for a policy, also avoiding the warning.  Each policy can also be set to either <strong>NEW</strong> or <strong>OLD</strong> behavior explicitly on the command line with the <strong>CMAKE_POLICY_DEFAULT_CMP&lt;NNNN&gt;</strong> variable.</p><p>The <strong>cmake_minimum_required()</strong> command does more than report an error if a too-old version of CMake is used to build a project.  It also sets all policies introduced in that CMake version or earlier to <strong>NEW</strong> behavior.  To manage policies without increasing the minimum required CMake version, the <strong>if(POLICY)</strong> command may be used:</p>
<pre>
if(POLICY CMP0990)
  cmake_policy(SET CMP0990 NEW)
endif()
</pre>
<p>This has the effect of using the <strong>NEW</strong> behavior with newer CMake releases which users may be using and not issuing a compatibility warning.</p><p>The setting of a policy is confined in some cases to not propagate to the parent scope.  For example, if the files read by the <strong>include()</strong> command or the <strong>find_package()</strong> command contain a use of <strong>cmake_policy()</strong>, that policy setting will not affect the caller by default.  Both commands accept an optional <strong>NO_POLICY_SCOPE</strong> keyword to control this behavior.</p><p>The <strong>CMAKE_MINIMUM_REQUIRED_VERSION</strong> variable may also be used to determine whether to report an error on use of deprecated macros or functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ALL POLICIES</h2>
        <div class="sectioncontent">
<h3>CMP0000</h3>
<p>A minimum required CMake version must be specified.</p><p>CMake requires that projects specify the version of CMake to which they have been written.  This policy has been put in place so users trying to build the project may be told when they need to update their CMake.  Specifying a version also helps the project build with CMake versions newer than that specified.  Use the cmake_minimum_required command at the top of your main CMakeLists.txt file:</p>
<pre>
cmake_minimum_required(VERSION &lt;major&gt;.&lt;minor&gt;)
</pre>
<p>where "&lt;major&gt;.&lt;minor&gt;" is the version of CMake you want to support (such as "2.6").  The command will ensure that at least the given version of CMake is running and help newer versions be compatible with the project.  See documentation of cmake_minimum_required for details.</p><p>Note that the command invocation must appear in the CMakeLists.txt file itself; a call in an included file is not sufficient.  However, the cmake_policy command may be called to set policy CMP0000 to OLD or NEW behavior explicitly.  The OLD behavior is to silently ignore the missing invocation.  The NEW behavior is to issue an error instead of a warning.  An included file may set CMP0000 explicitly to affect how this policy is enforced for the main CMakeLists.txt file.</p><p>This policy was introduced in CMake version 2.6.0.</p>
<h3>CMP0001</h3>
<p>CMAKE_BACKWARDS_COMPATIBILITY should no longer be used.</p><p>The OLD behavior is to check CMAKE_BACKWARDS_COMPATIBILITY and present it to the user.  The NEW behavior is to ignore CMAKE_BACKWARDS_COMPATIBILITY completely.</p><p>In CMake 2.4 and below the variable CMAKE_BACKWARDS_COMPATIBILITY was used to request compatibility with earlier versions of CMake.  In CMake 2.6 and above all compatibility issues are handled by policies and the cmake_policy command.  However, CMake must still check CMAKE_BACKWARDS_COMPATIBILITY for projects written for CMake 2.4 and below.</p><p>This policy was introduced in CMake version 2.6.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0002</h3>
<p>Logical target names must be globally unique.</p><p>Targets names created with add_executable, add_library, or add_custom_target are logical build target names.  Logical target names must be globally unique because:</p>
<pre>
- Unique names may be referenced unambiguously both in CMake
  code and on make tool command lines.
- Logical names are used by Xcode and VS IDE generators
  to produce meaningful project names for the targets.
</pre>
<p>The logical name of executable and library targets does not have to correspond to the physical file names built.  Consider using the OUTPUT_NAME target property to create two targets with the same physical name while keeping logical names distinct.  Custom targets must simply have globally unique names (unless one uses the global property ALLOW_DUPLICATE_CUSTOM_TARGETS with a Makefiles generator).</p><p>This policy was introduced in CMake version 2.6.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0003</h3>
<p>Libraries linked via full path no longer produce linker search paths.</p><p>This policy affects how libraries whose full paths are NOT known are found at link time, but was created due to a change in how CMake deals with libraries whose full paths are known.  Consider the code</p>
<pre>
target_link_libraries(myexe /path/to/libA.so)
</pre>
<p>CMake 2.4 and below implemented linking to libraries whose full paths are known by splitting them on the link line into separate components consisting of the linker search path and the library name.  The example code might have produced something like</p>
<pre>
... -L/path/to -lA ...
</pre>
<p>in order to link to library A.  An analysis was performed to order multiple link directories such that the linker would find library A in the desired location, but there are cases in which this does not work. CMake versions 2.6 and above use the more reliable approach of passing the full path to libraries directly to the linker in most cases.  The example code now produces something like</p>
<pre>
... /path/to/libA.so ....
</pre>
<p>Unfortunately this change can break code like</p>
<pre>
target_link_libraries(myexe /path/to/libA.so B)
</pre>
<p>where "B" is meant to find "/path/to/libB.so".  This code is wrong because the user is asking the linker to find library B but has not provided a linker search path (which may be added with the link_directories command).  However, with the old linking implementation the code would work accidentally because the linker search path added for library A allowed library B to be found.</p><p>In order to support projects depending on linker search paths added by linking to libraries with known full paths, the OLD behavior for this policy will add the linker search paths even though they are not needed for their own libraries.  When this policy is set to OLD, CMake will produce a link line such as</p>
<pre>
... -L/path/to /path/to/libA.so -lB ...
</pre>
<p>which will allow library B to be found as it was previously.  When this policy is set to NEW, CMake will produce a link line such as</p>
<pre>
... /path/to/libA.so -lB ...
</pre>
<p>which more accurately matches what the project specified.</p><p>The setting for this policy used when generating the link line is that in effect when the target is created by an add_executable or add_library command.  For the example described above, the code</p>
<pre>
cmake_policy(SET CMP0003 OLD) # or cmake_policy(VERSION 2.4)
add_executable(myexe myexe.c)
target_link_libraries(myexe /path/to/libA.so B)
</pre>
<p>will work and suppress the warning for this policy.  It may also be updated to work with the corrected linking approach:</p>
<pre>
cmake_policy(SET CMP0003 NEW) # or cmake_policy(VERSION 2.6)
link_directories(/path/to) # needed to find library B
add_executable(myexe myexe.c)
target_link_libraries(myexe /path/to/libA.so B)
</pre>
<p>Even better, library B may be specified with a full path:</p>
<pre>
add_executable(myexe myexe.c)
target_link_libraries(myexe /path/to/libA.so /path/to/libB.so)
</pre>
<p>When all items on the link line have known paths CMake does not check this policy so it has no effect.</p><p>Note that the warning for this policy will be issued for at most one target.  This avoids flooding users with messages for every target when setting the policy once will probably fix all targets.</p><p>This policy was introduced in CMake version 2.6.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0004</h3>
<p>Libraries linked may not have leading or trailing whitespace.</p><p>CMake versions 2.4 and below silently removed leading and trailing whitespace from libraries linked with code like</p>
<pre>
target_link_libraries(myexe " A ")
</pre>
<p>This could lead to subtle errors in user projects.</p><p>The OLD behavior for this policy is to silently remove leading and trailing whitespace.  The NEW behavior for this policy is to diagnose the existence of such whitespace as an error.  The setting for this policy used when checking the library names is that in effect when the target is created by an add_executable or add_library command.</p><p>This policy was introduced in CMake version 2.6.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0005</h3>
<p>Preprocessor definition values are now escaped automatically.</p><p>This policy determines whether or not CMake should generate escaped preprocessor definition values added via add_definitions.  CMake versions 2.4 and below assumed that only trivial values would be given for macros in add_definitions calls.  It did not attempt to escape non-trivial values such as string literals in generated build rules. CMake versions 2.6 and above support escaping of most values, but cannot assume the user has not added escapes already in an attempt to work around limitations in earlier versions.</p><p>The OLD behavior for this policy is to place definition values given to add_definitions directly in the generated build rules without attempting to escape anything.  The NEW behavior for this policy is to generate correct escapes for all native build tools automatically. See documentation of the COMPILE_DEFINITIONS target property for limitations of the escaping implementation.</p><p>This policy was introduced in CMake version 2.6.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0006</h3>
<p>Installing MACOSX_BUNDLE targets requires a BUNDLE DESTINATION.</p><p>This policy determines whether the install(TARGETS) command must be given a BUNDLE DESTINATION when asked to install a target with the MACOSX_BUNDLE property set.  CMake 2.4 and below did not distinguish application bundles from normal executables when installing targets. CMake 2.6 provides a BUNDLE option to the install(TARGETS) command that specifies rules specific to application bundles on the Mac. Projects should use this option when installing a target with the MACOSX_BUNDLE property set.</p><p>The OLD behavior for this policy is to fall back to the RUNTIME DESTINATION if a BUNDLE DESTINATION is not given.  The NEW behavior for this policy is to produce an error if a bundle target is installed without a BUNDLE DESTINATION.</p><p>This policy was introduced in CMake version 2.6.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0007</h3>
<p>list command no longer ignores empty elements.</p><p>This policy determines whether the list command will ignore empty elements in the list.  CMake 2.4 and below list commands ignored all empty elements in the list.  For example, a;b;;c would have length 3 and not 4.  The OLD behavior for this policy is to ignore empty list elements.  The NEW behavior for this policy is to correctly count empty elements in a list.</p><p>This policy was introduced in CMake version 2.6.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0008</h3>
<p>Libraries linked by full-path must have a valid library file name.</p><p>In CMake 2.4 and below it is possible to write code like</p>
<pre>
target_link_libraries(myexe /full/path/to/somelib)
</pre>
<p>where "somelib" is supposed to be a valid library file name such as "libsomelib.a" or "somelib.lib".  For Makefile generators this produces an error at build time because the dependency on the full path cannot be found.  For VS IDE and Xcode generators this used to work by accident because CMake would always split off the library directory and ask the linker to search for the library by name (-lsomelib or somelib.lib).  Despite the failure with Makefiles, some projects have code like this and build only with VS and/or Xcode. This version of CMake prefers to pass the full path directly to the native build tool, which will fail in this case because it does not name a valid library file.</p><p>This policy determines what to do with full paths that do not appear to name a valid library file.  The OLD behavior for this policy is to split the library name from the path and ask the linker to search for it.  The NEW behavior for this policy is to trust the given path and pass it directly to the native build tool unchanged.</p><p>This policy was introduced in CMake version 2.6.1.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0009</h3>
<p>FILE GLOB_RECURSE calls should not follow symlinks by default.</p><p>In CMake 2.6.1 and below, FILE GLOB_RECURSE calls would follow through symlinks, sometimes coming up with unexpectedly large result sets because of symlinks to top level directories that contain hundreds of thousands of files.</p><p>This policy determines whether or not to follow symlinks encountered during a FILE GLOB_RECURSE call.  The OLD behavior for this policy is to follow the symlinks.  The NEW behavior for this policy is not to follow the symlinks by default, but only if FOLLOW_SYMLINKS is given as an additional argument to the FILE command.</p><p>This policy was introduced in CMake version 2.6.2.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0010</h3>
<p>Bad variable reference syntax is an error.</p><p>In CMake 2.6.2 and below, incorrect variable reference syntax such as a missing close-brace ("${FOO") was reported but did not stop processing of CMake code.  This policy determines whether a bad variable reference is an error.  The OLD behavior for this policy is to warn about the error, leave the string untouched, and continue. The NEW behavior for this policy is to report an error.</p><p>This policy was introduced in CMake version 2.6.3.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0011</h3>
<p>Included scripts do automatic cmake_policy PUSH and POP.</p><p>In CMake 2.6.2 and below, CMake Policy settings in scripts loaded by the include() and find_package() commands would affect the includer. Explicit invocations of cmake_policy(PUSH) and cmake_policy(POP) were required to isolate policy changes and protect the includer.  While some scripts intend to affect the policies of their includer, most do not.  In CMake 2.6.3 and above, include() and find_package() by default PUSH and POP an entry on the policy stack around an included script, but provide a NO_POLICY_SCOPE option to disable it.  This policy determines whether or not to imply NO_POLICY_SCOPE for compatibility.  The OLD behavior for this policy is to imply NO_POLICY_SCOPE for include() and find_package() commands.  The NEW behavior for this policy is to allow the commands to do their default cmake_policy PUSH and POP.</p><p>This policy was introduced in CMake version 2.6.3.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0012</h3>
<p>if() recognizes numbers and boolean constants.</p><p>In CMake versions 2.6.4 and lower the if() command implicitly dereferenced arguments corresponding to variables, even those named like numbers or boolean constants, except for 0 and 1.  Numbers and boolean constants such as true, false, yes, no, on, off, y, n, notfound, ignore (all case insensitive) were recognized in some cases but not all.  For example, the code "if(TRUE)" might have evaluated as false.  Numbers such as 2 were recognized only in boolean expressions like "if(NOT 2)" (leading to false) but not as a single-argument like "if(2)" (also leading to false).  Later versions of CMake prefer to treat numbers and boolean constants literally, so they should not be used as variable names.</p><p>The OLD behavior for this policy is to implicitly dereference variables named like numbers and boolean constants.  The NEW behavior for this policy is to recognize numbers and boolean constants without dereferencing variables with such names.</p><p>This policy was introduced in CMake version 2.8.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0013</h3>
<p>Duplicate binary directories are not allowed.</p><p>CMake 2.6.3 and below silently permitted add_subdirectory() calls to create the same binary directory multiple times.  During build system generation files would be written and then overwritten in the build tree and could lead to strange behavior.  CMake 2.6.4 and above explicitly detect duplicate binary directories.  CMake 2.6.4 always considers this case an error.  In CMake 2.8.0 and above this policy determines whether or not the case is an error.  The OLD behavior for this policy is to allow duplicate binary directories.  The NEW behavior for this policy is to disallow duplicate binary directories with an error.</p><p>This policy was introduced in CMake version 2.8.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0014</h3>
<p>Input directories must have CMakeLists.txt.</p><p>CMake versions before 2.8 silently ignored missing CMakeLists.txt files in directories referenced by add_subdirectory() or subdirs(), treating them as if present but empty.  In CMake 2.8.0 and above this policy determines whether or not the case is an error.  The OLD behavior for this policy is to silently ignore the problem.  The NEW behavior for this policy is to report an error.</p><p>This policy was introduced in CMake version 2.8.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0015</h3>
<p>link_directories() treats paths relative to the source dir.</p><p>In CMake 2.8.0 and lower the link_directories() command passed relative paths unchanged to the linker.  In CMake 2.8.1 and above the link_directories() command prefers to interpret relative paths with respect to CMAKE_CURRENT_SOURCE_DIR, which is consistent with include_directories() and other commands.  The OLD behavior for this policy is to use relative paths verbatim in the linker command.  The NEW behavior for this policy is to convert relative paths to absolute paths by appending the relative path to CMAKE_CURRENT_SOURCE_DIR.</p><p>This policy was introduced in CMake version 2.8.1.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0016</h3>
<p>target_link_libraries() reports error if its only argument is not a target.</p><p>In CMake 2.8.2 and lower the target_link_libraries() command silently ignored if it was called with only one argument, and this argument wasn&apos;t a valid target.  In CMake 2.8.3 and above it reports an error in this case.</p><p>This policy was introduced in CMake version 2.8.3.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0017</h3>
<p>Prefer files from the CMake module directory when including from there.</p><p>Starting with CMake 2.8.4, if a cmake-module shipped with CMake (i.e. located in the CMake module directory) calls include() or find_package(), the files located in the CMake module directory are preferred over the files in CMAKE_MODULE_PATH.  This makes sure that the modules belonging to CMake always get those files included which they expect, and against which they were developed and tested.  In all other cases, the files found in CMAKE_MODULE_PATH still take precedence over the ones in the CMake module directory.  The OLD behavior is to always prefer files from CMAKE_MODULE_PATH over files from the CMake modules directory.</p><p>This policy was introduced in CMake version 2.8.4.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0018</h3>
<p>Ignore CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS variable.</p><p>CMake 2.8.8 and lower compiled sources in SHARED and MODULE libraries using the value of the undocumented CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS platform variable.  The variable contained platform-specific flags needed to compile objects for shared libraries.  Typically it included a flag such as -fPIC for position independent code but also included other flags needed on certain platforms.  CMake 2.8.9 and higher prefer instead to use the POSITION_INDEPENDENT_CODE target property to determine what targets should be position independent, and new undocumented platform variables to select flags while ignoring CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS completely.</p><p>The default for either approach produces identical compilation flags, but if a project modifies CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS from its original value this policy determines which approach to use.</p><p>The OLD behavior for this policy is to ignore the POSITION_INDEPENDENT_CODE property for all targets and use the modified value of CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS for SHARED and MODULE libraries.</p><p>The NEW behavior for this policy is to ignore CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS whether it is modified or not and honor the POSITION_INDEPENDENT_CODE target property.</p><p>This policy was introduced in CMake version 2.8.9.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0019</h3>
<p>Do not re-expand variables in include and link information.</p><p>CMake 2.8.10 and lower re-evaluated values given to the include_directories, link_directories, and link_libraries commands to expand any leftover variable references at the end of the configuration step.  This was for strict compatibility with VERY early CMake versions because all variable references are now normally evaluated during CMake language processing.  CMake 2.8.11 and higher prefer to skip the extra evaluation.</p><p>The OLD behavior for this policy is to re-evaluate the values for strict compatibility.  The NEW behavior for this policy is to leave the values untouched.</p><p>This policy was introduced in CMake version 2.8.11.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0020</h3>
<p>Automatically link Qt executables to qtmain target on Windows.</p><p>CMake 2.8.10 and lower required users of Qt to always specify a link dependency to the qtmain.lib static library manually on Windows. CMake 2.8.11 gained the ability to evaluate generator expressions while determining the link dependencies from IMPORTED targets.  This allows CMake itself to automatically link executables which link to Qt to the qtmain.lib library when using IMPORTED Qt targets.  For applications already linking to qtmain.lib, this should have little impact.  For applications which supply their own alternative WinMain implementation and for applications which use the QAxServer library, this automatic linking will need to be disabled as per the documentation.</p><p>The OLD behavior for this policy is not to link executables to qtmain.lib automatically when they link to the QtCore IMPORTEDtarget. The NEW behavior for this policy is to link executables to qtmain.lib automatically when they link to QtCore IMPORTED target.</p><p>This policy was introduced in CMake version 2.8.11.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0021</h3>
<p>Fatal error on relative paths in INCLUDE_DIRECTORIES target property.</p><p>CMake 2.8.10.2 and lower allowed the INCLUDE_DIRECTORIES target property to contain relative paths.  The base path for such relative entries is not well defined.  CMake 2.8.12 issues a FATAL_ERROR if the INCLUDE_DIRECTORIES property contains a relative path.</p><p>The OLD behavior for this policy is not to warn about relative paths in the INCLUDE_DIRECTORIES target property.  The NEW behavior for this policy is to issue a FATAL_ERROR if INCLUDE_DIRECTORIES contains a relative path.</p><p>This policy was introduced in CMake version 2.8.12.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0022</h3>
<p>INTERFACE_LINK_LIBRARIES defines the link interface.</p><p>CMake 2.8.11 constructed the &apos;link interface&apos; of a target from properties matching <strong>(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)?</strong>. The modern way to specify config-sensitive content is to use generator expressions and the <strong>IMPORTED_</strong> prefix makes uniform processing of the link interface with generator expressions impossible.  The INTERFACE_LINK_LIBRARIES target property was introduced as a replacement in CMake 2.8.12.  This new property is named consistently with the INTERFACE_COMPILE_DEFINITIONS, INTERFACE_INCLUDE_DIRECTORIES and INTERFACE_COMPILE_OPTIONS properties.  For in-build targets, CMake will use the INTERFACE_LINK_LIBRARIES property as the source of the link interface only if policy CMP0022 is NEW.  When exporting a target which has this policy set to NEW, only the INTERFACE_LINK_LIBRARIES property will be processed and generated for the IMPORTED target by default.  A new option to the install(EXPORT) and export commands allows export of the old-style properties for compatibility with downstream users of CMake versions older than 2.8.12.  The target_link_libraries command will no longer populate the properties matching LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)? if this policy is NEW.</p><p>Warning-free future-compatible code which works with CMake 2.8.7 onwards can be written by using the <strong>LINK_PRIVATE</strong> and <strong>LINK_PUBLIC</strong> keywords of <strong>target_link_libraries()</strong>.</p><p>The OLD behavior for this policy is to ignore the INTERFACE_LINK_LIBRARIES property for in-build targets.  The NEW behavior for this policy is to use the INTERFACE_LINK_LIBRARIES property for in-build targets, and ignore the old properties matching <strong>(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)?</strong>.</p><p>This policy was introduced in CMake version 2.8.12.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0023</h3>
<p>Plain and keyword target_link_libraries signatures cannot be mixed.</p><p>CMake 2.8.12 introduced the target_link_libraries signature using the PUBLIC, PRIVATE, and INTERFACE keywords to generalize the LINK_PUBLIC and LINK_PRIVATE keywords introduced in CMake 2.8.7.  Use of signatures with any of these keywords sets the link interface of a target explicitly, even if empty.  This produces confusing behavior when used in combination with the historical behavior of the plain target_link_libraries signature.  For example, consider the code:</p>
<pre>
target_link_libraries(mylib A)
target_link_libraries(mylib PRIVATE B)
</pre>
<p>After the first line the link interface has not been set explicitly so CMake would use the link implementation, A, as the link interface. However, the second line sets the link interface to empty.  In order to avoid this subtle behavior CMake now prefers to disallow mixing the plain and keyword signatures of target_link_libraries for a single target.</p><p>The OLD behavior for this policy is to allow keyword and plain target_link_libraries signatures to be mixed.  The NEW behavior for this policy is to not to allow mixing of the keyword and plain signatures.</p><p>This policy was introduced in CMake version 2.8.12.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0024</h3>
<p>Disallow include export result.</p><p>CMake 2.8.12 and lower allowed use of the include() command with the result of the export() command.  This relies on the assumption that the export() command has an immediate effect at configure-time during a cmake run.  Certain properties of targets are not fully determined until later at generate-time, such as the link language and complete list of link libraries.  Future refactoring will change the effect of the export() command to be executed at generate-time.  Use ALIAS targets instead in cases where the goal is to refer to targets by another name.</p><p>The OLD behavior for this policy is to allow including the result of an export() command.  The NEW behavior for this policy is not to allow including the result of an export() command.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0025</h3>
<p>Compiler id for Apple Clang is now <strong>AppleClang</strong>.</p><p>CMake 3.0 and above recognize that Apple Clang is a different compiler than upstream Clang and that they have different version numbers. CMake now prefers to present this to projects by setting the <strong>CMAKE_&lt;LANG&gt;_COMPILER_ID</strong> variable to <strong>AppleClang</strong> instead of <strong>Clang</strong>.  However, existing projects may assume the compiler id for Apple Clang is just <strong>Clang</strong> as it was in CMake versions prior to 3.0. Therefore this policy determines for Apple Clang which compiler id to report in the <strong>CMAKE_&lt;LANG&gt;_COMPILER_ID</strong> variable after language <strong>&lt;LANG&gt;</strong> is enabled by the <strong>project()</strong> or <strong>enable_language()</strong> command.  The policy must be set prior to the invocation of either command.</p><p>The OLD behavior for this policy is to use compiler id <strong>Clang</strong>.  The NEW behavior for this policy is to use compiler id <strong>AppleClang</strong>.</p><p>This policy was introduced in CMake version 3.0.  Use the <strong>cmake_policy()</strong> command to set this policy to OLD or NEW explicitly. Unlike most policies, CMake version 3.0.2 does <em>not</em> warn by default when this policy is not set and simply uses OLD behavior. See documentation of the <strong>CMAKE_POLICY_WARNING_CMP0025</strong> variable to control the warning.</p>
<h3>CMP0026</h3>
<p>Disallow use of the LOCATION target property.</p><p>CMake 2.8.12 and lower allowed reading the LOCATION target property (and configuration-specific variants) to determine the eventual location of build targets.  This relies on the assumption that all necessary information is available at configure-time to determine the final location and filename of the target.  However, this property is not fully determined until later at generate-time.  At generate time, the $&lt;TARGET_FILE&gt; generator expression can be used to determine the eventual LOCATION of a target output.</p><p>Code which reads the LOCATION target property can be ported to use the $&lt;TARGET_FILE&gt; generator expression together with the file(GENERATE) subcommand to generate a file containing the target location.</p><p>The OLD behavior for this policy is to allow reading the LOCATION properties from build-targets.  The NEW behavior for this policy is to not to allow reading the LOCATION properties from build-targets.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0027</h3>
<p>Conditionally linked imported targets with missing include directories.</p><p>CMake 2.8.11 introduced introduced the concept of INTERFACE_INCLUDE_DIRECTORIES, and a check at cmake time that the entries in the INTERFACE_INCLUDE_DIRECTORIES of an IMPORTED target actually exist.  CMake 2.8.11 also introduced generator expression support in the target_link_libraries command.  However, if an imported target is linked as a result of a generator expression evaluation, the entries in the INTERFACE_INCLUDE_DIRECTORIES of that target were not checked for existence as they should be.</p><p>The OLD behavior of this policy is to report a warning if an entry in the INTERFACE_INCLUDE_DIRECTORIES of a generator-expression conditionally linked IMPORTED target does not exist.</p><p>The NEW behavior of this policy is to report an error if an entry in the INTERFACE_INCLUDE_DIRECTORIES of a generator-expression conditionally linked IMPORTED target does not exist.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0028</h3>
<p>Double colon in target name means ALIAS or IMPORTED target.</p><p>CMake 2.8.12 and lower allowed the use of targets and files with double colons in target_link_libraries, with some buildsystem generators.</p><p>The use of double-colons is a common pattern used to namespace IMPORTED targets and ALIAS targets.  When computing the link dependencies of a target, the name of each dependency could either be a target, or a file on disk. Previously, if a target was not found with a matching name, the name was considered to refer to a file on disk.  This can lead to confusing error messages if there is a typo in what should be a target name.</p><p>The OLD behavior for this policy is to search for targets, then files on disk, even if the search term contains double-colons.  The NEW behavior for this policy is to issue a FATAL_ERROR if a link dependency contains double-colons but is not an IMPORTED target or an ALIAS target.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0029</h3>
<p>The <strong>subdir_depends()</strong> command should not be called.</p><p>The implementation of this command has been empty since December 2001 but was kept in CMake for compatibility for a long time.</p><p>CMake &gt;= 3.0 prefer that this command never be called. The OLD behavior for this policy is to allow the command to be called. The NEW behavior for this policy is to issue a FATAL_ERROR when the command is called.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0030</h3>
<p>The <strong>use_mangled_mesa()</strong> command should not be called.</p><p>This command was created in September 2001 to support VTK before modern CMake language and custom command capabilities.  VTK has not used it in years.</p><p>CMake &gt;= 3.0 prefer that this command never be called. The OLD behavior for this policy is to allow the command to be called. The NEW behavior for this policy is to issue a FATAL_ERROR when the command is called.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0031</h3>
<p>The <strong>load_command()</strong> command should not be called.</p><p>This command was added in August 2002 to allow projects to add arbitrary commands implemented in C or C++.  However, it does not work when the toolchain in use does not match the ABI of the CMake process.  It has been mostly superseded by the <strong>macro()</strong> and <strong>function()</strong> commands.</p><p>CMake &gt;= 3.0 prefer that this command never be called. The OLD behavior for this policy is to allow the command to be called. The NEW behavior for this policy is to issue a FATAL_ERROR when the command is called.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0032</h3>
<p>The <strong>output_required_files()</strong> command should not be called.</p><p>This command was added in June 2001 to expose the then-current CMake implicit dependency scanner.  CMake&apos;s real implicit dependency scanner has evolved since then but is not exposed through this command.  The scanning capabilities of this command are very limited and this functionality is better achieved through dedicated outside tools.</p><p>CMake &gt;= 3.0 prefer that this command never be called. The OLD behavior for this policy is to allow the command to be called. The NEW behavior for this policy is to issue a FATAL_ERROR when the command is called.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0033</h3>
<p>The <strong>export_library_dependencies()</strong> command should not be called.</p><p>This command was added in January 2003 to export <strong>&lt;tgt&gt;_LIB_DEPENDS</strong> internal CMake cache entries to a file for installation with a project. This was used at the time to allow transitive link dependencies to work for applications outside of the original build tree of a project. The functionality has been superseded by the <strong>export()</strong> and <strong>install(EXPORT)</strong> commands.</p><p>CMake &gt;= 3.0 prefer that this command never be called. The OLD behavior for this policy is to allow the command to be called. The NEW behavior for this policy is to issue a FATAL_ERROR when the command is called.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0034</h3>
<p>The <strong>utility_source()</strong> command should not be called.</p><p>This command was introduced in March 2001 to help build executables used to generate other files.  This approach has long been replaced by <strong>add_executable()</strong> combined with <strong>add_custom_command()</strong>.</p><p>CMake &gt;= 3.0 prefer that this command never be called. The OLD behavior for this policy is to allow the command to be called. The NEW behavior for this policy is to issue a FATAL_ERROR when the command is called.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0035</h3>
<p>The <strong>variable_requires()</strong> command should not be called.</p><p>This command was introduced in November 2001 to perform some conditional logic.  It has long been replaced by the <strong>if()</strong> command.</p><p>CMake &gt;= 3.0 prefer that this command never be called. The OLD behavior for this policy is to allow the command to be called. The NEW behavior for this policy is to issue a FATAL_ERROR when the command is called.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0036</h3>
<p>The <strong>build_name()</strong> command should not be called.</p><p>This command was added in May 2001 to compute a name for the current operating system and compiler combination.  The command has long been documented as discouraged and replaced by the <strong>CMAKE_SYSTEM</strong> and <strong>CMAKE_&lt;LANG&gt;_COMPILER</strong> variables.</p><p>CMake &gt;= 3.0 prefer that this command never be called. The OLD behavior for this policy is to allow the command to be called. The NEW behavior for this policy is to issue a FATAL_ERROR when the command is called.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0037</h3>
<p>Target names should not be reserved and should match a validity pattern.</p><p>CMake 2.8.12 and lower allowed creating targets using <strong>add_library()</strong>, <strong>add_executable()</strong> and <strong>add_custom_target()</strong> with unrestricted choice for the target name.  Newer cmake features such as <a href="../man7/cmake-generator-expressions.7.html"><strong>cmake-generator-expressions</strong>(7)</a></strong> and some diagnostics expect target names to match a restricted pattern.</p><p>Target names may contain upper and lower case letters, numbers, the underscore character (_), dot(.), plus(+) and minus(-).  As a special case, ALIAS targets and IMPORTED targets may contain two consequtive colons.</p><p>Target names reserved by one or more CMake generators are not allowed. Among others these include "all", "help" and "test".</p><p>The OLD behavior for this policy is to allow creating targets with reserved names or which do not match the validity pattern. The NEW behavior for this policy is to report an error if an add_* command is used with an invalid target name.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0038</h3>
<p>Targets may not link directly to themselves.</p><p>CMake 2.8.12 and lower allowed a build target to link to itself directly with a <strong>target_link_libraries()</strong> call. This is an indicator of a bug in user code.</p><p>The OLD behavior for this policy is to ignore targets which list themselves in their own link implementation.  The NEW behavior for this policy is to report an error if a target attempts to link to itself.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0039</h3>
<p>Utility targets may not have link dependencies.</p><p>CMake 2.8.12 and lower allowed using utility targets in the left hand side position of the <strong>target_link_libraries()</strong> command. This is an indicator of a bug in user code.</p><p>The OLD behavior for this policy is to ignore attempts to set the link libraries of utility targets.  The NEW behavior for this policy is to report an error if an attempt is made to set the link libraries of a utility target.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0040</h3>
<p>The target in the TARGET signature of add_custom_command() must exist.</p><p>CMake 2.8.12 and lower silently ignored a custom command created with the TARGET signature of <strong>add_custom_command()</strong> if the target is unknown.</p><p>The OLD behavior for this policy is to ignore custom commands for unknown targets. The NEW behavior for this policy is to report an error if the target referenced in <strong>add_custom_command()</strong> is unknown.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0041</h3>
<p>Error on relative include with generator expression.</p><p>Diagnostics in CMake 2.8.12 and lower silently ignored an entry in the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> of a target if it contained a generator expression at any position.</p><p>The path entries in that target property should not be relative. High-level API should ensure that by adding either a source directory or a install directory prefix, as appropriate.</p><p>As an additional diagnostic, the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> generated on an <strong>IMPORTED</strong> target for the install location should not contain paths in the source directory or the build directory.</p><p>The OLD behavior for this policy is to ignore relative path entries if they contain a generator expression. The NEW behavior for this policy is to report an error if a generator expression appears in another location and the path is relative.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0042</h3>
<p><strong>MACOSX_RPATH</strong> is enabled by default.</p><p>CMake 2.8.12 and newer has support for using <strong>@rpath</strong> in a target&apos;s install name.  This was enabled by setting the target property <strong>MACOSX_RPATH</strong>.  The <strong>@rpath</strong> in an install name is a more flexible and powerful mechanism than <strong>@executable_path</strong> or <strong>@loader_path</strong> for locating shared libraries.</p><p>CMake 3.0 and later prefer this property to be ON by default.  Projects wanting <strong>@rpath</strong> in a target&apos;s install name may remove any setting of the <strong>INSTALL_NAME_DIR</strong> and <strong>CMAKE_INSTALL_NAME_DIR</strong> variables.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0043</h3>
<p>Ignore COMPILE_DEFINITIONS_&lt;Config&gt; properties</p><p>CMake 2.8.12 and lower allowed setting the <strong>COMPILE_DEFINITIONS_&lt;CONFIG&gt;</strong> target property and <strong>COMPILE_DEFINITIONS_&lt;CONFIG&gt;</strong> directory property to apply configuration-specific compile definitions.</p><p>Since CMake 2.8.10, the <strong>COMPILE_DEFINITIONS</strong> property has supported <strong>generator expressions</strong> for setting configuration-dependent content.  The continued existence of the suffixed variables is redundant, and causes a maintenance burden.  Population of the <strong>COMPILE_DEFINITIONS_DEBUG</strong> property may be replaced with a population of <strong>COMPILE_DEFINITIONS</strong> directly or via <strong>target_compile_definitions()</strong>:</p>
<pre>
# Old Interfaces:
set_property(TARGET tgt APPEND PROPERTY
  COMPILE_DEFINITIONS_DEBUG DEBUG_MODE
)
set_property(DIRECTORY APPEND PROPERTY
  COMPILE_DEFINITIONS_DEBUG DIR_DEBUG_MODE
)

# New Interfaces:
set_property(TARGET tgt APPEND PROPERTY
  COMPILE_DEFINITIONS $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_MODE&gt;
)
target_compile_definitions(tgt PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_MODE&gt;)
set_property(DIRECTORY APPEND PROPERTY
  COMPILE_DEFINITIONS $&lt;$&lt;CONFIG:Debug&gt;:DIR_DEBUG_MODE&gt;
)
</pre>
<p>The OLD behavior for this policy is to consume the content of the suffixed <strong>COMPILE_DEFINITIONS_&lt;CONFIG&gt;</strong> target property when generating the compilation command. The NEW behavior for this policy is to ignore the content of the <strong>COMPILE_DEFINITIONS_&lt;CONFIG&gt;</strong> target property .</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0044</h3>
<p>Case sensitive <strong>&lt;LANG&gt;_COMPILER_ID</strong> generator expressions</p><p>CMake 2.8.12 introduced the <strong>&lt;LANG&gt;_COMPILER_ID</strong> <strong>generator expressions</strong> to allow comparison of the <strong>CMAKE_&lt;LANG&gt;_COMPILER_ID</strong> with a test value.  The possible valid values are lowercase, but the comparison with the test value was performed case-insensitively.</p><p>The OLD behavior for this policy is to perform a case-insensitive comparison with the value in the <strong>&lt;LANG&gt;_COMPILER_ID</strong> expression. The NEW behavior for this policy is to perform a case-sensitive comparison with the value in the <strong>&lt;LANG&gt;_COMPILER_ID</strong> expression.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0045</h3>
<p>Error on non-existent target in get_target_property.</p><p>In CMake 2.8.12 and lower, the <strong>get_target_property()</strong> command accepted a non-existent target argument without issuing any error or warning.  The result variable is set to a <strong>-NOTFOUND</strong> value.</p><p>The OLD behavior for this policy is to issue no warning and set the result variable to a <strong>-NOTFOUND</strong> value.  The NEW behavior for this policy is to issue a <strong>FATAL_ERROR</strong> if the command is called with a non-existent target.</p><p>This policy was introduced in CMake version 3.0.  CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0046</h3>
<p>Error on non-existent dependency in add_dependencies.</p><p>CMake 2.8.12 and lower silently ignored non-existent dependencies listed in the <strong>add_dependencies()</strong> command.</p><p>The OLD behavior for this policy is to silently ignore non-existent dependencies. The NEW behavior for this policy is to report an error if non-existent dependencies are listed in the <strong>add_dependencies()</strong> command.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0047</h3>
<p>Use <strong>QCC</strong> compiler id for the qcc drivers on QNX.</p><p>CMake 3.0 and above recognize that the QNX qcc compiler driver is different from the GNU compiler. CMake now prefers to present this to projects by setting the <strong>CMAKE_&lt;LANG&gt;_COMPILER_ID</strong> variable to <strong>QCC</strong> instead of <strong>GNU</strong>.  However, existing projects may assume the compiler id for QNX qcc is just <strong>GNU</strong> as it was in CMake versions prior to 3.0. Therefore this policy determines for QNX qcc which compiler id to report in the <strong>CMAKE_&lt;LANG&gt;_COMPILER_ID</strong> variable after language <strong>&lt;LANG&gt;</strong> is enabled by the <strong>project()</strong> or <strong>enable_language()</strong> command.  The policy must be set prior to the invocation of either command.</p><p>The OLD behavior for this policy is to use the <strong>GNU</strong> compiler id for the qcc and QCC compiler drivers. The NEW behavior for this policy is to use the <strong>QCC</strong> compiler id for those drivers.</p><p>This policy was introduced in CMake version 3.0.  Use the <strong>cmake_policy()</strong> command to set this policy to OLD or NEW explicitly. Unlike most policies, CMake version 3.0.2 does <em>not</em> warn by default when this policy is not set and simply uses OLD behavior. See documentation of the <strong>CMAKE_POLICY_WARNING_CMP0047</strong> variable to control the warning.</p>
<h3>CMP0048</h3>
<p>The <strong>project()</strong> command manages VERSION variables.</p><p>CMake version 3.0 introduced the <strong>VERSION</strong> option of the <strong>project()</strong> command to specify a project version as well as the name.  In order to keep <strong>PROJECT_VERSION</strong> and related variables consistent with variable <strong>PROJECT_NAME</strong> it is necessary to set the VERSION variables to the empty string when no <strong>VERSION</strong> is given to <strong>project()</strong>. However, this can change behavior for existing projects that set VERSION variables themselves since <strong>project()</strong> may now clear them. This policy controls the behavior for compatibility with such projects.</p><p>The OLD behavior for this policy is to leave VERSION variables untouched. The NEW behavior for this policy is to set VERSION as documented by the <strong>project()</strong> command.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0049</h3>
<p>Do not expand variables in target source entries.</p><p>CMake 2.8.12 and lower performed and extra layer of variable expansion when evaluating source file names:</p>
<pre>
set(a_source foo.c)
add_executable(foo &#92;${a_source})
</pre>
<p>This was undocumented behavior.</p><p>The OLD behavior for this policy is to expand such variables when processing the target sources.  The NEW behavior for this policy is to issue an error if such variables need to be expanded.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>
<h3>CMP0050</h3>
<p>Disallow add_custom_command SOURCE signatures.</p><p>CMake 2.8.12 and lower allowed a signature for <strong>add_custom_command()</strong> which specified an input to a command.  This was undocumented behavior. Modern use of CMake associates custom commands with their output, rather than their input.</p><p>The OLD behavior for this policy is to allow the use of <strong>add_custom_command()</strong> SOURCE signatures.  The NEW behavior for this policy is to issue an error if such a signature is used.</p><p>This policy was introduced in CMake version 3.0. CMake version 3.0.2 warns when the policy is not set and uses OLD behavior.  Use the cmake_policy command to set it to OLD or NEW explicitly.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2000-2014 Kitware, Inc.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="cmake-packages.7.html"><span aria-hidden="true">&larr;</span> cmake-packages.7: Cmake packages reference</a></li>
   <li class="next"><a href="cmake-properties.7.html">cmake-properties.7: Cmake properties reference <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

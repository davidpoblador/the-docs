<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cmake-packages: Cmake packages reference</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Cmake packages reference">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="cmake-packages (7) manual">
  <meta name="twitter:description" content="Cmake packages reference">
  <meta name="twitter:image" content="https://www.carta.tech/images/cmake-data-cmake-packages-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/cmake-packages.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="cmake-packages (7) manual" />
  <meta property="og:description" content="Cmake packages reference" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/cmake-data-cmake-packages-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">cmake-packages<small> (7)</small></h1>
        <p class="lead">Cmake packages reference</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/cmake-packages.7.html">
      <span itemprop="name">cmake-packages: Cmake packages reference</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/cmake-data/">
      <span itemprop="name">cmake-data</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/cmake-packages.7.html">
      <span itemprop="name">cmake-packages: Cmake packages reference</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>Packages provide dependency information to CMake based buildsystems.  Packages are found with the <strong>find_package()</strong> command.  The result of using <strong>find_package</strong> is either a set of <strong>IMPORTED</strong> targets, or a set of variables corresponding to build-relevant information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USING PACKAGES</h2>
        <div class="sectioncontent">
<p>CMake provides direct support for two forms of packages, <em>Config-file Packages</em> and <em>Find-module Packages</em>. Indirect support for <strong>pkg-config</strong> packages is also provided via the <strong>FindPkgConfig</strong> module.  In all cases, the basic form of <strong>find_package()</strong> calls is the same:</p>
<pre>
find_package(Qt4 4.7.0 REQUIRED) # CMake provides a Qt4 find-module
find_package(Qt5Core 5.1.0 REQUIRED) # Qt provides a Qt5 package config file.
find_package(LibXml2 REQUIRED) # Use pkg-config via the LibXml2 find-module
</pre>
<p>In cases where it is known that a package configuration file is provided by upstream, and only that should be used, the <strong>CONFIG</strong> keyword may be passed to <strong>find_package()</strong>:</p>
<pre>
find_package(Qt5Core 5.1.0 CONFIG REQUIRED)
find_package(Qt5Gui 5.1.0 CONFIG)
</pre>
<p>Similarly, the <strong>MODULE</strong> keyword says to use only a find-module:</p>
<pre>
find_package(Qt4 4.7.0 MODULE REQUIRED)
</pre>
<p>Specifying the type of package explicitly improves the error message shown to the user if it is not found.</p><p>Both types of packages also support specifying components of a package, either after the <strong>REQUIRED</strong> keyword:</p>
<pre>
find_package(Qt5 5.1.0 CONFIG REQUIRED Widgets Xml Sql)
</pre>
<p>or as a separate <strong>COMPONENTS</strong> list:</p>
<pre>
find_package(Qt5 5.1.0 COMPONENTS Widgets Xml Sql)
</pre>
<p>or as a separate <strong>OPTIONAL_COMPONENTS</strong> list:</p>
<pre>
find_package(Qt5 5.1.0 COMPONENTS Widgets
                       OPTIONAL_COMPONENTS Xml Sql
)
</pre>
<p>Handling of <strong>COMPONENTS</strong> and <strong>OPTIONAL_COMPONENTS</strong> is defined by the package.</p><p>By setting the <strong>CMAKE_DISABLE_FIND_PACKAGE_&lt;PackageName&gt;</strong> variable to <strong>TRUE</strong>, the <strong>PackageName</strong> package will not be searched, and will always be <strong>NOTFOUND</strong>.</p><h3>Config-file Packages</h3>
<p>A config-file package is a set of files provided by upstreams for downstreams to use. CMake searches in a number of locations for package configuration files, as described in the <strong>find_package()</strong> documentation.  The most simple way for a CMake user to tell <a href="../man1/cmake.1.html"><strong>cmake</strong>(1)</a></strong> to search in a non-standard prefix for a package is to set the <strong>CMAKE_PREFIX_PATH</strong> cache variable.</p><p>Config-file packages are provided by upstream vendors as part of development packages, that is, they belong with the header files and any other files provided to assist downsteams in using the package.</p><p>A set of variables which provide package status information are also set automatically when using a config-file package.  The <strong>&lt;Package&gt;_FOUND</strong> variable is set to true or false, depending on whether the package was found.  The <strong>&lt;Package&gt;_DIR</strong> cache variable is set to the location of the package configuration file.</p>
<h3>Find-module Packages</h3>
<p>A find module is a file with a set of rules for finding the required pieces of a dependency, primarily header files and libraries.  Typically, a find module is needed when the upstream is not built with CMake, or is not CMake-aware enough to otherwise provide a package configuration file.  Unlike a package configuration file, it is not shipped with upstream, but is used by downstream to find the files by guessing locations of files with platform-specific hints.</p><p>Unlike the case of an upstream-provided package configuration file, no single point of reference identifies the package as being found, so the <strong>&lt;Package&gt;_FOUND</strong> variable is not automatically set by the <strong>find_package()</strong> command.  It can still be expected to be set by convention however and should be set by the author of the Find-module.  Similarly there is no <strong>&lt;Package&gt;_DIR</strong> variable, but each of the artifacts such as library locations and header file locations provide a separate cache variable.</p><p>See the <a href="../man7/cmake-developer.7.html"><strong>cmake-developer</strong>(7)</a></strong> manual for more information about creating Find-module files.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PACKAGE LAYOUT</h2>
        <div class="sectioncontent">
<p>A config-file package consists of a <em>Package Configuration File</em> and optionally a <em>Package Version File</em> provided with the project distribution.</p><h3>Package Configuration File</h3>
<p>Consider a project <strong>Foo</strong> that installs the following files:</p>
<pre>
&lt;prefix&gt;/include/foo-1.2/foo.h
&lt;prefix&gt;/lib/foo-1.2/libfoo.a
</pre>
<p>It may also provide a CMake package configuration file:</p>
<pre>
&lt;prefix&gt;/lib/cmake/foo-1.2/FooConfig.cmake
</pre>
<p>with content defining <strong>IMPORTED</strong> targets, or defining variables, such as:</p>
<pre>
# ...
# (compute PREFIX relative to file location)
# ...
set(Foo_INCLUDE_DIRS ${PREFIX}/include/foo-1.2)
set(Foo_LIBRARIES ${PREFIX}/lib/foo-1.2/libfoo.a)
</pre>
<p>If another project wishes to use <strong>Foo</strong> it need only to locate the <strong>FooConfig.cmake</strong> file and load it to get all the information it needs about package content locations.  Since the package configuration file is provided by the package installation it already knows all the file locations.</p><p>The <strong>find_package()</strong> command may be used to search for the package configuration file.  This command constructs a set of installation prefixes and searches under each prefix in several locations.  Given the name <strong>Foo</strong>, it looks for a file called <strong>FooConfig.cmake</strong> or <strong>foo-config.cmake</strong>. The full set of locations is specified in the <strong>find_package()</strong> command documentation. One place it looks is:</p>
<pre>
&lt;prefix&gt;/lib/cmake/Foo*/
</pre>
<p>where <strong>Foo*</strong> is a case-insensitive globbing expression.  In our example the globbing expression will match <strong>&lt;prefix&gt;/lib/cmake/foo-1.2</strong> and the package configuration file will be found.</p><p>Once found, a package configuration file is immediately loaded.  It, together with a package version file, contains all the information the project needs to use the package.</p>
<h3>Package Version File</h3>
<p>When the <strong>find_package()</strong> command finds a candidate package configuration file it looks next to it for a version file. The version file is loaded to test whether the package version is an acceptable match for the version requested. If the version file claims compatibility the configuration file is accepted. Otherwise it is ignored.</p><p>The name of the package version file must match that of the package configuration file but has either <strong>-version</strong> or <strong>Version</strong> appended to the name before the <strong>.cmake</strong> extension.  For example, the files:</p>
<pre>
&lt;prefix&gt;/lib/cmake/foo-1.3/foo-config.cmake
&lt;prefix&gt;/lib/cmake/foo-1.3/foo-config-version.cmake
</pre>
<p>and:</p>
<pre>
&lt;prefix&gt;/lib/cmake/bar-4.2/BarConfig.cmake
&lt;prefix&gt;/lib/cmake/bar-4.2/BarConfigVersion.cmake
</pre>
<p>are each pairs of package configuration files and corresponding package version files.</p><p>When the <strong>find_package()</strong> command loads a version file it first sets the following variables:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_NAME</strong><strong></strong></p>
  </dt>
  <dd>
    <p>The &lt;package&gt; name</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Full requested version string</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_MAJOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Major version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_MINOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Minor version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_PATCH</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Patch version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_TWEAK</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Tweak version if requested, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_FIND_VERSION_COUNT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Number of version components, 0 to 4</p><p>The version file must use these variables to check whether it is compatible or an exact match for the requested version and set the following variables with results:</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_VERSION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Full provided version string</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_VERSION_EXACT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if version is exact match</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_VERSION_COMPATIBLE</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if version is compatible</p>
  </dd>
  <dt>
    <p><strong></strong><strong>PACKAGE_VERSION_UNSUITABLE</strong><strong></strong></p>
  </dt>
  <dd>
    <p>True if unsuitable as any version</p><p>Version files are loaded in a nested scope so they are free to set any variables they wish as part of their computation. The find_package command wipes out the scope when the version file has completed and it has checked the output variables. When the version file claims to be an acceptable match for the requested version the find_package command sets the following variables for use by the project:</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Full provided version string</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_MAJOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Major version if provided, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_MINOR</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Minor version if provided, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_PATCH</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Patch version if provided, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_TWEAK</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Tweak version if provided, else 0</p>
  </dd>
  <dt>
    <p><strong></strong><strong>&lt;package&gt;_VERSION_COUNT</strong><strong></strong></p>
  </dt>
  <dd>
    <p>Number of version components, 0 to 4</p><p>The variables report the version of the package that was actually found. The <strong>&lt;package&gt;</strong> part of their name matches the argument given to the <strong>find_package()</strong> command.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREATING PACKAGES</h2>
        <div class="sectioncontent">
<p>Usually, the upstream depends on CMake itself and can use some CMake facilities for creating the package files. Consider an upstream which provides a single shared library:</p>
<pre>
project(UpstreamLib)

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)

set(Upstream_VERSION 3.4.1)

include(GenerateExportHeader)

add_library(ClimbingStats SHARED climbingstats.cpp)
generate_export_header(ClimbingStats)
set_property(TARGET ClimbingStats PROPERTY VERSION ${Upstream_VERSION})
set_property(TARGET ClimbingStats PROPERTY SOVERSION 3)
set_property(TARGET ClimbingStats PROPERTY INTERFACE_ClimbingStats_MAJOR_VERSION 3)
set_property(TARGET ClimbingStats APPEND PROPERTY
  COMPATIBLE_INTERFACE_STRING ClimbingStats_MAJOR_VERSION
)

install(TARGETS ClimbingStats EXPORT ClimbingStatsTargets
  LIBRARY DESTINATION lib
  ARCHIVE DESTINATION lib
  RUNTIME DESTINATION bin
  INCLUDES DESTINATION include
)
install(
  FILES
    climbingstats.h
    "${CMAKE_CURRENT_BINARY_DIR}/climbingstats_export.h"
  DESTINATION
    include
  COMPONENT
    Devel
)

include(CMakePackageConfigHelpers)
write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfigVersion.cmake"
  VERSION ${Upstream_VERSION}
  COMPATIBILITY AnyNewerVersion
)

export(EXPORT ClimbingStatsTargets
  FILE "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsTargets.cmake"
  NAMESPACE Upstream::
)
configure_file(cmake/ClimbingStatsConfig.cmake
  "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfig.cmake"
  COPY_ONLY
)

set(ConfigPackageLocation lib/cmake/ClimbingStats)
install(EXPORT ClimbingStatsTargets
  FILE
    ClimbingStatsTargets.cmake
  NAMESPACE
    Upstream::
  DESTINATION
    ${ConfigPackageLocation}
)
install(
  FILES
    cmake/ClimbingStatsConfig.cmake
    "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfigVersion.cmake"
  DESTINATION
    ${ConfigPackageLocation}
  COMPONENT
    Devel
)
</pre>
<p>The <strong>CMakePackageConfigHelpers</strong> module provides a macro for creating a simple <strong>ConfigVersion.cmake</strong> file.  This file sets the version of the package.  It is read by CMake when <strong>find_package()</strong> is called to determine the compatibility with the requested version, and to set some version-specific variables <strong>&lt;Package&gt;_VERSION</strong>, <strong>&lt;Package&gt;_VERSION_MAJOR</strong>, <strong>&lt;Package&gt;_VERSION_MINOR</strong> etc.  The <strong>install(EXPORT)</strong> command is used to export the targets in the <strong>ClimbingStatsTargets</strong> export-set, defined previously by the <strong>install(TARGETS)</strong> command. This command generates the <strong>ClimbingStatsTargets.cmake</strong> file to contain <strong>IMPORTED</strong> targets, suitable for use by downsteams and arranges to install it to <strong>lib/cmake/ClimbingStats</strong>.  The generated <strong>ClimbingStatsConfigVersion.cmake</strong> and a <strong>cmake/ClimbingStatsConfig.cmake</strong> are installed to the same location, completing the package.</p><p>The generated <strong>IMPORTED</strong> targets have appropriate properties set to define their usage requirements, such as <strong>INTERFACE_INCLUDE_DIRECTORIES</strong>, <strong>INTERFACE_COMPILE_DEFINITIONS</strong> and other relevant built-in <strong>INTERFACE_</strong> properties.  The <strong>INTERFACE</strong> variant of user-defined properties listed in <strong>COMPATIBLE_INTERFACE_STRING</strong> and other <em>Compatible Interface Properties</em> are also propagated to the generated <strong>IMPORTED</strong> targets.  In the above case, <strong>ClimbingStats_MAJOR_VERSION</strong> is defined as a string which must be compatible among the dependencies of any depender.  By setting this custom defined user property in this version and in the next version of <strong>ClimbingStats</strong>, <a href="../man1/cmake.1.html"><strong>cmake</strong>(1)</a></strong> will issue a diagnostic if there is an attempt to use version 3 together with version 4.  Packages can choose to employ such a pattern if different major versions of the package are designed to be incompatible.</p><p>A <strong>NAMESPACE</strong> with double-colons is specified when exporting the targets for installation.  This convention of double-colons gives CMake a hint that the name is an <strong>IMPORTED</strong> target when it is used by downstreams with the <strong>target_link_libraries()</strong> command.  This way, CMake can issue a diagnostic if the package providing it has not yet been found.</p><p>In this case, when using <strong>install(TARGETS)</strong> the <strong>INCLUDES DESTINATION</strong> was specified.  This causes the <strong>IMPORTED</strong> targets to have their <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> populated with the <strong>include</strong> directory in the <strong>CMAKE_INSTALL_PREFIX</strong>.  When the <strong>IMPORTED</strong> target is used by downsteam, it automatically consumes the entries from that property.</p><p>In this case, the <strong>ClimbingStatsConfig.cmake</strong> file could be as simple as:</p>
<pre>
include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")
</pre>
<p>As this allows downstreams to use the <strong>IMPORTED</strong> targets.  If any macros should be provided by the <strong>ClimbingStats</strong> package, they should be in a separate file which is installed to the same location as the <strong>ClimbingStatsConfig.cmake</strong> file, and included from there.</p><p>Packages created by <strong>install(EXPORT)</strong> are designed to be relocatable, using paths relative to the location of the package itself.  When defining the interface of a target for <strong>EXPORT</strong>, keep in mind that the include directories should be specified as relative paths which are relative to the <strong>CMAKE_INSTALL_PREFIX</strong>:</p>
<pre>
target_include_directories(tgt INTERFACE
  # Wrong, not relocatable:
  $&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include/TgtName&gt;
)

target_include_directories(tgt INTERFACE
  # Ok, relocatable:
  $&lt;INSTALL_INTERFACE:include/TgtName&gt;
)
</pre>
<p>The <strong>$&lt;INSTALL_PREFIX&gt;</strong> <strong>generator expression</strong> may be used as a placeholder for the install prefix without resulting in a non-relocatable package.  This is necessary if complex generator expressions are used:</p>
<pre>
target_include_directories(tgt INTERFACE
  # Ok, relocatable:
  $&lt;INSTALL_INTERFACE:$&lt;$&lt;CONFIG:Debug&gt;:$&lt;INSTALL_PREFIX&gt;/include/TgtName&gt;&gt;
)
</pre>
<p>The <strong>export(EXPORT)</strong> command creates an <strong>IMPORTED</strong> targets definition file which is specific to the build-tree, and is not relocatable. This can similiarly be used with a suitable package configuration file and package version file to define a package for the build tree which may be used without installation.  Consumers of the build tree can simply ensure that the <strong>CMAKE_PREFIX_PATH</strong> contains the build directory, or set the <strong>ClimbingStats_DIR</strong> to <strong>&lt;build_dir&gt;/ClimbingStats</strong> in the cache.</p><p>This can also be extended to cover dependencies:</p>
<pre>
# ...
add_library(ClimbingStats SHARED climbingstats.cpp)
generate_export_header(ClimbingStats)

find_package(Stats 2.6.4 REQUIRED)
target_link_libraries(ClimbingStats PUBLIC Stats::Types)
</pre>
<p>As the <strong>Stats::Types</strong> target is a <strong>PUBLIC</strong> dependency of <strong>ClimbingStats</strong>, downsteams must also find the <strong>Stats</strong> package and link to the <strong>Stats::Types</strong> library.  The <strong>Stats</strong> package should be found in the <strong>ClimbingStatsConfig.cmake</strong> file to ensure this.  The <strong>find_dependency</strong> macro from the <strong>CMakeFindDependencyMacro</strong> helps with this by propagating whether the package is <strong>REQUIRED</strong>, or <strong>QUIET</strong> etc.  All <strong>REQUIRED</strong> dependencies of a package should be found in the <strong>Config.cmake</strong> file:</p>
<pre>
include(CMakeFindDependencyMacro)
find_dependency(Stats 2.6.4)

include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")
include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsMacros.cmake")
</pre>
<p>The <strong>find_dependency</strong> macro also sets <strong>ClimbingStats_FOUND</strong> to <strong>False</strong> if the dependency is not found, along with a diagnostic that the <strong>ClimbingStats</strong> package can not be used without the <strong>Stats</strong> package.</p><p>If <strong>COMPONENTS</strong> are specified when the downstream uses <strong>find_package()</strong>, they are listed in the <strong>&lt;Package&gt;_FIND_COMPONENTS</strong> variable. If a particular component is non-optional, then the <strong>&lt;Package&gt;_FIND_REQUIRED_&lt;comp&gt;</strong> will be true. This can be tested with logic in the package configuration file:</p>
<pre>
include(CMakeFindDependencyMacro)
find_dependency(Stats 2.6.4)

include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")
include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsMacros.cmake")

set(_supported_components Plot Table)

foreach(_comp ${ClimbingStats_FIND_COMPONENTS})
  if (NOT ";${_supported_components};" MATCHES _comp)
    set(ClimbingStats_FOUND False)
    set(ClimbingStats_NOTFOUND_MESSAGE "Specified unsupported component: ${_comp}")
  endif()
  include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStats${_comp}Targets.cmake")
endforeach()
</pre>
<p>Here, the <strong>ClimbingStats_NOTFOUND_MESSAGE</strong> is set to a diagnosis that the package could not be found because an invalid component was specified.  This message variable can be set for any case where the <strong>_FOUND</strong> variable is set to <strong>False</strong>, and will be displayed to the user.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PACKAGE REGISTRY</h2>
        <div class="sectioncontent">
<p>CMake provides two central locations to register packages that have been built or installed anywhere on a system:</p><ul>
<li><p><em>User Package Registry</em></p></li><li><p><em>System Package Registry</em></p><p>The registries are especially useful to help projects find packages in non-standard install locations or directly in their own build trees. A project may populate either the user or system registry (using its own means, see below) to refer to its location. In either case the package should store at the registered location a <em>Package Configuration File</em> (<strong>&lt;package&gt;Config.cmake</strong>) and optionally a <em>Package Version File</em> (<strong>&lt;package&gt;ConfigVersion.cmake</strong>).</p><p>The <strong>find_package()</strong> command searches the two package registries as two of the search steps specified in its documentation.  If it has sufficient permissions it also removes stale package registry entries that refer to directories that do not exist or do not contain a matching package configuration file.</p></li>
</ul><h3>User Package Registry</h3>
<p>The User Package Registry is stored in a per-user location. The <strong>export(PACKAGE)</strong> command may be used to register a project build tree in the user package registry.  CMake currently provides no interface to add install trees to the user package registry.  Installers must be manually taught to register their packages if desired.</p><p>On Windows the user package registry is stored in the Windows registry under a key in <strong>HKEY_CURRENT_USER</strong>.</p><p>A <strong>&lt;package&gt;</strong> may appear under registry key:</p>
<pre>
HKEY_CURRENT_USER&#92;Software&#92;Kitware&#92;CMake&#92;Packages&#92;&lt;package&gt;
</pre>
<p>as a <strong>REG_SZ</strong> value, with arbitrary name, that specifies the directory containing the package configuration file.</p><p>On UNIX platforms the user package registry is stored in the user home directory under <strong>~/.cmake/packages</strong>.  A <strong>&lt;package&gt;</strong> may appear under the directory:</p>
<pre>
~/.cmake/packages/&lt;package&gt;
</pre>
<p>as a file, with arbitrary name, whose content specifies the directory containing the package configuration file.</p>
<h3>System Package Registry</h3>
<p>The System Package Registry is stored in a system-wide location. CMake currently provides no interface to add to the system package registry. Installers must be manually taught to register their packages if desired.</p><p>On Windows the system package registry is stored in the Windows registry under a key in <strong>HKEY_LOCAL_MACHINE</strong>.  A <strong>&lt;package&gt;</strong> may appear under registry key:</p>
<pre>
HKEY_LOCAL_MACHINE&#92;Software&#92;Kitware&#92;CMake&#92;Packages&#92;&lt;package&gt;
</pre>
<p>as a <strong>REG_SZ</strong> value, with arbitrary name, that specifies the directory containing the package configuration file.</p><p>There is no system package registry on non-Windows platforms.</p>
<h3>Package Registry Example</h3>
<p>A simple convention for naming package registry entries is to use content hashes.  They are deterministic and unlikely to collide (<strong>export(PACKAGE)</strong> uses this approach). The name of an entry referencing a specific directory is simply the content hash of the directory path itself.</p><p>If a project arranges for package registry entries to exist, such as:</p>
<pre>
&gt; reg query HKCU&#92;Software&#92;Kitware&#92;CMake&#92;Packages&#92;MyPackage
HKEY_CURRENT_USER&#92;Software&#92;Kitware&#92;CMake&#92;Packages&#92;MyPackage
 45e7d55f13b87179bb12f907c8de6fc4 REG_SZ c:/Users/Me/Work/lib/cmake/MyPackage
 7b4a9844f681c80ce93190d4e3185db9 REG_SZ c:/Users/Me/Work/MyPackage-build
</pre>
<p>or:</p>
<pre>
$ cat ~/.cmake/packages/MyPackage/7d1fb77e07ce59a81bed093bbee945bd
/home/me/work/lib/cmake/MyPackage
$ cat ~/.cmake/packages/MyPackage/f92c1db873a1937f3100706657c63e07
/home/me/work/MyPackage-build
</pre>
<p>then the <strong>CMakeLists.txt</strong> code:</p>
<pre>
find_package(MyPackage)
</pre>
<p>will search the registered locations for package configuration files (<strong>MyPackageConfig.cmake</strong>).  The search order among package registry entries for a single package is unspecified and the entry names (hashes in this example) have no meaning.  Registered locations may contain package version files (<strong>MyPackageConfigVersion.cmake</strong>) to tell <strong>find_package()</strong> whether a specific location is suitable for the version requested.</p>
<h3>Package Registry Ownership</h3>
<p>Package registry entries are individually owned by the project installations that they reference.  A package installer is responsible for adding its own entry and the corresponding uninstaller is responsible for removing it.</p><p>The <strong>export(PACKAGE)</strong> command populates the user package registry with the location of a project build tree.  Build trees tend to be deleted by developers and have no "uninstall" event that could trigger removal of their entries.  In order to keep the registries clean the <strong>find_package()</strong> command automatically removes stale entries it encounters if it has sufficient permissions.  CMake provides no interface to remove an entry referencing an existing build tree once <strong>export(PACKAGE)</strong> has been invoked. However, if the project removes its package configuration file from the build tree then the entry referencing the location will be considered stale.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2000-2014 Kitware, Inc.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="cmake-language.7.html"><span aria-hidden="true">&larr;</span> cmake-language.7: Cmake language reference</a></li>
   <li class="next"><a href="cmake-policies.7.html">cmake-policies.7: Cmake policies reference <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pipe - overview of pipes and FIFOs</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="${metadescription}">
  
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pipe<small> (7)</small></h1>
        <p class="lead">overview of pipes and FIFOs</p>
      </div>

    <ol class="breadcrumb">
	<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_section">
		<a itemprop="url" href="https://www.carta.tech/man-pages/"><span itemprop="title">Linux Man Pages</span></a>
	</li>
	<li id="breadcrumb_section" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_page" itemprop="child">
		<a itemprop="url" href="https://www.carta.tech/man-pages/man7/"><span itemprop="title">Miscellaneous</span></a>
	</li>
	<li id="breadcrumb_page" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemprop="child" class="active">
		<a itemprop="url" href="https://www.carta.tech/man-pages/man7/pipe.7.html"><span itemprop="title">pipe</span></a>
	</li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<p>Pipes and FIFOs (also known as named pipes) provide a unidirectional interprocess communication channel. A pipe has a <em>read end</em> and a <em>write end</em>. Data written to the write end of a pipe can be read from the read end of the pipe.</p>
<p class='spacer'>

<p>A pipe is created using <a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a>, which creates a new pipe and returns two file descriptors, one referring to the read end of the pipe, the other referring to the write end. Pipes can be used to create a communication channel between related processes; see <a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a> for an example.</p>
<p class='spacer'>

<p>A FIFO (short for First In First Out) has a name within the filesystem (created using <a href="../man3/mkfifo.3.html"><strong>mkfifo</strong>(3)</a>), and is opened using <a href="../man2/open.2.html"><strong>open</strong>(2)</a>. Any process may open a FIFO, assuming the file permissions allow it. The read end is opened using the <strong>O_RDONLY</strong> flag; the write end is opened using the <strong>O_WRONLY</strong> flag. See <a href="../man7/fifo.7.html"><strong>fifo</strong>(7)</a> for further details. <em>Note</em>: although FIFOs have a pathname in the filesystem, I/O on FIFOs does not involve operations on the underlying device (if there is one).</p>
  <h3>I/O on pipes and FIFOs</h3>
<p>The only difference between pipes and FIFOs is the manner in which they are created and opened. Once these tasks have been accomplished, I/O on pipes and FIFOs has exactly the same semantics.</p>
<p class='spacer'>

<p>If a process attempts to read from an empty pipe, then <a href="../man2/read.2.html"><strong>read</strong>(2)</a> will block until data is available. If a process attempts to write to a full pipe (see below), then <a href="../man2/write.2.html"><strong>write</strong>(2)</a> blocks until sufficient data has been read from the pipe to allow the write to complete. Nonblocking I/O is possible by using the <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> <strong>F_SETFL</strong> operation to enable the <strong>O_NONBLOCK</strong> open file status flag.</p>
<p class='spacer'>

<p>The communication channel provided by a pipe is a <em>byte stream</em>: there is no concept of message boundaries.</p>
<p class='spacer'>

<p>If all file descriptors referring to the write end of a pipe have been closed, then an attempt to <a href="../man2/read.2.html"><strong>read</strong>(2)</a> from the pipe will see end-of-file (<a href="../man2/read.2.html"><strong>read</strong>(2)</a> will return 0). If all file descriptors referring to the read end of a pipe have been closed, then a <a href="../man2/write.2.html"><strong>write</strong>(2)</a> will cause a <strong>SIGPIPE</strong> signal to be generated for the calling process. If the calling process is ignoring this signal, then <a href="../man2/write.2.html"><strong>write</strong>(2)</a> fails with the error <strong>EPIPE</strong>. An application that uses <a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a> and <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a> should use suitable <a href="../man2/close.2.html"><strong>close</strong>(2)</a> calls to close unnecessary duplicate file descriptors; this ensures that end-of-file and <strong>SIGPIPE</strong>/<strong>EPIPE</strong> are delivered when appropriate.</p>
<p class='spacer'>

<p>It is not possible to apply <a href="../man2/lseek.2.html"><strong>lseek</strong>(2)</a> to a pipe.</p>
  <h3>Pipe capacity</h3>
<p>A pipe has a limited capacity. If the pipe is full, then a <a href="../man2/write.2.html"><strong>write</strong>(2)</a> will block or fail, depending on whether the <strong>O_NONBLOCK</strong> flag is set (see below). Different implementations have different limits for the pipe capacity. Applications should not rely on a particular capacity: an application should be designed so that a reading process consumes data as soon as it is available, so that a writing process does not remain blocked.</p>
<p class='spacer'>

<p>In Linux versions before 2.6.11, the capacity of a pipe was the same as the system page size (e.g., 4096 bytes on i386). Since Linux 2.6.11, the pipe capacity is 65536 bytes. Since Linux 2.6.35, the default pipe capacity is 65536 bytes, but the capacity can be queried and set using the <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> <strong>F_GETPIPE_SZ</strong> and <strong>F_SETPIPE_SZ</strong> operations. See <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> for more information.</p>
  <h3>PIPE_BUF</h3>
  <p>POSIX.1 says that <a href="../man2/write.2.html"><strong>write</strong>(2)</a>s of less than <strong>PIPE_BUF</strong> bytes must be atomic: the output data is written to the pipe as a contiguous sequence. Writes of more than <strong>PIPE_BUF</strong> bytes may be nonatomic: the kernel may interleave the data with data written by other processes. POSIX.1 requires <strong>PIPE_BUF</strong> to be at least 512 bytes. (On Linux, <strong>PIPE_BUF</strong> is 4096 bytes.) The precise semantics depend on whether the file descriptor is nonblocking (<strong>O_NONBLOCK</strong>), whether there are multiple writers to the pipe, and on <em>n</em>, the number of bytes to be written:</p>
  <dl class='dl-vertical'>
    <dt><strong>O_NONBLOCK</strong> disabled, <em>n</em> &lt;= <strong>PIPE_BUF</strong></dt>
    <dd>
  <p>All <em>n</em> bytes are written atomically; <a href="../man2/write.2.html"><strong>write</strong>(2)</a> may block if there is not room for <em>n</em> bytes to be written immediately</p>
    </dd>
    <dt><strong>O_NONBLOCK</strong> enabled, <em>n</em> &lt;= <strong>PIPE_BUF</strong></dt>
    <dd>
  <p>If there is room to write <em>n</em> bytes to the pipe, then <a href="../man2/write.2.html"><strong>write</strong>(2)</a> succeeds immediately, writing all <em>n</em> bytes; otherwise <a href="../man2/write.2.html"><strong>write</strong>(2)</a> fails, with <em>errno</em> set to <strong>EAGAIN</strong>.</p>
    </dd>
    <dt><strong>O_NONBLOCK</strong> disabled, <em>n</em> &gt; <strong>PIPE_BUF</strong></dt>
    <dd>
  <p>The write is nonatomic: the data given to <a href="../man2/write.2.html"><strong>write</strong>(2)</a> may be interleaved with <a href="../man2/write.2.html"><strong>write</strong>(2)</a>s by other process; the <a href="../man2/write.2.html"><strong>write</strong>(2)</a> blocks until <em>n</em> bytes have been written.</p>
    </dd>
    <dt><strong>O_NONBLOCK</strong> enabled, <em>n</em> &gt; <strong>PIPE_BUF</strong></dt>
    <dd>
  <p>If the pipe is full, then <a href="../man2/write.2.html"><strong>write</strong>(2)</a> fails, with <em>errno</em> set to <strong>EAGAIN</strong>. Otherwise, from 1 to <em>n</em> bytes may be written (i.e., a "partial write" may occur; the caller should check the return value from <a href="../man2/write.2.html"><strong>write</strong>(2)</a> to see how many bytes were actually written), and these bytes may be interleaved with writes by other processes.</p>
    </dd>
  </dl>
  <h3>Open file status flags</h3>
<p>The only open file status flags that can be meaningfully applied to a pipe or FIFO are <strong>O_NONBLOCK</strong> and <strong>O_ASYNC</strong>.</p>
<p class='spacer'>

<p>Setting the <strong>O_ASYNC</strong> flag for the read end of a pipe causes a signal (<strong>SIGIO</strong> by default) to be generated when new input becomes available on the pipe. The target for delivery of signals must be set using the <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> <strong>F_SETOWN</strong> command. On Linux, <strong>O_ASYNC</strong> is supported for pipes and FIFOs only since kernel 2.6.</p>
  <h3>Portability notes</h3>
<p>On some systems (but not Linux), pipes are bidirectional: data can be transmitted in both directions between the pipe ends. POSIX.1 requires only unidirectional pipes. Portable applications should avoid reliance on bidirectional pipe semantics.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEE ALSO</h2>
        <div class="sectioncontent">

<p><a href="../man1/mkfifo.1.html"><strong>mkfifo</strong>(1)</a>, <a href="../man2/dup.2.html"><strong>dup</strong>(2)</a>, <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a>, <a href="../man2/open.2.html"><strong>open</strong>(2)</a>, <a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a>, <a href="../man2/poll.2.html"><strong>poll</strong>(2)</a>, <a href="../man2/select.2.html"><strong>select</strong>(2)</a>, <a href="../man2/socketpair.2.html"><strong>socketpair</strong>(2)</a>, <a href="../man2/splice.2.html"><strong>splice</strong>(2)</a>, <a href="../man2/stat.2.html"><strong>stat</strong>(2)</a>, <a href="../man3/mkfifo.3.html"><strong>mkfifo</strong>(3)</a>, <a href="../man7/epoll.7.html"><strong>epoll</strong>(7)</a>, <a href="../man7/fifo.7.html"><strong>fifo</strong>(7)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
  <li class="previous"><a href="pid_namespaces.7.html"><span aria-hidden="true">&larr;</span> pid_namespaces.7: overview of Linux PID namespaces</a></li><li class="next"><a href="posixoptions.7.html">posixoptions.7: optional parts of the POSIX standard <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>
  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

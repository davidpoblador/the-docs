<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>funtext: Support for column\-based text files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Support for column\-based text files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="funtext (7) manual">
  <meta name="twitter:description" content="Support for column\-based text files">
  <meta name="twitter:image" content="https://www.carta.tech/images/libfuntools-dev-funtext-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/funtext.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="funtext (7) manual" />
  <meta property="og:description" content="Support for column\-based text files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libfuntools-dev-funtext-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">funtext<small> (7)</small></h1>
        <p class="lead">Support for column\-based text files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/funtext.7.html">
      <span itemprop="name">funtext: Support for column\-based text files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libfuntools-dev/">
      <span itemprop="name">libfuntools-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/funtext.7.html">
      <span itemprop="name">funtext: Support for column\-based text files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>This document contains a summary of the options for processing column-based text files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Funtools will automatically sense and process \*(L"standard\*(R" column-based text files as if they were \s-1FITS\s0 binary tables without any change in Funtools syntax. In particular, you can filter text files using the same syntax as \s-1FITS\s0 binary tables:</p>
<pre>
  fundisp foo.txt'[cir 512 512 .1]'
  fundisp -T foo.txt &gt; foo.rdb
  funtable foo.txt'[pha=1:10,cir 512 512 10]' foo.fits
</pre>
<p>The first example displays a filtered selection of a text file.  The second example converts a text file to an \s-1RDB\s0 file.  The third example converts a filtered selection of a text file to a \s-1FITS\s0 binary table.</p><p>Text files can also be used in Funtools image programs. In this case, you must provide binning parameters (as with raw event files), using the bincols keyword specifier:</p><p>  bincols=([xname[:tlmin[:tlmax:[binsiz]]]],[yname[:tlmin[:tlmax[:binsiz]]]</p><p>For example:</p><p>  funcnts foo'[bincols=(x:1024,y:1024)]' "ann 512 512 0 10 n=10"</p><p><strong>Standard Text Files</strong></p><p>Standard text files have the following characteristics:</p><ul>
<li><p>Optional comment lines start with #</p></li><li><p>Optional blank lines are considered comments</p></li><li><p>An optional table header consists of the following (in order):</p><ul>
<li><p>a single line of alpha-numeric column names</p></li><li><p>an optional line of unit strings containing the same number of cols</p></li><li><p>an optional line of dashes containing the same number of cols</p></li>
</ul></li><li><p>Data lines follow the optional header and (for the present) consist of</p>
<pre>
     the same number of columns as the header.
</pre>
</li><li><p>Standard delimiters such as space, tab, comma, semi\-colon, and bar.</p></li>
</ul><p>Examples:</p><p>  # rdb file   foo1  foo2    foo3    foos   ----  ----    ----    ----   1     2.2     3       xxxx   10    20.2    30      yyyy</p><p>  # multiple consecutive whitespace and dashes   foo1   foo2    foo3 foos   ---    ----    ---- ----      1    2.2    3    xxxx     10   20.2    30   yyyy</p><p>  # comma delims and blank lines   foo1,foo2,foo3,foos</p><p>  1,2.2,3,xxxx   10,20.2,30,yyyy</p><p>  # bar delims with null values   foo1|foo2|foo3|foos   1||3|xxxx   10|20.2||yyyy</p><p>  # header-less data   1     2.2   3 xxxx   10    20.2 30 yyyy</p><p>The default set of token delimiters consists of spaces, tabs, commas, semi\-colons, and vertical bars. Several parsers are used simultaneously to analyze a line of text in different ways.  One way of analyzing a line is to allow a combination of spaces, tabs, and commas to be squashed into a single delimiter (no null values between consecutive delimiters). Another way is to allow tab, semi\-colon, and vertical bar delimiters to support null values, i.e. two consecutive delimiters implies a null value (e.g. \s-1RDB\s0 file).  A successful parser is one which returns a consistent number of columns for all rows, with each column having a consistent data type.  More than one parser can be successful. For now, it is assumed that successful parsers all return the same tokens for a given line. (Theoretically, there are pathological cases, which will be taken care of as needed). Bad parsers are discarded on the fly.</p><p>If the header does not exist, then names \*(L"col1\*(R", \*(L"col2\*(R", etc.  are assigned to the columns to allow filtering.  Furthermore, data types for each column are determined by the data types found in the columns of the first data line, and can be one of the following: string, int, and double. Thus, all of the above examples return the following display:</p><p>  fundisp foo'[foo1&gt;5]'         FOO1                  FOO2       FOO3         FOOS   ---------- --------------------- ---------- ------------           10           20.20000000         30         yyyy</p><p><strong>Comments Convert to Header Params</strong></p><p>Comments which precede data rows are converted into header parameters and will be written out as such using funimage or funhead. Two styles of comments are recognized:</p><p>1. FITS-style comments have an equal sign \*(L"=\*(R" between the keyword and value and an optional slash \*(L"/\*(R" to signify a comment. The strict \s-1FITS\s0 rules on column positions are not enforced. In addition, strings only need to be quoted if they contain whitespace. For example, the following are valid FITS-style comments:</p><p>  # fits0 = 100   # fits1 = /usr/local/bin   # fits2 = "/usr/local/bin /opt/local/bin"   # fits3c = /usr/local/bin /opt/local/bin /usr/bin   # fits4c = "/usr/local/bin /opt/local/bin" / path dir</p><p>Note that the fits3c comment is not quoted and therefore its value is the single token \*(L"/usr/local/bin\*(R" and the comment is \*(L"opt/local/bin /usr/bin\*(R". This is different from the quoted comment in fits4c.</p><p>2. Free-form comments can have an optional colon separator between the keyword and value. In the absence of quote, all tokens after the keyword are part of the value, i.e. no comment is allowed. If a string is quoted, then slash \*(L"/\*(R" after the string will signify a comment. For example:</p><p>  # com1 /usr/local/bin   # com2 "/usr/local/bin /opt/local/bin"   # com3 /usr/local/bin /opt/local/bin /usr/bin   # com4c "/usr/local/bin /opt/local/bin" / path dir</p><p>  # com11: /usr/local/bin   # com12: "/usr/local/bin /opt/local/bin"   # com13: /usr/local/bin /opt/local/bin /usr/bin   # com14c: "/usr/local/bin /opt/local/bin" / path dir</p><p>Note that com3 and com13 are not quoted, so the whole string is part of the value, while comz4c and com14c are quoted and have comments following the values.</p><p>Some text files have column name and data type information in the header. You can specify the format of column information contained in the header using the \*(L"hcolfmt=\*(R" specification. See below for a detailed description.</p><p><strong>Multiple Tables in a Single File</strong></p><p>Multiple tables are supported in a single file. If an RDB-style file is sensed, then a ^L (vertical tab) will signify end of table. Otherwise, an end of table is sensed when a new header (i.e., all alphanumeric columns) is found. (Note that this heuristic does not work for single column tables where the column type is \s-1ASCII\s0 and the table that follows also has only one column.) You also can specify characters that signal an end of table condition using the <strong>eot=</strong> keyword. See below for details.</p><p>You can access the nth table (starting from 1) in a multi-table file by enclosing the table number in brackets, as with a \s-1FITS\s0 extension:</p><p>  fundisp foo'[2]'</p><p>The above example will display the second table in the file. (Index values start at 1 in oder to maintain logical compatibility with \s-1FITS\s0 files, where extension numbers also start at 1).</p><p><strong>\s-1</strong><strong>TEXT\s0()</strong><strong> Specifier</strong></p><p>As with \s-1<em>ARRAY\s0()</em> and \s-1<em>EVENTS\s0()</em> specifiers for raw image arrays and raw event lists respectively, you can use \s-1<em>TEXT\s0()</em> on text files to pass key=value options to the parsers. An empty set of keywords is equivalent to not having \s-1<em>TEXT\s0()</em> at all, that is:</p><p>  fundisp foo   fundisp foo'[TEXT()]'</p><p>are equivalent. A multi-table index number is placed before the \s-1<em>TEXT\s0()</em> specifier as the first token, when indexing into a multi\-table:</p><p>  fundisp foo'[2,TEXT(...)]'</p><p>The filter specification is placed after the \s-1<em>TEXT\s0()</em> specifier, separated by a comma, or in an entirely separate bracket:</p><p>  fundisp foo'[TEXT(...),circle 512 512 .1]'   fundisp foo'[2,TEXT(...)][circle 512 512 .1]'</p><p><strong></strong><strong>Text()</strong><strong> Keyword Options</strong></p><p>The following is a list of keywords that can be used within the \s-1<em>TEXT\s0()</em> specifier (the first three are the most important):</p><ul>
<li><p>delims=\*(L"[delims]\*(R" Specify token delimiters for this file. Only a single parser having these delimiters will be used to process the file.   fundisp foo.fits'[TEXT(delims="!")]'   fundisp foo.fits'[TEXT(delims="&#92;t%")]'</p></li><li><p>comchars=\*(L"[comchars]\*(R" Specify comment characters. You must include \*(L"&#92;n\*(R" to allow blank lines. These comment characters will be used for all standard parsers (unless delims are also specified).   fundisp foo.fits'[TEXT(comchars="!&#92;n")]'</p></li><li><p>cols=\*(L"[name1:type1 ...]\*(R" Specify names and data type of columns. This overrides header names and/or data types in the first data row or default names and data types for header-less tables.   fundisp foo.fits'[TEXT(cols="x:I,y:I,pha:I,pi:I,time:D,dx:E,dy:e")]' If the column specifier is the only keyword, then the cols= is not required (in analogy with \s-1<em>EVENTS\s0()</em>):   fundisp foo.fits'[TEXT(x:I,y:I,pha:I,pi:I,time:D,dx:E,dy:e)]' Of course, an index is allowed in this case:   fundisp foo.fits'[2,TEXT(x:I,y:I,pha:I,pi:I,time:D,dx:E,dy:e)]'</p></li><li><p>eot=\*(L"[eot delim]\*(R" Specify end of table string specifier for multi-table files. \s-1RDB\s0 files support ^L. The end of table specifier is a string and the whole string must be found alone on a line to signify \s-1EOT\s0. For example:   fundisp foo.fits'[TEXT(eot="END")]' will end the table when a line contains \*(L"\s-1END\s0\*(R" is found. Multiple lines are supported, so that:   fundisp foo.fits'[TEXT(eot="END&#92;nGAME")]' will end the table when a line contains \*(L"\s-1END\s0\*(R" followed by a line containing \*(L"\s-1GAME\s0\*(R". In the absence of an \s-1EOT\s0 delimiter, a new table will be sensed when a new header (all alphanumeric columns) is found.</p></li><li><p>null1=\*(L"[datatype]\*(R" Specify data type of a single null value in row 1. Since column data types are determined by the first row, a null value in that row will result in an error and a request to specify names and data types using cols=. If you only have a one null in row 1, you don't need to specify all names and columns. Instead, use null1=\*(L"type\*(R" to specify its data type.</p></li><li><p>alen=[n] Specify size in bytes for \s-1ASCII\s0 type columns. \s-1FITS\s0 binary tables only support fixed length \s-1ASCII\s0 columns, so a size value must be specified. The default is 16 bytes.</p></li><li><p>nullvalues=[\*(L"true\*(R"|\*(L"false\*(R"] Specify whether to expect null values. Give the parsers a hint as to whether null values should be allowed. The default is to try to determine this from the data.</p></li><li><p>whitespace=[\*(L"true\*(R"|\*(L"false\*(R"] Specify whether surrounding white space should be kept as part of string tokens.  By default surrounding white space is removed from tokens.</p></li><li><p>header=[\*(L"true\*(R"|\*(L"false\*(R"] Specify whether to require a header.  This is needed by tables containing all string columns (and with no row containing dashes), in order to be able to tell whether the first row is a header or part of the data. The default is false, meaning that the first row will be data. If a row dashes are present, the previous row is considered the column name row.</p></li><li><p>units=[\*(L"true\*(R"|\*(L"false\*(R"] Specify whether to require a units line. Give the parsers a hint as to whether a row specifying units should be allowed. The default is to try to determine this from the data.</p></li><li><p>i2f=[\*(L"true\*(R"|\*(L"false\*(R"] Specify whether to allow int to float conversions. If a column in row 1 contains an integer value, the data type for that column will be set to int. If a subsequent row contains a float in that same column, an error will be signaled. This flag specifies that, instead of an error, the float should be silently truncated to int. Usually, you will want an error to be signaled, so that you can specify the data type using cols= (or by changing the value of the column in row 1).</p></li><li><p>comeot=[\*(L"true\*(R"|\*(L"false\*(R"|0|1|2] Specify whether comment signifies end of table. If comeot is 0 or false, then comments do not signify end of table and can be interspersed with data rows. If the value is true or 1 (the default for standard parsers), then non-blank lines (e.g. lines beginning with '#') signify end of table but blanks are allowed between rows. If the value is 2, then all comments, including blank lines, signify end of table.</p></li><li><p>lazyeot=[\*(L"true\*(R"|\*(L"false\*(R"] Specify whether \*(L"lazy\*(R" end of table should be permitted (default is true for standard formats, except rdb format where explicit ^L is required between tables). A lazy \s-1EOT\s0 can occur when a new table starts directly after an old one, with no special \s-1EOT\s0 delimiter. A check for this \s-1EOT\s0 condition is begun when a given row contains all string tokens. If, in addition, there is a mismatch between the number of tokens in the previous row and this row, or a mismatch between the number of string tokens in the prev row and this row, a new table is assumed to have been started. For example:   ival1 sval3   ----- -----   1     two   3     four   jval1 jval2 tval3   ----- ----- ------   10    20    thirty   40    50    sixty Here the line \*(L"jval1 ...\*(R" contains all string tokens.  In addition, the number of tokens in this line (3) differs from the number of tokens in the previous line (2). Therefore a new table is assumed to have started. Similarly:   ival1 ival2 sval3   ----- ----- -----   1     2     three   4     5     six   jval1 jval2 tval3   ----- ----- ------   10    20    thirty   40    50    sixty Again, the line \*(L"jval1 ...\*(R" contains all string tokens. The number of string tokens in the previous row (1) differs from the number of tokens in the current <em>row</em>\|(3). We therefore assume a new table as been started. This lazy \s-1EOT\s0 test is not performed if lazyeot is explicitly set to false.</p></li><li><p>hcolfmt=[header column format] Some text files have column name and data type information in the header. For example, VizieR catalogs have headers containing both column names and data types:   #Column e_Kmag  (F6.3)  ?(k_msigcom) K total magnitude uncertainty (4)  [ucd=ERROR]   #Column Rflg    (A3)    (rd_flg) Source of JHK default mag (6)  [ucd=REFER_CODE]   #Column Xflg    (I1)    [0,2] (gal_contam) Extended source contamination (10) [ucd=CODE_MISC] while Sextractor files have headers containing column names alone:   #   1 X_IMAGE         Object position along x                         [pixel]   #   2 Y_IMAGE         Object position along y                         [pixel]   #   3 ALPHA_J2000     Right ascension of barycenter (J2000)           [deg]   #   4 DELTA_J2000     Declination of barycenter (J2000)               [deg] The hcolfmt specification allows you to describe which header lines contain column name and data type information. It consists of a string defining the format of the column line, using \*(L"$col\*(R" (or \*(L"$name\*(R") to specify placement of the column name, \*(L"$fmt\*(R" to specify placement of the data format, and \*(L"$skip\*(R" to specify tokens to ignore. You also can specify tokens explicitly (or, for those users familiar with how sscanf works, you can specify scanf skip specifiers using \*(L"%*\*(R"). For example, the VizieR hcolfmt above might be specified in several ways:   Column $col ($fmt)    # explicit specification of "Column" string   $skip  $col ($fmt)    # skip one token   %*s $col  ($fmt)      # skip one string (using scanf format) while the Sextractor format might be specified using:   $skip $col            # skip one token   %*d $col              # skip one int (using scanf format) You must ensure that the hcolfmt statement only senses actual column definitions, with no false positives or negatives.  For example, the first Sextractor specification, \*(L"$skip $col\*(R", will consider any header line containing two tokens to be a column name specifier, while the second one, \*(L"%*d $col\*(R", requires an integer to be the first token. In general, it is preferable to specify formats as explicitly as possible. Note that the VizieR-style header info is sensed automatically by the funtools standard VizieR-like parser, using the hcolfmt \*(L"Column $col ($fmt)\*(R".  There is no need for explicit use of hcolfmt in this case.</p></li><li><p>debug=[\*(L"true\*(R"|\*(L"false\*(R"] Display debugging information during parsing.</p></li>
</ul><p><strong>Environment Variables</strong></p><p>Environment variables are defined to allow many of these \s-1<em>TEXT\s0()</em> values to be set without having to include them in \s-1<em>TEXT\s0()</em> every time a file is processed:</p><p>  keyword       environment variable   -------       --------------------   delims        TEXT_DELIMS   comchars      TEXT_COMCHARS   cols          TEXT_COLUMNS   eot           TEXT_EOT   null1         TEXT_NULL1   alen          TEXT_ALEN   bincols       TEXT_BINCOLS   hcolfmt       TEXT_HCOLFMT</p><p><strong>Restrictions and Problems</strong></p><p>As with raw event files, the '+' (copy extensions) specifier is not supported for programs such as funtable.</p><p>String to int and int to string data conversions are allowed by the text parsers. This is done more by force of circumstance than by conviction: these transitions often happens with VizieR catalogs, which we want to support fully. One consequence of allowing these transitions is that the text parsers can get confused by columns which contain a valid integer in the first row and then switch to a string. Consider the following table:</p><p>  xxx   yyy     zzz   ----  ----    ----   111   aaa     bbb   ccc   222     ddd</p><p>The xxx column has an integer value in row one a string in row two, while the yyy column has the reverse. The parser will erroneously treat the first column as having data type int:</p><p>  fundisp foo.tab          XXX          YYY          ZZZ   ---------- ------------ ------------          111        'aaa'        'bbb'   1667457792        '222'        'ddd'</p><p>while the second column is processed correctly. This situation can be avoided in any number of ways, all of which force the data type of the first column to be a string. For example, you can edit the file and explicitly quote the first row of the column:</p><p>  xxx   yyy     zzz   ----  ----    ----   "111" aaa     bbb   ccc   222     ddd</p><p>  [sh] fundisp foo.tab            XXX          YYY          ZZZ   ------------ ------------ ------------          '111'        'aaa'        'bbb'          'ccc'        '222'        'ddd'</p><p>You can edit the file and explicitly set the data type of the first column:</p><p>  xxx:3A   yyy  zzz   ------   ---- ----   111      aaa  bbb   ccc      222  ddd</p><p>  [sh] fundisp foo.tab            XXX          YYY          ZZZ   ------------ ------------ ------------          '111'        'aaa'        'bbb'          'ccc'        '222'        'ddd'</p><p>You also can explicitly set the column names and data types of all columns, without editing the file:</p><p>  [sh] fundisp foo.tab'[TEXT(xxx:3A,yyy:3A,zzz:3a)]'            XXX          YYY          ZZZ   ------------ ------------ ------------          '111'        'aaa'        'bbb'          'ccc'        '222'        'ddd'</p><p>The issue of data type transitions (which to allow and which to disallow) is still under discussion.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO funtext&hellip;</h2>
        <div class="sectioncontent">
<p>See <a href="../man7/funtools.7.html"><strong>funtools</strong>(7)</a> for a list of Funtools help pages</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="funregions.7.html"><span aria-hidden="true">&larr;</span> funregions.7: Spatial region filtering</a></li>
   <li class="next"><a href="funtools.7.html">funtools.7: Fits users need tools <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

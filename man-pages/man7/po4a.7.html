<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>po4a: Framework to translate documentation and other materials</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Framework to translate documentation and other materials">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="po4a (7) manual">
  <meta name="twitter:description" content="Framework to translate documentation and other materials">
  <meta name="twitter:image" content="https://www.carta.tech/images/po4a-po4a-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/po4a.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="po4a (7) manual" />
  <meta property="og:description" content="Framework to translate documentation and other materials" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/po4a-po4a-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">po4a<small> (7)</small></h1>
        <p class="lead">Framework to translate documentation and other materials</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/po4a.7.html">
      <span itemprop="name">po4a: Framework to translate documentation and other materials</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/po4a/">
      <span itemprop="name">po4a</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/po4a.7.html">
      <span itemprop="name">po4a: Framework to translate documentation and other materials</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Introduction</h2>
        <div class="sectioncontent">
<p>The po4a (\s-1PO\s0 for anything) project goal is to ease translations (and more interestingly, the maintenance of translations) using gettext tools on areas where they were not expected like documentation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Table of content</h2>
        <div class="sectioncontent">
<p>This document is organized as follow:</p>
<dl class='dl-vertical'>
  <dt>
    1 Why should I use po4a? What is it good for?
  </dt>
  <dd>
    <p>This introducing chapter explains the motivation of the project and its philosophy. You should read it first if you are in the process of evaluating po4a for your own translations.</p>
  </dd>
  <dt>
    2 How to use po4a?
  </dt>
  <dd>
    <p>This chapter is a sort of reference manual, trying to answer the users' questions and to give you a better understanding of the whole process. This introduces how to do things with po4a and serve as an introduction to the documentation of the specific tools.</p>
<dl class='dl-vertical'>
  <dt>
    \s-1HOWTO\s0 begin a new translation?
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1HOWTO\s0 change the translation back to a documentation file?
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1HOWTO\s0 update a po4a translation?
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1HOWTO\s0 convert a pre-existing translation to po4a?
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1HOWTO\s0 add extra text to translations (like translator's name)?
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1HOWTO\s0 do all this in one program invocation?
  </dt>
  <dd>
    
  </dd>
  <dt>
    \s-1HOWTO\s0 customize po4a?
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>
  <dt>
    3 How does it work?
  </dt>
  <dd>
    <p>This chapter gives you a brief overview of the po4a internals, so that you may feel more confident to help us maintaining and improving it. It may also help you understanding why it does not do what you expected, and how to solve your problems.</p>
  </dd>
  <dt>
    4 \s-1FAQ\s0
  </dt>
  <dd>
    <p>This chapter groups the Frequently Asked Questions. In fact, most of the questions for now could be formulated that way: \*(L"Why is it designed this way, and not that one?\*(R" If you think po4a isn't the right answer to documentation translation, you should consider reading this section. If it does not answer your question, please contact us on the &lt;po4a-devel@lists.alioth.debian.org&gt; mailing list. We love feedback.</p>
  </dd>
  <dt>
    5 Specific notes about modules
  </dt>
  <dd>
    <p>This chapter presents the specificities of each module from the translator and original author's point of view. Read this to learn the syntax you will encounter when translating stuff in this module, or the rules you should follow in your original document to make translators' life easier. Actually, this section is not really part of this document. Instead, it is placed in each module's documentation. This helps ensuring that the information is up to date by keeping the documentation and the code together.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Why should I use po4a? What it is good for?</h2>
        <div class="sectioncontent">
<p>I like the idea of open-source software, making it possible for everybody to access software and its source code. But being French, I'm well aware that the licensing is not the only restriction to the openness of software: non-translated free software is useless for non-English speakers, and we still have some work to make it available to really everybody out there.</p><p>The perception of this situation by the open-source actors did dramatically improve recently. We, as translators, won the first battle and convinced everybody of the translations' importance. But unfortunately, it was the easy part. Now, we have to do the job and actually translate all this stuff.</p><p>Actually, open-source software themselves benefit of a rather decent level of translation, thanks to the wonderful gettext tool suite. It is able to extract the strings to translate from the program, present a uniform format to translators, and then use the result of their works at run time to display translated messages to the user.</p><p>But the situation is rather different when it comes to documentation. Too often, the translated documentation is not visible enough (not distributed as a part of the program), only partial, or not up to date. This last situation is by far the worst possible one. Outdated translation can reveal worse than no translation at all to the users by describing old program behavior which are not in use anymore.</p><h3>The problem to solve</h3>
<p>Translating documentation is not very difficult in itself. Texts are far longer than the messages of the program and thus take longer to be achieved, but no technical skill is really needed to do so. The difficult part comes when you have to maintain your work. Detecting which parts did change and need to be updated is very difficult, error-prone and highly unpleasant. I guess that this explains why so much translated documentation out there are outdated.</p>
<h3>The po4a answers</h3>
<p>So, the whole point of po4a is to make the documentation translation <em>maintainable</em>. The idea is to reuse the gettext methodology to this new field. Like in gettext, texts are extracted from their original locations in order to be presented in a uniform format to the translators. The classical gettext tools help them updating their works when a new release of the original comes out. But to the difference of the classical gettext model, the translations are then re-injected in the structure of the original document so that they can be processed and distributed just like the English version.</p><p>Thanks to this, discovering which parts of the document were changed and need an update becomes very easy. Another good point is that the tools will make almost all the work when the structure of the original document gets fundamentally reorganized and when some chapters are moved around, merged or split. By extracting the text to translate from the document structure, it also keeps you away from the text formatting complexity and reduces your chances to get a broken document (even if it does not completely prevent you to do so).</p><p>Please also see the <strong>\s-1FAQ\s0</strong> below in this document for a more complete list of the advantages and disadvantages of this approach.</p>
<h3>Supported formats</h3>
<p>Currently, this approach has been successfully implemented to several kinds of text formatting formats:</p><p><em>man</em></p><p>The good old manual pages' format, used by so much programs out there. The po4a support is very welcome here since this format is somewhat difficult to use and not really friendly to the newbies. The <em>Locale::Po4a::Man</em>\|(3pm) module also supports the mdoc format, used by the \s-1BSD\s0 man pages (they are also quite common on Linux).</p><p><em>pod</em></p><p>This is the Perl Online Documentation format. The language and extensions themselves are documented that way, as well as most of the existing Perl scripts. It makes easy to keep the documentation close to the actual code by embedding them both in the same file. It makes programmer life easier, but unfortunately, not the translator one.</p><p><em>sgml</em></p><p>Even if somewhat superseded by \s-1XML\s0 nowadays, this format is still used rather often for documents which are more than a few screens long. It allows you to make complete books. Updating the translation of so long documents can reveal to be a real nightmare. <strong>diff</strong> reveals often useless when the original text was re-indented after update. Fortunately, po4a can help you in that process.</p><p>Currently, only the DebianDoc and DocBook \s-1DTD\s0 are supported, but adding support to a new one is really easy. It is even possible to use po4a on an unknown \s-1SGML\s0 \s-1DTD\s0 without changing the code by providing the needed information on the command line. See <em>Locale::Po4a::Sgml</em>\|(3pm) for details.</p><p><em>TeX / LaTeX</em></p><p>The LaTeX format is a major documentation format used in the Free Software world and for publications. The <em>Locale::Po4a::LaTeX</em>\|(3pm) module was tested with the Python documentation, a book and some presentations.</p><p><em>texinfo</em></p><p>All the \s-1GNU\s0 documentation is written in this format (that's even one of the requirement to become an official \s-1GNU\s0 project).  The support for <em>Locale::Po4a::Texinfo</em>\|(3pm) in po4a is still at the beginning. Please report bugs and feature requests.</p><p><em>xml</em></p><p>The \s-1XML\s0 format is a base format for many documentation formats.</p><p>Currently, the DocBook \s-1DTD\s0 is supported by po4a. See <em>Locale::Po4a::Docbook</em>\|(3pm) for details.</p><p><em>others</em></p><p>Po4a can also handle some more rare or specialized formats, such as the documentation of compilation options for the 2.4.x kernels or the diagrams produced by the dia tool. Adding a new one is often very easy and the main task is to come up with a parser of your target format. See <em>Locale::Po4a::TransTractor</em>\|(3pm) for more information about this.</p>
<h3>Unsupported formats</h3>
<p>Unfortunately, po4a still lacks support for several documentation formats.</p><p>There is a whole bunch of other formats we would like to support in po4a, and not only documentation ones. Indeed, we aim at plugging all \*(L"market holes\*(R" left by the classical gettext tools. It encompass package descriptions (deb and rpm), package installation scripts questions, package changelogs, and all specialized file formats used by the programs such as game scenarios or wine resource files.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">How to use po4a?</h2>
        <div class="sectioncontent">
<p>This chapter is a sort of reference manual, trying to answer the users' questions and to give you a better understanding of the whole process. This introduces how to do things with po4a and serve as an introduction to the documentation of the specific tools.</p><h3>Graphical overview</h3>
<p>The following schema gives an overview of the process of translating documentation using po4a. Do not be afraid by its apparent complexity, it comes from the fact that the <em>whole</em> process is represented here. Once you converted your project to po4a, only the right part of the graphic is relevant.</p><p>Note that <em>master.doc</em> is taken as an example for the documentation to be translated and <em>translation.doc</em> is the corresponding translated text.  The suffix could be <em>.pod</em>, <em>.xml</em>, or <em>.sgml</em> depending on its format. Each part of the picture will be detailed in the next sections.</p>
<pre>
                                   master.doc
                                       |
                                       V
     +&lt;-----&lt;----+&lt;-----&lt;-----&lt;--------+-------&gt;--------&gt;-------+
     :           |                     |                        :
{translation}    |         { update of master.doc }             :
     :           |                     |                        :
   XX.doc        |                     V                        V
(optional)       |                 master.doc -&gt;--------&gt;------&gt;+
     :           |                   (new)                      |
     V           V                     |                        |
  [po4a-gettextize]   doc.XX.po---&gt;+   |                        |
          |            (old)       |   |                        |
          |              ^         V   V                        |
          |              |     [po4a-updatepo]                  |
          V              |           |                          V
   translation.pot       ^           V                          |
          |              |         doc.XX.po                    |
          |              |         (fuzzy)                      |
   { translation }       |           |                          |
          |              ^           V                          V
          |              |     {manual editing}                 |
          |              |           |                          |
          V              |           V                          V
      doc.XX.po ---&gt;----&gt;+&lt;---&lt;---- doc.XX.po   addendum     master.doc
      (initial)                   (up-to-date) (optional)   (up-to-date)
          :                          |            |             |
          :                          V            |             |
          +-----&gt;-----&gt;-----&gt;------&gt; +            |             |
                                     |            |             |
                                     V            V             V
                                     +------&gt;-----+------&lt;------+
                                                  |
                                                  V
                                           [po4a-translate]
                                                  |
                                                  V
                                                XX.doc
                                            (up-to-date)
</pre>
<p>On the left part, the conversion of a translation not using po4a to this system is shown. On the top of the right part, the action of the original author is depicted (updating the documentation).  The middle of the right part is where the automatic actions of po4a are depicted. The new material are extracted, and compared against the exiting translation. Parts which didn't change are found, and previous translation is used. Parts which where partially modified are also connected to the previous translation, but with a specific marker indicating that the translation must be updated. The bottom of the figure shows how a formatted document is built.</p><p>Actually, as a translator, the only manual operation you have to do is the part marked {manual editing}. Yeah, I'm sorry, but po4a helps you translate. It does not translate anything for you...</p>
<h3>\s-1HOWTO\s0 begin a new translation?</h3>
<p>This section presents the needed steps required to begin a new translation with po4a. The refinements involved in converting an existing project to this system are detailed in the relevant section.</p><p>To begin a new translation using po4a, you have to do the following steps:</p><ul>
<li><p>Extract the text which have to be translated from the original &lt;<em>master.doc</em>&gt; document into a new translation template &lt;<em>translation.pot</em>&gt; file (the gettext format). For that, use the <strong>po4a-gettextize</strong> program this way:   $ po4a-gettextize -f &lt;format&gt; -m &lt;master.doc&gt; -p &lt;translation.pot&gt; &lt;<em>format</em>&gt; is naturally the format used in the <em>master.doc</em> document. As expected, the output goes into <em>translation.pot</em>. Please refer to <em>po4a-gettextize</em>\|(1) for more details about the existing options.</p></li><li><p>Actually translate what should be translated. For that, you have to rename the \s-1POT\s0 file for example to <em>doc.XX.po</em> (where <em>\s-1XX\s0</em> is the \s-1ISO639\s0 code of the language you are translating to, e.g. <strong>fr</strong> for French), and edit the resulting file. It is often a good idea to not name the file <em>\s-1XX\s0.po</em> to avoid confusion with the translation of the program messages, but this your call. Don't forget to update the \s-1PO\s0 file headers, they are important. The actual translation can be done using the Emacs' or Vi's \s-1PO\s0 mode, Lokalize (\s-1KDE\s0 based), Gtranslator (\s-1GNOME\s0 based) or whichever program you prefer to use for them (e.g. Virtaal). If you wish to learn more about this, you definitively need to refer to the gettext documentation, available in the <strong>gettext-doc</strong> package.</p></li>
</ul>
<h3>\s-1HOWTO\s0 change the translation back to a documentation file?</h3>
<p>Once you're done with the translation, you want to get the translated documentation and distribute it to users along with the original one. For that, use the <em>po4a-translate</em>\|(1) program like that (where <em>\s-1XX\s0</em> is the language code):</p><p>  $ po4a-translate -f &lt;format&gt; -m &lt;master.doc&gt; -p &lt;doc.XX.po&gt; -l &lt;XX.doc&gt;</p><p>As before, &lt;<em>format</em>&gt; is the format used in the <em>master.doc</em> document. But this time, the \s-1PO\s0 file provided with the <strong>-p</strong> flag is part of the input. This is your translation. The output goes into <em>\s-1XX\s0.doc</em>.</p><p>Please refer to <em>po4a-translate</em>\|(1) for more details.</p>
<h3>\s-1HOWTO\s0 update a po4a translation?</h3>
<p>To update your translation when the original <em>master.doc</em> file has changed, use the <em>po4a-updatepo</em>\|(1) program like that:</p><p>  $ po4a-updatepo -f &lt;format&gt; -m &lt;new_master.doc&gt; -p &lt;old_doc.XX.po&gt;</p><p>(Please refer to <em>po4a-updatepo</em>\|(1) for more details)</p><p>Naturally, the new paragraph in the document won't get magically translated in the \s-1PO\s0 file with this operation, and you'll need to update the \s-1PO\s0 file manually. Likewise, you may have to rework the translation for paragraphs which were modified a bit. To make sure you won't miss any of them, they are marked as \*(L"fuzzy\*(R" during the process and you have to remove this marker before the translation can be used by <strong>po4a-translate</strong>. As for the initial translation, the best is to use your favorite \s-1PO\s0 editor here.</p><p>Once your \s-1PO\s0 file is up-to-date again, without any untranslated or fuzzy string left, you can generate a translated documentation file, as explained in the previous section.</p>
<h3>\s-1HOWTO\s0 convert a pre-existing translation to po4a?</h3>
<p>Often, you used to translate manually the document happily until a major reorganization of the original <em>master.doc</em> document happened. Then, after some unpleasant tries with <strong>diff</strong> or similar tools, you want to convert to po4a. But of course, you don't want to loose your existing translation in the process. Don't worry, this case is also handled by po4a tools and is called gettextization.</p><p>The key here is to have the same structure in the translated document and in the original one so that the tools can match the content accordingly.</p><p>If you are lucky (i.e., if the structures of both documents perfectly match), it will work seamlessly and you will be set in a few seconds. Otherwise, you may understand why this process has such an ugly name, and you'd better be prepared to some grunt work here. In any case, remember that it is the price to pay to get the comfort of po4a afterward. And the good point is that you have to do so only once.</p><p>I cannot emphasis this too much. In order to ease the process, it is thus important that you find the exact version which were used to do the translation. The best situation is when you noted down the \s-1VCS\s0 revision used for the translation and you didn't modify it in the translation process, so that you can use it.</p><p>It won't work well when you use the updated original text with the old translation. It remains possible, but is harder and really should be avoided if possible. In fact, I guess that if you fail to find the original text again, the best solution is to find someone to do the gettextization for you (but, please, not me ;).</p><p>Maybe I'm too dramatic here. Even when things go wrong, it remains ways faster than translating everything again. I was able to gettextize the existing French translation of the Perl documentation in one day, even though things <strong>did</strong> went wrong. That was more than two megabytes of text, and a new translation would have lasted months or more.</p><p>Let me explain the basis of the procedure first and I will come back on hints to achieve it when the process goes wrong. To ease comprehension, let's use above example once again.</p><p>Once you have the old <em>master.doc</em> again which matches with the translation <em>\s-1XX\s0.doc</em>, the gettextization can be done directly to the \s-1PO\s0 file <em>doc.XX.po</em> without manual translation of <em>translation.pot</em> file:</p><p> $ po4a-gettextize -f &lt;format&gt; -m &lt;old_master.doc&gt; -l &lt;XX.doc&gt; -p &lt;doc.XX.po&gt;</p><p>When you're lucky, that's it. You converted your old translation to po4a and can begin with the updating task right away. Just follow the procedure explained a few section ago to synchronize your \s-1PO\s0 file with the newest original document, and update the translation accordingly.</p><p>Please note that even when things seem to work properly, there is still room for errors in this process. The point is that po4a is unable to understand the text to make sure that the translation match the original. That's why all strings are marked as \*(L"fuzzy\*(R" in the process. You should check each of them carefully before removing those markers.</p><p>Often the document structures don't match exactly, preventing <strong>po4a-gettextize</strong> from doing its job properly. At that point, the whole game is about editing the files to get their damn structures matching.</p><p>It may help to read the section <strong>Gettextization: how does it work?</strong> below. Understanding the internal process will help you to make this work. The good point is that <strong>po4a-gettextize</strong> is rather verbose about what went wrong when it happens. First, it pinpoints where in the documents the structures' discrepancies are. You will learn the strings that don't match, their positions in the text, and the type of each of them. Moreover, the \s-1PO\s0 file generated so far will be dumped to <em>gettextization.failed.po</em>.</p><ul>
<li><p>Remove all extra parts of the translations, such as the section in which you give the translator name and thank every people who contributed to the translation. Addenda, which are described in the next section, will allow you to re-add them afterward.</p></li><li><p>Do not hesitate to edit both the original and the translation. The most important thing is to get the \s-1PO\s0 file. You will be able to update it afterward. That being said, editing the translation should be preferred when both are possible since it makes things easier when the gettextization is done.</p></li><li><p>If needed, kill some parts of the original if they happen to not be translated. When synchronizing the \s-1PO\s0 with the document afterward, they will come back from themselves.</p></li><li><p>If you changed the structure a bit (to merge two paragraphs, or split another one), undo those changes. If there are issues in the original, you should inform the original author. Fixing them in your translation only fixes them for a part of the community. And moreover, it's impossible when using po4a ;)</p></li><li><p>Sometimes, the paragraph content does match, but their types don't. Fixing it is rather format-dependant. In \s-1POD\s0 and man, it often comes from the fact that one of the two contains a line beginning with a white space where the other doesn't. In those formats, such paragraph cannot be wrapped and thus become a different type. Just remove the space and you are fine. It may also be a typo in the tag name. Likewise, two paragraphs may get merged together in \s-1POD\s0 when the separating line contains some spaces, or when there is no empty line before the =item line and the content of the item.</p></li><li><p>Sometimes, there is a desynchronization between the files, and the translation is attached to the wrong original paragraph. It is the sign that the real problem was before in the files. Check <em>gettextization.failed.po</em> to see when the desynchronization begins, and fix it there.</p></li><li><p>Sometimes, you get the strong feeling that po4a ate some parts of the text, either the original or the translation. <em>gettextization.failed.po</em> indicates that both of them where gently matching, and then the gettextization fails because it tried to match one paragraph with the one after (or before) the right one, as if the right one disappeared. Curse po4a as I did when it first happened to me. Generously. This unfortunate situation happens when the same paragraph is repeated over the document. In that case, no new entry is created in the \s-1PO\s0 file, but a new reference is added to the existing one instead. So, when the same paragraph appears twice in the original but both are not translated in the exact same way each time, you will get the feeling that a paragraph of the original disappeared. Just kill the new translation. If you prefer to kill the first translation instead when it was actually better, remove the second one from where it is and put it in place of the first one. In the contrary, if two similar but different paragraphs were translated in the exact same way, you will get the feeling that a paragraph of the translation disappeared. A solution is to add a stupid string to the original paragraph (such as \*(L"I'm different\*(R"). Don't be afraid, those things will disappear during the synchronization, and when the added text is short enough, gettext will match your translation to the existing text (marking it as fuzzy, but you don't really care since all strings are fuzzy after gettextization).</p></li>
</ul><p>Hopefully, those tips will help you making your gettextization work and obtain your precious \s-1PO\s0 file. You are now ready to synchronize your file and begin your translation. Please note that on large text, it may happen that the first synchronization takes a long time.</p><p>For example, the first <strong>po4a-updatepo</strong> of the Perl documentation's French translation (5.5 Mb \s-1PO\s0 file) took about two days full on a 1Ghz G5 computer. Yes, 48 hours. But the subsequent ones only take a dozen of seconds on my old laptop. This is because the first time, most of the msgid of the \s-1PO\s0 file don't match any of the \s-1POT\s0 file ones. This forces gettext to search for the closest one using a costly string proximity algorithm.</p>
<h3>\s-1HOWTO\s0 add extra text to translations (like translator's name)?</h3>
<p>Because of the gettext approach, doing this becomes more difficult in po4a than it was when simply editing a new file along the original one. But it remains possible, thanks to the so-called <strong>addenda</strong>.</p><p>It may help the comprehension to consider addenda as a sort of patches applied to the localized document after processing. They are rather different from the usual patches (they have only one line of context, which can embed Perl regular expression, and they can only add new text without removing any), but the functionalities are the same.</p><p>Their goal is to allow the translator to add extra content to the document which is not translated from the original document. The most common usage is to add a section about the translation itself, listing contributors and explaining how to report bug against the translation.</p><p>An addendum must be provided as a separate file. The first line constitutes a header indicating where in the produced document they should be placed. The rest of the addendum file will be added verbatim at the determined position of the resulting document.</p><p>The header has a pretty rigid syntax: It must begin with the string <strong>\s-1PO4A-HEADER:\s0</strong>, followed by a semi-colon (<strong>;</strong>) separated list of <em>key</em><strong>=</strong><em>value</em> fields. White spaces \s-1ARE\s0 important. Note that you cannot use the semi-colon char (<strong>;</strong>) in the value, and that quoting it doesn't help.</p><p>Again, it sounds scary, but the examples given below should help you to find how to write the header line you need. To illustrate the discussion, assume we want to add a section called \*(L"About this translation\*(R" after the \*(L"About this document\*(R" one.</p><p>Here are the possible header keys:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>position</strong> (mandatory)
  </dt>
  <dd>
    <p>a regexp. The addendum will be placed near the line matching this regexp. Note that we're speaking about the translated document here, not the original. If more than a line match this expression (or none), the addition will fail. It is indeed better to report an error than inserting the addendum at the wrong location. This line is called <em>position point</em> in the following. The point where the addendum is added is called <em>insertion point</em>. Those two points are near one from another, but not equal. For example, if you want to insert a new section, it is easier to put the <em>position point</em> on the title of the preceding section and explain po4a where the section ends (remember that <em>position point</em> is given by a regexp which should match a unique line). The localization of the <em>insertion point</em> with regard to the <em>position point</em> is controlled by the <strong>mode</strong>, <strong>beginboundary</strong> and <strong>endboundary</strong> fields, as explained below. In our case, we would have:      position=&lt;title&gt;About this document&lt;/title&gt;</p>
  </dd>
  <dt>
    <strong>mode</strong> (mandatory)
  </dt>
  <dd>
    <p>It can be either the string <strong>before</strong> or <strong>after</strong>, specifying the position of the addendum, relative to the <em>position point</em>. Since we want the new section to be placed below the one we are matching, we have:      mode=after</p>
  </dd>
  <dt>
    <strong>beginboundary</strong> (used only when <strong>mode=after</strong>, and mandatory in that case)
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>endboundary</strong> (idem)
  </dt>
  <dd>
    <p>regexp matching the end of the section after which the addendum goes. When <strong>mode=after</strong>, the <em>insertion point</em> is after the <em>position point</em>, but not directly after! It is placed at the end of the section beginning at the <em>position point</em>, i.e., after or before the line matched by the <em>???</em><strong>boundary</strong> argument, depending on whether you used <strong>beginboundary</strong> or <strong>endboundary</strong>. In our case, we can choose to indicate the end of the section we match by adding:    endboundary=&lt;/section&gt; or to indicate the beginning of the next section by indicating:    beginboundary=&lt;section&gt; In both case, our addendum will be placed after the <strong>&lt;/section&gt;</strong> and before the <strong>&lt;section&gt;</strong>. The first one is better since it will work even if the document gets reorganized. Both forms exist because documentation formats are different. In some of them, there is a way to mark the end of a section (just like the <strong>&lt;/section&gt;</strong> we just used), while some other don't explicitly mark the end of section (like in man). In the former case, you want to make a <em>boundary</em> matching the <em>end of a section</em>, so that the <em>insertion point</em> comes after it. In the latter case, you want to make a <em>boundary</em> matching the <em>beginning of the next section</em>, so that the <em>insertion point</em> comes just before it.</p>
  </dd>

</dl>
<p>This can seem obscure, but hopefully, the next examples will enlighten you.  PO4A-HEADER: mode=after; position=About this document; endboundary=&lt;/section&gt;  PO4A-HEADER: mode=after; position=About this document; beginboundary=&lt;section&gt;</p>
<dl class='dl-vertical'>
  <dt>
     If you want to add something after the following nroff section:
  </dt>
  <dd>
    <p>  .SH "AUTHORS" you should put a <strong>position</strong> matching this line, and a <strong>beginboundary</strong> matching the beginning of the next section (i.e., <strong>^&#92;.SH</strong>). The addendum will then be added <strong>after</strong> the <em>position point</em> and immediately <strong>before</strong> the first line matching the <strong>beginboundary</strong>. That is to say:  PO4A-HEADER:mode=after;position=AUTHORS;beginboundary=&#92;.SH  PO4A-HEADER:mode=after;position=Copyright Big Dude, 2004;beginboundary=^  PO4A-HEADER:mode=after;position=&lt;title&gt;About&lt;/title&gt;;beginboundary=FakePo4aBoundary</p>
  </dd>

</dl>
<p>In any case, remember that these are regexp. For example, if you want to match the end of a nroff section ending with the line</p><p>  .fi</p><p>don't use <strong>.fi</strong> as <strong>endboundary</strong>, because it will match with \*(L"the[ fi]le\*(R", which is obviously not what you expect. The correct <strong>endboundary</strong> in that case is: <strong>^&#92;.fi$</strong>.</p><p>If the addendum doesn't go where you expected, try to pass the <strong>-vv</strong> argument to the tools, so that they explain you what they do while placing the addendum.</p><p><em>More detailed example</em></p><p>Original document (\s-1POD\s0 formatted):</p><p> |=head1 NAME  |  |dummy - a dummy program  |  |=head1 AUTHOR  |  |me</p><p>Then, the following addendum will ensure that a section (in French) about the translator is added at the end of the file. (in French, \*(L"\s-1TRADUCTEUR\s0\*(R" means \*(L"\s-1TRANSLATOR\s0\*(R", and \*(L"moi\*(R" means \*(L"me\*(R")</p><p> |PO4A-HEADER:mode=after;position=AUTEUR;beginboundary=^=head  |  |=head1 TRADUCTEUR  |  |moi</p><p>In order to put your addendum before the \s-1AUTHOR\s0, use the following header:</p><p> PO4A-HEADER:mode=after;position=NOM;beginboundary=^=head1</p><p>This works because the next line matching the <strong>beginboundary</strong> /^=head1/ after the section \*(L"\s-1NAME\s0\*(R" (translated to \*(L"\s-1NOM\s0\*(R" in French), is the one declaring the authors. So, the addendum will be put between both sections.</p>
<h3>\s-1HOWTO\s0 do all this in one program invocation?</h3>
<p>The use of po4a proved to be a bit error prone for the users since you have to call two different programs in the right order (<strong>po4a-updatepo</strong> and then <strong>po4a-translate</strong>), each of them needing more than 3 arguments. Moreover, it was difficult with this system to use only one \s-1PO\s0 file for all your documents when more than one format was used.</p><p>The <em>po4a</em>\|(1) program was designed to solve those difficulties. Once your project is converted to the system, you write a simple configuration file explaining where your translation files are (\s-1PO\s0 and \s-1POT\s0), where the original documents are, their formats and where their translations should be placed.</p><p>Then, calling <em>po4a</em>\|(1) on this file ensures that the \s-1PO\s0 files are synchronized against the original document, and that the translated document are generated properly. Of course, you will want to call this program twice: once before editing the \s-1PO\s0 file to update them and once afterward to get a completely updated translated document. But you only need to remember one command line.</p>
<h3>\s-1HOWTO\s0 customize po4a?</h3>
<p>po4a modules have options (specified with the <strong>-o</strong> option) that can be used to change the module behavior.</p><p>It is also possible to customize a module or new / derivative / modified modules by putting a module in <em>lib/Locale/Po4a/</em>, and adding <em>lib</em> to the paths specified by the \s-1PERLLIB\s0 or \s-1PERL5LIB\s0 environment. For example:</p><p>   PERLLIB=$PWD/lib po4a --previous po4a/po4a.cfg</p><p>Note: the actual name of the lib directory is not important.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">How does it work?</h2>
        <div class="sectioncontent">
<p>This chapter gives you a brief overview of the po4a internals, so that you may feel more confident to help us maintaining and improving it. It may also help you understanding why it does not do what you expected, and how to solve your problems.</p><h3>What's the big picture here?</h3>
<p>The po4a architecture is object oriented (in Perl. Isn't that neat?). The common ancestor to all parser classes is called TransTractor. This strange name comes from the fact that it is at the same time in charge of translating document and extracting strings.</p><p>More formally, it takes a document to translate plus a \s-1PO\s0 file containing the translations to use as input while producing two separate outputs: Another \s-1PO\s0 file (resulting of the extraction of translatable strings from the input document), and a translated document (with the same structure than the input one, but with all translatable strings replaced with content of the input \s-1PO\s0). Here is a graphical representation of this:</p><p>   Input document --&#92;                             /---&gt; Output document                      &#92;      TransTractor::       /       (translated)                       +--&gt;--   parse()  --------+                      /                           &#92;    Input PO --------/                             &#92;---&gt; Output PO                                                          (extracted)</p><p>This little bone is the core of all the po4a architecture. If you omit the input \s-1PO\s0 and the output document, you get <strong>po4a-gettextize</strong>. If you provide both input and disregard the output \s-1PO\s0, you get <strong>po4a-translate</strong>.</p><p><em>TransTractor::parse()</em> is a virtual function implemented by each module. Here is a little example to show you how it works. It parses a list of paragraphs, each of them beginning with <strong>&lt;p&gt;</strong>.</p><p>  1 sub parse {   2   PARAGRAPH: while (1) {   3     $my ($paragraph,$pararef,$line,$lref)=("","","","");   4     $my $first=1;   5     while (($line,$lref)=$document-&gt;shiftline() && defined($line)) {   6       if ($line =~ m/&lt;p&gt;/ && !$first--; ) {   7         $document-&gt;unshiftline($line,$lref);   8   9         $paragraph =~ s/^&lt;p&gt;//s;  10         $document-&gt;pushline("&lt;p&gt;".$document-&gt;translate($paragraph,$pararef));  11  12         next PARAGRAPH;  13       } else {  14         $paragraph .= $line;  15         $pararef = $lref unless(length($pararef));  16       }  17     }  18     return; # Did not got a defined line? End of input file.  19   }  20 }</p><p>On line 6, we encounter <strong>&lt;p&gt;</strong> for the second time. That's the signal of the next paragraph. We should thus put the just obtained line back into the original document (line 7) and push the paragraph built so far into the outputs. After removing the leading <strong>&lt;p&gt;</strong> of it on line 9, we push the concatenation of this tag with the translation of the rest of the paragraph.</p><p>This <em>translate()</em> function is very cool. It pushes its argument into the output \s-1PO\s0 file (extraction) and returns its translation as found in the input \s-1PO\s0 file (translation). Since it's used as part of the argument of <em>pushline()</em>, this translation lands into the output document.</p><p>Isn't that cool? It is possible to build a complete po4a module in less than 20 lines when the format is simple enough...</p><p>You can learn more about this in <em>Locale::Po4a::TransTractor</em>\|(3pm).</p>
<h3>Gettextization: how does it work?</h3>
<p>The idea here is to take the original document and its translation, and to say that the Nth extracted string from the translation is the translation of the Nth extracted string from the original. In order to work, both files must share exactly the same structure. For example, if the files have the following structure, it is very unlikely that the 4th string in translation (of type 'chapter') is the translation of the 4th string in original (of type 'paragraph').</p><p>    Original         Translation</p><p>  chapter            chapter     paragraph          paragraph     paragraph          paragraph     paragraph        chapter   chapter              paragraph     paragraph          paragraph</p><p>For that, po4a parsers are used on both the original and the translation files to extract \s-1PO\s0 files, and then a third \s-1PO\s0 file is built from them taking strings from the second as translation of strings from the first. In order to check that the strings we put together are actually the translations of each other, document parsers in po4a should put information about the syntactical type of extracted strings in the document (all existing ones do so, yours should also). Then, this information is used to make sure that both documents have the same syntax. In the previous example, it would allow us to detect that string 4 is a paragraph in one case, and a chapter title in another case and to report the problem.</p><p>In theory, it would be possible to detect the problem, and resynchronize the files afterward (just like <strong>diff</strong> does). But what we should do of the few strings before desynchronizations is not clear, and it would produce bad results some times. That's why the current implementation don't try to resynchronize anything and verbosely fail when something goes wrong, requiring manual modification of files to fix the problem.</p><p>Even with these precautions, things can go wrong very easily here. That's why all translations guessed this way are marked fuzzy to make sure that the translator reviews and checks them.</p>
<h3>Addendum: How does it work?</h3>
<p>Well, that's pretty easy here. The translated document is not written directly to disk, but kept in memory until all the addenda are applied. The algorithms involved here are rather straightforward. We look for a line matching the position regexp, and insert the addendum before it if we're in <strong>mode=before</strong>. If not, we search for the next line matching the boundary and insert the addendum after this line if it's an <strong>endboundary</strong> or before this line if it's a <strong>beginboundary</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FAQ</h2>
        <div class="sectioncontent">
<p>This chapter groups the Frequently Asked Questions. In fact, most of the questions for now could be formulated that way: \*(L"Why is it designed this way, and not that one?\*(R" If you think po4a isn't the right answer to documentation translation, you should consider reading this section. If it does not answer your question, please contact us on the &lt;po4a-devel@lists.alioth.debian.org&gt; mailing list. We love feedback.</p><h3>Why to translate each paragraph separately?</h3>
<p>Yes, in po4a, each paragraph is translated separately (in fact, each module decides this, but all existing modules do so, and yours should also). There are two main advantages to this approach:</p><ul>
<li><p>When the technical parts of the document are hidden from the scene, the translator can't mess with them. The fewer markers we present to the translator the less error he can do.</p></li><li><p>Cutting the document helps in isolating the changes to the original document. When the original is modified, finding what parts of the translation need to be updated is eased by this process.</p></li>
</ul><p>Even with these advantages, some people don't like the idea of translating each paragraph separately. Here are some of the answers I can give to their fear:</p><ul>
<li><p>This approach proved successfully in the \s-1KDE\s0 project and allows people there to produce the biggest corpus of translated and up to date documentation I know.</p></li><li><p>The translators can still use the context to translate, since the strings in the \s-1PO\s0 file are in the same order than in the original document. Translating sequentially is thus rather comparable whether you use po4a or not. And in any case, the best way to get the context remains to convert the document to a printable format since the text formatting ones are not really readable, \s-1IMHO\s0.</p></li><li><p>This approach is the one used by professional translators. I agree, that they have somewhat different goals than open-source translators. The maintenance is for example often less critical to them since the content changes rarely.</p></li>
</ul>
<h3>Why not to split on sentence level (or smaller)?</h3>
<p>Professional translator tools sometimes split the document at the sentence level in order to maximize the reusability of previous translations and speed up their process.  The problem is that the same sentence may have several translations, depending on the context.</p><p>Paragraphs are by definition longer than sentences. It will hopefully ensure that having the same paragraph in two documents will have the same meaning (and translation), regardless of the context in each case.</p><p>Splitting on smaller parts than the sentence would be <strong>very bad</strong>. It would be a bit long to explain why here, but interested reader can refer to the <em>Locale::Maketext::TPJ13</em>\|(3pm) man page (which comes with the Perl documentation), for example. To make short, each language has its specific syntactic rules, and there is no way to build sentences by aggregating parts of sentences working for all existing languages (or even for the 5 of the 10 most spoken ones, or even less).</p>
<h3>Why not put the original as comment along with translation (or other way around)?</h3>
<p>At the first glance, gettext doesn't seem to be adapted to all kind of translations.  For example, it didn't seemed adapted to debconf, the interface all Debian packages use for their interaction with the user during installation. In that case, the texts to translate were pretty short (a dozen lines for each package), and it was difficult to put the translation in a specialized file since it has to be available before the package installation.</p><p>That's why the debconf developer decided to implement another solution, where translations are placed in the same file than the original. This is rather appealing. One would even want to do this for \s-1XML\s0, for example. It would look like that:</p><p> &lt;section&gt;   &lt;title lang="en"&gt;My title&lt;/title&gt;   &lt;title lang="fr"&gt;Mon titre&lt;/title&gt;</p><p>  &lt;para&gt;    &lt;text lang="en"&gt;My text.&lt;/text&gt;    &lt;text lang="fr"&gt;Mon texte.&lt;/text&gt;   &lt;/para&gt;  &lt;/section&gt;</p><p>But it was so problematic that a PO-based approach is now used. Only the original can be edited in the file, and the translations must take place in \s-1PO\s0 files extracted from the master template (and placed back at package compilation time). The old system was deprecated because of several issues:</p><ul>
<li><p>maintenance problems If several translators provide a patch at the same time, it gets hard to merge them together. How will you detect changes to the original, which need to be applied to the translations? In order to use diff, you have to note which version of the original you translated. I.e., you need a \s-1PO\s0 file in your file ;)</p></li><li><p>encoding problems This solution is viable when only European languages are involved, but the introduction of Korean, Russian and/or Arab really complicate the picture. \s-1UTF\s0 could be a solution, but there are still some problems with it. Moreover, such problems are hard to detect (i.e., only Korean readers will detect that the encoding of Korean is broken [because of the Russian translator])</p></li>
</ul><p>gettext solves all those problems together.</p>
<h3>But gettext wasn't designed for that use!</h3>
<p>That's true, but until now nobody came with a better solution. The only known alternative is manual translation, with all the maintenance issues.</p>
<h3>What about the other translation tools for documentation using gettext?</h3>
<p>As far as I know, there are only two of them:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>poxml</strong>
  </dt>
  <dd>
    <p>This is the tool developed by \s-1KDE\s0 people to handle DocBook \s-1XML\s0. \s-1AFAIK\s0, it was the first program to extract strings to translate from documentation to \s-1PO\s0 files, and inject them back after translation. It can only handle \s-1XML\s0, and only a particular \s-1DTD\s0. I'm quite unhappy with the handling of lists, which end in one big msgid. When the list become big, the chunk becomes harder to shallow.</p>
  </dd>
  <dt>
    <strong>po-debiandoc</strong>
  </dt>
  <dd>
    <p>This program done by Denis Barbier is a sort of precursor of the po4a \s-1SGML\s0 module, which more or less deprecates it. As the name says, it handles only the DebianDoc \s-1DTD\s0, which is more or less a deprecated \s-1DTD\s0.</p>
  </dd>

</dl>
<p>The main advantages of po4a over them are the ease of extra content addition (which is even worse there) and the ability to achieve gettextization.</p>
<h3>Educating developers about translation</h3>
<p>When you try to translate documentation or programs, you face three kinds of problems; linguistics (not everybody speaks two languages), technical (that's why po4a exists) and relational/human. Not all developers understand the necessity of translating stuff. Even when good willed, they may ignore how to ease the work of translators. To help with that, po4a comes with lot of documentation which can be referred to.</p><p>Another important point is that each translated file begins with a short comment indicating what the file is, how to use it. This should help the poor developers flooded with tons of files in different languages they hardly speak, and help them dealing correctly with it.</p><p>In the po4a project, translated documents are not source files anymore. Since \s-1SGML\s0 files are habitually source files, it's an easy mistake. That's why all files present this header:</p><p> |       *****************************************************  |       *           GENERATED FILE, DO NOT EDIT             *  |       * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *  |       *****************************************************  |  | This file was generated by <strong>po4a-translate</strong>(1). Do not store it (in VCS,  | for example), but store the PO file used as source file by po4a-translate.  |  | In fact, consider this as a binary, and the PO file as a regular source file:  | If the PO gets lost, keeping this translation up-to-date will be harder ;)</p><p>Likewise, gettext's regular \s-1PO\s0 files only need to be copied to the <em>po/</em> directory. But <strong>this is not the case of the ones manipulated by po4a</strong>. The major risk here is that a developer erases the existing translation of his program with the translation of his documentation. (Both of them can't be stored in the same \s-1PO\s0 file, because the program needs to install its translation as an mo file while the documentation only uses its translation at compile time). That's why the \s-1PO\s0 files produced by the po-debiandoc module contain the following header:</p><p> #  #  ADVISES TO DEVELOPERS:  #    - you do not need to manually edit POT or PO files.  #    - this file contains the translation of your debconf templates.  #      Do not replace the translation of your program with this !!  #        (or your translators will get very upset)  #  #  ADVISES TO TRANSLATORS:  #    If you are not familiar with the PO format, gettext documentation  #     is worth reading, especially sections dedicated to this format.  #    For example, run:  #         info -n &apos;(gettext)PO Files&apos;  #         info -n &apos;(gettext)Header Entry&apos;  #  #    Some information specific to po-debconf are available at  #            /usr/share/doc/po-debconf/README-trans  #         or http://www.debian.org/intl/l10n/po-debconf/README-trans  #</p>
<h3>\s-1SUMMARY\s0 of the advantages of the gettext based approach</h3>
<ul>
<li><p>The translations are not stored along with the original, which makes it possible to detect if translations become out of date.</p></li><li><p>The translations are stored in separate files from each other, which prevents translators of different languages from interfering, both when submitting their patch and at the file encoding level.</p></li><li><p>It is based internally on <strong>gettext</strong> (but <strong>po4a</strong> offers a very simple interface so that you don't need to understand the internals to use it). That way, we don't have to re-implement the wheel, and because of their wide use, we can think that these tools are more or less bug free.</p></li><li><p>Nothing changed for the end-user (beside the fact translations will hopefully be better maintained). The resulting documentation file distributed is exactly the same.</p></li><li><p>No need for translators to learn a new file syntax and their favorite \s-1PO\s0 file editor (like Emacs' \s-1PO\s0 mode, Lokalize or Gtranslator) will work just fine.</p></li><li><p>gettext offers a simple way to get statistics about what is done, what should be reviewed and updated, and what is still to do. Some example can be found at those addresses:  - http://kv-53.narod.ru/kaider1.png  - http://www.debian.org/intl/l10n/</p></li>
</ul><p>But everything isn't green, and this approach also has some disadvantages we have to deal with.</p><ul>
<li><p>Addenda are... strange at the first glance.</p></li><li><p>You can't adapt the translated text to your preferences, like splitting a paragraph here, and joining two other ones there. But in some sense, if there is an issue with the original, it should be reported as a bug anyway.</p></li><li><p>Even with an easy interface, it remains a new tool people have to learn. One of my dreams would be to integrate somehow po4a to Gtranslator or Lokalize. When an \s-1SGML\s0 file is opened, the strings are automatically extracted. When it's saved a translated \s-1SGML\s0 file can be written to disk. If we manage to do an \s-1MS\s0 Word (\s-1TM\s0) module (or at least \s-1RTF\s0) professional translators may even use it.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p> Denis Barbier &lt;barbier,linuxfr.org&gt;  Martin Quinson (mquinson#debian.org)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pipe.7.html"><span aria-hidden="true">&larr;</span> pipe.7: Overview of pipes and fifos</a></li>
   <li class="next"><a href="po4a-runtime.7.html">po4a-runtime.7: Po4a and runtime gettext translation without autotools <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

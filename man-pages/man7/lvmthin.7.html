<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>lvmthin: Lvmthin  lvm thin provisioning</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Lvmthin  lvm thin provisioning">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="lvmthin (7) manual">
  <meta name="twitter:description" content="Lvmthin  lvm thin provisioning">
  <meta name="twitter:image" content="https://www.carta.tech/images/lvm2-lvmthin-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/lvmthin.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="lvmthin (7) manual" />
  <meta property="og:description" content="Lvmthin  lvm thin provisioning" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/lvm2-lvmthin-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">lvmthin<small> (7)</small></h1>
        <p class="lead">Lvmthin  lvm thin provisioning</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/lvmthin.7.html">
      <span itemprop="name">lvmthin: Lvmthin  lvm thin provisioning</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/lvm2/">
      <span itemprop="name">lvm2</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/lvmthin.7.html">
      <span itemprop="name">lvmthin: Lvmthin  lvm thin provisioning</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Blocks in a standard logical volume are allocated when the LV is created, but blocks in a thin provisioned logical volume are allocated as they are written.  Because of this, a thin provisioned LV is given a virtual size, and can then be much larger than physically available storage.  The amount of physical storage provided for thin provisioned LVs can be increased later as the need arises.</p><p>Blocks in a standard LV are allocated (during creation) from the VG, but blocks in a thin LV are allocated (during use) from a special "thin pool LV".  The thin pool LV contains blocks of physical storage, and blocks in thin LVs just reference blocks in the thin pool LV.</p><p>A thin pool LV must be created before thin LVs can be created within it. A thin pool LV is created by combining two standard LVs: a large data LV that will hold blocks for thin LVs, and a metadata LV that will hold metadata.  The metadata tracks which data blocks belong to each thin LV.</p><p>Snapshots of thin LVs are efficient because the data blocks common to a thin LV and any of its snapshots are shared.  Snapshots may be taken of thin LVs or of other thin snapshots.  Blocks common to recursive snapshots are also shared in the thin pool.  There is no limit to or degradation from sequences of snapshots.</p><p>As thin LVs or snapshot LVs are written to, they consume data blocks in the thin pool.  As free data blocks in the pool decrease, more free blocks may need to be supplied.  This is done by extending the thin pool data LV with additional physical space from the VG.  Removing thin LVs or snapshots from the thin pool can also free blocks in the thin pool. However, removing LVs is not always an effective way of freeing space in a thin pool because the amount is limited to the number of blocks not shared with other LVs in the pool.</p><p>Incremental block allocation from thin pools can cause thin LVs to become fragmented.  Standard LVs generally avoid this problem by allocating all the blocks at once during creation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Thin Terms</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>ThinDataLV</p>
  </dt>
  <dd>
    <p>thin data LV</p><p>large LV created in a VG</p><p>used by thin pool to store ThinLV blocks</p>
  </dd>
  <dt>
    <p>ThinMetaLV</p>
  </dt>
  <dd>
    <p>thin metadata LV</p><p>small LV created in a VG</p><p>used by thin pool to track data block usage</p>
  </dd>
  <dt>
    <p>ThinPoolLV</p>
  </dt>
  <dd>
    <p>thin pool LV</p><p>combination of ThinDataLV and ThinMetaLV</p><p>contains ThinLVs and SnapLVs</p>
  </dd>
  <dt>
    <p>ThinLV</p>
  </dt>
  <dd>
    <p>thin LV</p><p>created from ThinPoolLV</p><p>appears blank after creation</p>
  </dd>
  <dt>
    <p>SnapLV</p>
  </dt>
  <dd>
    <p>snapshot LV</p><p>created from ThinPoolLV</p><p>appears as a snapshot of another LV after creation</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Thin Usage</h2>
        <div class="sectioncontent">
<p>The primary method for using lvm thin provisioning:</p><h3>1. create ThinDataLV</h3>
<p>Create an LV that will hold thin pool data.</p><p><strong>lvcreate -n ThinDataLV -L LargeSize VG</strong></p><p><em>Example</em></p><p># lvcreate -n pool0 -L 10G vg</p>
<h3>2. create ThinMetaLV</h3>
<p>Create an LV that will hold thin pool metadata.</p><p><strong>lvcreate -n ThinMetaLV -L SmallSize VG</strong></p><p><em>Example</em></p><p># lvcreate -n pool0meta -L 1G vg</p><p># lvs</p>
<pre>
  LV        VG Attr       LSize
  pool0     vg -wi-a----- 10.00g
  pool0meta vg -wi-a----- 1.00g
</pre>

<h3>3. create ThinPoolLV</h3>

<pre>
Combine the data and metadata LVs into a thin pool LV.
ThinDataLV is renamed to hidden ThinPoolLV_tdata.
ThinMetaLV is renamed to hidden ThinPoolLV_tmeta.
The new ThinPoolLV takes the previous name of ThinDataLV.
</pre>
<p><strong>lvconvert --thinpool VG/ThinDataLV --poolmetadata VG/ThinMetaLV</strong></p><p><em>Example</em></p><p># lvconvert --thinpool vg/pool0 --poolmetadata vg/pool0meta</p><p># lvs vg/pool0</p>
<pre>
  LV    VG Attr       LSize  Pool Origin Data% Meta%
  pool0 vg twi-a-tz-- 10.00g      0.00   0.00
</pre>
<p># lvs -a</p>
<pre>
  LV            VG Attr       LSize
  pool0         vg twi-a-tz-- 10.00g
  [pool0_tdata] vg Twi-ao---- 10.00g
  [pool0_tmeta] vg ewi-ao---- 1.00g
</pre>

<h3>4. create ThinLV</h3>

<pre>
Create a new thin LV from the thin pool LV.
The thin LV is created with a virtual size.
Multiple new thin LVs may be created in the thin pool.
Thin LV names must be unique in the VG.
The thinpool argument specifies which thin pool will
contain the ThinLV.
</pre>
<p><strong>lvcreate -n ThinLV -V VirtualSize --thinpool VG/ThinPoolLV</strong></p><p><em>Example</em></p><p>Create a thin LV in a thin pool:</p><p># lvcreate -n thin1 -V 1T --thinpool vg/pool0</p><p>Create another thin LV in the same thin pool:</p><p># lvcreate -n thin2 -V 1T --thinpool vg/pool0</p><p># lvs vg/thin1 vg/thin2</p>
<pre>
  LV    VG Attr       LSize Pool  Origin Data%
  thin1 vg Vwi-a-tz-- 1.00t pool0        0.00
  thin2 vg Vwi-a-tz-- 1.00t pool0        0.00
</pre>

<h3>5. create SnapLV</h3>
<p>Create snapshots of an existing ThinLV or SnapLV.</p><p>Do not specify <strong>-L</strong>, <strong>--size</strong> when creating a thin snapshot.</p><p>A size argument will cause an old COW snapshot to be created.</p><p><strong>lvcreate -n SnapLV -s VG/ThinLV</strong></p><p><strong>lvcreate -n SnapLV -s VG/PrevSnapLV</strong></p><p><em>Example</em></p><p>Create first snapshot of an existing ThinLV:</p><p># lvcreate -n thin1s1 -s vg/thin1</p><p>Create second snapshot of the same ThinLV:</p><p># lvcreate -n thin1s2 -s vg/thin1</p><p>Create a snapshot of the first snapshot:</p><p># lvcreate -n thin1s1s1 -s vg/thin1s1</p><p># lvs vg/thin1s1 vg/thin1s2 vg/thin1s1s1</p>
<pre>
  LV        VG Attr       LSize Pool  Origin
  thin1s1   vg Vwi---tz-k 1.00t pool0 thin1
  thin1s2   vg Vwi---tz-k 1.00t pool0 thin1
  thin1s1s1 vg Vwi---tz-k 1.00t pool0 thin1s1
</pre>

<h3>6. activate SnapLV</h3>
<p>Thin snapshots are created with the persistent "activation skip" flag, indicated by the "k" attribute.  Use -K with lvchange or vgchange to activate thin snapshots with the "k" attribute.</p><p><strong>lvchange -ay -K VG/SnapLV</strong></p><p><em>Example</em></p><p># lvchange -ay -K vg/thin1s1</p><p># lvs vg/thin1s1</p>
<pre>
  LV      VG Attr       LSize Pool  Origin
  thin1s1 vg Vwi-a-tz-k 1.00t pool0 thin1
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Thin Topics</h2>
        <div class="sectioncontent">
<p><strong>Specify devices for data and metadata LVs</strong></p><p><strong>Tolerate device failures using raid</strong></p><p><strong>Spare metadata LV</strong></p><p><strong>Metadata check and repair</strong></p><p><strong>Automatic pool metadata LV</strong></p><p><strong>Activation of thin snapshots</strong></p><p><strong>Removing thin pool LVs, thin LVs and snapshots</strong></p><p><strong>Manually manage free data space of thin pool LV</strong></p><p><strong>Manually manage free metadata space of a thin pool LV</strong></p><p><strong>Using fstrim to increase free space in a thin pool LV</strong></p><p><strong>Automatically extend thin pool LV</strong></p><p><strong>Data space exhaustion</strong></p><p><strong>Metadata space exhaustion</strong></p><p><strong>Zeroing</strong></p><p><strong>Discard</strong></p><p><strong>Chunk size</strong></p><p><strong>Size of pool metadata LV</strong></p><p><strong>Create a thin snapshot of an external, read only LV</strong></p><p><strong>Convert a standard LV to a thin LV with an external origin</strong></p><p><strong>Single step thin pool LV creation</strong></p><p><strong>Single step thin pool LV and thin LV creation</strong></p><p><strong>Merge thin snapshots</strong></p><p><strong>XFS on snapshots</strong></p><h3>Specify devices for data and metadata LVs</h3>
<p>The data and metadata LVs in a thin pool are best created on separate physical devices.  To do that, specify the device name(s) at the end of the lvcreate line.  It can be especially helpful to use fast devices for the metadata LV.</p><p><strong>lvcreate -n ThinDataLV -L LargeSize VG LargePV</strong></p><p><strong>lvcreate -n ThinMetaLV -L SmallSize VG SmallPV</strong></p><p><strong>lvconvert --thinpool VG/ThinDataLV --poolmetadata VG/ThinMetaLV</strong></p><p><em>Example</em></p>
<pre>
# lvcreate -n pool0 -L 10G vg /dev/sdA
# lvcreate -n pool0meta -L 1G vg /dev/sdB
# lvconvert --thinpool vg/pool0 --poolmetadata vg/pool0meta
</pre>
<p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>thin_pool_metadata_require_separate_pvs</strong></p><p>controls the default PV usage for thin pool creation.</p>
<h3>Tolerate device failures using raid</h3>
<p>To tolerate device failures, use raid for the pool data LV and pool metadata LV.  This is especially recommended for pool metadata LVs.</p><p><strong>lvcreate --type raid1 -m 1 -n ThinMetaLV -L SmallSize VG PVA PVB</strong></p><p><strong>lvcreate --type raid1 -m 1 -n ThinDataLV -L LargeSize VG PVC PVD</strong></p><p><strong>lvconvert --thinpool VG/ThinDataLV --poolmetadata VG/ThinMetaLV</strong></p><p><em>Example</em></p>
<pre>
# lvcreate --type raid1 -m 1 -n pool0 -L 10G vg /dev/sdA /dev/sdB
# lvcreate --type raid1 -m 1 -n pool0meta -L 1G vg /dev/sdC /dev/sdD
# lvconvert --thinpool vg/pool0 --poolmetadata vg/pool0meta
</pre>

<h3>Spare metadata LV</h3>
<p>The first time a thin pool LV is created, lvm will create a spare metadata LV in the VG.  This behavior can be controlled with the option --poolmetadataspare y|n.  (Future thin pool creations will also attempt to create the pmspare LV if none exists.)</p><p>To create the pmspare ("pool metadata spare") LV, lvm first creates an LV with a default name, e.g. lvol0, and then converts this LV to a hidden LV with the _pmspare suffix, e.g. lvol0_pmspare.</p><p>One pmspare LV is kept in a VG to be used for any thin pool.</p><p>The pmspare LV cannot be created explicitly, but may be removed explicitly.</p><p><em>Example</em></p>
<pre>
# lvcreate -n pool0 -L 10G vg
# lvcreate -n pool0meta -L 1G vg
# lvconvert --thinpool vg/pool0 --poolmetadata vg/pool0meta

# lvs -a
  [lvol0_pmspare] vg          ewi-------  10.00g
  pool0           vg          twi---tz--  10.00g
  [pool0_tdata]   vg          Twi-------  10.00g
  [pool0_tmeta]   vg          ewi-------   1.00g
</pre>
<p>The "Metadata check and repair" section describes the use of the pmspare LV.</p>
<h3>Metadata check and repair</h3>
<p>If thin pool metadata is damaged, it may be repairable. Checking and repairing thin pool metadata is analagous to running fsck on a file system.</p><p>When a thin pool LV is activated, lvm runs the thin_check command to check the correctness of the metadata on the pool metadata LV.</p><p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>thin_check_executable</strong></p><p>can be set to an empty string ("") to disable the thin_check step. This is not recommended.</p><p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>thin_check_options</strong></p><p>controls the command options used for the thin_check command.</p><p>If the thin_check command finds a problem with the metadata, the thin pool LV is not activated, and the thin pool metadata should be repaired.</p><p>Command to repair a thin pool:</p><p><strong>lvconvert --repair VG/ThinPoolLV</strong></p><p>Repair performs the following steps:</p><p>1. Creates a new, repaired copy of the metadata.</p><p>lvconvert runs the thin_repair command to read damaged metadata from the existing pool metadata LV, and writes a new repaired copy to the VG's pmspare LV.</p><p>2. Replaces the thin pool metadata LV.</p><p>If step 1 is successful, the thin pool metadata LV is replaced with the pmspare LV containing the corrected metadata. The previous thin pool metadata LV, containing the damaged metadata, becomes visible with the new name ThinPoolLV_tmetaN (where N is 0,1,...).</p><p>If the repair works, the thin pool LV and its thin LVs can be activated, and the LV containing the damaged thin pool metadata can be removed. It may be useful to move the new metadata LV (previously pmspare) to a better PV.</p><p>If the repair does not work, the thin pool LV and its thin LVs are lost.</p><p>If metadata is manually restored with thin_repair directly, the pool metadata LV can be manually swapped with another LV containing new metadata:</p><p><strong>lvconvert --thinpool VG/ThinPoolLV --poolmetadata VG/NewThinMetaLV</strong></p>
<h3>Automatic pool metadata LV</h3>
<p>A thin data LV can be converted to a thin pool LV without specifying a thin pool metadata LV.  LVM will automatically create a metadata LV from the same VG.</p><p><strong>lvcreate -n ThinDataLV -L LargeSize VG</strong></p><p><strong>lvconvert --thinpool VG/ThinDataLV</strong></p><p><em>Example</em></p>
<pre>
# lvcreate -n pool0 -L 10G vg
# lvconvert --thinpool vg/pool0

# lvs -a
  pool0           vg          twi-a-tz--  10.00g
  [pool0_tdata]   vg          Twi-ao----  10.00g
  [pool0_tmeta]   vg          ewi-ao----  16.00m
</pre>

<h3>Activation of thin snapshots</h3>
<p>When a thin snapshot LV is created, it is by default given the "activation skip" flag.  This flag is indicated by the "k" attribute displayed by lvs:</p>
<pre>
# lvs vg/thin1s1
  LV         VG  Attr       LSize Pool  Origin
  thin1s1    vg  Vwi---tz-k 1.00t pool0 thin1
</pre>
<p>This flag causes the snapshot LV to be skipped, i.e. not activated, by normal activation commands.  The skipping behavior does not apply to deactivation commands.</p><p>A snapshot LV with the "k" attribute can be activated using the -K (or --ignoreactivationskip) option in addition to the standard -ay (or --activate y) option.</p><p>Command to activate a thin snapshot LV:</p><p><strong>lvchange -ay -K VG/SnapLV</strong></p><p>The persistent "activation skip" flag can be turned off during lvcreate, or later with lvchange using the -kn (or --setactivationskip n) option. It can be turned on again with -ky (or --setactivationskip y).</p><p>When the "activation skip" flag is removed, normal activation commands will activate the LV, and the -K activation option is not needed.</p><p>Command to create snapshot LV without the activation skip flag:</p><p><strong>lvcreate -kn -n SnapLV -s VG/ThinLV</strong></p><p>Command to remove the activation skip flag from a snapshot LV:</p><p><strong>lvchange -kn VG/SnapLV</strong></p><p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>auto_set_activation_skip</strong></p><p>controls the default activation skip setting used by lvcreate.</p>
<h3>Removing thin pool LVs, thin LVs and snapshots</h3>
<p>Removing a thin LV and its related snapshots returns the blocks it used to the thin pool LV.  These blocks will be reused for other thin LVs and snapshots.</p><p>Removing a thin pool LV removes both the data LV and metadata LV and returns the space to the VG.</p><p>lvremove of thin pool LVs, thin LVs and snapshots cannot be reversed with vgcfgrestore.</p><p>vgcfgbackup does not back up thin pool metadata.</p>
<h3>Manually manage free data space of thin pool LV</h3>
<p>The available free space in a thin pool LV can be displayed with the lvs command.  Free space can be added by extending the thin pool LV.</p><p>Command to extend thin pool data space:</p><p><strong>lvextend -L Size VG/ThinPoolLV</strong></p><p><em>Example</em></p>
<pre>
1. A thin pool LV is using 26.96% of its data blocks.
# lvs
  LV    VG           Attr       LSize   Pool  Origin Data%
  pool0 vg           twi-a-tz--  10.00g               26.96

2. Double the amount of physical space in the thin pool LV.
# lvextend -L+10G vg/pool0

3. The percentage of used data blocks is half the previous value.
# lvs
  LV    VG           Attr       LSize   Pool  Origin Data%
  pool0 vg           twi-a-tz--  20.00g               13.48
</pre>
<p>Other methods of increasing free data space in a thin pool LV include removing a thin LV and its related snapsots, or running fstrim on the file system using a thin LV.</p>
<h3>Manually manage free metadata space of a thin pool LV</h3>
<p>The available metadata space in a thin pool LV can be displayed with the lvs -o+metadata_percent command.</p><p>Command to extend thin pool metadata space:</p><p><strong>lvextend -L Size VG/ThinPoolLV_tmeta</strong></p><p><em>Example</em></p><p>1. A thin pool LV is using 12.40% of its metadata blocks.</p>
<pre>
# lvs -oname,size,data_percent,metadata_percent vg/pool0
  LV    LSize   Data%  Meta%
  pool0  20.00g  13.48  12.40
</pre>
<p>2. Display a thin pool LV with its component thin data LV and thin metadata LV.</p>
<pre>
# lvs -a -oname,attr,size vg
  LV              Attr       LSize
  pool0           twi-a-tz--  20.00g
  [pool0_tdata]   Twi-ao----  20.00g
  [pool0_tmeta]   ewi-ao----  12.00m
</pre>
<p>3. Double the amount of physical space in the thin metadata LV.</p>
<pre>
# lvextend -L+12M vg/pool0_tmeta
</pre>
<p>4. The percentage of used metadata blocks is half the previous value.</p>
<pre>
# lvs -a -oname,size,data_percent,metadata_percent vg
  LV              LSize   Data%  Meta%
  pool0            20.00g  13.48   6.20
  [pool0_tdata]    20.00g
  [pool0_tmeta]    24.00m
</pre>

<h3>Using fstrim to increase free space in a thin pool LV</h3>
<p>Removing files in a file system on top of a thin LV does not generally add free space back to the thin pool.  Manually running the fstrim command can return space back to the thin pool that had been used by removed files.  fstrim uses discards and will not work if the thin pool LV has discards mode set to ignore.</p><p><em>Example</em></p><p>A thin pool has 10G of physical data space, and a thin LV has a virtual size of 100G.  Writing a 1G file to the file system reduces the free space in the thin pool by 10% and increases the virtual usage of the file system by 1%.  Removing the 1G file restores the virtual 1% to the file system, but does not restore the physical 10% to the thin pool.  The fstrim command restores the physical space to the thin pool.</p>
<pre>
# lvs -a -oname,attr,size,pool_lv,origin,data_percent,metadata_percent vg
LV              Attr       LSize   Pool  Origin Data%  Meta%
pool0           twi-a-tz--  10.00g               47.01  21.03
thin1           Vwi-aotz-- 100.00g pool0          2.70

# df -h /mnt/X
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/vg-thin1   99G  1.1G   93G   2% /mnt/X

# dd if=/dev/zero of=/mnt/X/1Gfile bs=4096 count=262144; sync

# lvs
pool0           vg   twi-a-tz--  10.00g               57.01  25.26
thin1           vg   Vwi-aotz-- 100.00g pool0          3.70

# df -h /mnt/X
/dev/mapper/vg-thin1   99G  2.1G   92G   3% /mnt/X

# rm /mnt/X/1Gfile

# lvs
pool0           vg   twi-a-tz--  10.00g               57.01  25.26
thin1           vg   Vwi-aotz-- 100.00g pool0          3.70

# df -h /mnt/X
/dev/mapper/vg-thin1   99G  1.1G   93G   2% /mnt/X

# fstrim -v /mnt/X

# lvs
pool0           vg   twi-a-tz--  10.00g               47.01  21.03
thin1           vg   Vwi-aotz-- 100.00g pool0          2.70
</pre>
<p>The "Discard" section covers an option for automatically freeing data space in a thin pool.</p>
<h3>Automatically extend thin pool LV</h3>
<p>An lvm daemon (dmeventd) will by default monitor the data usage of thin pool LVs and extend them when the usage reaches a certain level. The necessary free space must exist in the VG to extend the thin pool LVs.</p><p>Command to enable or disable the monitoring and automatic extension of an existing thin pool LV:</p><p><strong>lvchange --monitor {y|n} VG/ThinPoolLV</strong></p><p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>thin_pool_autoextend_threshold</strong></p><p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>thin_pool_autoextend_percent</strong></p><p>control the default autoextend behavior.</p><p>thin_pool_autoextend_threshold is a percentage value that defines when the thin pool LV should be extended.  Setting this to 100 disables automatic extention.  The minimum value is 50.</p><p>thin_pool_autoextend_percent defines how much extra data space should be added to the thin pool, in percent of its current size.</p><p>Warnings are emitted through syslog when the use of a pool reaches 80%, 85%, 90% and 95%.</p><p><em>Example</em></p><p>If thin_pool_autoextend_threshold is 70 and thin_pool_autoextend_percent is 20, whenever a pool exceeds 70% usage, it will be extended by another 20%. For a 1G pool, using 700M will trigger a resize to 1.2G. When the usage exceeds 840M, the pool will be extended to 1.44G, and so on.</p>
<h3>Data space exhaustion</h3>
<p>If thin pool data space is exhausted, writes to thin LVs will be queued until the the data space is extended.  Reading is still possible.</p><p>When data space is exhausted, the lvs command displays 100 under Data% for the thin pool LV:</p>
<pre>
# lvs vg/pool0
  LV     VG           Attr       LSize   Pool  Origin Data%
  pool0  vg           twi-a-tz-- 512.00m              100.00
</pre>
<p>A thin pool can run out of data blocks for any of the following reasons:</p><p>1. Automatic extension of the thin pool is disabled, and the thin pool is not manually extended.  (Disabling automatic extension is not recommended.)</p><p>2. The dmeventd daemon is not running and the thin pool is not manually extended.  (Disabling dmeventd is not recommended.)</p><p>3. Automatic extension of the thin pool is too slow given the rate of writes to thin LVs in the pool.  (This can be addressed by tuning the thin_pool_autoextend_threshold and thin_pool_autoextend_percent.)</p><p>4. The VG does not have enough free blocks to extend the thin pool.</p><p>The response to data space exhaustion is to extend the thin pool.  This is described in the section "Manually manage free data space of thin pool LV".</p>
<h3>Metadata space exhaustion</h3>
<p>If thin pool metadata space is exhausted (or a thin pool metadata operation fails), errors will be returned for IO operations on thin LVs.</p><p>When metadata space is exhausted, the lvs command displays 100 under Meta% for the thin pool LV:</p>
<pre>
# lvs -o lv_name,size,data_percent,metadata_percent vg/pool0
  LV    LSize Data%  Meta%
  pool0              100.00
</pre>
<p>The same reasons for thin pool data space exhaustion apply to thin pool metadata space.</p><p>Metadata space exhaustion can lead to inconsistent thin pool metadata and inconsistent file systems, so the response requires offline checking and repair.</p><p>1. Deactivate the thin pool LV, or reboot the system if this is not possible.</p><p>2. Repair thin pool with lvconvert --repair.</p>
<pre>
   See "Metadata check and repair".
</pre>
<p>3. Extend pool metadata space with lvextend VG/ThinPoolLV_tmeta.</p>
<pre>
   See "Manually manage free metadata space of a thin pool LV".
</pre>
<p>4. Check and repair file system with fsck.</p>
<h3>Zeroing</h3>
<p>When a thin pool provisions a new data block for a thin LV, the new block is first overwritten with zeros.  The zeroing mode is indicated by the "z" attribute displayed by lvs.  The option -Z (or --zero) can be added to commands to specify the zeroing mode.</p><p>Command to set the zeroing mode when creating a thin pool LV:</p><p><strong>lvconvert -Z{y|n} --thinpool VG/ThinDataLV</strong></p><p><strong>    --poolmetadata VG/ThinMetaLV</strong></p><p>Command to change the zeroing mode of an existing thin pool LV:</p><p><strong>lvchange -Z{y|n} VG/ThinPoolLV</strong></p><p>If zeroing mode is changed from "n" to "y", previously provisioned blocks are not zeroed.</p><p>Provisioning of large zeroed chunks impacts performance.</p><p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>thin_pool_zero</strong></p><p>controls the default zeroing mode used when creating a thin pool.</p>
<h3>Discard</h3>
<p>The discard behavior of a thin pool LV determines how discard requests are handled.  Enabling discard under a file system may adversely affect the file system performance (see the section on fstrim for an alternative.) Possible discard behaviors:</p><p>ignore: Ignore any discards that are received.</p><p>nopassdown: Process any discards in the thin pool itself and allow the no longer needed extends to be overwritten by new data.</p><p>passdown: Process discards in the thin pool (as with nopassdown), and pass the discards down the the underlying device.  This is the default mode.</p><p>Command to display the current discard mode of a thin pool LV:</p><p><strong>lvs -o+discards VG/ThinPoolLV</strong></p><p>Command to set the discard mode when creating a thin pool LV:</p><p><strong>lvconvert --discards {ignore|nopassdown|passdown}</strong></p><p><strong>--thinpool VG/ThinDataLV --poolmetadata VG/ThinMetaLV</strong></p><p>Command to change the discard mode of an existing thin pool LV:</p><p><strong>lvchange --discards {ignore|nopassdown|passdown} VG/ThinPoolLV</strong></p><p><em>Example</em></p>
<pre>
# lvs -o name,discards vg/pool0
pool0 passdown

# lvchange --discards ignore vg/pool0
</pre>
<p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>thin_pool_discards</strong></p><p>controls the default discards mode used when creating a thin pool.</p>
<h3>Chunk size</h3>
<p>The size of data blocks managed by a thin pool can be specified with the --chunksize option when the thin pool LV is created.  The default unit is kilobytes and the default value is 64KiB.  The value must be a power of two between 4KiB and 1GiB.</p><p>When a thin pool is used primarily for the thin provisioning feature, a larger value is optimal.  To optimize for a lot of snapshotting, a smaller value reduces copying time and consumes less space.</p><p>Command to display the thin pool LV chunk size:</p><p><strong>lvs -o+chunksize VG/ThinPoolLV</strong></p><p><em>Example</em></p>
<pre>
# lvs -o name,chunksize
  pool0 64.00k
</pre>
<p><a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a> <strong>thin_pool_chunk_size</strong></p><p>controls the default chunk size used when creating a thin pool.</p>
<h3>Size of pool metadata LV</h3>
<p>The amount of thin metadata depends on how many blocks are shared between thin LVs (i.e. through snapshots).  A thin pool with many snapshots may need a larger metadata LV.</p><p>The range of supported metadata LV sizes is 2MiB to 16GiB.</p><p>The default size is estimated with the formula:</p><p>ThinPoolLVSize / ThinPoolLVChunkSize * 64b.</p><p>When creating a thin metadata LV explicitly, the size is specified in the lvcreate command.  When a command automatically creates a thin metadata LV, the --poolmetadatasize option can be used specify a non-default size.  The default unit is megabytes.</p>
<h3>Create a thin snapshot of an external, read only LV</h3>
<p>Thin snapshots are typically taken of other thin LVs or other thin snapshot LVs within the same thin pool.  It is also possible to take thin snapshots of external, read only LVs.  Writes to the snapshot are stored in the thin pool, and the external LV is used to read unwritten parts of the thin snapshot.</p><p><strong>lvcreate -n SnapLV -s VG/ExternalOriginLV --thinpool VG/ThinPoolLV</strong></p><p><em>Example</em></p>
<pre>
# lvchange -an vg/lve
# lvchange --permission r vg/lve
# lvcreate -n snaplve -s vg/lve --thinpool vg/pool0

# lvs vg/lve vg/snaplve
  LV      VG  Attr       LSize  Pool  Origin Data%
  lve     vg  ori------- 10.00g
  snaplve vg  Vwi-a-tz-- 10.00g pool0 lve      0.00
</pre>

<h3>Convert a standard LV to a thin LV with an external origin</h3>
<p>A new thin LV can be created and given the name of an existing standard LV.  At the same time, the existing LV is converted to a read only external LV with a new name.  Unwritten portions of the thin LV are read from the external LV. The new name given to the existing LV can be specified with --originname, otherwise the existing LV will be given a default name, e.g. lvol#.</p><p>Convert ExampleLV into a read only external LV with the new name NewExternalOriginLV, and create a new thin LV that is given the previous name of ExampleLV.</p><p><strong>lvconvert --type thin --thinpool VG/ThinPoolLV</strong></p><p><strong>--originname NewExternalOriginLV --thin VG/ExampleLV</strong></p><p><em>Example</em></p>
<pre>
# lvcreate -n lv_example -L 10G vg

# lvs
  lv_example      vg          -wi-a-----  10.00g

# lvconvert --type thin --thinpool vg/pool0
          --originname lv_external --thin vg/lv_example

# lvs
  LV              VG          Attr       LSize   Pool  Origin
  lv_example      vg          Vwi-a-tz--  10.00g pool0 lv_external
  lv_external     vg          ori-------  10.00g
</pre>

<h3>Single step thin pool LV creation</h3>
<p>A thin pool LV can be created with a single lvcreate command, rather than using lvconvert on existing LVs. This one command creates a thin data LV, a thin metadata LV, and combines the two into a thin pool LV.</p><p><strong>lvcreate -L LargeSize --thinpool VG/ThinPoolLV</strong></p><p><em>Example</em></p>
<pre>
# lvcreate -L8M --thinpool vg/pool0

# lvs vg/pool0
  LV    VG  Attr       LSize Pool Origin Data%
  pool0 vg  twi-a-tz-- 8.00m               0.00

# lvs -a
  pool0           vg          twi-a-tz--   8.00m
  [pool0_tdata]   vg          Twi-ao----   8.00m
  [pool0_tmeta]   vg          ewi-ao----   8.00m
</pre>

<h3>Single step thin pool LV and thin LV creation</h3>
<p>A thin pool LV and a thin LV can be created with a single lvcreate command.  This one command creates a thin data LV, a thin metadata LV, combines the two into a thin pool LV, and creates a thin LV in the new pool.</p><p>-L LargeSize specifies the physical size of the thin pool LV.</p><p>-V VirtualSize specifies the virtual size of the thin LV.</p><p><strong>lvcreate -L LargeSize -V VirtualSize -n ThinLV</strong></p><p><strong>    --thinpool VG/ThinPoolLV</strong></p><p>Equivalent to:</p><p><strong>lvcreate -L LargeSize --thinpool VG/ThinPoolLV</strong></p><p><strong>lvcreate -n ThinLV -V VirtualSize --thinpool VG/ThinPoolLV</strong></p><p><em>Example</em></p>
<pre>
# lvcreate -L8M -V2G -n thin1 --thinpool vg/pool0

# lvs -a
  pool0           vg          twi-a-tz--   8.00m
  [pool0_tdata]   vg          Twi-ao----   8.00m
  [pool0_tmeta]   vg          ewi-ao----   8.00m
  thin1           vg          Vwi-a-tz--   2.00g pool0
</pre>

<h3>Merge thin snapshots</h3>
<p>A thin snapshot can be merged into its origin thin LV using the lvconvert --merge command.  The result of a snapshot merge is that the origin thin LV takes the content of the snapshot LV, and the snapshot LV is removed. Any content that was unique to the origin thin LV is lost after the merge.</p><p>Because a merge changes the content of an LV, it cannot be done while the LVs are open, e.g. mounted.  If a merge is initiated while the LVs are open, the effect of the merge is delayed until the origin thin LV is next activated.</p><p><strong>lvconvert --merge VG/SnapLV</strong></p><p><em>Example</em></p>
<pre>
# lvs vg
  LV      VG Attr       LSize   Pool  Origin
  pool0   vg twi-a-tz--  10.00g
  thin1   vg Vwi-a-tz-- 100.00g pool0
  thin1s1 vg Vwi-a-tz-k 100.00g pool0 thin1

# lvconvert --merge vg/thin1s1

# lvs vg
  LV      VG Attr       LSize   Pool  Origin
  pool0   vg twi-a-tz--  10.00g
  thin1   vg Vwi-a-tz-- 100.00g pool0
</pre>
<p><em>Example</em></p>
<pre>
Delayed merging of open LVs.

# lvs vg
  LV      VG Attr       LSize   Pool  Origin
  pool0   vg twi-a-tz--  10.00g
  thin1   vg Vwi-aotz-- 100.00g pool0
  thin1s1 vg Vwi-aotz-k 100.00g pool0 thin1

# df
/dev/mapper/vg-thin1            100G   33M  100G   1% /mnt/X
/dev/mapper/vg-thin1s1          100G   33M  100G   1% /mnt/Xs

# ls /mnt/X
file1 file2 file3
# ls /mnt/Xs
file3 file4 file5

# lvconvert --merge vg/thin1s1
Logical volume vg/thin1s1 contains a filesystem in use.
Delaying merge since snapshot is open.
Merging of thin snapshot thin1s1 will occur on next activation.

# umount /mnt/X
# umount /mnt/Xs

# lvs -a vg
  LV              VG   Attr       LSize   Pool  Origin
  pool0           vg   twi-a-tz--  10.00g
  [pool0_tdata]   vg   Twi-ao----  10.00g
  [pool0_tmeta]   vg   ewi-ao----   1.00g
  thin1           vg   Owi-a-tz-- 100.00g pool0
  [thin1s1]       vg   Swi-a-tz-k 100.00g pool0 thin1

# lvchange -an vg/thin1
# lvchange -ay vg/thin1

# mount /dev/vg/thin1 /mnt/X

# ls /mnt/X
file3 file4 file5
</pre>

<h3>XFS on snapshots</h3>
<p>Mounting an XFS file system on a new snapshot LV requires attention to the file system's log state and uuid.  On the snapshot LV, the xfs log will contain a dummy transaction, and the xfs uuid will match the uuid from the file system on the origin LV.</p><p>If the snapshot LV is writable, mounting will recover the log to clear the dummy transaction, but will require skipping the uuid check:</p><p>mount /dev/VG/SnapLV /mnt -o nouuid</p><p>Or, the uuid can be changed on disk before mounting:</p><p>xfs_admin -U generate /dev/VG/SnapLV</p><p>mount /dev/VG/SnapLV /mnt</p><p>If the snapshot LV is readonly, the log recovery and uuid check need to be skipped while mounting readonly:</p><p>mount /dev/VG/SnapLV /mnt -o ro,nouuid,norecovery</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO lvmthin&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man8/lvm.8.html"><strong>lvm</strong>(8)</a>, <a href="../man5/lvm.conf.5.html"><strong>lvm.conf</strong>(5)</a>, <a href="../man8/lvcreate.8.html"><strong>lvcreate</strong>(8)</a>, <a href="../man8/lvconvert.8.html"><strong>lvconvert</strong>(8)</a>, <a href="../man8/lvchange.8.html"><strong>lvchange</strong>(8)</a>, <a href="../man8/lvextend.8.html"><strong>lvextend</strong>(8)</a>, <a href="../man8/lvremove.8.html"><strong>lvremove</strong>(8)</a>, <a href="../man8/lvs.8.html"><strong>lvs</strong>(8)</a>, <a href="../man8/thin_dump.8.html"><strong>thin_dump</strong>(8)</a>, <a href="../man8/thin_repair.8.html"><strong>thin_repair</strong>(8)</a> <a href="../man8/thin_restore.8.html"><strong>thin_restore</strong>(8)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="lvmcache.7.html"><span aria-hidden="true">&larr;</span> lvmcache.7: Lvmcache  lvm caching</a></li>
   <li class="next"><a href="lxc.7.html">lxc.7: Linux containers <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

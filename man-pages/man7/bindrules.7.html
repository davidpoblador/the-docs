<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>bindrules: Shapetools version bind rules</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Shapetools version bind rules">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="bindrules (7) manual">
  <meta name="twitter:description" content="Shapetools version bind rules">
  <meta name="twitter:image" content="https://www.carta.tech/images/libatfs1-bindrules-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/bindrules.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="bindrules (7) manual" />
  <meta property="og:description" content="Shapetools version bind rules" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libatfs1-bindrules-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">bindrules<small> (7)</small></h1>
        <p class="lead">Shapetools version bind rules</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/bindrules.7.html">
      <span itemprop="name">bindrules: Shapetools version bind rules</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libatfs1/">
      <span itemprop="name">libatfs1</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/bindrules.7.html">
      <span itemprop="name">bindrules: Shapetools version bind rules</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The ShapeTools version binding subsystem (see <a href="../man1/vbind.1.html"><strong>vbind</strong>(1)</a>) provides a mechanism for expressing <em>general version bind rules</em>. These rules describe on an abstract level version properties, which will be matched against the properties of concrete versions during the version bind procedure. The goal is to select one or more versions from a named history in order to provides access to these version(s). A version bind operation is always performed for exactly one history at a time. Version bind rules express something like</p>
<pre>
	<em>Select the most recent saved version.</em>
	<em>If there is no saved version, select the busy version.</em>
</pre>
<p>ShapeTools however needs rules in a more formal notation to be able to interpret them. Let's see, how the rule above is translated into the formal notation.</p><p>Version bind rules consist of a list of attribute expressions evaluated one after another until one of the expressions leads to a unique version identification. The expressions are separated by semicolons, the last expression ends with a period. The rule from above will now read:</p>
<pre>
	<em>Select the most recent saved version</em> <strong>;</strong>
	<em>Select the busy version</em> <strong>.</strong>
</pre>
<p>Each attribute expression consist of a list of predicates, separated by commas. The predicates are evaluated from left to right resulting in a <em>hit set</em>, a set of versions fulfilling all predicates evaluated so far. The initial hit set for an attribute expression contains all versions of the name to be bound. Each predicate potentially narrows the hit set. The predicates in our rule are:</p>
<pre>
	<em>all saved versions</em> <strong>,</strong> <em>most recent version</em> <strong>;</strong>
	<em>busy version</em> <strong>.</strong>
</pre>
<p>Remember, that each predicate bases it's selection on the hit set left by the predicate before. Hence exchanging the two predicates in the first attribute expression may lead to different results. We will give more information on this topic in the section about the evaluation algorithm below. We now reach the final form of ShapeTools version bind rules. The predicates must be taken from a list of predefined names and be equipped with arguments:</p>
<pre>
	ge (status, saved) <strong>,</strong> max (stime)<strong> </strong><strong>;</strong><strong></strong>
	eq (status, busy) <strong>.</strong>
</pre>
<p>That's it so far. This is a rule how ShapeTools understands it. It does however illustrate just a small piece of the world of version bind rules. We will go on in this manual page with a detailed description of version bind rules divides into the sections</p>
<dl class='dl-vertical'>
  <dt>
    RULE HEAD
  </dt>
  <dd>
    <p>Description of the structure of rule heads.</p>
  </dd>
  <dt>
    EVALUATION ALGORITHM
  </dt>
  <dd>
    <p>The Algorithm how version bind rules are evaluated.</p>
  </dd>
  <dt>
    NAME PATTERNS
  </dt>
  <dd>
    <p>Name patterns as first predicate in attribute expressions.</p>
  </dd>
  <dt>
    PREDICATES
  </dt>
  <dd>
    <p>List of valid predicates.</p>
  </dd>
  <dt>
    ATTRIBUTES
  </dt>
  <dd>
    <p>A List of predefined attribute names and some word about the ordering relationship between attribute values.</p>
  </dd>
  <dt>
    EXPANSION
  </dt>
  <dd>
    <p>Description of the various types of expansion such as parameter substitution, attribute and macro expansion, and command substitution.</p>
  </dd>
  <dt>
    LEXICAL STRUCTURE
  </dt>
  <dd>
    <p>Lexical constraints for names and strings in version bind rules.</p>
  </dd>
  <dt>
    TIPS, TRICKS, AND TRAPS
  </dt>
  <dd>
    <p>Some common problems.</p>
  </dd>
  <dt>
    GRAMMAR
  </dt>
  <dd>
    <p>A complete grammar for version bind rules.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RULE HEAD</h2>
        <div class="sectioncontent">
<p>A version bind rule consists of a rule head and a rule body. The example above shows only the rule body. The rule head defines a name for the rule and optionally a parameter list. The name is a string consisting of any printable non-whitespace character except colon and parentheses. It is followed by an optional parameter list in parentheses and a colon, delimiting the rule head. Multiple parameters in the list are separated by comma. Examples are</p>
<pre>
	most_recently_released:

	from_release (release_name):

	last_released (library_path, include_path):

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EVALUATION ALGORITHM</h2>
        <div class="sectioncontent">
<p>The basic idea of the rule evaluation algorithm is, that in every state of processing a <em>hit set</em> exists, a set of versions reflecting the current rule evaluation result. The hit set is initialized with all versions of the given name at the beginning of each attribute expression. The attribute expressions predicates are processed from left to right in the order they occur. Each predicate imposes requirements to the versions in the hit set and eliminates all versions not fulfilling these requirements. So, the hit set becomes smaller and smaller during attribute expression evaluation. The following figure illustrates this process together with the rule most_recently_released defined above and the file foo existing as busy version and as versions 1.0 through 1.2.</p>
<pre>
	Initial hit set:	( foo[busy], foo[1.0], foo[1.1], foo[1.2] )

	Evaluate Predicate:	ge (status, saved),

	New hit set:	( foo[1.0], foo[1.1], foo[1.2] )

	Evaluate Predicate:	max (stime);

	Final hit set:	( foo[1.2] )
</pre>
<p>When the hit set becomes empty, that is when no version meets all the predicates evaluated so far, the attribute expression <em>fails</em> and processing is finished immediately. All remaining predicates will not be evaluated. Even remaining predicates without influence on the hit set (for example message predicates) will not be processed. Processing continues with the next attribute expression. If all attribute expressions finish prematurely, the whole version binding fails. In the following example, the first attribute expression fails and the second alternative leads to success.</p>
<pre>
	Initial hit set:	( bar[busy] )

	Evaluate Predicate:	ge (status, saved),

	New hit set (empty):	( )

	Evaluate next attribute expression
	starting with initial hit set again:	( bar[busy] )

	Evaluate Predicate:	eq (status, busy);

	Final hit set:	( bar[busy] )
</pre>
<p>When evaluation reaches the end of an attribute expression without the hit set being empty, two cases are possible. First, the hit set contains exactly one version and everything is fine. This is usually the desired state and rule evaluation returns the remaining version as bind result. Second, the hit set may contain more than one version. In this case, the evaluation algorithm depends on the expected result. When a unique version binding is expected, this is treated as failure and evaluation goes on with the next attribute expression. Non-unique version binding regards this as success and returns the whole hit set.</p><p>Extending the hit set during evaluation of an attribute expression is not possible. This would be against the nature of the version bind rules and would make them much more difficult to understand. Hit set extension may only happen by letting the current attribute expression fail and begin with a new one and the maximum hit set.</p><p>Failure of an attribute expression must not necessarily be caused by an empty hit set. It may also be caused by user interaction or by external constraints. The following rules exemplify user interaction:</p>
<pre>
	eq (state, busy), confirm (select busy version ?, y);
	ge (state, busy), max (version).
</pre>
<p>where the user will be asked for confirmation to select the busy version, and external constraints:</p>
<pre>
	exists (otto, 1.0), eq (state, busy);
	ge (state, busy), max (version).
</pre>
<p>where selection of the busy version happens only, when version 1.0 of otto exists (this example is somewhat silly). Predicates like confirm and exists don't care about the hit set. They provide the possibility to impose external control on the evaluation of version bind rules. An attribute expression may be finished prematurely and control switches to the next one.</p><p>There is another operator, the cut operator, that forces the whole bind operation to finish (and fail). Typically the cut operator stands at the end of an attribute expression that should never succeed. The following is a typical example for use of this. Version binding fails, if there is an update lock set on the most recent version.</p>
<pre>
	max (version), hasattr (locker), cut (history is locked !);
	max (version).
</pre>
<p>The cut operator accepts a string argument that will be written to the standard output.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAME PATTERNS</h2>
        <div class="sectioncontent">
<p>Each attribute expression may start with a pattern, against which the name to be bound is matched. Only when the name matches the pattern, the corresponding attribute expression will be evaluated. If not, the attribute expression will be skipped. When the pattern is omitted in the attribute expression (as in our example above), the expression is evaluated for each name.</p><p>The patterns are the same as those recognized by sh(1) for filename generation on the command line. Magic cookies are:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>*</strong>
  </dt>
  <dd>
    <p>matching any string, including the empty string,</p>
  </dd>
  <dt>
    <strong>?</strong>
  </dt>
  <dd>
    <p>matching any single character,</p>
  </dd>
  <dt>
    <strong>[c...]</strong>
  </dt>
  <dd>
    <p>matching any one of the characters enclosed in the square brackets,</p>
  </dd>
  <dt>
    <strong>[l-r]</strong>
  </dt>
  <dd>
    <p>matching any character lexically between the left (<strong>l</strong>) and the right (<strong>r</strong>) character, inclusive, and</p>
  </dd>
  <dt>
    <strong>[!c...]</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>[!l-r]</strong>
  </dt>
  <dd>
    <p>matching any character not recognized by their counterparts above.</p>
  </dd>

</dl>
<p>A rule with name patterns for example looks like:</p>
<pre>
	xyyz.h,	eq (version, 1.3);
	*.c, 	eq (generation, 2), max (revision);
	*.h, 	eq (generation, 3), max (revision).
</pre>
<p>In this example, version binding for C source files (most recent version from generation 2) is different from version binding for header files (most recent version from generation 3). Additionally, the name xyyz.h will always be bound to version 1.3.</p><p>If the name to be bound is given together with a (absolute or relative) pathname, this will <em>not</em> be cut off. The match is always performed lexically for the whole name given. Hence, the name pattern may also contain path names, like</p>
<pre>
	variant1/*,	eq (alias, var1-1.4);
	variant2/*, 	eq (alias, var2-1.2);
	/usr/sample/include/*.h,	max (revision).
</pre>
<p>Usually, the version bind subsystem does not check, if different path prefixes in the name pattern and the given name to be bound lead to the same location. The match is done lexically and must fit exactly. An exception is, when the name pattern is given as network path name as in <a href="../man3/atnetwork.3.html"><strong>atnetwork</strong>(3)</a>. A network pathname consists of the name of the host, controlling the device where a version is stored, the canonical pathname to the version and a version binding (e.g. version number, version alias, or date) either in brackets or separated from the name by an at (@) sign. Examples are</p>
<pre>
	desaster:/usr/sample/project/foo.c[1.0];
	desaster:/usr/sample/project/variant1/bar.c[var1-1.4];
	desaster:/usr/sample/project/xyyz.h@1.3;
	desaster:/usr/sample/project/bar.c@Fri Jun 18 13:40:58 MET DST 1993.
</pre>
<p>Network pathnames are mapped to canonical local pathnames before being processes and in this case, the given name to be bound will also be mapped to a canonical local pathname.</p><p>The technique using network pathnames is especially useful when storing the result of a successful version selection persistently. This makes the version selection easily reproducible from anywhere in the local areas network. <a href="../man1/shape.1.html"><strong>shape</strong>(1)</a> uses this mechanism when generating its <em>bound configuration threads</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PREDICATES</h2>
        <div class="sectioncontent">
<p>This is the complete list of valid predicate names and a synopsis of their arguments. The list is divided into several parts, each describing a certain class of predicates.</p><p>The first class are predicates working independently on each element of the current hit set. They impose certain requirements to the attributes of each version and eliminate those, not fulfilling the requirements.</p>
<dl class='dl-vertical'>
  <dt>
    eq (<em>attrName</em>,<em>attrValue</em>)
  </dt>
  <dd>
    <p>The named attribute must exist in the versions attribute list and it must have exactly the given value. When the corresponding version attribute has multiple values, at least one of the values must match exactly.</p>
  </dd>
  <dt>
    hasattr (<em>attrName</em>)
  </dt>
  <dd>
    <p>The named attribute must exist in the versions attribute list. When applied to a standard attribute, hasattr requires a value to be associated with the standard attribute. In case of user defined attributes, the attribute value is not regarded.</p>
  </dd>
  <dt>
    ne (<em>attrName</em>,<em>attrValue</em>)
  </dt>
  <dd>
    <p>The named attribute, when existing in the versions attribute buffer, must not have the given attribute value. When the attribute does not exist, everything is fine. If the attribute has multiple values, it is required, that none of the values matches the given <em>attrValue</em>.</p>
  </dd>
  <dt>
    {ge,gt,le,lt} (<em>attrName</em>,<em>attrValue</em>)
  </dt>
  <dd>
    <p>The named version attribute must have a value, that is greater or equal / greater than / less or equal / less than the given attribute value. The named attribute must exist in the versions attribute buffer, otherwise the version is eliminated from the hit set. For attributes with multiple values, only one of the values must meet the required property.</p>
  </dd>

</dl>
<p>The second class are predicates that do not operate on single version but rather on the complete hit set. They express relations between different versions in the hit set and base their selection on comparison of different versions. Usually, they are used to get a unique version binding, by ordering the hit set and selecting one of the extremes.</p>
<dl class='dl-vertical'>
  <dt>
    min (<em>attrName</em>)
  </dt>
  <dd>
    <p>Retain the version(s) with the lowest value for the named attribute in the hit set. String values are compared literally, others "naturally" (see the list of known attributes below for an explanation of that). Versions not carrying the named attribute or having no value associated with the attribute name are eliminated from the hit set.</p>
  </dd>
  <dt>
    max (<em>attrName</em>)
  </dt>
  <dd>
    <p>Retain the version(s) with the highest value for the named attribute in the hit set. String values are compared literally, others "naturally" (see the list of known attributes below for an explanation of that). Versions not carrying the named attribute or having no value associated with the attribute name are eliminated from the hit set.</p>
  </dd>

</dl>
<p>The next two predicate groups have no direct influence on the hit set. They can invalidate the hit set and cause the rule evaluation to go on with the next attribute expression, but they do never modify the hit set. These predicates are activated, when the evaluation of the attribute expression reaches them, i.e. when the hit set is not empty.</p>
<dl class='dl-vertical'>
  <dt>
    msg (<em>msgString</em>)
  </dt>
  <dd>
    <p>Print the given message to standard output and retain the current hit set.</p>
  </dd>
  <dt>
    cut (<em>msgString</em>)
  </dt>
  <dd>
    <p>Force the current rule binding to fail and print the given message to standard output. Printing is omitted, when the message string is empty. Rule processing is stopped immediately and the returned hit set is empty.</p>
  </dd>
  <dt>
    confirm (<em>msgString</em>,<em>expectedAnswer</em>)
  </dt>
  <dd>
    <p>Ask the user for confirmation to go on with the evaluation of the current attribute expression. The given message string is printed to standard output with the expected answer appended in square brackets. After that, user input is read. When the user confirms the expected answer (empty input) or his/her input matches the expected answer, evaluation of the current attribute expression continues. Otherwise, the current hit set is invalidated and processing goes on with the next attribute expression.</p>
  </dd>
  <dt>
    bindrule (<em>ruleName</em>)
  </dt>
  <dd>
    <p>Abort evaluation of current attribute expression and switch to another version bind rule. This predicate makes only sense as last predicate in an attribute expression, as following predicates will never be evaluated. Evaluation of the target rule (<em>ruleName</em>) happens as if the rule has been invoked directly, no influence on the initial hit set is taken. When the target rule fails, the evaluation algorithm switches back to the source rule and goes on with the next attribute expression.</p>
  </dd>

</dl>
<p>The last predicate group are external constraints. Their task is to influence the evaluation process by examining conditions outside the handled version history. Each of the following predicates has either a positive or a negative result. Positive results have no effect on the hit set and the evaluation process, while negative results invalidate the hit set and cause evaluation to go on with the next attribute expression.</p>
<dl class='dl-vertical'>
  <dt>
    exists (<em>name[binding]</em>)
  </dt>
  <dd>
    <p>Version binding with the given name (usually another one than the current target name) and the given version binding must lead to at least one version. The result is not required to be unique.</p>
  </dd>
  <dt>
    existsnot (<em>name[binding]</em>)
  </dt>
  <dd>
    <p>Version binding with the given name and rule must fail.</p>
  </dd>
  <dt>
    existsuniq (<em>name[binding]</em>)
  </dt>
  <dd>
    <p>Version binding with the given name and rule must lead to a unique selection.</p>
  </dd>
  <dt>
    condexpr (<em>program</em>,<em>expression</em>)
  </dt>
  <dd>
    <p>An external program, named in the program argument, is activated to evaluate the given expression. The expression string is written to the standard input of the external program. A zero result code is considered to be positive, all others negative.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBSOLETE PREDICATE NAMES</h2>
        <div class="sectioncontent">
<p>There are a number of known predicate names from former versions of the bind rules machinery. They are internally mapped to the new predicate names. These names are obsolete and should not be used any longer.</p><p><em>Obsolete name</em>	<em>mapped to</em> -	cut attr	eq attrex	hasattr attrge	ge attrgt	gt attrle	le attrlt	lt attrmax	max attrmin	min attrnot	ne condex	exists condnot	existsnot conduniq	existsuniq</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ATTRIBUTES</h2>
        <div class="sectioncontent">
<p>All predicates with effect on the contents of the hit set work on version attributes. These attributes are either standard attributes with a defined meaning or user defined attributes. The following is a list of attribute names recognized as standard attributes. All other names are considered to be user defined attributes.</p>
<dl class='dl-vertical'>
  <dt>
    alias
  </dt>
  <dd>
    <p>Version alias name (symbolic version identification name).</p>
  </dd>
  <dt>
    atime
  </dt>
  <dd>
    <p>The date of last access (read or write) to the versions contents.</p>
  </dd>
  <dt>
    author
  </dt>
  <dd>
    <p>The version author in the form <em>username@</em>domain<em>.</em></p>
  </dd>
  <dt>
    cachekey
  </dt>
  <dd>
    <p>A unique key for cached versions built from the creation date, the id of the creating process and a serial number (e.g. <em>740148430.18469.6</em>).</p>
  </dd>
  <dt>
    ctime
  </dt>
  <dd>
    <p>The date of the last status change. This date is updated, when an attribute is added or deleted, or an attribute value is changed.</p>
  </dd>
  <dt>
    generation
  </dt>
  <dd>
    <p>The generation number. The value for this attribute is plain numeric.</p>
  </dd>
  <dt>
    host
  </dt>
  <dd>
    <p>The name of the host from where the version was accessed. This attribute may have different values at one time, when the version is accessed from different hosts.</p>
  </dd>
  <dt>
    locker
  </dt>
  <dd>
    <p>The user who has set a lock on the concerned version. This attribute has an empty value, when no lock is active. The attribute value is given in the form <em>username@</em>domain<em>.</em></p>
  </dd>
  <dt>
    ltime
  </dt>
  <dd>
    <p>The date of last lock change (set or give up update lock). This has an empty value is empty, when there was never a lock set on the version.</p>
  </dd>
  <dt>
    mtime
  </dt>
  <dd>
    <p>The date of the last modification of the versions contents.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>The name (without suffix) of the version. For example <em>foo</em> for <em>foo.c</em>.</p>
  </dd>
  <dt>
    owner
  </dt>
  <dd>
    <p>The version owner in the form <em>username@</em>domain<em>.</em></p>
  </dd>
  <dt>
    revision
  </dt>
  <dd>
    <p>The revision number. As for generation, only numeric values are accepted.</p>
  </dd>
  <dt>
    size
  </dt>
  <dd>
    <p>The size of the versions contents in bytes.</p>
  </dd>
  <dt>
    status
  </dt>
  <dd>
    <p>The version status. This is one of busy, saved, proposed, published, accessed, or frozen.</p>
  </dd>
  <dt>
    stime
  </dt>
  <dd>
    <p>The save date. This attribute has an empty value for busy versions.</p>
  </dd>
  <dt>
    syspath
  </dt>
  <dd>
    <p>The absolute pathname through which the version was accessed. This attribute may have different values at one time, when the version is accessed by different pathnames (e.g. symbolic links).</p>
  </dd>
  <dt>
    type
  </dt>
  <dd>
    <p>The suffix part of the versions name. For example <em>fc</em> for <em>foo.c</em>.</p>
  </dd>
  <dt>
    version
  </dt>
  <dd>
    <p>The version number in the form <em>generation.revision</em>. A special value is the string busy instead of a version number. As busy versions have no version number, this value is used for identifying the busy version of a history.</p>
  </dd>

</dl>
<p>Some predicates (like <em>ge</em> or <em>max</em>) require an ordering relationship between attribute values. For user defined attributes, ordering bases on alphabetical (ASCII) comparison of the values. User defined attributes with multiple values are compared by their first values, if these are identical by their second values and so on. No value is considered smaller than any other value. For example</p>
<pre>
	attr1 = anton		attr2 = berta
	        berta	is smaller than	        anton
	        karl
</pre>
<p>but</p>
<pre>
	attr1 = anton		attr2 = anton
	        berta	is bigger than	        berta
	        karl

For some of the standard attributes listed above, we need special
regulations.
are ordered by generation number first and revision number secondary
(e.g. 1.2 is smaller than 2.1). Busy is smaller than
any version number.
are ordered by the version numbers (see above) of the identified
versions.
are ordered by simple text comparison. This has the effect that the
youngest cache key is considered the biggest.
are ordered in the sequence as listed above. Busy is the lowest
and frozen the highest state.
The order of user attributes bases on alphabetical comparison of the
string <em>username@</em>domain.
Time comparison assumes older dates to be smaller than newer ones.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPANSION</h2>
        <div class="sectioncontent">
<p>During evaluation of version bind rules, four different kinds of expansion are possible. These are  <em>parameter substitution</em>, <em>attribute expansion</em>, <em>external macro expansion</em> and <em>command substitution</em>. Expansion happens, when a magic pattern is found in the rule text, starting with either a dollar sign ($) or, in case of command substitution, with a backward quote character (`).</p><p>Generally, expansion in version bind rules happens only within patterns and within predicate arguments. Bind rule syntax or predicate names cannot be introduced by substituted strings. Expansions outside patterns and predicate arguments are ignored and usually lead to an error message.</p><h3>Parameter Substitution</h3>
<p>A parameter substitution string is usually introduced by the pattern $_ followed by the parameter name (an exception is $+ as shown below). The parameter name is optionally delimited by a dollar sign. This is necessary, when there is no whitespace character following. The parameter name may be any of the names specified in the rule head or one of the following predefined names.</p>
<dl class='dl-vertical'>
  <dt>
    $_rule$
  </dt>
  <dd>
    <p>The current rule name.</p>
  </dd>
  <dt>
    $_target$ or $+
  </dt>
  <dd>
    <p>The current target file name to be bound.</p>
  </dd>
  <dt>
    $_<em>parameter$</em>
  </dt>
  <dd>
    <p>Any other parameter.</p>
  </dd>

</dl>
<p>A parameter may have the same name as a citeable attribute (see below). In this case, the parameter citation hides the attribute citation. There is no way to cite the value of an attribute when there is an equally named rule parameter. The reserved names rule, target, and hits are not allowed as parameter names.</p>
<h3>Attribute Expansion</h3>
<p>An attribute expansion string looks exactly like a parameter substitution string. It is introduced by the pattern $_ followed by the attribute name which is optionally delimited by a dollar sign, when a non-whitespace character follows immediately. Attribute names may be built of any printable characters except '#'. Besides, it makes no sense to cite attributes with an equal sign ('=') in the attribute name, as the Attributed Filesystem (AtFS) doesn't allow this.</p><p>The value by which the attribute expansion string will be replaced depends on the current state of processing. This may cause different values to be inserted for the same citation in different processing states. Attribute expansion happens as late as possible, it is done right before the evaluation of the concerned pattern or predicate. With one exception, $_hits$, attribute expansions will only be substituted, if the current hit set cardinality is 1.</p>
<dl class='dl-vertical'>
  <dt>
    $_hits$ or $=
  </dt>
  <dd>
    <p>The number of versions satisfying the binding conditions expressed so far (the cardinality of the hit set). This value continuously changes during rule evaluation.</p>
  </dd>
  <dt>
    $_<em>attribute$</em>
  </dt>
  <dd>
    <p>The value of any attribute of a uniquely selected version.</p>
  </dd>

</dl>
<p>Attribute citations may be overloaded by parameter citations (see above).</p>
<h3>External Macro Expansion</h3>
<p>External macros are evaluated by an external macro processor. If no such macro processor is available, external macros remain unchanged. They have the form:</p>
<dl class='dl-vertical'>
  <dt>
    $C
  </dt>
  <dd>
    <p>where C is any printable non-whitespace character except '+', '=', '_', ':', or '#'</p>
  </dd>
  <dt>
    $(<em>macroName</em>) or ${<em>macroName</em>}
  </dt>
  <dd>
    <p>Macro names may not contain '#' characters. Other limitations may be imposed by the external macro definition and processing facility.</p>
  </dd>

</dl>

<h3>Command Substitution</h3>
<p>A command enclosed in back quotes occuring in a bind rule quotes will be replaced by its output. No modifications are done to the command output, hence it may contain newline characters.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LEXICAL STRUCTURE</h2>
        <div class="sectioncontent">
<p>There are some characters with special meaning when occurring in version bind rules. These are the syntactical characters colon (:), comma, (,), semicolon (;), period (.), and parentheses (( and )), the comment symbol (#), the dollar sign ($) or the back quote (`) introducing expansion strings ($), quotes (" and '), and the escape symbol (&#92;).</p><p>Comments are handled somewhat rigorously. A comment symbol (#) occurring anywhere in the rule name or rule body has effect as long as it is not escaped by a backslash (&#92;) character. Comments range from the comment symbol (inclusive) to the end of the line. Newline characters within comments may also be escaped by a backslash character, continuing the comment on the next line.</p><p>Nesting of parentheses and quotes is not supported.</p><p>The following is a list of lexical constraints for each part of a version bind rule.</p>
<dl class='dl-vertical'>
  <dt>
    Rule names and rule parameters
  </dt>
  <dd>
    <p>Rule names may consist of any printable non-whitespace character except colon and parentheses. The leftmost colon or opening parentheses delimits the rule name.</p><p>Rule parameter names follow the same lexical rule, but additionally must not contain comma characters, as this in the delimiter between parameters.</p>
  </dd>
  <dt>
    Patterns
  </dt>
  <dd>
    <p>In principle, name patterns may consist of any printable character. Comma and semicolon characters occurring in a name pattern must be escaped by a backslash character. A period occurring in a name pattern needs <em>not</em> to be escaped as long as it is not the last character (ignoring trailing whitespace) in the rule body. Period as last character is <em>always</em> considered to be end of rule sign. Name patterns may contain macro or parameter citations and command substitutions.</p>
  </dd>
  <dt>
    Predicates
  </dt>
  <dd>
    <p>Each predicate name must be one of the reserved names listed previously in this paper. Predicate arguments consist of any printable character including whitespace. Comma, parenthesis or quoting characters must be escaped. Any argument may be quoted by single or double quotes. Quoting exceeds line limits.</p><p>Predicate arguments may contain macro, attribute or parameter citations leaded by a dollar sign, or command substitutions enclosed in back quotes. When quoted in single quotes, dollar signs and back quotes occurring in a predicate argument are not taken by their special meaning and no citations happen. Double quotes do <em>not</em> hide citations.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TIPS, TRICKS, AND TRAPS</h2>
        <div class="sectioncontent">
<p><em>Why doesn't the bind rule select version xyz although I think it</em> should ?. An important facility to find an answer to this question is the <em>trace option</em> provided by the <a href="../man1/vbind.1.html"><strong>vbind</strong>(1)</a> command. It shows the evolution of the hit set during rule evaluation.</p><p>Typing errors in standard attribute names may lead to confusing situations. They cannot be recognized by the evaluation machinery, as any unknown attribute name is considered to be an user defined attribute.</p><p>A minus sign (-) as first character in an alternative is considered as part of the pattern and not as (old style) cut operator. Hence</p><p>	-; (- as pattern)</p><p>and</p><p>	,-; (default pattern followed by cut)</p><p>make a big difference. We recommend the use of cut() in any case. The short form (-) is supported only for compatibility with older versions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GRAMMAR</h2>
        <div class="sectioncontent">

<pre>
<em>bind_rule</em> ::= <em>bind_rule_head</em> <strong>:</strong>[<strong>-</strong>] <em>bind_rule_body</em> .

<em>bind_rule_head</em> ::= <em>rule_name</em> | <em>rule_name</em> <strong>(</strong> <em>rule_arg_list</em> <strong>)</strong> .

<em>rule_arg_list</em>: <em>rule_name</em> { <strong>,</strong> <em>arg_name</em> }* .

<em>bind_rule_body</em> ::= <em>attr_expression</em> { <strong>;</strong> <em>attr_expression</em>}* <strong>.</strong> .

<em>attr_expression</em> ::=	<em>name_pattern</em> { <strong>,</strong> <em>predicate</em> }* |
		 <em>predicate</em> { <strong>,</strong> <em>predicate</em> }* | .

<em>name_pattern</em> ::= { <em>&lt;any printable character or whitespace&gt;</em> }+

<em>predicate</em> ::=	<em>attr_value_predicate</em> <strong>(</strong> <em>attr_name</em> <strong>,</strong> <em>string</em> <strong>)</strong> |
	<em>attr_name_predicate</em> <strong>(</strong> <em>attr_name</em> <strong>)</strong> |
	<em>bind_rule_predicate</em> <strong>(</strong> <em>rule_name</em> <strong>)</strong> |
	<em>msg_predicate</em> <strong>(</strong> <em>string</em> <strong>)</strong> |
	<em>msg_answer_predicate</em> <strong>(</strong> <em>string</em> <strong>,</strong> <em>string</em> <strong>)</strong> |
	<em>cond_rule_predicate</em> <strong>(</strong> <em>string</em> <strong>,</strong> <em>bind_rule_head</em> <strong>)</strong> |
	<em>cond_expr_predicate</em> <strong>(</strong> <em>string</em> <strong>,</strong> <em>string</em> <strong>)</strong> |
	<em>cut_predicate</em>.

<em>attr_value_predicate</em> ::= eq<em> | ge</em> | gt<em> | le</em> | lt<em> | ne</em> .

<em>attr_name_predicate</em> ::= hasattr<em> | max</em> | min<em> .</em>

<em>bind_rule_predicate</em> ::= bindrule<em> .</em>

<em>msg_predicate</em> ::= cut<em> | msg</em> .

<em>msg_answer_predicate</em> ::= confirm<em> .</em>

<em>cond_rule_predicate</em> ::= exists<em> | existsnot</em> | existsuniq<em> .</em>

<em>cond_expr_predicate</em> ::= condexpr<em> .</em>

<em>cut_predicate</em> ::= <strong>-</strong> .

<em>attr_name</em> ::= 	arg_name | author<em> | atime</em> | ctime<em> | generation</em> |
		locker | ltime | mtime | owner |
		revision | size | state | stime | version .

<em>rule_name</em> ::= { <em>&lt;any printable character except colon and parentheses</em> }+ .

<em>arg_name</em> ::= { <em>&lt;any printable character except comma, colon and parentheses</em> }+ .

<em>string</em> ::= { <em>&lt;any printable character or whitespace&gt;</em> } .
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>$SHAPETOOLS/BindRules</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO bindrules&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/vbind.1.html"><strong>vbind</strong>(1)</a>, <a href="../man1/vadm.1.html"><strong>vadm</strong>(1)</a>, <a href="../man3/atnetwork.3.html"><strong>atnetwork</strong>(3)</a>, <a href="../man1/shape.1.html"><strong>shape</strong>(1)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Andreas.Lampen@cs.tu-berlin.de</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="bilibop.7.html"><span aria-hidden="true">&larr;</span> bilibop.7: Run debian gnu/linux from an external media</a></li>
   <li class="next"><a href="blosxom.7.html">blosxom.7: A lightweight yet feature-packed weblog <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

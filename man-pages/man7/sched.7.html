<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>sched: Overview of scheduling apis</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Overview of scheduling apis">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="sched (7) manual">
  <meta name="twitter:description" content="Overview of scheduling apis">
  <meta property="og:type" content="website" />
  <meta property="og:title" content="sched (7) manual" />
  <meta property="og:description" content="Overview of scheduling apis" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">sched<small> (7)</small></h1>
        <p class="lead">Overview of scheduling apis</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/sched.7.html">
      <span itemprop="name">sched: Overview of scheduling apis</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/man-pages/">
      <span itemprop="name">man-pages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/sched.7.html">
      <span itemprop="name">sched: Overview of scheduling apis</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<h3>API summary</h3>
<p>The Linux scheduling APIs are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><a href="../man2/sched_setscheduler.2.html"><strong>sched_setscheduler</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Set the scheduling policy and parameters of a specified thread.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_getscheduler.2.html"><strong>sched_getscheduler</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Return the scheduling policy of a specified thread.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_setparam.2.html"><strong>sched_setparam</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Set the scheduling parameters of a specified thread.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_getparam.2.html"><strong>sched_getparam</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Fetch the scheduling parameters of a specified thread.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_get_priority_max.2.html"><strong>sched_get_priority_max</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Return the maximum priority available in a specified scheduling policy.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_get_priority_min.2.html"><strong>sched_get_priority_min</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Return the minimum priority available in a specified scheduling policy.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_rr_get_interval.2.html"><strong>sched_rr_get_interval</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Fetch the quantum used for threads that are scheduled under the "round-robin" scheduling policy.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_yield.2.html"><strong>sched_yield</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Cause the caller to relinquish the CPU, so that some other thread be executed.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_setaffinity.2.html"><strong>sched_setaffinity</strong>(2)</a></p>
  </dt>
  <dd>
    <p>(Linux-specific) Set the CPU affinity of a specified thread.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_getaffinity.2.html"><strong>sched_getaffinity</strong>(2)</a></p>
  </dt>
  <dd>
    <p>(Linux-specific) Get the CPU affinity of a specified thread.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Set the scheduling policy and parameters of a specified thread. This (Linux-specific) system call provides a superset of the functionality of <a href="../man2/sched_setscheduler.2.html"><strong>sched_setscheduler</strong>(2)</a> and <a href="../man2/sched_setparam.2.html"><strong>sched_setparam</strong>(2)</a>.</p>
  </dd>
  <dt>
    <p><a href="../man2/sched_getattr.2.html"><strong>sched_getattr</strong>(2)</a></p>
  </dt>
  <dd>
    <p>Fetch the scheduling policy and parameters of a specified thread. This (Linux-specific) system call provides a superset of the functionality of <a href="../man2/sched_getscheduler.2.html"><strong>sched_getscheduler</strong>(2)</a> and <a href="../man2/sched_getparam.2.html"><strong>sched_getparam</strong>(2)</a>.</p>
  </dd>

</dl>

<h3>Scheduling policies</h3>
<p>The scheduler is the kernel component that decides which runnable thread will be executed by the CPU next. Each thread has an associated scheduling policy and a <em>static</em> scheduling priority, <em>sched_priority</em>. The scheduler makes its decisions based on knowledge of the scheduling policy and static priority of all threads on the system.</p><p>For threads scheduled under one of the normal scheduling policies (<strong>SCHED_OTHER</strong>, <strong>SCHED_IDLE</strong>, <strong>SCHED_BATCH</strong>), <em>sched_priority</em> is not used in scheduling decisions (it must be specified as 0).</p><p>Processes scheduled under one of the real-time policies (<strong>SCHED_FIFO</strong>, <strong>SCHED_RR</strong>) have a <em>sched_priority</em> value in the range 1 (low) to 99 (high). (As the numbers imply, real-time threads always have higher priority than normal threads.) Note well: POSIX.1 requires an implementation to support only a minimum 32 distinct priority levels for the real-time policies, and some systems supply just this minimum. Portable programs should use <a href="../man2/sched_get_priority_min.2.html"><strong>sched_get_priority_min</strong>(2)</a> and <a href="../man2/sched_get_priority_max.2.html"><strong>sched_get_priority_max</strong>(2)</a> to find the range of priorities supported for a particular policy.</p><p>Conceptually, the scheduler maintains a list of runnable threads for each possible <em>sched_priority</em> value. In order to determine which thread runs next, the scheduler looks for the nonempty list with the highest static priority and selects the thread at the head of this list.</p><p>A thread's scheduling policy determines where it will be inserted into the list of threads with equal static priority and how it will move inside this list.</p><p>All scheduling is preemptive: if a thread with a higher static priority becomes ready to run, the currently running thread will be preempted and returned to the wait list for its static priority level. The scheduling policy determines the ordering only within the list of runnable threads with equal static priority.</p>
<h3>SCHED_FIFO: First in-first out scheduling</h3>
<p><strong>SCHED_FIFO</strong> can be used only with static priorities higher than 0, which means that when a <strong>SCHED_FIFO</strong> threads becomes runnable, it will always immediately preempt any currently running <strong>SCHED_OTHER</strong>, <strong>SCHED_BATCH</strong>, or <strong>SCHED_IDLE</strong> thread. <strong>SCHED_FIFO</strong> is a simple scheduling algorithm without time slicing. For threads scheduled under the <strong>SCHED_FIFO</strong> policy, the following rules apply:</p><ul>
<li><p>A <strong>SCHED_FIFO</strong> thread that has been preempted by another thread of higher priority will stay at the head of the list for its priority and will resume execution as soon as all threads of higher priority are blocked again.</p></li><li><p>When a <strong>SCHED_FIFO</strong> thread becomes runnable, it will be inserted at the end of the list for its priority.</p></li><li><p>A call to <a href="../man2/sched_setscheduler.2.html"><strong>sched_setscheduler</strong>(2)</a>, <a href="../man2/sched_setparam.2.html"><strong>sched_setparam</strong>(2)</a>, or <a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a> will put the <strong>SCHED_FIFO</strong> (or <strong>SCHED_RR</strong>) thread identified by <em>pid</em> at the start of the list if it was runnable. As a consequence, it may preempt the currently running thread if it has the same priority. (POSIX.1 specifies that the thread should go to the end of the list.)</p></li><li><p>A thread calling <a href="../man2/sched_yield.2.html"><strong>sched_yield</strong>(2)</a> will be put at the end of the list.</p></li>
</ul><p>No other events will move a thread scheduled under the <strong>SCHED_FIFO</strong> policy in the wait list of runnable threads with equal static priority.</p><p>A <strong>SCHED_FIFO</strong> thread runs until either it is blocked by an I/O request, it is preempted by a higher priority thread, or it calls <a href="../man2/sched_yield.2.html"><strong>sched_yield</strong>(2)</a>.</p>
<h3>SCHED_RR: Round-robin scheduling</h3>
<p><strong>SCHED_RR</strong> is a simple enhancement of <strong>SCHED_FIFO</strong>. Everything described above for <strong>SCHED_FIFO</strong> also applies to <strong>SCHED_RR</strong>, except that each thread is allowed to run only for a maximum time quantum. If a <strong>SCHED_RR</strong> thread has been running for a time period equal to or longer than the time quantum, it will be put at the end of the list for its priority. A <strong>SCHED_RR</strong> thread that has been preempted by a higher priority thread and subsequently resumes execution as a running thread will complete the unexpired portion of its round-robin time quantum. The length of the time quantum can be retrieved using <a href="../man2/sched_rr_get_interval.2.html"><strong>sched_rr_get_interval</strong>(2)</a>.</p>
<h3>SCHED_DEADLINE: Sporadic task model deadline scheduling</h3>
<p>Since version 3.14, Linux provides a deadline scheduling policy (<strong>SCHED_DEADLINE</strong>). This policy is currently implemented using GEDF (Global Earliest Deadline First) in conjunction with CBS (Constant Bandwidth Server). To set and fetch this policy and associated attributes, one must use the Linux-specific <a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a> and <a href="../man2/sched_getattr.2.html"><strong>sched_getattr</strong>(2)</a> system calls.</p><p>A sporadic task is one that has a sequence of jobs, where each job is activated at most once per period. Each job also has a <em>relative deadline</em>, before which it should finish execution, and a <em>computation time</em>, which is the CPU time necessary for executing the job. The moment when a task wakes up because a new job has to be executed is called the <em>arrival time</em> (also referred to as the request time or release time). The <em>start time</em> is the time at which a task starts its execution. The <em>absolute deadline</em> is thus obtained by adding the relative deadline to the arrival time.</p><p>The following diagram clarifies these terms:</p>
<pre>
arrival/wakeup                    absolute deadline
     |    start time                    |
     |        |                         |
     v        v                         v
-----x--------xooooooooooooooooo--------x--------x---
              |&lt;- comp. time -&gt;|
     |&lt;------- relative deadline ------&gt;|
     |&lt;-------------- period -------------------&gt;|
</pre>
<p>When setting a <strong>SCHED_DEADLINE</strong> policy for a thread using <a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a>, one can specify three parameters: <em>Runtime</em>, <em>Deadline</em>, and <em>Period</em>. These parameters do not necessarily correspond to the aforementioned terms: usual practice is to set Runtime to something bigger than the average computation time (or worst-case execution time for hard real-time tasks), Deadline to the relative deadline, and Period to the period of the task. Thus, for <strong>SCHED_DEADLINE</strong> scheduling, we have:</p>
<pre>
arrival/wakeup                    absolute deadline
     |    start time                    |
     |        |                         |
     v        v                         v
-----x--------xooooooooooooooooo--------x--------x---
              |&lt;-- Runtime -------&gt;|
     |&lt;----------- Deadline -----------&gt;|
     |&lt;-------------- Period -------------------&gt;|
</pre>
<p>The three deadline-scheduling parameters correspond to the <em>sched_runtime</em>, <em>sched_deadline</em>, and <em>sched_period</em> fields of the <em>sched_attr</em> structure; see <a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a>. These fields express values in nanoseconds. If <em>sched_period</em> is specified as 0, then it is made the same as <em>sched_deadline</em>.</p><p>The kernel requires that:</p>
<pre>
    sched_runtime &lt;= sched_deadline &lt;= sched_period
</pre>
<p>In addition, under the current implementation, all of the parameter values must be at least 1024 (i.e., just over one microsecond, which is the resolution of the implementation), and less than 2^63. If any of these checks fails, <a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a> fails with the error <strong>EINVAL</strong>.</p><p>The CBS guarantees non-interference between tasks, by throttling threads that attempt to over-run their specified Runtime.</p><p>To ensure deadline scheduling guarantees, the kernel must prevent situations where the set of <strong>SCHED_DEADLINE</strong> threads is not feasible (schedulable) within the given constraints. The kernel thus performs an admittance test when setting or changing <strong>SCHED_DEADLINE</strong> policy and attributes. This admission test calculates whether the change is feasible; if it is not, <a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a> fails with the error <strong>EBUSY</strong>.</p><p>For example, it is required (but not necessarily sufficient) for the total utilization to be less than or equal to the total number of CPUs available, where, since each thread can maximally run for Runtime per Period, that thread's utilization is its Runtime divided by its Period.</p><p>In order to fulfil the guarantees that are made when a thread is admitted to the <strong>SCHED_DEADLINE</strong> policy, <strong>SCHED_DEADLINE</strong> threads are the highest priority (user controllable) threads in the system; if any <strong>SCHED_DEADLINE</strong> thread is runnable, it will preempt any thread scheduled under one of the other policies.</p><p>A call to <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a> by a thread scheduled under the <strong>SCHED_DEADLINE</strong> policy will fail with the error <strong>EAGAIN</strong>, unless the thread has its reset-on-fork flag set (see below).</p><p>A <strong>SCHED_DEADLINE</strong> thread that calls <a href="../man2/sched_yield.2.html"><strong>sched_yield</strong>(2)</a> will yield the current job and wait for a new period to begin.</p>
<h3>SCHED_OTHER: Default Linux time-sharing scheduling</h3>
<p><strong>SCHED_OTHER</strong> can be used at only static priority 0. <strong>SCHED_OTHER</strong> is the standard Linux time-sharing scheduler that is intended for all threads that do not require the special real-time mechanisms. The thread to run is chosen from the static priority 0 list based on a <em>dynamic</em> priority that is determined only inside this list. The dynamic priority is based on the nice value (set by <a href="../man2/nice.2.html"><strong>nice</strong>(2)</a>, <a href="../man2/setpriority.2.html"><strong>setpriority</strong>(2)</a>, or <a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a>) and increased for each time quantum the thread is ready to run, but denied to run by the scheduler. This ensures fair progress among all <strong>SCHED_OTHER</strong> threads.</p>
<h3>SCHED_BATCH: Scheduling batch processes</h3>
<p>(Since Linux 2.6.16.) <strong>SCHED_BATCH</strong> can be used only at static priority 0. This policy is similar to <strong>SCHED_OTHER</strong> in that it schedules the thread according to its dynamic priority (based on the nice value). The difference is that this policy will cause the scheduler to always assume that the thread is CPU-intensive. Consequently, the scheduler will apply a small scheduling penalty with respect to wakeup behavior, so that this thread is mildly disfavored in scheduling decisions.</p><p>This policy is useful for workloads that are noninteractive, but do not want to lower their nice value, and for workloads that want a deterministic scheduling policy without interactivity causing extra preemptions (between the workload's tasks).</p>
<h3>SCHED_IDLE: Scheduling very low priority jobs</h3>
<p>(Since Linux 2.6.23.) <strong>SCHED_IDLE</strong> can be used only at static priority 0; the process nice value has no influence for this policy.</p><p>This policy is intended for running jobs at extremely low priority (lower even than a +19 nice value with the <strong>SCHED_OTHER</strong> or <strong>SCHED_BATCH</strong> policies).</p>
<h3>Resetting scheduling policy for child processes</h3>
<p>Each thread has a reset-on-fork scheduling flag. When this flag is set, children created by <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a> do not inherit privileged scheduling policies. The reset-on-fork flag can be set by either:</p><ul>
<li><p>ORing the <strong>SCHED_RESET_ON_FORK</strong> flag into the <em>policy</em> argument when calling <a href="../man2/sched_setscheduler.2.html"><strong>sched_setscheduler</strong>(2)</a> (since Linux 2.6.32); or</p></li><li><p>specifying the <strong>SCHED_FLAG_RESET_ON_FORK</strong> flag in <em>attr.sched_flags</em> when calling <a href="../man2/sched_setattr.2.html"><strong>sched_setattr</strong>(2)</a>.</p></li>
</ul><p>Note that the constants used with these two APIs have different names. The state of the reset-on-fork flag can analogously be retrieved using <a href="../man2/sched_getscheduler.2.html"><strong>sched_getscheduler</strong>(2)</a> and <a href="../man2/sched_getattr.2.html"><strong>sched_getattr</strong>(2)</a>.</p><p>The reset-on-fork feature is intended for media-playback applications, and can be used to prevent applications evading the <strong>RLIMIT_RTTIME</strong> resource limit (see <a href="../man2/getrlimit.2.html"><strong>getrlimit</strong>(2)</a>) by creating multiple child processes.</p><p>More precisely, if the reset-on-fork flag is set, the following rules apply for subsequently created children:</p><ul>
<li><p>If the calling thread has a scheduling policy of <strong>SCHED_FIFO</strong> or <strong>SCHED_RR</strong>, the policy is reset to <strong>SCHED_OTHER</strong> in child processes.</p></li><li><p>If the calling process has a negative nice value, the nice value is reset to zero in child processes.</p></li>
</ul><p>After the reset-on-fork flag has been enabled, it can be reset only if the thread has the <strong>CAP_SYS_NICE</strong> capability. This flag is disabled in child processes created by <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a>.</p>
<h3>Privileges and resource limits</h3>
<p>In Linux kernels before 2.6.12, only privileged (<strong>CAP_SYS_NICE</strong>) threads can set a nonzero static priority (i.e., set a real-time scheduling policy). The only change that an unprivileged thread can make is to set the <strong>SCHED_OTHER</strong> policy, and this can be done only if the effective user ID of the caller matches the real or effective user ID of the target thread (i.e., the thread specified by <em>pid</em>) whose policy is being changed.</p><p>A thread must be privileged (<strong>CAP_SYS_NICE</strong>) in order to set or modify a <strong>SCHED_DEADLINE</strong> policy.</p><p>Since Linux 2.6.12, the <strong>RLIMIT_RTPRIO</strong> resource limit defines a ceiling on an unprivileged thread's static priority for the <strong>SCHED_RR</strong> and <strong>SCHED_FIFO</strong> policies. The rules for changing scheduling policy and priority are as follows:</p><ul>
<li><p>If an unprivileged thread has a nonzero <strong>RLIMIT_RTPRIO</strong> soft limit, then it can change its scheduling policy and priority, subject to the restriction that the priority cannot be set to a value higher than the maximum of its current priority and its <strong>RLIMIT_RTPRIO</strong> soft limit.</p></li><li><p>If the <strong>RLIMIT_RTPRIO</strong> soft limit is 0, then the only permitted changes are to lower the priority, or to switch to a non-real-time policy.</p></li><li><p>Subject to the same rules, another unprivileged thread can also make these changes, as long as the effective user ID of the thread making the change matches the real or effective user ID of the target thread.</p></li><li><p>Special rules apply for the <strong>SCHED_IDLE</strong> policy. In Linux kernels before 2.6.39, an unprivileged thread operating under this policy cannot change its policy, regardless of the value of its <strong>RLIMIT_RTPRIO</strong> resource limit. In Linux kernels since 2.6.39, an unprivileged thread can switch to either the <strong>SCHED_BATCH</strong> or the <strong>SCHED_OTHER</strong> policy so long as its nice value falls within the range permitted by its <strong>RLIMIT_NICE</strong> resource limit (see <a href="../man2/getrlimit.2.html"><strong>getrlimit</strong>(2)</a>).</p></li>
</ul><p>Privileged (<strong>CAP_SYS_NICE</strong>) threads ignore the <strong>RLIMIT_RTPRIO</strong> limit; as with older kernels, they can make arbitrary changes to scheduling policy and priority. See <a href="../man2/getrlimit.2.html"><strong>getrlimit</strong>(2)</a> for further information on <strong>RLIMIT_RTPRIO</strong>.</p>
<h3>Limiting the CPU usage of real-time and deadline processes</h3>
<p>A nonblocking infinite loop in a thread scheduled under the <strong>SCHED_FIFO</strong>, <strong>SCHED_RR</strong>, or <strong>SCHED_DEADLINE</strong> policy will block all threads with lower priority forever. Prior to Linux 2.6.25, the only way of preventing a runaway real-time process from freezing the system was to run (at the console) a shell scheduled under a higher static priority than the tested application. This allows an emergency kill of tested real-time applications that do not block or terminate as expected.</p><p>Since Linux 2.6.25, there are other techniques for dealing with runaway real-time and deadline processes. One of these is to use the <strong>RLIMIT_RTTIME</strong> resource limit to set a ceiling on the CPU time that a real-time process may consume. See <a href="../man2/getrlimit.2.html"><strong>getrlimit</strong>(2)</a> for details.</p><p>Since version 2.6.25, Linux also provides two <em>/proc</em> files that can be used to reserve a certain amount of CPU time to be used by non-real-time processes. Reserving some CPU time in this fashion allows some CPU time to be allocated to (say) a root shell that can be used to kill a runaway process. Both of these files specify time values in microseconds:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>/proc/sys/kernel/sched_rt_period_us</em></p>
  </dt>
  <dd>
    <p>This file specifies a scheduling period that is equivalent to 100% CPU bandwidth. The value in this file can range from 1 to <strong>INT_MAX</strong>, giving an operating range of 1 microsecond to around 35 minutes. The default value in this file is 1,000,000 (1 second).</p>
  </dd>
  <dt>
    <p><em>/proc/sys/kernel/sched_rt_runtime_us</em></p>
  </dt>
  <dd>
    <p>The value in this file specifies how much of the "period" time can be used by all real-time and deadline scheduled processes on the system. The value in this file can range from -1 to <strong>INT_MAX</strong>-1. Specifying -1 makes the runtime the same as the period; that is, no CPU time is set aside for non-real-time processes (which was the Linux behavior before kernel 2.6.25). The default value in this file is 950,000 (0.95 seconds), meaning that 5% of the CPU time is reserved for processes that don't run under a real-time or deadline scheduling policy.</p>
  </dd>

</dl>

<h3>Response time</h3>
<p>A blocked high priority thread waiting for I/O has a certain response time before it is scheduled again. The device driver writer can greatly reduce this response time by using a "slow interrupt" interrupt handler.</p>
<h3>Miscellaneous</h3>
<p>Child processes inherit the scheduling policy and parameters across a <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a>. The scheduling policy and parameters are preserved across <a href="../man2/execve.2.html"><strong>execve</strong>(2)</a>.</p><p>Memory locking is usually needed for real-time processes to avoid paging delays; this can be done with <a href="../man2/mlock.2.html"><strong>mlock</strong>(2)</a> or <a href="../man2/mlockall.2.html"><strong>mlockall</strong>(2)</a>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>Originally, Standard Linux was intended as a general-purpose operating system being able to handle background processes, interactive applications, and less demanding real-time applications (applications that need to usually meet timing deadlines). Although the Linux kernel 2.6 allowed for kernel preemption and the newly introduced O(1) scheduler ensures that the time needed to schedule is fixed and deterministic irrespective of the number of active tasks, true real-time computing was not possible up to kernel version 2.6.17.</p><h3>Real-time features in the mainline Linux kernel</h3>
<p>From kernel version 2.6.18 onward, however, Linux is gradually becoming equipped with real-time capabilities, most of which are derived from the former <em>realtime-preempt</em> patches developed by Ingo Molnar, Thomas Gleixner, Steven Rostedt, and others. Until the patches have been completely merged into the mainline kernel, they must be installed to achieve the best real-time performance. These patches are named:</p>
<pre>
patch-<em>kernelversion</em>-rt<em>patchversion</em>
</pre>
<p>and can be downloaded from</p><p>Without the patches and prior to their full inclusion into the mainline kernel, the kernel configuration offers only the three preemption classes <strong>CONFIG_PREEMPT_NONE</strong>, <strong>CONFIG_PREEMPT_VOLUNTARY</strong>, and <strong>CONFIG_PREEMPT_DESKTOP</strong> which respectively provide no, some, and considerable reduction of the worst-case scheduling latency.</p><p>With the patches applied or after their full inclusion into the mainline kernel, the additional configuration item <strong>CONFIG_PREEMPT_RT</strong> becomes available. If this is selected, Linux is transformed into a regular real-time operating system. The FIFO and RR scheduling policies are then used to run a thread with true real-time priority and a minimum worst-case scheduling latency.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO sched&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/chrt.1.html"><strong>chrt</strong>(1)</a>, <a href="../man1/taskset.1.html"><strong>taskset</strong>(1)</a>, <a href="../man2/getpriority.2.html"><strong>getpriority</strong>(2)</a>, <a href="../man2/mlock.2.html"><strong>mlock</strong>(2)</a>, <a href="../man2/mlockall.2.html"><strong>mlockall</strong>(2)</a>, <a href="../man2/munlock.2.html"><strong>munlock</strong>(2)</a>, <a href="../man2/munlockall.2.html"><strong>munlockall</strong>(2)</a>, <a href="../man2/nice.2.html"><strong>nice</strong>(2)</a>, <a href="../man2/sched_get_priority_max.2.html"><strong>sched_get_priority_max</strong>(2)</a>, <a href="../man2/sched_get_priority_min.2.html"><strong>sched_get_priority_min</strong>(2)</a>, <a href="../man2/sched_getscheduler.2.html"><strong>sched_getscheduler</strong>(2)</a>, <a href="../man2/sched_getaffinity.2.html"><strong>sched_getaffinity</strong>(2)</a>, <a href="../man2/sched_getparam.2.html"><strong>sched_getparam</strong>(2)</a>, <a href="../man2/sched_rr_get_interval.2.html"><strong>sched_rr_get_interval</strong>(2)</a>, <a href="../man2/sched_setaffinity.2.html"><strong>sched_setaffinity</strong>(2)</a>, <a href="../man2/sched_setscheduler.2.html"><strong>sched_setscheduler</strong>(2)</a>, <a href="../man2/sched_setparam.2.html"><strong>sched_setparam</strong>(2)</a>, <a href="../man2/sched_yield.2.html"><strong>sched_yield</strong>(2)</a>, <a href="../man2/setpriority.2.html"><strong>setpriority</strong>(2)</a>, <a href="../man3/pthread_getaffinity_np.3.html"><strong>pthread_getaffinity_np</strong>(3)</a>, <a href="../man3/pthread_setaffinity_np.3.html"><strong>pthread_setaffinity_np</strong>(3)</a>, <a href="../man3/sched_getcpu.3.html"><strong>sched_getcpu</strong>(3)</a>, <a href="../man7/capabilities.7.html"><strong>capabilities</strong>(7)</a>, <a href="../man7/cpuset.7.html"><strong>cpuset</strong>(7)</a></p><p><em>Programming for the real world - POSIX.4</em> by Bill O. Gallmeister, O'Reilly & Associates, Inc., ISBN 1-56592-074-0.</p><p>The Linux kernel source files <em>Documentation/scheduler/sched-deadline.txt</em>, <em>Documentation/scheduler/sched-rt-group.txt</em>, <em>Documentation/scheduler/sched-design-CFS.txt</em>, and <em>Documentation/scheduler/sched-nice-design.txt</em></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="rtnetlink.7.html"><span aria-hidden="true">&larr;</span> rtnetlink.7: Linux ipv4 routing socket</a></li>
   <li class="next"><a href="sctp.7.html">sctp.7: Sctp protocol. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

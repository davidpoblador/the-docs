<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CREATE_AGGREGATE: Define a new aggregate function</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Define a new aggregate function">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="CREATE_AGGREGATE (7) manual">
  <meta name="twitter:description" content="Define a new aggregate function">
  <meta name="twitter:image" content="https://www.carta.tech/images/postgresql-client-9.4-CREATE_AGGREGATE-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/CREATE_AGGREGATE.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="CREATE_AGGREGATE (7) manual" />
  <meta property="og:description" content="Define a new aggregate function" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/postgresql-client-9.4-CREATE_AGGREGATE-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">CREATE_AGGREGATE<small> (7)</small></h1>
        <p class="lead">Define a new aggregate function</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/CREATE_AGGREGATE.7.html">
      <span itemprop="name">CREATE_AGGREGATE: Define a new aggregate function</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/postgresql-client-9.4/">
      <span itemprop="name">postgresql-client-9.4</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/CREATE_AGGREGATE.7.html">
      <span itemprop="name">CREATE_AGGREGATE: Define a new aggregate function</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
CREATE AGGREGATE <em>name</em> ( [ <em>argmode</em> ] [ <em>argname</em> ] <em>arg_data_type</em> [ , ... ] ) (
    SFUNC = <em>sfunc</em>,
    STYPE = <em>state_data_type</em>
    [ , SSPACE = <em>state_data_size</em> ]
    [ , FINALFUNC = <em>ffunc</em> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <em>initial_condition</em> ]
    [ , MSFUNC = <em>msfunc</em> ]
    [ , MINVFUNC = <em>minvfunc</em> ]
    [ , MSTYPE = <em>mstate_data_type</em> ]
    [ , MSSPACE = <em>mstate_data_size</em> ]
    [ , MFINALFUNC = <em>mffunc</em> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <em>minitial_condition</em> ]
    [ , SORTOP = <em>sort_operator</em> ]
)

CREATE AGGREGATE <em>name</em> ( [ [ <em>argmode</em> ] [ <em>argname</em> ] <em>arg_data_type</em> [ , ... ] ]
                        ORDER BY [ <em>argmode</em> ] [ <em>argname</em> ] <em>arg_data_type</em> [ , ... ] ) (
    SFUNC = <em>sfunc</em>,
    STYPE = <em>state_data_type</em>
    [ , SSPACE = <em>state_data_size</em> ]
    [ , FINALFUNC = <em>ffunc</em> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <em>initial_condition</em> ]
    [ , HYPOTHETICAL ]
)

or the old syntax

CREATE AGGREGATE <em>name</em> (
    BASETYPE = <em>base_type</em>,
    SFUNC = <em>sfunc</em>,
    STYPE = <em>state_data_type</em>
    [ , SSPACE = <em>state_data_size</em> ]
    [ , FINALFUNC = <em>ffunc</em> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <em>initial_condition</em> ]
    [ , MSFUNC = <em>msfunc</em> ]
    [ , MINVFUNC = <em>minvfunc</em> ]
    [ , MSTYPE = <em>mstate_data_type</em> ]
    [ , MSSPACE = <em>mstate_data_size</em> ]
    [ , MFINALFUNC = <em>mffunc</em> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <em>minitial_condition</em> ]
    [ , SORTOP = <em>sort_operator</em> ]
)
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>CREATE AGGREGATE</strong> defines a new aggregate function. Some basic and commonly-used aggregate functions are included with the distribution; they are documented in Section 9.20, &ldquo;Aggregate Functions&rdquo;, in the documentation. If one defines new types or needs an aggregate function not already provided, then <strong>CREATE AGGREGATE</strong> can be used to provide the desired features.</p><p>If a schema name is given (for example, CREATE AGGREGATE myschema.myagg ...) then the aggregate function is created in the specified schema. Otherwise it is created in the current schema.</p><p>An aggregate function is identified by its name and input data type(s). Two aggregates in the same schema can have the same name if they operate on different input types. The name and input data type(s) of an aggregate must also be distinct from the name and input data type(s) of every ordinary function in the same schema. This behavior is identical to overloading of ordinary function names (see CREATE FUNCTION (<a href="../man7/CREATE_FUNCTION.7.html"><strong>CREATE_FUNCTION</strong>(7)</a>)).</p><p>A simple aggregate function is made from one or two ordinary functions: a state transition function <em>sfunc</em>, and an optional final calculation function <em>ffunc</em>. These are used as follows:</p>
<pre>
<em>sfunc</em>( internal-state, next-data-values ) ---&gt; next-internal-state
<em>ffunc</em>( internal-state ) ---&gt; aggregate-value
</pre>
<p>PostgreSQL creates a temporary variable of data type <em>stype</em> to hold the current internal state of the aggregate. At each input row, the aggregate argument value(s) are calculated and the state transition function is invoked with the current state value and the new argument value(s) to calculate a new internal state value. After all the rows have been processed, the final function is invoked once to calculate the aggregate&apos;s return value. If there is no final function then the ending state value is returned as-is.</p><p>An aggregate function can provide an initial condition, that is, an initial value for the internal state value. This is specified and stored in the database as a value of type text, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out null.</p><p>If the state transition function is declared &ldquo;strict&rdquo;, then it cannot be called with null inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is null, then at the first row with all-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at each subsequent row with all-nonnull input values. This is handy for implementing aggregates like <strong>max</strong>. Note that this behavior is only available when <em>state_data_type</em> is the same as the first <em>arg_data_type</em>. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function.</p><p>If the state transition function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null state values for itself. This allows the aggregate author to have full control over the aggregate&apos;s handling of null values.</p><p>If the final function is declared &ldquo;strict&rdquo;, then it will not be called when the ending state value is null; instead a null result will be returned automatically. (Of course this is just the normal behavior of strict functions.) In any case the final function has the option of returning a null value. For example, the final function for <strong>avg</strong> returns null when it sees there were zero input rows.</p><p>Sometimes it is useful to declare the final function as taking not just the state value, but extra parameters corresponding to the aggregate&apos;s input values. The main reason for doing this is if the final function is polymorphic and the state value&apos;s data type would be inadequate to pin down the result type. These extra parameters are always passed as NULL (and so the final function must not be strict when the FINALFUNC_EXTRA option is used), but nonetheless they are valid parameters. The final function could for example make use of <strong>get_fn_expr_argtype</strong> to identify the actual argument type in the current call.</p><p>An aggregate can optionally support moving-aggregate mode, as described in Section 35.10.1, &ldquo;Moving-Aggregate Mode&rdquo;, in the documentation. This requires specifying the MSFUNC, MINVFUNC, and MSTYPE parameters, and optionally the MSPACE, MFINALFUNC, MFINALFUNC_EXTRA, and MINITCOND parameters. Except for MINVFUNC, these parameters work like the corresponding simple-aggregate parameters without M; they define a separate implementation of the aggregate that includes an inverse transition function.</p><p>The syntax with ORDER BY in the parameter list creates a special type of aggregate called an ordered-set aggregate; or if HYPOTHETICAL is specified, then a hypothetical-set aggregate is created. These aggregates operate over groups of sorted values in order-dependent ways, so that specification of an input sort order is an essential part of a call. Also, they can have direct arguments, which are arguments that are evaluated only once per aggregation rather than once per input row. Hypothetical-set aggregates are a subclass of ordered-set aggregates in which some of the direct arguments are required to match, in number and data types, the aggregated argument columns. This allows the values of those direct arguments to be added to the collection of aggregate-input rows as an additional &ldquo;hypothetical&rdquo; row.</p><p>Aggregates that behave like <strong>MIN</strong> or <strong>MAX</strong> can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a sort operator. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</p>
<pre>
SELECT agg(col) FROM tab;
</pre>
<p>must be equivalent to:</p>
<pre>
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</pre>
<p>Further assumptions are that the aggregate ignores null inputs, and that it delivers a null result if and only if there were no non-null inputs. Ordinarily, a data type&apos;s &lt; operator is the proper sort operator for <strong>MIN</strong>, and &gt; is the proper sort operator for <strong>MAX</strong>. Note that the optimization will never actually take effect unless the specified operator is the &ldquo;less than&rdquo; or &ldquo;greater than&rdquo; strategy member of a B-tree index operator class.</p><p>To be able to create an aggregate function, you must have USAGE privilege on the argument types, the state type(s), and the return type, as well as EXECUTE privilege on the transition and final functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARAMETERS</h2>
        <div class="sectioncontent">
<p><em>name</em></p><p>The name (optionally schema-qualified) of the aggregate function to create.</p><p><em>argmode</em></p><p>The mode of an argument: IN or VARIADIC. (Aggregate functions do not support OUT arguments.) If omitted, the default is IN. Only the last argument can be marked VARIADIC.</p><p><em>argname</em></p><p>The name of an argument. This is currently only useful for documentation purposes. If omitted, the argument has no name.</p><p><em>arg_data_type</em></p><p>An input data type on which this aggregate function operates. To create a zero-argument aggregate function, write * in place of the list of argument specifications. (An example of such an aggregate is <strong>count(*)</strong>.)</p><p><em>base_type</em></p><p>In the old syntax for <strong>CREATE AGGREGATE</strong>, the input data type is specified by a basetype parameter rather than being written next to the aggregate name. Note that this syntax allows only one input parameter. To define a zero-argument aggregate function with this syntax, specify the basetype as "ANY" (not *). Ordered-set aggregates cannot be defined with the old syntax.</p><p><em>sfunc</em></p><p>The name of the state transition function to be called for each input row. For a normal <em>N</em>-argument aggregate function, the <em>sfunc</em> must take <em>N</em>+1 arguments, the first being of type <em>state_data_type</em> and the rest matching the declared input data type(s) of the aggregate. The function must return a value of type <em>state_data_type</em>. This function takes the current state value and the current input data value(s), and returns the next state value.</p><p>For ordered-set (including hypothetical-set) aggregates, the state transition function receives only the current state value and the aggregated arguments, not the direct arguments. Otherwise it is the same.</p><p><em>state_data_type</em></p><p>The data type for the aggregate&apos;s state value.</p><p><em>state_data_size</em></p><p>The approximate average size (in bytes) of the aggregate&apos;s state value. If this parameter is omitted or is zero, a default estimate is used based on the <em>state_data_type</em>. The planner uses this value to estimate the memory required for a grouped aggregate query. The planner will consider using hash aggregation for such a query only if the hash table is estimated to fit in work_mem; therefore, large values of this parameter discourage use of hash aggregation.</p><p><em>ffunc</em></p><p>The name of the final function called to compute the aggregate&apos;s result after all input rows have been traversed. For a normal aggregate, this function must take a single argument of type <em>state_data_type</em>. The return data type of the aggregate is defined as the return type of this function. If <em>ffunc</em> is not specified, then the ending state value is used as the aggregate&apos;s result, and the return type is <em>state_data_type</em>.</p><p>For ordered-set (including hypothetical-set) aggregates, the final function receives not only the final state value, but also the values of all the direct arguments.</p><p>If FINALFUNC_EXTRA is specified, then in addition to the final state value and any direct arguments, the final function receives extra NULL values corresponding to the aggregate&apos;s regular (aggregated) arguments. This is mainly useful to allow correct resolution of the aggregate result type when a polymorphic aggregate is being defined.</p><p><em>initial_condition</em></p><p>The initial setting for the state value. This must be a string constant in the form accepted for the data type <em>state_data_type</em>. If not specified, the state value starts out null.</p><p><em>msfunc</em></p><p>The name of the forward state transition function to be called for each input row in moving-aggregate mode. This is exactly like the regular transition function, except that its first argument and result are of type <em>mstate_data_type</em>, which might be different from <em>state_data_type</em>.</p><p><em>minvfunc</em></p><p>The name of the inverse state transition function to be used in moving-aggregate mode. This function has the same argument and result types as <em>msfunc</em>, but it is used to remove a value from the current aggregate state, rather than add a value to it. The inverse transition function must have the same strictness attribute as the forward state transition function.</p><p><em>mstate_data_type</em></p><p>The data type for the aggregate&apos;s state value, when using moving-aggregate mode.</p><p><em>mstate_data_size</em></p><p>The approximate average size (in bytes) of the aggregate&apos;s state value, when using moving-aggregate mode. This works the same as <em>state_data_size</em>.</p><p><em>mffunc</em></p><p>The name of the final function called to compute the aggregate&apos;s result after all input rows have been traversed, when using moving-aggregate mode. This works the same as <em>ffunc</em>, except that its first argument&apos;s type is <em>mstate_data_type</em> and extra dummy arguments are specified by writing MFINALFUNC_EXTRA. The aggregate result type determined by <em>mffunc</em> or <em>mstate_data_type</em> must match that determined by the aggregate&apos;s regular implementation.</p><p><em>minitial_condition</em></p><p>The initial setting for the state value, when using moving-aggregate mode. This works the same as <em>initial_condition</em>.</p><p><em>sort_operator</em></p><p>The associated sort operator for a <strong>MIN</strong>- or <strong>MAX</strong>-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</p><p>HYPOTHETICAL</p><p>For ordered-set aggregates only, this flag specifies that the aggregate arguments are to be processed according to the requirements for hypothetical-set aggregates: that is, the last few direct arguments must match the data types of the aggregated (WITHIN GROUP) arguments. The HYPOTHETICAL flag has no effect on run-time behavior, only on parse-time resolution of the data types and collations of the aggregate&apos;s arguments.</p><p>The parameters of <strong>CREATE AGGREGATE</strong> can be written in any order, not just the order illustrated above.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>In parameters that specify support function names, you can write a schema name if needed, for example SFUNC = public.sum. Do not write argument types there, however &ndash; the argument types of the support functions are determined from other parameters.</p><p>If an aggregate supports moving-aggregate mode, it will improve calculation efficiency when the aggregate is used as a window function for a window with moving frame start (that is, a frame start mode other than UNBOUNDED PRECEDING). Conceptually, the forward transition function adds input values to the aggregate&apos;s state when they enter the window frame from the bottom, and the inverse transition function removes them again when they leave the frame at the top. So, when values are removed, they are always removed in the same order they were added. Whenever the inverse transition function is invoked, it will thus receive the earliest added but not yet removed argument value(s). The inverse transition function can assume that at least one row will remain in the current state after it removes the oldest row. (When this would not be the case, the window function mechanism simply starts a fresh aggregation, rather than using the inverse transition function.)</p><p>The forward transition function for moving-aggregate mode is not allowed to return NULL as the new state value. If the inverse transition function returns NULL, this is taken as an indication that the inverse function cannot reverse the state calculation for this particular input, and so the aggregate calculation will be redone from scratch for the current frame starting position. This convention allows moving-aggregate mode to be used in situations where there are some infrequent cases that are impractical to reverse out of the running state value.</p><p>If no moving-aggregate implementation is supplied, the aggregate can still be used with moving frames, but PostgreSQL will recompute the whole aggregation whenever the start of the frame moves. Note that whether or not the aggregate supports moving-aggregate mode, PostgreSQL can handle a moving frame end without recalculation; this is done by continuing to add new values to the aggregate&apos;s state. It is assumed that the final function does not damage the aggregate&apos;s state value, so that the aggregation can be continued even after an aggregate result value has been obtained for one set of frame boundaries.</p><p>The syntax for ordered-set aggregates allows VARIADIC to be specified for both the last direct parameter and the last aggregated (WITHIN GROUP) parameter. However, the current implementation restricts use of VARIADIC in two ways. First, ordered-set aggregates can only use VARIADIC "any", not other variadic array types. Second, if the last direct parameter is VARIADIC "any", then there can be only one aggregated parameter and it must also be VARIADIC "any". (In the representation used in the system catalogs, these two parameters are merged into a single VARIADIC "any" item, since pg_proc cannot represent functions with more than one VARIADIC parameter.) If the aggregate is a hypothetical-set aggregate, the direct arguments that match the VARIADIC "any" parameter are the hypothetical ones; any preceding parameters represent additional direct arguments that are not constrained to match the aggregated arguments.</p><p>Currently, ordered-set aggregates do not need to support moving-aggregate mode, since they cannot be used as window functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>See Section 35.10, &ldquo;User-defined Aggregates&rdquo;, in the documentation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMPATIBILITY</h2>
        <div class="sectioncontent">
<p><strong>CREATE AGGREGATE</strong> is a PostgreSQL language extension. The SQL standard does not provide for user-defined aggregate functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO CREATE_AGGREGATE&hellip;</h2>
        <div class="sectioncontent">
<p>ALTER AGGREGATE (<a href="../man7/ALTER_AGGREGATE.7.html"><strong>ALTER_AGGREGATE</strong>(7)</a>), DROP AGGREGATE (<a href="../man7/DROP_AGGREGATE.7.html"><strong>DROP_AGGREGATE</strong>(7)</a>)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="COMMIT_PREPARED.7.html"><span aria-hidden="true">&larr;</span> COMMIT_PREPARED.7: Commit a transaction that was earlier prepared for two-phase commit</a></li>
   <li class="next"><a href="CREATE_CAST.7.html">CREATE_CAST.7: Define a new cast <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

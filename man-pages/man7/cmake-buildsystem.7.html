<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cmake-buildsystem: Cmake buildsystem reference</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Cmake buildsystem reference">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="cmake-buildsystem (7) manual">
  <meta name="twitter:description" content="Cmake buildsystem reference">
  <meta name="twitter:image" content="https://www.carta.tech/images/cmake-data-cmake-buildsystem-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/cmake-buildsystem.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="cmake-buildsystem (7) manual" />
  <meta property="og:description" content="Cmake buildsystem reference" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/cmake-data-cmake-buildsystem-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">cmake-buildsystem<small> (7)</small></h1>
        <p class="lead">Cmake buildsystem reference</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/cmake-buildsystem.7.html">
      <span itemprop="name">cmake-buildsystem: Cmake buildsystem reference</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/cmake-data/">
      <span itemprop="name">cmake-data</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/cmake-buildsystem.7.html">
      <span itemprop="name">cmake-buildsystem: Cmake buildsystem reference</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>A CMake-based buildsystem is organized as a set of high-level logical targets.  Each target corresponds to an executable or library, or is a custom target containing custom commands.  Dependencies between the targets are expressed in the buildsystem to determine the build order and the rules for regeneration in response to change.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BINARY TARGETS</h2>
        <div class="sectioncontent">
<p>Executables and libraries are defined using the <strong>add_library()</strong> and <strong>add_executable()</strong> commands.  The resulting binary files have appropriate prefixes, suffixes and extensions for the platform targeted. Dependencies between binary targets are expressed using the <strong>target_link_libraries()</strong> command:</p>
<pre>
add_library(archive archive.cpp zip.cpp lzma.cpp)
add_executable(zipapp zipapp.cpp)
target_link_libraries(zipapp archive)
</pre>
<p><strong>archive</strong> is defined as a static library -- an archive containing objects compiled from <strong>archive.cpp</strong>, <strong>zip.cpp</strong>, and <strong>lzma.cpp</strong>.  <strong>zipapp</strong> is defined as an executable formed by compiling and linking <strong>zipapp.cpp</strong>. When linking the <strong>zipapp</strong> executable, the <strong>archive</strong> static library is linked in.</p><h3>Binary Library Types</h3>
<p>By default, the <strong>add_library()</strong> command defines a static library, unless a type is specified.  A type may be specified when using the command:</p>
<pre>
add_library(archive SHARED archive.cpp zip.cpp lzma.cpp)
</pre>

<pre>
add_library(archive STATIC archive.cpp zip.cpp lzma.cpp)
</pre>
<p>The <strong>BUILD_SHARED_LIBS</strong> variable may be enabled to change the behavior of <strong>add_library()</strong> to build shared libraries by default.</p><p>In the context of the buildsystem definition as a whole, it is largely irrelevant whether particular libraries are <strong>SHARED</strong> or <strong>STATIC</strong> -- the commands, dependency specifications and other APIs work similarly regardless of the library type.  The <strong>MODULE</strong> library type is dissimilar in that it is generally not linked to -- it is not used in the right-hand-side of the <strong>target_link_libraries()</strong> command. It is a type which is loaded as a plugin using runtime techniques.</p>
<pre>
add_library(archive MODULE 7z.cpp)
</pre>
<p>The <strong>OBJECT</strong> library type is also not linked to. It defines a non-archival collection of object files resulting from compiling the given source files. The object files collection can be used as source inputs to other targets:</p>
<pre>
add_library(archive OBJECT archive.cpp zip.cpp lzma.cpp)

add_library(archiveExtras STATIC $&lt;TARGET_OBJECTS:archive&gt; extras.cpp)

add_executable(test_exe $&lt;TARGET_OBJECTS:archive&gt; test.cpp)
</pre>
<p><strong>OBJECT</strong> libraries may only be used locally as sources in a buildsystem -- they may not be installed, exported, or used in the right hand side of <strong>target_link_libraries()</strong>.  They also may not be used as the <strong>TARGET</strong> in a use of the <strong>add_custom_command(TARGET)</strong> command signature.</p><p>Commands such as <strong>add_custom_command()</strong>, which generates rules to be run at build time can transparently use an <strong>EXECUTABLE</strong> target as a <strong>COMMAND</strong> executable.  The buildsystem rules will ensure that the executable is built before attempting to run the command.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUILD SPECIFICATION AND USAGE REQUIREMENTS</h2>
        <div class="sectioncontent">
<p>The <strong>target_include_directories()</strong>, <strong>target_compile_definitions()</strong> and <strong>target_compile_options()</strong> commands specify the build specifications and the usage requirements of binary targets.  The commands populate the <strong>INCLUDE_DIRECTORIES</strong>, <strong>COMPILE_DEFINITIONS</strong> and <strong>COMPILE_OPTIONS</strong> target properties respectively, and/or the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong>, <strong>INTERFACE_COMPILE_DEFINITIONS</strong> and <strong>INTERFACE_COMPILE_OPTIONS</strong> target properties.</p><p>Each of the commands has a <strong>PRIVATE</strong>, <strong>PUBLIC</strong> and <strong>INTERFACE</strong> mode.  The <strong>PRIVATE</strong> mode populates only the non-<strong>INTERFACE_</strong> variant of the target property and the <strong>INTERFACE</strong> mode populates only the <strong>INTERFACE_</strong> variants. The <strong>PUBLIC</strong> mode populates both variants of the repective target property. Each command may be invoked with multiple uses of each keyword:</p>
<pre>
target_compile_definitions(archive
  PRIVATE BUILDING_WITH_LZMA
  INTERFACE USING_ARCHIVE_LIB
)
</pre>
<p>Note that usage requirements are not designed as a way to make downstreams use particular <strong>COMPILE_OPTIONS</strong> or <strong>COMPILE_DEFINITIONS</strong> etc for convenience only.  The contents of the properties must be <strong>requirements</strong>, not merely recommendations or convenience.</p><h3>Target Properties</h3>
<p>The contents of the <strong>INCLUDE_DIRECTORIES</strong>, <strong>COMPILE_DEFINITIONS</strong> and <strong>COMPILE_OPTIONS</strong> target properties are used appropriately when compiling the source files of a binary target.</p><p>Entries in the <strong>INCLUDE_DIRECTORIES</strong> are added to the compile line with <strong>-I</strong> or <strong>-isystem</strong> prefixes and in the order of appearance in the property value.</p><p>Entries in the <strong>COMPILE_DEFINITIONS</strong> are prefixed with <strong>-D</strong> or <strong>/D</strong> and added to the compile line in an unspecified order.  The <strong>DEFINE_SYMBOL</strong> target property is also added as a compile definition as a special convenience case for <strong>SHARED</strong> and <strong>MODULE</strong> library targets.</p><p>Entries in the <strong>COMPILE_OPTIONS</strong> are escaped for the shell and added in the order of appearance in the property value.  Several compile options have special separate handling, such as <strong>POSITION_INDEPENDENT_CODE</strong>.</p><p>The contents of the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong>, <strong>INTERFACE_COMPILE_DEFINITIONS</strong> and <strong>INTERFACE_COMPILE_OPTIONS</strong> target properties are <em>Usage Requirements</em> -- they specify content which consumers must use to correctly compile and link with the target they appear on. For any binary target, the contents of each <strong>INTERFACE_</strong> property on each target specified in a <strong>target_link_libraries()</strong> command is consumed:</p>
<pre>
set(srcs archive.cpp zip.cpp)
if (LZMA_FOUND)
  list(APPEND srcs lzma.cpp)
endif()
add_library(archive SHARED ${srcs})
if (LZMA_FOUND)
  # The archive library sources are compiled with -DBUILDING_WITH_LZMA
  target_compile_definitions(archive PRIVATE BUILDING_WITH_LZMA)
endif()
target_compile_definitions(archive INTERFACE USING_ARCHIVE_LIB)

add_executable(consumer)
# Link consumer to archive and consume its usage requirements. The consumer
# executable sources are compiled with -DUSING_ARCHIVE_LIB.
target_link_libraries(consumer archive)
</pre>
<p>Because it is common to require that the source directory and corresponding build directory are added to the <strong>INCLUDE_DIRECTORIES</strong>, the <strong>CMAKE_INCLUDE_CURRENT_DIR</strong> variable can be enabled to conveniently add the corresponding directories to the <strong>INCLUDE_DIRECTORIES</strong> of all targets.  The variable <strong>CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE</strong> can be enabled to add the corresponding directories to the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> of all targets.  This makes use of targets in multiple different directories convenient through use of the <strong>target_link_libraries()</strong> command.</p>
<h3>Transitive Usage Requirements</h3>
<p>The usage requirements of a target can transitively propagate to dependents. The <strong>target_link_libraries()</strong> command has <strong>PRIVATE</strong>, <strong>INTERFACE</strong> and <strong>PUBLIC</strong> keywords to control the propagation.</p>
<pre>
add_library(archive archive.cpp)
target_compile_definitions(archive INTERFACE USING_ARCHIVE_LIB)

add_library(serialization serialization.cpp)
target_compile_definitions(serialization INTERFACE USING_SERIALIZATION_LIB)

add_library(archiveExtras extras.cpp)
target_link_libraries(archiveExtras PUBLIC archive)
target_link_libraries(archiveExtras PRIVATE serialization)
# archiveExtras is compiled with -DUSING_ARCHIVE_LIB
# and -DUSING_SERIALIZATION_LIB

add_executable(consumer consumer.cpp)
# consumer is compiled with -DUSING_ARCHIVE_LIB
target_link_libraries(consumer archiveExtras)
</pre>
<p>Because <strong>archive</strong> is a <strong>PUBLIC</strong> dependency of <strong>archiveExtras</strong>, the usage requirements of it are propagated to <strong>consumer</strong> too.  Because <strong>serialization</strong> is a <strong>PRIVATE</strong> dependency of <strong>archive</strong>, the usage requirements of it are not propagated to <strong>consumer</strong>.</p><p>Generally, a dependency should be specified in a use of <strong>target_link_libraries()</strong> with the <strong>PRIVATE</strong> keyword if it is used by only the implementation of a library, and not in the header files.  If a dependency is additionally used in the header files of a library (e.g. for class inheritance), then it should be specified as a <strong>PUBLIC</strong> dependency. A dependency which is not used by the implementation of a library, but only by its headers should be specified as an <strong>INTERFACE</strong> dependency.  The <strong>target_link_libraries()</strong> command may be invoked with multiple uses of each keyword:</p>
<pre>
target_link_libraries(archiveExtras
  PUBLIC archive
  PRIVATE serialization
)
</pre>
<p>Usage requirements are propagated by reading the <strong>INTERFACE_</strong> variants of target properties from dependencies and appending the values to the non-<strong>INTERFACE_</strong> variants of the operand.  For example, the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> of dependencies is read and appended to the <strong>INCLUDE_DIRECTORIES</strong> of the operand.  In cases where order is relevant and maintained, and the order resulting from the <strong>target_link_libraries()</strong> calls does not allow correct compilation, use of an appropriate command to set the property directly may update the order.</p><p>For example, if the linked libraries for a target must be specified in the order <strong>lib1</strong> <strong>lib2</strong> <strong>lib3</strong> , but the include directories must be specified in the order <strong>lib3</strong> <strong>lib1</strong> <strong>lib2</strong>:</p>
<pre>
target_link_libraries(myExe lib1 lib2 lib3)
target_include_directories(myExe
  PRIVATE $&lt;TARGET_PROPERTY:INTERFACE_INCLUDE_DIRECTORIES:lib3&gt;)
</pre>

<h3>Compatible Interface Properties</h3>
<p>Some target properties are required to be compatible between a target and the interface of each dependency.  For example, the <strong>POSITION_INDEPENDENT_CODE</strong> target property may specify a boolean value of whether a target should be compiled as position-independent-code, which has platform-specific consequences. A target may also specify the usage requirement <strong>INTERFACE_POSITION_INDEPENDENT_CODE</strong> to communicate that consumers must be compiled as position-independent-code.</p>
<pre>
add_executable(exe1 exe1.cpp)
set_property(TARGET exe1 PROPERTY POSITION_INDEPENDENT_CODE ON)

add_library(lib1 SHARED lib1.cpp)
set_property(TARGET lib1 PROPERTY INTERFACE_POSITION_INDEPENDENT_CODE ON)

add_executable(exe2 exe2.cpp)
target_link_libraries(exe2 lib1)
</pre>
<p>Here, both <strong>exe1</strong> and <strong>exe2</strong> will be compiled as position-independent-code. <strong>lib1</strong> will also be compiled as position-independent-code because that is the default setting for <strong>SHARED</strong> libraries.  If dependencies have conflicting, non-compatible requirements <a href="../man1/cmake.1.html"><strong>cmake</strong>(1)</a></strong> issues a diagnostic:</p>
<pre>
add_library(lib1 SHARED lib1.cpp)
set_property(TARGET lib1 PROPERTY INTERFACE_POSITION_INDEPENDENT_CODE ON)

add_library(lib2 SHARED lib2.cpp)
set_property(TARGET lib2 PROPERTY INTERFACE_POSITION_INDEPENDENT_CODE OFF)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 lib1)
set_property(TARGET exe1 PROPERTY POSITION_INDEPENDENT_CODE OFF)

add_executable(exe2 exe2.cpp)
target_link_libraries(exe2 lib1 lib2)
</pre>
<p>The <strong>lib1</strong> requirement <strong>INTERFACE_POSITION_INDEPENDENT_CODE</strong> is not "compatible" with the <strong>POSITION_INDEPENDENT_CODE</strong> property of the <strong>exe1</strong> target.  The library requires that consumers are built as position-independent-code, while the executable specifies to not built as position-independent-code, so a diagnostic is issued.</p><p>The <strong>lib1</strong> and <strong>lib2</strong> requirements are not "compatible".  One of them requires that consumers are built as position-independent-code, while the other requires that consumers are not built as position-independent-code. Because <strong>exe2</strong> links to both and they are in conflict, a diagnostic is issued.</p><p>To be "compatible", the <strong>POSITION_INDEPENDENT_CODE</strong> property, if set must be either the same, in a boolean sense, as the <strong>INTERFACE_POSITION_INDEPENDENT_CODE</strong> property of all transitively specified dependencies on which that property is set.</p><p>This property of "compatible interface requirement" may be extended to other properties by specifying the property in the content of the <strong>COMPATIBLE_INTERFACE_BOOL</strong> target property.  Each specified property must be compatible between the consuming target and the corresponding property with an <strong>INTERFACE_</strong> prefix from each dependency:</p>
<pre>
add_library(lib1Version2 SHARED lib1_v2.cpp)
set_property(TARGET lib1Version2 PROPERTY INTERFACE_CUSTOM_PROP ON)
set_property(TARGET lib1Version2 APPEND PROPERTY
  COMPATIBLE_INTERFACE_BOOL CUSTOM_PROP
)

add_library(lib1Version3 SHARED lib1_v3.cpp)
set_property(TARGET lib1Version3 PROPERTY INTERFACE_CUSTOM_PROP OFF)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 lib1Version2) # CUSTOM_PROP will be ON

add_executable(exe2 exe2.cpp)
target_link_libraries(exe2 lib1Version2 lib1Version3) # Diagnostic
</pre>
<p>Non-boolean properties may also participate in "compatible interface" computations.  Properties specified in the <strong>COMPATIBLE_INTERFACE_STRING</strong> property must be either unspecified or compare to the same string among all transitively specified dependencies. This can be useful to ensure that multiple incompatible versions of a library are not linked together through transitive requirements of a target:</p>
<pre>
add_library(lib1Version2 SHARED lib1_v2.cpp)
set_property(TARGET lib1Version2 PROPERTY INTERFACE_LIB_VERSION 2)
set_property(TARGET lib1Version2 APPEND PROPERTY
  COMPATIBLE_INTERFACE_STRING LIB_VERSION
)

add_library(lib1Version3 SHARED lib1_v3.cpp)
set_property(TARGET lib1Version3 PROPERTY INTERFACE_LIB_VERSION 3)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 lib1Version2) # LIB_VERSION will be "2"

add_executable(exe2 exe2.cpp)
target_link_libraries(exe2 lib1Version2 lib1Version3) # Diagnostic
</pre>
<p>The <strong>COMPATIBLE_INTERFACE_NUMBER_MAX</strong> target property specifies that content will be evaluated numerically and the maximum number among all specified will be calculated:</p>
<pre>
add_library(lib1Version2 SHARED lib1_v2.cpp)
set_property(TARGET lib1Version2 PROPERTY INTERFACE_CONTAINER_SIZE_REQUIRED 200)
set_property(TARGET lib1Version2 APPEND PROPERTY
  COMPATIBLE_INTERFACE_NUMBER_MAX CONTAINER_SIZE_REQUIRED
)

add_library(lib1Version3 SHARED lib1_v3.cpp)
set_property(TARGET lib1Version2 PROPERTY INTERFACE_CONTAINER_SIZE_REQUIRED 1000)

add_executable(exe1 exe1.cpp)
# CONTAINER_SIZE_REQUIRED will be "200"
target_link_libraries(exe1 lib1Version2)

add_executable(exe2 exe2.cpp)
# CONTAINER_SIZE_REQUIRED will be "1000"
target_link_libraries(exe2 lib1Version2 lib1Version3)
</pre>
<p>Similarly, the <strong>COMPATIBLE_INTERFACE_NUMBER_MIN</strong> may be used to calculate the numeric minimum value for a property from dependencies.</p><p>Each calculated "compatible" property value may be read in the consumer at generate-time using generator expressions.</p><p>Note that for each dependee, the set of properties specified in each compatible interface property must not intersect with the set specified in any of the other properties.</p>
<h3>Property Origin Debugging</h3>
<p>Because build specifications can be determined by dependencies, the lack of locality of code which creates a target and code which is responsible for setting build specifications may make the code more difficult to reason about. <a href="../man1/cmake.1.html"><strong>cmake</strong>(1)</a></strong> provides a debugging facility to print the origin of the contents of properties which may be determined by dependencies.  The properties which can be debugged are listed in the <strong>CMAKE_DEBUG_TARGET_PROPERTIES</strong> variable documentation:</p>
<pre>
set(CMAKE_DEBUG_TARGET_PROPERTIES
  INCLUDE_DIRECTORIES
  COMPILE_DEFINITIONS
  POSITION_INDEPENDENT_CODE
  CONTAINER_SIZE_REQUIRED
  LIB_VERSION
)
add_executable(exe1 exe1.cpp)
</pre>
<p>In the case of properties listed in <strong>COMPATIBLE_INTERFACE_BOOL</strong> or <strong>COMPATIBLE_INTERFACE_STRING</strong>, the debug output shows which target was responsible for setting the property, and which other dependencies also defined the property.  In the case of <strong>COMPATIBLE_INTERFACE_NUMBER_MAX</strong> and <strong>COMPATIBLE_INTERFACE_NUMBER_MIN</strong>, the debug output shows the value of the property from each dependency, and whether the value determines the new extreme.</p>
<h3>Build Specification with Generator Expressions</h3>
<p>Build specifications may use <strong>generator expressions</strong> containing content which may be conditional or known only at generate-time.  For example, the calculated "compatible" value of a property may be read with the <strong>TARGET_PROPERTY</strong> expression:</p>
<pre>
add_library(lib1Version2 SHARED lib1_v2.cpp)
set_property(TARGET lib1Version2 PROPERTY
  INTERFACE_CONTAINER_SIZE_REQUIRED 200)
set_property(TARGET lib1Version2 APPEND PROPERTY
  COMPATIBLE_INTERFACE_NUMBER_MAX CONTAINER_SIZE_REQUIRED
)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 lib1Version2)
target_compile_definitions(exe1 PRIVATE
    CONTAINER_SIZE=$&lt;TARGET_PROPERTY:CONTAINER_SIZE_REQUIRED&gt;
)
</pre>
<p>In this case, the <strong>exe1</strong> source files will be compiled with <strong>-DCONTAINER_SIZE=200</strong>.</p><p>Configuration determined build specifications may be conveniently set using the <strong>CONFIG</strong> generator expression.</p>
<pre>
target_compile_definitions(exe1 PRIVATE
    $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_BUILD&gt;
)
</pre>
<p>The <strong>CONFIG</strong> parameter is compared case-insensitively with the configuration being built.  In the presence of <strong>IMPORTED</strong> targets, the content of <strong>MAP_IMPORTED_CONFIG_DEBUG</strong> is also accounted for by this expression.</p><p>Some buildsystems generated by <a href="../man1/cmake.1.html"><strong>cmake</strong>(1)</a></strong> have a predetermined build-configuration set in the <strong>CMAKE_BUILD_TYPE</strong> variable.  The buildsystem for the IDEs such as Visual Studio and Xcode are generated independent of the build-configuration, and the actual build configuration is not known until build-time.  Therefore, code such as</p>
<pre>
string(TOLOWER ${CMAKE_BUILD_TYPE} _type)
if (_type STREQUAL debug)
  target_compile_definitions(exe1 PRIVATE DEBUG_BUILD)
endif()
</pre>
<p>may appear to work for <strong>Makefile</strong> based and <strong>Ninja</strong> generators, but is not portable to IDE generators.  Additionally, the <strong>IMPORTED</strong> configuration-mappings are not accounted for with code like this, so it should be avoided.</p><p>The unary <strong>TARGET_PROPERTY</strong> generator expression and the <strong>TARGET_POLICY</strong> generator expression are evaluated with the consuming target context.  This means that a usage requirement specification may be evaluated differently based on the consumer:</p>
<pre>
add_library(lib1 lib1.cpp)
target_compile_definitions(lib1 INTERFACE
  $&lt;$&lt;STREQUAL:$&lt;TARGET_PROPERTY:TYPE&gt;,EXECUTABLE&gt;:LIB1_WITH_EXE&gt;
  $&lt;$&lt;STREQUAL:$&lt;TARGET_PROPERTY:TYPE&gt;,SHARED_LIBRARY&gt;:LIB1_WITH_SHARED_LIB&gt;
  $&lt;$&lt;TARGET_POLICY:CMP0041&gt;:CONSUMER_CMP0041_NEW&gt;
)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 lib1)

cmake_policy(SET CMP0041 NEW)

add_library(shared_lib shared_lib.cpp)
target_link_libraries(shared_lib lib1)
</pre>
<p>The <strong>exe1</strong> executable will be compiled with <strong>-DLIB1_WITH_EXE</strong>, while the <strong>shared_lib</strong> shared library will be compiled with <strong>-DLIB1_WITH_SHARED_LIB</strong> and <strong>-DCONSUMER_CMP0041_NEW</strong>, because policy <strong>CMP0041</strong> is <strong>NEW</strong> at the point where the <strong>shared_lib</strong> target is created.</p><p>The <strong>BUILD_INTERFACE</strong> expression wraps requirements which are only used when consumed from a target in the same buildsystem, or when consumed from a target exported to the build directory using the <strong>export()</strong> command.  The <strong>INSTALL_INTERFACE</strong> expression wraps requirements which are only used when consumed from a target which has been installed and exported with the <strong>install(EXPORT)</strong> command:</p>
<pre>
add_library(ClimbingStats climbingstats.cpp)
target_compile_definitions(ClimbingStats INTERFACE
  $&lt;BUILD_INTERFACE:ClimbingStats_FROM_BUILD_LOCATION&gt;
  $&lt;INSTALL_INTERFACE:ClimbingStats_FROM_INSTALLED_LOCATION&gt;
)
install(TARGETS ClimbingStats EXPORT libExport ${InstallArgs})
install(EXPORT libExport NAMESPACE Upstream::
        DESTINATION lib/cmake/ClimbingStats)
export(EXPORT libExport NAMESPACE Upstream::)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 ClimbingStats)
</pre>
<p>In this case, the <strong>exe1</strong> executable will be compiled with <strong>-DClimbingStats_FROM_BUILD_LOCATION</strong>.  The exporting commands generate <strong>IMPORTED</strong> targets with either the <strong>INSTALL_INTERFACE</strong> or the <strong>BUILD_INTERFACE</strong> omitted, and the <strong>*_INTERFACE</strong> marker stripped away. A separate project consuming the <strong>ClimbingStats</strong> package would contain:</p>
<pre>
find_package(ClimbingStats REQUIRED)

add_executable(Downstream main.cpp)
target_link_libraries(Downstream Upstream::ClimbingStats)
</pre>
<p>Depending on whether the <strong>ClimbingStats</strong> package was used from the build location or the install location, the <strong>Downstream</strong> target would be compiled with either <strong>-DClimbingStats_FROM_BUILD_LOCATION</strong> or <strong>-DClimbingStats_FROM_INSTALL_LOCATION</strong>.  For more about packages and exporting see the <a href="../man7/cmake-packages.7.html"><strong>cmake-packages</strong>(7)</a></strong> manual.</p>
<h3>Include Directories and Usage Requirements</h3>
<p>Include directories require some special consideration when specified as usage requirements and when used with generator expressions.  The <strong>target_include_directories()</strong> command accepts both relative and absolute include directories:</p>
<pre>
add_library(lib1 lib1.cpp)
target_include_directories(lib1 PRIVATE
  /absolute/path
  relative/path
)
</pre>
<p>Relative paths are interpreted relative to the source directory where the command appears.  Relative paths are not allowed in the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> of <strong>IMPORTED</strong> targets.</p><p>In cases where a non-trivial generator expression is used, the <strong>INSTALL_PREFIX</strong> expression may be used within the argument of an <strong>INSTALL_INTERFACE</strong> expression.  It is a replacement marker which expands to the installation prefix when imported by a consuming project.</p><p>Include directories usage requirements commonly differ between the build-tree and the install-tree.  The <strong>BUILD_INTERFACE</strong> and <strong>INSTALL_INTERFACE</strong> generator expressions can be used to describe separate usage requirements based on the usage location.  Relative paths are allowed within the <strong>INSTALL_INTERFACE</strong> expression and are interpreted relative to the installation prefix.  For example:</p>
<pre>
add_library(ClimbingStats climbingstats.cpp)
target_include_directories(ClimbingStats INTERFACE
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/generated&gt;
  $&lt;INSTALL_INTERFACE:/absolute/path&gt;
  $&lt;INSTALL_INTERFACE:relative/path&gt;
  $&lt;INSTALL_INTERFACE:$&lt;INSTALL_PREFIX&gt;/$&lt;CONFIG&gt;/generated&gt;
)
</pre>
<p>Two convenience APIs are provided relating to include directories usage requirements.  The <strong>CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE</strong> variable may be enabled, with an equivalent effect to:</p>
<pre>
set_property(TARGET tgt APPEND PROPERTY
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR};${CMAKE_CURRENT_BINARY_DIR}&gt;
)
</pre>
<p>for each target affected.  The convenience for installed targets is an <strong>INCLUDES DESTINATION</strong> component with the <strong>install(TARGETS)</strong> command:</p>
<pre>
install(TARGETS foo bar bat EXPORT tgts ${dest_args}
  INCLUDES DESTINATION include
)
install(EXPORT tgts ${other_args})
install(FILES ${headers} DESTINATION include)
</pre>
<p>This is equivalent to appending <strong>${CMAKE_INSTALL_PREFIX}/include</strong> to the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> of each of the installed <strong>IMPORTED</strong> targets when generated by <strong>install(EXPORT)</strong>.</p><p>When the <strong>INTERFACE_INCLUDE_DIRECTORIES</strong> of an <em>imported target</em> is consumed, the entries in the property are treated as <strong>SYSTEM</strong> include directories, as if they were listed in the <strong>INTERFACE_SYSTEM_INCLUDE_DIRECTORIES</strong> of the dependency. This can result in omission of compiler warnings for headers found in those directories.  This behavior for <em>Imported Targets</em> may be controlled with the <strong>NO_SYSTEM_FROM_IMPORTED</strong> target property.</p><p>If a binary target is linked transitively to a Mac OX framework, the <strong>Headers</strong> directory of the framework is also treated as a usage requirement. This has the same effect as passing the framework directory as an include directory.</p>
<h3>Link Libraries and Generator Expressions</h3>
<p>Like build specifications, <strong>link libraries</strong> may be specified with generator expression conditions.  However, as consumption of usage requirements is based on collection from linked dependencies, there is an additional limitation that the link dependencies must form a "directed acyclic graph".  That is, if linking to a target is dependent on the value of a target property, that target property may not be dependent on the linked dependencies:</p>
<pre>
add_library(lib1 lib1.cpp)
add_library(lib2 lib2.cpp)
target_link_libraries(lib1 PUBLIC
  $&lt;$&lt;TARGET_PROPERTY:POSITION_INDEPENDENT_CODE&gt;:lib2&gt;
)
add_library(lib3 lib3.cpp)
set_property(TARGET lib3 PROPERTY INTERFACE_POSITION_INDEPENDENT_CODE ON)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 lib1 lib3)
</pre>
<p>As the value of the <strong>POSITION_INDEPENDENT_CODE</strong> property of the <strong>exe1</strong> target is dependent on the linked libraries (<strong>lib3</strong>), and the edge of linking <strong>exe1</strong> is determined by the same <strong>POSITION_INDEPENDENT_CODE</strong> property, the dependency graph above contains a cycle.  <a href="../man1/cmake.1.html"><strong>cmake</strong>(1)</a></strong> issues a diagnostic in this case.</p>
<h3>Output Files</h3>
<p>The buildsystem targets created by the <strong>add_library()</strong> and <strong>add_executable()</strong> commands create rules to create binary outputs. The exact output location of the binaries can only be determined at generate-time because it can depend on the build-configuration and the link-language of linked dependencies etc.  <strong>TARGET_FILE</strong>, <strong>TARGET_LINKER_FILE</strong> and related expressions can be used to access the name and location of generated binaries.  These expressions do not work for <strong>OBJECT</strong> libraries however, as there is no single file generated by such libraries which is relevant to the expressions.</p>
<h3>Directory-Scoped Commands</h3>
<p>The <strong>target_include_directories()</strong>, <strong>target_compile_definitions()</strong> and <strong>target_compile_options()</strong> commands have an effect on only one target at a time.  The commands <strong>add_definitions()</strong>, <strong>add_compile_options()</strong> and <strong>include_directories()</strong> have a similar function, but operate at directory scope instead of target scope for convenience.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PSEUDO TARGETS</h2>
        <div class="sectioncontent">
<p>Some target types do not represent outputs of the buildsystem, but only inputs such as external dependencies, aliases or other non-build artifacts.  Pseudo targets are not represented in the generated buildsystem.</p><h3>Imported Targets</h3>
<p>An <strong>IMPORTED</strong> target represents a pre-existing dependency.  Usually such targets are defined by an upstream package and should be treated as immutable.  It is not possible to use an <strong>IMPORTED</strong> target in the left-hand-side of the <strong>target_compile_definitions()</strong>, <strong>target_include_directories()</strong>, <strong>target_compile_options()</strong> or <strong>target_link_libraries()</strong> commands, as that would be an attempt to modify it.  <strong>IMPORTED</strong> targets are designed to be used only in the right-hand-side of those commands.</p><p><strong>IMPORTED</strong> targets may have the same usage requirement properties populated as binary targets, such as <strong>INTERFACE_INCLUDE_DIRECTORIES</strong>, <strong>INTERFACE_COMPILE_DEFINITIONS</strong>, <strong>INTERFACE_COMPILE_OPTIONS</strong>, <strong>INTERFACE_LINK_LIBRARIES</strong>, and <strong>INTERFACE_POSITION_INDEPENDENT_CODE</strong>.</p><p>The <strong>LOCATION</strong> may also be read from an IMPORTED target, though there is rarely reason to do so.  Commands such as <strong>add_custom_command()</strong> can transparently use an <strong>IMPORTED</strong> <strong>EXECUTABLE</strong> target as a <strong>COMMAND</strong> executable.</p><p>The scope of the definition of an <strong>IMPORTED</strong> target is the directory where it was defined.  It may be accessed and used from subdirectories, but not from parent directories or sibling directories.  The scope is similar to the scope of a cmake variable.</p><p>It is also possible to define a <strong>GLOBAL</strong> <strong>IMPORTED</strong> target which is accessible globally in the buildsystem.</p><p>See the <a href="../man7/cmake-packages.7.html"><strong>cmake-packages</strong>(7)</a></strong> manual for more on creating packages with <strong>IMPORTED</strong> targets.</p>
<h3>Alias Targets</h3>
<p>An <strong>ALIAS</strong> target is a name which may be used interchangably with a binary target name in read-only contexts.  A primary use-case for <strong>ALIAS</strong> targets is for example or unit test executables accompanying a library, which may be part of the same buildsystem or built separately based on user configuration.</p>
<pre>
add_library(lib1 lib1.cpp)
install(TARGETS lib1 EXPORT lib1Export ${dest_args})
install(EXPORT lib1Export NAMESPACE Upstream:: ${other_args})

add_library(Upstream::lib1 ALIAS lib1)
</pre>
<p>In another directory, we can link unconditionally to the <strong>Upstream::lib1</strong> target, which may be an <strong>IMPORTED</strong> target from a package, or an <strong>ALIAS</strong> target if built as part of the same buildsystem.</p>
<pre>
if (NOT TARGET Upstream::lib1)
  find_package(lib1 REQUIRED)
endif()
add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 Upstream::lib1)
</pre>
<p><strong>ALIAS</strong> targets are not mutable, installable or exportable.  They are entirely local to the buildsystem description.  A name can be tested for whether it is an <strong>ALIAS</strong> name by reading the <strong>ALIASED_TARGET</strong> property from it:</p>
<pre>
get_target_property(_aliased Upstream::lib1 ALIASED_TARGET)
if(_aliased)
  message(STATUS "The name Upstream::lib1 is an ALIAS for ${_aliased}.")
endif()
</pre>

<h3>Interface Libraries</h3>
<p>An <strong>INTERFACE</strong> target has no <strong>LOCATION</strong> and is mutable, but is otherwise similar to an <strong>IMPORTED</strong> target.</p><p>It may specify usage requirements such as <strong>INTERFACE_INCLUDE_DIRECTORIES</strong>, <strong>INTERFACE_COMPILE_DEFINITIONS</strong>, <strong>INTERFACE_COMPILE_OPTIONS</strong>, <strong>INTERFACE_LINK_LIBRARIES</strong>, and <strong>INTERFACE_POSITION_INDEPENDENT_CODE</strong>. Only the <strong>INTERFACE</strong> modes of the <strong>target_include_directories()</strong>, <strong>target_compile_definitions()</strong>, <strong>target_compile_options()</strong>, and <strong>target_link_libraries()</strong> commands may be used with <strong>INTERFACE</strong> libraries.</p><p>A primary use-case for <strong>INTERFACE</strong> libraries is header-only libraries.</p>
<pre>
add_library(Eigen INTERFACE)
target_include_directories(Eigen INTERFACE
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src&gt;
  $&lt;INSTALL_INTERFACE:include/Eigen&gt;
)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 Eigen)
</pre>
<p>Here, the usage requirements from the <strong>Eigen</strong> target are consumed and used when compiling, but it has no effect on linking.</p><p>Another use-case is to employ an entirely target-focussed design for usage requirements:</p>
<pre>
add_library(pic_on INTERFACE)
set_property(TARGET pic_on PROPERTY INTERFACE_POSITION_INDEPENDENT_CODE ON)
add_library(pic_off INTERFACE)
set_property(TARGET pic_off PROPERTY INTERFACE_POSITION_INDEPENDENT_CODE OFF)

add_library(enable_rtti INTERFACE)
target_compile_options(enable_rtti INTERFACE
  $&lt;$&lt;OR:$&lt;COMPILER_ID:GNU&gt;,$&lt;COMPILER_ID:Clang&gt;&gt;:-rtti&gt;
)

add_executable(exe1 exe1.cpp)
target_link_libraries(exe1 pic_on enable_rtti)
</pre>
<p>This way, the build specification of <strong>exe1</strong> is expressed entirely as linked targets, and the complexity of compiler-specific flags is encapsulated in an <strong>INTERFACE</strong> library target.</p><p>The properties permitted to be set on or read from an <strong>INTERFACE</strong> library are:</p><ul>
<li><p>Properties matching <strong>INTERFACE_*</strong></p></li><li><p>Built-in properties matching <strong>COMPATIBLE_INTERFACE_*</strong></p></li><li><p><strong>EXPORT_NAME</strong></p></li><li><p><strong>IMPORTED</strong></p></li><li><p><strong>NAME</strong></p></li><li><p>Properties matching <strong>MAP_IMPORTED_CONFIG_*</strong></p><p><strong>INTERFACE</strong> libraries may be installed and exported.  Any content they refer to must be installed separately:</p>
<pre>
add_library(Eigen INTERFACE)
target_include_directories(Eigen INTERFACE
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src&gt;
  $&lt;INSTALL_INTERFACE:include/Eigen&gt;
)

install(TARGETS Eigen EXPORT eigenExport)
install(EXPORT eigenExport NAMESPACE Upstream::
  DESTINATION lib/cmake/Eigen
)
install(FILES
    ${CMAKE_CURRENT_SOURCE_DIR}/src/eigen.h
    ${CMAKE_CURRENT_SOURCE_DIR}/src/vector.h
    ${CMAKE_CURRENT_SOURCE_DIR}/src/matrix.h
  DESTINATION include/Eigen
)
</pre>
</li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2000-2014 Kitware, Inc.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="cloudprint-service.7.html"><span aria-hidden="true">&larr;</span> cloudprint-service.7: Manage the google cloud print proxy</a></li>
   <li class="next"><a href="cmake-commands.7.html">cmake-commands.7: Cmake language command reference <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

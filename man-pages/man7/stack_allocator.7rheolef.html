<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>stack_allocator: Stack-based allocator</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Stack-based allocator">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="stack_allocator (7rheolef) manual">
  <meta name="twitter:description" content="Stack-based allocator">
  <meta name="twitter:image" content="https://www.carta.tech/images/librheolef-dev-stack_allocator-7rheolef.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7rheolef/stack_allocator.7rheolef.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="stack_allocator (7rheolef) manual" />
  <meta property="og:description" content="Stack-based allocator" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/librheolef-dev-stack_allocator-7rheolef.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">stack_allocator<small> (7rheolef)</small></h1>
        <p class="lead">Stack-based allocator</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7rheolef/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7rheolef/stack_allocator.7rheolef.html">
      <span itemprop="name">stack_allocator: Stack-based allocator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/librheolef-dev/">
      <span itemprop="name">librheolef-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7rheolef/stack_allocator.7rheolef.html">
      <span itemprop="name">stack_allocator: Stack-based allocator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Stack-based allocator, conform to the STL specification of allocators. Designed to use stack-based data passed as a parameter to the allocator constructor. Does not "free" the memory. Assumes that if the allocator is copied, stack memory is cleared and new allocations begin at the bottom of the stack again.</p><p>Also works with any memory buffer, including heap memory. If the caller passes in heap memory, the caller is responsible for freeing the memory.</p><p>This allocator handles a limited area of memory: if this limit is reached, a "std::bad_alloc" exception is emmited. For a non-limited memory handler in the same spirit, see "heap_allocator"(9).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">

<pre>
    const size_t stack_size = 1024;
    vector&lt;unsigned char&gt; stack (stack_size);
    stack_allocator&lt;double&gt; stack_alloc (stack.begin().operator-&gt;(), stack.size());
    typedef map &lt;size_t, double, less&lt;size_t&gt;, stack_allocator&lt;pair&lt;size_t,double&gt; &gt; &gt;  map_type;
    map_type a (less&lt;size_t&gt;(), stack_alloc);
    a.insert (make_pair (0, 3.14));
    a.insert (make_pair (1, 1.17));
    for (map_type::iterator iter = a.begin(), last = a.end(); iter != last; iter++) {
      cout &lt;&lt; (*iter).first &lt;&lt; " " &lt;&lt; (*iter).second &lt;&lt; endl;
    }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTATION</h2>
        <div class="sectioncontent">

<pre>
template &lt;typename T&gt;
class stack_allocator {
protected:
    struct handler_type; // forward declaration:
public:

// typedefs:

    typedef size_t         size_type;
    typedef std::ptrdiff_t difference_type;
    typedef T*             pointer;
    typedef const T*       const_pointer;
    typedef T&             reference;
    typedef const T&       const_reference;
    typedef T              value_type;

// constructors:

    stack_allocator() throw()
      : handler (new handler_type)
    {
    }
    stack_allocator (unsigned char* stack, size_t stack_size) throw()
      : handler (new handler_type (stack, stack_size))
    {
        warning_macro ("stack_allocator cstor");
    }
    stack_allocator (const stack_allocator& sa) throw()
      : handler (sa.handler)
    {
        ++handler-&gt;reference_count;
    }
    template &lt;typename U&gt;
    stack_allocator (const stack_allocator&lt;U&gt;& sa) throw()
      : handler ((typename stack_allocator&lt;T&gt;::handler_type*)(sa.handler))
    {
        ++handler-&gt;reference_count;
    }
    ~stack_allocator() throw()
    {
        warning_macro ("stack_allocator dstor");
        check_macro (handler != NULL, "unexpected null mem_info");
        if (--handler-&gt;reference_count == 0) delete handler;
    }
    // Rebind to allocators of other types
    template &lt;typename U&gt;
    struct rebind {
        typedef stack_allocator&lt;U&gt; other;
    };

// assignement:

    stack_allocator& operator= (const stack_allocator& sa)
    {
        handler = sa.handler;
        ++handler-&gt;reference_count;
        return *this;
    }

// utility functions:

    pointer       address (reference r)       const { return &r; }
    const_pointer address (const_reference c) const { return &c; }
    size_type     max_size() const { return std::numeric_limits&lt;size_t&gt;::max() / sizeof(T); }

// in-place construction/destruction

    void construct (pointer p, const_reference c)
    {
        // placement new operator:
        new( reinterpret_cast&lt;void*&gt;(p) ) T(c);
    }
    // C++ 2011: default construct a value of type T at the location referenced by p
    void construct (pointer p) { new ( reinterpret_cast&lt;void*&gt;(p) ) T(); }

    void destroy (pointer p)
    {
        // call destructor directly:
        (p)-&gt;~T();
    }

// allocate raw memory

    pointer allocate (size_type n, const void* = NULL)
    {
        warning_macro ("allocate "&lt;&lt;n&lt;&lt;" type " &lt;&lt; typename_macro(T));
        check_macro (handler-&gt;stack != NULL, "unexpected null stack");
        void* p = handler-&gt;stack + handler-&gt;allocated_size;
        handler-&gt;allocated_size += n*sizeof(T);

        if (handler-&gt;allocated_size + 1 &gt; handler-&gt;max_size) {
            warning_macro ("stack is full: throwing...");
            throw std::bad_alloc();
        }
        return pointer (p);
    }
    void deallocate (pointer p, size_type n)
    {
        warning_macro ("deallocate "&lt;&lt;n&lt;&lt;" type "&lt;&lt;typename_macro(T));
        // No need to free stack memory
    }
    const handler_type* get_handler() const {
        return handler;
    }

// data:

protected:
    struct handler_type {
        unsigned char* stack;
        size_t         allocated_size;
        size_t         max_size;
        size_t         reference_count;

        handler_type()
          : stack (NULL),
            allocated_size (0),
            max_size (0),
            reference_count (1)
        {
          warning_macro ("stack_allocator::mem_info cstor NULL");
        }
        handler_type (unsigned char* stack1, size_t size1)
          : stack (stack1),
            allocated_size (0),
            max_size (size1),
            reference_count (1)
        {
          warning_macro ("stack_allocator::mem_info cstori: size="&lt;&lt;max_size);
        }
        ~handler_type()
        {
          warning_macro ("stack_allocator::mem_info dstor: size="&lt;&lt;max_size);
        }
    };
    handler_type* handler;
    template &lt;typename U&gt; friend class stack_allocator;
};
// Comparison
template &lt;typename T1&gt;
bool operator==( const stack_allocator&lt;T1&gt;& lhs, const stack_allocator&lt;T1&gt;& rhs) throw()
{
    return lhs.get_handler() == rhs.get_handler();
}
template &lt;typename T1&gt;
bool operator!=( const stack_allocator&lt;T1&gt;& lhs, const stack_allocator&lt;T1&gt;& rhs) throw()
{
    return lhs.get_handler() != rhs.get_handler();
}
</pre>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="smart_pointer.7rheolef.html"><span aria-hidden="true">&larr;</span> smart_pointer.7rheolef: Reference counted safe pointer with true copy semantic</a></li>
   <li class="next"><a href="tetrahedron.7rheolef.html">tetrahedron.7rheolef: Tetraedron reference element <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

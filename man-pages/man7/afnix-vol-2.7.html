<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>afnix-vol-2: Afnix reference manual</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Afnix reference manual">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="afnix-vol-2 (7) manual">
  <meta name="twitter:description" content="Afnix reference manual">
  <meta name="twitter:image" content="https://www.carta.tech/images/afnix-afnix-vol-2-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/afnix-vol-2.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="afnix-vol-2 (7) manual" />
  <meta property="og:description" content="Afnix reference manual" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/afnix-afnix-vol-2-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">afnix-vol-2<small> (7)</small></h1>
        <p class="lead">Afnix reference manual</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/afnix-vol-2.7.html">
      <span itemprop="name">afnix-vol-2: Afnix reference manual</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/afnix/">
      <span itemprop="name">afnix</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/afnix-vol-2.7.html">
      <span itemprop="name">afnix-vol-2: Afnix reference manual</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">RESERVED KEYWORDS</h2>
        <div class="sectioncontent">
<p>Reserved keyword are, with symbols and literals, the basic constituents of the writing system. With couple of exception, reserved keywords are in fact special forms. During the execution, a special</p><p><strong>assert</strong></p><p>The assert special form check for equality between two operands. Both objects must be of the same type. If the equality test fails, the special form print a message and abort the execution. By default, the assertion checking is turned off. The interpreter option -f assert enables the assertion checking. When the interpreter is compiled in debug mode, the assertion checking is turned on by default.</p><p><em>Syntax</em></p><p>assert "form 1" "form 2"</p><p><em>Example</em></p><p>assert true (== 1 1) assert 3    (+  2 1)</p><p><strong>block</strong></p><p>The block special form defines a new nameset for sequential execution of regular form or implicit form. When the block form is evaluated, the block nameset is linked to its parent nameset. When all forms have been executed, the block nameset is destroyed and the result of the last evaluation in the block is considered to be the result of the block evaluation.</p><p><em>Syntax</em></p><p>block "regular form" block "block form"</p><p><em>Example</em></p><p>trans a 1 block {</p>
<pre>
  assert    a 1
  trans     a (+ 1 1)
  assert    a 2
  assert ..:a 1
</pre>
<p>} assert 1 a</p><p><strong>class</strong></p><p>The class special form creates a new class object. Without argument, an instance of that class is created without data members.</p><p><em>Syntax</em></p><p>class</p><p><em>Example</em></p><p>const Color (class) trans Color:preset (red green blue) {</p>
<pre>
  const this:red   red
  const this:green green
  const this:blue  blue
</pre>
<p>} const red   (Color 255   0   0) const green (Color   0 255   0) const blue  (Color   0   0 255)</p><p><strong>const</strong></p><p>The const special form binds a symbol with an object and marks it as a constant symbol. When used with three or four argument, a gamma expression is automatically created. const can also be used to bind class or instance members.</p><p><em>Syntax</em></p><p>const symbol "object" const symbol "argument" "body" const symbol "argument" "closed variables" "body"</p><p><em>Example</em></p><p>const number 123 const max (x y) (if (&gt; x y) x y)</p><p><strong>delay</strong></p><p>The delay special form delays the evaluation of the form argument by creating a Promise object. The promise evaluate to itself until a call to force the evaluation has been made. When the promise has been forced, the evaluation result is stored. Further call to force will produce the same result. Without argument, the delayed evaluation is nil. With one argument, a Promise object is created directly. With several argument, a cons cell is created with the first argument left unevaluated and the other evaluated. This permit to delay a form while evaluatin the calling arguments.</p><p><em>Syntax</em></p><p>delay "form"</p><p><em>Example</em></p><p>trans  y 3 const  l ((lambda (x) (+ x y)) 1) assert 4 (force l) trans  y 0 assert 4 (force l) trans  y 1 trans  d (delay (lambda (x) (+ x 1)) y) assert 2 (force d)</p><p><strong>do</strong></p><p>The do special form is used to build loop with forward condition. The loop construct accepts either 2 or 3 arguments. With 2 argument, the first argument is the loop body and the second argument is the loop condition which must evaluates to a boolean object. With 3 arguments, the first argument is the initial condition that is executed only once.</p><p><em>Syntax</em></p><p>do "body" "condition" do "initial" "body" "condition"</p><p><em>Example</em></p><p>const number-of-digits (s) {</p>
<pre>
  const len (s:length)
  trans index 0
  trans count 0
  do {
    trans c (s:get index)
    if (c:digit-p) (count:++)
  } (&lt; (index:++) len)
  eval count
</pre>
<p>}</p><p><strong>enum</strong></p><p>The enum special form creates an enumeration from a list of literal. The result object is an Enum object that holds the enumerated items. An item evaluation results with an Item object that is bound to the enumeration object.</p><p><em>Syntax</em></p><p>enum "literal" ...</p><p><em>Example</em></p><p>const e (enum E1 E2 E3)</p><p><strong>errorln</strong></p><p>The errorln special form prints on the interpreter error stream a set of arguments. Each arguments have to be a literal which are converted to a string. When all arguments have been printed a new line character is printed. The error special form behaves like errorln excepts that a new line character is not printed at the end of the arguments.</p><p><em>Syntax</em></p><p>errorln errorln "nil" errorln "literal list"</p><p><em>Example</em></p><p>errorln errorln "hello millennium" ' ' 2000</p><p><strong>eval</strong></p><p>The eval special form simply evaluates the object argument. The form is useful when returning an argument from a lambda or gamma expression using an implicit form.</p><p><em>Syntax</em></p><p>eval "object"</p><p><em>Example</em></p><p>const ret (x) (eval x) eval (protect (+ 1 2))</p><p><strong>for</strong></p><p>The for special form provides a facility to iterate on iterable objects. The Cons, List and Vector objects are typical iterable objects. For each iterable objects, a symbol is set after each iteration. Each object symbol value can be used for further computation. The iteration stops when one of the objects iterator is at the end position.</p><p><em>Syntax</em></p><p>for "symbol list" "iterable object list" "body"</p><p><em>Example</em></p><p># compute the scalar product of two vectors const scalar-product (u v) {</p>
<pre>
  trans result 0
  for (x y) (u v) (result:+= (* x y))
  eval result
</pre>
<p>}</p><p><strong>force</strong></p><p>The force special form forces the evaluation of its argument. If the argument evaluates to a promise object, the promise evaluation is forced. If the argument is not a promise, force keyword behaves like eval. When a promise has been forced, further call to force will not change the evaluation result.</p><p><em>Syntax</em></p><p>force "object"</p><p><em>Example</em></p><p>trans  y 3 const  l ((lambda (x) (+ x y)) 1) assert 4 (force l) trans  y 0 assert 4 (force l)</p><p><strong>if</strong></p><p>The if special form executes a form based on the evaluation of a boolean expression. In its first representation, if executes a form if the condition is evaluated to true. An alternate form can be specified and is executed if the boolean expression evaluates to false. It is an error to use a conditional form which does not evaluate to a boolean object.</p><p><em>Syntax</em></p><p>if "condition" "true form" if "condition" "true form" "else form"</p><p><em>Example</em></p><p>const max (x y) (if (&gt; x y) x y)</p><p><strong>lambda</strong></p><p>The lambda special form creates a new closure object with eventually a set of arguments and a set of closed variables. In its first form, the closure is declared with a set of arguments or nil to indicate no argument. In its second form, the closure is declared with a set of arguments and a set of closed variables. The closed variables are evaluated at the construction of the closure and become part of the closure object. When the closure is called, a new nameset is created and linked with the parent nameset. The set of calling arguments are bounded in that nameset with the formal argument list to become the actual arguments. The set of closed variables is linked at runtime to the closure nameset. A lambda or gamma expression can have its argument declared as const argument.</p><p><em>Syntax</em></p><p>lambda "nil" "body" lambda "argument list" "body" lambda "argument list" "closed variables list" "body"</p><p><em>Example</em></p><p>const no-args (lambda nil (+ 1 1)) const add     (lambda ((const x) (const y)) (+ x y)) const closed  (lambda (x) (y) (+ x y))</p><p><strong>launch</strong></p><p>The launch special form creates a new thread by executing the form argument in a normal thread. The created thread is added in the normal thread list by creating a clone of the interpreter and starting immediately the execution of the form with the cloned interpreter. The command returns the thread object in the calling thread. When the thread terminates, the thread object holds the result of the last executed form. The main thread is suspended until all normal threads have completed their execution.</p><p><em>Syntax</em></p><p>launch "form" launch "thread" "form"</p><p><em>Example</em></p><p>launch (println "hello world")</p><p><strong>loop</strong></p><p>The loop special form executes a loop based on an initial condition, an exit condition and a step form. The initial condition is only executed one time. The exit condition is tested at each loop iteration. The loop special form creates its own nameset since the initial condition generally binds symbol locally for the loop.</p><p><em>Syntax</em></p><p>loop "init form" "exit form" "step" "form"</p><p><em>Example</em></p><p>loop (trans i 0) (&lt; i 10) (i:++) (println i)</p><p><strong>nameset</strong></p><p>The nameset special form creates a new nameset. With no argument, a new nameset is created and no parent is binded to this nameset. With one argument, the argument must evaluate to a nameset and that nameset is used as the parent one. If a nameset has to be created with the global nameset as the parent, the symbol ... can be used to reference the top level nameset. The symbol . references the current nameset. The symbol .. references the parent nameset of the current nameset.</p><p><em>Syntax</em></p><p>nameset nameset "parent nameset"</p><p><em>Example</em></p><p>const local-nameset-not-bound (nameset) const local-nameset-bounded   (nameset ...) const ...:global-nameset      (nameset)</p><p><strong>println</strong></p><p>The println special form prints on the interpreter output stream a set of arguments. Each arguments have to be a literal which is converted to a string. When all arguments have been printed a new line character is printed. The print special form behaves like println excepts that a new line character is not printed at the end of the arguments.</p><p><em>Syntax</em></p><p>println println "nil" println "literal list"</p><p><em>Example</em></p><p>println println "hello millennium" ' ' 2000</p><p><strong>protect</strong></p><p>The protect special form take a single argument and returns it without evaluation. Protect is mainly use to get a symbol or form object.</p><p><em>Syntax</em></p><p>protect "object"</p><p><em>Example</em></p><p>const cons (protect (+ 1 2))</p><p><strong>return</strong></p><p>The return special form causes the current expression to stop its evaluation and returns the argument or nil. The return keyword is primarily used in lambda or gamma expressions. If used in a top level block, the block execution is stopped and the control is transferred to the top level.</p><p><em>Syntax</em></p><p>return "object"</p><p><em>Example</em></p><p>return (+ 1 2)</p><p><strong>sync</strong></p><p>The sync special form is a form synchronizer. Within a multi-threaded environment, the engine guarantees that only one thread will execute the form. The other threads are suspended until the form has been completed.</p><p><em>Syntax</em></p><p>sync "form"</p><p><em>Example</em></p><p>const print-message (code mesg) (</p>
<pre>
  sync {
    errorln "error  : " code
    errorln "message: " mesg
  }
</pre>
<p>)</p><p><strong>switch</strong></p><p>The switch special form is a form selector. The first argument is the object to switch. The second argument is a list of forms with an object matcher and an execution form. The else special form can be used as default matcher.</p><p><em>Syntax</em></p><p>switch "selector" "list of conditions"</p><p><em>Example</em></p><p>const get-primary-color (color value) (</p>
<pre>
  switch color (
    ("red"   (return (value:substr 0 2))
      ("green" (return (value:substr 2 4))
        ("blue"  (return (value:substr 4 6))
        )
      )
</pre>
<p><strong>throw</strong></p><p>The throw special form throws an exception. Without argument, an exception of type user-exception is thrown. With one argument, the exception id is set. With two arguments, the exception id and exception reason are set. With three arguments, the exception id, exception reason and exception object are set. An exception object represented by the symbol what can also be thrown. This is the method used to re-throw an exception.</p><p><em>Syntax</em></p><p>throw throw what throw "id" throw "id" "reason" throw "id" "reason" "object"</p><p><em>Example</em></p><p>throw throw "type-error" throw "type-error" "invalid argument"</p><p><strong>trans</strong></p><p>The trans special form creates or sets a symbol with an object. trans searches in the current nameset only. If a symbol is found, it is set with the object. If the symbol is not found, it is created in the current nameset. The trans keyword can also be used with qualified names. With 3 or 4 arguments, trans creates automatically a lambda expression.</p><p><em>Syntax</em></p><p>trans symbol "object" trans symbol "argument" "body" trans symbol "argument" "closed variables" "body"</p><p><em>Example</em></p><p>trans a 1 trans fact (n) (if (&lt; n 1) 1 (* n (fact (- n 1))))</p><p><strong>try</strong></p><p>The try special form catch an exception in the current execution nameset. The first argument is a form to execute. The optional second argument is the exception handler to be called in case of exception. If there is no exception handler, all exceptions are caught. The result of execution is either the result of the form execution, or the exception object in case of exception, or nil if the exception is a native one. If there is an exception handler, the handler is executed with a new nameset and the special symbol what is bound to the exception. If the exception is nil, the symbol what is undefined.</p><p><em>Syntax</em></p><p>try "form" try "form" " exception handler"</p><p><em>Example</em></p><p>try (+ 1 2) try (throw) try (throw "hello") try (throw "hello" "world") try (throw "hello" "world" "folks")</p><p><strong>unref</strong></p><p>The unref special form unreference a symbol.</p><p><em>Syntax</em></p><p>unref symbol</p><p><em>Example</em></p><p>const number 123 unref number</p><p><strong>while</strong></p><p>The while special form is used to build loop with backward condition. The loop construct accepts either 2 or 3 arguments. With 2 argument, the first argument is the loop condition and the second argument is the loop body that must evaluate to a boolean. With 3 arguments, the first argument is the initial condition that is executed only once.</p><p><em>Syntax</em></p><p>while "condition" "body" while "initial" "condition" "body"</p><p><em>Example</em></p><p>const gcd (u v) {</p>
<pre>
  while (!= v 0) {
    trans r (u:mod v)
    u:= v
    v:= r
  }
  eval u
</pre>
<p>}</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESERVED OBJECTS</h2>
        <div class="sectioncontent">
<p>This chapter is a reference of the reserved objects with their respective builtin methods. The reserved objects are those objects defined in the global interpreter nameset and bind as reserved names. All literal have a string representation. The to-string method is always available for these reserved objects. A literal object has a default constructor. Generally, it can also be constructed by a same type object or by a string object.</p><p><strong>Literal</strong></p><p>The Literal object is a base object for all literal object. The sole purpose of a literal object is to provide to methods named to-string and to-literal that return a string representation of the literal object.</p><p><em>Predicate</em></p><p>literal-p</p><p><em>Inheritance</em></p><p>Serial</p><p><em>Methods</em></p><p><strong>to-string -&gt; String (none)</strong></p><p>The to-string method returns a string representation of the literal. The string is expected to represent at best the literal.</p><p><strong>to-literal -&gt; String (none)</strong></p><p>The to-literal method returns a string representation of the literal. The string differs from the to-string method in the sense that the string is a literal representation. For example the literal representation of a string is the quoted string.</p><p><strong>Nameable</strong></p><p>The Nameable object is a base object that support name definition. The sole purpose of a literal object is to provide to method named get-name that returns the object name.</p><p><em>Predicate</em></p><p>nameable-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Methods</em></p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the associated object name. The object name defined here is a name that the class wishes to associate with the object. For example, the InputFile is a nameable class and the name is the file name.</p><p><strong>Item</strong></p><p>The Item reserved object is an enumeration item. The item is bound to an enumeration object. An item object is created during the evaluation of an enumeration object. An enumeration item cannot be constructed directly.</p><p><em>Predicate</em></p><p>item-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (Boolean)</strong></p><p>The == operator returns true if the calling object is equal to the boolean argument.</p><p><strong>!= -&gt; Boolean (Boolean)</strong></p><p>The == operator returns true if the calling object is not equal to the boolean argument.</p><p><em>Methods</em></p><p><strong>get-enum -&gt; Enum (none)</strong></p><p>The get-enum method returns the enumeration object bound to the item. The item must be a dynamic item or an exception is thrown.</p><p><strong>Boolean</strong></p><p>The Boolean reserved object implements the behavior of a native boolean type. Two builtin symbols, namely true and false are used to represent the value of a boolean instance. The Boolean type is primarily used for test expression.</p><p><em>Predicate</em></p><p>boolean-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>Boolean (none)</strong></p><p>The Boolean constructor create a boolean object those default value is false.</p><p><strong>Boolean (Boolean)</strong></p><p>The Boolean constructor create a boolean object with the boolean object argument.</p><p><strong>Boolean (String)</strong></p><p>The Boolean constructor create a boolean object with the string object argument. The string "true" denotes the true value while the string "false" denotes the false value.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (Boolean)</strong></p><p>The == operator returns true if the calling object is equal to the boolean argument.</p><p><strong>!= -&gt; Boolean (Boolean)</strong></p><p>The == operator returns true if the calling object is not equal to the boolean argument.</p><p><strong>Number</strong></p><p>The Number reserved objectis a base class for all number objects. The number base object is used by the Integer, Real and Relatif objects. The class provides essentially the methods needed to format a number.</p><p><em>Predicate</em></p><p>number-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Methods</em></p><p><strong>format -&gt; String (none|Integer)</strong></p><p>The format method format the calling number instance with a certain number of digits after the decimal point. In the first form without argument, the default formating representation is performed with a null precision. In the second format, a number is represented with a certain precision given by the calling argument.</p><p><strong>to-hexa -&gt; String (none)</strong></p><p>The to-hexa method returns a signed hexadecimal representation of a number. This method works well with Integer and Relatif objects.</p><p><strong>to-hexa-string -&gt; String (none)</strong></p><p>The to-hexa-string method returns a hexadecimal representation of a number without a prefix. The number is always considered positive. This method works well with Integer and Relatif objects.</p><p><strong>Integer</strong></p><p>The Integer reserved object implements the behavior of a native 64 bits signed integer type. Standard decimal notation is used to construct integer object from a literal. The integer object can also be constructed from a string. Standard operators are provided for this class. The Integer object is a literal object derived from the Number object.</p><p><em>Predicate</em></p><p>integer-p</p><p><em>Inheritance</em></p><p>Number</p><p><em>Constructors</em></p><p><strong>Integer (none)</strong></p><p>The Integer constructor create an integer object those default value is 0.</p><p><strong>Integer (Real)</strong></p><p>The Integer constructor create an integer object with the real object argument those value is truncated to an integer value.</p><p><strong>Integer (Integer)</strong></p><p>The Integer constructor create an integer object with the integer object argument.</p><p><strong>Integer (Character)</strong></p><p>The Integer constructor create an integer object with the character object argument. The character encoding value is used as the integer value.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (Integer|Real)</strong></p><p>The == operator returns true if the calling object is equal to the integer or real argument.</p><p><strong>!= -&gt; Boolean (Integer|Real)</strong></p><p>The != operator returns true if the calling object is not equal to the integer or real argument.</p><p><strong>+ -&gt; Integer (Integer|Real)</strong></p><p>The + operator returns the sum of the calling integer with an integer or a real object.</p><p><strong>- -&gt; Integer (Integer|Real)</strong></p><p>The - operator returns the subtraction of the calling integer with an integer or a real object.</p><p><strong>* -&gt; Integer (Integer|Real)</strong></p><p>The * operator returns the multiplication of the calling integer with an integer or a real object.</p><p><strong>/ -&gt; Integer (Integer|Real)</strong></p><p>The / operator returns the division of the calling integer with an integer or a real object.</p><p><strong>&lt; -&gt; Boolean (Integer|Real)</strong></p><p>The &lt; operator returns true if the calling integer is less than the integer or real object.</p><p><strong>&lt;= -&gt; Boolean (Integer|Real)</strong></p><p>The &lt;= operator returns true if the calling integer is less equal than the integer or real object.</p><p><strong>&gt; -&gt; Boolean (Integer|Real)</strong></p><p>The &gt; operator returns true if the calling integer is greater than the integer or real object.</p><p><strong>&gt;= -&gt; Boolean (Integer|Real)</strong></p><p>The &gt;= operator returns true if the calling integer is greater equal than the integer or real object.</p><p><strong>++ -&gt; Integer (Integer|Real)</strong></p><p>The ++ operator increments the calling integer by 1.</p><p><strong>-- -&gt; Integer (Integer|Real)</strong></p><p>The -- operator decrements the calling integer by 1.</p><p><strong>+= -&gt; Integer (Integer|Real)</strong></p><p>The += operator add and assign the calling integer with an integer or real argument object.</p><p><strong>-= -&gt; Integer (Integer|Real)</strong></p><p>The -= operator subtracts and assign the calling integer with an integer or real argument object.</p><p><strong>*= -&gt; Integer (Integer|Real)</strong></p><p>The *= operator multiply and assign the calling integer with an integer or real argument object.</p><p><strong>/= -&gt; Integer (Integer|Real)</strong></p><p>The /= operator divide and assign the calling integer with an integer or real argument object.</p><p><em>Methods</em></p><p><strong>or -&gt; Integer (Integer)</strong></p><p>The or method returns the binary or between the integer and the integer argument.</p><p><strong>abs -&gt; Integer (none)</strong></p><p>The abs method returns the absolute value of the calling integer instance.</p><p><strong>not -&gt; Integer (none)</strong></p><p>The not method returns the binary negation of the calling integer instance.</p><p><strong>shl -&gt; Integer (Integer)</strong></p><p>The shl method returns a new integer corresponding to the calling integer instance shifted left by the integer argument.</p><p><strong>shr -&gt; Integer (Integer)</strong></p><p>The shr method returns a new integer corresponding to the calling integer instance shifted right by the integer argument.</p><p><strong>and -&gt; Integer (Integer)</strong></p><p>The and method returns a new integer corresponding to the binary and between the calling integer instance and the integer argument.</p><p><strong>xor -&gt; Integer (Integer)</strong></p><p>The xor method returns a new integer corresponding to the binary xor between the calling integer instance and the integer argument.</p><p><strong>mod -&gt; Integer (Integer)</strong></p><p>The mod method returns the modulo between the integer instance and the integer argument. A type-error exception is raised if the argument is not an argument.</p><p><strong>odd-p -&gt; Boolean (none)</strong></p><p>The odd-p method returns true if the integer instance is odd, false otherwise.</p><p><strong>even-p -&gt; Boolean (none)</strong></p><p>The even-p method returns true if the integer instance is even, false otherwise.</p><p><strong>zero-p -&gt; Boolean (none)</strong></p><p>The zero-p method returns true if the integer instance is null, false otherwise.</p><p><strong>Relatif</strong></p><p>The Relatif reserved object implements the behavior of an unlimited signed integer type. Standard decimal notation followed by the 'r' or 'R' character is used to construct relatif object from a literal. The relatif object can also be constructed from a string. This class is similar to the Integer class. The Relatif is a literal object derived from the Number object.</p><p><em>Predicate</em></p><p>relatif-p</p><p><em>Inheritance</em></p><p>Number</p><p><em>Constructors</em></p><p><strong>Relatif (none)</strong></p><p>The Relatif constructor create a relatif object those default value is 0.</p><p><strong>Relatif (Real)</strong></p><p>The Relatif constructor create an relatif object with the real object argument those value is truncated to an integer value.</p><p><strong>Relatif (Relatif)</strong></p><p>The Relatif constructor create an relatif object with the relatif object argument.</p><p><strong>Relatif (Integer)</strong></p><p>The Relatif constructor create an relatif object with the integer object argument.</p><p><strong>Relatif (Character)</strong></p><p>The Relatif constructor create an relatif object with the character object argument. The character encoding value is used as the relatif value.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (Relatif|Integer)</strong></p><p>The == operator returns true if the calling object is equal to the relatif or integer argument.</p><p><strong>!= -&gt; Boolean (Relatif|Integer)</strong></p><p>The == operator returns true if the calling object is not equal to the relatif or integer argument.</p><p><strong>+ -&gt; Relatif (Relatif|Integer)</strong></p><p>The + operator returns the sum of the calling relatif with an relatif or a integer object.</p><p><strong>- -&gt; Relatif (Relatif|Integer)</strong></p><p>The - operator returns the subtraction of the calling relatif with an relatif or a integer object.</p><p><strong>* -&gt; Relatif (Relatif|Integer)</strong></p><p>The * operator returns the multiplication of the calling relatif with an relatif or a integer object.</p><p><strong>/ -&gt; Relatif (Relatif|Integer)</strong></p><p>The / operator returns the division of the calling relatif with an relatif or a integer object.</p><p><strong>&lt; -&gt; Boolean (Relatif|Integer)</strong></p><p>The &lt; operator returns true if the calling relatif is less than the relatif or integer object.</p><p><strong>&lt;= -&gt; Boolean (Relatif|Integer)</strong></p><p>The &lt;= operator returns true if the calling relatif is less equal than the relatif or integer object.</p><p><strong>&gt; -&gt; Boolean (Relatif|Integer)</strong></p><p>The &gt; operator returns true if the calling relatif is greater than the relatif or integer object.</p><p><strong>&gt;= -&gt; Boolean (Relatif|Integer)</strong></p><p>The &gt;= operator returns true if the calling relatif is greater equal than the relatif or integer object.</p><p><strong>++ -&gt; Relatif (Relatif|Integer)</strong></p><p>The ++ operator increments the calling relatif by 1.</p><p><strong>-- -&gt; Relatif (Relatif|Integer)</strong></p><p>The -- operator decrements the calling relatif by 1.</p><p><strong>+= -&gt; Relatif (Relatif|Integer)</strong></p><p>The += operator add and assign the calling relatif with an relatif or integer argument object.</p><p><strong>-= -&gt; Relatif (Relatif|Integer)</strong></p><p>The -= operator subtracts and assign the calling relatif with an relatif or integer argument object.</p><p><strong>*= -&gt; Relatif (Relatif|Integer)</strong></p><p>The *= operator multiply and assign the calling relatif with an relatif or integer argument object.</p><p><strong>/= -&gt; Relatif (Relatif|Integer)</strong></p><p>The /= operator divide and assign the calling relatif with an relatif or integer argument object.</p><p><em>Methods</em></p><p><strong>or -&gt; Relatif (Relatif)</strong></p><p>The or method returns the binary or between the relatif and the relatif argument.</p><p><strong>abs -&gt; Relatif (none)</strong></p><p>The abs method returns the absolute value of the calling relatif instance.</p><p><strong>not -&gt; Relatif (none)</strong></p><p>The not method returns the binary negation of the calling relatif instance.</p><p><strong>shl -&gt; Relatif (Integer)</strong></p><p>The shl method returns a new relatif corresponding to the calling relatif instance shifted left by the integer argument.</p><p><strong>shr -&gt; Relatif (Integer)</strong></p><p>The shr method returns a new relatif corresponding to the calling relatif instance shifted right by the integer argument.</p><p><strong>pow -&gt; Relatif (Integer|Relatif|Integer Integer|Relatif Relatif)</strong></p><p>The pow method returns a new relatif corresponding to the power of the calling relatif instance with the integer or relatif argument. With one argument, the power is computed directly. With two arguments, a fast modular exponentiation is performed with the second argument as the modulus.</p><p><strong>mmi -&gt; Relatif (Integer|Relatif)</strong></p><p>The mmi method returns the multiplicative modular inverse of the calling relatif. The argument is the modulus to use for the inverse calculation.</p><p><strong>and -&gt; Relatif (Relatif)</strong></p><p>The and method returns a new relatif corresponding to the binary and between the calling relatif instance and the relatif argument.</p><p><strong>xor -&gt; Relatif (Relatif)</strong></p><p>The xor method returns a new relatif corresponding to the binary xor between the calling relatif instance and the relatif argument.</p><p><strong>mod -&gt; Relatif (Relatif|Integer)</strong></p><p>The mod method returns the modulo between the relatif instance and the relatif or integer argument. A type-error exception is raised if the argument is invalid.</p><p><strong>odd-p -&gt; Boolean (none)</strong></p><p>The odd-p method returns true if the relatif instance is odd, false otherwise.</p><p><strong>even-p -&gt; Boolean (none)</strong></p><p>The even-p method returns true if the relatif instance is even, false otherwise.</p><p><strong>zero-p -&gt; Boolean (none)</strong></p><p>The zero-p method returns true if the relatif instance is null, false otherwise.</p><p><strong>get-msb -&gt; Integer (none)</strong></p><p>The get-msb method returns the most significnd bit position for the calling relatif. If the number is null, 0 is returned. The msb position is thus counted from 1.</p><p><strong>Real</strong></p><p>The Real reserved object implements the behavior of a double floating point number type. Standard decimal dot notation or scientific notation is used to construct real object from a literal. The real object can also be constructed from an integer, a character or a string. The Real object is a literal object derived from the Number object.</p><p><em>Predicate</em></p><p>real-p</p><p><em>Inheritance</em></p><p>Number</p><p><em>Constructors</em></p><p><strong>Real (none)</strong></p><p>The Real constructor create an real object those default value is 0.0.</p><p><strong>Real (Real)</strong></p><p>The Real constructor create an real object with the real object argument.</p><p><strong>Real (Integer)</strong></p><p>The Real constructor create an real object with the integer object argument.</p><p><strong>Real (Character)</strong></p><p>The Real constructor create an real object with the character object argument. The character encoding value is used as the integer value.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (Integer|Real)</strong></p><p>The == operator returns true if the calling object is equal to the integer or real argument.</p><p><strong>!= -&gt; Boolean (Integer|Real)</strong></p><p>The == operator returns true if the calling object is not equal to the integer or real argument.</p><p><strong>+ -&gt; Real (Integer|Real)</strong></p><p>The + operator returns the sum of the calling real with an integer or a real object.</p><p><strong>- -&gt; Real (Integer|Real)</strong></p><p>The - operator returns the subtraction of the calling real with an integer or a real object.</p><p><strong>* -&gt; Real (Integer|Real)</strong></p><p>The * operator returns the multiplication of the calling real with an integer or a real object.</p><p><strong>/ -&gt; Real (Integer|Real)</strong></p><p>The / operator returns the division of the calling real with an integer or a real object.</p><p><strong>&lt; -&gt; Boolean (Integer|Real)</strong></p><p>The &lt; operator returns true if the calling real is less than the integer or real object.</p><p><strong>&lt;= -&gt; Boolean (Integer|Real)</strong></p><p>The &lt;= operator returns true if the calling real is less equal than the integer or real object.</p><p><strong>&gt; -&gt; Boolean (Integer|Real)</strong></p><p>The &gt; operator returns true if the calling real is greater than the integer or real object.</p><p><strong>&gt;= -&gt; Boolean (Integer|Real)</strong></p><p>The &gt;= operator returns true if the calling real is greater equal than the integer or real object.</p><p><strong>++ -&gt; Real (Integer|Real)</strong></p><p>The ++ operator increments the calling real by 1.</p><p><strong>-- -&gt; Real (Integer|Real)</strong></p><p>The -- operator decrements the calling real by 1.</p><p><strong>+= -&gt; Real (Integer|Real)</strong></p><p>The += operator add and assign the calling real with an integer or real argument object.</p><p><strong>-= -&gt; Real (Integer|Real)</strong></p><p>The -= operator subtracts and assign the calling real with an integer or real argument object.</p><p><strong>*= -&gt; Real (Integer|Real)</strong></p><p>The *= operator multiply and assign the calling real with an integer or real argument object.</p><p><strong>/= -&gt; Real (Integer|Real)</strong></p><p>The += operator divide and assign the calling real with an integer or real argument object.</p><p><em>Methods</em></p><p><strong>nan-p -&gt; Boolean (none)</strong></p><p>The nan-p method returns true if the calling real number instance is not-a-number (nan).</p><p><strong>ceiling -&gt; Real (none)</strong></p><p>The ceiling method returns the ceiling of the calling real number instance.</p><p><strong>floor -&gt; Real (none)</strong></p><p>The floor method returns the floor of the calling real number instance.</p><p><strong>abs -&gt; Real (none)</strong></p><p>The abs method returns the absolute value of the calling real number instance.</p><p><strong>pow -&gt; Real (Real|Integer)</strong></p><p>The pow method returns the power of the calling real with the argument. The exponent argument can be either an integer or a real number.</p><p><strong>sqrt -&gt; Real (none)</strong></p><p>The sqrt method returns the square root of the calling real number instance.</p><p><strong>log -&gt; Real (none)</strong></p><p>The log method returns the natural logarithm of the calling real number instance.</p><p><strong>exp -&gt; Real (none)</strong></p><p>The exp method returns the exponential of the calling real number instance.</p><p><strong>sin -&gt; Real (none)</strong></p><p>The sin method returns the sine of the calling floating point instance. The angle is expressed in radian.</p><p><strong>cos -&gt; Real (none)</strong></p><p>The cos method returns the cosine of the calling floating point instance. The angle is expressed in radian.</p><p><strong>tan -&gt; Real (none)</strong></p><p>The tan method returns the tangent of the calling floating point instance. The angle is expressed in radian.</p><p><strong>asin -&gt; Real (none)</strong></p><p>The asin method returns the arc sine of the calling floating point instance. The result is in radian.</p><p><strong>acos -&gt; Real (none)</strong></p><p>The acos method returns the arc cosine of the calling floating point instance. The result is in radian.</p><p><strong>atan -&gt; Real (none)</strong></p><p>The atan method returns the arc tangent of the calling floating point instance. The result is in radian.</p><p><strong>sinh -&gt; Real (none)</strong></p><p>The sinh method returns the hyperbolic sine of the calling real number instance.</p><p><strong>cosh -&gt; Real (none)</strong></p><p>The cosh method returns the hyperbolic cosine of the calling real number instance.</p><p><strong>tanh -&gt; Real (none)</strong></p><p>The atan method returns the hyperbolic tangent of the calling real number instance.</p><p><strong>asinh -&gt; Real (none)</strong></p><p>The asinh method returns the hyperbolic arc sine of the calling real number instance.</p><p><strong>acosh -&gt; Real (none)</strong></p><p>The acosh method returns the hyperbolic arc cosine of the calling real number instance.</p><p><strong>atanh -&gt; Real (none)</strong></p><p>The atanh method returns the hyperbolic arc tangent of the calling real number instance.</p><p><strong>zero-p -&gt; Boolean (none)</strong></p><p>The zero-p method returns true if the calling real instance is null, false otherwise.</p><p><strong>Character</strong></p><p>The Character reserved object implements the behavior of an Unicode character type. A character can be constructed from a literal quoted notation, with a string or with the U+ hexadecimal notation. The character class is designed to handle the full range of the Unicode character space by using an internal 32 bit quad representation with 31 bit valid. The Character class conform also with the ISO 10646 character representation.</p><p><em>Predicate</em></p><p>character-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>Character (none)</strong></p><p>The Character constructor create a character object those default value is the null character.</p><p><strong>Character (String)</strong></p><p>The Character constructor create a character object with the string object argument.</p><p><strong>Character (Integer)</strong></p><p>The Character constructor create a character object with the integer object argument.</p><p><strong>Character (Character)</strong></p><p>The Character constructor create a character object with the character object argument.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (Character)</strong></p><p>The == operator returns true if the calling object is equal to the character argument.</p><p><strong>!= -&gt; Boolean (Character)</strong></p><p>The != operator returns true if the calling object is not equal to the character argument.</p><p><strong>&lt; -&gt; Boolean (Character)</strong></p><p>The &lt; operator returns true if the calling character is less than the character object.</p><p><strong>&lt;= -&gt; Boolean (Character)</strong></p><p>The &lt;= operator returns true if the calling character is less equal than the character object.</p><p><strong>&gt; -&gt; Boolean (Character)</strong></p><p>The &gt; operator returns true if the calling character is greater than the character object.</p><p><strong>&gt;= -&gt; Boolean (Character)</strong></p><p>The &gt;= operator returns true if the calling character is greater equal than the character object.</p><p><strong>++ -&gt; Character (Character)</strong></p><p>The ++ operator increments the calling character by the next one in lexicographic order.</p><p><strong>-- -&gt; Character (Character)</strong></p><p>The -- operator decrements the calling character by the previous one in lexicographic order.</p><p><strong>+= -&gt; Character (Integer)</strong></p><p>The += operator add the integer argument to the calling character.</p><p><strong>-= -&gt; Character (Integer)</strong></p><p>The -= operator subtracts the integer argument to the calling character.</p><p><em>Methods</em></p><p><strong>letter-p -&gt; Boolean (none)</strong></p><p>The letter-p predicate returns true if the character is a letter character, false otherwise.</p><p><strong>digit-p -&gt; Boolean (none)</strong></p><p>The digit-p predicate returns true if the character is a digit character, false otherwise.</p><p><strong>alpha-p -&gt; Boolean (none)</strong></p><p>The alpha-p predicate returns true if the character is an alphanumeric character, false otherwise.</p><p><strong>blank-p -&gt; Boolean (none)</strong></p><p>The blank-p predicate returns true if the character is a blank or tab character, false otherwise.</p><p><strong>eol-p -&gt; Boolean (none)</strong></p><p>The eol-p predicate returns true if the character is an end-of-line character, false otherwise.</p><p><strong>eos-p -&gt; Boolean (none)</strong></p><p>The eos-p predicate returns true if the character is an end-of-stream character, false otherwise.</p><p><strong>nil-p -&gt; Boolean (none)</strong></p><p>The nil-p predicate returns true if the character is the nil character, false otherwise.</p><p><strong>to-integer -&gt; Integer (none)</strong></p><p>The to-integer method returns an integer representation of the characters.</p><p><strong>Byte</strong></p><p>The Byte reserved object implements the behavior of an 8 bit character type. A byte can be constructed from a integer or from another byte. The Byte class is similar to the Character class but is not a literal object because it does not have a literal representation. Most of the time, a byte object is created by another object like a stream, when using the read method for example.</p><p><em>Predicate</em></p><p>byte-p</p><p><em>Inheritance</em></p><p>Serial</p><p><em>Constructors</em></p><p><strong>Byte (none)</strong></p><p>The Byte constructor create a byte object those default value is the null byte.</p><p><strong>Byte (Integer)</strong></p><p>The Byte constructor create a byte object with the integer object argument. The integer value must be in the range of 0x00 to 0xFF.</p><p><strong>Byte (Byte)</strong></p><p>The Byte constructor create a byte object with the byte object argument.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (Byte)</strong></p><p>The == operator returns true if the calling object is equal to the byte argument.</p><p><strong>!= -&gt; Boolean (Byte)</strong></p><p>The != operator returns true if the calling object is not equal to the byte argument.</p><p><strong>&lt; -&gt; Boolean (Byte)</strong></p><p>The &lt; operator returns true if the calling byte is less than the byte object.</p><p><strong>&lt;= -&gt; Boolean (Byte)</strong></p><p>The &lt;= operator returns true if the calling byte is less equal than the byte object.</p><p><strong>&gt; -&gt; Boolean (Byte)</strong></p><p>The &gt; operator returns true if the calling byte is greater than the byte object.</p><p><strong>&gt;= -&gt; Boolean (Byte)</strong></p><p>The &gt;= operator returns true if the calling byte is greater equal than the byte object.</p><p><strong>++ -&gt; Byte (Byte)</strong></p><p>The ++ operator increments the calling byte by one.</p><p><strong>-- -&gt; Byte (Byte)</strong></p><p>The -- operator decrements the calling byte by one.</p><p><strong>+= -&gt; Byte (Integer)</strong></p><p>The += operator adds the integer argument to the calling byte.</p><p><strong>-= -&gt; Byte (Integer)</strong></p><p>The -= operator subtracts the integer argument to the calling byte.</p><p><em>Methods</em></p><p><strong>eos-p -&gt; Boolean (none)</strong></p><p>The eos-p predicate returns true if the character is an end-of-stream character, false otherwise.</p><p><strong>nil-p -&gt; Boolean (none)</strong></p><p>The nil-p predicate returns true if the byte is the nil byte, false otherwise.</p><p><strong>to-integer -&gt; Integer (none)</strong></p><p>The to-integer method returns an integer representation of the byte.</p><p><strong>to-char -&gt; Character (none)</strong></p><p>The to-char method returns a character representing the byte.</p><p><strong>String</strong></p><p>The String reserved object implements the behavior of an internal character array. The double quote notation is the literal notation for a string. A string can also be constructed from the standard objects. Strings can be compared, transformed or extracted with the help of the methods listed below. Internally, the string is represented as an array of Unicode characters.</p><p><em>Predicate</em></p><p>string-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>String (none)</strong></p><p>The String constructor create a string object those default value is the null string.</p><p><strong>String (Literal)</strong></p><p>The String constructor create a string object with the literal object argument.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (String)</strong></p><p>The == operator returns true if the calling object is equal to the string argument.</p><p><strong>!= -&gt; Boolean (String)</strong></p><p>The != operator returns true if the calling object is not equal to the string argument.</p><p><strong>&lt; -&gt; Boolean (String)</strong></p><p>The &lt; operator returns true if the calling string is less than the string argument.</p><p><strong>&lt;= -&gt; Boolean (String)</strong></p><p>The &lt;= operator returns true if the calling string is less equal than the string argument.</p><p><strong>&gt; -&gt; Boolean (String)</strong></p><p>The &gt; operator returns true if the calling string is greater than the string argument.</p><p><strong>&gt;= -&gt; Boolean (String)</strong></p><p>The &gt;= operator returns true if the calling string is greater equal than the string argument.</p><p><strong>+ -&gt; String (String)</strong></p><p>The + operator returns the sum of the calling string with an string object.</p><p><strong>+= -&gt; String (String)</strong></p><p>The += operator add and assign the calling string with the string argument.</p><p><em>Methods</em></p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the string.</p><p><strong>first -&gt; Character (none)</strong></p><p>The first method returns the first character in the string.</p><p><strong>last -&gt; Character (none)</strong></p><p>The last method returns the last character in the string.</p><p><strong>strip-left -&gt; String (none|String)</strong></p><p>The strip-left method removes the leading blanks and tabs and returns a new string. With a string argument, each character in the string is taken as a character separator that should be stripped.</p><p><strong>strip-right -&gt; String (none|String)</strong></p><p>The strip-right method removes the trailing blanks and tabs and returns a new string.With a string argument, each character in the string is taken as a character separator that should be stripped.</p><p><strong>strip -&gt; String (none|String)</strong></p><p>The strip method removes the leading, trailing blanks and tabs and returns a new string. With a string argument, each character in the string is taken as a character separator that should be stripped.</p><p><strong>split -&gt; Vector (none|String)</strong></p><p>The split method split the string into one or more string according to break sequence. If no argument is passed to the call, the break sequence is assumed to be a blank, tab and eol characters.</p><p><strong>extract -&gt; Vector (Character)</strong></p><p>The extract method extracts one or more string which are enclosed by a control character passed as an argument. The method returns a vector of strings.</p><p><strong>to-upper -&gt; String (none)</strong></p><p>The to-upper converts all string characters to upper case and returns a new string.</p><p><strong>to-lower -&gt; String (none)</strong></p><p>The to-lower method converts all string characters to lower case and returns a new string.</p><p><strong>get -&gt; Character (Integer)</strong></p><p>The get method returns a the string character at the position given by the argument. If the index is invalid, an exception is raised.</p><p><strong>sub-left -&gt; String (Integer)</strong></p><p>The sub-left method returns the left sub string of the calling string up-to the argument index. If the index is out of range, the string is returned.</p><p><strong>sub-right -&gt; String (Integer)</strong></p><p>The sub-right method returns the right sub string of the calling string starting at the argument index. If the index is out of range, the string is returned.</p><p><strong>fill-left -&gt; String (Character Integer)</strong></p><p>The fill-left method returns a string filled on the left with the character argument. The second argument is the desired length of the resulting string. If the calling is too long, the string is returned.</p><p><strong>fill-right -&gt; String (Character Integer)</strong></p><p>The fill-left method returns a string filled on the right with the character argument. The second argument is the desired length of the resulting string. If the calling is too long, the string is returned.</p><p><strong>substr -&gt; String (Integer Integer)</strong></p><p>The substr method returns a string starting at the first argument index and ending at the second argument index. If the indexes are out of range, an exception is raised.</p><p><strong>Regex</strong></p><p>The Regex object is a special object which is automatically instantiated by the interpreter when using the delimiter character [ and ]. The regex syntax involves the use of standard characters, meta characters and control characters. Additionally, a string can be use to specify a series of characters. In its first form, the [ and ] characters are used as syntax delimiters. The lexical analyzer automatically recognizes this token as a regex and built the equivalent Regex object. The second form is the explicit construction of the Regex object. Note also that the [ and ] characters are also used as regex block delimiters. Any character, except the one used as operators can be used in a regex. The $ character is used as a meta-character -- or control character -- to represent a particular set of characters. For example, [hello world] is a regex which match only the "hello world" string. The [$d+] regex matches one or more digits. The following control characters are builtin in the regex engine.</p><table class="table table-striped">
<tr>
<th>Character</th>
<th>Description</th></tr>

<tr>
<td>$a</td>
<td>matches any letter or digit</td></tr>

<tr>
<td>$b</td>
<td>matches any blank characters</td></tr>

<tr>
<td>$c</td>
<td>matches any combining characters</td></tr>

<tr>
<td>$d</td>
<td>matches any digit</td></tr>

<tr>
<td>$e</td>
<td>matches eol, cr and eos</td></tr>

<tr>
<td>$l</td>
<td>matches any lower case letter</td></tr>

<tr>
<td>$n</td>
<td>matches eol or cr</td></tr>

<tr>
<td>$s</td>
<td>matches any letter</td></tr>

<tr>
<td>$u</td>
<td>matches any upper case letter</td></tr>

<tr>
<td>$v</td>
<td>matches any valid constituent</td></tr>

<tr>
<td>$w</td>
<td>matches any word constituent</td></tr>

<tr>
<td>$x</td>
<td>matches any hexadecimal characters</td></tr>
</table><p>The uppercase version is the complement of the corresponding lowercase character set. A character which follows a $ character and that is not a meta character is treated as a normal character. For example $[ is the [ character. A quoted string can be used to define character matching which could otherwise be interpreted as control characters or operator. A quoted string also interprets standard escaped sequences but not meta characters.</p><table class="table table-striped">
<tr>
<th>Character</th>
<th>Description</th></tr>

<tr>
<td>$A</td>
<td>any character except letter or digit</td></tr>

<tr>
<td>$B</td>
<td>any character except blank characters</td></tr>

<tr>
<td>$C</td>
<td>any character except combining characters</td></tr>

<tr>
<td>$D</td>
<td>any character except digit</td></tr>

<tr>
<td>$E</td>
<td>any character except eol, cr and eos</td></tr>

<tr>
<td>$L</td>
<td>any character except lower case letter</td></tr>

<tr>
<td>$N</td>
<td>any character except eol or cr</td></tr>

<tr>
<td>$S</td>
<td>any character except letter</td></tr>

<tr>
<td>$U</td>
<td>any character except upper case letter</td></tr>

<tr>
<td>$V</td>
<td>any character except constituent</td></tr>

<tr>
<td>$W</td>
<td>any character except word constituent</td></tr>

<tr>
<td>$X</td>
<td>any character except hex characters</td></tr>
</table><p>A character set is defined with the &lt; and &gt; characters. Any enclosed character defines a character set. Note that meta characters are also interpreted inside a character set. For example, &lt;$d+-&gt; represents any digit or a plus or minus. If the first character is the ^ character in the character set, the character set is complemented with regards to its definition. The following unary operators can be used with single character, control characters and sub-expressions.</p><table class="table table-striped">
<tr>
<th>Operator</th>
<th>Description</th></tr>

<tr>
<td>*</td>
<td>match 0 or more times</td></tr>

<tr>
<td>+</td>
<td>match 1 or more times</td></tr>

<tr>
<td>?</td>
<td>match 0 or 1 time</td></tr>

<tr>
<td>|</td>
<td>alternation</td></tr>
</table><p>Alternation is an operator which work with a secondary expression. Care should be taken when writing the right sub-expression. For example the following regex [$d|hello] is equivalent to [[$d|h]ello]. In other word, the minimal first sub-expression is used when compiling the regex.</p><p><em>Predicate</em></p><p>regex-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>Regex (none)</strong></p><p>The Regex constructor create a regex object those default value is the null regex.</p><p><strong>Regex (String)</strong></p><p>The Regex constructor create a regex object with the string object argument. The string argument is the regex specification.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (String)</strong></p><p>The == operator returns true if the argument is matched by the regex.</p><p><strong>!= -&gt; Boolean (String)</strong></p><p>The != operator returns true if the argument is not matched by the regex.</p><p><strong>&lt; -&gt; Boolean (String)</strong></p><p>The &lt; operator returns true if the argument is partially matched by the regex.</p><p><em>Methods</em></p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the group vector when a regex match has been successful.</p><p><strong>get -&gt; String (Integer)</strong></p><p>The get method returns by index the group sub-string when a regex match has been successful.</p><p><strong>match -&gt; String (String)</strong></p><p>The match method returns the first matching string of the argument string.</p><p><strong>replace -&gt; String (String String)</strong></p><p>The replace method returns a string constructed by replacing all matching sub-string -- from the first argument -- with the second argument string.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTAINER OBJECTS</h2>
        <div class="sectioncontent">
<p>This chapter is a reference of the reserved container objects with their respective builtin methods. Some of these container objects are iterable objects. When an object is iterable, an iterator constructor constructor is provided. The iterable-p predicate returns true if the container is an iterable object. The get-iterator method can be used to construct an object iterator. For a given iterator, the predicates end-p and valid-p can be used to check for the end or a valid iterator position. The next method move the iterator to its next position. The prev method move the iterator -- if possible -- to its previous position. The get-object method returns the object at the current iterator position.</p><p><strong>Cons</strong></p><p>A Cons instance or simply a cons cell is a simple element used to build linked list. The cons cell holds an object and a pointer to the next cons cell. The cons cell object is called car and the next cons cell is called the cdr. Historically, car means Current Address Register and cdr means Current Data Register. This notation is still present here for the sake of tradition.</p><p><em>Predicate</em></p><p>cons-p</p><p><em>Inheritance</em></p><p>SerialIterable</p><p><em>Constructors</em></p><p><strong>Cons (none)</strong></p><p>The Cons constructor create a default cons cell with the car and cdr set to nil.</p><p><strong>Cons (Objects...)</strong></p><p>The Cons constructor create a list of cons cells with the object arguments. Each argument object is assigned to the car of the cons cell while the cdr is used to link the cell together.</p><p><em>Methods</em></p><p><strong>get-car -&gt; Object (none)</strong></p><p>The get-car method returns the car of the calling cons cell.</p><p><strong>get-cdr -&gt; Cons (none)</strong></p><p>The get-cdr method returns the cdr of the calling cons cell.</p><p><strong>get-cadr -&gt; Object (none)</strong></p><p>The get-cadr method returns the car of the cdr of the calling cons cell or nil if the cdr is nil.</p><p><strong>get-caddr -&gt; Object (none)</strong></p><p>The get-caddr method returns the car of the cdr of the cdr of the calling cons cell or nil if the cdr is nil.</p><p><strong>get-cadddr -&gt; Object (none)</strong></p><p>The get-cadddr method returns the car of the cdr of the cdr of the cdr of the calling cons cell or nil if the cdr is nil.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the cons cell. The minimum length returned is always 1.</p><p><strong>nil-p -&gt; Boolean (none)</strong></p><p>The nil-p predicate returns true if the car of the calling cons cell is nil, false otherwise.</p><p><strong>block-p -&gt; Boolean (none)</strong></p><p>The block-p predicate returns true if the cons cell is of type block, false otherwise.</p><p><strong>get-iterator -&gt; Iterator (none)</strong></p><p>The get-iterator returns a forward iterator for this cons cell. No backward methods are supported for this object.</p><p><strong>set-car -&gt; Object (Object)</strong></p><p>The set-car set the car of the calling cons cell. The object argument is returned by the method.</p><p><strong>set-cdr -&gt; Cons (Cons)</strong></p><p>The set-cdr set the cdr of the calling cons cell. The cons cell argument is returned by the method.</p><p><strong>add -&gt; Object (Object)</strong></p><p>The add method appends an object at the end of the cons cell chain by creating a new cons cell and linking it with the last cdr. The object argument is returned by this method.</p><p><strong>get -&gt; Object (Integer)</strong></p><p>The get method returns the car of the cons cell chain at a certain position specified by the integer index argument.</p><p><strong>Enum</strong></p><p>The Enum builtin object is an enumeration object. The enumeration is constructed with the reserved keyword enum and a list of literals or by string name with a constructor.</p><p><em>Predicate</em></p><p>enum-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Enum (none)</strong></p><p>The Enum constructor create an empty enumeration.</p><p><strong>Enum (String...)</strong></p><p>The Enum constructor create an enumeration from a list of string arguments.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method resets the enumeration and makes it empty.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of items in the enumeration.</p><p><strong>exists-p -&gt; Boolean (String)</strong></p><p>The exists-p predicate returns true if the name argument exists as an item. The name argument must be a lexical name or an exception is thrown.</p><p><strong>add -&gt; none (String)</strong></p><p>The add method adds a new item to the enumeration by name. This method returns nil.</p><p><strong>get -&gt; String (Integer)</strong></p><p>The get method returns an item string representation by index. The integer argument is the item index.</p><p><strong>List</strong></p><p>The List builtin object provides the facility of a double-link list. The List object is another example of iterable object. The List object provides support for forward and backward iteration.</p><p><em>Predicate</em></p><p>list-p</p><p><em>Inheritance</em></p><p>Iterable</p><p><em>Constructors</em></p><p><strong>List (none)</strong></p><p>The List constructor create an empty list.</p><p><strong>List (Object...)</strong></p><p>The List constructor create a list from a list of object arguments.</p><p><em>Methods</em></p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the list. The minimum length is 0 for an empty list.</p><p><strong>get-iterator -&gt; Iterator (none)</strong></p><p>The get-iterator returns a forward/backward iterator for this list.</p><p><strong>add -&gt; Object (Object)</strong></p><p>The add method appends an object at the end of the list. The object argument is returned by this method.</p><p><strong>insert -&gt; Object (Object)</strong></p><p>The insert method inserts an object at the beginning of the list. The object argument is returned by this method.</p><p><strong>get -&gt; Object (Integer)</strong></p><p>The get method returns the object in the list at a certain position specified by the integer index argument.</p><p><strong>Strvec</strong></p><p>The Strvec builtin object provides the facility of an index array of strings. The Strvec object is serializable object that stores strings. The strings can be added with an optional preference for a unique string value. The class is similar to the general purpose Vector class.</p><p><em>Predicate</em></p><p>strvec-p</p><p><em>Inheritance</em></p><p>Serial</p><p><em>Constructors</em></p><p><strong>Strvec (none)</strong></p><p>The Strvec constructor create an empty string vector.</p><p><strong>Strvec (Integer|Boolean)</strong></p><p>The Strvec constructor create a string vector with a predefined size or with a uniq flag. In the first form, the preferred vector size is given as an argument. In the second form, the string unicity flag is given as an argument.</p><p><strong>Strvec (Integer Boolean)</strong></p><p>The Strvec constructor create a string vector with a predefined size and a uniq flag. The first argument is the preferred vector size. The second argument is the string unicity flag.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method resets the string vector. When the method is complete, the string vector is empty.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the string vector. The minimum length is 0 for an empty vector.</p><p><strong>min-length -&gt; Integer (none)</strong></p><p>The min-length method returns the minimum string length of the string vector.</p><p><strong>max-length -&gt; Integer (none)</strong></p><p>The max-length method returns the maximum string length of the string vector.</p><p><strong>empty-p -&gt; Boolean (none)</strong></p><p>The empty-p predicate returns true if the vector is empty.</p><p><strong>active-p -&gt; Boolean (none)</strong></p><p>The active-p predicate returns true if the vector is not empty. This predicate is the negation of the empty-p predicate.</p><p><strong>get -&gt; String (Integer)</strong></p><p>The get method returns the string in the vector at a certain position specified by the integer index argument.</p><p><strong>set -&gt; none (Integer String)</strong></p><p>The set method set a vector position with a string. The first argument is the vector index. The second argument is the string to set.</p><p><strong>first -&gt; String (none)</strong></p><p>The first method returns the first string in the vector.</p><p><strong>last -&gt; String (none)</strong></p><p>The last method returns the last string in the vector.</p><p><strong>pop -&gt; Object (none)</strong></p><p>The pop method removes the first element in the string vector and returns it.</p><p><strong>pop-last -&gt; String (none)</strong></p><p>The pop-last method removes the last element in the string vector and returns it.</p><p><strong>find -&gt; Integer (String)</strong></p><p>The find method try to find a string in the vector. If the string is found, the vector index is returned else the -1 value is returned.</p><p><strong>lookup -&gt; Integer (String)</strong></p><p>The lookup method try to find a string in the vector. If the string is found, the vector index is returned else an exception is raised.</p><p><strong>add -&gt; none (String)</strong></p><p>The add method adds an object at the end of the vector. If the uniq flag is active, the string argument is not added if it already exists.</p><p><strong>exists-p -&gt; Boolean (String)</strong></p><p>The exists-p method returns true if the string argument exists in the vector.</p><p><strong>remove -&gt; none (Integer|String)</strong></p><p>The remove method removes a string from the vector by index or value. In the first form, the vector index is used as the place to remove. In the second form, the string argument is used as a key for removal. This method repacks the vector when the string has been removed.</p><p><strong>set-unique -&gt; none (Boolean)</strong></p><p>The set-unique method set the string vector unique flag. When the unique flag is set, there is only no string duplicate in the vector.</p><p><strong>get-unique -&gt; Boolean</strong></p><p>The get-unique method returns the string vector unique flag value.</p><p><strong>concat -&gt; String (none | Character)</strong></p><p>The concat method concatenates the string vector elements with a character separator. In the first form, with a separator character, the resulting string is the concatenation of the string vector elements. In the second form, the resulting string is the concatenation of the vector elements with a character separator. If the character separator is nil then no separator is placed.</p><p><strong>Vector</strong></p><p>The Vector builtin object provides the facility of an index array of objects. The Vector object is another example of iterable object. The Vector object provides support for forward and backward iteration.</p><p><em>Predicate</em></p><p>vector-p</p><p><em>Inheritance</em></p><p>SerialIterable</p><p><em>Constructors</em></p><p><strong>Vector (none)</strong></p><p>The Vector constructor create an empty vector.</p><p><strong>Vector (Object...)</strong></p><p>The Vector constructor create a vector from a list of object arguments.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the vector. When the method is complete, the vector is empty.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the vector. The minimum length is 0 for an empty vector.</p><p><strong>empty-p -&gt; Boolean (none)</strong></p><p>The empty-p predicate returns true if the vector is empty.</p><p><strong>get -&gt; Object (Integer)</strong></p><p>The get method returns the object in the vector at a certain position specified by the integer index argument.</p><p><strong>set -&gt; Object (Integer Object)</strong></p><p>The set method set a vector position with an object. The first argument is the vector index. The second argument is the object to set. The method returns the object to set.</p><p><strong>first -&gt; Object (none)</strong></p><p>The first method returns the first element in the vector.</p><p><strong>last -&gt; Object (none)</strong></p><p>The last method returns the last element in the vector.</p><p><strong>pop -&gt; Object (none)</strong></p><p>The pop method removes the first element in the vector and returns it.</p><p><strong>pop-last -&gt; Object (none)</strong></p><p>The pop-last method removes the last element in the vector and returns it.</p><p><strong>find -&gt; Integer (Object)</strong></p><p>The find method try to find an object in the vector. If the object is found, the vector index is returned as an Integer object, else nilp is returned.</p><p><strong>add -&gt; Object (Object|Integer Object)</strong></p><p>The add method appends an object at the end of the vector or at a certain index. In the first form, the object argument is added at the end of the vector. In the second form, the object argument is inserted in the vector at the specified index. In both cases, the object argument is returned by this method.</p><p><strong>exists-p -&gt; Boolean (Object)</strong></p><p>The exists-p method returns true if the object argument exists in the vector. This method is useful to make sure that only one occurrence of an object is added to a vector.</p><p><strong>clean -&gt; none (Integer)</strong></p><p>The clean method removes an object from the vector by index and repack the vector.</p><p><strong>remove -&gt; none (Object)</strong></p><p>The remove method removes an object from the vector and repack the vector. If duplicate exists in the file, only one is removed.</p><p><strong>get-iterator -&gt; Iterator (none)</strong></p><p>The get-iterator returns a forward/backward iterator for this vector.</p><p><strong>HashTable</strong></p><p>The HashTable builtin object is a container object which maps an object with a name. The hash table is dynamic and get resized automatically when needed. The lookup method throw an exception if the name is not found. The get method returns nilp if the object is not found.</p><p><em>Predicate</em></p><p>hashtable-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>HashTable (none)</strong></p><p>The HashTable constructor create an empty table.</p><p><strong>HashTable (Integer)</strong></p><p>The HashTable constructor create a table with a specific size.</p><p><em>Methods</em></p><p><strong>add -&gt; none (String Object)</strong></p><p>The add method adds a new object in the table by key. The first argument is the key used to associate the object in the table. The second argument is the object to add.</p><p><strong>length -&gt; Object (none)</strong></p><p>The length returns the number of objects in the table.</p><p><strong>empty-p -&gt; Boolean (none)</strong></p><p>The empty-p predicate returns true if the table is empty.</p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method resets the table so that it becomes empty.</p><p><strong>get -&gt; Object (String)</strong></p><p>The get method returns the object associated with a key. If the key is not found, nil is returned.</p><p><strong>lookup -&gt; Object (String)</strong></p><p>The lookup method returns the object associated with a key. If the key is not found, an exception is raised.</p><p><strong>get-key -&gt; String (Integer)</strong></p><p>The get-key method returns the key associated with an entry in the table by index. If the index is out of range, an exception is raised.</p><p><strong>get-object -&gt; Object (Integer)</strong></p><p>The get-object method returns the object associated with an entry in the table by index. If the index is out of range, an exception is raised.</p><p><strong>Set</strong></p><p>The Set builtin object provides the facility of a uniform set of objects. The Set object is another example of iterable object. The Set object provides support for forward and backward iteration.</p><p><em>Predicate</em></p><p>set-p</p><p><em>Inheritance</em></p><p>SerialIterable</p><p><em>Constructors</em></p><p><strong>Set (none)</strong></p><p>The Set constructor create an empty set.</p><p><strong>Set (Object...)</strong></p><p>The Set constructor create a set from a list of object arguments.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the set. When the method is complete, the set is empty.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of elements in the set. The minimum length is 0 for an empty set.</p><p><strong>add -&gt; Object (Object)</strong></p><p>The add method appends an object in the set. If the object already exists in the set, it is not added twice. This is the main difference between a set and a vector. The object argument is returned by this method.</p><p><strong>get -&gt; Object (Integer)</strong></p><p>The get method return object by index.</p><p><strong>empty-p -&gt; Boolean (Object)</strong></p><p>The empty-p predicate returns true if the set is empty.</p><p><strong>exists-p -&gt; Boolean (Object)</strong></p><p>The exists predicate returns true if the object argument exists in the set.</p><p><strong>merge -&gt; none (Set)</strong></p><p>The merge method merges the set argument into the calling set. If an element already exists in the set, it is not added.</p><p><strong>remix -&gt; none (Integer)</strong></p><p>The remix method mixes the set by randomly swapping all the elements. This method is useful when the set has been filled with a certain order by the access must be done randomly.</p><p><strong>remove -&gt; Boolean (Object)</strong></p><p>The remove method removes the object argument from the set. if the object is removed, the method returns true. If the object is not in the set, the method returns false.</p><p><strong>get-random-subset -&gt; Set (Integer)</strong></p><p>The get-random-subset method returns a subset those cardinal is at least the size argument with a set of randomly chosen elements. The result set might have a cardinal less than the requested size if the calling set cardinal is less than the requested size.</p><p><strong>get-iterator -&gt; Iterator (none)</strong></p><p>The get-iterator returns an iterator for this set. The iterator supports forward and backward iteration.</p><p><strong>Queue</strong></p><p>The Queue builtin object is a container used to queue and dequeue objects. The order of entry in the queue defines the order of exit from the queue. The queue is constructed either empty or with a set of objects.</p><p><em>Predicate</em></p><p>queue-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Queue (none)</strong></p><p>The Queue constructor create an empty queue.</p><p><strong>Queue (Object...)</strong></p><p>The Queue constructor create a queue with a list of object arguments</p><p><em>Methods</em></p><p><strong>enqueue -&gt; Object (Object)</strong></p><p>The enqueue adds an object in the queue and returns the queued object.</p><p><strong>dequeue -&gt; Object (none)</strong></p><p>The dequeue dequeue an object in the order it was queued.</p><p><strong>length -&gt; Object (none)</strong></p><p>The length returns the number of queued objects.</p><p><strong>empty-p -&gt; Boolean (none)</strong></p><p>The empty-p method returns true if the queue is empty.</p><p><strong>flush -&gt; none (none)</strong></p><p>The flush method flushes the queue so that it is empty.</p><p><strong>Heap</strong></p><p>The Heap builtin object is an object based heap class that organizes object with respect to a key. The heap is organized as a binary tree those root element is either the object with the highest or the lowest key. A flag controls whether the heap is operating in ascending or descending mode. By default, the heap operates in ascending mode, which means that the root node is the lowest one. The heap is self-resizable. The object insertion is also controlled by a minimum and maximum key. if the key is below the minimum key or above the maximum key, the object is not inserted.</p><p><em>Predicate</em></p><p>heap-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Heap (none)</strong></p><p>The Heap constructor create an empty heap. By default the heap operates in ascending mode.</p><p><strong>Heap (Integer)</strong></p><p>The Heap constructor create a heap with a specific size. By default the heap operates in ascending mode.</p><p><strong>Heap (Boolean)</strong></p><p>The Heap constructor create a heap with a specific mode. If the mode is true, the heap operates in ascending order. If the mode is false, the heap operates in descending order. In ascending order, the first object is the object with the lowest key.</p><p><strong>Heap (Integer Boolean)</strong></p><p>The Heap constructor create a heap with a specific size and mode. The first argument is the heap size. The second argument is the heap mode. If the mode is true, the heap operates in ascending order. If the mode is false, the heap operates in descending order. In ascending order, the first object is the object with the lowest key.</p><p><em>Methods</em></p><p><strong>add -&gt; none (Integer Object)</strong></p><p>The add method adds a new object in the heap by key. The first argument is the key used to set the object position in the heap. The second argument is the object to add.</p><p><strong>pop -&gt; Object (none)</strong></p><p>The pop pops the first available in the heap. If the heap is empty, an exception is raised.</p><p><strong>length -&gt; Object (none)</strong></p><p>The length returns the number of objects in the heap.</p><p><strong>empty-p -&gt; Boolean (none)</strong></p><p>The empty-p method returns true if the heap is empty.</p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the heap so that it becomes empty.</p><p><strong>get-key -&gt; Integer (Integer)</strong></p><p>The get-key method returns the key associated with an entry in the heap by index. If the index is out of range, an exception is raised.</p><p><strong>get-object -&gt; Object (Integer)</strong></p><p>The get-object method returns the object associated with an entry in the heap by index. If the index is out of range, an exception is raised.</p><p><strong>get-mode -&gt; Boolean (none)</strong></p><p>The get-mode method returns the heap operating mode. If the mode is true, the heap operates in ascending order. If the mode is false, the heap operates in descending order. In ascending order, the first object is the object with the lowest key.</p><p><strong>min-key-p -&gt; Boolean (none)</strong></p><p>The min-key-p predicate returns true if a minimum key has been set. The get-min-key method can be used to retrieve the minimum key value.</p><p><strong>max-key-p -&gt; Boolean (none)</strong></p><p>The max-key-p predicate returns true if a maximum key has been set. The get-max-key method can be used to retrieve the maximum key value.</p><p><strong>reset-min-key -&gt; none (none)</strong></p><p>The reset-min-key method resets the minimum key flag and value.</p><p><strong>reset-max-key -&gt; none (none)</strong></p><p>The reset-max-key method resets the maximum key flag and value.</p><p><strong>set-min-key -&gt; none (Integer)</strong></p><p>The set-min-key method sets the minimum key value.</p><p><strong>get-min-key -&gt; Integer (none)</strong></p><p>The get-min-key method returns the minimum key value.</p><p><strong>set-max-key -&gt; none (Integer)</strong></p><p>The set-max-key method sets the maximum key value.</p><p><strong>get-max-key -&gt; Integer (none)</strong></p><p>The get-max-key method returns the maximum key value.</p><p><strong>resize -&gt; none (none)</strong></p><p>The resize method resize the heap with a new size. if the size is lower than the number of elements, the procedure does nothing.</p><p><strong>Bitset</strong></p><p>The Bitset builtin object is a container for multi bit storage. The size of the bitset is determined at construction. With the use of an index, a particular bit can be set, cleared and tested.</p><p><em>Predicate</em></p><p>bitset-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Bitset (none)</strong></p><p>The BitSet constructor create an empty bitset.</p><p><strong>Bitset (Integer)</strong></p><p>The Bitset constructor create a bitset those size is given by the integer argument.</p><p><strong>Bitset (String)</strong></p><p>The Bitset constructor create a bitset by parsing the string argument. The string can be either in the normal binary form with or without the 0b prefix or in hexadecimal form with the 0x prefix.</p><p><strong>Bitset (Buffer Boolean)</strong></p><p>The Bitset constructor create a bitset from a buffer content. Each byte in the buffer is to be placed in the bitset. The boolean argument is the ascending flag. When true the buffer bytes are used in ascending index order, thus making the fist byte in the buffer to be used as the first right byte in the bitset. When false, the buffer bytes are used in descending index order, thus making the last byte in the buffer to be used as the first byte in the bitset.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the bitset and force the initial size to 0.</p><p><strong>marked-p -&gt; Boolean (Integer)</strong></p><p>The marked-p predicate returns true if the bit is set at the index argument.</p><p><strong>clear -&gt; none (Integer)</strong></p><p>The clear method clears a bit by the index argument.</p><p><strong>mark -&gt; none (Integer)</strong></p><p>The mark method marks a bit by the index argument.</p><p><strong>mark -&gt; none (Integer Boolean)</strong></p><p>The mark method set the bit value by the index argument with the boolean second argument.</p><p><strong>add -&gt; none (Integer Boolean)</strong></p><p>The add method add a bit in the bitset at the given position. The first argument is the bit position and the second argument is the bit value. The add method is the only method that resize a bitset.</p><p><strong>set -&gt; none (Integer|String)</strong></p><p>The set method set a bitset with an integer value. In the first form with an integer argument, the bitset is completely reset to a 64 bits bitset and the value set as an unsigned integer. In the second form with a string argument, the bitset is reset and the string argument is parsed as a binary string with or without binary prefix or as a hexadecimal string.</p><p><strong>clamp -&gt; none (Boolean)</strong></p><p>The clamp method clamp a bitset by boolean value. The bitset size is determined by finding the upper bit index that match the boolean argument.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the bitset in bits.</p><p><strong>to-byte -&gt; Integer (Byte)</strong></p><p>The to-byte method maps a portion of the bitset to a byte at a specific position. The integer argument is the bit position that is mapped to the byte lsb.</p><p><strong>subset -&gt; Integer (Bitset)</strong></p><p>The subset method returns a sub bitset by size.</p><p><strong>subset -&gt; Integer Integer (Bitset)</strong></p><p>The subset method returns a sub bitset by size and position. The first integer argument is the sub bitset size. The second argument is the bitset position where the sub bitset is extracted.</p><p><strong>Buffer</strong></p><p>The Buffer builtin object is a byte buffer that is widely used with i/o operations. The buffer can be constructed with or without literal arguments. The standard methods to add or push-back byte or characters are available. One attractive method is the write method which can write a complete buffer to an output stream specified as an argument. By default, the buffer operates in resize mode. If the buffer is configured to operate in non-resize mode, an exception is raised when trying to add a character when the buffer is full.</p><p><em>Predicate</em></p><p>buffer-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Buffer (none)</strong></p><p>The Buffer constructor create an empty buffer. The buffer is configured to operate in resize mode.</p><p><strong>Buffer (Literal...)</strong></p><p>The Buffer constructor create a buffer with a list of literal object arguments. Each literal argument is used to produce a byte representation which is added into the buffer.</p><p><em>Methods</em></p><p><strong>add -&gt; Integer (Byte|Literal|Buffer)</strong></p><p>The add method adds a byte, a literal object or a buffer to the calling buffer. The object argument is automatically converted to a sequence of bytes. For a buffer, the entire content is copied into the buffer. The method returns the number of bytes added into the buffer.</p><p><strong>get -&gt; Byte (none)</strong></p><p>The get method returns the next available byte in the buffer but do not remove it.</p><p><strong>read -&gt; Byte (none)</strong></p><p>The read method returns the next available character and remove it from the buffer.</p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the entire buffer and destroy its contents.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the buffer.</p><p><strong>full-p -&gt; Boolean (none)</strong></p><p>The full-p predicate return true if the buffer is full. If the buffer is re-sizeable, the method always return false.</p><p><strong>empty-p -&gt; Boolean (none)</strong></p><p>The empty-p predicate return true if the buffer is empty.</p><p><strong>resize-p -&gt; Boolean (none)</strong></p><p>The resize-p predicate return true if the buffer is re-sizeable.</p><p><strong>to-string -&gt; String (none)</strong></p><p>The to-string method returns a string representation of the buffer.</p><p><strong>format -&gt; String (none)</strong></p><p>The format method returns an octet string representation of the buffer.</p><p><strong>pushback -&gt; Integer (Byte|Literal|Buffer)</strong></p><p>The pushback method push back a byte, a literal object or a buffer in the calling buffer. The object argument is automatically converted to a sequence of bytes. For a buffer, the entire content is copied into the buffer. The method returns the number of byte pushbacked.</p><p><strong>get-host-word -&gt; Integer (none)</strong></p><p>The get-host-word method reads a word from the buffer and convert it to an integer. The word is assumed to be in network byte order and is converted into the host byte order before becoming an integer.</p><p><strong>get-host-quad -&gt; Integer (none)</strong></p><p>The get-host-quad method reads a quad from the buffer and convert it to an integer. The quad is assumed to be in network byte order and is converted into the host byte order before becoming an integer.</p><p><strong>get-host-octa -&gt; Integer (none)</strong></p><p>The get-host-octa method reads an octa from the buffer and convert it to an integer. The octa is assumed to be in network byte order and is converted into the host byte order before becoming an integer.</p><p><strong>set-resize -&gt; none (Boolean)</strong></p><p>The set-resize method set the resize flag for a particular buffer. This method can be used at any time.</p><p><strong>shl -&gt; none (Integer)</strong></p><p>The shl method shift left the buffer by a certain number of characters. The integer argument is the number of characters to shift.</p><p><strong>BlockBuffer</strong></p><p>The BlockBuffer builtin object is a special buffer class designed to hold bytes in a bound or unbound way. In the bound mode, the buffer size is know and the buffer cannot be resized. In the unbound mode, the buffer size is unknown and the buffer can be resized as needed. The block buffer is designed to be loaded by various means, including data, buffer or stream. Additionaly, the block buffer can be used to write into another buffer or a stream by block. By default the read and write block size is the system block size and the default mode is the bound mode, which can be changed by setting the buffer resize flag.</p><p><em>Predicate</em></p><p>block-buffer-p</p><p><em>Inheritance</em></p><p>Buffer</p><p><em>Constructors</em></p><p><strong>BlockBuffer (none)</strong></p><p>The BlockBuffer constructor create a non-resizable empty block buffer.</p><p><strong>BlockBuffer (Integer)</strong></p><p>The BlockBuffer constructor create a non-resizable block buffer. The integer argument is the block buffer size.</p><p><em>Methods</em></p><p><strong>read-count -&gt; Integer (none)</strong></p><p>The read-count method returns the number of characters read by the buffer. The read counter is increased during any read operation that might decrease the buffer length.</p><p><strong>write-count -&gt; Byte (none)</strong></p><p>The write-count method returns the number of characters writen into the buffer.</p><p><strong>copy -&gt; Integer (String|Buffer|InputStream|OutputStream)</strong></p><p>The copy method copies an object into or from the block buffer. Inthe first form, a string, a buffer or an input stream is isued to fill the buffer. If the buffer is resizable, the whole contents of the objects are copied into the block buffer. If the buffer is not resizable, the copy operation stops when the buffer is full. The copy method consumes characters with a buffer or an input stream object. With an output stream object, the block buffer characters are consumed while beeing written to the output stream. The total number of characters copied is returned by this method. When using a multiple types object that implements both the input and output stream model, the priority is given to the input stream type.</p><p><strong>copy-input-stream -&gt; Integer (InputStream)</strong></p><p>The copy-input-stream method copies an input stream into the block buffer. This method is similar to the copy method except that it operates only with an input stream. Such method is usefull when using object that implements multiple stream types.</p><p><strong>copy-output-stream -&gt; Integer (OutputStream)</strong></p><p>The copy-output-stream method copies an output stream into the block buffer. This method is similar to the copy method except that it operates only with an output stream. Such method is usefull when using object that implements multiple stream types.</p><p><strong>Property</strong></p><p>The Property builtin object is container for a name/value pair. Generally, the property object is used within a property list. An optional information field can be inserted into the property.</p><p><em>Predicate</em></p><p>property-p</p><p><em>Inheritance</em></p><p>Serial</p><p><em>Constructors</em></p><p><strong>Property (none)</strong></p><p>The Property constructor create an empty property.</p><p><strong>Property (String)</strong></p><p>The Property constructor create a property by name. The first argument is the property name.</p><p><strong>Property (String Literal)</strong></p><p>The Property constructor create a property by name and value. The first argument is the property name. The second argument is the property value.</p><p><strong>Property (String String Literal)</strong></p><p>The Property constructor create a property by name, info and value. The first argument is the property name. The second argument is the property info. The third argument is the property value.</p><p><em>Methods</em></p><p><strong>set -&gt; none (String Literal)</strong></p><p>The set method sets the property name and value. The first argument is the property name. The second argument is the property value, which is a literal converted to its string representation.</p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the property name.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the property name.</p><p><strong>set-info -&gt; none (String)</strong></p><p>The set-info method sets the property information.</p><p><strong>get-info -&gt; String (none)</strong></p><p>The get-info method returns the property information.</p><p><strong>set-value -&gt; none (Literal)</strong></p><p>The set-value method sets the property value. The literal argument is converted to its string representation.</p><p><strong>get-value -&gt; String (none)</strong></p><p>The get-value method returns the property string value.</p><p><strong>get-boolean-value -&gt; Boolean (none)</strong></p><p>The get-boolean-value method returns the property boolean value.</p><p><strong>get-integer-value -&gt; Integer (none)</strong></p><p>The get-integer-value method returns the property integer value.</p><p><strong>get-real-value -&gt; Real (none)</strong></p><p>The get-real-value method returns the property real value.</p><p><strong>Plist</strong></p><p>The Plist builtin object is a base container class used to manage property objects in an ordered way. The property list operates by maintaining a vector of property object along with a hash table that permits to find the object quickly.</p><p><em>Predicate</em></p><p>plist-p</p><p><em>Inheritance</em></p><p>SerialIterableNameable</p><p><em>Constructors</em></p><p><strong>Plist (none)</strong></p><p>The Plist constructor create an empty property list.</p><p><strong>Plist (String)</strong></p><p>The Plist constructor create a property list by name.</p><p><strong>Plist (String String)</strong></p><p>The Plist constructor create a property list by name and info.</p><p><em>Methods</em></p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the property list name.</p><p><strong>set-info -&gt; none (String)</strong></p><p>The set-info method sets the property list info.</p><p><strong>get-info -&gt; String (none)</strong></p><p>The get-info method returns the property list info.</p><p><strong>add -&gt; none (Property | String Literal | String String Literal)</strong></p><p>The add method add a property by object or name and value in the property list. In its first form the object is a property object. In the second form, the first argument is the property name and the second argument is the property value. In the the third form the first argument is the property name, the second argument is the property info and the this argument is the property value. if the property already exists an exception is raised.</p><p><strong>set -&gt; none (String Literal)</strong></p><p>The set method add or sets the property name and value in the property list. The first argument is the property name. The second argument is the property value. If the property already exists, the property value is changed.</p><p><strong>get -&gt; Property (Integer)</strong></p><p>The get method returns a property by index.</p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method resets the property lists</p><p><strong>empty-p -&gt; Boolean (none)</strong></p><p>The emptyp- predicate returns true if the property list is empty.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of properties in the property list.</p><p><strong>exists-p -&gt; Boolean (String)</strong></p><p>The exists-p method returns true if a property exists. The string argument is the property name.</p><p><strong>find -&gt; Property (String)</strong></p><p>The find method finds a property by name. The string argument is the property name. If the property does not exists, nil is returned.</p><p><strong>lookup -&gt; Property (String)</strong></p><p>The lookup method finds a property by name. The string argument is the property name. If the property does not exists, an exception is raised.</p><p><strong>get-value -&gt; String (String)</strong></p><p>The get-value method returns the property value. The string argument is the property name. If the property does not exist, an exception is raised.</p><p><strong>to-print-table -&gt; PrintTable (none | Boolean | Boolean Boolean)</strong></p><p>The to-print-table method converts the property list into a print table. The print table can be formated with the property info and value. In the first form, the print table is formated without the info field in normal value. In the second form, the boolean flag controls whther or not the info field is added in the table. In the third form, the second boolean value controls whther or not the real property value are converted in scientific notation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SPECIAL OBJECTS</h2>
        <div class="sectioncontent">
<p>This chapter is a reference of the reserved special objects with their respective built-in methods. Special objects are those objects which interact with the interpreter.</p><p><strong>Object</strong></p><p>The base object Object provides several methods which are common to all objects.</p><p><em>Methods</em></p><p><strong>repr -&gt; String (none)</strong></p><p>The repr method returns the object name in the form of a string. The result string is called the representation string.</p><p><strong>rdlock -&gt; none (none)</strong></p><p>The rdlock method try to acquire the object in read-lock mode. If the object is currently locked in write mode by another thread, the calling thread is suspended until the lock is released.</p><p><strong>wrlock -&gt; none (none)</strong></p><p>The wrlock method try to acquire the object in write-lock mode. If the object is currently locked by another thread, the calling thread is suspended until the lock is released.</p><p><strong>unlock -&gt; none (none)</strong></p><p>The unlock method try to unlock an object. An object will be unlocked if and only if the calling thread is the one who acquired the lock.</p><p><strong>clone -&gt; Object (none)</strong></p><p>The clone method returns a clone of the calling object. If the object cannot be cloned, an exception is raised.</p><p><strong>Interp</strong></p><p>The Interp is the interpreter object which is automatically bounded for each executable program. There is no constructor for this object. The current interpreter is bounded to the interp reserved symbol.</p><p><em>Predicate</em></p><p>interp-p</p><p><em>Inheritance</em></p><p>Runnable</p><p><em>Constants</em></p><p><strong>argv</strong></p><p>The argv data member holds the interpreter argument vector. The vector is initialized when the interpreter is created. Each argument is stored as a string object.</p><p><strong>os-name</strong></p><p>The os-name data member holds the operating system name. The data member evaluates as a string.</p><p><strong>os-type</strong></p><p>The os-type data member holds the operating system type. The data member evaluates as a string.</p><p><strong>version</strong></p><p>The version data member holds the full engine version. The data member evaluates as a string.</p><p><strong>program-name</strong></p><p>The program-name data member holds the interpreter program name. The data member evaluates as a string.</p><p><strong>major-version</strong></p><p>The major-version data member holds the interpreter major revision number. The data member evaluates as an integer.</p><p><strong>minor-version</strong></p><p>The minor-version data member holds the interpreter minor revision number. The data member evaluates as an integer.</p><p><strong>patch-version</strong></p><p>The patch-version data member holds the interpreter patch revision number. The data member evaluates as an integer.</p><p><strong>afnix-uri</strong></p><p>The afnix-uri data member holds the official uri. The data member evaluates as a string.</p><p><strong>machine-size</strong></p><p>The machine-size data member holds the interpreter machine size expressed in bits. Most of the time, the machine size is either 32 or 64 bits. If something else is returned, it certainly reflects an exotic platform.</p><p><strong>loader</strong></p><p>The loader data member holds the interpreter library loader. Under normal circumstances, the library loader should not be used and the standard interp:library form should be used.</p><p><strong>resolver</strong></p><p>The resolver data member holds the interpreter resolver. The resolver can be used to add dynamically a librarian or a directory to the interpreter module resolver.</p><p><em>Methods</em></p><p><strong>load -&gt; Boolean (String)</strong></p><p>The load method opens a file those name is the method argument and executes each form in the file by doing a read-eval loop. When all forms have been executed, the file is closed and the method returns true. In case of exception, the file is closed and the method returns false.</p><p><strong>library -&gt; Library (String)</strong></p><p>The library method opens a shared library and a returns a shared library object.</p><p><strong>launch -&gt; Thread (form|thread form)</strong></p><p>The launch method executes the form argument in a normal thread. The normal thread is created by cloning the current interpreter. In the first form, a thread object is created by the method and return when the thread as been launched. In the second form, a thread is started by binding a form to the thread object.</p><p><strong>set-epsilon -&gt; none (Real)</strong></p><p>The set-epsilon method sets the interpreter epsilon which corresponds to the real precision. The real precision is used by the ?= operator to compare real values.</p><p><strong>get-epsilon -&gt; Real (none)</strong></p><p>The get-real precision method returns the interpreter epsilon which correspond to the real precision. The real-precision is used by the ?= operator to compare real values.</p><p><strong>dup -&gt; Interp (none|Terminal)</strong></p><p>The dup method returns a clone of the current interpreter by binding the terminal steam argument. Without argument, a new terminal object is automatically created and bound to the newly created interpreter.</p><p><strong>loop -&gt; Boolean (none)</strong></p><p>The loop method executes the interpreter main loop by reading the interpreter input stream. The loop is finished when the end-of-stream is reached with the input stream. The method returns a boolean flag to indicate whether or not the loop was successful.</p><p><strong>set-primary-prompt -&gt; none (String)</strong></p><p>The set-primary-prompt method sets the interpreter terminal primary prompt which is used during the interpreter main loop.</p><p><strong>set-secondary-prompt -&gt; none (String)</strong></p><p>The set-secondary-prompt method sets the interpreter terminal secondary prompt which is used during the interpreter main loop.</p><p><strong>get-primary-prompt -&gt; String (none)</strong></p><p>The get-primary-prompt method returns the interpreter terminal primary prompt.</p><p><strong>get-secondary -&gt; String (none)</strong></p><p>The get-secondary-prompt method returns the interpreter terminal secondary prompt.</p><p><strong>Thread</strong></p><p>The Thread object is a special object which acts as a thread descriptor. Such object is created with the launch reserved keyword.</p><p><em>Predicate</em></p><p>thread-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Thread (none)</strong></p><p>The Thread constructor create a default thread object without any form bound to it. The object can be later used with the launch command.</p><p><em>Methods</em></p><p><strong>end-p -&gt; none (none)</strong></p><p>The end-p predicate returns true if the thread argument has finished. This predicate indicates that the thread result is a valid one.</p><p><strong>wait -&gt; none (none)</strong></p><p>The wait method suspends the calling thread until the thread argument as completed. The wait method is the primary mechanism to detect a thread completion.</p><p><strong>result -&gt; Object (none)</strong></p><p>The result method returns the thread result. If the thread is not completed, the nil value is returned. However, this method should not be used to check if a thread has completed and the wait method must be used because a thread result might be nil.</p><p><strong>Condvar</strong></p><p>The condition variable Condvar object is a special object which provides a mean of synchronization between one and several threads. The condition is said to be false unless it has been marked. When a condition is marked, all threads waiting for that condition to become true are notified and one thread is activated with that condition.</p><p><em>Predicate</em></p><p>condvar-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Condvar (none)</strong></p><p>The Condvar constructor creates a default condition variable.</p><p><em>Methods</em></p><p><strong>lock -&gt; none (none)</strong></p><p>The lock method locks the condition variable mutex. If the mutex is already locked, the calling thread is suspended until the lock is released. When the method returns, the resumed thread owns the condition variable lock. It is the thread responsibility to reset the condition variable and unlock it.</p><p><strong>mark -&gt; none (none)</strong></p><p>The mark method marks the condition variable and notify all pending threads of such change. The mark method is the basic notification mechanism.</p><p><strong>wait -&gt; none (none)</strong></p><p>The wait method waits for a condition variable to be marked. When such condition occurs, the suspended thread is run. When the method returns, the resumed thread owns the condition variable lock. It is the thread responsibility to reset the condition variable and unlock it.</p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method acquires the condition variable mutex, reset the mark, and unlock it. If the lock has been taken, the calling thread is suspended.</p><p><strong>unlock -&gt; none (none)</strong></p><p>The unlock method unlock the condition variable mutex. This method should be used after a call to lock or wait.</p><p><strong>wait-unlock -&gt; none (none)</strong></p><p>The wait-unlock method wait until a condition variable is marked. When such condition occurs, the suspended thread is run. Before the method returns, the condition variable is reset and the mutex unlocked. With two threads to synchronize, this is the preferred method compared to wait.</p><p><strong>Lexical</strong></p><p>The Lexical object is a special object built by the reader. A lexical name is also a literal object. Although the best way to create a lexical name is with a form, the lexical object can also be constructed with a string name. A lexical name can be mapped to a symbol by using the map method.</p><p><em>Predicate</em></p><p>lexical-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>Lexical (none)</strong></p><p>The Lexical constructor create an empty lexical object which evaluates to nil.</p><p><strong>Lexical (String)</strong></p><p>The Lexical constructor create a lexical object using the string argument as the lexical name.</p><p><em>Methods</em></p><p><strong>map -&gt; Object (none)</strong></p><p>The map method returns the object that is mapped by the lexical name. Most of the time, a symbol object is returned since it is the kind of object stored in a nameset. Eventually the mapping might returns an argument object if used inside a closure.</p><p><strong>Qualified</strong></p><p>The Qualified object is a special object built by the reader. A qualified object is similar to a lexical object. It is also a literal object. Like a lexical name, a qualified name can be created with a form or by direct construction with a name. Like a lexical name, the map method can be used to retrieve the symbol associated with that name.</p><p><em>Predicate</em></p><p>qualified-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>Qualified (none)</strong></p><p>The Qualifed constructor create an empty qualified name object which evaluates to nil.</p><p><strong>Qualified (String)</strong></p><p>The Qualified constructor create a qualified name object using the string argument as the qualified name. The name is parse for qualified name syntax adherence.</p><p><em>Methods</em></p><p><strong>map -&gt; Object (none)</strong></p><p>The map method returns the object that is mapped by the qualified name. Most of the time, a symbol object is returned since it is the kind of object stored in a nameset. Eventually the mapping might returns an argument object if used inside a closure.</p><p><strong>Symbol</strong></p><p>The Symbol object is a special object used by nameset to map a name with an object. Generally a symbol is obtained by mapping a lexical or qualified name. As an object, the symbol holds a name, an object and a constant flag. The symbol name cannot be changed since it might introduce inconsistencies in the containing nameset. On the other hand, the constant flag and the object can be changed. A symbol is a literal object. A symbol that is not bounded to a nameset can be constructed dynamically. Such symbol is said to be not interned.</p><p><em>Predicate</em></p><p>symbol-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>Symbol (String)</strong></p><p>The Symbol constructor create a symbol by name. The associated object is marked as nil.</p><p><strong>Symbol (String Object)</strong></p><p>The Symbol constructor create a symbol by name and bind the object argument to the symbol.</p><p><em>Methods</em></p><p><strong>get-const -&gt; Boolean (none)</strong></p><p>The get-const method returns the symbol const flag. If the flag is true, the symbol object cannot be changed unless that flags is reset with the set-const method.</p><p><strong>set-const -&gt; none (Boolean)</strong></p><p>The set-const method set the symbol const flag. This method is useful to mark a symbol as const or to make a const symbol mutable.</p><p><strong>get-object -&gt; Object (none)</strong></p><p>The get-object method returns the symbol object.</p><p><strong>set-object -&gt; none (Object)</strong></p><p>The set-object method set the symbol object. The object can be obtained by evaluating the symbol.</p><p><strong>Closure</strong></p><p>The Closure object is a special object that represents a lambda or gamma expression. A closure is represented by a set of arguments, a set of closed variables and a form to execute. A boolean flag determines the type of closure. The closure predicate lambda-p returns true if the closure is a lambda expression. Closed variables can be defines and evaluated with the use of the qualified name mechanism. Closure mutation is achieved with the add-argument and set-form method. An empty closure can be defined at construction as well.</p><p><em>Predicate</em></p><p>closure-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Closure (none)</strong></p><p>The Closure constructor create a default closure. When the closure is created, a local set of arguments and closed variables is generated. Note that such local set is dynamic. There is no restriction to reconfigure a particular lambda at run-time. The difference between a lambda and a gamma expression resides in the nameset binding when the closure is called. With a lambda, the closure nameset parent is the calling nameset. With a gamma expression, the parent nameset is always the top-level interpreter nameset. Note also, that the symbol self is automatically bounded for this closure.</p><p><strong>Closure (Boolean)</strong></p><p>The Closure constructor create a closure which acts as lambda expression if the boolean argument is true. If the boolean argument is false, the closure will behave like a gamma expression.</p><p><em>Methods</em></p><p><strong>gamma-p -&gt; Boolean (none)</strong></p><p>The gamma-p predicate returns true if the closure is a gamma expression. The predicate returns true for a lambda expression.</p><p><strong>lambda-p -&gt; Boolean (none)</strong></p><p>The lambda-p predicate returns true if the closure is a lambda expression. The predicate returns false for a gamma expression.</p><p><strong>get-form -&gt; Object (none)</strong></p><p>The get-form method returns the closure form object.</p><p><strong>set-form -&gt; none (Object)</strong></p><p>The set-form method sets the closure form object.</p><p><strong>add-argument -&gt; none (String|Lexical|form)</strong></p><p>The add-argument method adds an argument to the closure. The argument object can be either a string, a lexical object of a simple form that defines a constant lexical name.</p><p><strong>Librarian</strong></p><p>The Librarian object is a special object that read or write a librarian. Without argument, a librarian is created for writing purpose. With one file name argument, the librarian is created for reading.</p><p><em>Predicate</em></p><p>librarian-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Constructors</em></p><p><strong>Librarian (none)</strong></p><p>The Librarian constructor creates a librarian for writing. Initially, the librarian is empty and files must be added with the add method.</p><p><strong>Librarian (String)</strong></p><p>The Librarian constructor creates a librarian for reading using the name as the librarian file name.</p><p><em>Methods</em></p><p><strong>add -&gt; none (String)</strong></p><p>The add method adds a file into the librarian. The librarian must have been opened in write mode.</p><p><strong>write -&gt; none (String)</strong></p><p>The write method writes a librarian to a file those name is the argument.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of file in the librarian. This method work, no matter how the librarian has been opened.</p><p><strong>exists-p -&gt; Boolean (String)</strong></p><p>The exists-p predicate returns true if the file argument exists in the librarian.</p><p><strong>extract -&gt; InputMapped (String)</strong></p><p>The extract method returns an input stream mapped to the file name argument.</p><p><strong>Resolver</strong></p><p>The Resolver object is a special object that gives the ability to open a file based on a file path resolver. The resolver maintains a list of valid path and returns an input stream for a file on demand.</p><p><em>Predicate</em></p><p>resolver-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Resolver (none)</strong></p><p>The Resolver constructor creates a default resolver. Once created, the add method can be used to add path to the resolver.</p><p><em>Methods</em></p><p><strong>add -&gt; none (String)</strong></p><p>The add method adds a path into the resolver. The path can points either to a directory or a librarian.</p><p><strong>lookup -&gt; InputStream (String)</strong></p><p>The lookup method resolves the file name argument and returns an input stream for that file.</p><p><strong>valid-p -&gt; Boolean (String)</strong></p><p>The valid-p predicate returns true if the file name argument can be resolved. If the file name can be resolved, the lookup method can be called to get an input stream.</p><p><strong>PrintTable</strong></p><p>The PrintTable class is a formatting class for tables. The table is constructed with the number of columns -- default to 1 -- and eventually the number of rows. Once the table is created, element are added to the table with the add method. Specific table element can be set with the set method. The class provide a format method those default is to print the table on the interpreter standard output. With an output stream argument or a buffer, the table is formatted to these objects. The table formatting includes an optional column width, a filling character and a filling direction flag. By default, the column width is 0. This means that the column width is computed as the maximum length of all column elements. If the column width is set with the set-column-size method, the string element might be truncated to the left or right -- depending on the filling flag -- to fit the column width. Each table element can also be associated with a tag. The tag-p method can be used to test for the presence of a tag, while the set-tag and get-tag methods can be used to set or get the tag by row and column coordinates.</p><p><em>Predicate</em></p><p>print-table-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>PrintTable (none)</strong></p><p>The PrintTable constructor creates a default table with one column.</p><p><strong>PrintTable (Integer)</strong></p><p>The PrintTable constructor creates a table with a pre-defined number of columns specified in the constructor argument.</p><p><strong>PrintTable (Integer Integer)</strong></p><p>The PrintTable constructor creates a table with a pre-defined number of columns and rows specified in the constructor arguments.</p><p><em>Methods</em></p><p><strong>head-p -&gt; Boolean (none)</strong></p><p>The head-p predicate returns true if the table header is defined.</p><p><strong>add-head -&gt; none ([String+])</strong></p><p>The add-head method add to the table header the string arguments. The number of arguments must be equal to the number of columns.</p><p><strong>get-head -&gt; String (Integer)</strong></p><p>The get-head method returns a table header element by column index. The integer argument is the header row index.</p><p><strong>set-head -&gt; none (Integer String)</strong></p><p>The set-head method sets a table header element by column index. The first argument is the header column index and the second is the header string value to set.</p><p><strong>add -&gt; Integer (none|[Literal...])</strong></p><p>The add method serves several purposes. Without argument, a new row is added and the row index is returned. The row index can be later used with the set method to set a particular table element. With one or several literal arguments, those length must match the number of columns, a new row is created and those arguments added to the table. The row number is also returned.</p><p><strong>get -&gt; String (Integer Integer)</strong></p><p>The get method returns a particular table element by row and column. The first argument is the table row index and the second is the table column index.</p><p><strong>set -&gt; none (Integer Integer Literal)</strong></p><p>The set method sets a particular table element by row and column. The first argument is the table row index and the second is the table column index. The last argument is a literal object that is converted to a string prior its insertion.</p><p><strong>tag-p -&gt; Boolean (Integer Integer)</strong></p><p>The tag-p predicate returns true if a tag is present at a particular table element. The first argument is the table row index and the second is the table column index.</p><p><strong>set-tag -&gt; none (Integer Integer String)</strong></p><p>The set-tag method sets a particular table tag by row and column. The first argument is the table row index and the second is the table column index. The last argument is the tag value.</p><p><strong>get-tag -&gt; String (Integer Integer)</strong></p><p>The get-tag method returns a particular table tag by row and column. The first argument is the table row index and the second is the table column index.</p><p><strong>dump -&gt; none|String (none|Integer|OutputStream|Buffer)</strong></p><p>The dump method dumps the table to an output stream or a buffer. Without argument, the default interpreter output stream is used. With an integer argument, the specified row is used and a string is returned. With a buffer or an output stream, the whole table is written and nothing is returned.</p><p><strong>format -&gt; none|String (none|Integer|OutputStream|Buffer)</strong></p><p>The format method writes the formatted table to an output stream or a buffer. Without argument, the default interpreter output stream is used. With an integer argument, the specified row is used and a string is returned. With a buffer or an output stream, the whole table is written and nothing is returned.</p><p><strong>get-rows -&gt; Integer (none)</strong></p><p>The get-rows method returns the number of rows in the table.</p><p><strong>get-columns -&gt; Integer (none)</strong></p><p>The get-columns method returns the number of columns in the table.</p><p><strong>set-column-size -&gt; none (Integer Integer)</strong></p><p>The set-column-size method sets the desired width for a particular column. The first argument is the column index and the second argument is the column width.If 0 is given, the column width is computed as the maximum of the column elements.</p><p><strong>get-column-size -&gt; Integer (Integer)</strong></p><p>The get-column-size method returns the desired width for a particular column.</p><p><strong>set-column-fill -&gt; none (Integer Character)</strong></p><p>The set-column-fill method sets the filling character for a particular column. The first argument is the column index and the second argument is a character to use when filling a particular column element. The default filling character is the blank character.</p><p><strong>get-column-fill -&gt; Character (Integer)</strong></p><p>The get-column-fill method returns the filling character for a particular column.</p><p><strong>set-column-direction -&gt; none (Integer Boolean)</strong></p><p>The set-column-direction method sets the direction flag for a particular column. The first argument is the column index and the second argument is a boolean. A false value indicates a filling by the left while a true value indicates a filling by the right. The column filling character is used for this operation.</p><p><strong>get-column-direction -&gt; Boolean (Integer)</strong></p><p>The get-column-direction method returns the direction flag for a particular column.</p><p><strong>Logger</strong></p><p>The Looger class is a message logger that stores messages in a buffer with a level. The default level is the level 0. A negative level generally indicates a warning or an error message but this is just a convention which is not enforced by the class. A high level generally indicates a less important message. The messages are stored in a circular buffer. When the logger is full, a new message replace the oldest one. By default, the logger is initialized with a 256 messages capacity that can be resized.</p><p><em>Predicate</em></p><p>logger-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Logger (none)</strong></p><p>The Logger constructor creates a default logger.</p><p><strong>Logger (Integer)</strong></p><p>The Logger constructor creates a logger with a specific size specified as the constructor argument.</p><p><strong>Logger (String)</strong></p><p>The Logger constructor creates a logger with an information argument. The information string is later used to format the logged messages.</p><p><strong>Logger (Integer String)</strong></p><p>The Logger constructor creates a logger with a specific size and an information argument. The first argument is the logger size. The second argument is the information string. The information string is later used to format the logged messages.</p><p><em>Methods</em></p><p><strong>add -&gt; none (String|String Integer)</strong></p><p>The add method adds a message in the logger. With one argument, the method take a single string message. with two arguments, the first arguments is the message and the second argument is the message level.</p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the logger class by removing all messages.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of messages stored in the logger object.</p><p><strong>resize -&gt; none (Integer)</strong></p><p>The resize method resize the logger class by increasing the size of the message buffer. The old messages are kept during the resizing operation.</p><p><strong>set-info -&gt; none (String)</strong></p><p>The set-info method sets the logger information string. The information string is used by the derived classes when a message is printed.</p><p><strong>get-info -&gt; String (none)</strong></p><p>The get-info method returns the logger information string. The information string is used by the derived classes when a message is printed.</p><p><strong>set-default-level -&gt; none (Integer)</strong></p><p>The set-default-level method sets the default level use for storing message. This parameter is used with the add method in conjunction with the message argument. When the message level is specified, the default message level is ignored.</p><p><strong>get-default-level -&gt; Integer (none)</strong></p><p>The get-default-level method returns the default message level used by the logger. The default message level is used by the add method when the message level is not specified directly.</p><p><strong>get-message -&gt; String (Integer)</strong></p><p>The get-message method returns a logger message by index. The integer argument is the message index.</p><p><strong>get-full-message -&gt; String (Integer)</strong></p><p>The get-full-message method returns a fully formatted logger message by index. The integer argument is the message index. The message includes the time and contents.</p><p><strong>get-message-time -&gt; Integer (Integer)</strong></p><p>The get-message-time method returns the logger message time by index. The integer argument is the message index.</p><p><strong>get-message-level -&gt; Integer (Integer)</strong></p><p>The get-message-level method returns the logger message level by index. The integer argument is the message index.</p><p><strong>set-output-stream -&gt; none (OutputStream|String)</strong></p><p>The set-output-stream method set the logger output stream. The output stream can be either an output stream or an output file name.</p><p><strong>Counter</strong></p><p>The Counter class is a mechanism designed to count integer both upward or downward. The counter is initialized with a start and end value. With a single value, the start value is set to 0 and the counter direction determined by the end value. The counter object is also a literal object, meaning that it can be directly printed. The object is also designed to be used directly in a loop.</p><p><em>Predicate</em></p><p>counter-p</p><p><em>Inheritance</em></p><p>Literal</p><p><em>Constructors</em></p><p><strong>Counter (none)</strong></p><p>The Counter constructor creates a default counter. Since, both start and end values are initialized to 0, this object will never count.</p><p><strong>Counter (Integer)</strong></p><p>The Counter constructor creates an upward counter. If the argument value, the initial counter value is the argument value and the counter will counter from the value to 0. If the argument value is positive, the final counter value is the argument value and the counter will count from 0 to this value.</p><p><strong>Counter (Integer Integer)</strong></p><p>The Counter constructor creates a counter with an initial and final values. Depending on the initial and final value the counter might be an upward or a downward counter.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the counter to its start value.</p><p><strong>step-p -&gt; Boolean (none)</strong></p><p>The step-p predicate checks if the counter can be moved by one position. If the test is successful, the counter is moved upward or downward. the method returns the result of the test.</p><p><strong>valid-p -&gt; Boolean (none)</strong></p><p>The valid-p predicate returns true if the counter can be moved by one position.</p><p><strong>Lexer</strong></p><p>The Lexer class is the lexical analyzer for the writing system. The lexical analyzer consumes characters from an input stream and produces tokens. From a token, it is possible to derive an object in the form of a constant object which can be evaluated to a literal or to another object in the presence of a lexical or qualified object. The lexical analyzer is integrated inside the form reader. As an object it is possible to use it when it becomes necesary to parse strings.</p><p><em>Predicate</em></p><p>lexer-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Methods</em></p><p><strong>get-token -&gt; Token (none)</strong></p><p>The get-token method returns the next available token.</p><p><strong>get-object -&gt; Object (none)</strong></p><p>The get-object method returns the next available object.</p><p><strong>get-line-number -&gt; Integer (none)</strong></p><p>The get-line-number method returns the token line number which is the current line number under processing.</p><p><strong>Former</strong></p><p>The Former class is an abstract class used to derive form reader. The class defines only a method parse which returns a form. The method getlnum returns the form line number.</p><p><em>Predicate</em></p><p>former-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Methods</em></p><p><strong>parse -&gt; Form (none)</strong></p><p>The parse method returns the next available form.</p><p><strong>get-line-number -&gt; Integer (none)</strong></p><p>The get-line-number method returns the form line number which is the current line number under processing.</p><p><strong>Reader</strong></p><p>The Reader class is the general purpose form reader which supports the writing system syntax. The reader is primarily used to parse file or be run interactively. The reader consumes tokens until a complete form can be built. The form does not have any particular meaning and must be post processed by the application.</p><p><em>Predicate</em></p><p>reader-p</p><p><em>Inheritance</em></p><p>FormerNameable</p><p><em>Constructors</em></p><p><strong>Reader (none)</strong></p><p>The Reader constructor creates a default reader.</p><p><strong>Reader (String|InputStream)</strong></p><p>The Reader constructor creates a reader by string or input stream. In the first form, a string is mapped into a string stream which is used by the reader to parse form. In the second form, an input stream is bound to the reader to parse forms.</p><p><strong>Loader</strong></p><p>The Loader class is a library loader. The loader keep a list of loaded libraries. This class is bound to the interpreter and cannot be constructed. Use the interp:loader to access the interpreter loader. for safety reason, it is not possible to add a libray to the loader. The interpreter method interp:library is the prefered method to access the loader.</p><p><em>Predicate</em></p><p>loader-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Methods</em></p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of loaded libraries.</p><p><strong>get -&gt; Library (Integer)</strong></p><p>The get method returns a library object by index.</p><p><strong>exists-p -&gt; Boolean (String)</strong></p><p>The exists-p predicate returns true if a library is already loaded in the interpreter.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="afnix-vol-0.7.html"><span aria-hidden="true">&larr;</span> afnix-vol-0.7: Afnix installation guide</a></li>
   <li class="next"><a href="aio.7.html">aio.7: Posix asynchronous i/o overview <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SELECT: Retrieve rows from a table or view</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Retrieve rows from a table or view">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SELECT (7) manual">
  <meta name="twitter:description" content="Retrieve rows from a table or view">
  <meta name="twitter:image" content="https://www.carta.tech/images/postgresql-client-9.4-SELECT-7.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man7/SELECT.7.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SELECT (7) manual" />
  <meta property="og:description" content="Retrieve rows from a table or view" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/postgresql-client-9.4-SELECT-7.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SELECT<small> (7)</small></h1>
        <p class="lead">Retrieve rows from a table or view</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/SELECT.7.html">
      <span itemprop="name">SELECT: Retrieve rows from a table or view</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/postgresql-client-9.4/">
      <span itemprop="name">postgresql-client-9.4</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/SELECT.7.html">
      <span itemprop="name">SELECT: Retrieve rows from a table or view</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
[ WITH [ RECURSIVE ] <em>with_query</em> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <em>expression</em> [, ...] ) ] ]
    [ * | <em>expression</em> [ [ AS ] <em>output_name</em> ] [, ...] ]
    [ FROM <em>from_item</em> [, ...] ]
    [ WHERE <em>condition</em> ]
    [ GROUP BY <em>expression</em> [, ...] ]
    [ HAVING <em>condition</em> [, ...] ]
    [ WINDOW <em>window_name</em> AS ( <em>window_definition</em> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <em>select</em> ]
    [ ORDER BY <em>expression</em> [ ASC | DESC | USING <em>operator</em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <em>count</em> | ALL } ]
    [ OFFSET <em>start</em> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <em>count</em> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <em>table_name</em> [, ...] ] [ NOWAIT ] [...] ]

where <em>from_item</em> can be one of:

    [ ONLY ] <em>table_name</em> [ * ] [ [ AS ] <em>alias</em> [ ( <em>column_alias</em> [, ...] ) ] ]
    [ LATERAL ] ( <em>select</em> ) [ AS ] <em>alias</em> [ ( <em>column_alias</em> [, ...] ) ]
    <em>with_query_name</em> [ [ AS ] <em>alias</em> [ ( <em>column_alias</em> [, ...] ) ] ]
    [ LATERAL ] <em>function_name</em> ( [ <em>argument</em> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <em>alias</em> [ ( <em>column_alias</em> [, ...] ) ] ]
    [ LATERAL ] <em>function_name</em> ( [ <em>argument</em> [, ...] ] ) [ AS ] <em>alias</em> ( <em>column_definition</em> [, ...] )
    [ LATERAL ] <em>function_name</em> ( [ <em>argument</em> [, ...] ] ) AS ( <em>column_definition</em> [, ...] )
    [ LATERAL ] ROWS FROM( <em>function_name</em> ( [ <em>argument</em> [, ...] ] ) [ AS ( <em>column_definition</em> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <em>alias</em> [ ( <em>column_alias</em> [, ...] ) ] ]
    <em>from_item</em> [ NATURAL ] <em>join_type</em> <em>from_item</em> [ ON <em>join_condition</em> | USING ( <em>join_column</em> [, ...] ) ]

and <em>with_query</em> is:

    <em>with_query_name</em> [ ( <em>column_name</em> [, ...] ) ] AS ( <em>select</em> | <em>values</em> | <em>insert</em> | <em>update</em> | <em>delete</em> )

TABLE [ ONLY ] <em>table_name</em> [ * ]
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>SELECT</strong> retrieves rows from zero or more tables. The general processing of <strong>SELECT</strong> is as follows:</p><p>All queries in the WITH list are computed. These effectively serve as temporary tables that can be referenced in the FROM list. A WITH query that is referenced more than once in FROM is computed only once. (See WITH Clause below.)</p><p>All elements in the FROM list are computed. (Each element in the FROM list is a real or virtual table.) If more than one element is specified in the FROM list, they are cross-joined together. (See FROM Clause below.)</p><p>If the WHERE clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See WHERE Clause below.)</p><p>If the GROUP BY clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the HAVING clause is present, it eliminates groups that do not satisfy the given condition. (See GROUP BY Clause and HAVING Clause below.)</p><p>The actual output rows are computed using the <strong>SELECT</strong> output expressions for each selected row or row group. (See SELECT List below.)</p><p>SELECT DISTINCT eliminates duplicate rows from the result. SELECT DISTINCT ON eliminates rows that match on all the specified expressions. SELECT ALL (the default) will return all candidate rows, including duplicates. (See DISTINCT Clause below.)</p><p>Using the operators UNION, INTERSECT, and EXCEPT, the output of more than one <strong>SELECT</strong> statement can be combined to form a single result set. The UNION operator returns all rows that are in one or both of the result sets. The INTERSECT operator returns all rows that are strictly in both result sets. The EXCEPT operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless ALL is specified. The noise word DISTINCT can be added to explicitly specify eliminating duplicate rows. Notice that DISTINCT is the default behavior here, even though ALL is the default for <strong>SELECT</strong> itself. (See UNION Clause, INTERSECT Clause, and EXCEPT Clause below.)</p><p>If the ORDER BY clause is specified, the returned rows are sorted in the specified order. If ORDER BY is not given, the rows are returned in whatever order the system finds fastest to produce. (See ORDER BY Clause below.)</p><p>If the LIMIT (or FETCH FIRST) or OFFSET clause is specified, the <strong>SELECT</strong> statement only returns a subset of the result rows. (See LIMIT Clause below.)</p><p>If FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE or FOR KEY SHARE is specified, the <strong>SELECT</strong> statement locks the selected rows against concurrent updates. (See The Locking Clause below.)</p><p>You must have SELECT privilege on each column used in a <strong>SELECT</strong> command. The use of FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE or FOR KEY SHARE requires UPDATE privilege as well (for at least one column of each table so selected).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARAMETERS</h2>
        <div class="sectioncontent">
<h3>WITH Clause</h3>
<p>The WITH clause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be a <strong>SELECT</strong>, <strong>TABLE</strong>, <strong>VALUES</strong>, <strong>INSERT</strong>, <strong>UPDATE</strong> or <strong>DELETE</strong> statement. When writing a data-modifying statement (<strong>INSERT</strong>, <strong>UPDATE</strong> or <strong>DELETE</strong>) in WITH, it is usual to include a RETURNING clause. It is the output of RETURNING, <em>not</em> the underlying table that the statement modifies, that forms the temporary table that is read by the primary query. If RETURNING is omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query.</p><p>A name (without schema qualification) must be specified for each WITH query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.</p><p>If RECURSIVE is specified, it allows a <strong>SELECT</strong> subquery to reference itself by name. Such a subquery must have the form</p>
<pre>
<em>non_recursive_term</em> UNION [ ALL | DISTINCT ] <em>recursive_term</em>
</pre>
<p>where the recursive self-reference must appear on the right-hand side of the UNION. Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursive <strong>SELECT</strong> query in a data-modifying statement. See Section 7.8, &ldquo;WITH Queries (Common Table Expressions)&rdquo;, in the documentation for an example.</p><p>Another effect of RECURSIVE is that WITH queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without RECURSIVE, WITH queries can only reference sibling WITH queries that are earlier in the WITH list.</p><p>A key property of WITH queries is that they are evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output.</p><p>The primary query and the WITH queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in WITH cannot be seen from other parts of the query, other than by reading its RETURNING output. If two such data-modifying statements attempt to modify the same row, the results are unspecified.</p><p>See Section 7.8, &ldquo;WITH Queries (Common Table Expressions)&rdquo;, in the documentation for additional information.</p>
<h3>FROM Clause</h3>
<p>The FROM clause specifies one or more source tables for the <strong>SELECT</strong>. If multiple sources are specified, the result is the Cartesian product (cross join) of all the sources. But usually qualification conditions are added (via WHERE) to restrict the returned rows to a small subset of the Cartesian product.</p><p>The FROM clause can contain the following elements:</p><p><em>table_name</em></p><p>The name (optionally schema-qualified) of an existing table or view. If ONLY is specified before the table name, only that table is scanned. If ONLY is not specified, the table and all its descendant tables (if any) are scanned. Optionally, * can be specified after the table name to explicitly indicate that descendant tables are included.</p><p><em>alias</em></p><p>A substitute name for the FROM item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given FROM foo AS f, the remainder of the <strong>SELECT</strong> must refer to this FROM item as f not foo. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.</p><p><em>select</em></p><p>A sub-<strong>SELECT</strong> can appear in the FROM clause. This acts as though its output were created as a temporary table for the duration of this single <strong>SELECT</strong> command. Note that the sub-<strong>SELECT</strong> must be surrounded by parentheses, and an alias <em>must</em> be provided for it. A <a href="../man7/VALUES.7.html"><strong>VALUES</strong>(7)</a> command can also be used here.</p><p><em>with_query_name</em></p><p>A WITH query is referenced by writing its name, just as though the query&apos;s name were a table name. (In fact, the WITH query hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table&apos;s name.) An alias can be provided in the same way as for a table.</p><p><em>function_name</em></p><p>Function calls can appear in the FROM clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function&apos;s output were created as a temporary table for the duration of this single <strong>SELECT</strong> command. When the optional <strong>WITH ORDINALITY</strong> clause is added to the function call, a new column is appended after all the function&apos;s output columns with numbering for each row.</p><p>An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function&apos;s composite return type, including the column added by ORDINALITY if present.</p><p>Multiple function calls can be combined into a single FROM-clause item by surrounding them with ROWS FROM( ... ). The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, NULLs are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.</p><p>If the function has been defined as returning the record data type, then an alias or the key word AS must be present, followed by a column definition list in the form ( <em>column_name</em> <em>data_type</em> [, ... ]). The column definition list must match the actual number and types of columns returned by the function.</p><p>When using the ROWS FROM( ... ) syntax, if one of the functions requires a column definition list, it&apos;s preferred to put the column definition list after the function call inside ROWS FROM( ... ). A column definition list can be placed after the ROWS FROM( ... ) construct only if there&apos;s just a single function and no WITH ORDINALITY clause.</p><p>To use ORDINALITY together with a column definition list, you must use the ROWS FROM( ... ) syntax and put the column definition list inside ROWS FROM( ... ).</p><p><em>join_type</em></p><p>One of</p><p>[ INNER ] JOIN</p><p>LEFT [ OUTER ] JOIN</p><p>RIGHT [ OUTER ] JOIN</p><p>FULL [ OUTER ] JOIN</p><p>CROSS JOIN</p><p>For the INNER and OUTER join types, a join condition must be specified, namely exactly one of NATURAL, ON <em>join_condition</em>, or USING (<em>join_column</em> [, ...]). See below for the meaning. For CROSS JOIN, none of these clauses can appear.</p><p>A JOIN clause combines two FROM items, which for convenience we will refer to as &ldquo;tables&rdquo;, though in reality they can be any type of FROM item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, JOINs nest left-to-right. In any case JOIN binds more tightly than the commas separating FROM-list items.</p><p>CROSS JOIN and INNER JOIN produce a simple Cartesian product, the same result as you get from listing the two tables at the top level of FROM, but restricted by the join condition (if any). CROSS JOIN is equivalent to INNER JOIN ON (TRUE), that is, no rows are removed by qualification. These join types are just a notational convenience, since they do nothing you couldn&apos;t do with plain FROM and WHERE.</p><p>LEFT OUTER JOIN returns all rows in the qualified Cartesian product (i.e., all combined rows that pass its join condition), plus one copy of each row in the left-hand table for which there was no right-hand row that passed the join condition. This left-hand row is extended to the full width of the joined table by inserting null values for the right-hand columns. Note that only the JOIN clause&apos;s own condition is considered while deciding which rows have matches. Outer conditions are applied afterwards.</p><p>Conversely, RIGHT OUTER JOIN returns all the joined rows, plus one row for each unmatched right-hand row (extended with nulls on the left). This is just a notational convenience, since you could convert it to a LEFT OUTER JOIN by switching the left and right tables.</p><p>FULL OUTER JOIN returns all the joined rows, plus one row for each unmatched left-hand row (extended with nulls on the right), plus one row for each unmatched right-hand row (extended with nulls on the left).</p><p>ON <em>join_condition</em></p><p><em>join_condition</em> is an expression resulting in a value of type boolean (similar to a WHERE clause) that specifies which rows in a join are considered to match.</p><p>USING ( <em>join_column</em> [, ...] )</p><p>A clause of the form USING ( a, b, ... ) is shorthand for ON left_table.a = right_table.a AND left_table.b = right_table.b .... Also, USING implies that only one of each pair of equivalent columns will be included in the join output, not both.</p><p>NATURAL</p><p>NATURAL is shorthand for a USING list that mentions all columns in the two tables that have the same names.</p><p>LATERAL</p><p>The LATERAL key word can precede a sub-<strong>SELECT</strong>FROM item. This allows the sub-<strong>SELECT</strong> to refer to columns of FROM items that appear before it in the FROM list. (Without LATERAL, each sub-<strong>SELECT</strong> is evaluated independently and so cannot cross-reference any other FROM item.)</p><p>LATERAL can also precede a function-call FROM item, but in this case it is a noise word, because the function expression can refer to earlier FROM items in any case.</p><p>A LATERAL item can appear at top level in the FROM list, or within a JOIN tree. In the latter case it can also refer to any items that are on the left-hand side of a JOIN that it is on the right-hand side of.</p><p>When a FROM item contains LATERAL cross-references, evaluation proceeds as follows: for each row of the FROM item providing the cross-referenced column(s), or set of rows of multiple FROM items providing the columns, the LATERAL item is evaluated using that row or row set&apos;s values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).</p><p>The column source table(s) must be INNER or LEFT joined to the LATERAL item, else there would not be a well-defined set of rows from which to compute each set of rows for the LATERAL item. Thus, although a construct such as <em>X</em> RIGHT JOIN LATERAL <em>Y</em> is syntactically valid, it is not actually allowed for <em>Y</em> to reference <em>X</em>.</p>
<h3>WHERE Clause</h3>
<p>The optional WHERE clause has the general form</p>
<pre>
WHERE <em>condition</em>
</pre>
<p>where <em>condition</em> is any expression that evaluates to a result of type boolean. Any row that does not satisfy this condition will be eliminated from the output. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</p>
<h3>GROUP BY Clause</h3>
<p>The optional GROUP BY clause has the general form</p>
<pre>
GROUP BY <em>expression</em> [, ...]
</pre>
<p>GROUP BY will condense into a single row all selected rows that share the same values for the grouped expressions. <em>expression</em> can be an input column name, or the name or ordinal number of an output column (<strong>SELECT</strong> list item), or an arbitrary expression formed from input-column values. In case of ambiguity, a GROUP BY name will be interpreted as an input-column name rather than an output column name.</p><p>Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no GROUP BY clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a FILTER clause to the aggregate function call; see Section 4.2.7, &ldquo;Aggregate Expressions&rdquo;, in the documentation for more information. When a FILTER clause is present, only those rows matching it are included in the input to that aggregate function.</p><p>When GROUP BY is present, or any aggregate functions are present, it is not valid for the <strong>SELECT</strong> list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.</p><p>Keep in mind that all aggregate functions are evaluated before evaluating any &ldquo;scalar&rdquo; expressions in the HAVING clause or SELECT list. This means that, for example, a CASE expression cannot be used to skip evaluation of an aggregate function; see Section 4.2.14, &ldquo;Expression Evaluation Rules&rdquo;, in the documentation.</p><p>Currently, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE and FOR KEY SHARE cannot be specified with GROUP BY.</p>
<h3>HAVING Clause</h3>
<p>The optional HAVING clause has the general form</p>
<pre>
HAVING <em>condition</em>
</pre>
<p>where <em>condition</em> is the same as specified for the WHERE clause.</p><p>HAVING eliminates group rows that do not satisfy the condition. HAVING is different from WHERE: WHERE filters individual rows before the application of GROUP BY, while HAVING filters group rows created by GROUP BY. Each column referenced in <em>condition</em> must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns.</p><p>The presence of HAVING turns a query into a grouped query even if there is no GROUP BY clause. This is the same as what happens when the query contains aggregate functions but no GROUP BY clause. All the selected rows are considered to form a single group, and the <strong>SELECT</strong> list and HAVING clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the HAVING condition is true, zero rows if it is not true.</p><p>Currently, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE and FOR KEY SHARE cannot be specified with HAVING.</p>
<h3>WINDOW Clause</h3>
<p>The optional WINDOW clause has the general form</p>
<pre>
WINDOW <em>window_name</em> AS ( <em>window_definition</em> ) [, ...]
</pre>
<p>where <em>window_name</em> is a name that can be referenced from OVER clauses or subsequent window definitions, and <em>window_definition</em> is</p>
<pre>
[ <em>existing_window_name</em> ]
[ PARTITION BY <em>expression</em> [, ...] ]
[ ORDER BY <em>expression</em> [ ASC | DESC | USING <em>operator</em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <em>frame_clause</em> ]
</pre>
<p>If an <em>existing_window_name</em> is specified it must refer to an earlier entry in the WINDOW list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own PARTITION BY clause, and it can specify ORDER BY only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.</p><p>The elements of the PARTITION BY list are interpreted in much the same fashion as elements of a GROUP BY Clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular GROUP BY clause. They are allowed here because windowing occurs after grouping and aggregation.</p><p>Similarly, the elements of the ORDER BY list are interpreted in much the same fashion as elements of an ORDER BY Clause, except that the expressions are always taken as simple expressions and never the name or number of an output column.</p><p>The optional <em>frame_clause</em> defines the window frame for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the current row). The <em>frame_clause</em> can be one of</p>
<pre>
{ RANGE | ROWS } <em>frame_start</em>
{ RANGE | ROWS } BETWEEN <em>frame_start</em> AND <em>frame_end</em>
</pre>
<p>where <em>frame_start</em> and <em>frame_end</em> can be one of</p>
<pre>
UNBOUNDED PRECEDING
<em>value</em> PRECEDING
CURRENT ROW
<em>value</em> FOLLOWING
UNBOUNDED FOLLOWING
</pre>
<p>If <em>frame_end</em> is omitted it defaults to CURRENT ROW. Restrictions are that <em>frame_start</em> cannot be UNBOUNDED FOLLOWING, <em>frame_end</em> cannot be UNBOUNDED PRECEDING, and the <em>frame_end</em> choice cannot appear earlier in the above list than the <em>frame_start</em> choice &ndash; for example RANGE BETWEEN CURRENT ROW AND <em>value</em> PRECEDING is not allowed.</p><p>The default framing option is RANGE UNBOUNDED PRECEDING, which is the same as RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW; it sets the frame to be all rows from the partition start up through the current row&apos;s last peer (a row that ORDER BY considers equivalent to the current row, or all rows if there is no ORDER BY). In general, UNBOUNDED PRECEDING means that the frame starts with the first row of the partition, and similarly UNBOUNDED FOLLOWING means that the frame ends with the last row of the partition (regardless of RANGE or ROWS mode). In ROWS mode, CURRENT ROW means that the frame starts or ends with the current row; but in RANGE mode it means that the frame starts or ends with the current row&apos;s first or last peer in the ORDER BY ordering. The <em>value</em>PRECEDING and <em>value</em>FOLLOWING cases are currently only allowed in ROWS mode. They indicate that the frame starts or ends with the row that many rows before or after the current row. <em>value</em> must be an integer expression not containing any variables, aggregate functions, or window functions. The value must not be null or negative; but it can be zero, which selects the current row itself.</p><p>Beware that the ROWS options can produce unpredictable results if the ORDER BY ordering does not order the rows uniquely. The RANGE options are designed to ensure that rows that are peers in the ORDER BY ordering are treated alike; all peer rows will be in the same frame.</p><p>The purpose of a WINDOW clause is to specify the behavior of window functions appearing in the query&apos;s SELECT List or ORDER BY Clause. These functions can reference the WINDOW clause entries by name in their OVER clauses. A WINDOW clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any WINDOW clause at all, since a window function call can specify its window definition directly in its OVER clause. However, the WINDOW clause saves typing when the same window definition is needed for more than one window function.</p><p>Currently, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE and FOR KEY SHARE cannot be specified with WINDOW.</p><p>Window functions are described in detail in Section 3.5, &ldquo;Window Functions&rdquo;, in the documentation, Section 4.2.8, &ldquo;Window Function Calls&rdquo;, in the documentation, and Section 7.2.4, &ldquo;Window Function Processing&rdquo;, in the documentation.</p>
<h3>SELECT List</h3>
<p>The <strong>SELECT</strong> list (between the key words SELECT and FROM) specifies expressions that form the output rows of the <strong>SELECT</strong> statement. The expressions can (and usually do) refer to columns computed in the FROM clause.</p><p>Just as in a table, every output column of a <strong>SELECT</strong> has a name. In a simple <strong>SELECT</strong> this name is just used to label the column for display, but when the <strong>SELECT</strong> is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write AS<em>output_name</em> after the column&apos;s expression. (You can omit AS, but only if the desired output name does not match any PostgreSQL keyword (see Appendix&nbsp;C, SQL Key Words). For protection against possible future keyword additions, it is recommended that you always either write AS or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column&apos;s expression is a simple column reference then the chosen name is the same as that column&apos;s name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as ?column?.</p><p>An output column&apos;s name can be used to refer to the column&apos;s value in ORDER BY and GROUP BY clauses, but not in the WHERE or HAVING clauses; there you must write out the expression instead.</p><p>Instead of an expression, * can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write <em>table_name</em>.* as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with AS; the output column names will be the same as the table columns&apos; names.</p>
<h3>DISTINCT Clause</h3>
<p>If SELECT DISTINCT is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates). SELECT ALL specifies the opposite: all rows are kept; that is the default.</p><p>SELECT DISTINCT ON ( <em>expression</em> [, ...] ) keeps only the first row of each set of rows where the given expressions evaluate to equal. The DISTINCT ON expressions are interpreted using the same rules as for ORDER BY (see above). Note that the &ldquo;first row&rdquo; of each set is unpredictable unless ORDER BY is used to ensure that the desired row appears first. For example:</p>
<pre>
SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;
</pre>
<p>retrieves the most recent weather report for each location. But if we had not used ORDER BY to force descending order of time values for each location, we&apos;d have gotten a report from an unpredictable time for each location.</p><p>The DISTINCT ON expression(s) must match the leftmost ORDER BY expression(s). The ORDER BY clause will normally contain additional expression(s) that determine the desired precedence of rows within each DISTINCT ON group.</p><p>Currently, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE and FOR KEY SHARE cannot be specified with DISTINCT.</p>
<h3>UNION Clause</h3>
<p>The UNION clause has this general form:</p>
<pre>
<em>select_statement</em> UNION [ ALL | DISTINCT ] <em>select_statement</em>
</pre>
<p><em>select_statement</em> is any <strong>SELECT</strong> statement without an ORDER BY, LIMIT, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, or FOR KEY SHARE clause. (ORDER BY and LIMIT can be attached to a subexpression if it is enclosed in parentheses. Without parentheses, these clauses will be taken to apply to the result of the UNION, not to its right-hand input expression.)</p><p>The UNION operator computes the set union of the rows returned by the involved <strong>SELECT</strong> statements. A row is in the set union of two result sets if it appears in at least one of the result sets. The two <strong>SELECT</strong> statements that represent the direct operands of the UNION must produce the same number of columns, and corresponding columns must be of compatible data types.</p><p>The result of UNION does not contain any duplicate rows unless the ALL option is specified. ALL prevents elimination of duplicates. (Therefore, UNION ALL is usually significantly quicker than UNION; use ALL when you can.) DISTINCT can be written to explicitly specify the default behavior of eliminating duplicate rows.</p><p>Multiple UNION operators in the same <strong>SELECT</strong> statement are evaluated left to right, unless otherwise indicated by parentheses.</p><p>Currently, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE and FOR KEY SHARE cannot be specified either for a UNION result or for any input of a UNION.</p>
<h3>INTERSECT Clause</h3>
<p>The INTERSECT clause has this general form:</p>
<pre>
<em>select_statement</em> INTERSECT [ ALL | DISTINCT ] <em>select_statement</em>
</pre>
<p><em>select_statement</em> is any <strong>SELECT</strong> statement without an ORDER BY, LIMIT, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, or FOR KEY SHARE clause.</p><p>The INTERSECT operator computes the set intersection of the rows returned by the involved <strong>SELECT</strong> statements. A row is in the intersection of two result sets if it appears in both result sets.</p><p>The result of INTERSECT does not contain any duplicate rows unless the ALL option is specified. With ALL, a row that has <em>m</em> duplicates in the left table and <em>n</em> duplicates in the right table will appear min(<em>m</em>,<em>n</em>) times in the result set. DISTINCT can be written to explicitly specify the default behavior of eliminating duplicate rows.</p><p>Multiple INTERSECT operators in the same <strong>SELECT</strong> statement are evaluated left to right, unless parentheses dictate otherwise. INTERSECT binds more tightly than UNION. That is, A UNION B INTERSECT C will be read as A UNION (B INTERSECT C).</p><p>Currently, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE and FOR KEY SHARE cannot be specified either for an INTERSECT result or for any input of an INTERSECT.</p>
<h3>EXCEPT Clause</h3>
<p>The EXCEPT clause has this general form:</p>
<pre>
<em>select_statement</em> EXCEPT [ ALL | DISTINCT ] <em>select_statement</em>
</pre>
<p><em>select_statement</em> is any <strong>SELECT</strong> statement without an ORDER BY, LIMIT, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, or FOR KEY SHARE clause.</p><p>The EXCEPT operator computes the set of rows that are in the result of the left <strong>SELECT</strong> statement but not in the result of the right one.</p><p>The result of EXCEPT does not contain any duplicate rows unless the ALL option is specified. With ALL, a row that has <em>m</em> duplicates in the left table and <em>n</em> duplicates in the right table will appear max(<em>m</em>-<em>n</em>,0) times in the result set. DISTINCT can be written to explicitly specify the default behavior of eliminating duplicate rows.</p><p>Multiple EXCEPT operators in the same <strong>SELECT</strong> statement are evaluated left to right, unless parentheses dictate otherwise. EXCEPT binds at the same level as UNION.</p><p>Currently, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE and FOR KEY SHARE cannot be specified either for an EXCEPT result or for any input of an EXCEPT.</p>
<h3>ORDER BY Clause</h3>
<p>The optional ORDER BY clause has this general form:</p>
<pre>
ORDER BY <em>expression</em> [ ASC | DESC | USING <em>operator</em> ] [ NULLS { FIRST | LAST } ] [, ...]
</pre>
<p>The ORDER BY clause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order.</p><p>Each <em>expression</em> can be the name or ordinal number of an output column (<strong>SELECT</strong> list item), or it can be an arbitrary expression formed from input-column values.</p><p>The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the AS clause.</p><p>It is also possible to use arbitrary expressions in the ORDER BY clause, including columns that do not appear in the <strong>SELECT</strong> output list. Thus the following statement is valid:</p>
<pre>
SELECT name FROM distributors ORDER BY code;
</pre>
<p>A limitation of this feature is that an ORDER BY clause applying to the result of a UNION, INTERSECT, or EXCEPT clause can only specify an output column name or number, not an expression.</p><p>If an ORDER BY expression is a simple name that matches both an output column name and an input column name, ORDER BY will interpret it as the output column name. This is the opposite of the choice that GROUP BY will make in the same situation. This inconsistency is made to be compatible with the SQL standard.</p><p>Optionally one can add the key word ASC (ascending) or DESC (descending) after any expression in the ORDER BY clause. If not specified, ASC is assumed by default. Alternatively, a specific ordering operator name can be specified in the USING clause. An ordering operator must be a less-than or greater-than member of some B-tree operator family. ASC is usually equivalent to USING &lt; and DESC is usually equivalent to USING &gt;. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)</p><p>If NULLS LAST is specified, null values sort after all non-null values; if NULLS FIRST is specified, null values sort before all non-null values. If neither is specified, the default behavior is NULLS LAST when ASC is specified or implied, and NULLS FIRST when DESC is specified (thus, the default is to act as though nulls are larger than non-nulls). When USING is specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator.</p><p>Note that ordering options apply only to the expression they follow; for example ORDER BY x, y DESC does not mean the same thing as ORDER BY x DESC, y DESC.</p><p>Character-string data is sorted according to the collation that applies to the column being sorted. That can be overridden at need by including a COLLATE clause in the <em>expression</em>, for example ORDER BY mycolumn COLLATE "en_US". For more information see Section 4.2.10, &ldquo;Collation Expressions&rdquo;, in the documentation and Section 22.2, &ldquo;Collation Support&rdquo;, in the documentation.</p>
<h3>LIMIT Clause</h3>
<p>The LIMIT clause consists of two independent sub-clauses:</p>
<pre>
LIMIT { <em>count</em> | ALL }
OFFSET <em>start</em>
</pre>
<p><em>count</em> specifies the maximum number of rows to return, while <em>start</em> specifies the number of rows to skip before starting to return rows. When both are specified, <em>start</em> rows are skipped before starting to count the <em>count</em> rows to be returned.</p><p>If the <em>count</em> expression evaluates to NULL, it is treated as LIMIT ALL, i.e., no limit. If <em>start</em> evaluates to NULL, it is treated the same as OFFSET 0.</p><p>SQL:2008 introduced a different syntax to achieve the same result, which PostgreSQL also supports. It is:</p>
<pre>
OFFSET <em>start</em> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <em>count</em> ] { ROW | ROWS } ONLY
</pre>
<p>In this syntax, to write anything except a simple integer constant for <em>start</em> or <em>count</em>, you must write parentheses around it. If <em>count</em> is omitted in a FETCH clause, it defaults to 1. ROW and ROWS as well as FIRST and NEXT are noise words that don&apos;t influence the effects of these clauses. According to the standard, the OFFSET clause must come before the FETCH clause if both are present; but PostgreSQL is laxer and allows either order.</p><p>When using LIMIT, it is a good idea to use an ORDER BY clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query&apos;s rows &ndash; you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don&apos;t know what ordering unless you specify ORDER BY.</p><p>The query planner takes LIMIT into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for LIMIT and OFFSET. Thus, using different LIMIT/OFFSET values to select different subsets of a query result <em>will give inconsistent results</em> unless you enforce a predictable result ordering with ORDER BY. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless ORDER BY is used to constrain the order.</p><p>It is even possible for repeated executions of the same LIMIT query to return different subsets of the rows of a table, if there is not an ORDER BY to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.</p>
<h3>The Locking Clause</h3>
<p>FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE and FOR KEY SHARE are locking clauses; they affect how SELECT locks rows as they are obtained from the table.</p><p>The locking clause has the general form</p>
<pre>
FOR <em>lock_strength</em> [ OF <em>table_name</em> [, ...] ] [ NOWAIT ]
</pre>
<p>where <em>lock_strength</em> can be one of</p>
<pre>
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
</pre>
<p>For more information on each row-level lock mode, refer to Section 13.3.2, &ldquo;Row-level Locks&rdquo;, in the documentation.</p><p>To prevent the operation from waiting for other transactions to commit, use the NOWAIT option. With NOWAIT, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. Note that NOWAIT applies only to the row-level lock(s) &ndash; the required ROW SHARE table-level lock is still taken in the ordinary way (see Chapter 13, Concurrency Control, in the documentation). You can use <a href="../man7/LOCK.7.html"><strong>LOCK</strong>(7)</a> with the NOWAIT option first, if you need to acquire the table-level lock without waiting.</p><p>If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the <strong>SELECT</strong> are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to WITH queries referenced by the primary query. If you want row locking to occur within a WITH query, specify a locking clause within the WITH query.</p><p>Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed as NOWAIT if that is specified in any of the clauses affecting it.</p><p>The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.</p><p>When a locking clause appears at the top level of a <strong>SELECT</strong> query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a LIMIT is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by OFFSET will get locked). Similarly, if a locking clause is used in a cursor&apos;s query, only rows actually fetched or stepped past by the cursor will be locked.</p><p>When a locking clause appears in a sub-<strong>SELECT</strong>, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,</p>
<pre>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
</pre>
<p>will lock only rows having col1 = 5, even though that condition is not textually within the sub-query.</p><p>Previous releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:</p>
<pre>
BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;
</pre>
<p>would fail to preserve the FOR UPDATE lock after the <strong>ROLLBACK TO</strong>. This has been fixed in release 9.3.</p><p><strong>Caution</strong></p><p>It is possible for a <strong>SELECT</strong> command running at the READ COMMITTED transaction isolation level and using ORDER BY and a locking clause to return rows out of order. This is because ORDER BY is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the SELECT unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the FOR UPDATE/SHARE clause in a sub-query, for example</p>
<pre>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;
</pre>
<p>Note that this will result in locking all rows of mytable, whereas FOR UPDATE at the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if the ORDER BY is combined with LIMIT or other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.</p><p>At the REPEATABLE READ or SERIALIZABLE transaction isolation level this would cause a serialization failure (with a SQLSTATE of &apos;40001&apos;), so there is no possibility of receiving rows out of order under these isolation levels.</p>
<h3>TABLE Command</h3>
<p>The command</p>
<pre>
TABLE <em>name</em>
</pre>
<p>is equivalent to</p>
<pre>
SELECT * FROM <em>name</em>
</pre>
<p>It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the WITH, UNION, INTERSECT, EXCEPT, ORDER BY, LIMIT, OFFSET, FETCH and FOR locking clauses can be used with <strong>TABLE</strong>; the WHERE clause and any form of aggregation cannot be used.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>To join the table films with the table distributors:</p>
<pre>
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...
</pre>
<p>To sum the column len of all films and group the results by kind:</p>
<pre>
SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38
</pre>
<p>To sum the column len of all films, group the results by kind and show those group totals that are less than 5 hours:</p>
<pre>
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval &apos;5 hours&apos;;

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38
</pre>
<p>The following two examples are identical ways of sorting the individual results according to the contents of the second column (name):</p>
<pre>
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</pre>
<p>The next example shows how to obtain the union of the tables distributors and actors, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key word ALL is omitted.</p>
<pre>
distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE &apos;W%&apos;
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE &apos;W%&apos;;

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</pre>
<p>This example shows how to use a function in the FROM clause, both with and without a column definition list:</p>
<pre>
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</pre>
<p>Here is an example of a function with an ordinality column added:</p>
<pre>
SELECT * FROM unnest(ARRAY[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)
</pre>
<p>This example shows how to use a simple WITH clause:</p>
<pre>
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
</pre>
<p>Notice that the WITH query was evaluated only once, so that we got two sets of the same three random values.</p><p>This example uses WITH RECURSIVE to find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:</p>
<pre>
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = &apos;Mary&apos;
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
</pre>
<p>Notice the typical form of recursive queries: an initial condition, followed by UNION, followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. (See Section 7.8, &ldquo;WITH Queries (Common Table Expressions)&rdquo;, in the documentation for more examples.)</p><p>This example uses LATERAL to apply a set-returning function <strong>get_product_names()</strong> for each row of the manufacturers table:</p>
<pre>
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
</pre>
<p>Manufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could do:</p>
<pre>
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMPATIBILITY</h2>
        <div class="sectioncontent">
<p>Of course, the <strong>SELECT</strong> statement is compatible with the SQL standard. But there are some extensions and some missing features.</p><h3>Omitted FROM Clauses</h3>
<p>PostgreSQL allows one to omit the FROM clause. It has a straightforward use to compute the results of simple expressions:</p>
<pre>
SELECT 2+2;

 ?column?
----------
        4
</pre>
<p>Some other SQL databases cannot do this except by introducing a dummy one-row table from which to do the <strong>SELECT</strong>.</p><p>Note that if a FROM clause is not specified, the query cannot reference any database tables. For example, the following query is invalid:</p>
<pre>
SELECT distributors.* WHERE distributors.name = &apos;Westward&apos;;
</pre>
<p>PostgreSQL releases prior to 8.1 would accept queries of this form, and add an implicit entry to the query&apos;s FROM clause for each table referenced by the query. This is no longer allowed.</p>
<h3>Empty SELECT Lists</h3>
<p>The list of output expressions after SELECT can be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard. PostgreSQL allows it to be consistent with allowing zero-column tables. However, an empty list is not allowed when DISTINCT is used.</p>
<h3>Omitting the AS Key Word</h3>
<p>In the SQL standard, the optional key word AS can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword). PostgreSQL is slightly more restrictive: AS is required if the new column name matches any keyword at all, reserved or not. Recommended practice is to use AS or double-quote output column names, to prevent any possible conflict against future keyword additions.</p><p>In FROM items, both the standard and PostgreSQL allow AS to be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.</p>
<h3>ONLY and Inheritance</h3>
<p>The SQL standard requires parentheses around the table name when writing ONLY, for example SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE .... PostgreSQL considers these parentheses to be optional.</p><p>PostgreSQL allows a trailing * to be written to explicitly specify the non-ONLY behavior of including child tables. The standard does not allow this.</p><p>(These points apply equally to all SQL commands supporting the ONLY option.)</p>
<h3>Function Calls in FROM</h3>
<p>PostgreSQL allows a function call to be written directly as a member of the FROM list. In the SQL standard it would be necessary to wrap such a function call in a sub-<strong>SELECT</strong>; that is, the syntax FROM <em>func</em>(...) <em>alias</em> is approximately equivalent to FROM LATERAL (SELECT <em>func</em>(...)) <em>alias</em>. Note that LATERAL is considered to be implicit; this is because the standard requires LATERAL semantics for an UNNEST() item in FROM. PostgreSQL treats UNNEST() the same as other set-returning functions.</p>
<h3>Namespace Available to GROUP BY and ORDER BY</h3>
<p>In the SQL-92 standard, an ORDER BY clause can only use output column names or numbers, while a GROUP BY clause can only use expressions based on input column names. PostgreSQL extends each of these clauses to allow the other choice as well (but it uses the standard&apos;s interpretation if there is ambiguity). PostgreSQL also allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.</p><p>SQL:1999 and later use a slightly different definition which is not entirely upward compatible with SQL-92. In most cases, however, PostgreSQL will interpret an ORDER BY or GROUP BY expression the same way SQL:1999 does.</p>
<h3>Functional Dependencies</h3>
<p>PostgreSQL recognizes functional dependency (allowing columns to be omitted from GROUP BY) only when a table&apos;s primary key is included in the GROUP BY list. The SQL standard specifies additional conditions that should be recognized.</p>
<h3>WINDOW Clause Restrictions</h3>
<p>The SQL standard provides additional options for the window <em>frame_clause</em>. PostgreSQL currently supports only the options listed above.</p>
<h3>LIMIT and OFFSET</h3>
<p>The clauses LIMIT and OFFSET are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses OFFSET ... FETCH {FIRST|NEXT} ... for the same functionality, as shown above in LIMIT Clause. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated rownum column, which is not available in PostgreSQL, to implement the effects of these clauses.)</p>
<h3>FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, FOR KEY SHARE</h3>
<p>Although FOR UPDATE appears in the SQL standard, the standard allows it only as an option of <strong>DECLARE CURSOR</strong>. PostgreSQL allows it in any <strong>SELECT</strong> query as well as in sub-<strong>SELECT</strong>s, but this is an extension. The FOR NO KEY UPDATE, FOR SHARE and FOR KEY SHARE variants, as well as the NOWAIT option, do not appear in the standard.</p>
<h3>Data-Modifying Statements in WITH</h3>
<p>PostgreSQL allows <strong>INSERT</strong>, <strong>UPDATE</strong>, and <strong>DELETE</strong> to be used as WITH queries. This is not found in the SQL standard.</p>
<h3>Nonstandard Clauses</h3>
<p>DISTINCT ON ( ... ) is an extension of the SQL standard.</p><p>ROWS FROM( ... ) is an extension of the SQL standard.</p>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SECURITY_LABEL.7.html"><span aria-hidden="true">&larr;</span> SECURITY_LABEL.7: Define or change a security label applied to an object</a></li>
   <li class="next"><a href="SELECT_INTO.7.html">SELECT_INTO.7: Define a new table from the results of a query <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>usb_submit_urb: Issue an asynchronous transfer request for an endpoint</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Issue an asynchronous transfer request for an endpoint">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="usb_submit_urb (9) manual">
  <meta name="twitter:description" content="Issue an asynchronous transfer request for an endpoint">
  <meta name="twitter:image" content="https://www.carta.tech/images/linux-manual-3.16-usb_submit_urb-9.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man9/usb_submit_urb.9.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="usb_submit_urb (9) manual" />
  <meta property="og:description" content="Issue an asynchronous transfer request for an endpoint" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/linux-manual-3.16-usb_submit_urb-9.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">usb_submit_urb<small> (9)</small></h1>
        <p class="lead">Issue an asynchronous transfer request for an endpoint</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/">
      <span itemprop="name">Kernel routines</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/usb_submit_urb.9.html">
      <span itemprop="name">usb_submit_urb: Issue an asynchronous transfer request for an endpoint</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/linux-manual-3.16/">
      <span itemprop="name">linux-manual-3.16</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/usb_submit_urb.9.html">
      <span itemprop="name">usb_submit_urb: Issue an asynchronous transfer request for an endpoint</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>int usb_submit_urb(struct&nbsp;urb&nbsp;*&nbsp;</strong><em>urb</em><strong>, gfp_t&nbsp;</strong><em>mem_flags</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ARGUMENTS</h2>
        <div class="sectioncontent">
<p><em>urb</em></p><p>pointer to the urb describing the request</p><p><em>mem_flags</em></p><p>the type of memory to allocate, see <strong>kmalloc</strong> for a list of valid options for this.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This submits a transfer request, and transfers control of the URB describing that request to the USB subsystem. Request completion will be indicated later, asynchronously, by calling the completion handler. The three types of completion are success, error, and unlink (a software-induced fault, also called &ldquo;request cancellation&rdquo;).</p><p>URBs may be submitted in interrupt context.</p><p>The caller must have correctly initialized the URB before submitting it. Functions such as <strong>usb_fill_bulk_urb</strong> and <strong>usb_fill_control_urb</strong> are available to ensure that most fields are correctly initialized, for the particular kind of transfer, although they will not initialize any transfer flags.</p><p>If the submission is successful, the <strong>complete</strong> callback from the URB will be called exactly once, when the USB core and Host Controller Driver (HCD) are finished with the URB. When the completion function is called, control of the URB is returned to the device driver which issued the request. The completion handler may then immediately free or reuse that URB.</p><p>With few exceptions, USB device drivers should never access URB fields provided by usbcore or the HCD until its <strong>complete</strong> is called. The exceptions relate to periodic transfer scheduling. For both interrupt and isochronous urbs, as part of successful URB submission urb-&gt;interval is modified to reflect the actual transfer period used (normally some power of two units). And for isochronous urbs, urb-&gt;start_frame is modified to reflect when the URB&apos;s transfers were scheduled to start.</p><p>Not all isochronous transfer scheduling policies will work, but most host controller drivers should easily handle ISO queues going from now until 10-200 msec into the future. Drivers should try to keep at least one or two msec of data in the queue; many controllers require that new transfers start at least 1 msec in the future when they are added. If the driver is unable to keep up and the queue empties out, the behavior for new submissions is governed by the URB_ISO_ASAP flag. If the flag is set, or if the queue is idle, then the URB is always assigned to the first available (and not yet expired) slot in the endpoint&apos;s schedule. If the flag is not set and the queue is active then the URB is always assigned to the next slot in the schedule following the end of the endpoint&apos;s previous URB, even if that slot is in the past. When a packet is assigned in this way to a slot that has already expired, the packet is not transmitted and the corresponding usb_iso_packet_descriptor&apos;s status field will return -EXDEV. If this would happen to all the packets in the URB, submission fails with a -EXDEV error code.</p><p>For control endpoints, the synchronous <strong>usb_control_msg</strong> call is often used (in non-interrupt context) instead of this call. That is often used through convenience wrappers, for the requests that are standardized in the USB 2.0 specification. For bulk endpoints, a synchronous <strong>usb_bulk_msg</strong> call is available.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN</h2>
        <div class="sectioncontent">
<p>0 on successful submissions. A negative error number otherwise.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REQUEST QUEUING</h2>
        <div class="sectioncontent">
<p>URBs may be submitted to endpoints before previous ones complete, to minimize the impact of interrupt latencies and system overhead on data throughput. With that queuing policy, an endpoint&apos;s queue would never be empty. This is required for continuous isochronous data streams, and may also be required for some kinds of interrupt transfers. Such queuing also maximizes bandwidth utilization by letting USB controllers start work on later requests before driver software has finished the completion processing for earlier (successful) requests.</p><p>As of Linux 2.6, all USB endpoint transfer queues support depths greater than one. This was previously a HCD-specific behavior, except for ISO transfers. Non-isochronous endpoint queues are inactive during cleanup after faults (transfer errors or cancellation).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESERVED BANDWIDTH TRANSFERS</h2>
        <div class="sectioncontent">
<p>Periodic transfers (interrupt or isochronous) are performed repeatedly, using the interval specified in the urb. Submitting the first urb to the endpoint reserves the bandwidth necessary to make those transfers. If the USB subsystem can&apos;t allocate sufficient bandwidth to perform the periodic request, submitting such a periodic request should fail.</p><p>For devices under xHCI, the bandwidth is reserved at configuration time, or when the alt setting is selected. If there is not enough bus bandwidth, the configuration/alt setting request will fail. Therefore, submissions to periodic endpoints on devices under xHCI should never fail due to bandwidth constraints.</p><p>Device drivers must explicitly request that repetition, by ensuring that some URB is always on the endpoint&apos;s queue (except possibly for short periods during completion callbacks). When there is no longer an urb queued, the endpoint&apos;s bandwidth reservation is canceled. This means drivers can use their completion handlers to ensure they keep bandwidth they need, by reinitializing and resubmitting the just-completed urb until the driver longer needs that periodic bandwidth.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMORY FLAGS</h2>
        <div class="sectioncontent">
<p>The general rules for how to decide which mem_flags to use are the same as for kmalloc. There are four different possible values; GFP_KERNEL, GFP_NOFS, GFP_NOIO and GFP_ATOMIC.</p><p>GFP_NOFS is not ever used, as it has not been implemented yet.</p><p>GFP_ATOMIC is used when (a) you are inside a completion handler, an interrupt, bottom half, tasklet or timer, or (b) you are holding a spinlock or rwlock (does not apply to semaphores), or (c) current-&gt;state != TASK_RUNNING, this is the case only after you&apos;ve changed it.</p><p>GFP_NOIO is used in the block io path and error handling of storage devices.</p><p>All other situations use GFP_KERNEL.</p><p>Some more specific rules for mem_flags can be inferred, such as (1) start_xmit, timeout, and receive methods of network drivers must use GFP_ATOMIC (they are called with a spinlock held); (2) queuecommand methods of scsi drivers must use GFP_ATOMIC (also called with a spinlock held); (3) If you use a kernel thread with a network driver you must use GFP_NOIO, unless (b) or (c) apply; (4) after you have done a <strong>down</strong> you can use GFP_KERNEL, unless (b) or (c) apply or your are in a storage driver&apos;s block io path; (5) USB probe and disconnect can use GFP_KERNEL unless (b) or (c) apply; and (6) changing firmware on a running storage or net device uses GFP_NOIO, unless b) or c) apply</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="usb_string_ids_tab.9.html"><span aria-hidden="true">&larr;</span> usb_string_ids_tab.9: Allocate unused string ids in batch</a></li>
   <li class="next"><a href="usb_unanchor_urb.9.html">usb_unanchor_urb.9: Unanchors an urb <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

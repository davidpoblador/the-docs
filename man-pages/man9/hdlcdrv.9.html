<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>hdlcdrv: Hdlc amateur (ax.25) packet radio network driver</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Hdlc amateur (ax.25) packet radio network driver">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="hdlcdrv (9) manual">
  <meta name="twitter:description" content="Hdlc amateur (ax.25) packet radio network driver">
  <meta name="twitter:image" content="https://www.carta.tech/images/ax25-tools-hdlcdrv-9.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man9/hdlcdrv.9.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="hdlcdrv (9) manual" />
  <meta property="og:description" content="Hdlc amateur (ax.25) packet radio network driver" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ax25-tools-hdlcdrv-9.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">hdlcdrv<small> (9)</small></h1>
        <p class="lead">Hdlc amateur (ax.25) packet radio network driver</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/">
      <span itemprop="name">Kernel routines</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/hdlcdrv.9.html">
      <span itemprop="name">hdlcdrv: Hdlc amateur (ax.25) packet radio network driver</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ax25-tools/">
      <span itemprop="name">ax25-tools</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/hdlcdrv.9.html">
      <span itemprop="name">hdlcdrv: Hdlc amateur (ax.25) packet radio network driver</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;linux/hdlcdrv.h&gt;</strong></p><p><strong>linux/drivers/net/hdlcdrv.c</strong></p><p><strong>extern inline void hdlcdrv_putbits(struct hdlcdrv_state * </strong><em>s</em><strong>, unsigned int </strong><em>bits</em><strong>);</strong></p><p><strong>extern inline unsigned int hdlcdrv_getbits(struct hdlcdrv_state * </strong><em>s</em><strong>);</strong></p><p><strong>extern inline void hdlcdrv_channelbit(struct hdlcdrv_state * </strong><em>s</em><strong>, unsigned int </strong><em>bit</em><strong>);</strong></p><p><strong>extern inline void hdlcdrv_setdcd(struct hdlcdrv_state * </strong><em>s</em><strong> , int </strong><em>dcd</em><strong>);</strong></p><p><strong>extern inline int hdlcdrv_ptt(struct hdlcdrv_state * </strong><em>s</em><strong>);</strong></p><p><strong>void hdlcdrv_receiver(struct device *, struct hdlcdrv_state *);</strong></p><p><strong>void hdlcdrv_transmitter(struct device *, struct hdlcdrv_state *);</strong></p><p><strong>void hdlcdrv_arbitrate(struct device *, struct hdlcdrv_state *);</strong></p><p><strong>int hdlcdrv_register_hdlcdrv(struct device * </strong><em>dev</em><strong>, struct hdlcdrv_ops * </strong><em>ops</em><strong>, unsigned int </strong><em>privsize</em><strong>, char * </strong><em>ifname</em><strong>, unsigned int </strong><em>baseaddr</em><strong> , unsigned int </strong><em>irq</em><strong>, unsigned int </strong><em>dma</em><strong>);</strong></p><p><strong>int hdlcdrv_unregister_hdlcdrv(struct device * </strong><em>dev</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This driver should ease the implementation of simple AX.25 packet radio modems where the software is responsible for the HDLC encoding and decoding. Examples of such modems include the <em>baycom</em> family and the <em>soundcard</em> modems.</p><p>This driver provides a standard Linux network driver interface. It can even be compiled if Kernel AX.25 is not enabled in the Linux configuration. This allows this driver to be used even for userland AX.25 stacks such as <em>Wampes</em> or <em>TNOS</em>, with the help of the <em>net2kiss</em> utility.</p><p>This driver does not access any hardware; it is the responsibility of an additional hardware driver such as <em>baycom</em> or <em>soundmodem</em> to access the hardware and derive the bitstream to feed into this driver.</p><p>The hardware driver should store its state in a structure of the following form:</p>
<pre>
struct hwdrv_state {
	struct hdlc_state <em>hdrv</em>;

	... the drivers private state
};
</pre>
<p>A pointer to this structure will be stored in <em>dev-&gt;priv</em>.</p><p><strong>hdlcdrv_register_hdlcdrv</strong> registers a hardware driver to the hdlc driver. <em>dev</em> points to storage for the <em>device</em> structure, which must be provided by the hardware driver, but gets initialized by this function call. <em>ops</em> provides information about the hardware driver and its calls. <em>privsize</em> should be <em>sizeof(struct&nbsp;hwdrv_state)</em>. <em>ifname</em> specifies the name the interface should get. <em>baseaddr</em>, <em>irq</em> and <em>dma</em> are simply stored in the <em>device</em> structure. After this function succeeds, the interface is registered with the kernel. It is not running, however, this must be done with <strong>ifconfig&nbsp;</strong><em>ifname</em><strong>&nbsp;up</strong>.</p><p><strong>hdlcdrv_unregister_hdlcdrv</strong> shuts the interface down and unregisters it with the kernel.</p><p><strong>hdlcdrv_putbits</strong> delivers 16 received bits for processing to the HDLC driver. This routine merely stores them in a buffer and does not process them. It is thus fast and can be called with interrupts off. The least significant bit should be the first one received.</p><p><strong>hdlcdrv_getbits</strong> requests 16 bits from the driver for transmission. The least significant bit should be transmitted first. This routine takes them from a buffer and is therefore fast. It can be called with interrupts off.</p><p><strong>hdlcdrv_channelbit</strong> puts a single bit into a buffer, which can be displayed with <strong>sethdlc&nbsp;-s</strong>. It is intended for driver debugging purposes.</p><p><strong>hdlcdrv_setdcd</strong> informs the HDLC driver about the channel state (i.e. if the hardware driver detected a data carrier). This information is used in the channel access algorithm, i.e. it prevents the driver from transmitting on a half duplex channel if there is already a transmitter on air.</p><p><strong>hdlcdrv_ptt</strong> should be called by the hardware driver to determine if it should start or stop transmitting. The hardware driver does not need to worry about keyup delays. This is done by the HDLC driver.</p><p><strong>hdlcdrv_receiver</strong> actually processes the received bits delivered by <strong>hdlcdrv_putbits</strong>. It should be called with interrupts on. It guards itself against reentrance problems.</p><p><strong>hdlcdrv_transmitter</strong> actually prepares the bits to be transmitted. It should be called with interrupts on. It guards itself against reentrance problems.</p><p><strong>hdlcdrv_arbitrate</strong> does the channel access algorithm (p-persistent CSMA). It should be called once every 10ms. Note that the hardware driver <strong>must</strong> set the <em>hdrv.par.bitrate</em> field prior to starting operation so that <strong>hdlcdrv</strong> can calculate the transmitter keyup delay correctly.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HARDWARE DRIVER ENTRY POINTS</h2>
        <div class="sectioncontent">
<p>The hardware driver should provide the following information to the HDLC driver:</p>
<pre>
struct hdlcdrv_ops {
        const char *<em>drvname</em>;
        const char *<em>drvinfo</em>;
        int (*<em>open</em>)(struct device *);
        int (*<em>close</em>)(struct device *);
        int (*<em>ioctl</em>)(struct device *, struct ifreq *, int);
};
</pre>
<p><strong>drvname</strong> and <strong>drvinfo</strong> are just for informational purposes.</p><p>The following routines receive a pointer to the <em>device</em> structure, where they may find the io address, irq and dma channels.</p><p><strong>open</strong> must be provided. It is called during <strong>ifconfig&nbsp;</strong><em>ifname</em><strong>&nbsp;up</strong> and should check for the hardware, grab it and initialize it. It usually installs an interrupt handler which then gets invoked by the hardware.</p><p><strong>close</strong> must be provided. It is called during <strong>ifconfig&nbsp;</strong><em>ifname</em><strong>&nbsp;down</strong> and should undo all actions done by <strong>open</strong>, i.e. release io regions and irqs.</p><p><strong>ioctl</strong> may be provided to implement device specific ioctl's.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IOCTL CALLS</h2>
        <div class="sectioncontent">
<p>The driver only responds to <em>SIOCDEVPRIVATE</em>. Parameters are passed from and to the driver using the following struct:</p>
<pre>
struct hdlcdrv_ioctl {
        int cmd;
        union {
                struct hdlcdrv_params mp;
                struct hdlcdrv_channel_params cp;
                struct hdlcdrv_channel_state cs;
                unsigned int calibrate;
                unsigned char bits;
        } data;
};
</pre>
<p>Since the 16 private <em>ioctl&nbsp;request</em> numbers for network drivers were not enough, the driver implements its own <em>sub&nbsp;request</em> number with <em>cmd</em>. The following numbers are implemented:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>HDLCDRVCTL_GETMODEMPAR</strong></p>
  </dt>
  <dd>
    <p>returns the IO parameters of the modem in <em>data.mp</em>. This includes the io address, irq, eventually dma, and ports to output a PTT signal.</p>
  </dd>
  <dt>
    <p><strong>HDLCDRVCTL_SETMODEMPAR</strong></p>
  </dt>
  <dd>
    <p>sets the modem parameters. Only superuser can do this. Parameters can only be changed if the interface is not running (i.e. down).</p>
  </dd>
  <dt>
    <p><strong>HDLCDRVCTL_GETCHANNELPAR</strong></p>
  </dt>
  <dd>
    <p>returns the channel access parameters.</p>
  </dd>
  <dt>
    <p><strong>HDLCDRVCTL_SETCHANNELPAR</strong></p>
  </dt>
  <dd>
    <p>sets the channel access parameters. Only superuser can do this. They may also be changed using the <strong>kissparms</strong> command if using kernel AX.25 or the <strong>param</strong> command of <strong>*NOS</strong>.</p>
  </dd>
  <dt>
    <p><strong>HDLCDRVCTL_GETSTAT</strong></p>
  </dt>
  <dd>
    <p>statistics and status information, such as if a carrier is detected on the channel and if the interface is currently transmitting.</p>
  </dd>
  <dt>
    <p><strong>HDLCDRVCTL_CALIBRATE</strong></p>
  </dt>
  <dd>
    <p>instructs the driver to transmit a calibration pattern for the specified number of seconds.</p>
  </dd>
  <dt>
    <p><strong>HDLCDRVCTL_GETSAMPLES</strong></p>
  </dt>
  <dd>
    <p>returns the bits delivered by the hardware driver with <em>hdlcdrv_channelbit</em>. The bits are returned 8 at a time with the least significant bit the first one. This command may not be available, depending on debugging settings.</p>
  </dd>
  <dt>
    <p><strong>HDLCDRVCTL_GETBITS</strong></p>
  </dt>
  <dd>
    <p>returns the bits delivered by the hardware driver to the HDLC decoder. The bits are returned 8 at a time with the least significant bit the first one. This command may not be available, depending on debugging settings.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO hdlcdrv&hellip;</h2>
        <div class="sectioncontent">
<p><strong>baycom</strong>&nbsp;(9), <strong>soundmodem</strong>&nbsp;(9), <strong>sethdlc</strong>&nbsp;(8),  linux/drivers/net/hdlcdrv.c,</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>hdlcdrv was written by Thomas Sailer, HB9JNX/AE4WA, (t.sailer@alumni.ethz.ch).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="hcd_buffer_destroy.9.html"><span aria-hidden="true">&larr;</span> hcd_buffer_destroy.9: Deallocate buffer pools</a></li>
   <li class="next"><a href="hdmi_audio_infoframe_init.9.html">hdmi_audio_infoframe_init.9: Initialize an hdmi audio infoframe <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

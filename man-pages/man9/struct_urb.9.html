<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>struct_urb: Usb request block</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Usb request block">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="struct_urb (9) manual">
  <meta name="twitter:description" content="Usb request block">
  <meta name="twitter:image" content="https://www.carta.tech/images/linux-manual-3.16-struct_urb-9.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man9/struct_urb.9.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="struct_urb (9) manual" />
  <meta property="og:description" content="Usb request block" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/linux-manual-3.16-struct_urb-9.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">struct_urb<small> (9)</small></h1>
        <p class="lead">Usb request block</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/">
      <span itemprop="name">Kernel routines</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/struct_urb.9.html">
      <span itemprop="name">struct_urb: Usb request block</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/linux-manual-3.16/">
      <span itemprop="name">linux-manual-3.16</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/struct_urb.9.html">
      <span itemprop="name">struct_urb: Usb request block</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
struct urb {
  struct list_head urb_list;
  struct list_head anchor_list;
  struct usb_anchor * anchor;
  struct usb_device * dev;
  struct usb_host_endpoint * ep;
  unsigned int pipe;
  unsigned int stream_id;
  int status;
  unsigned int transfer_flags;
  void * transfer_buffer;
  dma_addr_t transfer_dma;
  struct scatterlist * sg;
  int num_mapped_sgs;
  int num_sgs;
  u32 transfer_buffer_length;
  u32 actual_length;
  unsigned char * setup_packet;
  dma_addr_t setup_dma;
  int start_frame;
  int number_of_packets;
  int interval;
  int error_count;
  void * context;
  usb_complete_t complete;
  struct usb_iso_packet_descriptor iso_frame_desc[0];
};
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMBERS</h2>
        <div class="sectioncontent">
<p>urb_list</p><p>For use by current owner of the URB.</p><p>anchor_list</p><p>membership in the list of an anchor</p><p>anchor</p><p>to anchor URBs to a common mooring</p><p>dev</p><p>Identifies the USB device to perform the request.</p><p>ep</p><p>Points to the endpoint&apos;s data structure. Will eventually replace <em>pipe</em>.</p><p>pipe</p><p>Holds endpoint number, direction, type, and more. Create these values with the eight macros available; usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is &ldquo;ctrl&rdquo; (control), &ldquo;bulk&rdquo;, &ldquo;int&rdquo; (interrupt), or &ldquo;iso&rdquo; (isochronous). For example <strong>usb_sndbulkpipe</strong> or <strong>usb_rcvintpipe</strong>. Endpoint numbers range from zero to fifteen. Note that &ldquo;in&rdquo; endpoint two is a different endpoint (and pipe) from &ldquo;out&rdquo; endpoint two. The current configuration controls the existence, type, and maximum packet size of any given endpoint.</p><p>stream_id</p><p>the endpoint&apos;s stream ID for bulk streams</p><p>status</p><p>This is read in non-iso completion functions to get the status of the particular request. ISO requests only use it to tell whether the URB was unlinked; detailed status for each frame is in the fields of the iso_frame-desc.</p><p>transfer_flags</p><p>A variety of flags may be used to affect how URB submission, unlinking, or operation are handled. Different kinds of URB can use different flags.</p><p>transfer_buffer</p><p>This identifies the buffer to (or from) which the I/O request will be performed unless URB_NO_TRANSFER_DMA_MAP is set (however, do not leave garbage in transfer_buffer even then). This buffer must be suitable for DMA; allocate it with <strong>kmalloc</strong> or equivalent. For transfers to &ldquo;in&rdquo; endpoints, contents of this buffer will be modified. This buffer is used for the data stage of control transfers.</p><p>transfer_dma</p><p>When transfer_flags includes URB_NO_TRANSFER_DMA_MAP, the device driver is saying that it provided this DMA address, which the host controller driver should use in preference to the transfer_buffer.</p><p>sg</p><p>scatter gather buffer list, the buffer size of each element in the list (except the last) must be divisible by the endpoint&apos;s max packet size if no_sg_constraint isn&apos;t set in &apos;struct usb_bus&apos;</p><p>num_mapped_sgs</p><p>(internal) number of mapped sg entries</p><p>num_sgs</p><p>number of entries in the sg list</p><p>transfer_buffer_length</p><p>How big is transfer_buffer. The transfer may be broken up into chunks according to the current maximum packet size for the endpoint, which is a function of the configuration and is encoded in the pipe. When the length is zero, neither transfer_buffer nor transfer_dma is used.</p><p>actual_length</p><p>This is read in non-iso completion functions, and it tells how many bytes (out of transfer_buffer_length) were transferred. It will normally be the same as requested, unless either an error was reported or a short read was performed. The URB_SHORT_NOT_OK transfer flag may be used to make such short reads be reported as errors.</p><p>setup_packet</p><p>Only used for control transfers, this points to eight bytes of setup data. Control transfers always start by sending this data to the device. Then transfer_buffer is read or written, if needed.</p><p>setup_dma</p><p>DMA pointer for the setup packet. The caller must not use this field; setup_packet must point to a valid buffer.</p><p>start_frame</p><p>Returns the initial frame for isochronous transfers.</p><p>number_of_packets</p><p>Lists the number of ISO transfer buffers.</p><p>interval</p><p>Specifies the polling interval for interrupt or isochronous transfers. The units are frames (milliseconds) for full and low speed devices, and microframes (1/8 millisecond) for highspeed and SuperSpeed devices.</p><p>error_count</p><p>Returns the number of ISO transfers that reported errors.</p><p>context</p><p>For use in completion functions. This normally points to request-specific driver context.</p><p>complete</p><p>Completion handler. This URB is passed as the parameter to the completion function. The completion function may then do what it likes with the URB, including resubmitting or freeing it.</p><p>iso_frame_desc[0]</p><p>Used to provide arrays of ISO transfer buffers and to collect the transfer status for each buffer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This structure identifies USB transfer requests. URBs must be allocated by calling <strong>usb_alloc_urb</strong> and freed with a call to <strong>usb_free_urb</strong>. Initialization may be done using various usb_fill_*<strong>_urb</strong> functions. URBs are submitted using <strong>usb_submit_urb</strong>, and pending requests may be canceled using <strong>usb_unlink_urb</strong> or <strong>usb_kill_urb</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TRANSFER BUFFERS</h2>
        <div class="sectioncontent">
<p>Normally drivers provide I/O buffers allocated with <strong>kmalloc</strong> or otherwise taken from the general page pool. That is provided by transfer_buffer (control requests also use setup_packet), and host controller drivers perform a dma mapping (and unmapping) for each buffer transferred. Those mapping operations can be expensive on some platforms (perhaps using a dma bounce buffer or talking to an IOMMU), although they&apos;re cheap on commodity x86 and ppc hardware.</p><p>Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag, which tells the host controller driver that no such mapping is needed for the transfer_buffer since the device driver is DMA-aware. For example, a device driver might allocate a DMA buffer with <strong>usb_alloc_coherent</strong> or call <strong>usb_buffer_map</strong>. When this transfer flag is provided, host controller drivers will attempt to use the dma address found in the transfer_dma field rather than determining a dma address themselves.</p><p>Note that transfer_buffer must still be set if the controller does not support DMA (as indicated by bus.uses_dma) and when talking to root hub. If you have to trasfer between highmem zone and the device on such controller, create a bounce buffer or bail out with an error. If transfer_buffer cannot be set (is in highmem) and the controller is DMA capable, assign NULL to it, so that usbmon knows not to use the value. The setup_packet must always be set, so it cannot be located in highmem.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INITIALIZATION</h2>
        <div class="sectioncontent">
<p>All URBs submitted must initialize the dev, pipe, transfer_flags (may be zero), and complete fields. All URBs must also initialize transfer_buffer and transfer_buffer_length. They may provide the URB_SHORT_NOT_OK transfer flag, indicating that short reads are to be treated as errors; that flag is invalid for write requests.</p><p>Bulk URBs may use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers should always terminate with a short packet, even if it means adding an extra zero length packet.</p><p>Control URBs must provide a valid pointer in the setup_packet field. Unlike the transfer_buffer, the setup_packet may not be mapped for DMA beforehand.</p><p>Interrupt URBs must provide an interval, saying how often (in milliseconds or, for highspeed devices, 125 microsecond units) to poll for transfers. After the URB has been submitted, the interval field reflects how the transfer was actually scheduled. The polling interval may be more frequent than requested. For example, some controllers have a maximum interval of 32 milliseconds, while others support intervals of up to 1024 milliseconds. Isochronous URBs also have transfer intervals. (Note that for isochronous endpoints, as well as high speed interrupt endpoints, the encoding of the transfer interval in the endpoint descriptor is logarithmic. Device drivers must convert that value to linear units themselves.)</p><p>If an isochronous endpoint queue isn&apos;t already running, the host controller will schedule a new URB to start as soon as bandwidth utilization allows. If the queue is running then a new URB will be scheduled to start in the first transfer slot following the end of the preceding URB, if that slot has not already expired. If the slot has expired (which can happen when IRQ delivery is delayed for a long time), the scheduling behavior depends on the URB_ISO_ASAP flag. If the flag is clear then the URB will be scheduled to start in the expired slot, implying that some of its packets will not be transferred; if the flag is set then the URB will be scheduled in the first unexpired slot, breaking the queue&apos;s synchronization. Upon URB completion, the start_frame field will be set to the (micro)frame number in which the transfer was scheduled. Ranges for frame counter values are HC-specific and can go from as low as 256 to as high as 65536 frames.</p><p>Isochronous URBs have a different data transfer model, in part because the quality of service is only &ldquo;best effort&rdquo;. Callers provide specially allocated URBs, with number_of_packets worth of iso_frame_desc structures at the end. Each such packet is an individual ISO transfer. Isochronous URBs are normally queued, submitted by drivers to arrange that transfers are at least double buffered, and then explicitly resubmitted in completion handlers, so that data (such as audio or video) streams at as constant a rate as the host controller scheduler can support.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMPLETION CALLBACKS</h2>
        <div class="sectioncontent">
<p>The completion callback is made <strong>in_interrupt</strong>, and one of the first things that a completion handler should do is check the status field. The status field is provided for all URBs. It is used to report unlinked URBs, and status for all non-ISO transfers. It should not be examined before the URB is returned to the completion handler.</p><p>The context field is normally used to link URBs back to the relevant driver or request state.</p><p>When the completion callback is invoked for non-isochronous URBs, the actual_length field tells how many bytes were transferred. This field is updated even when the URB terminated with an error or was unlinked.</p><p>ISO transfer status is reported in the status and actual_length fields of the iso_frame_desc array, and the number of errors is reported in error_count. Completion callbacks for ISO transfers will normally (re)submit URBs to ensure a constant transfer rate.</p><p>Note that even fields marked &ldquo;public&rdquo; should not be touched by the driver when the urb is owned by the hcd, that is, since the call to <strong>usb_submit_urb</strong> till the entry into the completion routine.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="struct_uio_port.9.html"><span aria-hidden="true">&larr;</span> struct_uio_port.9: Description of a uio port region</a></li>
   <li class="next"><a href="struct_usb_class_driver.9.html">struct_usb_class_driver.9: Identifies a usb driver that wants to use the usb major number <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

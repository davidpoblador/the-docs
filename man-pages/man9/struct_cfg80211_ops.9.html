<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>struct_cfg80211_ops: Backend description for wireless configuration</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Backend description for wireless configuration">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="struct_cfg80211_ops (9) manual">
  <meta name="twitter:description" content="Backend description for wireless configuration">
  <meta name="twitter:image" content="https://www.carta.tech/images/linux-manual-3.16-struct_cfg80211_ops-9.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man9/struct_cfg80211_ops.9.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="struct_cfg80211_ops (9) manual" />
  <meta property="og:description" content="Backend description for wireless configuration" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/linux-manual-3.16-struct_cfg80211_ops-9.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">struct_cfg80211_ops<small> (9)</small></h1>
        <p class="lead">Backend description for wireless configuration</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/">
      <span itemprop="name">Kernel routines</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/struct_cfg80211_ops.9.html">
      <span itemprop="name">struct_cfg80211_ops: Backend description for wireless configuration</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/linux-manual-3.16/">
      <span itemprop="name">linux-manual-3.16</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/struct_cfg80211_ops.9.html">
      <span itemprop="name">struct_cfg80211_ops: Backend description for wireless configuration</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
struct cfg80211_ops {
  int (* suspend) (struct wiphy *wiphy, struct cfg80211_wowlan *wow);
  int (* resume) (struct wiphy *wiphy);
  void (* set_wakeup) (struct wiphy *wiphy, bool enabled);
  struct wireless_dev * (* add_virtual_intf) (struct wiphy *wiphy,const char *name,enum nl80211_iftype type,u32 *flags,struct vif_params *params);
  int (* del_virtual_intf) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* change_virtual_intf) (struct wiphy *wiphy,struct net_device *dev,enum nl80211_iftype type, u32 *flags,struct vif_params *params);
  int (* add_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,struct key_params *params);
  int (* get_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,void *cookie,void (*callback);
  int (* del_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr);
  int (* set_default_key) (struct wiphy *wiphy,struct net_device *netdev,u8 key_index, bool unicast, bool multicast);
  int (* set_default_mgmt_key) (struct wiphy *wiphy,struct net_device *netdev,u8 key_index);
  int (* start_ap) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_ap_settings *settings);
  int (* change_beacon) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_beacon_data *info);
  int (* stop_ap) (struct wiphy *wiphy, struct net_device *dev);
  int (* add_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac,struct station_parameters *params);
  int (* del_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac);
  int (* change_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac,struct station_parameters *params);
  int (* get_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac, struct station_info *sinfo);
  int (* dump_station) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *mac, struct station_info *sinfo);
  int (* add_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst, const u8 *next_hop);
  int (* del_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst);
  int (* change_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst, const u8 *next_hop);
  int (* get_mpath) (struct wiphy *wiphy, struct net_device *dev,u8 *dst, u8 *next_hop, struct mpath_info *pinfo);
  int (* dump_mpath) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *dst, u8 *next_hop,struct mpath_info *pinfo);
  int (* get_mesh_config) (struct wiphy *wiphy,struct net_device *dev,struct mesh_config *conf);
  int (* update_mesh_config) (struct wiphy *wiphy,struct net_device *dev, u32 mask,const struct mesh_config *nconf);
  int (* join_mesh) (struct wiphy *wiphy, struct net_device *dev,const struct mesh_config *conf,const struct mesh_setup *setup);
  int (* leave_mesh) (struct wiphy *wiphy, struct net_device *dev);
  int (* change_bss) (struct wiphy *wiphy, struct net_device *dev,struct bss_parameters *params);
  int (* set_txq_params) (struct wiphy *wiphy, struct net_device *dev,struct ieee80211_txq_params *params);
  int (* libertas_set_mesh_channel) (struct wiphy *wiphy,struct net_device *dev,struct ieee80211_channel *chan);
  int (* set_monitor_channel) (struct wiphy *wiphy,struct cfg80211_chan_def *chandef);
  int (* scan) (struct wiphy *wiphy,struct cfg80211_scan_request *request);
  int (* auth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_auth_request *req);
  int (* assoc) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_assoc_request *req);
  int (* deauth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_deauth_request *req);
  int (* disassoc) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_disassoc_request *req);
  int (* connect) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_connect_params *sme);
  int (* disconnect) (struct wiphy *wiphy, struct net_device *dev,u16 reason_code);
  int (* join_ibss) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_ibss_params *params);
  int (* leave_ibss) (struct wiphy *wiphy, struct net_device *dev);
  int (* set_mcast_rate) (struct wiphy *wiphy, struct net_device *dev,int rate[IEEE80211_NUM_BANDS]);
  int (* set_wiphy_params) (struct wiphy *wiphy, u32 changed);
  int (* set_tx_power) (struct wiphy *wiphy, struct wireless_dev *wdev,enum nl80211_tx_power_setting type, int mbm);
  int (* get_tx_power) (struct wiphy *wiphy, struct wireless_dev *wdev,int *dbm);
  int (* set_wds_peer) (struct wiphy *wiphy, struct net_device *dev,const u8 *addr);
  void (* rfkill_poll) (struct wiphy *wiphy);
#ifdef CONFIG_NL80211_TESTMODE
  int (* testmode_cmd) (struct wiphy *wiphy, struct wireless_dev *wdev,void *data, int len);
  int (* testmode_dump) (struct wiphy *wiphy, struct sk_buff *skb,struct netlink_callback *cb,void *data, int len);
#endif
  int (* set_bitrate_mask) (struct wiphy *wiphy,struct net_device *dev,const u8 *peer,const struct cfg80211_bitrate_mask *mask);
  int (* dump_survey) (struct wiphy *wiphy, struct net_device *netdev,int idx, struct survey_info *info);
  int (* set_pmksa) (struct wiphy *wiphy, struct net_device *netdev,struct cfg80211_pmksa *pmksa);
  int (* del_pmksa) (struct wiphy *wiphy, struct net_device *netdev,struct cfg80211_pmksa *pmksa);
  int (* flush_pmksa) (struct wiphy *wiphy, struct net_device *netdev);
  int (* remain_on_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,struct ieee80211_channel *chan,unsigned int duration,u64 *cookie);
  int (* cancel_remain_on_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,u64 cookie);
  int (* mgmt_tx) (struct wiphy *wiphy, struct wireless_dev *wdev,struct cfg80211_mgmt_tx_params *params,u64 *cookie);
  int (* mgmt_tx_cancel_wait) (struct wiphy *wiphy,struct wireless_dev *wdev,u64 cookie);
  int (* set_power_mgmt) (struct wiphy *wiphy, struct net_device *dev,bool enabled, int timeout);
  int (* set_cqm_rssi_config) (struct wiphy *wiphy,struct net_device *dev,s32 rssi_thold, u32 rssi_hyst);
  int (* set_cqm_txe_config) (struct wiphy *wiphy,struct net_device *dev,u32 rate, u32 pkts, u32 intvl);
  void (* mgmt_frame_register) (struct wiphy *wiphy,struct wireless_dev *wdev,u16 frame_type, bool reg);
  int (* set_antenna) (struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);
  int (* get_antenna) (struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);
  int (* set_ringparam) (struct wiphy *wiphy, u32 tx, u32 rx);
  void (* get_ringparam) (struct wiphy *wiphy,u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
  int (* sched_scan_start) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_sched_scan_request *request);
  int (* sched_scan_stop) (struct wiphy *wiphy, struct net_device *dev);
  int (* set_rekey_data) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_gtk_rekey_data *data);
  int (* tdls_mgmt) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u8 action_code,  u8 dialog_token,u16 status_code, u32 peer_capability,const u8 *buf, size_t len);
  int (* tdls_oper) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, enum nl80211_tdls_operation oper);
  int (* probe_client) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u64 *cookie);
  int (* set_noack_map) (struct wiphy *wiphy,struct net_device *dev,u16 noack_map);
  int (* get_et_sset_count) (struct wiphy *wiphy,struct net_device *dev, int sset);
  void (* get_et_stats) (struct wiphy *wiphy, struct net_device *dev,struct ethtool_stats *stats, u64 *data);
  void (* get_et_strings) (struct wiphy *wiphy, struct net_device *dev,u32 sset, u8 *data);
  int (* get_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,struct cfg80211_chan_def *chandef);
  int (* start_p2p_device) (struct wiphy *wiphy,struct wireless_dev *wdev);
  void (* stop_p2p_device) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* set_mac_acl) (struct wiphy *wiphy, struct net_device *dev,const struct cfg80211_acl_data *params);
  int (* start_radar_detection) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_chan_def *chandef,u32 cac_time_ms);
  int (* update_ft_ies) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_update_ft_ies_params *ftie);
  int (* crit_proto_start) (struct wiphy *wiphy,struct wireless_dev *wdev,enum nl80211_crit_proto_id protocol,u16 duration);
  void (* crit_proto_stop) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* set_coalesce) (struct wiphy *wiphy,struct cfg80211_coalesce *coalesce);
  int (* channel_switch) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_csa_settings *params);
  int (* set_qos_map) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_qos_map *qos_map);
  int (* set_ap_chanwidth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_chan_def *chandef);
};
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMBERS</h2>
        <div class="sectioncontent">
<p>suspend</p><p>wiphy device needs to be suspended. The variable <em>wow</em> will be <strong>NULL</strong> or contain the enabled Wake-on-Wireless triggers that are configured for the device.</p><p>resume</p><p>wiphy device needs to be resumed</p><p>set_wakeup</p><p>Called when WoWLAN is enabled/disabled, use this callback to call <strong>device_set_wakeup_enable</strong> to enable/disable wakeup from the device.</p><p>add_virtual_intf</p><p>create a new virtual interface with the given name, must set the struct wireless_dev&apos;s iftype. Beware: You must create the new netdev in the wiphy&apos;s network namespace! Returns the struct wireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must also set the address member in the wdev.</p><p>del_virtual_intf</p><p>remove the virtual interface</p><p>change_virtual_intf</p><p>change type/configuration of virtual interface, keep the struct wireless_dev&apos;s iftype updated.</p><p>add_key</p><p>add a key with the given parameters. <em>mac_addr</em> will be <strong>NULL</strong> when adding a group key.</p><p>get_key</p><p>get information about the key with the given parameters. <em>mac_addr</em> will be <strong>NULL</strong> when requesting information for a group key. All pointers given to the <em>callback</em> function need not be valid after it returns. This function should return an error if it is not possible to retrieve the key, -ENOENT if it doesn&apos;t exist.</p><p>del_key</p><p>remove a key given the <em>mac_addr</em> (<strong>NULL</strong> for a group key) and <em>key_index</em>, return -ENOENT if the key doesn&apos;t exist.</p><p>set_default_key</p><p>set the default key on an interface</p><p>set_default_mgmt_key</p><p>set the default management frame key on an interface</p><p>start_ap</p><p>Start acting in AP mode defined by the parameters.</p><p>change_beacon</p><p>Change the beacon parameters for an access point mode interface. This should reject the call when AP mode wasn&apos;t started.</p><p>stop_ap</p><p>Stop being an AP, including stopping beaconing.</p><p>add_station</p><p>Add a new station.</p><p>del_station</p><p>Remove a station; <em>mac</em> may be NULL to remove all stations.</p><p>change_station</p><p>Modify a given station. Note that flags changes are not much validated in cfg80211, in particular the auth/assoc/authorized flags might come to the driver in invalid combinations -- make sure to check them, also against the existing state! Drivers must call <strong>cfg80211_check_station_change</strong> to validate the information.</p><p>get_station</p><p>get station information for the station identified by <em>mac</em></p><p>dump_station</p><p>dump station callback -- resume dump at index <em>idx</em></p><p>add_mpath</p><p>add a fixed mesh path</p><p>del_mpath</p><p>delete a given mesh path</p><p>change_mpath</p><p>change a given mesh path</p><p>get_mpath</p><p>get a mesh path for the given parameters</p><p>dump_mpath</p><p>dump mesh path callback -- resume dump at index <em>idx</em></p><p>get_mesh_config</p><p>Get the current mesh configuration</p><p>update_mesh_config</p><p>Update mesh parameters on a running mesh. The mask is a bitfield which tells us which parameters to set, and which to leave alone.</p><p>join_mesh</p><p>join the mesh network with the specified parameters (invoked with the wireless_dev mutex held)</p><p>leave_mesh</p><p>leave the current mesh network (invoked with the wireless_dev mutex held)</p><p>change_bss</p><p>Modify parameters for a given BSS.</p><p>set_txq_params</p><p>Set TX queue parameters</p><p>libertas_set_mesh_channel</p><p>Only for backward compatibility for libertas, as it doesn&apos;t implement join_mesh and needs to set the channel to join the mesh instead.</p><p>set_monitor_channel</p><p>Set the monitor mode channel for the device. If other interfaces are active this callback should reject the configuration. If no interfaces are active or the device is down, the channel should be stored for when a monitor interface becomes active.</p><p>scan</p><p>Request to do a scan. If returning zero, the scan request is given the driver, and will be valid until passed to <strong>cfg80211_scan_done</strong>. For scan results, call <strong>cfg80211_inform_bss</strong>; you can call this outside the scan/scan_done bracket too.</p><p>auth</p><p>Request to authenticate with the specified peer (invoked with the wireless_dev mutex held)</p><p>assoc</p><p>Request to (re)associate with the specified peer (invoked with the wireless_dev mutex held)</p><p>deauth</p><p>Request to deauthenticate from the specified peer (invoked with the wireless_dev mutex held)</p><p>disassoc</p><p>Request to disassociate from the specified peer (invoked with the wireless_dev mutex held)</p><p>connect</p><p>Connect to the ESS with the specified parameters. When connected, call <strong>cfg80211_connect_result</strong> with status code <strong>WLAN_STATUS_SUCCESS</strong>. If the connection fails for some reason, call <strong>cfg80211_connect_result</strong> with the status from the AP. (invoked with the wireless_dev mutex held)</p><p>disconnect</p><p>Disconnect from the BSS/ESS. (invoked with the wireless_dev mutex held)</p><p>join_ibss</p><p>Join the specified IBSS (or create if necessary). Once done, call <strong>cfg80211_ibss_joined</strong>, also call that function when changing BSSID due to a merge. (invoked with the wireless_dev mutex held)</p><p>leave_ibss</p><p>Leave the IBSS. (invoked with the wireless_dev mutex held)</p><p>set_mcast_rate</p><p>Set the specified multicast rate (only if vif is in ADHOC or MESH mode)</p><p>set_wiphy_params</p><p>Notify that wiphy parameters have changed; <em>changed</em> bitfield (see enum wiphy_params_flags) describes which values have changed. The actual parameter values are available in struct wiphy. If returning an error, no value should be changed.</p><p>set_tx_power</p><p>set the transmit power according to the parameters, the power passed is in mBm, to get dBm use <strong>MBM_TO_DBM</strong>. The wdev may be <strong>NULL</strong> if power was set for the wiphy, and will always be <strong>NULL</strong> unless the driver supports per-vif TX power (as advertised by the nl80211 feature flag.)</p><p>get_tx_power</p><p>store the current TX power into the dbm variable; return 0 if successful</p><p>set_wds_peer</p><p>set the WDS peer for a WDS interface</p><p>rfkill_poll</p><p>polls the hw rfkill line, use cfg80211 reporting functions to adjust rfkill hw state</p><p>testmode_cmd</p><p>run a test mode command; <em>wdev</em> may be <strong>NULL</strong></p><p>testmode_dump</p><p>Implement a test mode dump. The cb-&gt;args[2] and up may be used by the function, but 0 and 1 must not be touched. Additionally, return error codes other than -ENOBUFS and -ENOENT will terminate the dump and return to userspace with an error, so be careful. If any data was passed in from userspace then the data/len arguments will be present and point to the data contained in <strong>NL80211_ATTR_TESTDATA</strong>.</p><p>set_bitrate_mask</p><p>set the bitrate mask configuration</p><p>dump_survey</p><p>get site survey information.</p><p>set_pmksa</p><p>Cache a PMKID for a BSSID. This is mostly useful for fullmac devices running firmwares capable of generating the (re) association RSN IE. It allows for faster roaming between WPA2 BSSIDs.</p><p>del_pmksa</p><p>Delete a cached PMKID.</p><p>flush_pmksa</p><p>Flush all cached PMKIDs.</p><p>remain_on_channel</p><p>Request the driver to remain awake on the specified channel for the specified duration to complete an off-channel operation (e.g., public action frame exchange). When the driver is ready on the requested channel, it must indicate this with an event notification by calling <strong>cfg80211_ready_on_channel</strong>.</p><p>cancel_remain_on_channel</p><p>Cancel an on-going remain-on-channel operation. This allows the operation to be terminated prior to timeout based on the duration value.</p><p>mgmt_tx</p><p>Transmit a management frame.</p><p>mgmt_tx_cancel_wait</p><p>Cancel the wait time from transmitting a management frame on another channel</p><p>set_power_mgmt</p><p>Configure WLAN power management. A timeout value of -1 allows the driver to adjust the dynamic ps timeout value.</p><p>set_cqm_rssi_config</p><p>Configure connection quality monitor RSSI threshold.</p><p>set_cqm_txe_config</p><p>Configure connection quality monitor TX error thresholds.</p><p>mgmt_frame_register</p><p>Notify driver that a management frame type was registered. Note that this callback may not sleep, and cannot run concurrently with itself.</p><p>set_antenna</p><p>Set antenna configuration (tx_ant, rx_ant) on the device. Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may reject TX/RX mask combinations they cannot support by returning -EINVAL (also see nl80211.h <em>NL80211_ATTR_WIPHY_ANTENNA_TX</em>).</p><p>get_antenna</p><p>Get current antenna configuration from device (tx_ant, rx_ant).</p><p>set_ringparam</p><p>Set tx and rx ring sizes.</p><p>get_ringparam</p><p>Get tx and rx ring current and maximum sizes.</p><p>sched_scan_start</p><p>Tell the driver to start a scheduled scan.</p><p>sched_scan_stop</p><p>Tell the driver to stop an ongoing scheduled scan. This call must stop the scheduled scan and be ready for starting a new one before it returns, i.e. <em>sched_scan_start</em> may be called immediately after that again and should not fail in that case. The driver should not call <strong>cfg80211_sched_scan_stopped</strong> for a requested stop (when this method returns 0.)</p><p>set_rekey_data</p><p>give the data necessary for GTK rekeying to the driver</p><p>tdls_mgmt</p><p>Transmit a TDLS management frame.</p><p>tdls_oper</p><p>Perform a high-level TDLS operation (e.g. TDLS link setup).</p><p>probe_client</p><p>probe an associated client, must return a cookie that it later passes to <strong>cfg80211_probe_status</strong>.</p><p>set_noack_map</p><p>Set the NoAck Map for the TIDs.</p><p>get_et_sset_count</p><p>Ethtool API to get string-set count. See <em>ethtool_ops</em>.get_sset_count</p><p>get_et_stats</p><p>Ethtool API to get a set of u64 stats. See <em>ethtool_ops</em>.get_ethtool_stats</p><p>get_et_strings</p><p>Ethtool API to get a set of strings to describe stats and perhaps other supported types of ethtool data-sets. See <em>ethtool_ops</em>.get_strings</p><p>get_channel</p><p>Get the current operating channel for the virtual interface. For monitor interfaces, it should return <strong>NULL</strong> unless there&apos;s a single current monitoring channel.</p><p>start_p2p_device</p><p>Start the given P2P device.</p><p>stop_p2p_device</p><p>Stop the given P2P device.</p><p>set_mac_acl</p><p>Sets MAC address control list in AP and P2P GO mode. Parameters include ACL policy, an array of MAC address of stations and the number of MAC addresses. If there is already a list in driver this new list replaces the existing one. Driver has to clear its ACL when number of MAC addresses entries is passed as 0. Drivers which advertise the support for MAC based ACL have to implement this callback.</p><p>start_radar_detection</p><p>Start radar detection in the driver.</p><p>update_ft_ies</p><p>Provide updated Fast BSS Transition information to the driver. If the SME is in the driver/firmware, this information can be used in building Authentication and Reassociation Request frames.</p><p>crit_proto_start</p><p>Indicates a critical protocol needs more link reliability for a given duration (milliseconds). The protocol is provided so the driver can take the most appropriate actions.</p><p>crit_proto_stop</p><p>Indicates critical protocol no longer needs increased link reliability. This operation can not fail.</p><p>set_coalesce</p><p>Set coalesce parameters.</p><p>channel_switch</p><p>initiate channel-switch procedure (with CSA)</p><p>set_qos_map</p><p>Set QoS mapping information to the driver</p><p>set_ap_chanwidth</p><p>Set the AP (including P2P GO) mode channel width for the given interface This is used e.g. for dynamic HT 20/40 MHz channel width changes during the lifetime of the BSS.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This struct is registered by fullmac card drivers and/or wireless stacks in order to handle configuration requests on their interfaces.</p><p>All callbacks except where otherwise noted should return 0 on success or a negative error code.</p><p>All operations are currently invoked under rtnl for consistency with the wireless extensions but this is subject to reevaluation as soon as this code is used more widely and we have a first user without wext.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><strong>Johannes Berg</strong> &lt;johannes@sipsolutions.net&gt;</p><p>Author.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="struct_cfg80211_ibss_params.9.html"><span aria-hidden="true">&larr;</span> struct_cfg80211_ibss_params.9: Ibss parameters</a></li>
   <li class="next"><a href="struct_cfg80211_pmksa.9.html">struct_cfg80211_pmksa.9: Pmk security association <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

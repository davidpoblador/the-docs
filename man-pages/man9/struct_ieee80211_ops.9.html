<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>struct_ieee80211_ops: Callbacks from mac80211 to the driver</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Callbacks from mac80211 to the driver">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="struct_ieee80211_ops (9) manual">
  <meta name="twitter:description" content="Callbacks from mac80211 to the driver">
  <meta name="twitter:image" content="https://www.carta.tech/images/linux-manual-3.16-struct_ieee80211_ops-9.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man9/struct_ieee80211_ops.9.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="struct_ieee80211_ops (9) manual" />
  <meta property="og:description" content="Callbacks from mac80211 to the driver" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/linux-manual-3.16-struct_ieee80211_ops-9.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">struct_ieee80211_ops<small> (9)</small></h1>
        <p class="lead">Callbacks from mac80211 to the driver</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/">
      <span itemprop="name">Kernel routines</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/struct_ieee80211_ops.9.html">
      <span itemprop="name">struct_ieee80211_ops: Callbacks from mac80211 to the driver</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/linux-manual-3.16/">
      <span itemprop="name">linux-manual-3.16</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/struct_ieee80211_ops.9.html">
      <span itemprop="name">struct_ieee80211_ops: Callbacks from mac80211 to the driver</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
struct ieee80211_ops {
  void (* tx) (struct ieee80211_hw *hw,struct ieee80211_tx_control *control,struct sk_buff *skb);
  int (* start) (struct ieee80211_hw *hw);
  void (* stop) (struct ieee80211_hw *hw);
#ifdef CONFIG_PM
  int (* suspend) (struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
  int (* resume) (struct ieee80211_hw *hw);
  void (* set_wakeup) (struct ieee80211_hw *hw, bool enabled);
#endif
  int (* add_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* change_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum nl80211_iftype new_type, bool p2p);
  void (* remove_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* config) (struct ieee80211_hw *hw, u32 changed);
  void (* bss_info_changed) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_bss_conf *info,u32 changed);
  int (* start_ap) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (* stop_ap) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  u64 (* prepare_multicast) (struct ieee80211_hw *hw,struct netdev_hw_addr_list *mc_list);
  void (* configure_filter) (struct ieee80211_hw *hw,unsigned int changed_flags,unsigned int *total_flags,u64 multicast);
  int (* set_tim) (struct ieee80211_hw *hw, struct ieee80211_sta *sta,bool set);
  int (* set_key) (struct ieee80211_hw *hw, enum set_key_cmd cmd,struct ieee80211_vif *vif, struct ieee80211_sta *sta,struct ieee80211_key_conf *key);
  void (* update_tkip_key) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_key_conf *conf,struct ieee80211_sta *sta,u32 iv32, u16 *phase1key);
  void (* set_rekey_data) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_gtk_rekey_data *data);
  void (* set_default_unicast_key) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, int idx);
  int (* hw_scan) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct cfg80211_scan_request *req);
  void (* cancel_hw_scan) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* sched_scan_start) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_sched_scan_request *req,struct ieee80211_sched_scan_ies *ies);
  int (* sched_scan_stop) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  void (* sw_scan_start) (struct ieee80211_hw *hw);
  void (* sw_scan_complete) (struct ieee80211_hw *hw);
  int (* get_stats) (struct ieee80211_hw *hw,struct ieee80211_low_level_stats *stats);
  void (* get_tkip_seq) (struct ieee80211_hw *hw, u8 hw_key_idx,u32 *iv32, u16 *iv16);
  int (* set_frag_threshold) (struct ieee80211_hw *hw, u32 value);
  int (* set_rts_threshold) (struct ieee80211_hw *hw, u32 value);
  int (* sta_add) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta);
  int (* sta_remove) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta);
#ifdef CONFIG_MAC80211_DEBUGFS
  void (* sta_add_debugfs) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry *dir);
  void (* sta_remove_debugfs) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry *dir);
#endif
  void (* sta_notify) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,enum sta_notify_cmd, struct ieee80211_sta *sta);
  int (* sta_state) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta,enum ieee80211_sta_state old_state,enum ieee80211_sta_state new_state);
  void (* sta_pre_rcu_remove) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta);
  void (* sta_rc_update) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,u32 changed);
  int (* conf_tx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, u16 ac,const struct ieee80211_tx_queue_params *params);
  u64 (* get_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (* set_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,u64 tsf);
  void (* reset_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (* tx_last_beacon) (struct ieee80211_hw *hw);
  int (* ampdu_action) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum ieee80211_ampdu_mlme_action action,struct ieee80211_sta *sta, u16 tid, u16 *ssn,u8 buf_size);
  int (* get_survey) (struct ieee80211_hw *hw, int idx,struct survey_info *survey);
  void (* rfkill_poll) (struct ieee80211_hw *hw);
  void (* set_coverage_class) (struct ieee80211_hw *hw, u8 coverage_class);
#ifdef CONFIG_NL80211_TESTMODE
  int (* testmode_cmd) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,void *data, int len);
  int (* testmode_dump) (struct ieee80211_hw *hw, struct sk_buff *skb,struct netlink_callback *cb,void *data, int len);
#endif
  void (* flush) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,u32 queues, bool drop);
  void (* channel_switch) (struct ieee80211_hw *hw,struct ieee80211_channel_switch *ch_switch);
  int (* set_antenna) (struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
  int (* get_antenna) (struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
  int (* remain_on_channel) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_channel *chan,int duration,enum ieee80211_roc_type type);
  int (* cancel_remain_on_channel) (struct ieee80211_hw *hw);
  int (* set_ringparam) (struct ieee80211_hw *hw, u32 tx, u32 rx);
  void (* get_ringparam) (struct ieee80211_hw *hw,u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
  bool (* tx_frames_pending) (struct ieee80211_hw *hw);
  int (* set_bitrate_mask) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,const struct cfg80211_bitrate_mask *mask);
  void (* rssi_callback) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum ieee80211_rssi_event rssi_event);
  void (* allow_buffered_frames) (struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason,bool more_data);
  void (* release_buffered_frames) (struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason,bool more_data);
  int (* get_et_sset_count) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, int sset);
  void (* get_et_stats) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ethtool_stats *stats, u64 *data);
  void (* get_et_strings) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,u32 sset, u8 *data);
  int (* get_rssi) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta, s8 *rssi_dbm);
  void (* mgd_prepare_tx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* add_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx);
  void (* remove_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx);
  void (* change_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx,u32 changed);
  int (* assign_vif_chanctx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx);
  void (* unassign_vif_chanctx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx);
  int (* switch_vif_chanctx) (struct ieee80211_hw *hw,struct ieee80211_vif_chanctx_switch *vifs,int n_vifs,enum ieee80211_chanctx_switch_mode mode);
  void (* restart_complete) (struct ieee80211_hw *hw);
#if IS_ENABLED(CONFIG_IPV6)
  void (* ipv6_addr_change) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct inet6_dev *idev);
#endif
  void (* channel_switch_beacon) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_chan_def *chandef);
  int (* join_ibss) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (* leave_ibss) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  u32 (* get_expected_throughput) (struct ieee80211_sta *sta);
};
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMBERS</h2>
        <div class="sectioncontent">
<p>tx</p><p>Handler that 802.11 module calls for each transmitted frame. skb contains the buffer starting from the IEEE 802.11 header. The low-level driver should send the frame out based on configuration in the TX control data. This handler should, preferably, never fail and stop queues appropriately. Must be atomic.</p><p>start</p><p>Called before the first netdevice attached to the hardware is enabled. This should turn on the hardware and must turn on frame reception (for possibly enabled monitor interfaces.) Returns negative error codes, these may be seen in userspace, or zero. When the device is started it should not have a MAC address to avoid acknowledging frames before a non-monitor device is added. Must be implemented and can sleep.</p><p>stop</p><p>Called after last netdevice attached to the hardware is disabled. This should turn off the hardware (at least it must turn off frame reception.) May be called right after add_interface if that rejects an interface. If you added any work onto the mac80211 workqueue you should ensure to cancel it on this callback. Must be implemented and can sleep.</p><p>suspend</p><p>Suspend the device; mac80211 itself will quiesce before and stop transmitting and doing any other configuration, and then ask the device to suspend. This is only invoked when WoWLAN is configured, otherwise the device is deconfigured completely and reconfigured at resume time. The driver may also impose special conditions under which it wants to use the &ldquo;normal&rdquo; suspend (deconfigure), say if it only supports WoWLAN when the device is associated. In this case, it must return 1 from this function.</p><p>resume</p><p>If WoWLAN was configured, this indicates that mac80211 is now resuming its operation, after this the device must be fully functional again. If this returns an error, the only way out is to also unregister the device. If it returns 1, then mac80211 will also go through the regular complete restart on resume.</p><p>set_wakeup</p><p>Enable or disable wakeup when WoWLAN configuration is modified. The reason is that <strong>device_set_wakeup_enable</strong> is supposed to be called when the configuration changes, not only in <strong>suspend</strong>.</p><p>add_interface</p><p>Called when a netdevice attached to the hardware is enabled. Because it is not called for monitor mode devices, <em>start</em> and <em>stop</em> must be implemented. The driver should perform any initialization it needs before the device can be enabled. The initial configuration for the interface is given in the conf parameter. The callback may refuse to add an interface by returning a negative error code (which will be seen in userspace.) Must be implemented and can sleep.</p><p>change_interface</p><p>Called when a netdevice changes type. This callback is optional, but only if it is supported can interface types be switched while the interface is UP. The callback may sleep. Note that while an interface is being switched, it will not be found by the interface iteration callbacks.</p><p>remove_interface</p><p>Notifies a driver that an interface is going down. The <em>stop</em> callback is called after this if it is the last interface and no monitor interfaces are present. When all interfaces are removed, the MAC address in the hardware must be cleared so the device no longer acknowledges packets, the mac_addr member of the conf structure is, however, set to the MAC address of the device going away. Hence, this callback must be implemented. It can sleep.</p><p>config</p><p>Handler for configuration requests. IEEE 802.11 code calls this function to change hardware configuration, e.g., channel. This function should never fail but returns a negative error code if it does. The callback can sleep.</p><p>bss_info_changed</p><p>Handler for configuration requests related to BSS parameters that may vary during BSS&apos;s lifespan, and may affect low level driver (e.g. assoc/disassoc status, erp parameters). This function should not be used if no BSS has been set, unless for association indication. The <em>changed</em> parameter indicates which of the bss parameters has changed when a call is made. The callback can sleep.</p><p>start_ap</p><p>Start operation on the AP interface, this is called after all the information in bss_conf is set and beacon can be retrieved. A channel context is bound before this is called. Note that if the driver uses software scan or ROC, this (and <em>stop_ap</em>) isn&apos;t called when the AP is just &ldquo;paused&rdquo; for scanning/ROC, which is indicated by the beacon being disabled/enabled via <em>bss_info_changed</em>.</p><p>stop_ap</p><p>Stop operation on the AP interface.</p><p>prepare_multicast</p><p>Prepare for multicast filter configuration. This callback is optional, and its return value is passed to <strong>configure_filter</strong>. This callback must be atomic.</p><p>configure_filter</p><p>Configure the device&apos;s RX filter. See the section &ldquo;Frame filtering&rdquo; for more information. This callback must be implemented and can sleep.</p><p>set_tim</p><p>Set TIM bit. mac80211 calls this function when a TIM bit must be set or cleared for a given STA. Must be atomic.</p><p>set_key</p><p>See the section &ldquo;Hardware crypto acceleration&rdquo; This callback is only called between add_interface and remove_interface calls, i.e. while the given virtual interface is enabled. Returns a negative error code if the key can&apos;t be added. The callback can sleep.</p><p>update_tkip_key</p><p>See the section &ldquo;Hardware crypto acceleration&rdquo; This callback will be called in the context of Rx. Called for drivers which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY. The callback must be atomic.</p><p>set_rekey_data</p><p>If the device supports GTK rekeying, for example while the host is suspended, it can assign this callback to retrieve the data necessary to do GTK rekeying, this is the KEK, KCK and replay counter. After rekeying was done it should (for example during resume) notify userspace of the new replay counter using <strong>ieee80211_gtk_rekey_notify</strong>.</p><p>set_default_unicast_key</p><p>Set the default (unicast) key index, useful for WEP when the device sends data packets autonomously, e.g. for ARP offloading. The index can be 0-3, or -1 for unsetting it.</p><p>hw_scan</p><p>Ask the hardware to service the scan request, no need to start the scan state machine in stack. The scan must honour the channel configuration done by the regulatory agent in the wiphy&apos;s registered bands. The hardware (or the driver) needs to make sure that power save is disabled. The <em>req</em> ie/ie_len members are rewritten by mac80211 to contain the entire IEs after the SSID, so that drivers need not look at these at all but just send them after the SSID -- mac80211 includes the (extended) supported rates and HT information (where applicable). When the scan finishes, <strong>ieee80211_scan_completed</strong> must be called; note that it also must be called when the scan cannot finish due to any error unless this callback returned a negative error code. The callback can sleep.</p><p>cancel_hw_scan</p><p>Ask the low-level tp cancel the active hw scan. The driver should ask the hardware to cancel the scan (if possible), but the scan will be completed only after the driver will call <strong>ieee80211_scan_completed</strong>. This callback is needed for wowlan, to prevent enqueueing a new scan_work after the low-level driver was already suspended. The callback can sleep.</p><p>sched_scan_start</p><p>Ask the hardware to start scanning repeatedly at specific intervals. The driver must call the <strong>ieee80211_sched_scan_results</strong> function whenever it finds results. This process will continue until sched_scan_stop is called.</p><p>sched_scan_stop</p><p>Tell the hardware to stop an ongoing scheduled scan. In this case, <strong>ieee80211_sched_scan_stopped</strong> must not be called.</p><p>sw_scan_start</p><p>Notifier function that is called just before a software scan is started. Can be NULL, if the driver doesn&apos;t need this notification. The callback can sleep.</p><p>sw_scan_complete</p><p>Notifier function that is called just after a software scan finished. Can be NULL, if the driver doesn&apos;t need this notification. The callback can sleep.</p><p>get_stats</p><p>Return low-level statistics. Returns zero if statistics are available. The callback can sleep.</p><p>get_tkip_seq</p><p>If your device implements TKIP encryption in hardware this callback should be provided to read the TKIP transmit IVs (both IV32 and IV16) for the given key from hardware. The callback must be atomic.</p><p>set_frag_threshold</p><p>Configuration of fragmentation threshold. Assign this if the device does fragmentation by itself; if this callback is implemented then the stack will not do fragmentation. The callback can sleep.</p><p>set_rts_threshold</p><p>Configuration of RTS threshold (if device needs it) The callback can sleep.</p><p>sta_add</p><p>Notifies low level driver about addition of an associated station, AP, IBSS/WDS/mesh peer etc. This callback can sleep.</p><p>sta_remove</p><p>Notifies low level driver about removal of an associated station, AP, IBSS/WDS/mesh peer etc. Note that after the callback returns it isn&apos;t safe to use the pointer, not even RCU protected; no RCU grace period is guaranteed between returning here and freeing the station. See <em>sta_pre_rcu_remove</em> if needed. This callback can sleep.</p><p>sta_add_debugfs</p><p>Drivers can use this callback to add debugfs files when a station is added to mac80211&apos;s station list. This callback and <em>sta_remove_debugfs</em> should be within a CONFIG_MAC80211_DEBUGFS conditional. This callback can sleep.</p><p>sta_remove_debugfs</p><p>Remove the debugfs files which were added using <em>sta_add_debugfs</em>. This callback can sleep.</p><p>sta_notify</p><p>Notifies low level driver about power state transition of an associated station, AP, IBSS/WDS/mesh peer etc. For a VIF operating in AP mode, this callback will not be called when the flag <strong>IEEE80211_HW_AP_LINK_PS</strong> is set. Must be atomic.</p><p>sta_state</p><p>Notifies low level driver about state transition of a station (which can be the AP, a client, IBSS/WDS/mesh peer etc.) This callback is mutually exclusive with <em>sta_add</em>/<em>sta_remove</em>. It must not fail for down transitions but may fail for transitions up the list of states. Also note that after the callback returns it isn&apos;t safe to use the pointer, not even RCU protected - no RCU grace period is guaranteed between returning here and freeing the station. See <em>sta_pre_rcu_remove</em> if needed. The callback can sleep.</p><p>sta_pre_rcu_remove</p><p>Notify driver about station removal before RCU synchronisation. This is useful if a driver needs to have station pointers protected using RCU, it can then use this call to clear the pointers instead of waiting for an RCU grace period to elapse in <em>sta_state</em>. The callback can sleep.</p><p>sta_rc_update</p><p>Notifies the driver of changes to the bitrates that can be used to transmit to the station. The changes are advertised with bits from enum ieee80211_rate_control_changed and the values are reflected in the station data. This callback should only be used when the driver uses hardware rate control (<strong>IEEE80211_HW_HAS_RATE_CONTROL</strong>) since otherwise the rate control algorithm is notified directly. Must be atomic.</p><p>conf_tx</p><p>Configure TX queue parameters (EDCF (aifs, cw_min, cw_max), bursting) for a hardware TX queue. Returns a negative error code on failure. The callback can sleep.</p><p>get_tsf</p><p>Get the current TSF timer value from firmware/hardware. Currently, this is only used for IBSS mode BSSID merging and debugging. Is not a required function. The callback can sleep.</p><p>set_tsf</p><p>Set the TSF timer to the specified value in the firmware/hardware. Currently, this is only used for IBSS mode debugging. Is not a required function. The callback can sleep.</p><p>reset_tsf</p><p>Reset the TSF timer and allow firmware/hardware to synchronize with other STAs in the IBSS. This is only used in IBSS mode. This function is optional if the firmware/hardware takes full care of TSF synchronization. The callback can sleep.</p><p>tx_last_beacon</p><p>Determine whether the last IBSS beacon was sent by us. This is needed only for IBSS mode and the result of this function is used to determine whether to reply to Probe Requests. Returns non-zero if this device sent the last beacon. The callback can sleep.</p><p>ampdu_action</p><p>Perform a certain A-MPDU action The RA/TID combination determines the destination and TID we want the ampdu action to be performed for. The action is defined through ieee80211_ampdu_mlme_action. Starting sequence number (<em>ssn</em>) is the first frame we expect to perform the action on. Notice that TX/RX_STOP can pass NULL for this parameter. The <em>buf_size</em> parameter is only valid when the action is set to <strong>IEEE80211_AMPDU_TX_OPERATIONAL</strong> and indicates the peer&apos;s reorder buffer size (number of subframes) for this session -- the driver may neither send aggregates containing more subframes than this nor send aggregates in a way that lost frames would exceed the buffer size. If just limiting the aggregate size, this would be</p><p>get_survey</p><p>Return per-channel survey information</p><p>rfkill_poll</p><p>Poll rfkill hardware state. If you need this, you also need to set wiphy-&gt;rfkill_poll to <strong>true</strong> before registration, and need to call <strong>wiphy_rfkill_set_hw_state</strong> in the callback. The callback can sleep.</p><p>set_coverage_class</p><p>Set slot time for given coverage class as specified in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout accordingly. This callback is not required and may sleep.</p><p>testmode_cmd</p><p>Implement a cfg80211 test mode command. The passed <em>vif</em> may be <strong>NULL</strong>. The callback can sleep.</p><p>testmode_dump</p><p>Implement a cfg80211 test mode dump. The callback can sleep.</p><p>flush</p><p>Flush all pending frames from the hardware queue, making sure that the hardware queues are empty. The <em>queues</em> parameter is a bitmap of queues to flush, which is useful if different virtual interfaces use different hardware queues; it may also indicate all queues. If the parameter <em>drop</em> is set to <strong>true</strong>, pending frames may be dropped. Note that vif can be NULL. The callback can sleep.</p><p>channel_switch</p><p>Drivers that need (or want) to offload the channel switch operation for CSAs received from the AP may implement this callback. They must then call <strong>ieee80211_chswitch_done</strong> to indicate completion of the channel switch.</p><p>set_antenna</p><p>Set antenna configuration (tx_ant, rx_ant) on the device. Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may reject TX/RX mask combinations they cannot support by returning -EINVAL (also see nl80211.h <em>NL80211_ATTR_WIPHY_ANTENNA_TX</em>).</p><p>get_antenna</p><p>Get current antenna configuration from device (tx_ant, rx_ant).</p><p>remain_on_channel</p><p>Starts an off-channel period on the given channel, must call back to <strong>ieee80211_ready_on_channel</strong> when on that channel. Note that normal channel traffic is not stopped as this is intended for hw offload. Frames to transmit on the off-channel channel are transmitted normally except for the <strong>IEEE80211_TX_CTL_TX_OFFCHAN</strong> flag. When the duration (which will always be non-zero) expires, the driver must call <strong>ieee80211_remain_on_channel_expired</strong>. Note that this callback may be called while the device is in IDLE and must be accepted in this case. This callback may sleep.</p><p>cancel_remain_on_channel</p><p>Requests that an ongoing off-channel period is aborted before it expires. This callback may sleep.</p><p>set_ringparam</p><p>Set tx and rx ring sizes.</p><p>get_ringparam</p><p>Get tx and rx ring current and maximum sizes.</p><p>tx_frames_pending</p><p>Check if there is any pending frame in the hardware queues before entering power save.</p><p>set_bitrate_mask</p><p>Set a mask of rates to be used for rate control selection when transmitting a frame. Currently only legacy rates are handled. The callback can sleep.</p><p>rssi_callback</p><p>Notify driver when the average RSSI goes above/below thresholds that were registered previously. The callback can sleep.</p><p>allow_buffered_frames</p><p>Prepare device to allow the given number of frames to go out to the given station. The frames will be sent by mac80211 via the usual TX path after this call. The TX information for frames released will also have the <strong>IEEE80211_TX_CTL_NO_PS_BUFFER</strong> flag set and the last one will also have <strong>IEEE80211_TX_STATUS_EOSP</strong> set. In case frames from multiple TIDs are released and the driver might reorder them between the TIDs, it must set the <strong>IEEE80211_TX_STATUS_EOSP</strong> flag on the last frame and clear it on all others and also handle the EOSP bit in the QoS header correctly. Alternatively, it can also call the <strong>ieee80211_sta_eosp</strong> function. The <em>tids</em> parameter is a bitmap and tells the driver which TIDs the frames will be on; it will at most have two bits set. This callback must be atomic.</p><p>release_buffered_frames</p><p>Release buffered frames according to the given parameters. In the case where the driver buffers some frames for sleeping stations mac80211 will use this callback to tell the driver to release some frames, either for PS-poll or uAPSD. Note that if the <em>more_data</em> parameter is <strong>false</strong> the driver must check if there are more frames on the given TIDs, and if there are more than the frames being released then it must still set the more-data bit in the frame. If the <em>more_data</em> parameter is <strong>true</strong>, then of course the more-data bit must always be set. The <em>tids</em> parameter tells the driver which TIDs to release frames from, for PS-poll it will always have only a single bit set. In the case this is used for a PS-poll initiated release, the <em>num_frames</em> parameter will always be 1 so code can be shared. In this case the driver must also set <strong>IEEE80211_TX_STATUS_EOSP</strong> flag on the TX status (and must report TX status) so that the PS-poll period is properly ended. This is used to avoid sending multiple responses for a retried PS-poll frame. In the case this is used for uAPSD, the <em>num_frames</em> parameter may be bigger than one, but the driver may send fewer frames (it must send at least one, however). In this case it is also responsible for setting the EOSP flag in the QoS header of the frames. Also, when the service period ends, the driver must set <strong>IEEE80211_TX_STATUS_EOSP</strong> on the last frame in the SP. Alternatively, it may call the function <strong>ieee80211_sta_eosp</strong> to inform mac80211 of the end of the SP. This callback must be atomic.</p><p>get_et_sset_count</p><p>Ethtool API to get string-set count.</p><p>get_et_stats</p><p>Ethtool API to get a set of u64 stats.</p><p>get_et_strings</p><p>Ethtool API to get a set of strings to describe stats and perhaps other supported types of ethtool data-sets.</p><p>get_rssi</p><p>Get current signal strength in dBm, the function is optional and can sleep.</p><p>mgd_prepare_tx</p><p>Prepare for transmitting a management frame for association before associated. In multi-channel scenarios, a virtual interface is bound to a channel before it is associated, but as it isn&apos;t associated yet it need not necessarily be given airtime, in particular since any transmission to a P2P GO needs to be synchronized against the GO&apos;s powersave state. mac80211 will call this function before transmitting a management frame prior to having successfully associated to allow the driver to give it channel time for the transmission, to get a response and to be able to synchronize with the GO. The callback will be called before each transmission and upon return mac80211 will transmit the frame right away. The callback is optional and can (should!) sleep.</p><p>add_chanctx</p><p>Notifies device driver about new channel context creation.</p><p>remove_chanctx</p><p>Notifies device driver about channel context destruction.</p><p>change_chanctx</p><p>Notifies device driver about channel context changes that may happen when combining different virtual interfaces on the same channel context with different settings</p><p>assign_vif_chanctx</p><p>Notifies device driver about channel context being bound to vif. Possible use is for hw queue remapping.</p><p>unassign_vif_chanctx</p><p>Notifies device driver about channel context being unbound from vif.</p><p>switch_vif_chanctx</p><p>switch a number of vifs from one chanctx to another, as specified in the list of <em>ieee80211_vif_chanctx_switch</em> passed to the driver, according to the mode defined in ieee80211_chanctx_switch_mode.</p><p>restart_complete</p><p>Called after a call to <strong>ieee80211_restart_hw</strong>, when the reconfiguration has completed. This can help the driver implement the reconfiguration step. Also called when reconfiguring because the driver&apos;s resume function returned 1, as this is just like an &ldquo;inline&rdquo; hardware restart. This callback may sleep.</p><p>ipv6_addr_change</p><p>IPv6 address assignment on the given interface changed. Currently, this is only called for managed or P2P client interfaces. This callback is optional; it must not sleep.</p><p>channel_switch_beacon</p><p>Starts a channel switch to a new channel. Beacons are modified to include CSA or ECSA IEs before calling this function. The corresponding count fields in these IEs must be decremented, and when they reach 1 the driver must call <strong>ieee80211_csa_finish</strong>. Drivers which use <strong>ieee80211_beacon_get</strong> get the csa counter decremented by mac80211, but must check if it is 1 using <strong>ieee80211_csa_is_complete</strong> after the beacon has been transmitted and then call <strong>ieee80211_csa_finish</strong>. If the CSA count starts as zero or 1, this function will not be called, since there won&apos;t be any time to beacon before the switch anyway.</p><p>join_ibss</p><p>Join an IBSS (on an IBSS interface); this is called after all information in bss_conf is set up and the beacon can be retrieved. A channel context is bound before this is called.</p><p>leave_ibss</p><p>Leave the IBSS again.</p><p>get_expected_throughput</p><p>extract the expected throughput towards the specified station. The returned value is expressed in Kbps. It returns 0 if the RC algorithm does not have proper data to provide.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This structure contains various callbacks that the driver may handle or, in some cases, must handle, for example to configure the hardware to a new channel or to transmit a frame.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">POSSIBLE WITH A BUF_SIZE OF 8</h2>
        <div class="sectioncontent">
<p>- TX: 1.....7 - RX: 2....7 (lost frame #1) - TX: 8..1... which is invalid since #1 was now re-transmitted well past the buffer size of 8. Correct ways to retransmit #1 would be: - TX: 1 or 18 or 81 Even &ldquo;189&rdquo; would be wrong since 1 could be lost again.</p><p>Returns a negative error code on failure. The callback can sleep.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><strong>Johannes Berg</strong> &lt;johannes@sipsolutions.net&gt;</p><p>Author.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="struct_ieee80211_key_conf.9.html"><span aria-hidden="true">&larr;</span> struct_ieee80211_key_conf.9: Key information</a></li>
   <li class="next"><a href="struct_ieee80211_radiotap_iterator.9.html">struct_ieee80211_radiotap_iterator.9: Tracks walk thru present radiotap args <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>struct_wimax_dev: Generic wimax device</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Generic wimax device">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="struct_wimax_dev (9) manual">
  <meta name="twitter:description" content="Generic wimax device">
  <meta name="twitter:image" content="https://www.carta.tech/images/linux-manual-3.16-struct_wimax_dev-9.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man9/struct_wimax_dev.9.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="struct_wimax_dev (9) manual" />
  <meta property="og:description" content="Generic wimax device" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/linux-manual-3.16-struct_wimax_dev-9.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">struct_wimax_dev<small> (9)</small></h1>
        <p class="lead">Generic wimax device</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/">
      <span itemprop="name">Kernel routines</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/struct_wimax_dev.9.html">
      <span itemprop="name">struct_wimax_dev: Generic wimax device</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/linux-manual-3.16/">
      <span itemprop="name">linux-manual-3.16</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man9/struct_wimax_dev.9.html">
      <span itemprop="name">struct_wimax_dev: Generic wimax device</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
struct wimax_dev {
  struct net_device * net_dev;
  struct list_head id_table_node;
  struct mutex mutex;
  struct mutex mutex_reset;
  enum wimax_st state;
  int (* op_msg_from_user) (struct wimax_dev *wimax_dev,const char *,const void *, size_t,const struct genl_info *info);
  int (* op_rfkill_sw_toggle) (struct wimax_dev *wimax_dev,enum wimax_rf_state);
  int (* op_reset) (struct wimax_dev *wimax_dev);
  struct rfkill * rfkill;
  unsigned int rf_hw;
  unsigned int rf_sw;
  char name[32];
  struct dentry * debugfs_dentry;
};
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMBERS</h2>
        <div class="sectioncontent">
<p>net_dev</p><p>[fill] Pointer to the struct net_device this WiMAX device implements.</p><p>id_table_node</p><p>[private] link to the list of wimax devices kept by id-table.c. Protected by it&apos;s own spinlock.</p><p>mutex</p><p>[private] Serializes all concurrent access and execution of operations.</p><p>mutex_reset</p><p>[private] Serializes reset operations. Needs to be a different mutex because as part of the reset operation, the driver has to call back into the stack to do things such as state change, that require wimax_dev-&gt;mutex.</p><p>state</p><p>[private] Current state of the WiMAX device.</p><p>op_msg_from_user</p><p>[fill] Driver-specific operation to handle a raw message from user space to the driver. The driver can send messages to user space using with <strong>wimax_msg_to_user</strong>.</p><p>op_rfkill_sw_toggle</p><p>[fill] Driver-specific operation to act on userspace (or any other agent) requesting the WiMAX device to change the RF Kill software switch (WIMAX_RF_ON or WIMAX_RF_OFF). If such hardware support is not present, it is assumed the radio cannot be switched off and it is always on (and the stack will error out when trying to switch it off). In such case, this function pointer can be left as NULL.</p><p>op_reset</p><p>[fill] Driver specific operation to reset the device. This operation should always attempt first a warm reset that does not disconnect the device from the bus and return 0. If that fails, it should resort to some sort of cold or bus reset (even if it implies a bus disconnection and device disappearance). In that case, -ENODEV should be returned to indicate the device is gone. This operation has to be synchronous, and return only when the reset is complete. In case of having had to resort to bus/cold reset implying a device disconnection, the call is allowed to return inmediately.</p><p>rfkill</p><p>[private] integration into the RF-Kill infrastructure.</p><p>rf_hw</p><p>[private] State of the hardware radio switch (OFF/ON)</p><p>rf_sw</p><p>[private] State of the software radio switch (OFF/ON)</p><p>name[32]</p><p>[fill] A way to identify this device. We need to register a name with many subsystems (rfkill, workqueue creation, etc). We can&apos;t use the network device name as that might change and in some instances we don&apos;t know it yet (until we don&apos;t call <strong>register_netdev</strong>). So we generate an unique one using the driver name and device bus id, place it here and use it across the board. Recommended naming: DRIVERNAME-BUSNAME:BUSID (dev-&gt;bus-&gt;name, dev-&gt;bus_id).</p><p>debugfs_dentry</p><p>[private] Used to hook up a debugfs entry. This shows up in the debugfs root as wimax&#92;:DEVICENAME.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTE</h2>
        <div class="sectioncontent">
<p>wimax_dev-&gt;mutex is NOT locked when this op is being called; however, wimax_dev-&gt;mutex_reset IS locked to ensure serialization of calls to <strong>wimax_reset</strong>. See <strong>wimax_reset</strong>&apos;s documentation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This structure defines a common interface to access all WiMAX devices from different vendors and provides a common API as well as a free-form device-specific messaging channel.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>1. Embed a struct wimax_dev at *the beginning* the network device structure so that <strong>netdev_priv</strong> points to it.</p><p>2. <strong>memset</strong> it to zero</p><p>3. Initialize with <strong>wimax_dev_init</strong>. This will leave the WiMAX device in the <strong>__WIMAX_ST_NULL</strong> state.</p><p>4. Fill all the fields marked with [fill]; once called <strong>wimax_dev_add</strong>, those fields CANNOT be modified.</p><p>5. Call <strong>wimax_dev_add</strong> *after* registering the network device. This will leave the WiMAX device in the <strong>WIMAX_ST_DOWN</strong> state. Protect the driver&apos;s net_device-&gt;<strong>open</strong> against succeeding if the wimax device state is lower than <strong>WIMAX_ST_DOWN</strong>.</p><p>6. Select when the device is going to be turned on/initialized; for example, it could be initialized on &apos;ifconfig up&apos; (when the netdev op &apos;<strong>open</strong>&apos; is called on the driver).</p><p>When the device is initialized (at `ifconfig up` time, or right after calling <strong>wimax_dev_add</strong> from <strong>_probe</strong>, make sure the following steps are taken</p><p>a. Move the device to <strong>WIMAX_ST_UNINITIALIZED</strong>. This is needed so some API calls that shouldn&apos;t work until the device is ready can be blocked.</p><p>b. Initialize the device. Make sure to turn the SW radio switch off and move the device to state <strong>WIMAX_ST_RADIO_OFF</strong> when done. When just initialized, a device should be left in RADIO OFF state until user space devices to turn it on.</p><p>c. Query the device for the state of the hardware rfkill switch and call <strong>wimax_rfkill_report_hw</strong> and <strong>wimax_rfkill_report_sw</strong> as needed. See below.</p><p><strong>wimax_dev_rm</strong> undoes before unregistering the network device. Once <strong>wimax_dev_add</strong> is called, the driver can get called on the wimax_dev-&gt;op_* function pointers</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONCURRENCY</h2>
        <div class="sectioncontent">
<p>The stack provides a mutex for each device that will disallow API calls happening concurrently; thus, op calls into the driver through the wimax_dev-&gt;op*() function pointers will always be serialized and *never* concurrent.</p><p>For locking, take wimax_dev-&gt;mutex is taken; (most) operations in the API have to check for <strong>wimax_dev_is_ready</strong> to return 0 before continuing (this is done internally).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REFERENCE COUNTING</h2>
        <div class="sectioncontent">
<p>The WiMAX device is reference counted by the associated network device. The only operation that can be used to reference the device is <strong>wimax_dev_get_by_genl_info</strong>, and the reference it acquires has to be released with dev_put(wimax_dev-&gt;net_dev).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RFKILL</h2>
        <div class="sectioncontent">
<p>At startup, both HW and SW radio switchess are assumed to be off.</p><p>At initialization time [after calling <strong>wimax_dev_add</strong>], have the driver query the device for the status of the software and hardware RF kill switches and call <strong>wimax_report_rfkill_hw</strong> and <strong>wimax_rfkill_report_sw</strong> to indicate their state. If any is missing, just call it to indicate it is ON (radio always on).</p><p>Whenever the driver detects a change in the state of the RF kill switches, it should call <strong>wimax_report_rfkill_hw</strong> or <strong>wimax_report_rfkill_sw</strong> to report it to the stack.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="struct_w1_slave.9.html"><span aria-hidden="true">&larr;</span> struct_w1_slave.9: Holds a single slave device on the bus</a></li>
   <li class="next"><a href="struct_wiphy.9.html">struct_wiphy.9: Wireless hardware description <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>form: Representation of a finite element bilinear form</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Representation of a finite element bilinear form">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="form (2rheolef) manual">
  <meta name="twitter:description" content="Representation of a finite element bilinear form">
  <meta name="twitter:image" content="https://www.carta.tech/images/librheolef-dev-form-2rheolef.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man2rheolef/form.2rheolef.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="form (2rheolef) manual" />
  <meta property="og:description" content="Representation of a finite element bilinear form" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/librheolef-dev-form-2rheolef.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">form<small> (2rheolef)</small></h1>
        <p class="lead">Representation of a finite element bilinear form</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/form.2rheolef.html">
      <span itemprop="name">form: Representation of a finite element bilinear form</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/librheolef-dev/">
      <span itemprop="name">librheolef-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/form.2rheolef.html">
      <span itemprop="name">form: Representation of a finite element bilinear form</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The form class groups four sparse matrix, associated to a bilinear form on two finite element spaces:</p>
<pre>
       a: U*V   ----&gt; IR
         (u,v)  |---&gt; a(u,v)
</pre>
<p>The operator <strong>A</strong> associated to the bilinear form is defined by:</p>
<pre>
       A: U  ----&gt; V'
          u  |---&gt; A(u)
</pre>
<p>where <strong>u</strong> and <strong>v</strong> are fields (see <strong>field</strong>(2)), and <strong>A(u)</strong> is such that <strong>a(u,v)=&lt;A(u),v&gt;</strong> for all u in U and v in V and where <strong>&lt;.,.&gt;</strong> denotes the duality product between V and V'. Since V is a finite dimensional spaces, the duality product is the euclidian product in IR^dim(V).</p><p>Since both U and V are finite dimensional spaces, the linear operator can be represented by a matrix. The <strong>form</strong> class is represented by four sparse matrix in <strong>csr</strong> format (see <strong>csr</strong>(2)), associated to unknown and blocked degrees of freedom of origin and destination spaces (see <strong>space</strong>(2)).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>The operator A associated to a bilinear form a(.,.) by the relation (Au,v) = a(u,v) could be applied by using a sample matrix notation A*u, as shown by the following code:</p>
<pre>
      geo omega("square");
      space V (omega,"P1");
      form a (V,V,"grad_grad");
      field uh = interpolate (fct, V);
      field vh = a*uh;
      cout &lt;&lt; v;
</pre>
<p>The form-field <strong>vh=a*uh</strong> operation is equivalent to the following matrix-vector operations:</p>
<pre>
     vh.set_u() = a.uu()*uh.u() + a.ub()*uh.b();
     vh.set_b() = a.bu()*uh.u() + a.bb()*uh.b();
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ALGEBRA</h2>
        <div class="sectioncontent">
<p>Forms, as matrices (see <strong>csr</strong>(2)), support linear algebra: Adding or substracting two forms writes <strong>a+b</strong> and <strong>a-b</strong>, respectively, and multiplying a form by a field <strong>uh</strong> writes <strong>a*uh</strong>. Thus, any linear combination of forms is available.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WEIGHTED FORM</h2>
        <div class="sectioncontent">
<p>A weighted form is a form with an extra weight function <strong>w(x)</strong>, e.g.:</p>
<pre>
                   /
                  |
       a(uh,vh) = |       grad(uh).grad(vh) w(x) dx
                  |
                 / Omega
</pre>
<p>In the present implementation, <strong>w</strong> can be any field, function or class-function or any nonlinear field expression (see <strong>field</strong>(2)). As the integration cannot be performed exactly in general, a quadrature formula can be supplied. This feature is extensively used when solving nonlinear problems.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTATION</h2>
        <div class="sectioncontent">

<pre>
template&lt;class T, class M&gt;
class form_basic {
public :
// typedefs:

    typedef typename csr&lt;T,M&gt;::size_type    size_type;
    typedef T                               value_type;
    typedef typename scalar_traits&lt;T&gt;::type float_type;
    typedef geo_basic&lt;float_type,M&gt;         geo_type;
    typedef space_basic&lt;float_type,M&gt;       space_type;

// allocator/deallocator:

    form_basic ();
    form_basic (const form_basic&lt;T,M&gt;&);


// allocators from initializer list (c++ 2011):

#ifdef _RHEOLEF_HAVE_STD_INITIALIZER_LIST
    form_basic (const std::initializer_list&lt;form_concat_value&lt;T,M&gt; &gt;& init_list);
    form_basic (const std::initializer_list&lt;form_concat_line &lt;T,M&gt; &gt;& init_list);
#endif // _RHEOLEF_HAVE_STD_INITIALIZER_LIST

// accessors:

    const space_type& get_first_space() const;
    const space_type& get_second_space() const;
    const geo_type&   get_geo() const;

    const communicator& comm() const;

// linear algebra:

    form_basic&lt;T,M&gt;  operator+  (const form_basic&lt;T,M&gt;& b) const;
    form_basic&lt;T,M&gt;  operator-  (const form_basic&lt;T,M&gt;& b) const;
    form_basic&lt;T,M&gt;  operator*  (const form_basic&lt;T,M&gt;& b) const;
    form_basic&lt;T,M&gt;& operator*= (const T& lambda);
    field_basic&lt;T,M&gt; operator*  (const field_basic&lt;T,M&gt;& xh) const;
    field_basic&lt;T,M&gt; trans_mult (const field_basic&lt;T,M&gt;& yh) const;
    float_type operator () (const field_basic&lt;T,M&gt;& uh, const field_basic&lt;T,M&gt;& vh) const;

// io:

    odiststream& put (odiststream& ops, bool show_partition = true) const;
    void dump (std::string name) const;

// accessors & modifiers to unknown & blocked parts:

    const csr&lt;T,M&gt;&     uu() const { return _uu; }
    const csr&lt;T,M&gt;&     ub() const { return _ub; }
    const csr&lt;T,M&gt;&     bu() const { return _bu; }
    const csr&lt;T,M&gt;&     bb() const { return _bb; }
          csr&lt;T,M&gt;& set_uu()       { return _uu; }
          csr&lt;T,M&gt;& set_ub()       { return _ub; }
          csr&lt;T,M&gt;& set_bu()       { return _bu; }
          csr&lt;T,M&gt;& set_bb()       { return _bb; }

// data
protected:
    space_type  _X;
    space_type  _Y;
    csr&lt;T,M&gt;    _uu;
    csr&lt;T,M&gt;    _ub;
    csr&lt;T,M&gt;    _bu;
    csr&lt;T,M&gt;    _bb;

// internals:
public:
    // with vf expression arg
    template &lt;class Expr&gt;
    void assembly_internal (
        const geo_basic&lt;T,M&gt;&         dom,
        const geo_basic&lt;T,M&gt;&         band,
        const band_basic&lt;T,M&gt;&        gh,
        const Expr&                   expr,
        const form_option_type&       fopt,
        bool                          is_on_band);
    template &lt;class Expr&gt;
    void assembly (
        const geo_basic&lt;T,M&gt;&         domain,
        const Expr&                   expr,
        const form_option_type&       fopt);
    template &lt;class Expr&gt;
    void assembly (
        const band_basic&lt;T,M&gt;&        gh,
        const Expr&                   expr,
        const form_option_type&       fopt);

    // backward compat: named forms
    form_basic (const space_type& X, const space_type& Y,
        const std::string& name = "",
        const quadrature_option_type& qopt = quadrature_option_type(quadrature_option_type::max_family,0));

    form_basic (const space_type& X, const space_type& Y,
        const std::string& name,
        const field_basic&lt;T,M&gt;& weight,
        const quadrature_option_type& qopt = quadrature_option_type(quadrature_option_type::max_family,0));

    template&lt;class Function&gt;
    form_basic (const space_type& X, const space_type& Y,
        const std::string& name,
        Function weight,
        const quadrature_option_type& qopt = quadrature_option_type(quadrature_option_type::max_family,0));

    form_basic (const space_type& X, const space_type& Y,
        const std::string& name,
        const geo_basic&lt;T,M&gt;& gamma,
        const quadrature_option_type& qopt = quadrature_option_type(quadrature_option_type::max_family,0));

    form_basic (const space_type& X, const space_type& Y,
        const std::string& name,
        const geo_basic&lt;T,M&gt;& gamma,
        const field_basic&lt;T,M&gt;& weight,
        const quadrature_option_type& qopt = quadrature_option_type(quadrature_option_type::max_family,0));

    template&lt;class Function&gt;
    form_basic (
        const space_type& X,
        const space_type& Y,
        const std::string& name,
        const geo_basic&lt;T,M&gt;& gamma,
        Function weight,
        const quadrature_option_type& qopt = quadrature_option_type(quadrature_option_type::max_family,0));
protected:
    // backward compat: named forms (cont.)
    template&lt;class WeightFunction&gt;
    void form_init (
                   const std::string&      name,
                   bool                    has_weight,
                   WeightFunction          weight,
                   const quadrature_option_type& qopt);
    template&lt;class WeightFunction&gt;
    void form_init_on_domain (
                   const std::string&      name,
                   const geo_basic&lt;T,M&gt;&   gamma,
                   bool                    has_weight,
                   WeightFunction          weight,
                   const geo_basic&lt;T,M&gt;&   w_omega, // the domain where the fct weight is defined
                   const quadrature_option_type& qopt);
};
template&lt;class T, class M&gt; form_basic&lt;T,M&gt; trans (const form_basic&lt;T,M&gt;& a);
template&lt;class T, class M&gt; field_basic&lt;T,M&gt; diag (const form_basic&lt;T,M&gt;& a);
template&lt;class T, class M&gt; form_basic&lt;T,M&gt;  diag (const field_basic&lt;T,M&gt;& dh);
typedef form_basic&lt;Float,rheo_default_memory_model&gt; form;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO form&hellip;</h2>
        <div class="sectioncontent">
<p><strong>field</strong>(2), <strong>csr</strong>(2), <strong>space</strong>(2), <strong>csr</strong>(2), <strong>field</strong>(2)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="field_functor.2rheolef.html"><span aria-hidden="true">&larr;</span> field_functor.2rheolef: A functor wrapper suitable for field expressions</a></li>
   <li class="next"><a href="form_option_type.2rheolef.html">form_option_type.2rheolef: Send options to the integrate function <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

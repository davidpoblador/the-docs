<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>field: Piecewise polynomial finite element field</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Piecewise polynomial finite element field">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="field (2rheolef) manual">
  <meta name="twitter:description" content="Piecewise polynomial finite element field">
  <meta name="twitter:image" content="https://www.carta.tech/images/librheolef-dev-field-2rheolef.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man2rheolef/field.2rheolef.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="field (2rheolef) manual" />
  <meta property="og:description" content="Piecewise polynomial finite element field" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/librheolef-dev-field-2rheolef.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">field<small> (2rheolef)</small></h1>
        <p class="lead">Piecewise polynomial finite element field</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/field.2rheolef.html">
      <span itemprop="name">field: Piecewise polynomial finite element field</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/librheolef-dev/">
      <span itemprop="name">librheolef-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/field.2rheolef.html">
      <span itemprop="name">field: Piecewise polynomial finite element field</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Store degrees of freedom associated to a mesh and a piecewise polynomial approximation, with respect to the numbering defined by the underlying <strong>space</strong>(2).</p><p>This class contains two vectors, namely unknown and blocked degrees of freedoms, and the associated finite element space. Blocked and unknown degrees of freedom can be set by using domain name indexation:</p>
<pre>
        geo omega ("circle");
        space Xh (omega, "P1");
        Xh.block ("boundary");
        field uh (Xh);
        uh ["boundary"] = 0;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERPOLATION</h2>
        <div class="sectioncontent">
<p>Interpolation of a function <strong>u</strong> in a field <strong>uh</strong> with respect to the interpolation writes:</p>
<pre>
        Float u (const point& x) { return x[0]*x[1]; }
        ...
        field uh = interpolate (Xh, u);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LINEAR ALGEBRA</h2>
        <div class="sectioncontent">
<p>Linear algebra, such as <strong>uh+vh</strong>, <strong>uh-vh</strong> and <strong>lambda*uh + mu*vh</strong>, where <strong>lambda</strong> and <strong>mu</strong> are of type <strong>Float</strong>, are supported. The duality product between two fields <strong>lh</strong> and <strong>vh</strong> writes simply <strong>dual(lh,vh)</strong>: for discrete fields, it corresponds to a simple Euclidian dot product in <strong>IR^n</strong>. The application of a bilinear form (see <strong>form</strong>(2)) writes <strong>m(uh,vh)</strong> and is equivalent to <strong>dual(m*uh,vh)</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NON-LINEAR ALGEBRA</h2>
        <div class="sectioncontent">
<p>Non-linear operations, such as <strong>sqrt(uh)</strong> or <strong>1/uh</strong> are also available. Notice that non-linear operations do not returns in general picewise polynomials: the value returned by <strong>sqrt(uh)</strong> may be filtered by <strong>interpolate</strong>,</p>
<pre>
        field vh = interpolate (Xh, sqrt(uh));
</pre>
<p>the Lagrange interpolant, to becomes a piecewise polynomial: All standard unary and binary math functions <strong>abs, cos, sin</strong>... are available on fields. Also <strong>sqr(uh)</strong>, the square of a field, and <strong>min(uh,vh)</strong>, <strong>max(uh,vh)</strong> are provided. Binary functions can be used also with a scalar, as in</p>
<pre>
        field vh = interpolate (Xh, max (abs(uh), 0));
        field wh = interpolate (Xh, pow (abs(uh), 1./3));
</pre>
<p>For applying a user-provided function to a field, use the <strong>compose</strong> function:</p>
<pre>
        field vh = interpolate(Xh, compose(f, uh));
        field wh = interpolate(Xh, compose(f, uh, vh));
</pre>
<p>The composition supports also general unary and binary class-functions. Also, the multiplication <strong>uh*vh</strong> and the division <strong>uh/vh</strong> returns a result that is not in the same discrete finite element space: its result may be filtered by the <strong>interpolate</strong> operator:</p>
<pre>
        field wh = interpolate(Xh, uh*vh);
</pre>
<p>Any function or class function can be used in nonlinear expressions: the function is interpolated in the specified finite element space.</p><p>There is a special predefined class-function named <strong>normal</strong> that represents the outer unnit normal vector on a boundary domain or surfacic mesh:</p>
<pre>
        size_t k = omega.order();
        string n_approx = "P" + itos(k-1) + "d";
        space Nh (omega["boundary"], n_approx, "vector");
        field nh = interpolate(Nh, normal());
</pre>
<p>The normal() function could appear in any nonlinear field expression: it is evaluated on the fly, based on the current mesh. Notice that when using isoparametric elements, the normal vector is no more constant along any face of the mesh. Also, on general curved domains, the unit normal vector is discontinuous accross boundary element interfaces.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACCESS BY DOMAIN</h2>
        <div class="sectioncontent">
<p>The restriction of a field to a geometric domain, says <strong>"boundary"</strong> writes <strong>uh["boundary"]</strong>: it represents the trace of the field on the boundary:</p>
<pre>
        space Xh (omega, "P1");
        uh["boundary"] = 0;
</pre>
<p>Extraction of the trace as a field is also possible:</p>
<pre>
        field wh = uh["boundary"];
</pre>
<p>The space associated to the trace writes <strong>wh.get_space()</strong> and is equivalent to <strong>space(omega["boundary"], "P1")</strong>. See see <strong>space</strong>(2).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VECTOR VALUED FIELD</h2>
        <div class="sectioncontent">
<p>A vector-valued field contains several components, as:</p>
<pre>
        space Xh (omega, "P2", "vector");
        field uh (Xh);
        field vh = uh[0] - uh[1];
        field nh = norm (uh);
</pre>
<p>The <strong>norm</strong> function returns the euclidian norm of the vector-valuated field at each degree of freedom: its result is a scalar field.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TENSOR VALUED FIELD</h2>
        <div class="sectioncontent">
<p>A tensor-valued field can be constructed and used as:</p>
<pre>
        space Th (omega, "P1d", "tensor");
        field sigma_h (Xh);
        field trace_h = sigma(0,0) + sigma_h(1,1);
        field nh = norm (sigma_h);
</pre>
<p>The <strong>norm</strong> function returns the euclidian norm of the tensor-valuated field at each degree of freedom: its result is a scalar field. Notice that, as tensor-valued fields are symmetric, extra-diagonals are counted twice.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GENERAL MULTI-COMPONENT INTERFACE</h2>
        <div class="sectioncontent">
<p>A general multi-component field writes:</p>
<pre>
        space Th (omega, "P1d", "tensor");
        space Vh (omega, "P2", "vector");
        space Qh (omega, "P1");
        space Xh = Th*Vh*Qh;
        field xh (Xh);
        field tau_h = xh[0]; // tensor-valued
        field uh    = xh[1]; // vector-valued
        field qh    = xh[2]; // scalar
</pre>
<p>Remark the hierarchical multi-component field structure: the first-component is tensor-valued and the second-one is vector-valued. There is no limitation upon the hierarchical number of levels in use.</p><p>For any field <strong>xh</strong>, the string <strong>xh.valued()</strong> returns <strong>"scalar"</strong> for a scalar field and <strong>"vector"</strong> for a vector-valued one. Other possible valued are <strong>"tensor"</strong> and <strong>"other"</strong>. The <strong>xh.size()</strong> returns the number of field components. When the field is scalar, it returns zero by convention, and <strong>xh[0]</strong> is undefined. A vector-valued field has <strong>d</strong> components, where <strong>d=omega.dimension()</strong>. A tensor-valued field has <strong>d*(d+1)/2</strong> components, where <strong>d=omega.dimension()</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BLOCKED AND UNBLOCKED ARRAYS</h2>
        <div class="sectioncontent">
<p>The field class contains two arrays of degrees-of-freedom (dof) associated respectively to blocked and unknown dofs. Blocked dofs corresponds to Dirichlet boundary conditions, as specified by space (See see <strong>space</strong>(2)). For simpliity, direct public access to these array is allowed, as <strong>uh.b</strong> and <strong>uh.u</strong>: see see <strong>vec</strong>(2).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOW-LEVEL DEGREE-OF-FREEDOM ACCESS</h2>
        <div class="sectioncontent">
<p>The field class provides a STL-like container interface for accessing the degrees-of-freedom (dof) of a finite element field <strong>uh</strong>. The number of dofs is <strong>uh.ndof()</strong> and any dof can be accessed via <strong>uh.dof(idof)</strong>. A non-local dof at the partition interface can be obtain via <strong>uh.dis_dof(dis_idof)</strong> where <strong>dis_idof</strong> is the (global) distribued index assoiated to the distribution <strong>uh.ownership()</strong>.</p><p>For performances, a STL-like iterator interface is available, with <strong>uh.begin_dof()</strong> and <strong>uh.end_dof()</strong> returns iterators to the arrays of dofs on the current processor. See see <strong>array</strong>(2) for more about distributed arrays.</p><p>For convenience, <strong>uh.max()</strong>, <strong>uh.min()</strong> and <strong>uh.max_abs()</strong> retuns respectively the maximum, minimum and maximum of the absolute value of the degrees of freedom.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILE FORMAT</h2>
        <div class="sectioncontent">
<p>TODO</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTATION NOTE</h2>
        <div class="sectioncontent">
<p>The field expression use the expression template technics in order to avoid temporaries when evaluating complex expressions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTATION</h2>
        <div class="sectioncontent">

<pre>
template &lt;class T, class M = rheo_default_memory_model&gt;
class field_basic : public std::unary_function&lt;point_basic&lt;typename scalar_traits&lt;T&gt;::type&gt;,T&gt; {
public :
// typedefs:

    typedef typename std::size_t            size_type;
    typedef M                               memory_type;
    typedef T                               scalar_type;
    typedef typename float_traits&lt;T&gt;::type  float_type;
//  typedef undeterminated_basic&lt;T&gt;         value_type; // TODO
    typedef T                               value_type; // TO_CLEAN
    typedef space_constant::valued_type     valued_type;
    typedef geo_basic  &lt;float_type,M&gt;       geo_type;
    typedef space_basic&lt;float_type,M&gt;       space_type;
    class iterator;
    class const_iterator;

// allocator/deallocator:

    field_basic();

    explicit field_basic (
        const space_type& V,
        const T& init_value = std::numeric_limits&lt;T&gt;::max());

    void resize (
        const space_type& V,
        const T& init_value = std::numeric_limits&lt;T&gt;::max());

    field_basic                   (const field_indirect&lt;T,M&gt;&);
    field_basic&lt;T, M&gt;& operator=  (const field_indirect&lt;T,M&gt;&);
    field_basic                   (const field_indirect_const&lt;T,M&gt;&);
    field_basic&lt;T, M&gt;& operator=  (const field_indirect_const&lt;T,M&gt;&);
    field_basic                   (const field_component&lt;T,M&gt;&);
    field_basic&lt;T, M&gt;& operator=  (const field_component&lt;T,M&gt;&);
    field_basic                   (const field_component_const&lt;T,M&gt;&);
    field_basic&lt;T, M&gt;& operator=  (const field_component_const&lt;T,M&gt;&);
    template &lt;class Expr&gt; field_basic                   (const field_expr&lt;Expr&gt;&);
    template &lt;class Expr&gt; field_basic&lt;T, M&gt;& operator=  (const field_expr&lt;Expr&gt;&);
    field_basic&lt;T, M&gt;& operator=  (const T&);

// initializer list (c++ 2011):

#ifdef _RHEOLEF_HAVE_STD_INITIALIZER_LIST
    field_basic (const std::initializer_list&lt;field_concat_value&lt;T,M&gt; &gt;& init_list);
    field_basic&lt;T,M&gt;& operator= (const std::initializer_list&lt;field_concat_value&lt;T,M&gt; &gt;& init_list);
#endif // _RHEOLEF_HAVE_STD_INITIALIZER_LIST

// accessors:

    const space_type&  get_space()  const { return _V; }
    const geo_type&    get_geo()    const { return _V.get_geo(); }
    std::string        stamp()      const { return _V.stamp(); }
    std::string        get_approx() const { return _V.get_approx(); }
    valued_type        valued_tag() const { return _V.valued_tag(); }
    const std::string& valued()     const { return _V.valued(); }

// accessors & modifiers to unknown & blocked parts:

    const vec&lt;T,M&gt;&     u() const { dis_dof_update_needed(); return _u; }
    const vec&lt;T,M&gt;&     b() const { dis_dof_update_needed(); return _b; }
          vec&lt;T,M&gt;& set_u()       { return _u; }
          vec&lt;T,M&gt;& set_b()       { return _b; }

// accessors to extremas:

    T min() const;
    T max() const;
    T max_abs() const;
    T min_abs() const;

// accessors by domains:

    field_indirect&lt;T,M&gt;        operator[] (const geo_basic&lt;T,M&gt;& dom);
    field_indirect_const&lt;T,M&gt;  operator[] (const geo_basic&lt;T,M&gt;& dom) const;
    field_indirect&lt;T,M&gt;        operator[] (std::string dom_name);
    field_indirect_const&lt;T,M&gt;  operator[] (std::string dom_name) const;

// accessors by components:

    size_type size() const { return _V.size(); }
    field_component&lt;T,M&gt;       operator[] (size_type i_comp);
    field_component_const&lt;T,M&gt; operator[] (size_type i_comp) const;
    field_component&lt;T,M&gt;       operator() (size_type i_comp, size_type j_comp);
    field_component_const&lt;T,M&gt; operator() (size_type i_comp, size_type j_comp) const;

// accessors by degrees-of-freedom (dof):

    const distributor& ownership() const { return get_space().ownership(); }
    const communicator& comm() const { return ownership().comm(); }
    size_type     ndof() const { return ownership().size(); }
    size_type dis_ndof() const { return ownership().dis_size(); }
          T& dof (size_type idof);
    const T& dof (size_type idof) const;
    const T& dis_dof (size_type dis_idof) const;
    iterator begin_dof();
    iterator end_dof();
    const_iterator begin_dof() const;
    const_iterator end_dof() const;

// input/output:

    idiststream& get (idiststream& ips);
    odiststream& put (odiststream& ops) const;
    odiststream& put_field (odiststream& ops) const;

// evaluate uh(x) where x is given locally as hat_x in K:

    T dis_evaluate (const point_basic&lt;T&gt;& x, size_type i_comp = 0) const;
    T operator()   (const point_basic&lt;T&gt;& x) const { return dis_evaluate (x,0); }
    point_basic&lt;T&gt; dis_vector_evaluate (const point_basic&lt;T&gt;& x) const;

// internals:
public:

    // evaluate uh(x) where x is given locally as hat_x in K:
    // requiers to call field::dis_dof_upgrade() before.
    T evaluate (const geo_element& K, const point_basic&lt;T&gt;& hat_xq, size_type i_comp = 0) const;

    // propagate changed values shared at partition boundaries to others procs
    void dis_dof_update() const;

    template &lt;class Expr&gt;
    void assembly_internal (
        const geo_basic&lt;T,M&gt;&         dom,
        const geo_basic&lt;T,M&gt;&         band,
        const band_basic&lt;T,M&gt;&        gh,
        const Expr&                   expr,
        const quadrature_option_type& qopt,
        bool                          is_on_band);
    template &lt;class Expr&gt;
    void assembly (
        const geo_basic&lt;T,M&gt;&         domain,
        const Expr&                   expr,
        const quadrature_option_type& qopt);
    template &lt;class Expr&gt;
    void assembly (
        const band_basic&lt;T,M&gt;&        gh,
        const Expr&                   expr,
        const quadrature_option_type& qopt);

protected:
    void dis_dof_update_internal() const;
    void dis_dof_update_needed() const;

// data:
    space_type   _V;
    vec&lt;T,M&gt;     _u;
    vec&lt;T,M&gt;     _b;
    mutable bool _dis_dof_update_needed;
};
template &lt;class T, class M&gt;
idiststream& operator &gt;&gt; (odiststream& ips, field_basic&lt;T,M&gt;& u);

template &lt;class T, class M&gt;
odiststream& operator &lt;&lt; (odiststream& ops, const field_basic&lt;T,M&gt;& uh);

typedef field_basic&lt;Float&gt; field;
typedef field_basic&lt;Float,sequential&gt; field_sequential;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO field&hellip;</h2>
        <div class="sectioncontent">
<p><strong>space</strong>(2), <strong>form</strong>(2), <strong>space</strong>(2), <strong>space</strong>(2), <strong>vec</strong>(2), <strong>array</strong>(2)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="eye.2rheolef.html"><span aria-hidden="true">&larr;</span> eye.2rheolef: The identity matrix</a></li>
   <li class="next"><a href="field_functor.2rheolef.html">field_functor.2rheolef: A functor wrapper suitable for field expressions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>creat - open and possibly create a file</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Open and possibly create a file">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">creat<small> (2)</small></h1>
        <p class="lead">Open and possibly create a file</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2/">
      <span itemprop="name">System calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2/creat.2.html">
      <span itemprop="name">creat</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/man-pages/">
      <span itemprop="name">man-pages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2/creat.2.html">
      <span itemprop="name">creat</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre><strong>#include &lt;sys/types.h&gt;</strong>
<strong>#include &lt;sys/stat.h&gt;</strong>
<strong>#include &lt;fcntl.h&gt;</strong>

<strong>int open(const char *</strong><em>pathname</em><strong>, int </strong><em>flags</em><strong>);</strong>
<strong>int open(const char *</strong><em>pathname</em><strong>, int </strong><em>flags</em><strong>, mode_t </strong><em>mode</em><strong>);</strong>

<strong>int creat(const char *</strong><em>pathname</em><strong>, mode_t </strong><em>mode</em><strong>);</strong>

<strong>int openat(int </strong><em>dirfd</em><strong>, const char *</strong><em>pathname</em><strong>, int </strong><em>flags</em><strong>);</strong>
<strong>int openat(int </strong><em>dirfd</em><strong>, const char *</strong><em>pathname</em><strong>, int </strong><em>flags</em><strong>, mode_t </strong><em>mode</em><strong>);</strong></pre>

<p class='spacer'>

<p>Feature Test Macro Requirements for glibc (see <a href="../man7/feature_test_macros.7.html"><strong>feature_test_macros</strong>(7)</a>):</p>
<p class='spacer'>

    <p><strong>openat</strong>():</p>
    <dl class='dl-vertical'>
      <dt>Since glibc 2.10:</dt>
      <dd>
    <p>_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200809L</p>
      </dd>
      <dt>Before glibc 2.10:</dt>
      <dd>
    <p>_ATFILE_SOURCE</p>
      </dd>
    </dl>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<p>Given a <em>pathname</em> for a file, <strong>open</strong>() returns a file descriptor, a small, nonnegative integer for use in subsequent system calls (<a href="../man2/read.2.html"><strong>read</strong>(2)</a>, <a href="../man2/write.2.html"><strong>write</strong>(2)</a>, <a href="../man2/lseek.2.html"><strong>lseek</strong>(2)</a>, <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a>, etc.). The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process.</p>
<p class='spacer'>

<p>By default, the new file descriptor is set to remain open across an <a href="../man2/execve.2.html"><strong>execve</strong>(2)</a> (i.e., the <strong>FD_CLOEXEC</strong> file descriptor flag described in <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> is initially disabled); the <strong>O_CLOEXEC</strong> flag, described below, can be used to change this default. The file offset is set to the beginning of the file (see <a href="../man2/lseek.2.html"><strong>lseek</strong>(2)</a>).</p>
<p class='spacer'>

<p>A call to <strong>open</strong>() creates a new <em>open file description</em>, an entry in the system-wide table of open files. The open file description records the file offset and the file status flags (see below). A file descriptor is a reference to an open file description; this reference is unaffected if <em>pathname</em> is subsequently removed or modified to refer to a different file. For further details on open file descriptions, see NOTES.</p>
<p class='spacer'>

<p>The argument <em>flags</em> must include one of the following <em>access modes</em>: <strong>O_RDONLY</strong>, <strong>O_WRONLY</strong>, or <strong>O_RDWR</strong>. These request opening the file read-only, write-only, or read/write, respectively.</p>
<p class='spacer'>

<p>In addition, zero or more file creation flags and file status flags can be bitwise-<em>or</em>'d in <em>flags</em>. The <em>file creation flags</em> are <strong>O_CLOEXEC</strong>, <strong>O_CREAT</strong>, <strong>O_DIRECTORY</strong>, <strong>O_EXCL</strong>, <strong>O_NOCTTY</strong>, <strong>O_NOFOLLOW</strong>, <strong>O_TMPFILE</strong>, and <strong>O_TRUNC</strong>. The <em>file status flags</em> are all of the remaining flags listed below. The distinction between these two groups of flags is that the file status flags can be retrieved and (in some cases) modified; see <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> for details.</p>
<p class='spacer'>

  <p>The full list of file creation flags and file status flags is as follows:</p>
  <dl class='dl-vertical'>
    <dt><strong>O_APPEND</strong></dt>
    <dd>
  <p>The file is opened in append mode. Before each <a href="../man2/write.2.html"><strong>write</strong>(2)</a>, the file offset is positioned at the end of the file, as if with <a href="../man2/lseek.2.html"><strong>lseek</strong>(2)</a>. <strong>O_APPEND</strong> may lead to corrupted files on NFS filesystems if more than one process appends data to a file at once. This is because NFS does not support appending to a file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
    </dd>
    <dt><strong>O_ASYNC</strong></dt>
    <dd>
  <p>Enable signal-driven I/O: generate a signal (<strong>SIGIO</strong> by default, but this can be changed via <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a>) when input or output becomes possible on this file descriptor. This feature is available only for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> for further details. See also BUGS, below.</p>
    </dd>
    <dt><strong>O_CLOEXEC</strong> (since Linux 2.6.23)</dt>
    <dd>
  <p>Enable the close-on-exec flag for the new file descriptor. Specifying this flag permits a program to avoid additional <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> <strong>F_SETFD</strong> operations to set the <strong>FD_CLOEXEC</strong> flag.</p>
<p class='spacer'>

  <p>Note that the use of this flag is essential in some multithreaded programs, because using a separate <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> <strong>F_SETFD</strong> operation to set the <strong>FD_CLOEXEC</strong> flag does not suffice to avoid race conditions where one thread opens a file descriptor and attempts to set its close-on-exec flag using <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> at the same time as another thread does a <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a> plus <a href="../man2/execve.2.html"><strong>execve</strong>(2)</a>. Depending on the order of execution, the race may lead to the file descriptor returned by <strong>open</strong>() being unintentionally leaked to the program executed by the child process created by <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a>. (This kind of race is in principle possible for any system call that creates a file descriptor whose close-on-exec flag should be set, and various other Linux system calls provide an equivalent of the <strong>O_CLOEXEC</strong> flag to deal with this problem.)</p>
    </dd>
    <dt><strong>O_CREAT</strong></dt>
    <dd>
    <p>If the file does not exist, it will be created. The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group ID of the process or to the group ID of the parent directory (depending on filesystem type and mount options, and the mode of the parent directory; see the mount options <em>bsdgroups</em> and <em>sysvgroups</em> described in <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a>).</p>
<p class='spacer'>

    <p>The <em>mode</em> argument specifies the file mode bits be applied when a new file is created. This argument must be supplied when <strong>O_CREAT</strong> or <strong>O_TMPFILE</strong> is specified in <em>flags</em>; if neither <strong>O_CREAT</strong> nor <strong>O_TMPFILE</strong> is specified, then <em>mode</em> is ignored. The effective mode is modified by the process's <em>umask</em> in the usual way: in the absence of a default ACL, the mode of the created file is <em>(mode&nbsp;&&nbsp;~umask)</em>. Note that this mode applies only to future accesses of the newly created file; the <strong>open</strong>() call that creates a read-only file may well return a read/write file descriptor.</p>
<p class='spacer'>

      <p>The following symbolic constants are provided for <em>mode</em>:</p>
      <dl class='dl-vertical'>
        <dt><strong>S_IRWXU</strong></dt>
        <dd>
      <p>00700 user (file owner) has read, write, and execute permission</p>
        </dd>
        <dt><strong>S_IRUSR</strong></dt>
        <dd>
      <p>00400 user has read permission</p>
        </dd>
        <dt><strong>S_IWUSR</strong></dt>
        <dd>
      <p>00200 user has write permission</p>
        </dd>
        <dt><strong>S_IXUSR</strong></dt>
        <dd>
      <p>00100 user has execute permission</p>
        </dd>
        <dt><strong>S_IRWXG</strong></dt>
        <dd>
      <p>00070 group has read, write, and execute permission</p>
        </dd>
        <dt><strong>S_IRGRP</strong></dt>
        <dd>
      <p>00040 group has read permission</p>
        </dd>
        <dt><strong>S_IWGRP</strong></dt>
        <dd>
      <p>00020 group has write permission</p>
        </dd>
        <dt><strong>S_IXGRP</strong></dt>
        <dd>
      <p>00010 group has execute permission</p>
        </dd>
        <dt><strong>S_IRWXO</strong></dt>
        <dd>
      <p>00007 others have read, write, and execute permission</p>
        </dd>
        <dt><strong>S_IROTH</strong></dt>
        <dd>
      <p>00004 others have read permission</p>
        </dd>
        <dt><strong>S_IWOTH</strong></dt>
        <dd>
      <p>00002 others have write permission</p>
        </dd>
        <dt><strong>S_IXOTH</strong></dt>
        <dd>
      <p>00001 others have execute permission</p>
        </dd>
      </dl>
<p class='spacer'>

      <p>According to POSIX, the effect when other bits are set in <em>mode</em> is unspecified. On Linux, the following bits are also honored in <em>mode</em>:</p>
      <dl class='dl-vertical'>
        <dt><strong>S_ISUID</strong></dt>
        <dd>
      <p>0004000 set-user-ID bit</p>
        </dd>
        <dt><strong>S_ISGID</strong></dt>
        <dd>
      <p>0002000 set-group-ID bit (see <a href="../man2/stat.2.html"><strong>stat</strong>(2)</a>)</p>
        </dd>
        <dt><strong>S_ISVTX</strong></dt>
        <dd>
      <p>0001000 sticky bit (see <a href="../man2/stat.2.html"><strong>stat</strong>(2)</a>)</p>
        </dd>
      </dl>
    </dd>
    <dt><strong>O_DIRECT</strong> (since Linux 2.4.10)</dt>
    <dd>
  <p>Try to minimize cache effects of the I/O to and from this file. In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done directly to/from user-space buffers. The <strong>O_DIRECT</strong> flag on its own makes an effort to transfer data synchronously, but does not give the guarantees of the <strong>O_SYNC</strong> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <strong>O_SYNC</strong> must be used in addition to <strong>O_DIRECT</strong>. See NOTES below for further discussion.</p>
<p class='spacer'>

  <p>A semantically similar (but deprecated) interface for block devices is described in <a href="../man8/raw.8.html"><strong>raw</strong>(8)</a>.</p>
    </dd>
    <dt><strong>O_DIRECTORY</strong></dt>
    <dd>
  <p>If <em>pathname</em> is not a directory, cause the open to fail. This flag was added in kernel version 2.1.126, to avoid denial-of-service problems if <a href="../man3/opendir.3.html"><strong>opendir</strong>(3)</a> is called on a FIFO or tape device.</p>
    </dd>
    <dt><strong>O_DSYNC</strong></dt>
    <dd>
  <p>Write operations on the file will complete according to the requirements of synchronized I/O <em>data</em> integrity completion.</p>
<p class='spacer'>

  <p>By the time <a href="../man2/write.2.html"><strong>write</strong>(2)</a> (and similar) return, the output data has been transferred to the underlying hardware, along with any file metadata that would be required to retrieve that data (i.e., as though each <a href="../man2/write.2.html"><strong>write</strong>(2)</a> was followed by a call to <a href="../man2/fdatasync.2.html"><strong>fdatasync</strong>(2)</a>). <em>See NOTES below</em>.</p>
    </dd>
    <dt><strong>O_EXCL</strong></dt>
    <dd>
  <p>Ensure that this call creates the file: if this flag is specified in conjunction with <strong>O_CREAT</strong>, and <em>pathname</em> already exists, then <strong>open</strong>() will fail.</p>
<p class='spacer'>

  <p>When these two flags are specified, symbolic links are not followed: if <em>pathname</em> is a symbolic link, then <strong>open</strong>() fails regardless of where the symbolic link points to.</p>
<p class='spacer'>

  <p>In general, the behavior of <strong>O_EXCL</strong> is undefined if it is used without <strong>O_CREAT</strong>. There is one exception: on Linux 2.6 and later, <strong>O_EXCL</strong> can be used without <strong>O_CREAT</strong> if <em>pathname</em> refers to a block device. If the block device is in use by the system (e.g., mounted), <strong>open</strong>() fails with the error <strong>EBUSY</strong>.</p>
<p class='spacer'>

  <p>On NFS, <strong>O_EXCL</strong> is supported only when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <strong>O_EXCL</strong> support is not provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file locking using a lockfile, and need to avoid reliance on NFS support for <strong>O_EXCL</strong>, can create a unique file on the same filesystem (e.g., incorporating hostname and PID), and use <a href="../man2/link.2.html"><strong>link</strong>(2)</a> to make a link to the lockfile. If <a href="../man2/link.2.html"><strong>link</strong>(2)</a> returns 0, the lock is successful. Otherwise, use <a href="../man2/stat.2.html"><strong>stat</strong>(2)</a> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
    </dd>
    <dt><strong>O_LARGEFILE</strong></dt>
    <dd>
  <p>(LFS) Allow files whose sizes cannot be represented in an <em>off_t</em> (but can be represented in an <em>off64_t</em>) to be opened. The <strong>_LARGEFILE64_SOURCE</strong> macro must be defined (before including <em>any</em> header files) in order to obtain this definition. Setting the <strong>_FILE_OFFSET_BITS</strong> feature test macro to 64 (rather than using <strong>O_LARGEFILE</strong>) is the preferred method of accessing large files on 32-bit systems (see <a href="../man7/feature_test_macros.7.html"><strong>feature_test_macros</strong>(7)</a>).</p>
    </dd>
    <dt><strong>O_NOATIME</strong> (since Linux 2.6.8)</dt>
    <dd>
  <p>Do not update the file last access time (<em>st_atime</em> in the inode) when the file is <a href="../man2/read.2.html"><strong>read</strong>(2)</a>. This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not be effective on all filesystems. One example is NFS, where the server maintains the access time.</p>
    </dd>
    <dt><strong>O_NOCTTY</strong></dt>
    <dd>
  <p>If <em>pathname</em> refers to a terminal device&ndash;see <a href="../man4/tty.4.html"><strong>tty</strong>(4)</a>&ndash;it will not become the process's controlling terminal even if the process does not have one.</p>
    </dd>
    <dt><strong>O_NOFOLLOW</strong></dt>
    <dd>
  <p>If <em>pathname</em> is a symbolic link, then the open fails. This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the pathname will still be followed. See also <strong>O_PATH</strong> below.</p>
    </dd>
    <dt><strong>O_NONBLOCK</strong> or <strong>O_NDELAY</strong></dt>
    <dd>
  <p>When possible, the file is opened in nonblocking mode. Neither the <strong>open</strong>() nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait.</p>
<p class='spacer'>

  <p>Note that this flag has no effect for regular files and block devices; that is, I/O operations will (briefly) block when device activity is required, regardless of whether <strong>O_NONBLOCK</strong> is set. Since <strong>O_NONBLOCK</strong> semantics might eventually be implemented, applications should not depend upon blocking behavior when specifying this flag for regular files and block devices.</p>
<p class='spacer'>

  <p>For the handling of FIFOs (named pipes), see also <a href="../man7/fifo.7.html"><strong>fifo</strong>(7)</a>. For a discussion of the effect of <strong>O_NONBLOCK</strong> in conjunction with mandatory file locks and with file leases, see <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a>.</p>
    </dd>
    <dt><strong>O_PATH</strong> (since Linux 2.6.39)</dt>
    <dd>
  <p>Obtain a file descriptor that can be used for two purposes: to indicate a location in the filesystem tree and to perform operations that act purely at the file descriptor level. The file itself is not opened, and other file operations (e.g., <a href="../man2/read.2.html"><strong>read</strong>(2)</a>, <a href="../man2/write.2.html"><strong>write</strong>(2)</a>, <a href="../man2/fchmod.2.html"><strong>fchmod</strong>(2)</a>, <a href="../man2/fchown.2.html"><strong>fchown</strong>(2)</a>, <a href="../man2/fgetxattr.2.html"><strong>fgetxattr</strong>(2)</a>, <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a>) fail with the error <strong>EBADF</strong>.</p>
<p class='spacer'>

      <p>The following operations <em>can</em> be performed on the resulting file descriptor:</p>
      <dl class='dl-horizontal'>
        <dt>*</dt>
        <dd>
      <p><a href="../man2/close.2.html"><strong>close</strong>(2)</a>; <a href="../man2/fchdir.2.html"><strong>fchdir</strong>(2)</a> (since Linux 3.5); <a href="../man2/fstat.2.html"><strong>fstat</strong>(2)</a> (since Linux 3.6).</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p>Duplicating the file descriptor (<a href="../man2/dup.2.html"><strong>dup</strong>(2)</a>, <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> <strong>F_DUPFD</strong>, etc.).</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p>Getting and setting file descriptor flags (<a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> <strong>F_GETFD</strong> and <strong>F_SETFD</strong>).</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p>Retrieving open file status flags using the <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> <strong>F_GETFL</strong> operation: the returned flags will include the bit <strong>O_PATH</strong>.</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p>Passing the file descriptor as the <em>dirfd</em> argument of <a href="../man2/openat.2.html"><strong>openat</strong>(2)</a> and the other "*at()" system calls. This includes <a href="../man2/linkat.2.html"><strong>linkat</strong>(2)</a> with <strong>AT_EMPTY_PATH</strong> (or via procfs using <strong>AT_SYMLINK_FOLLOW</strong>) even if the file is not a directory.</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p>Passing the file descriptor to another process via a UNIX domain socket (see <strong>SCM_RIGHTS</strong> in <a href="../man7/unix.7.html"><strong>unix</strong>(7)</a>).</p>
        </dd>
      </dl>
<p class='spacer'>

  <p>When <strong>O_PATH</strong> is specified in <em>flags</em>, flag bits other than <strong>O_CLOEXEC</strong>, <strong>O_DIRECTORY</strong>, and <strong>O_NOFOLLOW</strong> are ignored.</p>
<p class='spacer'>

  <p>If <em>pathname</em> is a symbolic link and the <strong>O_NOFOLLOW</strong> flag is also specified, then the call returns a file descriptor referring to the symbolic link. This file descriptor can be used as the <em>dirfd</em> argument in calls to <a href="../man2/fchownat.2.html"><strong>fchownat</strong>(2)</a>, <a href="../man2/fstatat.2.html"><strong>fstatat</strong>(2)</a>, <a href="../man2/linkat.2.html"><strong>linkat</strong>(2)</a>, and <a href="../man2/readlinkat.2.html"><strong>readlinkat</strong>(2)</a> with an empty pathname to have the calls operate on the symbolic link.</p>
    </dd>
    <dt><strong>O_SYNC</strong></dt>
    <dd>
  <p>Write operations on the file will complete according to the requirements of synchronized I/O <em>file</em> integrity completion (by contrast with the synchronized I/O <em>data</em> integrity completion provided by <strong>O_DSYNC</strong>.)</p>
<p class='spacer'>

  <p>By the time <a href="../man2/write.2.html"><strong>write</strong>(2)</a> (and similar) return, the output data and associated file metadata have been transferred to the underlying hardware (i.e., as though each <a href="../man2/write.2.html"><strong>write</strong>(2)</a> was followed by a call to <a href="../man2/fsync.2.html"><strong>fsync</strong>(2)</a>). <em>See NOTES below</em>.</p>
    </dd>
    <dt><strong>O_TMPFILE</strong> (since Linux 3.11)</dt>
    <dd>
  <p>Create an unnamed temporary file. The <em>pathname</em> argument specifies a directory; an unnamed inode will be created in that directory's filesystem. Anything written to the resulting file will be lost when the last file descriptor is closed, unless the file is given a name.</p>
<p class='spacer'>

  <p><strong>O_TMPFILE</strong> must be specified with one of <strong>O_RDWR</strong> or <strong>O_WRONLY</strong> and, optionally, <strong>O_EXCL</strong>. If <strong>O_EXCL</strong> is not specified, then <a href="../man2/linkat.2.html"><strong>linkat</strong>(2)</a> can be used to link the temporary file into the filesystem, making it permanent, using code like the following:</p>
<p class='spacer'>

<pre>char path[PATH_MAX];
fd = open("/path/to/dir", O_TMPFILE | O_RDWR,
                        S_IRUSR | S_IWUSR);

/* File I/O on 'fd'... */

snprintf(path, PATH_MAX,  "/proc/self/fd/%d", fd);
linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file",
                        AT_SYMLINK_FOLLOW);</pre>

<p class='spacer'>

  <p>In this case, the <strong>open</strong>() <em>mode</em> argument determines the file permission mode, as with <strong>O_CREAT</strong>.</p>
<p class='spacer'>

  <p>Specifying <strong>O_EXCL</strong> in conjunction with <strong>O_TMPFILE</strong> prevents a temporary file from being linked into the filesystem in the above manner. (Note that the meaning of <strong>O_EXCL</strong> in this case is different from the meaning of <strong>O_EXCL</strong> otherwise.)</p>
<p class='spacer'>

      <p>There are two main use cases for <strong>O_TMPFILE</strong>:</p>
      <dl class='dl-horizontal'>
        <dt>*</dt>
        <dd>
      <p>Improved <a href="../man3/tmpfile.3.html"><strong>tmpfile</strong>(3)</a> functionality: race-free creation of temporary files that (1) are automatically deleted when closed; (2) can never be reached via any pathname; (3) are not subject to symlink attacks; and (4) do not require the caller to devise unique names.</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p>Creating a file that is initially invisible, which is then populated with data and adjusted to have appropriate filesystem attributes (<a href="../man2/fchown.2.html"><strong>fchown</strong>(2)</a>, <a href="../man2/fchmod.2.html"><strong>fchmod</strong>(2)</a>, <a href="../man2/fsetxattr.2.html"><strong>fsetxattr</strong>(2)</a>, etc.) before being atomically linked into the filesystem in a fully formed state (using <a href="../man2/linkat.2.html"><strong>linkat</strong>(2)</a> as described above).</p>
        </dd>
      </dl>
<p class='spacer'>

  <p><strong>O_TMPFILE</strong> requires support by the underlying filesystem; only a subset of Linux filesystems provide that support. In the initial implementation, support was provided in the ext2, ext3, ext4, UDF, Minix, and shmem filesystems. XFS support was added in Linux 3.15, and Btrfs support was added in Linux 3.16.</p>
    </dd>
    <dt><strong>O_TRUNC</strong></dt>
    <dd>
  <p>If the file already exists and is a regular file and the access mode allows writing (i.e., is <strong>O_RDWR</strong> or <strong>O_WRONLY</strong>) it will be truncated to length 0. If the file is a FIFO or terminal device file, the <strong>O_TRUNC</strong> flag is ignored. Otherwise, the effect of <strong>O_TRUNC</strong> is unspecified.</p>
    </dd>
  </dl>
  <h3>creat()</h3>
<p>A call to <strong>creat</strong>() is equivalent to calling <strong>open</strong>() with <em>flags</em> equal to <strong>O_CREAT|O_WRONLY|O_TRUNC</strong>.</p>
  <h3>openat()</h3>
<p>The <strong>openat</strong>() system call operates in exactly the same way as <strong>open</strong>(), except for the differences described here.</p>
<p class='spacer'>

<p>If the pathname given in <em>pathname</em> is relative, then it is interpreted relative to the directory referred to by the file descriptor <em>dirfd</em> (rather than relative to the current working directory of the calling process, as is done by <strong>open</strong>() for a relative pathname).</p>
<p class='spacer'>

<p>If <em>pathname</em> is relative and <em>dirfd</em> is the special value <strong>AT_FDCWD</strong>, then <em>pathname</em> is interpreted relative to the current working directory of the calling process (like <strong>open</strong>()).</p>
<p class='spacer'>

<p>If <em>pathname</em> is absolute, then <em>dirfd</em> is ignored.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">

<p><strong>open</strong>(), <strong>openat</strong>(), and <strong>creat</strong>() return the new file descriptor, or -1 if an error occurred (in which case, <em>errno</em> is set appropriately).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">

  <p><strong>open</strong>(), <strong>openat</strong>(), and <strong>creat</strong>() can fail with the following errors:</p>
  <dl class='dl-vertical'>
    <dt><strong>EACCES</strong></dt>
    <dd>
  <p>The requested access to the file is not allowed, or search permission is denied for one of the directories in the path prefix of <em>pathname</em>, or the file did not exist yet and write access to the parent directory is not allowed. (See also <a href="../man7/path_resolution.7.html"><strong>path_resolution</strong>(7)</a>.)</p>
    </dd>
    <dt><strong>EDQUOT</strong></dt>
    <dd>
  <p>Where <strong>O_CREAT</strong> is specified, the file does not exist, and the user's quota of disk blocks or inodes on the filesystem has been exhausted.</p>
    </dd>
    <dt><strong>EEXIST</strong></dt>
    <dd>
  <p><em>pathname</em> already exists and <strong>O_CREAT</strong> and <strong>O_EXCL</strong> were used.</p>
    </dd>
    <dt><strong>EFAULT</strong></dt>
    <dd>
  <p><em>pathname</em> points outside your accessible address space.</p>
    </dd>
    <dt><strong>EFBIG</strong></dt>
    <dd>
  <p>See <strong>EOVERFLOW</strong>.</p>
    </dd>
    <dt><strong>EINTR</strong></dt>
    <dd>
  <p>While blocked waiting to complete an open of a slow device (e.g., a FIFO; see <a href="../man7/fifo.7.html"><strong>fifo</strong>(7)</a>), the call was interrupted by a signal handler; see <a href="../man7/signal.7.html"><strong>signal</strong>(7)</a>.</p>
    </dd>
    <dt><strong>EINVAL</strong></dt>
    <dd>
  <p>The filesystem does not support the <strong>O_DIRECT</strong> flag. See <strong>NOTES</strong> for more information.</p>
    </dd>
    <dt><strong>EINVAL</strong></dt>
    <dd>
  <p>Invalid value in <em>flags</em>.</p>
    </dd>
    <dt><strong>EINVAL</strong></dt>
    <dd>
  <p><strong>O_TMPFILE</strong> was specified in <em>flags</em>, but neither <strong>O_WRONLY</strong> nor <strong>O_RDWR</strong> was specified.</p>
    </dd>
    <dt><strong>EISDIR</strong></dt>
    <dd>
  <p><em>pathname</em> refers to a directory and the access requested involved writing (that is, <strong>O_WRONLY</strong> or <strong>O_RDWR</strong> is set).</p>
    </dd>
    <dt><strong>EISDIR</strong></dt>
    <dd>
  <p><em>pathname</em> refers to an existing directory, <strong>O_TMPFILE</strong> and one of <strong>O_WRONLY</strong> or <strong>O_RDWR</strong> were specified in <em>flags</em>, but this kernel version does not provide the <strong>O_TMPFILE</strong> functionality.</p>
    </dd>
    <dt><strong>ELOOP</strong></dt>
    <dd>
  <p>Too many symbolic links were encountered in resolving <em>pathname</em>.</p>
    </dd>
    <dt><strong>ELOOP</strong></dt>
    <dd>
  <p><em>pathname</em> was a symbolic link, and <em>flags</em> specified <strong>O_NOFOLLOW</strong> but not <strong>O_PATH</strong>.</p>
    </dd>
    <dt><strong>EMFILE</strong></dt>
    <dd>
  <p>The per-process limit on the number of open file descriptors has been reached (see the description of <strong>RLIMIT_NOFILE</strong> in <a href="../man2/getrlimit.2.html"><strong>getrlimit</strong>(2)</a>).</p>
    </dd>
    <dt><strong>ENAMETOOLONG</strong></dt>
    <dd>
  <p><em>pathname</em> was too long.</p>
    </dd>
    <dt><strong>ENFILE</strong></dt>
    <dd>
  <p>The system-wide limit on the total number of open files has been reached.</p>
    </dd>
    <dt><strong>ENODEV</strong></dt>
    <dd>
  <p><em>pathname</em> refers to a device special file and no corresponding device exists. (This is a Linux kernel bug; in this situation <strong>ENXIO</strong> must be returned.)</p>
    </dd>
    <dt><strong>ENOENT</strong></dt>
    <dd>
  <p><strong>O_CREAT</strong> is not set and the named file does not exist. Or, a directory component in <em>pathname</em> does not exist or is a dangling symbolic link.</p>
    </dd>
    <dt><strong>ENOENT</strong></dt>
    <dd>
  <p><em>pathname</em> refers to a nonexistent directory, <strong>O_TMPFILE</strong> and one of <strong>O_WRONLY</strong> or <strong>O_RDWR</strong> were specified in <em>flags</em>, but this kernel version does not provide the <strong>O_TMPFILE</strong> functionality.</p>
    </dd>
    <dt><strong>ENOMEM</strong></dt>
    <dd>
  <p>Insufficient kernel memory was available.</p>
    </dd>
    <dt><strong>ENOSPC</strong></dt>
    <dd>
  <p><em>pathname</em> was to be created but the device containing <em>pathname</em> has no room for the new file.</p>
    </dd>
    <dt><strong>ENOTDIR</strong></dt>
    <dd>
  <p>A component used as a directory in <em>pathname</em> is not, in fact, a directory, or <strong>O_DIRECTORY</strong> was specified and <em>pathname</em> was not a directory.</p>
    </dd>
    <dt><strong>ENXIO</strong></dt>
    <dd>
  <p><strong>O_NONBLOCK</strong> | <strong>O_WRONLY</strong> is set, the named file is a FIFO, and no process has the FIFO open for reading. Or, the file is a device special file and no corresponding device exists.</p>
    </dd>
    <dt><strong>EOPNOTSUPP</strong></dt>
    <dd>
  <p>The filesystem containing <em>pathname</em> does not support <strong>O_TMPFILE</strong>.</p>
    </dd>
    <dt><strong>EOVERFLOW</strong></dt>
    <dd>
  <p><em>pathname</em> refers to a regular file that is too large to be opened. The usual scenario here is that an application compiled on a 32-bit platform without <em>-D_FILE_OFFSET_BITS=64</em> tried to open a file whose size exceeds <em>(1&lt;&lt;31)-1</em> bytes; see also <strong>O_LARGEFILE</strong> above. This is the error specified by POSIX.1; in kernels before 2.6.24, Linux gave the error <strong>EFBIG</strong> for this case.</p>
    </dd>
    <dt><strong>EPERM</strong></dt>
    <dd>
  <p>The <strong>O_NOATIME</strong> flag was specified, but the effective user ID of the caller did not match the owner of the file and the caller was not privileged (<strong>CAP_FOWNER</strong>).</p>
    </dd>
    <dt><strong>EPERM</strong></dt>
    <dd>
  <p>The operation was prevented by a file seal; see <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a>.</p>
    </dd>
    <dt><strong>EROFS</strong></dt>
    <dd>
  <p><em>pathname</em> refers to a file on a read-only filesystem and write access was requested.</p>
    </dd>
    <dt><strong>ETXTBSY</strong></dt>
    <dd>
  <p><em>pathname</em> refers to an executable image which is currently being executed and write access was requested.</p>
    </dd>
    <dt><strong>EWOULDBLOCK</strong></dt>
    <dd>
  <p>The <strong>O_NONBLOCK</strong> flag was specified, and an incompatible lease was held on the file (see <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a>).</p>
    </dd>
  </dl>
<p class='spacer'>

  <p>The following additional errors can occur for <strong>openat</strong>():</p>
  <dl class='dl-vertical'>
    <dt><strong>EBADF</strong></dt>
    <dd>
  <p><em>dirfd</em> is not a valid file descriptor.</p>
    </dd>
    <dt><strong>ENOTDIR</strong></dt>
    <dd>
  <p><em>pathname</em> is a relative pathname and <em>dirfd</em> is a file descriptor referring to a file other than a directory.</p>
    </dd>
  </dl>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSIONS</h2>
        <div class="sectioncontent">

<p><strong>openat</strong>() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFORMING TO</h2>
        <div class="sectioncontent">

<p><strong>open</strong>(), <strong>creat</strong>() SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.</p>
<p class='spacer'>

<p><strong>openat</strong>(): POSIX.1-2008.</p>
<p class='spacer'>

<p>The <strong>O_DIRECT</strong>, <strong>O_NOATIME</strong>, <strong>O_PATH</strong>, and <strong>O_TMPFILE</strong> flags are Linux-specific. One must define <strong>_GNU_SOURCE</strong> to obtain their definitions.</p>
<p class='spacer'>

<p>The <strong>O_CLOEXEC</strong>, <strong>O_DIRECTORY</strong>, and <strong>O_NOFOLLOW</strong> flags are not specified in POSIX.1-2001, but are specified in POSIX.1-2008. Since glibc 2.12, one can obtain their definitions by defining either <strong>_POSIX_C_SOURCE</strong> with a value greater than or equal to 200809L or <strong>_XOPEN_SOURCE</strong> with a value greater than or equal to 700. In glibc 2.11 and earlier, one obtains the definitions by defining <strong>_GNU_SOURCE</strong>.</p>
<p class='spacer'>

<p>As noted in <a href="../man7/feature_test_macros.7.html"><strong>feature_test_macros</strong>(7)</a>, feature test macros such as <strong>_POSIX_C_SOURCE</strong>, <strong>_XOPEN_SOURCE</strong>, and <strong>_GNU_SOURCE</strong> must be defined before including <em>any</em> header files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<p>Under Linux, the <strong>O_NONBLOCK</strong> flag indicates that one wants to open but does not necessarily have the intention to read or write. This is typically used to open devices in order to get a file descriptor for use with <a href="../man2/ioctl.2.html"><strong>ioctl</strong>(2)</a>.</p>
<p class='spacer'>

<p>The (undefined) effect of <strong>O_RDONLY | O_TRUNC</strong> varies among implementations. On many systems the file is actually truncated.</p>
<p class='spacer'>

<p>Note that <strong>open</strong>() can open device special files, but <strong>creat</strong>() cannot create them; use <a href="../man2/mknod.2.html"><strong>mknod</strong>(2)</a> instead.</p>
<p class='spacer'>

<p>If the file is newly created, its <em>st_atime</em>, <em>st_ctime</em>, <em>st_mtime</em> fields (respectively, time of last access, time of last status change, and time of last modification; see <a href="../man2/stat.2.html"><strong>stat</strong>(2)</a>) are set to the current time, and so are the <em>st_ctime</em> and <em>st_mtime</em> fields of the parent directory. Otherwise, if the file is modified because of the <strong>O_TRUNC</strong> flag, its <em>st_ctime</em> and <em>st_mtime</em> fields are set to the current time.</p>
<p class='spacer'>

<p>The files in the <em>/proc/[pid]/fd</em> directory show the open file descriptors of the process with the PID <em>pid</em>. The files in the <em>/proc/[pid]/fdinfo</em> directory show even more information about these files descriptors. See <a href="../man5/proc.5.html"><strong>proc</strong>(5)</a> for further details of both of these directories.</p>
  <h3>Open file descriptions</h3>
<p>The term open file description is the one used by POSIX to refer to the entries in the system-wide table of open files. In other contexts, this object is variously also called an "open file object", a "file handle", an "open file table entry", or&ndash;in kernel-developer parlance&ndash;a <em>struct file</em>.</p>
<p class='spacer'>

<p>When a file descriptor is duplicated (using <a href="../man2/dup.2.html"><strong>dup</strong>(2)</a> or similar), the duplicate refers to the same open file description as the original file descriptor, and the two file descriptors consequently share the file offset and file status flags. Such sharing can also occur between processes: a child process created via <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a> inherits duplicates of its parent's file descriptors, and those duplicates refer to the same open file descriptions.</p>
<p class='spacer'>

<p>Each <a href="../man2/open.2.html"><strong>open</strong>(2)</a> of a file creates a new open file description; thus, there may be multiple open file descriptions corresponding to a file inode.</p>
  <h3>Synchronized I/O</h3>
<p>The POSIX.1-2008 "synchronized I/O" option specifies different variants of synchronized I/O, and specifies the <strong>open</strong>() flags <strong>O_SYNC</strong>, <strong>O_DSYNC</strong>, and <strong>O_RSYNC</strong> for controlling the behavior. Regardless of whether an implementation supports this option, it must at least support the use of <strong>O_SYNC</strong> for regular files.</p>
<p class='spacer'>

<p>Linux implements <strong>O_SYNC</strong> and <strong>O_DSYNC</strong>, but not <strong>O_RSYNC</strong>. (Somewhat incorrectly, glibc defines <strong>O_RSYNC</strong> to have the same value as <strong>O_SYNC</strong>.)</p>
<p class='spacer'>

<p><strong>O_SYNC</strong> provides synchronized I/O <em>file</em> integrity completion, meaning write operations will flush data and all associated metadata to the underlying hardware. <strong>O_DSYNC</strong> provides synchronized I/O <em>data</em> integrity completion, meaning write operations will flush data to the underlying hardware, but will only flush metadata updates that are required to allow a subsequent read operation to complete successfully. Data integrity completion can reduce the number of disk operations that are required for applications that don't need the guarantees of file integrity completion.</p>
<p class='spacer'>

<p>To understand the difference between the two types of completion, consider two pieces of file metadata: the file last modification timestamp (<em>st_mtime</em>) and the file length. All write operations will update the last file modification timestamp, but only writes that add data to the end of the file will change the file length. The last modification timestamp is not needed to ensure that a read completes successfully, but the file length is. Thus, <strong>O_DSYNC</strong> would only guarantee to flush updates to the file length metadata (whereas <strong>O_SYNC</strong> would also always flush the last modification timestamp metadata).</p>
<p class='spacer'>

<p>Before Linux 2.6.33, Linux implemented only the <strong>O_SYNC</strong> flag for <strong>open</strong>(). However, when that flag was specified, most filesystems actually provided the equivalent of synchronized I/O <em>data</em> integrity completion (i.e., <strong>O_SYNC</strong> was actually implemented as the equivalent of <strong>O_DSYNC</strong>).</p>
<p class='spacer'>

<p>Since Linux 2.6.33, proper <strong>O_SYNC</strong> support is provided. However, to ensure backward binary compatibility, <strong>O_DSYNC</strong> was defined with the same value as the historical <strong>O_SYNC</strong>, and <strong>O_SYNC</strong> was defined as a new (two-bit) flag value that includes the <strong>O_DSYNC</strong> flag value. This ensures that applications compiled against new headers get at least <strong>O_DSYNC</strong> semantics on pre-2.6.33 kernels.</p>
  <h3>NFS</h3>
<p>There are many infelicities in the protocol underlying NFS, affecting amongst others <strong>O_SYNC</strong> and <strong>O_NDELAY</strong>.</p>
<p class='spacer'>

<p>On NFS filesystems with UID mapping enabled, <strong>open</strong>() may return a file descriptor but, for example, <a href="../man2/read.2.html"><strong>read</strong>(2)</a> requests are denied with <strong>EACCES</strong>. This is because the client performs <strong>open</strong>() by checking the permissions, but UID mapping is performed by the server upon read and write requests.</p>
  <h3>FIFOs</h3>
<p>Opening the read or write end of a FIFO blocks until the other end is also opened (by another process or thread). See <a href="../man7/fifo.7.html"><strong>fifo</strong>(7)</a> for further details.</p>
  <h3>File access mode</h3>
<p>Unlike the other values that can be specified in <em>flags</em>, the <em>access mode</em> values <strong>O_RDONLY</strong>, <strong>O_WRONLY</strong>, and <strong>O_RDWR</strong> do not specify individual bits. Rather, they define the low order two bits of <em>flags</em>, and are defined respectively as 0, 1, and 2. In other words, the combination <strong>O_RDONLY | O_WRONLY</strong> is a logical error, and certainly does not have the same meaning as <strong>O_RDWR</strong>.</p>
<p class='spacer'>

<p>Linux reserves the special, nonstandard access mode 3 (binary 11) in <em>flags</em> to mean: check for read and write permission on the file and return a file descriptor that can't be used for reading or writing. This nonstandard access mode is used by some Linux drivers to return a file descriptor that is to be used only for device-specific <a href="../man2/ioctl.2.html"><strong>ioctl</strong>(2)</a> operations.</p>
  <h3>Rationale for openat() and other directory file descriptor APIs</h3>
<p><strong>openat</strong>() and the other system calls and library functions that take a directory file descriptor argument (i.e., <a href="../man2/execveat.2.html"><strong>execveat</strong>(2)</a>, <a href="../man2/faccessat.2.html"><strong>faccessat</strong>(2)</a>, <a href="../man2/fanotify_mark.2.html"><strong>fanotify_mark</strong>(2)</a>, <a href="../man2/fchmodat.2.html"><strong>fchmodat</strong>(2)</a>, <a href="../man2/fchownat.2.html"><strong>fchownat</strong>(2)</a>, <a href="../man2/fstatat.2.html"><strong>fstatat</strong>(2)</a>, <a href="../man2/futimesat.2.html"><strong>futimesat</strong>(2)</a>, <a href="../man2/linkat.2.html"><strong>linkat</strong>(2)</a>, <a href="../man2/mkdirat.2.html"><strong>mkdirat</strong>(2)</a>, <a href="../man2/mknodat.2.html"><strong>mknodat</strong>(2)</a>, <a href="../man2/name_to_handle_at.2.html"><strong>name_to_handle_at</strong>(2)</a>, <a href="../man2/readlinkat.2.html"><strong>readlinkat</strong>(2)</a>, <a href="../man2/renameat.2.html"><strong>renameat</strong>(2)</a>, <a href="../man2/symlinkat.2.html"><strong>symlinkat</strong>(2)</a>, <a href="../man2/unlinkat.2.html"><strong>unlinkat</strong>(2)</a>, <a href="../man2/utimensat.2.html"><strong>utimensat</strong>(2)</a>, <a href="../man3/mkfifoat.3.html"><strong>mkfifoat</strong>(3)</a>, and <a href="../man3/scandirat.3.html"><strong>scandirat</strong>(3)</a>) are supported for two reasons. Here, the explanation is in terms of the <strong>openat</strong>() call, but the rationale is analogous for the other interfaces.</p>
<p class='spacer'>

<p>First, <strong>openat</strong>() allows an application to avoid race conditions that could occur when using <strong>open</strong>() to open files in directories other than the current working directory. These race conditions result from the fact that some component of the directory prefix given to <strong>open</strong>() could be changed in parallel with the call to <strong>open</strong>(). Suppose, for example, that we wish to create the file <em>path/to/xxx.dep</em> if the file <em>path/to/xxx</em> exists. The problem is that between the existence check and the file creation step, <em>path</em> or <em>to</em> (which might be symbolic links) could be modified to point to a different location. Such races can be avoided by opening a file descriptor for the target directory, and then specifying that file descriptor as the <em>dirfd</em> argument of (say) <a href="../man2/fstatat.2.html"><strong>fstatat</strong>(2)</a> and <strong>openat</strong>().</p>
<p class='spacer'>

<p>Second, <strong>openat</strong>() allows the implementation of a per-thread "current working directory", via file descriptor(s) maintained by the application. (This functionality can also be obtained by tricks based on the use of <em>/proc/self/fd/</em>dirfd, but less efficiently.)</p>
  <h3>O_DIRECT</h3>
<p class='spacer'>

<p>The <strong>O_DIRECT</strong> flag may impose alignment restrictions on the length and address of user-space buffers and the file offset of I/Os. In Linux alignment restrictions vary by filesystem and kernel version and might be absent entirely. However there is currently no filesystem-independent interface for an application to discover these restrictions for a given file or filesystem. Some filesystems provide their own interfaces for doing so, for example the <strong>XFS_IOC_DIOINFO</strong> operation in <a href="../man3/xfsctl.3.html"><strong>xfsctl</strong>(3)</a>.</p>
<p class='spacer'>

<p>Under Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset must all be multiples of the logical block size of the filesystem. Since Linux 2.6.0, alignment to the logical block size of the underlying storage (typically 512 bytes) suffices. The logical block size can be determined using the <a href="../man2/ioctl.2.html"><strong>ioctl</strong>(2)</a> <strong>BLKSSZGET</strong> operation or from the shell using the command:</p>
<p class='spacer'>

<pre>    blockdev --getss</pre>

<p class='spacer'>

<p><strong>O_DIRECT</strong> I/Os should never be run concurrently with the <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a> system call, if the memory buffer is a private mapping (i.e., any mapping created with the <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a> <strong>MAP_PRIVATE</strong> flag; this includes memory allocated on the heap and statically allocated buffers). Any such I/Os, whether submitted via an asynchronous I/O interface or from another thread in the process, should be completed before <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a> is called. Failure to do so can result in data corruption and undefined behavior in parent and child processes. This restriction does not apply when the memory buffer for the <strong>O_DIRECT</strong> I/Os was created using <a href="../man2/shmat.2.html"><strong>shmat</strong>(2)</a> or <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a> with the <strong>MAP_SHARED</strong> flag. Nor does this restriction apply when the memory buffer has been advised as <strong>MADV_DONTFORK</strong> with <a href="../man2/madvise.2.html"><strong>madvise</strong>(2)</a>, ensuring that it will not be available to the child after <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a>.</p>
<p class='spacer'>

<p>The <strong>O_DIRECT</strong> flag was introduced in SGI IRIX, where it has alignment restrictions similar to those of Linux 2.4. IRIX has also a <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> call to query appropriate alignments, and sizes. FreeBSD 4.x introduced a flag of the same name, but without alignment restrictions.</p>
<p class='spacer'>

<p><strong>O_DIRECT</strong> support was added under Linux in kernel version 2.4.10. Older Linux kernels simply ignore this flag. Some filesystems may not implement the flag and <strong>open</strong>() will fail with <strong>EINVAL</strong> if it is used.</p>
<p class='spacer'>

<p>Applications should avoid mixing <strong>O_DIRECT</strong> and normal I/O to the same file, and especially to overlapping byte regions in the same file. Even when the filesystem correctly handles the coherency issues in this situation, overall I/O throughput is likely to be slower than using either mode alone. Likewise, applications should avoid mixing <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a> of files with direct I/O to the same files.</p>
<p class='spacer'>

<p>The behavior of <strong>O_DIRECT</strong> with NFS will differ from local filesystems. Older kernels, or kernels configured in certain ways, may not support this combination. The NFS protocol does not support passing the flag to the server, so <strong>O_DIRECT</strong> I/O will bypass the page cache only on the client; the server may still cache the I/O. The client asks the server to make the I/O synchronous to preserve the synchronous semantics of <strong>O_DIRECT</strong>. Some servers will perform poorly under these circumstances, especially if the I/O size is small. Some servers may also be configured to lie to clients about the I/O having reached stable storage; this will avoid the performance penalty at some risk to data integrity in the event of server power failure. The Linux NFS client places no alignment restrictions on <strong>O_DIRECT</strong> I/O.</p>
<p class='spacer'>

<p>In summary, <strong>O_DIRECT</strong> is a potentially powerful tool that should be used with caution. It is recommended that applications treat use of <strong>O_DIRECT</strong> as a performance option which is disabled by default.</p>
<p class='spacer'>

<p>"The thing that has always disturbed me about O_DIRECT is that the whole interface is just stupid, and was probably designed by a deranged monkey on some serious mind-controlling substances."&ndash;Linus</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">

<p>Currently, it is not possible to enable signal-driven I/O by specifying <strong>O_ASYNC</strong> when calling <strong>open</strong>(); use <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> to enable this flag.</p>
<p class='spacer'>

<p>One must check for two different error codes, <strong>EISDIR</strong> and <strong>ENOENT</strong>, when trying to determine whether the kernel supports <strong>O_TMPFILE</strong> functionality.</p>
<p class='spacer'>

<p>When both <strong>O_CREAT</strong> and <strong>O_DIRECTORY</strong> are specified in <em>flags</em> and the file specified by <em>pathname</em> does not exist, <strong>open</strong>() will create a regular file (i.e., <strong>O_DIRECTORY</strong> is ignored).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEE ALSO</h2>
        <div class="sectioncontent">

<p><a href="../man2/chmod.2.html"><strong>chmod</strong>(2)</a>, <a href="../man2/chown.2.html"><strong>chown</strong>(2)</a>, <a href="../man2/close.2.html"><strong>close</strong>(2)</a>, <a href="../man2/dup.2.html"><strong>dup</strong>(2)</a>, <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a>, <a href="../man2/link.2.html"><strong>link</strong>(2)</a>, <a href="../man2/lseek.2.html"><strong>lseek</strong>(2)</a>, <a href="../man2/mknod.2.html"><strong>mknod</strong>(2)</a>, <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a>, <a href="../man2/mount.2.html"><strong>mount</strong>(2)</a>, <a href="../man2/open_by_handle_at.2.html"><strong>open_by_handle_at</strong>(2)</a>, <a href="../man2/read.2.html"><strong>read</strong>(2)</a>, <a href="../man2/socket.2.html"><strong>socket</strong>(2)</a>, <a href="../man2/stat.2.html"><strong>stat</strong>(2)</a>, <a href="../man2/umask.2.html"><strong>umask</strong>(2)</a>, <a href="../man2/unlink.2.html"><strong>unlink</strong>(2)</a>, <a href="../man2/write.2.html"><strong>write</strong>(2)</a>, <a href="../man3/fopen.3.html"><strong>fopen</strong>(3)</a>, <strong>acl</strong>(5), <a href="../man7/fifo.7.html"><strong>fifo</strong>(7)</a>, <a href="../man7/path_resolution.7.html"><strong>path_resolution</strong>(7)</a>, <a href="../man7/symlink.7.html"><strong>symlink</strong>(7)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="copy_file_range.2.html"><span aria-hidden="true">&larr;</span> copy_file_range.2: Copy a range of data from one file to another</a></li>
   <li class="next"><a href="create_module.2.html">create_module.2: create a loadable module entry <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

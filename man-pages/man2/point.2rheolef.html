<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>point: Vertex of a mesh</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Vertex of a mesh">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="point (2rheolef) manual">
  <meta name="twitter:description" content="Vertex of a mesh">
  <meta name="twitter:image" content="https://www.carta.tech/images/librheolef-dev-point-2rheolef.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man2rheolef/point.2rheolef.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="point (2rheolef) manual" />
  <meta property="og:description" content="Vertex of a mesh" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/librheolef-dev-point-2rheolef.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">point<small> (2rheolef)</small></h1>
        <p class="lead">Vertex of a mesh</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/point.2rheolef.html">
      <span itemprop="name">point: Vertex of a mesh</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/librheolef-dev/">
      <span itemprop="name">librheolef-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2rheolef/point.2rheolef.html">
      <span itemprop="name">point: Vertex of a mesh</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Defines geometrical vertex as an array of coordinates. This array is also used as a vector of the three dimensional physical space.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTATION</h2>
        <div class="sectioncontent">

<pre>
template &lt;class T&gt;
class point_basic {
    public:

// typedefs:

        typedef size_t size_type;
        typedef T      element_type;
        typedef T      scalar_type;
        typedef T      float_type;

// allocators:

        explicit point_basic () { _x[0] = T();  _x[1] = T();  _x[2] = T(); }

        explicit point_basic (
                const T& x0,
                const T& x1 = 0,
                const T& x2 = 0)
                        { _x[0] = x0; _x[1] = x1; _x[2] = x2; }

        template &lt;class T1&gt;
        point_basic&lt;T&gt;(const point_basic&lt;T1&gt;& p)
                { _x[0] = p._x[0]; _x[1] = p._x[1]; _x[2] = p._x[2]; }

        template &lt;class T1&gt;
        point_basic&lt;T&gt;& operator = (const point_basic&lt;T1&gt;& p)
                { _x[0] = p._x[0]; _x[1] = p._x[1]; _x[2] = p._x[2]; return *this; }

#ifdef _RHEOLEF_HAVE_STD_INITIALIZER_LIST
        point_basic (const std::initializer_list&lt;T&gt;& il);
#endif // _RHEOLEF_HAVE_STD_INITIALIZER_LIST

// accessors:

        T& operator[](int i_coord)              { return _x[i_coord%3]; }
        const T&  operator[](int i_coord) const { return _x[i_coord%3]; }
        T& operator()(int i_coord)              { return _x[i_coord%3]; }
        const T&  operator()(int i_coord) const { return _x[i_coord%3]; }

        // interface for CGAL library inter-operability:
        const T& x() const { return _x[0]; }
        const T& y() const { return _x[1]; }
        const T& z() const { return _x[2]; }
        T& x(){ return _x[0]; }
        T& y(){ return _x[1]; }
        T& z(){ return _x[2]; }

// inputs/outputs:

        std::istream& get (std::istream& s, int d = 3)
        {
            switch (d) {
            case 0 : _x[0] = _x[1] = _x[2] = 0; return s;
            case 1 : _x[1] = _x[2] = 0; return s &gt;&gt; _x[0];
            case 2 : _x[2] = 0; return s &gt;&gt; _x[0] &gt;&gt; _x[1];
            default: return s &gt;&gt; _x[0] &gt;&gt; _x[1] &gt;&gt; _x[2];
            }
        }
        // output
        std::ostream& put (std::ostream& s, int d = 3) const;

// algebra:

        bool operator== (const point_basic&lt;T&gt;& v) const
                { return _x[0] == v[0] && _x[1] == v[1] && _x[2] == v[2]; }

        bool operator!= (const point_basic&lt;T&gt;& v) const
                { return !operator==(v); }

        point_basic&lt;T&gt;& operator+= (const point_basic&lt;T&gt;& v)
                { _x[0] += v[0]; _x[1] += v[1]; _x[2] += v[2]; return *this; }

        point_basic&lt;T&gt;& operator-= (const point_basic&lt;T&gt;& v)
                { _x[0] -= v[0]; _x[1] -= v[1]; _x[2] -= v[2]; return *this; }

        point_basic&lt;T&gt;& operator*= (const T& a)
                { _x[0] *= a; _x[1] *= a; _x[2] *= a; return *this; }

        point_basic&lt;T&gt;& operator/= (const T& a)
                { _x[0] /= a; _x[1] /= a; _x[2] /= a; return *this; }

        point_basic&lt;T&gt; operator+ (const point_basic&lt;T&gt;& v) const
                { return point_basic&lt;T&gt; (_x[0]+v[0], _x[1]+v[1], _x[2]+v[2]); }

        point_basic&lt;T&gt; operator- () const
                { return point_basic&lt;T&gt; (-_x[0], -_x[1], -_x[2]); }

        point_basic&lt;T&gt; operator- (const point_basic&lt;T&gt;& v) const
                { return point_basic&lt;T&gt; (_x[0]-v[0], _x[1]-v[1], _x[2]-v[2]); }

        point_basic&lt;T&gt; operator* (const T& a) const
                { return point_basic&lt;T&gt; (a*_x[0], a*_x[1], a*_x[2]); }
        point_basic&lt;T&gt; operator* (int a) const
                { return operator* (T(a)); }

        point_basic&lt;T&gt; operator/ (const T& a) const
                { return operator* (T(1)/T(a)); }

        point_basic&lt;T&gt; operator/ (point_basic&lt;T&gt; v) const
                { return point_basic&lt;T&gt; (_x[0]/v[0], _x[1]/v[1], _x[2]/v[2]); }

// data:
// protected:
        T _x[3];
// internal:
        static T _my_abs(const T& x) { return (x &gt; T(0)) ? x : -x; }
};
typedef point_basic&lt;Float&gt; point;

// algebra:
template&lt;class T&gt;
inline
point_basic&lt;T&gt;
operator* (int a, const point_basic&lt;T&gt;& u)
{
  return u.operator* (T(a));
}
template&lt;class T&gt;
inline
point_basic&lt;T&gt;
operator* (const T& a, const point_basic&lt;T&gt;& u)
{
  return u.operator* (a);
}
template&lt;class T&gt;
inline
point_basic&lt;T&gt;
vect (const point_basic&lt;T&gt;& v, const point_basic&lt;T&gt;& w)
{
  return point_basic&lt;T&gt; (
        v[1]*w[2]-v[2]*w[1],
        v[2]*w[0]-v[0]*w[2],
        v[0]*w[1]-v[1]*w[0]);
}
// metrics:
template&lt;class T&gt;
inline
T dot (const point_basic&lt;T&gt;& x, const point_basic&lt;T&gt;& y)
{
  return x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
}
template&lt;class T&gt;
inline
T norm2 (const point_basic&lt;T&gt;& x)
{
  return dot(x,x);
}
template&lt;class T&gt;
inline
T norm (const point_basic&lt;T&gt;& x)
{
  return sqrt(norm2(x));
}
template&lt;class T&gt;
inline
T dist2 (const point_basic&lt;T&gt;& x,  const point_basic&lt;T&gt;& y)
{
  return norm2(x-y);
}
template&lt;class T&gt;
inline
T dist (const point_basic&lt;T&gt;& x,  const point_basic&lt;T&gt;& y)
{
  return norm(x-y);
}
template&lt;class T&gt;
inline
T dist_infty (const point_basic&lt;T&gt;& x,  const point_basic&lt;T&gt;& y)
{
  return max(point_basic&lt;T&gt;::_my_abs(x[0]-y[0]),
         max(point_basic&lt;T&gt;::_my_abs(x[1]-y[1]),
             point_basic&lt;T&gt;::_my_abs(x[2]-y[2])));
}
template &lt;class T&gt;
T vect2d (const point_basic&lt;T&gt;& v, const point_basic&lt;T&gt;& w);

template &lt;class T&gt;
T mixt (const point_basic&lt;T&gt;& u, const point_basic&lt;T&gt;& v, const point_basic&lt;T&gt;& w);

// robust(exact) floating point predicates: return the sign of the value as (0, &gt; 0, &lt; 0)
// formally: orient2d(a,b,x) = vect2d(a-x,b-x)
template &lt;class T&gt;
int
sign_orient2d (
  const point_basic&lt;T&gt;& a,
  const point_basic&lt;T&gt;& b,
  const point_basic&lt;T&gt;& c);

template &lt;class T&gt;
int
sign_orient3d (
  const point_basic&lt;T&gt;& a,
  const point_basic&lt;T&gt;& b,
  const point_basic&lt;T&gt;& c,
  const point_basic&lt;T&gt;& d);

// compute also the value:
template &lt;class T&gt;
T orient2d(
  const point_basic&lt;T&gt;& a,
  const point_basic&lt;T&gt;& b,
  const point_basic&lt;T&gt;& c);

// formally: orient3d(a,b,c,x) = mixt3d(a-x,b-x,c-x)
template &lt;class T&gt;
T orient3d(
  const point_basic&lt;T&gt;& a,
  const point_basic&lt;T&gt;& b,
  const point_basic&lt;T&gt;& c,
  const point_basic&lt;T&gt;& d);

template &lt;class T&gt;
std::string ptos (const point_basic&lt;T&gt;& x, int d = 3);

// ccomparators: lexicographic order
template&lt;class T, size_t d&gt;
bool
lexicographically_less (const point_basic&lt;T&gt;& a, const point_basic&lt;T&gt;& b)
{
  for (typename point_basic&lt;T&gt;::size_type i = 0; i &lt; d; i++) {
    if (a[i] &lt; b[i]) return true;
    if (a[i] &gt; b[i]) return false;
  }
  return false; // equality
}
</pre>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="geo.2rheolef.html"><span aria-hidden="true">&larr;</span> geo.2rheolef: Finite element mesh (rheolef-6.5)</a></li>
   <li class="next"><a href="quadrature_option_type.2rheolef.html">quadrature_option_type.2rheolef: Send options to the integrate function <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

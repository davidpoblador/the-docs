<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>select: Synchronous i/o multiplexing</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Synchronous i/o multiplexing">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="select (2) manual">
  <meta name="twitter:description" content="Synchronous i/o multiplexing">
  <meta property="og:type" content="website" />
  <meta property="og:title" content="select (2) manual" />
  <meta property="og:description" content="Synchronous i/o multiplexing" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">select<small> (2)</small></h1>
        <p class="lead">Synchronous i/o multiplexing</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2/">
      <span itemprop="name">System calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2/select.2.html">
      <span itemprop="name">select: Synchronous i/o multiplexing</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/man-pages/">
      <span itemprop="name">man-pages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man2/select.2.html">
      <span itemprop="name">select: Synchronous i/o multiplexing</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
/* According to POSIX.1-2001, POSIX.1-2008 */

<strong>#include &lt;sys/select.h&gt;</strong>

/* According to earlier standards */

<strong>#include &lt;sys/time.h&gt;</strong>

<strong>#include &lt;sys/types.h&gt;</strong>

<strong>#include &lt;unistd.h&gt;</strong>

<strong>int select(int </strong><em>nfds</em><strong>, fd_set *</strong><em>readfds</em><strong>, fd_set *</strong><em>writefds</em><strong>,</strong>
<strong>           fd_set *</strong><em>exceptfds</em><strong>, struct timeval *</strong><em>timeout</em><strong>);</strong>

<strong>void FD_CLR(int </strong><em>fd</em><strong>, fd_set *</strong><em>set</em><strong>);</strong>

<strong>int  FD_ISSET(int </strong><em>fd</em><strong>, fd_set *</strong><em>set</em><strong>);</strong>

<strong>void FD_SET(int </strong><em>fd</em><strong>, fd_set *</strong><em>set</em><strong>);</strong>

<strong>void FD_ZERO(fd_set *</strong><em>set</em><strong>);</strong>

<strong>#include &lt;sys/select.h&gt;</strong>

<strong>int pselect(int </strong><em>nfds</em><strong>, fd_set *</strong><em>readfds</em><strong>, fd_set *</strong><em>writefds</em><strong>,</strong>
<strong>            fd_set *</strong><em>exceptfds</em><strong>, const struct timespec *</strong><em>timeout</em><strong>,</strong>
<strong>            const sigset_t *</strong><em>sigmask</em><strong>);</strong>
</pre>
<p>Feature Test Macro Requirements for glibc (see <a href="../man7/feature_test_macros.7.html"><strong>feature_test_macros</strong>(7)</a>):</p><p><strong>pselect</strong>(): _POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200112L</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>select</strong>() and <strong>pselect</strong>() allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of I/O operation (e.g., input possible). A file descriptor is considered ready if it is possible to perform a corresponding I/O operation (e.g., <a href="../man2/read.2.html"><strong>read</strong>(2)</a> without blocking, or a sufficiently small <a href="../man2/write.2.html"><strong>write</strong>(2)</a>).</p><p><strong>select</strong>() can monitor only file descriptors numbers that are less than <strong>FD_SETSIZE</strong>; <a href="../man2/poll.2.html"><strong>poll</strong>(2)</a> does not have this limitation. See BUGS.</p><p>The operation of <strong>select</strong>() and <strong>pselect</strong>() is identical, other than these three differences:</p>
<dl class='dl-vertical'>
  <dt>
    <p>(i)</p>
  </dt>
  <dd>
    <p><strong>select</strong>() uses a timeout that is a <em>struct timeval</em> (with seconds and microseconds), while <strong>pselect</strong>() uses a <em>struct timespec</em> (with seconds and nanoseconds).</p>
  </dd>
  <dt>
    <p>(ii)</p>
  </dt>
  <dd>
    <p><strong>select</strong>() may update the <em>timeout</em> argument to indicate how much time was left. <strong>pselect</strong>() does not change this argument.</p>
  </dd>
  <dt>
    <p>(iii)</p>
  </dt>
  <dd>
    <p><strong>select</strong>() has no <em>sigmask</em> argument, and behaves as <strong>pselect</strong>() called with NULL <em>sigmask</em>.</p>
  </dd>

</dl>
<p>Three independent sets of file descriptors are watched. Those listed in <em>readfds</em> will be watched to see if characters become available for reading (more precisely, to see if a read will not block; in particular, a file descriptor is also ready on end-of-file), those in <em>writefds</em> will be watched to see if space is available for write (though a large write may still block), and those in <em>exceptfds</em> will be watched for exceptions. On exit, the sets are modified in place to indicate which file descriptors actually changed status. Each of the three file descriptor sets may be specified as NULL if no file descriptors are to be watched for the corresponding class of events.</p><p>Four macros are provided to manipulate the sets. <strong>FD_ZERO</strong>() clears a set. <strong>FD_SET</strong>() and <strong>FD_CLR</strong>() respectively add and remove a given file descriptor from a set. <strong>FD_ISSET</strong>() tests to see if a file descriptor is part of the set; this is useful after <strong>select</strong>() returns.</p><p><em>nfds</em> is the highest-numbered file descriptor in any of the three sets, plus 1.</p><p>The <em>timeout</em> argument specifies the interval that <strong>select</strong>() should block waiting for a file descriptor to become ready. The call will block until either:</p><ul>
<li><p>a file descriptor becomes ready;</p></li><li><p>the call is interrupted by a signal handler; or</p></li><li><p>the timeout expires.</p></li>
</ul><p>Note that the <em>timeout</em> interval will be rounded up to the system clock granularity, and kernel scheduling delays mean that the blocking interval may overrun by a small amount. If both fields of the <em>timeval</em> structure are zero, then <strong>select</strong>() returns immediately. (This is useful for polling.) If <em>timeout</em> is NULL (no timeout), <strong>select</strong>() can block indefinitely.</p><p><em>sigmask</em> is a pointer to a signal mask (see <a href="../man2/sigprocmask.2.html"><strong>sigprocmask</strong>(2)</a>); if it is not NULL, then <strong>pselect</strong>() first replaces the current signal mask by the one pointed to by <em>sigmask</em>, then does the "select" function, and then restores the original signal mask.</p><p>Other than the difference in the precision of the <em>timeout</em> argument, the following <strong>pselect</strong>() call:</p>
<pre>
    ready = pselect(nfds, &readfds, &writefds, &exceptfds,
                    timeout, &sigmask);

</pre>
<p>is equivalent to <em>atomically</em> executing the following calls:</p>
<pre>
    sigset_t origmask;

    pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);
    pthread_sigmask(SIG_SETMASK, &origmask, NULL);
</pre>
<p>The reason that <strong>pselect</strong>() is needed is that if one wants to wait for either a signal or for a file descriptor to become ready, then an atomic test is needed to prevent race conditions. (Suppose the signal handler sets a global flag and returns. Then a test of this global flag followed by a call of <strong>select</strong>() could hang indefinitely if the signal arrived just after the test but just before the call. By contrast, <strong>pselect</strong>() allows one to first block signals, handle the signals that have come in, then call <strong>pselect</strong>() with the desired <em>sigmask</em>, avoiding the race.)</p><h3>The timeout</h3>
<p>The time structures involved are defined in <em>&lt;sys/time.h&gt;</em> and look like</p>
<pre>
struct timeval {
    long    tv_sec;         /* seconds */
    long    tv_usec;        /* microseconds */
};
</pre>
<p>and</p>
<pre>
struct timespec {
    long    tv_sec;         /* seconds */
    long    tv_nsec;        /* nanoseconds */
};
</pre>
<p>(However, see below on the POSIX.1 versions.)</p><p>Some code calls <strong>select</strong>() with all three sets empty, <em>nfds</em> zero, and a non-NULL <em>timeout</em> as a fairly portable way to sleep with subsecond precision.</p><p>On Linux, <strong>select</strong>() modifies <em>timeout</em> to reflect the amount of time not slept; most other implementations do not do this. (POSIX.1 permits either behavior.) This causes problems both when Linux code which reads <em>timeout</em> is ported to other operating systems, and when code is ported to Linux that reuses a <em>struct timeval</em> for multiple <strong>select</strong>()s in a loop without reinitializing it. Consider <em>timeout</em> to be undefined after <strong>select</strong>() returns.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>On success, <strong>select</strong>() and <strong>pselect</strong>() return the number of file descriptors contained in the three returned descriptor sets (that is, the total number of bits that are set in <em>readfds</em>, <em>writefds</em>, <em>exceptfds</em>) which may be zero if the timeout expires before anything interesting happens. On error, -1 is returned, and <em>errno</em> is set to indicate the error; the file descriptor sets are unmodified, and <em>timeout</em> becomes undefined.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>EBADF</strong></p>
  </dt>
  <dd>
    <p>An invalid file descriptor was given in one of the sets. (Perhaps a file descriptor that was already closed, or one on which an error has occurred.)</p>
  </dd>
  <dt>
    <p><strong>EINTR</strong></p>
  </dt>
  <dd>
    <p>A signal was caught; see <a href="../man7/signal.7.html"><strong>signal</strong>(7)</a>.</p>
  </dd>
  <dt>
    <p><strong>EINVAL</strong></p>
  </dt>
  <dd>
    <p><em>nfds</em> is negative or exceeds the <strong>RLIMIT_NOFILE</strong> resource limit (see <a href="../man2/getrlimit.2.html"><strong>getrlimit</strong>(2)</a>).</p>
  </dd>
  <dt>
    <p><strong>EINVAL</strong></p>
  </dt>
  <dd>
    <p>The value contained within <em>timeout</em> is invalid.</p>
  </dd>
  <dt>
    <p><strong>ENOMEM</strong></p>
  </dt>
  <dd>
    <p>Unable to allocate memory for internal tables.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSIONS</h2>
        <div class="sectioncontent">
<p><strong>pselect</strong>() was added to Linux in kernel 2.6.16. Prior to this, <strong>pselect</strong>() was emulated in glibc (but see BUGS).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFORMING TO</h2>
        <div class="sectioncontent">
<p><strong>select</strong>() conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (<strong>select</strong>() first appeared in 4.2BSD). Generally portable to/from non-BSD systems supporting clones of the BSD socket layer (including System&nbsp;V variants). However, note that the System&nbsp;V variant typically sets the timeout variable before exit, but the BSD variant does not.</p><p><strong>pselect</strong>() is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>An <em>fd_set</em> is a fixed size buffer. Executing <strong>FD_CLR</strong>() or <strong>FD_SET</strong>() with a value of <em>fd</em> that is negative or is equal to or larger than <strong>FD_SETSIZE</strong> will result in undefined behavior. Moreover, POSIX requires <em>fd</em> to be a valid file descriptor.</p><p>On some other UNIX systems, <strong>select</strong>() can fail with the error <strong>EAGAIN</strong> if the system fails to allocate kernel-internal resources, rather than <strong>ENOMEM</strong> as Linux does. POSIX specifies this error for <a href="../man2/poll.2.html"><strong>poll</strong>(2)</a>, but not for <strong>select</strong>(). Portable programs may wish to check for <strong>EAGAIN</strong> and loop, just as with <strong>EINTR</strong>.</p><p>Concerning the types involved, the classical situation is that the two fields of a <em>timeval</em> structure are typed as <em>long</em> (as shown above), and the structure is defined in <em>&lt;sys/time.h&gt;</em>. The POSIX.1 situation is</p>
<pre>
struct timeval {
    time_t         tv_sec;     /* seconds */
    suseconds_t    tv_usec;    /* microseconds */
};
</pre>
<p>where the structure is defined in <em>&lt;sys/select.h&gt;</em> and the data types <em>time_t</em> and <em>suseconds_t</em> are defined in <em>&lt;sys/types.h&gt;</em>.</p><p>Concerning prototypes, the classical situation is that one should include <em>&lt;time.h&gt;</em> for <strong>select</strong>(). The POSIX.1 situation is that one should include <em>&lt;sys/select.h&gt;</em> for <strong>select</strong>() and <strong>pselect</strong>().</p><p>Under glibc 2.0, <em>&lt;sys/select.h&gt;</em> gives the wrong prototype for <strong>pselect</strong>(). Under glibc 2.1 to 2.2.1, it gives <strong>pselect</strong>() when <strong>_GNU_SOURCE</strong> is defined. Since glibc 2.2.2, the requirements are as shown in the SYNOPSIS.</p><h3>Multithreaded applications</h3>
<p>If a file descriptor being monitored by <strong>select</strong>() is closed in another thread, the result is unspecified. On some UNIX systems, <strong>select</strong>() unblocks and returns, with an indication that the file descriptor is ready (a subsequent I/O operation will likely fail with an error, unless another the file descriptor reopened between the time <strong>select</strong>() returned and the I/O operations was performed). On Linux (and some other systems), closing the file descriptor in another thread has no effect on <strong>select</strong>(). In summary, any application that relies on a particular behavior in this scenario must be considered buggy.</p>
<h3>C library/kernel differences</h3>
<p>The Linux kernel allows file descriptor sets of arbitrary size, determining the length of the sets to be checked from the value of <em>nfds</em>. However, in the glibc implementation, the <em>fd_set</em> type is fixed in size. See also BUGS.</p><p>The <strong>pselect</strong>() interface described in this page is implemented by glibc. The underlying Linux system call is named <strong>pselect6</strong>(). This system call has somewhat different behavior from the glibc wrapper function.</p><p>The Linux <strong>pselect6</strong>() system call modifies its <em>timeout</em> argument. However, the glibc wrapper function hides this behavior by using a local variable for the timeout argument that is passed to the system call. Thus, the glibc <strong>pselect</strong>() function does not modify its <em>timeout</em> argument; this is the behavior required by POSIX.1-2001.</p><p>The final argument of the <strong>pselect6</strong>() system call is not a <em>sigset_t&nbsp;*</em> pointer, but is instead a structure of the form:</p>
<pre>
struct {
    const sigset_t *ss;     /* Pointer to signal set */
    size_t          ss_len; /* Size (in bytes) of object pointed
                               to by 'ss' */
};

</pre>
<p>This allows the system call to obtain both a pointer to the signal set and its size, while allowing for the fact that most architectures support a maximum of 6 arguments to a system call.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>POSIX allows an implementation to define an upper limit, advertised via the constant <strong>FD_SETSIZE</strong>, on the range of file descriptors that can be specified in a file descriptor set. The Linux kernel imposes no fixed limit, but the glibc implementation makes <em>fd_set</em> a fixed-size type, with <strong>FD_SETSIZE</strong> defined as 1024, and the <strong>FD_*</strong>() macros operating according to that limit. To monitor file descriptors greater than 1023, use <a href="../man2/poll.2.html"><strong>poll</strong>(2)</a> instead.</p><p>Glibc 2.0 provided a version of <strong>pselect</strong>() that did not take a <em>sigmask</em> argument.</p><p>Starting with version 2.1, glibc provided an emulation of <strong>pselect</strong>() that was implemented using <a href="../man2/sigprocmask.2.html"><strong>sigprocmask</strong>(2)</a> and <strong>select</strong>(). This implementation remained vulnerable to the very race condition that <strong>pselect</strong>() was designed to prevent. Modern versions of glibc use the (race-free) <strong>pselect</strong>() system call on kernels where it is provided.</p><p>On systems that lack <strong>pselect</strong>(), reliable (and more portable) signal trapping can be achieved using the self-pipe trick. In this technique, a signal handler writes a byte to a pipe whose other end is monitored by <strong>select</strong>() in the main program. (To avoid possibly blocking when writing to a pipe that may be full or reading from a pipe that may be empty, nonblocking I/O is used when reading from and writing to the pipe.)</p><p>Under Linux, <strong>select</strong>() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use <strong>O_NONBLOCK</strong> on sockets that should not block.</p><p>On Linux, <strong>select</strong>() also modifies <em>timeout</em> if the call is interrupted by a signal handler (i.e., the <strong>EINTR</strong> error return). This is not permitted by POSIX.1. The Linux <strong>pselect</strong>() system call has the same behavior, but the glibc wrapper hides this behavior by internally copying the <em>timeout</em> to a local variable and passing that variable to the system call.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int
main(void)
{
    fd_set rfds;
    struct timeval tv;
    int retval;

    /* Watch stdin (fd 0) to see when it has input. */

    FD_ZERO(&rfds);
    FD_SET(0, &rfds);

    /* Wait up to five seconds. */

    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(1, &rfds, NULL, NULL, &tv);
    /* Don't rely on the value of tv now! */

    if (retval == -1)
        perror("select()");
    else if (retval)
        printf("Data is available now.&#92;n");
        /* FD_ISSET(0, &rfds) will be true. */
    else
        printf("No data within five seconds.&#92;n");

    exit(EXIT_SUCCESS);
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO select&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man2/accept.2.html"><strong>accept</strong>(2)</a>, <a href="../man2/connect.2.html"><strong>connect</strong>(2)</a>, <a href="../man2/poll.2.html"><strong>poll</strong>(2)</a>, <a href="../man2/read.2.html"><strong>read</strong>(2)</a>, <a href="../man2/recv.2.html"><strong>recv</strong>(2)</a>, <a href="../man2/restart_syscall.2.html"><strong>restart_syscall</strong>(2)</a>, <a href="../man2/send.2.html"><strong>send</strong>(2)</a>, <a href="../man2/sigprocmask.2.html"><strong>sigprocmask</strong>(2)</a>, <a href="../man2/write.2.html"><strong>write</strong>(2)</a>, <a href="../man7/epoll.7.html"><strong>epoll</strong>(7)</a>, <a href="../man7/time.7.html"><strong>time</strong>(7)</a></p><p>For a tutorial with discussion and examples, see <a href="../man2/select_tut.2.html"><strong>select_tut</strong>(2)</a>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="security.2.html"><span aria-hidden="true">&larr;</span> security.2: Unimplemented system calls</a></li>
   <li class="next"><a href="select_tut.2.html">select_tut.2: Synchronous i/o multiplexing <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

.TH "FBB::SharedStream" "3bobcat" "2005\-2014" "libbobcat\-dev_3\&.23\&.01\-x\&.tar\&.gz" "I/O on shared memory"

.PP 
.SH "NAME"
FBB::SharedStream \- I/O operations on shared memory
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/sharedstream>\fP
.br 
Linking option: \fI\-lpthread \-lbobcat\fP 
.PP 
.SH "DESCRIPTION"

.PP 
This class combines the features of the \fBstd::istream\fP and
\fBstd::ostream\fP classes, operating on shared memory\&. As with \fIstd::fstream\fP
objects, a \fIseekp\fP or \fIseekg\fP member call is required to switch from
writing to reading or v\&.v\&. 
.PP 
As with \fIstd::fstream\fP objects, \fBFBB::SharedStream\fP objects do not keep
separate offsets for reading and writeing: the seek\-members always refer to
the (single) offset maintained by the \fIFBB::SharedMemory\fP object to which
the \fBSharedStream\fP object interfaces\&. 
.PP 
So, although \fItellg\fP and \fItellp\fP return identical values, \fItellg\fP should
not be called after writing to a \fBSharedStream\fP object, and \fItellp\fP should
not be called after reading from a \fBSharedStream\fP object, as calling members
related to reading (\fItellg\fP) after writing and v\&.v\&. put the stream in its
fail state\&.
.PP 
.SH "NAMESPACE"
\fBFBB\fP
.br 
All constructors, members, operators and manipulators, mentioned in this
man\-page, are defined in the namespace \fBFBB\fP\&.
.PP 
.SH "INHERITS FROM"
\fBFBB::SharedStreambuf\fP (private inheritance),
.br 
\fBstd::istream\fP,
.br 
\fBstd::ostream\fP,
.br 
\fBFBB::SharedEnum__\fP (cf\&. \fBsharedmemory\fP(3bobcat) for a description of
this base class)\&.
.PP 
.SH "SIZEUNIT ENUMERATION"

.PP 
The \fBenum SizeUnit\fP defines the following symbolic constants:
.IP o 
\fBkB\fP, representing 1024 (2**10) bytes of memory;
.IP o 
\fBMB\fP, representing 1048576 (2**20 bytes of memory;
.IP o 
\fBGB\fP, representing 1073741824 (2**30) bytes of memory
)
.IP 
.SH "CONSTRUCTORS"
.IP o 
\fBSharedStream()\fP:
.br 
The default constructor defines a stub a \fBSharedStream\fP object that
cannot immediately be used to access shared memory\&. To use it, its
member \fIopen\fP must first be called\&.
.IP 
.IP o 
\fBSharedStream(size_t maxSize, SizeUnit sizeUnit, 
std::ios::openmode openMode = std::ios::in | std::ios::out,
size_t access = 0600)\fP:
.br 
This constructor creates a stream inheriting the facilities of an
\fIstd::istream\fP and \fIstd::ostream\fP that interfaces to a shared
memory segment having a capacity of at least \fImaxSize * sizeUnit\fP
bytes\&. 
.IP 
By default, the shared memory segment is opened for reading and
writing\&. Different from the open modes used for file streams, creating
a shared memory stream with open modes \fIios::in | ios::out\fP is
OK\&. In this case the shared memory segment is created and once
information has been written to the shared memory it can also be read
again\&. 
.IP 
The shared memory\(cq\&s access rights are defined by the \fIaccess\fP
parameter, interpreted as an octal value, using the well\-known
(\fBchmod\fP(1)) way to define the access rights for owner, group and
others\&.
.IP 
If construction fails, an \fIFBB::Exception\fP is thrown\&.
.IP 
.IP o 
\fBSharedStream(int id, std::ios::openmode openMode = std::ios::in |
std::ios::out)\fP:
.br 
This constructor creates a stream inheriting the facilities of an
\fIstd::istream\fP and \fIstd::ostream\fP that connects to a shared memory
segment having ID \fIid\fP\&. 
.IP 
Specifying the \fIios::trunc\fP flag immediately clears the contents of
the shared memory\&.
.IP 
An \fIFBB::Exception\fP is thrown if construction fails (e\&.g\&., no shared
memory segment having ID \fIid\fP exists),
Copy and move constructors are not available\&.
.IP 
.SH "OVERLOADED OPERATORS"

.IP 
No overloaded move and copy assignment operators are available\&.
.IP 
.SH "MEMBER FUNCTIONS"

.IP 
All members of \fIstd::istream\fP and \fIstd::ostream\fP and the \fIenum\fP
values \fIkB, MB\fP, and \fIGB\fP, defined by \fIFBB::SharedEnum__\fP are available\&. 
.IP 
.IP o 
\fBFBB::SharedCondition attachSharedCondition(std::ios::off_type offset,
std::ios::seekdir origin)\fP:
.br 
Returns an \fBFBB::SharedCondition\fP(3) object, interfacing to a shared
condition variable located at offset \fIoffset\fP (relative to
\fIorigin\fP) in the \fISharedMemory\fP object to which the
\fBSharedStream\fP object interfaces\&.  This member does not alter the
value returned by the stream\(cq\&s \fItellg\fP and \fItellp\fP members\&.
.IP 
An \fIFBB::Exception\fP is thrown if the \fIFBB::SharedCondition\fP object
could not be constructed\&.
.IP 
.IP o 
\fBFBB::SharedCondition createSharedCondition()\fP:
.br 
Returns an \fBFBB::SharedCondition\fP(3) object, interfacing to a newly
created shared condition variable which is created at the current
offset of the \fISharedMemory\fP object to which the \fBSharedStream\fP
object interfaces (or at the first offset of the next physical shared
memory data block, cf\&. \fBsharedcondition\fP(3bobcat))\&.  Creating a
\fISharedCondition\fP object does not alter the value returned by the
stream\(cq\&s \fItellg\fP and \fItellp\fP members\&.
.IP 
An \fIFBB::Exception\fP is thrown if the \fIFBB::SharedCondition\fP object
could not be constructed\&.
.IP 
.IP o 
\fBint id() const\fP:
.br 
The ID of the shared memory segment is returned\&.
.IP 
.IP o 
\fBvoid kill()\fP:
.br 
Without locking the shared memory first,  all shared memory is returned
to the operating system\&. The \fBFBB::SharedStream\fP object is unusable
after returning from \fIkill\fP\&. Other processes that were using the
shared memory can continue to do so\&.
.IP 
.IP o 
\fBvoid memInfo(std::ostream &out, char const *end = \(dq\&\en\(dq\&)\fP:
.br 
Information about the \fISharedMemory\fP object is inserted into the
provide \fIostream\fP object\&. The IDs of the shared segments, their
sizes, the maximum number of shared memory segments, the number of
bytes that can be read from the shared memory, and its actual storage
capacity, etc\&., are displayed\&. Following the information about the
shared memory, \fIend\fP is inserted into \fIout\fP\&.
.IP 
.IP o 
\fBvoid open(size_t maxSize, SizeUnit sizeUnit,
std::ios::openmode openMode = std::ios::in | std::ios::out,
size_t access = 0600)\fP:
.br 
This member creates a shared memory segment having a capacity of at
least \fImaxSize * sizeUnit\fP bytes, and connects the shared memory
segment to the \fBFBB::SharedStream\fP\&. A matching \fIclose\fP member does
not exist and is not required\&. 
.IP 
By default, the shared memory segment is opened for reading and
writing\&. Different from the open modes used for file streams, creating
a shared memory stream with open modes \fIios::in | ios::out\fP is
OK\&. In this case the shared memory segment is created and once
information has been written to the shared memory it can also be read
again\&. 
.IP 
The shared memory\(cq\&s access rights are defined by the \fIaccess\fP
parameter, interpreted as an octal value, using the well\-known
(\fBchmod\fP(1)) way to define the access rights for owner, group and
others\&.
.IP 
If opening fails, an \fIFBB::Exception\fP is thrown\&.
.IP 
.IP o 
\fBvoid open(int id, std::ios::openmode openMode = std::ios::in |
std::ios::out)\fP:
.br 
This member connects the \fBFBB::SharedStream\fP object to a shared
memory segment having ID \fIid\fP\&. A matching \fIclose\fP member does
not exist and is not required\&. If opening succeeds the shared
memory is ready for use\&. 
.IP 
Specifying the \fIios::trunc\fP flag immediately clears the contents of
the shared memory\&.
.IP 
An \fIFBB::Exception\fP is thrown if opening fails (e\&.g\&., no shared
memory segment having ID \fIid\fP exists)\&. 
.IP 
.IP o 
\fBvoid remove()\fP:
.br 
The shared memory is first locked\&. Next, all shared memory is returned
to the operating system\&. The \fBFBB::SharedStream\fP object is unusable
after returning from \fIremove\fP\&. Other processes that were using the
shared memory can continue to do so\&.
.IP 
.IP o 
\fBbool truncate(std::streamsize offset)\fP:
.br 
If \fIoffset\fP is not exceeding the value returned by \fIseekg(0,
std::ios::end)\fP, then this latter value is changed to \fIoffset\fP and
\fItrue\fP is returned\&. Otherwise \fIfalse\fP is returned, and the value
returned by \fIseekg\fP is not altered\&. If the value returned by
\fItellg\fP exceeded \fIoffset\fP, \fItellg\fP\(cq\&s return value it is reduced
to \fIoffset\fP as well\&. Subsequent read operations on the shared memory
can only succeed as long as \fItellg\fP\(cq\&s return value hasn\(cq\&t reached
the value \fIoffset\fP\&. 

.PP 
.SH "EXAMPLE"

.PP 
.nf 
#include <iostream>
#include <string>
#include <ostream>
#include <istream>

#include <bobcat/exception>
#include <bobcat/sharedstream>
#include <bobcat/sharedcondition>

using namespace std;
using namespace FBB;

int main()
{
    SharedStream sharedStream;

    int id = \-1;

    while (true)
    {
        cout << 
                \(dq\&\en\(dq\&
                \(dq\& K             kill (no lock) existing shared segment\en\(dq\&
                \(dq\& S             show stats of current shared segment\en\(dq\&
                \(dq\& L <id>        Load segment <id>\en\(dq\&
                \(dq\& C             Install a SharedCondition at offset 0\en\(dq\&
                \(dq\& c            create new shared memory (sets id)\en\(dq\&
//                \(dq\& l            lock segment id until key pressed\en\(dq\&
//                \(dq\& p <x> c      put char c at offset x\en\(dq\&
                \(dq\& q            quit\en\(dq\&
//                \(dq\& r <x> <n>    read n chars from offset x\en\(dq\&
//                \(dq\& w <x> args   write all args at offset x\en\(dq\&
                  \(dq\& i            insert lines (until empty) at the current \(dq\&
                                                                \(dq\&offset\en\(dq\&

                  \(dq\& x            extract lines (until EOF) from the current \(dq\&
                                                                \(dq\&offset\en\(dq\&
                  \(dq\& X            extract the next line from the current \(dq\&
                                                                \(dq\&offset\en\(dq\&
                  \(dq\&              when nodified via \(cq\&N\(cq\&\en\(dq\&
                  \(dq\& N            notify a waiting X\en\(dq\&
                  \(dq\& s <x>        seek (abs) offset x\en\(dq\&
                \(dq\&? \(dq\&;

        char ch;
        cin >> ch;

        ios::off_type offset;

        cout << \(dq\&Requested: \(dq\& << ch << \(cq\&\en\(cq\&;

        sharedStream\&.clear();

        switch (ch)
        {
            case \(cq\&c\(cq\&:
            {
                sharedStream\&.open(1, SharedStream::kB);

                id = sharedStream\&.id();
                cout << \(dq\&id = \(dq\& << id << \(cq\&\en\(cq\&;
                sharedStream\&.memInfo(cout);
                cout << \(cq\&\en\(cq\&;
            }
            break;
        
            case \(cq\&C\(cq\&:
            {
                sharedStream\&.seekp(0);
                SharedCondition cond(sharedStream\&.createSharedCondition());
                sharedStream\&.seekg(cond\&.width());
                break;
            }

            case \(cq\&K\(cq\&:         // delete segment
            {
                if (id == \-1)
                {
                    cout << \(dq\&No segment loaded\en\(dq\&;
                    continue;
                }

                cout << \(dq\&Removing segment id = \(dq\& << id << \(cq\&\en\(cq\&;
                if (ch == \(cq\&R\(cq\&)
                    sharedStream\&.remove();
                else
                    sharedStream\&.kill();

                id = \-1;
            }
            break;

            case \(cq\&L\(cq\&:
                cin >> id;
                cout << \(dq\&Loading segment \(dq\& << id << \(cq\&\en\(cq\&;
                sharedStream\&.open(id);
                sharedStream\&.memInfo(cout);
                cout << \(cq\&\en\(cq\&;
            break;

            case \(cq\&S\(cq\&:
                if (id == \-1)
                {
                    cout << \(dq\&No segment loaded\en\(dq\&;
                    continue;
                }
                sharedStream\&.memInfo(cout);
                cout << \(cq\&\en\(cq\&;
            break;
            
            case \(cq\&s\(cq\&:
            {
                size_t offset;
                if (id == \-1)
                {
                    cout << \(dq\&No segment loaded\en\(dq\&;
                    continue;
                }
                cin >> offset;
                sharedStream\&.seekg(offset);
                sharedStream\&.seekp(offset);
                cout << \(dq\&tellg: \(dq\& << sharedStream\&.tellg() << \(dq\&, \(dq\&
                        \(dq\&tellp: \(dq\& << sharedStream\&.tellp() << \(cq\&\en\(cq\&;
            }
            break;
            
            case \(cq\&i\(cq\&:
            {
                string line;
                getline(cin, line);
                sharedStream\&.seekp(0, ios::cur);
                while (true)
                {
                    cout << \(dq\&? \(dq\&;
                    if (not getline(cin, line) || line\&.empty())
                        break;
                    sharedStream << line << endl;
                    cout << 
                            \(dq\&   tellp: \(dq\& << sharedStream\&.tellp() << \(cq\&\en\(cq\&;
                }
                    cout << // \(dq\&   tellg: \(dq\& << sharedStream\&.tellg() << \(dq\&, \(dq\&
                            \(dq\&   tellp: \(dq\& << sharedStream\&.tellp() << \(cq\&\en\(cq\&;
            }
            break;
                    
            case \(cq\&x\(cq\&:
            {
                string line;
                sharedStream\&.seekg(0, ios::cur);

                while (true)
                {
                    cout << \(dq\&: \(dq\&;
                    if (not getline(sharedStream, line))
                        break;
                    cout << line << \(dq\&\en\(dq\&
                            \(dq\&   tellg: \(dq\& << sharedStream\&.tellg() << \(dq\&, \(dq\&
                            \(dq\&   tellp: \(dq\& << sharedStream\&.tellp() << \(cq\&\en\(cq\&;
                }
            }
            break;
                    
            case \(cq\&X\(cq\&:
            {
                SharedCondition cond(sharedStream\&.attachSharedCondition(0));

                string line;
                sharedStream\&.seekg(cond\&.width());

                cond\&.lock();

                while (true)
                {
                    cond\&.wait();

                    cout << \(dq\&: \(dq\&;
                    if (not getline(sharedStream, line))
                        break;

                    cout << line << \(dq\&\en\(dq\&
                            \(dq\&   tellg: \(dq\& << sharedStream\&.tellg() << \(dq\&, \(dq\&
                            \(dq\&   tellp: \(dq\& << sharedStream\&.tellp() << \(cq\&\en\(cq\&;
                }
                cout << \(dq\&All done\en\(dq\&;
                cond\&.unlock();
            }
            break;

            case \(cq\&N\(cq\&:
            {
                string line;
                getline(cin, line);

                SharedCondition cond(sharedStream\&.attachSharedCondition(0));
                while (true)
                {
                    cout << \(dq\&\(cq\&enter\(cq\& or \(cq\&q\(cq\&? \(dq\&;
                    getline(cin, line);

                    if (line == \(dq\&q\(dq\&)
                        break;

                    cond\&.lock();
                    cond\&.notify();
                    cond\&.unlock();
                }
            }
            break;
        
            case \(cq\&p\(cq\&:           // put a char behind the last written
            {
                if (id == \-1)
                {
                    cout << \(dq\&No segment loaded\en\(dq\&;
                    continue;
                }

                cin >> offset >> ch;
                if (!cin)
                    throw Exception() << \(dq\&cmd specification error\(dq\&;
    
                sharedStream\&.seekp(offset);
                cout << \(dq\&Segment id = \(dq\& << id << \(dq\& at write offset \(dq\& << 
                                                    sharedStream\&.tellp() << \(cq\&\en\(cq\&;
                sharedStream\&.put(ch);
            }
            break;
                
            case \(cq\&r\(cq\&:           // put a char behind the last written
            {
                if (id == \-1)
                {
                    cout << \(dq\&No segment loaded\en\(dq\&;
                    continue;
                }

                int n;

                cin >> offset >> n;
                if (!cin)
                    throw Exception() << \(dq\&cmd specification error\(dq\&;

                char buf[n];

                sharedStream\&.seekg(offset);
                cout << \(dq\&Segment id = \(dq\& << id << \(dq\& at offset \(dq\& << 
                         sharedStream\&.tellg() << \(dq\&, to read \(dq\& << n << \(dq\& bytes\en\(dq\&;
    
                n = sharedStream\&.read(buf, n)\&.gcount();
    
                if (n < 0)
                    cout << \(dq\&No data at \(dq\& << offset << \(cq\&\en\(cq\&;
                else
                {
                    cout << \(dq\&Retrieved \(dq\& << n << \(dq\& bytes, containing `\(dq\&;
                    cout\&.write(buf, n);
                    cout << \(dq\&\(cq\&\en\(dq\&;
    
                    for (auto ch: buf)
                        cout << static_cast<int>(ch) << \(cq\& \(cq\&;
                    cout << \(cq\&\en\(cq\&;
                }
            }
            break;
                
            case \(cq\&w\(cq\&:           // write chars at offset
            {
                if (id == \-1)
                {
                    cout << \(dq\&No segment loaded\en\(dq\&;
                    continue;
                }

                string line;

                cin >> offset;
                getline(cin, line);
                if (!cin)
                    throw Exception() << \(dq\&cmd specification error\(dq\&;
    
                streampos pos = sharedStream\&.seekp(offset)\&.tellp();

                cout << \(dq\&Segment id = \(dq\& << id << \(dq\& at offset \(dq\& << 
                         pos << \(dq\&, to write \(dq\& << line\&.length() << \(dq\& bytes\en\(dq\&;
    
                
                sharedStream\&.write(line\&.data(), line\&.length());

                if (!sharedStream)
                    cout << \(dq\&No room left to write any bytes\en\(dq\&;
                else
                    cout << \(dq\&Wrote \(dq\& << (sharedStream\&.tellp() \- pos) << \(dq\& bytes\en\(dq\&;
            }
            break;
                
            case \(cq\&q\(cq\&:
            return 0;

            default:
                cout << \(dq\&request not implemented: \(dq\& << ch << \(cq\&\en\(cq\&;
            break;
        }
    }
}


.fi 

.PP 
.SH "FILES"
\fIbobcat/sharedstream\fP \- defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7),  \fBchmod\fP(1),
\fBisharedstream\fP(3bobcat),
\fBosharedstream\fP(3bobcat),
\fBsharedblock\fP(3bobcat), 
\fBsharedcondition\fP(3bobcat), 
\fBsharedmemory\fP(3bobcat)
\fBsharedmutex\fP(3bobcat), 
\fBsharedpos\fP(3bobcat), 
\fBsharedsegment\fP(3bobcat),
\fBsharedstreambuf\fP(3bobcat)
.PP 
.SH "BUGS"
Note that by default exceptions thrown from within a \fBstd::stream\fP
object are caught by the stream object, setting its \fIios::failbit\fP flag\&. To
allow exceptions to leave a stream object, its \fIexceptions\fP member can be
called, e\&.g\&., using:
.nf 

    myStream\&.exceptions(ios::failbit | ios::badbit | ios::eofbit);
        
.fi 

.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_3\&.23\&.01\-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1\-dev_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\(cq\&s Own Base Classes And Templates\(cq\&\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
GNU General Public License (GPL)\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 

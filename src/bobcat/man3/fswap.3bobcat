.TH "FBB::fswap" "3bobcat" "2005\-2014" "libbobcat\-dev_3\&.23\&.01\-x\&.tar\&.gz" "Fast swap function"

.PP 
.SH "NAME"
FBB::fswap \- generic template fast swap function
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/fswap>\fP
.br 

.PP 
.SH "DESCRIPTION"
The information stored in objects frequently needs to be swapped\&. A
well\-known example is the swapping operation required when implementing an
overloaded assignment operator\&. For example, the generic form of the operator
assignment operator is:
.nf 

    Class &operator=(Class const &other)
    {
        Class tmp(other);
        swap(tmp);
        return *this;
    }
        
.fi 
The swap functionality merely swaps the contents of the current object and
another object\&. The standard \fIstd::swap\fP function calls the class\(cq\&s
\fIoperator=\fP function to swap objects\&. Newer implementations might use
move\-operations to increase the speed of the swaping operation, but in both
cases some form of the assignment operator must be available\&. Swapping,
however, might be possible when assignemnt isn\(cq\&t\&. Classes having reference
data members usually don\(cq\&t offer assignment operators but swapping might be a
well\-defined operation\&.
.PP 
It is well known that objects can be installed in a block of memory using
\fIplacement new\fP, using a block of memory the size of the object to construct
the object it\&. This is the foundation of the template function \fIFBB::fswap\fP
(fast swap)\&. This swap function merely uses the memory occupied by objects to
implement the swapping operation and it may therefore be used with classes
having const data members, reference data members, ponters to allocated memory
etc, etc\&. The function simply uses a spare block of memory the size of the
object to be swapped\&. It then uses \fBmemcpy\fP(3) to swap the information
contained in the two objects, using the spare block of memory as a
placeholder\&.
.PP 
The function uses partial specializations to optimize the swapping
operation for objects of sizes 1, 2, 4 or 8 bytes\&. It uses \fBmemcpy\fP(3) for
objects of other sizes\&.
.PP 
.SH "NAMESPACE"
\fBFBB\fP
.br 
All constructors, members, operators and manipulators, mentioned in this
man\-page, are defined in the namespace \fBFBB\fP\&.
.PP 
.SH "INHERITS FROM"
\-
.PP 
.SH "SWAP FUNCTION"

.PP 
.IP o 
\fBfswap(Type &lhs, Type &rhs)\fP:
.br 
This template function swaps the contents of the two objects\&. It can
be used with classes having const data members, reference members, pointer
members or standard value\-typed data members\&.

.PP 
.SH "EXAMPLE"
.nf 
#include <iostream>
#include \(dq\&\&.\&./fswap\(dq\&

class Demo
{
    std::ostream &d_out;
    size_t d_value;

    public:
        Demo(std::ostream &out = std::cerr, size_t value = 0)
        :
            d_out(out),
            d_value(value)
        {}

        void show(char const *msg)
        {
            d_out << msg << \(dq\&\&. Value: \(dq\& << d_value << \(cq\&\en\(cq\&;
        }
};


using namespace std;

int main()
{
    Demo d1;
    Demo d2(cout, 12);

    FBB::fswap(d1, d2);

    d1\&.show(\(dq\&This is d1\(dq\&);              // to cerr: 12
    d2\&.show(\(dq\&This is d2\(dq\&);              // to cout: 0
}







.fi 

.PP 
.SH "FILES"
\fIbobcat/fswap\fP \- defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7), \fBmemcpy\fP(3)
.PP 
.SH "BUGS"
The \fIfswap\fP function should not be applied mechanically to swap objects
of classes having pointer data members defining, e\&.g\&., a linked list\&. Consider
a list of four objects like:
.nf 

    A \-> B \-> C \-> D
        
.fi 
fast\-swapping B and C would result in the following corrupted list:
.nf 

               +\-\-\-\-\-\-+
               |      |
    A \-> C \-+  +\-> B \-+   +\-> D
            |             |
            +\-\-\-\-\-\-\-\-\-\-\-\-\-+
        
.fi 
However, classes implementing a data structure like a linked\-list might
still benefit from fast swapping operations: by implementing their own swap
member they could first use fast swapping to swap the objects, followed by 
another fast swap to unswap their `next\(cq\& pointers\&.
.PP 
The \fIfswap\fP function should also not be used for objects defining
(back\-)pointers to their own data\&. Consider the following objects using
pointers to data and (back\-)pointers to the original objects:
.nf 

    Before fswapping:
        A                                  B                          
       +\-\-\-\-\-\-\-\-+   +\-\-\-\-\-\-\-\-\-\-\-+         +\-\-\-\-\-\-\-\-+   +\-\-\-\-\-\-\-\-\-\-\-+  
       |        |   |           |         |        |   |           |  
     +\-\-> *Aimp\-\-\-\-\-\-> *A (back)\-\-+     +\-\-> *Bimp\-\-\-\-\-\-> *B (back)\-\-+
     | |        |   |           | |     | |        |   |           | |
     +\-\-**Aimp  |   +\-\-\-\-\-\-\-\-\-\-\-+ |     +\-\-**Bimp  |   +\-\-\-\-\-\-\-\-\-\-\-+ |
       +\-\-\-\-\-\-\-\-+ <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+       +\-\-\-\-\-\-\-\-+ <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+

    After fswapping:
                     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
                  +\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-+                
    +\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+             | |                
    |   A         |  v                 |   B         | v              
    |  +\-\-\-\-\-\-\-\-+ | +\-\-\-\-\-\-\-\-\-\-\-+      |  +\-\-\-\-\-\-\-\-+ | +\-\-\-\-\-\-\-\-\-\-\-+  
    |  |        | | |           |      |  |        | | |           |  
  +\-\-\-\-\-> *Bimp\-\-\-+ |  *A (back)\-\-+    +\-\-\-> *Aimp\-\-\-+ |  *B (back)\-\-+
  | |  |        |   |           | |       |        |   |           | |
  | +\-\-\-**Bimp  |   +\-\-\-\-\-\-\-\-\-\-\-+ |    +\-\-\-**Aimp  |   +\-\-\-\-\-\-\-\-\-\-\-+ |
  |    +\-\-\-\-\-\-\-\-+ <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+    |  +\-\-\-\-\-\-\-\-+ <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
        
.fi 
After the swap \fI**Bimp\fP should point to \fIBimp\fP\(cq\&s address (now at A),
but in fact it points to \fIAimp\fP\(cq\&s address (now at B)\&. Likewise, the back
pointers still point at their original objects rather than at their swapped
objects\&. 
.PP 
All \fIstream\fP classes define such pointers and can therefore not be swapped
using \fIfswap\fP\&.
.PP 
The bottom line being that \fIfswap\fP should only be used for self\-defined
classes for which it can be proven that fast\-swapping does not corrupt the
values of its pointer data\&.
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_3\&.23\&.01\-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1\-dev_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\(cq\&s Own Base Classes And Templates\(cq\&\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
GNU General Public License (GPL)\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 

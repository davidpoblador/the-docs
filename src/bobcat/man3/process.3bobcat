.TH "FBB::Process" "3bobcat" "2005\-2014" "libbobcat\-dev_3\&.23\&.01\-x\&.tar\&.gz" "Running Child Processes"

.PP 
.SH "NAME"
FBB::Process \- Runs external programs
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/process>\fP
.br 
Linking option: \fI\-lbobcat\fP 
.PP 
.SH "DESCRIPTION"
The \fBFBB::Process\fP class offers an extensive interface to calling
external programs and/or scripts from a \fBC++\fP program (so\-called
\fIchild\-processes\fP)\&. The class offers an easy to use, stream\-based interface
to the standard input, standard output and standard error streams of child
processes\&.
.PP 
Objects of the \fIclass Process\fP use standard process\-executing functions,
like members of the \fBexecl\fP(1) family or \fBsh\fP(1) to execute child
processes\&. Thus, child processes can be executable programs or
\fIshell\-scripts\fP\&.
.PP 
The standard input, output and error streams of child processes may
be accessed through their \fIProcess\fP parent objects\&. Input expected by child
processes may be inserted by \fIProcess\fP objects, and output generated by
child processes may be extracted from \fIProcess\fP objects\&. 
.PP 
When using (output) redirection with the \fIUSE_SHELL\fP path specification (see
below for the path and IOMode specifications), the \fIIGNORE_COUT IOMode\fP (and
possibly \fIIGNORE_CERR\fP) should normally be specified (see also this
man\-page\(cq\&s \fBPIPING\fP section)\&.
.PP 
\fIProcess\fP objects may repeatedly be used to execute the same or different
child processes\&. Before the next child process is started, the \fIProcess\fP
object first terminates its currently active child process\&. Alternatively, a
currently active child process is automatically ended if the \fIProcess\fP
object goes out of scope, if its \fIstop\fP or \fIeoi\fP (end\-of\-information)
member is called, or if the \fIeoi\fP manipulator is inserted into the
\fIProcess\fP object\&.
.PP 
Programs to be called as child processes may be specified at \fIProcess\(cq\&s\fP
constructor\-time or through \fIProcess\(cq\&s setCommand\fP member\&. \fIProcess\fP
constructors (or \fIProcess set\fP\-members) never start child processes\&. Child
processes are started through \fIstart\fP members or the assignment operator\&.
.PP 
Child processes may receive information at their standard input streams
through information inserted into \fIProcess\fP objects\&. In these cases the
\fIProcess\fP objects must inform their child processes that they have received
all input\&. For this the \fIclose\fP or \fIeoi\fP member or the \fIeoi\fP manipulator
can be used\&. After calling the \fIclose\fP member, the \fIwaitForChild\fP member
should be called as well\&. This is not necessary if either the \fIeoi\fP member
or the \fIeoi\fP manipulator is used\&.
.PP 
If \fIwaitForChild\fP is not called (but information sent to the child which
could not be fully processed by the child process in case the child process
terminated as a result of the \fIProcess\fP object going out of scope), then the
operating system issues a \fIBroken pipe\fP message, indicating that information
in a pipe was lost\&.
.PP 
Arguments passed to child processes may be surrounded by double
or single quotes\&. Arguments surrounded by double quotes have their double
quotes removed, while interpreting any escape\-sequences that may have been
used within\&. Arguments surrounded by single quotes have their single quotes
removed, while accepting their contents as\-is\&. In addition unquoted
escape\-sequences may be specified: those escape sequences are evaluated and
replaced by their intended characters (e\&.g\&., \fI\e100\fP is converted to \fI@\fP)\&.
.PP 
A full command specification may be surrounded by backtics
(\fI`\fP\-characters)\&. These backtick characters are removed by the \fIProcess\fP
object when the command is started\&.
.PP 
Child processes may be allowed a limited amount of time (in seconds) to
complete\&. By default no time limit is imposed upon child processes\&.
.PP 
By default the standard input, output and error streams of child processes are
accessed through their \fIProcess\fP parent processes: information inserted into
the \fIProcess\fP object is forwarded to the child process\(cq\&s standard input
stream, information sent by the child process to its standard output stream
can be extracted from its parent \fIProcess\fP object, and information sent by
the child process to its standard error stream may be obtained through
\fIProcess\(cq\&s childErrStream\fP member\&.
.PP 
If the parent and child processes have agreed on some communication process,
then information may alternatingly be sent to and received from the child
process through the \fIProcess\(cq\&s ostream\fP and \fIistream\fP
facilities\&. Alternatively, unspecified amounts of information written by child
processes may be processed by separate threads (cf\&. this manual page\(cq\&s
\fBEXAMPLES\fP section)\&.
.PP 
.SH "NAMESPACE"
\fBFBB\fP
.br 
All constructors, members, operators and manipulators, mentioned in this
man\-page, are defined in the namespace \fBFBB\fP\&.
.PP 
.SH "INHERITS FROM"
\fBFBB::Fork\fP(3bobcat) (private), 
.br 
\fBFBB:IOStream\fP(3bobcat)
\fBFBB:ProcessEnums\fP
.PP 
The \fIstruct ProcessEnums\fP defines enumerations and support functions which
are used by several classes\&. Its enumerations are documented below; there is
no separate \fBProcessEnums\fP man\-page\&.
.PP 
.SH "ENUMERATIONS"

.PP 
\fBenum ProcessType\fP:
.br 

.PP 
The \fBenum ProcessType\fP defines how a child process is started or
located\&. Its values are specified at constructor\-time or through the
\fIsetProcessType\fP member\&. This enumeration defines the following symbolic
constants:
.IP o 
\fBNO_PATH\fP:
.br 
The program specified as child process is started as specified,
without searching the elements of the \fIPATH\fP environment
variable\&.
.IP o 
\fBUSE_PATH\fP:
.br 
The elements of the \fIPATH\fP environment variable are used when
locating the program specified as child process\&.
.IP o 
\fBUSE_SHELL\fP:
.br 
The program specified as child process is called using \fI/bin/sh
\-c\fP\&. When (output) redirection is used with the specified command
the \fIIGNORE_COUT IOMode\fP (and possibly also the \fIIGNORE_CERR
IOMode\fP) should be specified\&.

.PP 
\fBenum IOMode\fP:
.br 

.PP 
Values of the \fIenum IOMode\fP are used to define which of the child
process\(cq\&s standard streams can be accessed through the \fIProcess\fP object\&. Its
symbolic constants may be combined using the \fIbit_or\fP operator\&. By default
\fICIN | COUT | CERR\fP is used (see below)\&.
.PP 
The following symbolic constants are available:
.IP o 
\fBALL\fP:
.br 
Shortcut for \fBCIN | COUT | CERR\fP\&.
.IP o 
\fBCIN\fP:
.br 
Information inserted into the \fIProcess\fP object is forwarded to
its child process\&.  If this is not required then \fICIN\fP should
not be specified\&.
.IP o 
\fBCERR\fP:
.br 
Information written by the child process to its standard error
stream is accessible through \fIProcess\(cq\&s childErrStream\fP member\&.
If this is not required then \fICERR\fP should not be specified\&.
.IP o 
\fBCOUT\fP:
.br 
Information written by the child process to its standard output
stream may be directly be extracted from the \fIProcess\fP object,
or from its \fIchildOutStream\fP member\&.  If this is not required
then \fICERR\fP should not be specified\&.
.IP o 
\fBDIRECT\fP:
.br 
When starting a child process (see below at the member \fIstart\fP)
the current process (i\&.e\&., the program defining the \fIProcess\fP
object) is replaced by the child process, inheriting the current
process\(cq\&s standard input and output streams\&. If this mode is
specified in combination with any other \fIIOMode\fP (except for
\fISTD\fP, see below) an \fIstd::invalid_argument\fP exception is
thrown\&.
.IP o 
\fBIGNORE_CERR\fP:
.br 
Information written by the child process to its standard error
stream is sent to \fI/dev/null\fP\&. An \fIstd::invalid_argument\fP
exception is thrown if this mode is specified in combination with
\fBDIRECT, CERR\fP and/or \fBMERGE_COUT_CERR\fP\&.
.IP o 
\fBIGNORE_COUT\fP:
.br 
Information written by the child process to its standard output
stream is sent to \fI/dev/null\fP\&. An \fIstd::invalid_argument\fP
exception is thrown if this mode is specified in combination with
\fBCOUT, DIRECT\fP and/or \fBMERGE_COUT_CERR\fP\&.
.IP o 
\fBIGNORE_COUT_CERR\fP:
.br 
Shortcut for \fIIGNORE_CERR | IGNORE_COUT\fP\&.
.IP o 
\fBMERGE_COUT_CERR\fP:
.br 
Information extracted from the \fIProcess\fP object is written by the
child process to its standard output and standard error streams\&.
An \fIstd::invalid_argument\fP exception is thrown if this mode is
specified in combination with \fBCOUT, CERR, DIRECT, IGNORE_COUT\fP
or \fIIGNORE_CERR\fP\&.
.IP o 
\fBNONE\fP:
.br 
The \fIProcess\fP object does not extract information from or insert
information into the standard streams of its child process\&. The
child process reads the same standard input stream and writes the
same standard output streams as its parent \fIProcess\fP
object\&. When this mode is specified in combination with other
\fIIOMode\fP values it is silently ignored\&.  

.PP 
\fBenum ChildOutput\fP:
.br 
The \fIChildOutput\fP enumeration defines values returned by the
\fIavailable\fP member (see below) indicating to which standard stream the
child process has written information\&.  This enumeration defines the following
values:
.IP o 
\fBNOTHING_AVAILABLE\fP:
.br 
The child process did not (yet) write any information to its
standard streams;
.IP o 
\fBCHILD_COUT\fP:
.br 
The child process wrote information to its standard output
stream which is waiting for extraction\&.
.IP o 
\fBCHILD_CERR\fP:
.br 
The child process wrote information to its standard error stream
which is waiting for extraction\&.
The latter two values may be combined using the \fIbit_or\fP operator\&. The
\fIbit_and\fP operator,returning a \fIbool\fP value can be used to test whether
information on a specific output stream is available\&.
.PP 
.SH "PROCESS PARAMETERS"

.PP 
Four process parameters may be specified: the sizes of the stream buffers
which are used when communicating with child processes; to specify which of
the standard streams of child processes can be accessed from the \fIProcess\fP
object combinations of \fIIOMode\fP values are used; to specify how child
programs are found a \fIProcessType\fP value is used; to specify the maximum
time (in seconds) the child program is allowed to run a \fIsize_t\fP values is
used\&.
.PP 
By default, the stream buffers hold 200 bytes; all the child\(cq\&s standard
streams (standard input, output and error) are accessible from the \fIParent\fP
process; the \fIPATH\fP environment variable is \fInot\fP used to locate the child
program; and the child processes will be allowed an unlimited amount of time
to run\&.
.PP 
After constructing a \fIProcess\fP object all default parameters may be
modified\&. These parameters may either be altered for a single process or a
\fIProcess\fP object\(cq\&s general defaults may be modified\&. The \fIset*\fP members
(see below) may be used to change the default process parameters\&. When
parameters are specified otherwise, they will only be active for the next
process\&.
.PP 
.SH "CONSTRUCTORS"

.PP 
The command provided to the following constructors may be the
(initial part of the) specification of an external program to run\&. When the
program is eventually started it may start and end with a \fIback\-tick\fP
(\fI`\fP)\&. The back\-ticks will be removed just before the specified program is
executed\&.
.PP 
Child processes are \fInot\fP started automatically following \fIProcess\fP
object constructions\&. A \fIstart\fP member or the assignment operator (see
below) is used to start the specified child process\&.
.PP 
The \fImode\fP parameter that is defined for the second through fourth
constructor is defined as a \fIsize_t\fP for backward compatibility reasons\&.
Internally, this argument is immediately converted to a \fIProcess::IOMode\fP
value, silently ignoring values which do not represent valid \fIIOMode\fP
values\&. Multiple \fIIOMode\fP values may be combined using the bit\-or operator\&.
.PP 
After constructing a \fIProcess\fP object its parameters can be changed
using \fIset\fP\-member functions, function call operators or \fIstart\fP members\&. 
.PP 
.IP o 
\fBProcess(std::string const &cmd = \(dq\&\(dq\&)\fP:
.br 
This constructor is used to specify the (initial part of a) command to
execute from a \fIProcess\fP object\&. Default values are used for the
process parameters (see section \fBPROCESS PARAMETERS\fP)\&.
.IP 
.IP o 
\fBProcess(size_t mode, std::string const &cmd = \(dq\&\(dq\&)\fP:
.br 
This constructor requires the specification of the object\(cq\&s 
\fBIOMode\fP, and it can be used to specify the (initial part of
a) command to execute from a \fIProcess\fP object\&. Default values
are used for the remaining process parameters (see section \fBPROCESS
PARAMETERS\fP)\&. 
.IP 
.IP o 
\fBProcess(size_t mode, ProcessType type, std::string const &cmd = \(dq\&\(dq\&)\fP:
.br 
This constructor requires the specification of the object\(cq\&s
\fBIOMode\fP and \fIProcessType\fP, and it can be used to specify the (initial
part of a) command to execute from a \fIProcess\fP object\&.  Default values are
used for the remaining process parameters (see section \fBPROCESS
PARAMETERS\fP)\&.
.IP 
.IP o 
\fBProcess(size_t mode, ProcessType type, size_t timeLimit, 
std::string const &cmd = \(dq\&\(dq\&)\fP:
.br 
This constructor requires the specification of the object\(cq\&s
\fBIOMode\fP, \fIProcessType\fP, and child process time limit\&. The (initial part
of a) command to execute from a \fIProcess\fP object may optionally be
specified\&. The default process parameter is used for the sizes of the
internally used stream buffers (see section \fBPROCESS PARAMETERS\fP)\&.
.IP 
.IP o 
\fBProcess(IOMode mode, ProcessType type, size_t timeLimit, size_t
bufferSize, std::string const &cmd = \(dq\&\(dq\&)\fP:
.br 
This constructor requires the specification of the object\(cq\&s
\fBIOMode\fP, \fIProcessType\fP, child process time limit, and size of the
internally used stream buffers\&. The (initial part of a) command to execute
from a \fIProcess\fP object may optionally be specified\&. Note that this
constructor\(cq\&s \fImode\fP parameter does not accept a \fIsize_t\fP argument\&.
The class \fBProcess\fP does not offer copy or move constructors\&.
.PP 
.SH "OVERLOADED OPERATORS"

.PP 
.IP o 
\fBProcess &operator<<(Type value)\fP:
.br 
This operator inserts \fIvalue\fP into the child\(cq\&s standard
input stream\&. I\&.e\&., the child process reads \fIvalue\fP from its standard
input\&. A value of any type that can be inserted into an \fIostream\fP can be
inserted into a \fIProcess\fP object\&. Nothing happens if the member is used when
the child process has terminated\&. The behavior of this operator is undefined
unless \fIIOMode CIN\fP was specified\&.
.IP 
.IP o 
\fBProcess &operator>>(Type value)\fP:
.br 
This operator extracts \fIvalue\fP from the child\(cq\&s standard output
stream and optionally (if \fIIOMode MERGE_COUT_CERR\fP was specified) from the
child\(cq\&s error stream\&. I\&.e\&., \fIvalue\fP may be extracted from \fIProcess\fP
objects\&. A value of any type that can be extracted from an \fIistream\fP
can be extracted from a \fIProcess\fP object\&. Nothing happens if the member is
used when the child process has terminated\&. The behavior of this operator is
undefined unless \fIIOMode COUT\fP or \fIMERGE_COUT_CERR\fP was specified\&.
.IP 
.IP o 
\fBProcess &operator+=(std::string const &)\fP:
.br 
This operator adds the provided \fIstd::string\fP object to the currenly
defined command specification of a \fIProcess\fP object\&. The member
\fIoperator+=\fP does not add a separating blank space between the currently
stored command specification and the text to append\&.  It merely adds its
right\-hand side string to the command stored so far\&. It does not affect a
currently running child process\&.
.IP 
.IP o 
\fBint operator=(std::string const &cmd)\fP:
.br 
The \fIoperator=\fP member defines \fIcmd\fP as the  stored command in
a \fIProcess\fP object\&.  
.IP 
Before starting the child process a possibly active child process is first
stopped by calling \fIstop\fP\&. It returns \fIstop\fP\(cq\&s return value\&.
.IP 
.IP o 
\fBProcess &operator()(IOMode mode)\fP:
.br 
This operator changes the the \fIProcess\fP object\(cq\&s \fIIOMode\fP
parameter\&. A reference to the \fIProcess\fP object is returned, allowing
constructions like
.nf 

    process(Process::COUT) = \(dq\&/bin/cat\(dq\&; 
        
.fi 
to start a new child process with the specified \fIIOMode\fP\&. 
.IP 
.IP o 
\fBProcess &operator()(IOMode mode, ProcessType type)\fP:
.br 
This operator changes the \fIProcess\fP object\(cq\&s \fIIOMode\fP and
\fIProcessType\fP process parameters\&.
.IP 
.IP o 
\fBProcess &operator()(size_t mode, ProcessType type, size_t timeLimit)\fP:
.br 
This operator changes the \fIProcess\fP object\(cq\&s mentioned process
parameters, silently converting the \fIsize_t mode\fP to an \fIIOMode\fP
value\&. The currently specified default size of the stream buffers is kept
as\-is\&.
.IP 
.IP o 
\fBProcess &operator()(IOMode mode, ProcessType type, size_t timeLimit,
size_t bufferSize)\fP:
.br 
This operator changes all of the \fIProcess\fP object\(cq\&s process
parameters\&.
.IP 
.IP o 
\fBProcess &operator|(Process &lhs, Process &rhs)\fP:
.br 
This operator implements process \fIpiping\fP: information sent b
\fIlhs\fP to its standard output becomes the \fIrhs\fP\(cq\&s standard input\&. The
operator returns \fIrhs\fP\&. 
.IP 
This operator mimics the piping\-operator supported by most command\-shell
programs and should not be confused with the binary\-or operator\&. The operator
starts the \fIlhs\fP\(cq\&s  child process, but the \fIrhs\fP\(cq\&s child
process (and thus pipe processing) must explicitly be started\&.
.IP 
Since \fIoperator|\fP is left\-associative and \fIrhs\fP is returned piping can
be \fIchained\fP, allowing constructions like \fIp1 | p2 | p3\fP, where \fIp1, p2\fP
and \fIp3\fP are \fIProcess\fP objects\&. 
.IP 
The following idiom can be used to start the execution of a chain of
processes: \fI(p1 | p2 | p3)\&.start()\fP\&. Alternatively, the following two\-step
procedure can be used:
.nf 

    p1 | p2 | p3;
    p3\&.start();
        
.fi 

.IP 
If \fIp1\fP specifies \fIProcess::CIN\fP then this \fIIOMode\fP is forwared to
the final process of the chain of processes\&. It is not necessary to specify
\fIProcess::CIN\fP for \fIp3\fP\&. In fact, most \fIIOMode\fP flags of processes
passed to \fIoperator|\fP are ignored or modified\&. Acceptable \fIIOModes\fP are
\fIProcess::IGNORE_CERR\fP and \fIProcess::CERR\fP (accepted for all processes),
\fIProcess::CIN\fP (accepted for the first process of the chain), and
\fIProcess::COUT\fP (for the last process of the chain)\&. After connecting a
series of processes using \fIoperator|\fP all input and output (except for the
standard error streams) is handled through the last process: if
\fIProcess::CIN\fP is specified for the first process then this mode is
transferred to the last process, so information inserted into the last process
enters the pipe through the first process\(cq\&s standard input\&.
.IP 
The next example illustrates how input can be inserted into the first
process from a main process and sent to the standard output stream by the
final process:
.nf 
   
    using namespace std;
    using namespace FBB;

    Process p1(Process::CIN, \(dq\&/bin/cat\(dq\&); 
    Process p2(\(dq\&/bin/cat\(dq\&);
    Process p3(Process::STD, \(dq\&/bin/cat\(dq\&);

    p1 | p2 | p3;

    p3\&.start();

    p3 << cin\&.rdbuf() << eoi;
        
.fi 
Note that when specifying multiple commands using the piping operator
(\fI\(cq\&|\(cq\&\fP), traditionally \fIUSE_SHELL\fP had to be specified, as the traditional
piping operator is a shell\-feature\&. \fIProcess\(cq\&s operator|\fP handles I/O piping
itself, and thus avoids the additional shell process\&.
The default overloaded copy and move assignment operators are not
available\&.
.PP 
.SH "MEMBERS"

.PP 
.IP o 
\fBbool active()\fP:
.br 
This member returns \fItrue\fP if the child process is currently running
and \fIfalse\fP if not\&.
.IP 
.IP o 
\fBsize_t available()\fP:
.br 
This member returns immediately\&. Its return value indicates whether
any information can be obtained from the child process as value(s) from the
\fIenum ChildOutput\fP\&. \fINOTHING_AVAILABLE\fP is returned if no information is
ready for extraction\&. \fICHILD_COUT\fP is returned if information from the child
process\(cq\&s standard output stream is available; \fICHILD_CERR\fP is returned if
information from the child process\(cq\&s standard error stream is available;
\fICHILD_COUT | CHILD_CERR\fP is returned if information from both the standard
output and standard error streams is available\&. The \fIbit_and\fP operator,
returning a \fIbool\fP value, can be used to determine which stream has any
pending information\&. E\&.g\&.,
.nf 

    if (process\&.available() & Process::CHILD_COUT)
        cout << \(dq\&Process has child standard output available\(dq\&;
        
.fi 

.IP 
.IP o 
\fBsize_t bufSize() const\fP:
.br 
This member returns the default size of the stream buffers that are
used for communication with child processes\&. If called while a child process
is actually running, then the value returned by this member may differ from
the value that was actually used when starting the child process, as the
default value may be altered by a function call operator just before starting
the child process\&.
.IP 
.IP o 
\fBstd::istream &cerr()\fP:
.br 
This member should be avoided\&. Use \fIchildErrStream\fP instead\&.
.br 

.IP 
.IP o 
\fBstd::istream &childErrStream()\fP:
.br 
If \fIProcess::CERR\fP was specified then this member interfaces
to the child\(cq\&s standard error stream\&. By extracting the information from
\fIchildErrStream\fP the parent process retrieves the information sent by its
child process to its standard error stream\&.
.IP 
.IP o 
\fBstd::istream &childOutStream()\fP:
.br 
If \fIProcess::COUT\fP or
\fIProcess::MERGE_COUT_CERR\fP was specified then this member interfaces
to the child\(cq\&s standard output stream\&. By extracting the information from
\fIchildOutStream\fP the parent process retrieves the information sent by its
child process to its standard output stream\&. Alternatively, this information
may directly be extracted from the \fIProcess\fP object itself, but this member
does not require the use of a \fIstatic_cast\fP to disambiguate the intended
stream buffer in statements like
.nf 

    cout << process\&.childOutStream()\&.rdbbuf()
        
.fi 

.IP 
.IP o 
\fBvoid close()\fP:
.br 
This member closes the child\(cq\&s input stream\&. In situations where the
child continuously reads information from its standard input stream this
member can be used to inform the child process that input has terminated\&. This
member should only be used when \fIIOMode CIN\fP was specified for the currently
running child process; otherwise its behavior is undefined\&. Alternatively, the
\fIeoi\fP member or manipulator may be used\&.
.IP 
.IP o 
\fBvoid eoi()\fP:
.br 
This member closes the child\(cq\&s input stream, and then calls
\fIwaitForChild\fP to wait for the child process to end\&. In situations where the
child continuously reads information from its standard input stream this
member can be used to inform the child process that input has terminated\&. This
member should only be used when \fIIOMode CIN\fP was specified for the currently
running child process; otherwise its behavior is undefined\&. Alternatively, the
\fIclose\fP member or \fIeoi\fP manipulator may be used\&.
.IP 
.IP o 
\fBstd::istream &errStream()\fP:
.br 
This member may be used to extract information written by the child
process to its standard error stream\&.  This member should only be used when
\fIIOMode CERR\fP was specified for the currently running child process;
otherwise its behavior is undefined\&.
.br 

.IP 
.IP o 
\fBIOMode ioMode() const\fP:
.br 
This member returns the default \fIIOMode\fP\&. If called while a child
process is actually running, then the value returned by this member may differ
from the value that was actually used when starting the child process, as the
default value may be altered by a function call operator just before starting
the child process\&.
.IP 
.IP o 
\fBProcessType processType() const\fP:
.br 
This member returns the default \fIProcessType\fP of child proceses\&. If
called while a child process is actually running, then the value returned by
this member may differ from the value that was actually used when starting the
child process, as the default value may be altered by a function call operator
just before starting the child process\&.
.IP 
.IP o 
\fBsize_t timeLimit() const\fP:
.br 
This member returns the default time limit (in seconds) of child
processes\&. A return value of zero indicates that no time limit is enforced\&. If
called while a child process is actually running, then the value returned by
this member may differ from the value that was actually used when starting the
child process, as the default value may be altered by a function call operator
just before starting the child process\&.
.IP 
.IP o 
\fBvoid setBufSize(size_t bufSize)\fP:
.br 
This member changes the default stream buffer size that is used for
communication with child processes\&. A zero byte buffer size is silently
changed into one\&. The new default value will be used when starting the next
child process\&.
.IP 
.IP o 
\fBvoid setCommand(std::string const &cmd)\fP:
.br 
The \fIsetCommand\fP member (re)defines the (initial part of a) child
process command specification\&.
.IP 
This member does not actually start the child process, and \fIoperator+=\fP
may be used to append additional text to the command specification\&. Also, this
member may be used when a child process is currently active: its use does not
affect a currently running child process\&.
.IP 
.IP o 
\fBvoid setIOMode(iomode mode)\fP:
.br 
This member changes the default \fIIOMode\fP\&. The new default value will
be used when starting the next child process\&.
.IP 
.IP o 
\fBvoid setProcessType(ProcessType type)\fP:
.br 
This member changes the default \fIProcessType\fP\&. The new default value
will be used when starting the next child process\&.
.IP 
.IP o 
\fBvoid setTimeLimit(size_t timeLimit)\fP:
.br 
This member changes the default execution time limit (in seconds)\&. No
time limit will be imposed upon child processes if \fItimeLimit 0\fP is
specified\&. The new default value will be used when starting the next child
process\&.
.IP 
.IP o 
\fBvoid start()\fP:
.br 
The currently specified command is started using the \fIProcess\fP
object\(cq\&s process parameters\&. 
.IP 
Having specified a command to start, the first white\-space delimited
element of the specified command is used as the name of the program to
start\&. If the program should be called through \fBsh\fP(1), the \fIUSE_SHELL
ProcessType\fP or a \fIsystem\fP member should be used\&.
.IP 
If a child process does not terminate by itself, then it is terminated
when it has run for its alloted time; when the \fIProcess\fP object\(cq\&s \fIstart\fP
or \fIstop\fP members are called; when the object\(cq\&s assignment operator is used;
or when the object goes out of scope\&.
.IP 
.IP o 
\fBvoid start(IOMode mode)\fP:
.br 
The currently specified command is started using the specified
\fIIOMode\fP, but otherwise using the currently configured \fIProcess\fP object\(cq\&s
process parameters\&. The specified \fIIOMode\fP is only used for the child
process that is started by this member\&.
.IP 
.IP o 
\fBvoid start(IOMode mode, ProcessType type)\fP:
.br 
The currently specified command is started using the specified
\fIIOMode\fP and \fIProcessType\fP, but otherwise using the currently configured
\fIProcess\fP object\(cq\&s process parameters\&. The specified process parameter
values are only used for the child process that is started by this member\&.
.IP 
.IP o 
\fBvoid start(size_t mode, Program program, size_t timeLimit)\fP:
.br 
The currently specified command is started using the specified
\fIIOMode\fP, \fIProcessType\fP, and time limit (silently converting the \fIsize_t
mode\fP to an \fIIOMode\fP value), and using the currently configured \fIProcess\fP
object\(cq\&s stream buffer size parameter\&. The specified process parameter values
are only used for the child process that is started by this member\&.
.IP 
.IP o 
\fBvoid start(IOMode mode, Program program, size_t timeLimit, size_t
bufferSize)\fP:
.br 
The currently specified command is started using the specified process
parameters\&. The specified parameter values are only used for the child process
that is started by this member\&.
.IP 
.IP o 
\fBvoid showMode(char const *lab) const\fP:
.br 
This member displays the label \fIlab\fP, followed by the current
process ID, followed by the child process\(cq\&s process ID, followed by a textual
representation of the currently active \fIIOMode\fP\&.
.IP 
.IP o 
\fBstd::string const &str() const\fP:
.br 
This member returns the contents of the current child process command
specification\&. It shows the command as it will be (or has been) executed by
\fIstart\fP, \fIsystem\fP or the assignment operator\&. 
.IP 
.IP o 
\fBvoid system()\fP:
.br 
This member executes the currently stored command as a command to
\fBsh\fP(1)\&.  When using \fIsystem\fP redirections can be included in the command
itself (this renders the redirected streams implied by the current \fBIOMode\fP)
useless\&. The currently set process parameters are used when \fBsh\fP(1) is
executed\&.
.IP 
.IP o 
\fBvoid system(IOMode mode)\fP:
.br 
This member executes the currently stored command as a command to
\fBsh\fP(1) (cf\&. \fIsystem\fP above) using the specified \fIIOMode\fP rather than
the current default \fIIOMode\fP setting\&.
.IP 
.IP o 
\fBvoid system(IOMode mode, size_t timeLimit)\fP:
.br 
This member executes the currently stored command as a command to
\fBsh\fP(1) (cf\&. \fIsystem\fP above) using the specified \fIIOMode\fP and time
limit\&.
.IP 
.IP o 
\fBvoid system(IOMode mode, size_t timeLimit, size_t bufSize)\fP:
.br 
This member executes the currently stored command as a command to
\fBsh\fP(1) (cf\&. \fIsystem\fP above) using the specified \fIIOMode\fP, time
limit, and stream buffer size values\&.
.IP 
.IP o 
\fBint stop()\fP:
.br 
This member terminates a currently active child process\&. The child
process is twice sent a \fISIG_TERM\fP signal, followed by a \fISIG_KILL\fP
signal\&. This member returns the exit\-value of the child process that was
stopped\&. Its operation and return value are undefined if called without a
running child process\&.
.IP 
Following \fIstop\fP a new command may be called using \fIstart, system\fP or
the assignment operator (see earlier)\&. Those members first calls \fIstop\fP\&.
When the intention is to start another child process, then there\(cq\&s no need to
call \fIstop\fP explicitly\&. Also, \fIstop\fP is called when the \fIProcess\fP object
goes out of scope\&.
.IP 
.IP o 
\fBint waitForChild()\fP:
.br 
This member is inherited from the class \fIFBB::Fork\fP\&. It waits for a
child process to end\&. It is called to prevent premature termination of a
child process before calling \fIstop\fP\&. It is not always necessary to call
\fIwaitForChild\fP\&. E\&.g\&., when a process writes to its standard output stream
and all output has been read then the child process can be stopped without
calling \fIwaitForChild\fP\&.

.PP 
.SH "MANIPULATOR"
.IP o 
\fBFBB::eoi\fP:
.br 
This manipulator may be inserted into a \fIProcess\fP object for which
\fIIOMode CIN\fP was specified\&. It closes the child\(cq\&s input stream, and then
calls \fIwaitForChild\fP to wait for the child process to end\&. In situations
where the child continuously reads information from its standard input stream
this member can be used to inform the child process that input has
terminated\&. Alternatively, \fIProcess\fP object\(cq\&s \fIclose\fP or \fIeoi\fP members
may be used\&.

.PP 
.SH "EXAMPLES"

.PP 
The first example shows how a program only producing output can be
called\&. Its child process simply is \fI/bin/ls\fP:
.nf 

int main()
{
    Process process(Process::COUT, \(dq\&/bin/ls \-Fla\(dq\&);

    process\&.start();
    cout << process\&.childOutStream()\&.rdbuf();
}

.fi 

.PP 
The next example shows how a child program can be given a limited amount
of execution time: lines entered at the keyboard are echoed to the standard
output stream for at most 5 seconds:
.nf 

int main()
{
    Process process(Process::CIN | Process::COUT, \(dq\&/bin/cat\(dq\&);
    process\&.setTimeLimit(5);

    process\&.start();

    while (true)
    {
        cout << \(dq\&? \(dq\&;
        string line;
        if (not getline(cin, line))
            return 0;

        process << line << endl;        // to /bin/cat
        line\&.clear();

        if (not getline(process, line))    // from /bin/cat
            break;

        cout << \(dq\&Received: \(dq\& << line << endl;
    }

    cout << \(dq\&/bin/cat time limit of 5 seconds reached: child process ended\en\(dq\&;
}

.fi 

.PP 
The final example shows how multi threading can be used to access the
child program\(cq\&s standard output and standard error streams through the
\fIProcess\fP object:
.nf 

void collect(ostream *outStream, streambuf *rdbuf)
{
    *outStream << rdbuf << flush;
}

int main()
{
    string cmd(getcwd(0, 0));
    cmd += \(dq\&/cincoutcerr\(dq\&;

    Process all(Process::ALL, cmd);

    all\&.start();

    thread outThread(collect, &cout, all\&.childOutStream()\&.rdbuf());
    thread errThread(collect, &cerr, all\&.childErrStream()\&.rdbuf());

    all << cin\&.rdbuf() << eoi;

    outThread\&.join();
    errThread\&.join();
}

.fi 

.PP 
Additional examples are found in the distribution\(cq\&s
\fIbobcat/process/driver\fP directory\&. 
.PP 
.SH "FILES"
\fIbobcat/process\fP \- defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7), \fBexecle\fP(3), \fBfork\fP(3bobcat), \fBiostream\fP(3fork),
\fBsh\fP(1)
.PP 
.SH "BUGS"
With the release of Bobcat 1\&.21\&.1 the class \fIProcess\fP was completely
rewritten\&. The new implementation, however, should not affect existing
programs other than that \fIProcess\fP will no longer impose a limited
time\-to\-live upon child processes\&. The interface was enlarged, but this should
not affect existing programs\&. The internal organization of the \fIProcess\fP
class \fIhas\fP changed though, requiring recompilation of sources defining
\fIProcess\fP class type objects and linking dynamically to the \fIBobcat\fP
library\&. 
.PP 
With the release of Bobcat 2\&.11\&.0 another major modification of
\fIProcess\fP was realized\&. Although \fIProcess\fP\(cq\&s internal organization was
again modified this does not affect exeisting programs using \fIProcess\fP
objects\&. No recompilation of existing sources using \fIProcess\fP is required\&.
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_3\&.23\&.01\-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1\-dev_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\(cq\&s Own Base Classes And Templates\(cq\&\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
GNU General Public License (GPL)\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 

.TH "FBB::ServerSocket" "3bobcat" "2005\-2014" "libbobcat\-dev_3\&.23\&.01\-x\&.tar\&.gz" "Server Socket"

.PP 
.SH "NAME"
FBB::ServerSocket \- Server socket accepting Internet connection requests
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/serversocket>\fP
.br 
Linking option: \fI\-lbobcat\fP 
.PP 
.SH "DESCRIPTION"
An \fBFBB::ServerSocket\fP may be constructed to listen for connection
requests from the Internet or from the local host\&. Connection requests may be
accepted in either \fIblocking\fP or \fInon\-blocking\fP modes\&. When a connection
is accepted a socket is returned which may be used to read information from or
write information to the client that requested the connection\&. The socket that
is made available is a \fIfile descriptor\fP which may be used to initialize a
\fBstd::istream\fP and/or \fBstd::ostream\fP\&. The \fBstd::istream\fP is used to read
information from the client process; the \fBstd::ostream\fP is used to send
information to the client process\&.  Since a socket may be considered a \fIfile
descriptor\fP the avaiable \fBFBB::IFdStream\fP, \fBFBB::IFdStreamBuf\fP,
\fBFBB::OFdStream\fP, and \fBFBB::OFdStreamBuf\fP classes may be used profitably
here\&. Note that having available a socket does not mean that this defines the
communication protocol\&. It is (still) the responsibility of the programmer to
comply with an existing protocol or to implement a tailor\-made protocol\&. The
latter situation implies that the sequence of input\- and output operations is
defined by the programmer\&.
.PP 
.SH "NAMESPACE"
\fBFBB\fP
.br 
All constructors, members, operators and manipulators, mentioned in this
man\-page, are defined in the namespace \fBFBB\fP\&.
.PP 
.SH "INHERITS FROM"
\fBFBB::SocketBase\fP
.PP 
.SH "CONSTRUCTOR"
.IP o 
\fBServerSocket(size_t  port)\fP:
.br 
This constructor initializes an \fBFBB::ServerSocket\fP object, which
will listen for connections at the specified port\&.  The construction of the
socket does not mean that the \fBFBB::ServerSocket\fP object is actually
listening for connections\&. To start listening, the member \fBlisten()\fP should
be used\&.
The copy constructor is not available\&.
.PP 
.SH "MEMBER FUNCTIONS"
All members of \fBFBB::SocketBase\fP (and thus of \fBFBB::InetAddress\fP) are
available, as \fBFBB::ServerSocket\fP inherits from \fBFBB::SocketBase\fP\&.
.IP o 
\fBvoid listen(size_t backlog = 5, bool blocking = true)\fP:
.br 
The \fBlisten()\fP member defines the way the \fBFBB::ServerSocket\fP will
listen for clients requesting a connection\&.  It can be used only once with a
\fBFBB::ServerSocket\fP\&. An \fBFBB::Exception\fP object is thrown if listening fails,
if the constructor could not create a socket, or if the \fBSocketBase\fP base
class could not properly be constructed\&.
.IP 
The \fBlisten()\fP member\(cq\&s \fIbacklog\fP parameter defines the size of the
\fBFBB::ServerSocket\fP\(cq\&s internal queue in which connection requests may be
stored waiting for their turn to be serviced\&. When \fIbacklog\fP requests are
waiting and another request arrives, then that request is lost\&. 
.IP 
The member\(cq\&s second parameter, \fIblocking\fP, is used to control the
blocking mode\&. By default, blocking is used, and \fIlisten()\fP will wait until
a connection is established\&. This is ok in situations where clients connect
infrquently and for relatively short time intervals\&. Otherwise, in more
complex programs, an \fBFBB::Selector\fP object can be used to sense input on
the server socket and/or on various client sockets\&.
.IP 
.IP o 
\fBSocketBase accept()\fP:
.br 
The \fBaccept()\fP member returns an \fBFBB::SocketBase\fP object
containing information about the client whose connection request was
accepted\&. The \fBFBB::SocketBase\fP object\(cq\&s socket value may be used to
initialize streams that can be used to communicate with the client\&. In more
complex programs the \fBFBB::SocketBase\fP could be passed to a class derived
from \fBFBB::Fork\fP, handling the communication with the child as a separate
(child) process\&. 

.PP 
.SH "EXAMPLE"
See also the \fBclientsocket\fP(3bobcat) example\&.
.nf 

    #include <iostream>
    #include <bobcat/serversocket>
    #include <bobcat/ifdstream>
    #include <bobcat/ofdstream>
    
    #include <bobcat/a2x>
    
    using namespace std;
    using namespace FBB;
    
    int main(int argc, char **argv)
    try
    {
        if (argc == 1)
        {
            cerr << \(dq\&Provide server port number\en\(dq\&;
            return 1;
        }
    
        size_t portnr = A2x(argv[1]);
    
        ServerSocket server(portnr);
    
        cerr << \(dq\&server listens on port \(dq\& << argv[1] << endl;
    
        cerr << \(dq\&serversocket returns:\en\(dq\& <<
            \(dq\&address = \(dq\& << server\&.dottedDecimalAddress() << \(dq\&\en\(dq\&
            \(dq\&port    = \(dq\& << server\&.port() << endl;
    
        int fd = server\&.socket();       // open the socket\(cq\&s descriptor
    
        cout << \(dq\&File descriptor of the socket is \(dq\& << fd << \(dq\&\en\(dq\&
            \(dq\&The server terminates when it receives a \(dq\&
                                        \(dq\&single `q\(cq\& on a line\en\(dq\&
            \(dq\&A connection is terminated when no input \(dq\&
                                        \(dq\&is received anymore\&.\en\(dq\&
            \(dq\&Then another connection is possible\(dq\& << endl;
    
        server\&.listen();                // listen in blocking mode
    
        while (true)
        {
            SocketBase fdb = server\&.accept();
            int fd = fdb\&.socket();
    
            cerr << \(dq\&Client FD = \(dq\& << fd << \(dq\&, \(dq\& << endl <<
                    \(dq\&address = \(dq\& << fdb\&.dottedDecimalAddress() << \(dq\&, \(dq\& << 
                    endl <<
                    \(dq\&communication through port \(dq\& << fdb\&.port() << endl;
    
            IFdStream in(fd);           // stream to read from client
            OFdStream out(fd);          // stream to write to client
            string cmd;
            
            while (getline(in, cmd))
            {
                cout << \(dq\&Got: \(dq\& << cmd << endl;
                out << \(dq\&Got: \(dq\& << cmd << \(dq\&\er\(dq\& << endl;
    
                if (cmd[0] == \(cq\&q\(cq\&)
                    return 0;
            }
            cout << \(dq\&Ready for another connection\en\(dq\&;
        }
    }
    catch (Exception const &err)
    {
        cerr <<
            err\&.what() << endl <<
            \(dq\&Server socket on port \(dq\& << argv[1] << 
            \(dq\& can\(cq\&t be opened\(dq\& << endl;
        return \-1;
    }        
        
.fi 

.PP 
.SH "FILES"
\fIbobcat/serversocket\fP \- defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7), \fBclientsocket\fP(3bobcat), \fBfork\fP(3bobcat),
\fBifdstream\fP(3bobcat), \fBifdstreambuf\fP(3bobcat), \fBinetaddress\fP(3bobcat),
\fBlocalserversocket\fP(3bobcat), \fBofdstream\fP(3bobcat),
\fBofdstream\fP(3bobcat), \fBselect\fP(2), \fBselector\fP(3bobcat),
\fBsocketbase\fP(3bobcat)
.PP 
.SH "BUGS"
None Reported\&.
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_3\&.23\&.01\-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1\-dev_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\(cq\&s Own Base Classes And Templates\(cq\&\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
GNU General Public License (GPL)\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 

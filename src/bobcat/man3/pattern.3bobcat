.TH "FBB::Pattern" "3bobcat" "2005\-2014" "libbobcat\-dev_3\&.23\&.01\-x\&.tar\&.gz" "Pattern matcher"

.PP 
.SH "NAME"
FBB::Pattern \- Performs RE pattern matching
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/pattern>\fP
.br 
Linking option: \fI\-lbobcat\fP 
.PP 
.SH "DESCRIPTION"
\fBPattern\fP objects may be used for Regular Expression (RE) pattern
matching\&. The class is a wrapper around the \fBregcomp\fP(3) family of
functions\&. By default it uses `extended regular expressions\(cq\&, requiring you to
escape multipliers and bounding\-characters when they should be interpreted as
ordinary characters (i\&.e\&., \fI*, +, ?, ^, $, |, (, ), [, ], {, }\fP should be
escaped when used as literal characters)\&.
.PP 
The \fBPattern\fP class supports the use of the following (Perl\-like)
special escape sequences: 
.br 
\eb \- indicating a word\-boundary 
.br 
\ed \- indicating a digit (\fI[[:digit:]]\fP) character 
.br 
\es \- indicating a white\-space (\fI[:space:]\fP) character 
.br 
\ew \- indicating a word (\fI[:alnum:]\fP) character
.PP 
The corresponding capitals (e\&.g\&., \fB\eW\fP) define the complementary
character sets\&. The capitalized character set shorthands are not expanded
inside explicit character\-classes (i\&.e\&., \fI[ \&.\&.\&. ]\fP constructions)\&. So
\fI[\eW]\fP represents a set of two characters: \fI\e\fP and \fIW\fP\&.
.PP 
As the backslash (\fI\e\fP) is treated as a special character it should be
handled carefully\&. \fBPattern\fP converts the escape sequences \fI\ed \es \ew\fP (and
outside of explicit character classes the sequences \fI\eD \eS \eW\fP) to their
respective character classes\&. All other escape sequences are kept as is, and
the resulting regular expression is offered to the pattern matching
compilation function \fBregcomp\fP(3)\&. This function will again interpret
escape sequences\&. Consequently some care should be exercised when defining
patterns containing escape sequences\&. Here are the rules:
.IP o 
Special escape sequences (like \fI\ed\fP) are converted to character
classes\&. E\&.g\&.,
.nf 

    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    Specify:    Converts to:    regcomp uses:      Matches:
    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    \ed          [[:digit:]]     [[:digit:]]        3
    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
        
.fi 
.IP o 
Ordinary escape sequences (like \fI\ex\fP) are kept as\-is\&. E\&.g\&.,
.nf 

    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    Specify:    Converts to:    regcomp uses:      Matches:
    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    \ex          \ex              x                  x
    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
        
.fi 
.IP o 
To specify a literal escape sequence, it must be written twice\&. E\&.g\&.,
.nf 

    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    Specify:    Converts to:    regcomp uses:      Matches:
    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    \e\ex         \e\ex             \ex                 \ex
    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
        
.fi 

.PP 
.SH "NAMESPACE"
\fBFBB\fP
.br 
All constructors, members, operators and manipulators, mentioned in this
man\-page, are defined in the namespace \fBFBB\fP\&.
.PP 
.SH "INHERITS FROM"
\-
.PP 
.SH "TYPEDEF"
.IP o 
\fBPattern::Position\fP:
.br 
A nested type representing the offsets of the first character and
the offset beyond the last character of the matched text or indexed
subexpression, defined as \fIstd::pair<std::string::size_type,
std::string::size_type>\fP\&.

.PP 
.SH "CONSTRUCTORS"
.IP o 
\fBPattern()\fP:
.br 
The default constructor defines no pattern, but is available as a
placeholder for, e\&.g\&., containers requiring default constructors\&. A
\fBPattern\fP object thus constructed cannot be used to match patterns, but
can be the \fIlvalue\fP in assignments where another \fBPattern\fP object is
the \fIrvalue\fP\&. However, it can receive a pattern using the member
\fBsetPattern()\fP (see below)\&. An \fBFBB::Exception\fP object is thrown if the object
could not be constructed\&.
.IP o 
\fBPattern(std::string const &pattern, 
bool caseSensitive = true, 
size_t nSub = 10,
int options = REG_EXTENDED | REG_NEWLINE)\fP:
.br 
This constructor compiles \fIpattern\fP, preparing the \fBPattern\fP
object for pattern matches\&. The second parameter determines whether case
sensitive matching will be used (the default) or not\&. Subexpressions are
defined by parentheses pairs\&. Each matching pair defines a subexpression,
where the order\-number of their opening parentheses determines the
subexpression\(cq\&s index\&. By default at most 10 subexpressions are recognized\&.
The \fIoptions\fP flags may be:
.IP 
REG_EXTENDED: 
.br 
Use POSIX Extended Regular Expression syntax when
interpreting regex\&.  If not set, POSIX Basic Regular
Expression syntax is used\&.
.IP 
REG_NOSUB: 
.br 
Support for substring addressing of matches is  not
required\&.   The  nmatch  and  pmatch  parameters to
regexec are ignored if the pattern buffer  supplied
was compiled with this flag set\&.
.IP 
REG_NEWLINE: 
.br 
Match\-any\-character  operators  don\(cq\&t  match a newline\&.
.IP 
A non\-matching list ([^\&.\&.\&.])  not containing a newline
does not match a newline\&.
.IP 
Match\-beginning\-of\-line operator (^) matches the empty
string immediately after a newline, regardless of whether
eflags, the execution flags of regexec, contains
REG_NOTBOL\&.
.IP 
Match\-end\-of\-line operator ($)  matches  the  empty
string  immediately before a newline, regardless of
whether eflags contains REG_NOTEOL\&.

.PP 
\fIPattern\fP offers  copy and move constructors\&.
.PP 
.SH "MEMBER FUNCTIONS"
All members of \fBstd::ostringstream\fP and \fB  std::exception\fP are
available, as \fBPattern\fP inherits from these classes\&.
.IP o 
\fBstd::string before() const\fP:
.br 
Following a successful match, \fBbefore()\fP returns the text before the
matched text\&.
.IP o 
\fBstd::string beyond() const\fP:
.br 
Following a successful match, \fBbeyond()\fP returns the text beyond the
matched text\&.
.IP o 
\fBsize_t end() const\fP:
.br 
Returns the number of matched elements (text and
subexpressions)\&. \fBend()\fP is the lowest index value for which \fBposition()\fP
returns two \fIstd::string::npos\fP values (see the \fBposition()\fP member
function, below)\&.
.IP o 
\fBvoid match(std::string const &text, int options = 0)\fP:
.br 
Match a string with a pattern\&.  If the text could not be matched, an
\fBException\fP exception is thrown , using \fBPattern::match()\fP as its prefix\-text\&.
.IP 
Options may be:
.IP 
REG_NOTBOL: 
.br 
The match\-beginning\-of\-line operator always fails to match
(but see the compilation flag REG_NEWLINE above) This flag
may be used when different portions of a string are passed
to regexec and the beginning of the string should not be
interpreted as the beginning of the line\&.
.IP 
REG_NOTEOL: 
.br 
The  match\-end\-of\-line  operator  always  fails  to
match  (but  see  the  compilation flag REG_NEWLINE)
.IP o 
\fBstd::string matched() const\fP:
.br 
Following a successful match, this function returns the matched text\&.
.IP o 
\fBstd::string const &pattern() const\fP:
.br 
This member function returns the pattern that is offered to
\fBregcomp\fP(3)\&. It returns the contents of a \fIstatic\fP string that is
overwritten at each construction of a \fBPattern\fP object and at each call of
the \fIsetPattern()\fP member function\&.
.IP o 
\fBPattern::Position position(size_t index) const\fP:
.br 
With \fIindex == 0\fP the fully matched text is returned (identical to
\fImatched()\fP)\&. Other index values return the corresponding
subexpressions\&. \fBstd::string::npos, std::string::npos\fP is returned if index
is at least \fBend()\fP (which may happen at index value 0)\&.
.IP o 
\fBvoid setPattern(std::string const &pattern, 
bool caseSensitive = true, 
size_t nSub = 10,
int options = REG_EXTENDED | REG_NEWLINE)\fP:
.br 
This member function installs a new  compiled \fIpattern\fP in its
\fBPattern\fP object\&. This member\(cq\&s parameters are identical to the second
constructor\(cq\&s parameters\&. Refer to that constructor for details about the
parameters\&. Like the constructor, an \fBFBB::Exception\fP exception is thrown if the
new pattern could not be compiled\&.
.IP o 
\fBvoid swap(Pattern &other)\fP:
.br 
The contents of the current object and the \fIother\fP object are
swapped\&. 

.PP 
.SH "OVERLOADED OPERATORS"

.PP 
.IP o 
\fBPattern &operator=(Pattern &other)\fP:
.br 
A standard overloaded assignment operator\&.
.IP o 
\fBstd::string operator[](size_t index) const\fP:
.br 
Returns the matched text (for index 0) or the text of a
subexpression\&. An empty string is returned for index values which are at least
\fBend()\fP\&.
.IP o 
\fBPattern &operator<<(int matchOptions)\fP:
.br 
Defines match\-options to be used with the following overloaded
operator\&. 
.IP o 
\fBbool operator<<(std::string const &text)\fP:
.br 
Performs a \fBmatch(text, matchOptions)\fP call, catching any exception
that might be thrown\&. If no \fImatchOptions\fP were set using the above
overloaded operator, none are used\&. The options set this way are not `sticky\(cq\&:
when necessary, they have to be re\-inserted before each new pattern
matching\&. The function returns \fBtrue\fP if the matching was successful,
\fBfalse\fP otherwise\&.

.PP 
.SH "EXAMPLE"
.nf 
/*
                              driver\&.cc
*/

#include \(dq\&driver\&.h\(dq\&

#include <bobcat/pattern>

using namespace std;
using namespace FBB;


void showSubstr(string const &str)
{
    static int 
        count = 1;

    cout << \(dq\&String \(dq\& << count++ << \(dq\& is \(cq\&\(dq\& << str << \(dq\&\(cq\&\en\(dq\&;
}


int main(int argc, char **argv)
{
    {
        Pattern one(\(dq\&one\(dq\&);
        Pattern two(one);
        Pattern three(\(dq\&a\(dq\&);
        Pattern four;
        three = two;
    }

    try 
    {
        Pattern pattern(\(dq\&aap|noot|mies\(dq\&);

        {
            Pattern extra(Pattern(pattern));
        }
    
        if (pattern << \(dq\&noot\(dq\&)
            cout << \(dq\&noot matches\en\(dq\&;
        else
            cout << \(dq\&: noot doesn\(cq\&t match\en\(dq\&;
    }
    catch (exception const &e)
    {
        cout << e\&.what() << \(dq\&: compilation failed\(dq\& << endl;
    }
        
    string pat = \(dq\&\e\ed+\(dq\&;

    while (true)
    {
        cout << \(dq\&Pattern: \(cq\&\(dq\& << pat << \(dq\&\(cq\&\en\(dq\&;

        try
        {
            Pattern patt(pat, argc == 1);   // case sensitive by default,
                                            // any arg for case insensitive

            cout << \(dq\&Compiled pattern: \(dq\& << patt\&.pattern() << endl;

            Pattern pattern;
            pattern = patt;                 // assignment operator

            while (true)
            {
                cout << \(dq\&string to match : \(dq\&;

                string st;
                getline(cin, st);
                if (st == \(dq\&\(dq\&)
                    break;
                cout << \(dq\&String: \(cq\&\(dq\& << st << \(dq\&\(cq\&\en\(dq\&;
                try
                {
                    pattern\&.match(st);

                    Pattern p3(pattern);
        
                    cout << \(dq\&before:  \(dq\& << p3\&.before() << \(dq\&\en\(dq\&
                            \(dq\&matched: \(dq\& << p3\&.matched() << \(dq\&\en\(dq\&  
                            \(dq\&beyond:  \(dq\& << pattern\&.beyond() << \(dq\&\en\(dq\&  
                            \(dq\&end() = \(dq\& << pattern\&.end() << endl;
        
                    for (size_t idx = 0; idx < pattern\&.end(); ++idx)
                    {
                        string str = pattern[idx];
            
                        if (str == \(dq\&\(dq\&)
                            cout << \(dq\&part \(dq\& << idx << \(dq\& not present\en\(dq\&;
                        else
                        {
                            Pattern::Position pos = pattern\&.position(idx);
        
                            cout << \(dq\&part \(dq\& << idx << \(dq\&: \(cq\&\(dq\& << str << \(dq\&\(cq\& (\(dq\& <<
                                    pos\&.first << \(dq\&\-\(dq\& << pos\&.second << \(dq\&)\en\(dq\&;
                        }
                    }
                }
                catch (exception const &e)
                {
                    cout << e\&.what() << \(dq\&: \(dq\& << st << \(dq\& doesn\(cq\&t match\(dq\& << endl;
                    continue;
                }
            }
        }            
        catch (exception const &e)
        {
            cout << e\&.what() << \(dq\&: compilation failed\(dq\& << endl;
        }

        cout << \(dq\&New pattern: \(dq\&;

        if (!getline(cin, pat) || !pat\&.length())
            return 0;
    }
}






.fi 

.PP 
.SH "FILES"
\fIbobcat/pattern\fP \- defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7), \fBregcomp\fP(3), \fBregex\fP(3), \fBregex\fP(7)
.PP 
.SH "BUGS"
Using \fIPattern\fP objects as static data members of classes (or as global
objects) is potentially dangerous\&. If the object files defining these static
data members are stored in a dynamic library they may not be initialized
properly or timely, and their eventual destruction may result in a
segmentation fault\&. This is a well\-known problem with static data, see, e\&.g\&.,
\fIhttp://www\&.parashift\&.com/c++\-faq\-lite/ctors\&.html#faq\-10\&.15\fP\&. In situations
like this prefer the use of a (shared, unique) pointer to a \fIPattern\fP,
initialzing the pointer when, e\&.g\&., first used\&.
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_3\&.23\&.01\-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1\-dev_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\(cq\&s Own Base Classes And Templates\(cq\&\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
GNU General Public License (GPL)\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 

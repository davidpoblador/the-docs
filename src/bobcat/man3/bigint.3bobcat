.TH "FBB::BigInt" "3bobcat" "2005\-2014" "libbobcat\-dev_3\&.23\&.01\-x\&.tar\&.gz" "Big Integers"

.PP 
.SH "NAME"
FBB::BigInt \- Arithmetic on Integers of Unlimited Size
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/bigint>\fP
.br 
Linking option: \fI\-lbobcat \-lcrypto\fP 
.PP 
.SH "DESCRIPTION"

.PP 
This class is defined as a wrapper class around the \fIopenSSL\fP \fIBN\fP series
of functions, offering members to perform arithmetic on integral values of
unlimited sizes\&. Members are offered to generate primes and to perform all
kinds of common arithmetic operations on \fIBigInt\fP objects\&. Also, conversions
to characters and standard numerical value types are offered\&.
.PP 
Below, the phrase \fIthe object\fP may also refer to the object\(cq\&s value\&. The
context in which this occurs will make clear that the object\(cq\&s value rather
than the object as\-is is referred to\&.
.PP 
Various constructors accept \fIBIGNUM\fP arguments\&. Type \fIBIGNUM\fP is the type
containing an integer of unlimited precision as defined by OpenSSL\&.
.PP 
Signs of \fIBigInt\fP are handled in a special way\&. Whether a \fIBigInt\fP is
negative or positive is determined by its sign\-flag, and not by a sign bit as
is the case with \fIint\fP typed values\&. Since \fIBigInt\fP values have unlimited
precision shifting values to the left won\(cq\&t change their signs\&.
.PP 
Operators return either a reference to the current (modified) object or return
a \fIBigInt\fP object containing the computed value\&. The rule followed here was
to implement the operators analogously to the way the operators work on
\fIint\fP type values and variables\&. E\&.g\&., \fIoperator+()\fP returns a \fIBigInt\fP
value whereas \fIoperator+=()\fP returns a \fIBigInt &\fP reference\&.
.PP 
All members modifying their objects return a reference to the current
(modified) object\&. All members not modifying the current object return a
\fIBigInt\fP object\&. If both members exists performing the same
functionality the name of the member returning a \fIBigInt\fP object ends
in a \fIc\fP (const) (e\&.g\&., \fIaddMod\fP and \fIaddModc\fP)\&.
.PP 
Almost all operators, members and constructors (except for the default
constructor) throw \fIException\fP exceptions on failure\&.
.PP 
.SH "INHERITS FROM"
\-
.PP 
.SH "TYPE"

.PP 
The class \fBBigInt\fP defines the type \fIWord\fP, which is equal to the type
\fIBN_ULONG\fP used by \fIOpenSSL\fP to store integral values of unlimited
precision\&. A \fIWord\fP is an \fIunsigned long\fP, which is, depending on the
architecture, usually 64 or 32 bits long\&. 
.PP 
.SH "ENUMERATIONS"
\fBMsb\fP
.br 
This (most significant bit) enumeration is used when generating a
cryptographically strong random number\&. Its values are:
.IP o 
\fBMSB_UNKNOWN\fP:
.br 
The most significant bit may be 0 or 1\&.
.IP o 
\fBMSB_IS_ONE\fP:
.br 
The most significant bit is guaranteed to be 1\&.
.IP o 
\fBTOP_TWO_BITS_ONE\fP:
.br 
The two most significant bits are guaranteed to be 1, resulting in a
product of two values each containing \fInBits\fP having \fI2 * nBits\fP
bits\&.

.PP 
\fBLsb\fP
.br 
This (least significant bit) enumeration is used when generating random
numbers, ensuring that the resulting value is either odd or even\&.
.IP o 
\fBEVEN\fP:
.br 
The random value will be an even value;
.IP o 
\fBODD\fP:
.br 
The random value will be an odd value\&.

.PP 
.SH "CONSTRUCTORS"

.PP 
.IP o 
\fBBigInt()\fP:
.br 
The default constructor initializes a \fIBigInt\fP value to 0\&.
.IP o 
\fBexplicit BigInt(BIGNUM const &value)\fP:
.br 
This constructor initializes a \fIBigInt\fP from a \fIconst BIGNUM\fP\&. 
.IP o 
\fBexplicit BigInt(BIGNUM const *value)\fP:
.br 
This constructor initializes a \fIBigInt\fP from a pointer to a 
\fIconst BIGNUM\fP\&.
.IP o 
\fBBigInt(Type value)\fP:
.br 
This constructor is defined as a member template\&. Any type that can be
converted using a static cast to an \fIunsigned long\fP can be used as argument
to this constructor\&. Promotion is allowed, so in many situations where
\fIBigInt\fPs are expected a plain numerical value can be used as well\&.
.IP o 
\fBBigInt(char const *bigEndian, size_t length, bool negative = false)\fP:
.br 
This constructor initializes a \fIBigInt\fP from \fIlength\fP
big\-endian encoded bytes stored in \fIbigEndian\fP\&. This constructor interprets
the \fIchar\fP values pointed at by \fIbigEndian\fP as unsigned values\&. Use this
constructor to reconstruct a \fIBigInt\fP object from the data made available by
the \fIbigEndian\fP member\&. If the number represents a negative value, then
provide a third argument \fItrue\fP\&.
.IP o 
\fBexplicit BigInt(std::string const &bigEndian, bool negative = false)\fP:
.br 
This constructor initializes a \fIBigInt\fP from the bytes stored in
\fIbigEndian\fP, which must be big\-endian encoded\&. This constructor interprets
the \fIchar\fP values stored in \fIbigEndian\fP as unsigned values\&. If the number
that is stored in \fIbigEndian\fP represents a negative value, then provide a
second argument \fItrue\fP\&.

.PP 
The standard copy constructor is available, the move constructor is not
available\&. 
.PP 
.SH "MEMBER FUNCTIONS"
.IP o 
\fBBigInt &addMod(BigInt const &rhs, BigInt const &mod) \fP:
.br 
\fIRhs\fP is added (modulo \fImod\fP) to the current object\&.
.IP 
.IP o 
\fBBigInt addModc(BigInt const &rhs, BigInt const &mod) \fP:
.br 
The sum (modulo \fImod\fP) of the current object and \fIrhs\fP is returned\&.
.IP 
.IP o 
\fBBigInt::Word at(size_t index) const\fP:
.br 
Returns the \fIWord\fP at \fIindex\fP\&. E\&.g\&., on a 32 bit architecture, if
the \fBBigInt\fP value equals 2, then \fIat(0)\fP returns 0, and
\fIat(1)\fP returns 2\&. If \fIindex\fP equals or exceeds the value returned
by \fInWords\fP an \fIFBB::Exception\fP is thrown\&.
.IP 
.IP o 
\fBBIGNUM const &bignum() const\fP:
.br 
A reference to the \fIBIGNUM\fP value maintained by the current
\fIBigInt\fP object is returned\&.
.IP 
.IP o 
\fBchar *bigEndian() const\fP:
.br 
The value represented by the current object
is stored in a series of \fIchar\fP typed values in big\-endian order\&. If
a value consists of 5 \fIchar\fPs the eight most significant bits will
be stored in the \fIchar\fP having index value 0, the eight least
significant bits will be stored in the \fIchar\fP having index value
4\&. When needed simply swap \fIchar[i]\fP with \fIchar[j]\fP (i = 0
\&.\&. nBytes/2, j = nBytes\-1 \&.\&. nBytes/2) to convert to little\-endian
order\&. The return value consists of a series of \fIsizeInBytes()\fP (see
below) dynamically allocated \fIchar\fP values\&. The caller of
\fIbigEndian\fP owns the allocated memory and should eventually delete
it again using \fIdelete[]\fP\&. Note that the current object\(cq\&s \fIsign\fP
cannot be inferred from the return value\&.
.IP 
.IP o 
\fBBigInt &clearBit(size_t index)\fP:
.br 
The current object\(cq\&s bit at index position \fIindex\fP is cleared\&.
.IP 
.IP o 
\fBBigInt clearBit(size_t index) const\fP:
.br 
A copy of the current object having its bit at index position
\fIindex\fP cleared\&.
.IP 
.IP o 
\fBlong long diophantus(long long *factor1, long long *factor2, 
long long value1, long long value2)\fP:
.br 
The integral solution of \fIfactor1 * value1 + factor2 * value2 = gcd\fP
is computed\&. The function returns the greatest common divisor
(\fIgcd\fP) of \fIvalue1\fP and \fIvalue2\fP, and returns their
multiplication factors in, respectively, \fI*factor1\fP and
\fI*factor2\fP\&. The solution is not unique: another solution is obtained
by adding \fIk * value2\fP to \fIfactor1\fP and subtracting \fIk * value1\fP
from \fIfactor2\fP\&. For values exceeding \fIstd::numeric_limits<long,
long>::max()\fP the next member can be used\&.
.IP 
.IP o 
\fBBigInt diophantus(BigInt *factor1, BigInt *factor2, 
BigInt const &value1, BigInt const &value2)\fP:
.br 
The integral solution of \fIfactor1 * value1 + factor2 * value2 = gcd\fP
is computed\&. The function returns the greatest common divisor
(\fIgcd\fP) of \fIvalue1\fP and \fIvalue2\fP, and returns their
multiplication factors in, respectively, \fI*factor1\fP and
\fI*factor2\fP\&. The solution is not unique: another solution is obtained
by adding \fIk * value2\fP to \fIfactor1\fP and subtracting \fIk * value1\fP
from \fIfactor2\fP\&.
.IP 
.IP o 
\fBBigInt &div(BigInt *remainder, BigInt const &rhs)\fP:
.br 
The current object is divided by \fIrhs\fP\&. The division\(cq\&s remainder
is returned in \fI*remainder\fP\&.
.IP 
.IP o 
\fBBigInt divc(BigInt *remainder, BigInt const &rhs) const\fP:
.br 
The quotient of the current object and \fIrhs\fP is returned\&. The
division\(cq\&s remainder is returned in \fI*remainder\fP\&.
.IP 
.IP o 
\fBint compare(BigInt const &rsh) const\fP:
.br 
Using signed values, if the current object is smaller than \fIrhs\fP \-1
is returned; if they are equal 0 is returned; if the current object is
larger than \fIths\fP 1 is returned (see also \fIuCompare\fP)\&. 
.IP 
.IP o 
\fBBigInt &exp(BigInt const &exponent)\fP:
.br 
The current object is raised to the power \fIexponent\fP\&.
.IP 
.IP o 
\fBBigInt expc(BigInt const &exponent) const\fP:
.br 
The current object raised to the power \fIexponent\fP is returned\&.
.IP 
.IP o 
\fBBigInt &expMod(BigInt const &exponent, BigInt const &mod)\fP:
.br 
The current object is raised to the power \fIexponent\fP modulo \fImod\fP\&.
.IP 
.IP o 
\fBBigInt expModc(BigInt const &exponent, BigInt const &mod) const\fP:
.br 
The current object raised to the power \fIexponent\fP modulo \fImod\fP is
returned\&.
.IP 
.IP o 
\fBBigInt &gcd(BigInt const &rhs)\fP:
.br 
The greatest common divisor (gcd) of the current object and \fIrhs\fP is
assigned to the current object\&. To compute the least common multiple
(lcm) the following relationship can be used:
.nf 

    lcm(a, b) = a * b / a\&.gcd(b)
        
.fi 

.IP 
.IP o 
\fBBigInt gcdc(BigInt const &rhs) const\fP:
.br 
The greatest common divisor (gcd) of the current object and \fIrhs\fP is
returned\&. To compute the least common multiple (lcm) the following
relationship can be used: 
.nf 

    lcm(a, b) = a * b / a\&.gcd(b)
        
.fi 

.IP 
.IP o 
\fBbool hasBit(size_t index)\fP:
.br 
\fITrue\fP is returned if the bit at index position \fIindex\fP has been
set, \fIfalse\fP otherwise\&.
.IP 
.IP o 
\fBBigInt &inverseMod(BigInt const &mod)\fP:
.br 
The inverse of the current object modulo \fImod\fP is assigned to the
current object\&. This is the value \fIret\fP for which the following
expression holds true:
.nf 
 
        (*this * ret) % mod = 1 
       
.fi 

.IP 
.IP o 
\fBBigInt inverseModc(BigInt const &mod) const\fP:
.br 
This  inverse of the current object modulo \fImod\fP is returned\&.
.IP 
.IP o 
\fBbool isNegative() const\fP:
.br 
Returns \fItrue\fP if the current object contains a negative value\&.
.IP 
.IP o 
\fBbool isOdd() const\fP:
.br 
Returns \fItrue\fP if the current object is an odd value\&.
.IP 
.IP o 
\fBbool isOne() const\fP:
.br 
Returns \fItrue\fP if the current object equals one (1)\&.
.IP 
.IP o 
\fBBigInt &isqrt()\fP:
.br 
The current object\(cq\&s integer square root value is assigned to the
current object\&. The integer square root of a value \fIx\fP is the
biggest integral value whose square does not exceed \fIx\fP\&. E\&.g\&.,
\fIisqrt(17) == 4\fP\&. An \fIException\fP exception is thrown if the current
object\(cq\&s value is smaller than one\&.
.IP 
.IP o 
\fBBigInt isqrtc() const\fP:
.br 
The integer square root of the current object is returned\&. An
\fIException\fP exception is thrown if the current object\(cq\&s value is smaller
than one\&.  
.IP 
.IP o 
\fBbool isZero() const\fP:
.br 
Returns \fItrue\fP if the current object equals zero (0)\&.
.IP 
.IP o 
\fBBigInt &lshift()\fP:
.br 
The current object\(cq\&s bits are shifted one bit to the left\&. The object\(cq\&s
sign remains unaltered\&.
.IP 
.IP o 
\fBBigInt lshiftc()\fP:
.br 
The current object\(cq\&s bits shifted one bit to the left are returned\&. The
object\(cq\&s sign will be equal to the current object\(cq\&s sign\&.
.IP 
.IP o 
\fBBigInt &lshift(size_t nBits)\fP:
.br 
The current object\(cq\&s bits are shifted \fInBits\fP to the left\&. The
object\(cq\&s sign remains unaltered\&.
.IP 
.IP o 
\fBBigInt lshiftc(size_t nBits) const\fP:
.br 
The current object\(cq\&s bits shifted \fInBits\fP bit to the left are
returned\&. The object\(cq\&s sign will be equal to the current object\(cq\&s
sign\&.
.IP 
.IP o 
\fBBigInt &maskBits(size_t lowerNBits)\fP:
.br 
The  current object\(cq\&s \fIlowerNBits\fP lower bits are kept, its
higher order bits are cleared\&. The object\(cq\&s sign is not affected\&.
.IP 
.IP o 
\fBBigInt maskBitsc(size_t lowerNBits) const\fP:
.br 
A copy of the current object is returned having all but its
\fIlowerNBits\fP lower bits cleared\&. The sign of the returned object
will be equal to the current object\(cq\&s sign\&.
.IP 
.IP o 
\fBsize_t maxWordIndex() const\fP:
.br 
Returns the maximum \fIWord\fP\-index that can be used with the \fIat\fP
and \fIsetWord\fP members for the current \fBBigInt\fP value\&.
.IP 
.IP o 
\fBBigInt &mulMod(BigInt const &rhs, BigInt const &mod)\fP:
.br 
The current object is multiplied  (modulo \fImod\fP) by \fIrhs\fP\&.
.IP 
.IP o 
\fBBigInt mulModc(BigInt const &rhs, BigInt const &mod) const\fP:
.br 
The current object multiplied (modulo \fImod\fP) by \fIrhs\fP is returned\&.
.IP 
.IP o 
\fBBigInt &negate()\fP:
.br 
The current object\(cq\&s value is negated (i\&.e\&., the value changes its
sign)\&.
.IP 
.IP o 
\fBBigInt negatec() const\fP:
.br 
The  negated value of the current object is returned\&.
.IP 
.IP o 
\fBBigInt &rshift()\fP:
.br 
The current object\(cq\&s bits are shifted one bit to the right\&. The object\(cq\&s
sign remains unaltered\&.
.IP 
.IP o 
\fBBigInt rshiftc()\fP:
.br 
The current object\(cq\&s bits shifted one bit to the right are returned\&. The
object\(cq\&s sign will be equal to the current object\(cq\&s sign\&.
.IP 
.IP o 
\fBBigInt &rshift(size_t nBits)\fP:
.br 
The current object\(cq\&s bits are shifted \fInBits\fP to the right\&. The
object\(cq\&s sign remains unaltered\&.
.IP 
.IP o 
\fBBigInt rshiftc(size_t nBits) const\fP:
.br 
The current object\(cq\&s bits shifted \fInBits\fP bit to the right are
returned\&. The object\(cq\&s sign will be equal to the current object\(cq\&s
sign\&.
.IP 
.IP o 
\fBBigInt &setBit(size_t index)\fP:
.br 
The bit at index position \fIindex\fP is set\&. 
.IP 
.IP o 
\fBBigInt setBitc(size_t index) const\fP:
.br 
A copy of the current object is returned having its bit at index
position \fIindex\fP set\&.
.IP 
.IP o 
\fBBigInt &setBit(size_t index, bool value)\fP:
.br 
The bit at index position \fIindex\fP is set to \fIvalue\fP\&.
.IP 
.IP o 
\fBBigInt setBitc(size_t index, bool value) const\fP:
.br 
A copy of the current object is returned having its bit at index
position \fIindex\fP set to \fIvalue\fP\&.
.IP 
.IP o 
\fBBigInt &setNegative(bool negative)\fP:
.br 
The current object\(cq\&s sign will be set to negative if the function\(cq\&s
argument is \fItrue\fP, it will be set to positive if the function\(cq\&s
argument is \fIfalse\fP\&.
.IP 
.IP o 
\fBBigInt setNegativec(bool negative) const\fP:
.br 
A copy of the current object is return having a negative sign if the
function\(cq\&s argument is \fItrue\fP and a positive sign if the function\(cq\&s
argument is \fIfalse\fP\&.
.IP 
.IP o 
\fBvoid setWord(size_t index, BigInt::Word value)\fP:
.br 
Assigns \fIvalue\fP to the \fIWord\fP at \fIindex\fP\&. E\&.g\&., on a 32 bit
architecture, if the \fBBigInt\fP value equals 2, then
after \fIsetWord(1, 1)\fP the value has become 2\&. If \fIindex\fP
exceeds the value returned by \fInWords\fP an \fIFBB::Exception\fP is
thrown\&.
.IP 
.IP o 
\fBsize_t size() const\fP:
.br 
The number of bytes required to store the current \fIBIGNUM\fP value is
returned\&. 
.IP 
.IP o 
\fBsize_t sizeInBits() const\fP:
.br 
The number of bits required to represent the current \fIBIGNUM\fP value
is returned\&. 
.IP 
.IP o 
\fBsize_t sizeInBytes() const\fP:
.br 
The number of bytes required to store the current \fIBIGNUM\fP value is
returned (returns the same value as the \fIsize\fP memeber does)\&.
.IP 
.IP o 
\fBsize_t constexpr sizeOfWord() const\fP:
.br 
\fBBigInt\fP values are stored in units of `words\(cq\&, which are unsigned
long values\&. These values may consist of, e\&.g\&., 32 or 64 bits\&. The
number of bytes occupied by a `word\(cq\& is returned: 4 for a 32 bit
value, 8 for a 64 bit value, and possibly other values, depending on
specific architecture peculiarities\&. The value returned by this
member, therefore, is architecture dependent\&.
.IP 
.IP o 
\fBBigInt &sqr()\fP:
.br 
The current object\(cq\&s value is squared\&.
.IP 
.IP o 
\fBBigInt sqrc() const\fP:
.br 
The square of the current object is returned\&.
.IP 
.IP o 
\fBBigInt &sqrMod(BigInt const &mod) const\fP:
.br 
The current object\(cq\&s value is squared modulo \fImod\fP\&.
.IP 
.IP o 
\fBBigInt sqrModc(BigInt const &mod) const\fP:
.br 
The square (modulo \fImod\fP) of the current object is returned\&.
.IP 
.IP o 
\fBBigInt &subMod(BigInt const &rhs, BigInt const &mod)\fP:
.br 
\fIRhs\fP is subtracted modulo \fImod\fP from the current object\&.
.IP 
.IP o 
\fBBigInt subModc(BigInt const &rhs, BigInt const &mod) const\fP:
.br 
The difference (modulo \fImod\fP) of the current object and \fIrhs\fP is
returned\&.
.IP 
.IP o 
\fBvoid swap(BigInt &other)\fP:
.br 
The current object swaps its value with \fIother\fP\&.
.IP 
.IP o 
\fBBigInt &tildeBits()\fP:
.br 
All the bits in
the bytes of the current object and the sign of the current object
are toggled\&.
So, after
.nf 

        Bigint b(5);
        b\&.tildeBits();
            
.fi 
\fIb\fP contains the value \-250\&. Also see the discussion with
\fIoperator~()\fP below\&.
.IP 
.IP o 
\fBBigInt tildeBitsc() const\fP:
.br 
A copy of the current object whose bits are toggled is returned\&.
.IP 
.IP o 
\fBBigInt &tildeInt()\fP:
.br 
The `tilde\(cq\& operation is performed on the current object using the
standard \fIint\fP semantics\&. E\&.g\&., ~5 results in \-6\&.  Also see the
discussion with \fIoperator~()\fP below\&.
.IP 
.IP o 
\fBBigInt tildeIntc() const\fP:
.br 
A copy of the current object is returned to which the `tilde\(cq\& operation
has been performed using the standard \fIint\fP semantics\&.
.IP 
.IP o 
\fBunsigned long ulong() const\fP:
.br 
The absolute value stored in the current object is returned as an
unsigned long\&. If it cannot be represented by an unsigned long it
returns \fI0xffffffffL\fP\&.
.IP 
.IP o 
\fBint uCompare(BigInt const &rsh) const\fP:
.br 
Using absolute values, if the current object is smaller than \fIrhs\fP \-1
is returned; if they are equal 0 is returned; if the current object is
larger than \fIths\fP 1 is returned (see also \fIuCompare\fP)\&.

.PP 
.SH "OVERLOADED OPERATORS"

.PP 
Except for some operators all operators perform their intuitive
operations\&. Where that isn\(cq\&t completely true an explanatory remark is
provided\&. E\&.g\&., \fIoperator*()\fP multiplies two \fIBigInt\fPs, possibly promoting
one of the operands; \fIoperator*=()\fP multiplies the lhs by the rhs
\fIBigInt\fP, possibly promoting the rhs operand\&.
.PP 
Here are the available operators:
.PP 
\fBUnary operators:\fP
.PP 
.IP o 
\fBbool operator bool() const\fP:
.br 
Returns \fItrue\fP if the \fIBigInt\fP value is unequal zero, otherwise
\fIfalse\fP is returned\&.
.IP 
.IP o 
\fBBigInt &operator++()\fP:
.br 
.IP o 
\fBBigInt operator++(int)\fP:
.br 
.IP o 
\fBBigInt &operator\-\-()\fP:
.br 
.IP o 
\fBBigInt operator\-\-(int)\fP:
.br 
.IP o 
\fBBigInt operator\-()\fP:
.br 
.IP o 
\fBint operator[](size_t idx) const\fP:
.br 
With \fIBigInt\fP objects it returns the bit\-value of the object\(cq\&s
\fIidx\fPth bit as the value 0 or 1\&.
.IP 
.IP o 
\fBBigInt::Bit operator[](size_t idx)\fP:
.br 
With non\-const \fIBigInt\fP objects it returns a reference to the
bit\-value of the object\(cq\&s \fIidx\fPth bit\&. When used as \fIlvalue\fP
assigning a 0 or non\-zero value to the operator\(cq\&s return value will
either clear or set the bit\&.  Likewise, the following arithmetic
assignment operators may be used: binary or (\fI|=\fP), binary and
(\fI&=\fP) or binary xor (\fI^=\fP)\&. When used as \fIrvalue\fP the value of
the object\(cq\&s \fIidx\fPth bit is returned as a \fIbool\fP value\&. When
inseerted into a \fIstd::ostream\fP the bit\(cq\&s value is displayed as 0 or
1\&. 
.IP 
.IP o 
\fBBigInt operator~()\fP:
.br 
This operator is \fInot\fP implemented as it cannot be implemented so
that it matches the actions of this operator when applied to \fIint\fP
type values\&.
.IP 
When used on \fIint\fP values this operator toggles all the \fIint\fP\(cq\&s
bits\&. E\&.g\&., ~5 represents \-6, and ~\-6 again equals five\&. The \-6 is the
result of the sign bit of \fIint\fP values\&. The obvious implementation
of \fIBigInt::operator~()\fP is to toggle all the value\(cq\&s bits and to
toggle its sign bit\&. For 5 this would result in \-250: 5, being 101
(binary), fits in one byte, so ~5 becomes 11111010 (binary), which is
250\&. Its sign must be reversed as well, so it becomes \-250\&.  This
clearly differs from the value represented by the \fIint\fP constant ~5:
when constructing \fIBigInt(~5)\fP, the value \-6 is obtained\&.
.IP 
It is possible to change the implementation\&. E\&.g\&., after
.nf 

        Bigint b(5);
        b = ~b;
            
.fi 
\fI~b\fP could be implemented so that it results in the value \-6\&. But
this too leads to unexpected results\&. While \fI5 & ~5 == 0\fP, this
would no longer hold true for \fIBigInt\fP objects: Assuming \fIb\fP
contains 5 then \fIb & ~b\fP would expand to (binary) \fI101 &
(negative)110\fP which equals (binary) 100\&.
.IP 
Since either implementation produces unexpected results
\fIBigInt::operator~()\fP was not implemented\&. Instead two members are
offered: \fItildeBits()\fP, toggling all the bits of all the
\fIBigInt\fP bytes and toggling its sign (so
.nf 

        Bigint b(5);
        b\&.tildeBits();
            
.fi 
changes \fIb\fP\(cq\&s value into \-250), and \fItildeInt()\fP changing the
object\(cq\&s value into the value that would have been obtained if a
\fIBigInt\fP was a mere \fIint\fP (so    
.nf 

        Bigint b(5);
        b\&.tildeInt();
            
.fi 
changes \fIb\fP\(cq\&s value into \-6)\&.

.PP 
\fBBinary operators:\fP
.PP 
.IP o 
\fBBigInt operator*(BigInt const &lhs, BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt operator/(BigInt const &lhs, BigInt const &rhs)\fP:
.br 
This operator returns the quotient of the \fIlhs\fP object divided by the
\fIrhs\fP object\&. The remainder is lost (The member \fIdiv\fP performs the
division and makes the remainder available as well)\&.
.IP o 
\fBBigInt operator%(BigInt const &lhs, BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt operator+(BigInt const &lhs, BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt operator\-(BigInt const &lhs, BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt operator<<(BigInt const &lhs, size_t nBits)\fP:
.br 
See also the \fIlshift\fP members\&. If \fIlhs\fP is positive, 
.IP o 
\fBBigInt operator>>=(BigInt const &lhs, size_t nBits)\fP:
.br 
See also the \fIrshift\fP members\&.
.IP o 
\fBBigInt operator&(BigInt const &lhs, BigInt const &rhs)\fP:
.br 
This operator returns a \fIBigInt\fP value consisting of the
\fIbit_and\fP\-ed bits and sign flags of lhs and rhs
operands\&. Consequently, if one operand is positive, the resulting
value will be positive\&. 
.IP o 
\fBBigInt operator|(BigInt const &lhs, BigInt const &rhs)\fP:
.br 
This operator returns a \fIBigInt\fP value consisting of the
\fIbit_or\fP\-ed bits and sign flags of lhs and rhs
operands\&. Consequently, if either operand is negative, the result will
be negative\&. 
.IP o 
\fBBigInt operator^(BigInt const &lhs, BigInt const &rhs)\fP:
.br 
This operator returns a \fIBigInt\fP value consisting of the
\fIbit_xor\fP\-ed bits and sign flags of lhs and rhs
operands\&. Consequently, if exactly one operand is negative, the result
will be negative\&. 

.PP 
\fB(Arithmetic) assignment operator(s):\fP
.PP 
.IP o 
\fBBigInt &operator=(BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt &operator*=(BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt &operator/=(BigInt const &rhs)\fP:
.br 
This operator assigns the result of the (integer) division of the current
\fIBigInt\fP object by \fIths\fP to the current object\&. The remainder is
lost\&. The member \fIdiv\fP divides and makes the remainder available as
well\&.
.IP o 
\fBBigInt &operator%=(BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt &operator+=(BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt &operator\-=(BigInt const &rhs)\fP:
.br 
.IP o 
\fBBigInt &operator<<=(size_t nBits)\fP:
.br 
See also the \fIlshift\fP members\&.
.IP o 
\fBBigInt &operator>>=(size_t nBits)\fP:
.br 
See also the \fIrshift\fP members\&.
.IP o 
\fBBigInt &operator&=(BigInt const &rhs)\fP:
.br 
This operator \fIbit_and\fPs the bits and sign flags of the current
object and the rhs operand\&.
.IP o 
\fBBigInt &operator|=(BigInt const &rhs)\fP:
.br 
This operator \fIbit_or\fPs the bits and sign flags of the current
object and the rhs operand\&.
.IP o 
\fBBigInt &operator^=(BigInt const &rhs)\fP:
.br 
This operator \fIbit_xor\fPs the bits and sign flags of the current
object and the rhs operand\&.

.PP 
Note that the move operator is not available
.PP 
.SH "STATIC MEMBERS"

.PP 
All members returning a \fIBigInt\fP computed from a set of arguments and
not requiring an existing \fIBigInt\fP object are defined as static members\&.
.PP 
.IP o 
\fBBigInt fromText(std::string text, int mode = 0)\fP:
.br 
This member converts a textual representation of a number to a
\fIBigInt\fP value\&. Conversion continues until the end of \fItext\fP or
until a character outside of an expected range is encountered\&.  
.IP 
The expected range may be preset by specifying \fImode\fP as \fIios::dec,
ios::oct,\fP or \fIios::hex\fP or (the default) the expected range is
determined by \fIfromText\fP itself by inspecting the characters in
\fItext\fP\&.
.IP 
By default if \fItext\fP contains hexadecimal characters then
\fIfromText\fP assumes that the number is represented as a hexadecimal
value (e\&.g\&., \fI\(dq\&abc\(dq\&\fP is converted to the (decimal) value 2748); if
\fItext\fP starts with 0 and contains only characters in the range 0
until (including) 7 then \fIfromText\fP assumes the number is
represented as an octal value (e\&.g\&., \fI\(dq\&01234\(dq\&\fP is converted to the
(decimal) value 668)\&. Otherwise a decimal value is assumed\&. 
.IP 
If the text does not represent a valid numerical value (of the
given extraction mode) then a \fIFBB::Exception\fP exception is thrown
(\fIfromText: text does not represent a BigInt value\fP)\&.
.IP 
.IP o 
\fBBigInt rand(size_t size, Msb msb = MSB_IS_ONE, Lsb lsb = ODD)\fP:
.br 
This member returns a cryptographically strong pseudo\-random number
of \fIsize\fP bits\&. The most significant bit(s) can be controlled by
\fImsb\fP (by default \fBMSB_IS_ONE\fP), the least significant bit can be
controlled by \fIlsb\fP (by default \fBODD\fP)\&. Before calling this
member the random number generator must have been seeded\&.
.IP 
From the \fBRAND_add\fP(3ssl) man\-page:
.IP 
OpenSSL makes sure that the PRNG state is unique for each thread\&. On
systems that provide \fI/dev/urandom\fP, the randomness device is used
to seed the PRNG transparently\&. However, on all other systems, the
application is responsible for seeding the PRNG by calling
\fBRAND_add\fP(3ssl), \fBRAND_egd\fP(3ssl), \fBRAND_load_file\fP(3ssl), or
\fBRAND_seed\fP(3ssl)\&.
.IP 
.IP o 
\fBBigInt randRange(BigInt const &max)\fP:
.br 
This member returns a cryptographically strong pseudo\-random
number in the range \fI0 <= number < max\fP\&. Before calling this
member the random number generator must have been seeded (see also
\fBrand\fP, described above)\&.
.IP 
.IP o 
\fBBigInt setBigEndian(std::string const &bytes)\fP:
.br 
The \fIbytes\&.length()\fP bytes of \fIbytes\fP are used to compute a
\fIBigInt\fP object which is returned by this function\&. The characters
in \fIbytes\fP are interpreted as a series of bytes in big\-endian
order\&. See also the member function \fIbigEndian()\fP above\&. The
returned \fIBigInt\fP has a positive value\&.
.IP 
.IP o 
\fBBigInt prime(size_t nBits, 
BigInt const *mod = 0, BigInt const *rem = 0,
PrimeType primeType = ANY)\fP:
.br 
This member returns a prime number of \fIbBits\fP bits\&. If both \fImod\fP
and \fIrem\fP are non\-zero, the condition prime % mod == rem\&.
(E\&.g\&., use \fIprime % mod == 1\fP in order to suit a given
generator)\&. The parameter \fIprimeType\fP can be \fIANY\fP, \fI(prime \- 1)
/ 2\fP may or may not be a prime\&. If it is \fISAFE\fP then  \fI(prime \- 1)
/ 2\fP will be a (so\-called \fIsafe\fP) prime\&.
.IP 
.IP o 
\fBBigInt pseudoRand(size_t size, Msb msb = MSB_IS_ONE, Lsb lsb =
ODD)\fP:
.br 
This member returns a potentially predictable pseudo\-random number of
\fIsize\fP bits\&. The most significant bit(s) can be controlled by
\fImsb\fP (by default \fBMSB_IS_ONE\fP), the least significant bit can be
controlled by \fIlsb\fP (by default \fBODD\fP)\&. It can be used for
non\-cryptographic purposes and for certain purposes in cryptographic
protocols, but usually not for key generation\&.
.IP 
.IP o 
\fBBigInt pseudoRandRange(BigInt const &max)\fP:
.br 
This member returns a potentially predictable  pseudo\-random
number in the range \fI0 <= number < max\fP\&.

.PP 
.SH "FREE FUNCTIONS IN THE FBB NAMESPACE"

.PP 
.IP o 
\fBstd::ostream &operator<<(ostream &out, BigInt const &value)\fP:
.br 
Inserts \fIvalue\fP into the provided \fIostream\fP\&. If the \fIhex\fP
manipulator has been inserted into the stream before inserting the \fIBigInt\fP
value the value will be displayed as a hexadecimal value (without a leading
\fI0x\fP); if the \fIoct\fP manipulator has been inserted the value will be
represented as an octal value (starting with a 0)\&. The value will be
displayed as a decimal value if the \fIdec\fP manipulator is active\&. If the
\fIBigInt\fP value is negative its value will be preceded by a minus
character\&. 
.IP o 
\fBstd::istream &operator>>(istream &in, BigInt &value)\fP:
.br 
Extracts \fIvalue\fP from the provided \fIistream\fP\&. Depending on the
currently set extraction mode (\fIdec, oct,\fP or \fIhex\fP) the matching
set of characters will be extracted from \fIin\fP and converted to a
number which is stored in \fIvalue\fP\&. Extraction stops at EOF or at the
first character outside of the range of characters matching the
extraction mode\&. if no numerical characters were extracted the
stream\(cq\&s \fIfailbit\fP is set\&. The extracted value may be preceded
by a minus character, resulting in an extracted negative value\&.

.PP 
.SH "EXAMPLE"
.nf 

#include <iostream>
#include <bobcat/bigint>

using namespace std;
using namespace FBB;

int main()
{
    BigInt value(BigInt::prime(100));
    BigInt mod(BigInt::rand(50));
    BigInt inverse(value\&.inverseModc(mod));

    cout << \(cq\&(\(cq\& << value << \(dq\& * \(dq\& << inverse << \(dq\&) % \(dq\& << mod << \(dq\& = \(dq\& <<
             (    value       *      inverse     ) %      mod << endl;
}
        
.fi 

.PP 
.SH "FILES"
\fIbobcat/bigint\fP \- defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7), \fBdiffiehellman\fP(3bobcat), 
\fBRAND_add\fP(3ssl), \fBRAND_egd\fP(3ssl),
\fBRAND_load_file\fP(3ssl), \fBRAND_seed\fP(3)\&.
.PP 
.SH "BUGS"

.PP 
Sep/Oct 2013: due to a change in library handling by the linker
(cf\&. http://fedoraproject\&.org/wiki/UnderstandingDSOLinkChange and
https://wiki\&.debian\&.org/ToolChain/DSOLinking) libraries that are
indirectly required are no longer automatically linked to your program\&. With
\fBBigInt\fP this is \fIlibcrypto\fP, which requires programs to link to both
\fIbobcat\fP and \fIcrypto\fP\&.
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_3\&.23\&.01\-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_3\&.23\&.01\-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1\-dev_3\&.23\&.01\-x_*\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\(cq\&s Own Base Classes And Templates\(cq\&\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
GNU General Public License (GPL)\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 
